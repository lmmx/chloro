COMPARISON DIFF
============================================================

Original size: 16579 bytes
Chloro size:   14586 bytes
Rustfmt size:  16579 bytes

✗ Outputs DIFFER

@@ -2,67 +2,90 @@
 //! Difftastic format implementation for displaying structural diffs.
 //!
 //! This module provides support for parsing difftastic JSON output and
 //! converting it into sections that can be navigated and edited in asterism.
+
 use crate::formats::Format;
-
 use crate::section::{ChunkType, Section};
-
 use ratatui::{
     style::{Color, Style},
     text::{Line, Span},
 };
-
 use serde::{Deserialize, Serialize};
-
 use serde_json::Value;
-
 use std::fmt::Write;
-
 use std::path::Path;
-
 use std::{fs, io};
 
+/// Represents a file in difftastic output
+#[derive(Debug, Serialize, Deserialize)]
 pub struct DifftFile {
+    /// Programming language identified by difftastic for syntax highlighting.
     pub language: String,
+    /// File path relative to the comparison root.
     pub path: String,
+    /// Grouped diff hunks, each containing lines that changed together.
+    #[serde(default)]
     pub chunks: Option<Vec<Vec<DifftLine>>>,
+    /// Change classification: "unchanged", "changed", "created", or "deleted".
     pub status: String,
 }
 
+/// Represents a line in a diff chunk
+#[derive(Debug, Serialize, Deserialize)]
 pub struct DifftLine {
+    /// Left-hand (original) side of the comparison, absent for pure additions.
+    #[serde(skip_serializing_if = "Option::is_none")]
     pub lhs: Option<DifftSide>,
+    /// Right-hand (modified) side of the comparison, absent for pure deletions.
+    #[serde(skip_serializing_if = "Option::is_none")]
     pub rhs: Option<DifftSide>,
 }
 
+/// Represents one side (left or right) of a diff line
+#[derive(Debug, Serialize, Deserialize)]
 pub struct DifftSide {
+    /// Original line position in the source file (1-indexed).
     pub line_number: u32,
+    /// Structural changes within this line, ordered by column position.
     pub changes: Vec<DifftChange>,
 }
 
+/// Represents a change within a line
+#[derive(Debug, Serialize, Deserialize)]
 pub struct DifftChange {
+    /// Column offset where this change begins (0-indexed).
     pub start: u32,
+    /// Column offset where this change ends (exclusive).
     pub end: u32,
+    /// Text content of this change segment.
     pub content: String,
+    /// Syntax category for rendering: "delimiter", "string", "keyword", "comment", "type", "normal"
+    /// or "`tree_sitter_error`".
     pub highlight: String,
 }
 
+/// Difftastic format handler
 pub struct DifftasticFormat;
 
-impl DifftasticFormat {
-    fn file_extension() -> &'static str {
+impl Format for DifftasticFormat {
+    fn file_extension(&self) -> &'static str {
         "diff"
     }
-    fn language() -> tree_sitter::Language {
+
+    fn language(&self) -> tree_sitter::Language {
         // Difftastic doesn't use tree-sitter parsing
         tree_sitter_md::LANGUAGE.into()
     }
-    fn section_query() -> &'static str {
+
+    fn section_query(&self) -> &'static str {
         ""
     }
-    fn title_query() -> &'static str {
+
+    fn title_query(&self) -> &'static str {
         ""
     }
-    fn format_section_display(level: usize, title: &str) -> Line<'static> {
+
+    fn format_section_display(&self, level: usize, title: &str) -> Line<'static> {
         // Check if this is a hunk header with format: (N) @@ -X,Y +A,B @@
         if title.contains("@@") && title.starts_with('(') {
             if let Some(close_paren) = title.find(')') {
@@ -80,21 +103,25 @@
                 return Line::from(spans);
             }
         }
+
         // For file nodes or other sections
         let color = if level == 0 {
             Color::Cyan // Files
         } else {
             Color::LightYellow // Hunks
         };
+
         let spans = vec![
             Span::styled("● ", Style::default().fg(color)),
             Span::raw(title.to_string()),
         ];
+
         Line::from(spans)
     }
 }
 
 impl DifftasticFormat {
+    /// Determine hunk color from the header string itself
     fn determine_hunk_color_from_header(header: &str) -> Color {
         // Parse @@ -X,Y +A,B @@
         if let Some(hunk_part) = header.strip_prefix("@@").and_then(|s| s.split("@@").next()) {
@@ -132,13 +159,21 @@
                 }
             }
         }
-        Color::LightYellow
-        // Modification
+        Color::LightYellow // Modification
     }
 }
 
 #[allow(clippy::too_many_arguments)]
-fn create_chunk_section(file_path: &str, title: String, line_num: i64, column_start: i64, column_end: i64, chunk_type: ChunkType, lhs_text: Option<String>, rhs_text: Option<String>) -> Section {
+fn create_chunk_section(
+    file_path: &str,
+    title: String,
+    line_num: i64,
+    column_start: i64,
+    column_end: i64,
+    chunk_type: ChunkType,
+    lhs_text: Option<String>,
+    rhs_text: Option<String>,
+) -> Section {
     Section {
         title,
         level: 2,
@@ -158,6 +193,13 @@
     }
 }
 
+/// Parse difftastic JSON output into sections
+///
+/// Files become non-navigable containers, hunks become navigable sections.
+///
+/// # Errors
+///
+/// Returns an error if JSON parsing fails or if the format is invalid.
 pub fn parse_difftastic_json(json_str: &str) -> io::Result<Vec<Section>> {
     let files: Vec<DifftFile> = if let Ok(files) = serde_json::from_str::<Vec<DifftFile>>(json_str)
     {
@@ -184,8 +226,10 @@
             })
             .collect::<Result<Vec<DifftFile>, io::Error>>()?
     };
+
     let mut sections = Vec::new();
     let mut global_line = 0i64;
+
     for file in &files {
         // Skip unchanged files
         if file.status == "unchanged" {
@@ -281,9 +325,11 @@
             global_line += i64::try_from(line_count).unwrap_or(0) + 1;
         }
     }
+
     Ok(sections)
 }
 
+/// Format a change as a proper git diff hunk header
 fn format_hunk_header(change: &DifftLine, hunk_num: usize) -> String {
     let (lhs_line, rhs_line) = match (&change.lhs, &change.rhs) {
         (Some(lhs), Some(rhs)) => (lhs.line_number, rhs.line_number),
@@ -291,14 +337,18 @@
         (None, Some(rhs)) => (0, rhs.line_number),
         _ => (0, 0),
     };
+
     // Determine chunk size (for now, single line changes)
     let lhs_count = i32::from(change.lhs.is_some());
     let rhs_count = i32::from(change.rhs.is_some());
+
     format!("({hunk_num}) @@ -{lhs_line},{lhs_count} +{rhs_line},{rhs_count} @@")
 }
 
+/// Format a single change for display
 fn format_change_content(change: &DifftLine) -> String {
     let mut output = String::new();
+
     match (&change.lhs, &change.rhs) {
         (Some(lhs), Some(rhs)) => {
             // Modified line - show both sides
@@ -334,6 +384,7 @@
             output.push_str(" \n");
         }
     }
+
     output
 }
 
@@ -350,26 +401,36 @@
 
 fn extract_column_range(side: &Value) -> (i64, i64) {
     let changes = side.get("changes").and_then(|c| c.as_array());
+
     let start = changes
         .and_then(|arr| arr.first())
         .and_then(|first| first.get("start"))
         .and_then(serde_json::Value::as_i64)
         .unwrap_or(0);
+
     let end = changes
         .and_then(|arr| arr.last())
         .and_then(|last| last.get("end"))
         .and_then(serde_json::Value::as_i64)
         .unwrap_or(0);
+
     (start, end)
 }
 
+/// Extract the difftastic hunks as sections (same as sections in a markdown etc)
+///
+/// # Errors
+///
+/// Returns an error if the JSON file cannot be read from disk.
 pub fn extract_difftastic_sections(json_path: &Path) -> io::Result<Vec<Section>> {
     let content = fs::read_to_string(json_path)?;
     let lines: Vec<Value> = content
         .lines()
         .filter_map(|line| serde_json::from_str(line).ok())
         .collect();
+
     let mut sections = Vec::new();
+
     for value in lines {
         let file_path = value
             .get("path")
@@ -419,6 +480,7 @@
             }
         }
     }
+
     Ok(sections)
 }
 
