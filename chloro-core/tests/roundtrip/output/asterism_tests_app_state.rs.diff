COMPARISON DIFF
============================================================

Original size: 12822 bytes
Chloro size:   12787 bytes
Rustfmt size:  12822 bytes

âœ— Outputs DIFFER

@@ -1,11 +1,7 @@
 use super::AppState;
-
 use crate::section::Section;
-
 use std::fs;
-
 use std::io::Write;
-
 use tempfile::NamedTempFile;
 
 #[test]
@@ -14,6 +10,7 @@
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# Hello\n\n?\n\n## World\n\n??").unwrap();
     let path = file.path().to_path_buf();
+
     // Create sections matching the file
     let sections = vec![
         Section {
@@ -51,23 +48,31 @@
             rhs_content: None,
         },
     ];
+
     let mut app = AppState::new(vec![path.clone()], sections, 100);
+
     // Find first navigable node (should be first section)
     if let Some(first) = app.navigate_to_first() {
         app.current_node_index = first;
     }
+
     // Enter detail view for first section
     app.enter_detail_view();
+
     // Simulate editing: replace "?" with "Yeah"
     if let Some(ref mut editor_state) = app.editor_state {
         editor_state.lines = edtui::Lines::from("\nYeah\n");
     }
+
     // Save
     app.save_current().unwrap();
+
     // Verify file content
     let content = fs::read_to_string(&path).unwrap();
     let lines: Vec<&str> = content.lines().collect();
+
     println!("{lines:?}");
+
     assert_eq!(
         lines,
         vec!["# Hello", "", "", "Yeah", "", "## World", "", "??"]
@@ -79,6 +84,7 @@
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# Test\n\nOriginal").unwrap();
     let path = file.path().to_path_buf();
+
     let sections = vec![Section {
         title: "Test".to_string(),
         level: 1,
@@ -96,19 +102,26 @@
         lhs_content: None,
         rhs_content: None,
     }];
+
     let mut app = AppState::new(vec![path.clone()], sections, 100);
+
     if let Some(first) = app.navigate_to_first() {
         app.current_node_index = first;
     }
+
     app.enter_detail_view();
+
     // Make an edit
     if let Some(ref mut editor_state) = app.editor_state {
         editor_state.lines = edtui::Lines::from("\nModified\n");
     }
+
     app.save_current().unwrap();
     app.exit_detail_view(true);
+
     // Generate plan
     let plan = app.generate_edit_plan();
+
     assert!(
         !plan.edits.is_empty(),
         "Edit plan should contain the saved edit"
@@ -121,6 +134,7 @@
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# One\n\nA\n\n## Two\n\nB\n\n### Three\n\nC").unwrap();
     let path = file.path().to_path_buf();
+
     let sections = vec![
         Section {
             title: "One".to_string(),
@@ -174,7 +188,9 @@
             rhs_content: None,
         },
     ];
+
     let mut app = AppState::new(vec![path.clone()], sections, 100);
+
     // Find and edit first section
     if let Some(first) = app.navigate_to_first() {
         app.current_node_index = first;
@@ -185,6 +201,7 @@
     }
     app.save_current().unwrap();
     app.exit_detail_view(true);
+
     // Find and edit third section (index 2)
     // After rebuild, need to find the section again
     if let Some(node_idx) = app.tree_nodes.iter().position(|n| {
@@ -198,11 +215,13 @@
     }) {
         app.current_node_index = node_idx;
     }
+
     app.enter_detail_view();
     if let Some(ref mut editor_state) = app.editor_state {
         editor_state.lines = edtui::Lines::from("\nCCC\n");
     }
     app.save_current().unwrap();
+
     // Verify file content
     let content = fs::read_to_string(&path).unwrap();
     assert!(
@@ -221,6 +240,7 @@
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# One\n\nA\n\n## Two\n\nB").unwrap();
     let path = file.path().to_path_buf();
+
     let sections = vec![
         Section {
             title: "One".to_string(),
@@ -257,7 +277,9 @@
             rhs_content: None,
         },
     ];
+
     let app = AppState::new(vec![path], sections, 100);
+
     // Single file mode should only show sections, no file nodes
     assert_eq!(app.tree_nodes.len(), 2);
     assert!(app.tree_nodes[0].navigable);
@@ -268,10 +290,13 @@
 fn test_tree_structure_multi_file() {
     let mut file1 = NamedTempFile::new().unwrap();
     let mut file2 = NamedTempFile::new().unwrap();
+
     writeln!(file1, "# One\n\nA").unwrap();
     writeln!(file2, "# Two\n\nB").unwrap();
+
     let path1 = file1.path().to_path_buf();
     let path2 = file2.path().to_path_buf();
+
     let sections = vec![
         Section {
             title: "One".to_string(),
@@ -308,10 +333,13 @@
             rhs_content: None,
         },
     ];
+
     let app = AppState::new(vec![path1, path2], sections, 100);
+
     // Multi-file mode should show file nodes + sections
     // 2 files + 2 sections = 4 nodes
     assert_eq!(app.tree_nodes.len(), 4);
+
     // File nodes should not be navigable
     let mut file_nodes = 0;
     let mut section_nodes = 0;
@@ -322,6 +350,7 @@
             file_nodes += 1;
         }
     }
+
     assert_eq!(file_nodes, 2, "Should have 2 file nodes");
     assert_eq!(section_nodes, 2, "Should have 2 section nodes");
 }
@@ -331,10 +360,12 @@
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# One\n\nA\n\n## Two\n\nB").unwrap();
     let path = file.path().to_path_buf();
+
     // Create a fake multi-file scenario with one file
     let mut file2 = NamedTempFile::new().unwrap();
     writeln!(file2, "# Three\n\nC").unwrap();
     let path2 = file2.path().to_path_buf();
+
     let sections = vec![
         Section {
             title: "One".to_string(),
@@ -388,17 +419,21 @@
             rhs_content: None,
         },
     ];
+
     let mut app = AppState::new(vec![path, path2], sections, 100);
+
     // Start at first position (should be file node, non-navigable)
     app.current_node_index = 0;
     assert!(
         !app.tree_nodes[0].navigable,
         "First node should be file (non-navigable)"
     );
+
     // Navigate to next - should skip to first section
     if let Some(next) = app.find_next_node() {
         app.current_node_index = next;
     }
+
     assert!(
         app.tree_nodes[app.current_node_index].navigable,
         "Should skip to navigable node"
