COMPARISON DIFF
============================================================

Original size: 3153 bytes
Chloro size:   3043 bytes
Rustfmt size:  3226 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Things for resolving vars in the infer context of the next-trait-solver.
 
 use rustc_type_ir::{
+    TypeFolder, TypeSuperFoldable, TypeVisitableExt,
     data_structures::DelayedMap,
     inherent::{Const as _, Ty as _},
-    TypeFolder, TypeSuperFoldable, TypeVisitableExt,
 };
 
 use crate::next_solver::{Const, DbInterner, ErrorGuaranteed, Region, Ty};
-
 use super::InferCtxt;
 
-///////////////////////////////////////////////////////////////////////////
-// OPPORTUNISTIC VAR RESOLVER
-
 /// The opportunistic resolver can be used at any time. It simply replaces
 /// type/const variables that have been unified with the things they have
 /// been unified with (similar to `shallow_resolve`, but deep). This is
 impl<'a, 'db> OpportunisticVarResolver<'a, 'db> {
     #[inline]
     pub fn new(infcx: &'a InferCtxt<'db>) -> Self {
-        OpportunisticVarResolver {
-            infcx,
-            cache: Default::default(),
-        }
+        OpportunisticVarResolver { infcx, cache: Default::default() }
     }
 }
 
         if !t.has_infer() {
             return t;
         }
-
         if t.is_infer() {
             Ty::new_error(self.interner, ErrorGuaranteed)
         } else {
         if !c.has_infer() {
             return c;
         }
-
         if c.is_ct_infer() {
             Const::new_error(self.interner, ErrorGuaranteed)
         } else {
     }
 
     fn fold_region(&mut self, r: Region<'db>) -> Region<'db> {
-        if r.is_var() {
-            Region::error(self.interner)
-        } else {
-            r
-        }
+        if r.is_var() { Region::error(self.interner) } else { r }
     }
 }