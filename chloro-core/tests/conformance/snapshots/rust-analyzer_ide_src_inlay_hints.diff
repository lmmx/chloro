COMPARISON DIFF
============================================================

Original size: 36233 bytes
Chloro size:   32283 bytes
Rustfmt size:  36233 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use crate::{FileId, navigation_target::TryToNav};
 
 mod adjustment;
+
 mod bind_pat;
+
 mod binding_mode;
+
 mod bounds;
+
 mod chaining;
+
 mod closing_brace;
+
 mod closure_captures;
+
 mod closure_ret;
+
 mod discriminant;
+
 mod extern_block;
+
 mod generic_param;
+
 mod implicit_drop;
+
 mod implicit_static;
+
 mod implied_dyn_trait;
+
 mod lifetime;
+
 mod param_name;
+
 mod ra_fixture;
+
 mod range_exclusive;
 
-// Feature: Inlay Hints
-//
-// rust-analyzer shows additional information inline with the source code.
-// Editors usually render this using read-only virtual text snippets interspersed with code.
-//
-// rust-analyzer by default shows hints for
-//
-// * types of local variables
-// * names of function arguments
-// * names of const generic parameters
-// * types of chained expressions
-//
-// Optionally, one can enable additional hints for
-//
-// * return types of closure expressions
-// * elided lifetimes
-// * compiler inserted reborrows
-// * names of generic type and lifetime parameters
-//
-// Note: inlay hints for function argument names are heuristically omitted to reduce noise and will not appear if
-// any of the
-// [following criteria](https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L92-L99)
-// are met:
-//
-// * the parameter name is a suffix of the function's name
-// * the argument is a qualified constructing or call expression where the qualifier is an ADT
-// * exact argument<->parameter match(ignoring leading underscore) or parameter is a prefix/suffix
-//   of argument with _ splitting it off
-// * the parameter name starts with `ra_fixture`
-// * the parameter name is a
-// [well known name](https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L200)
-// in a unary function
-// * the parameter name is a
-// [single character](https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L201)
-// in a unary function
-//
-// ![Inlay hints](https://user-images.githubusercontent.com/48062697/113020660-b5f98b80-917a-11eb-8d70-3be3fd558cdd.png)
-pub(crate) fn inlay_hints(
-    db: &RootDatabase,
-    file_id: FileId,
-    range_limit: Option<TextRange>,
-    config: &InlayHintsConfig<'_>,
-) -> Vec<InlayHint> {
+pub(crate) fn inlay_hints(db: &RootDatabase, file_id: FileId, range_limit: Option<TextRange>, config: &InlayHintsConfig<'_>) -> Vec<InlayHint> {
     let _p = tracing::info_span!("inlay_hints").entered();
     let sema = Semantics::new(db);
     let file_id = sema
         .unwrap_or_else(|| EditionedFileId::current_edition(db, file_id));
     let file = sema.parse(file_id);
     let file = file.syntax();
-
     let mut acc = Vec::new();
-
     let Some(scope) = sema.scope(file) else {
         return acc;
     };
     let famous_defs = FamousDefs(&sema, scope.krate());
     let display_target = famous_defs.1.to_display_target(sema.db);
-
     let ctx = &mut InlayHintCtx::default();
     let mut hints = |event| {
         if let Some(node) = handle_event(ctx, event) {
     extern_block_parent: Option<ast::ExternBlock>,
 }
 
-pub(crate) fn inlay_hints_resolve(
-    db: &RootDatabase,
-    file_id: FileId,
-    resolve_range: TextRange,
-    hash: u64,
-    config: &InlayHintsConfig<'_>,
-    hasher: impl Fn(&InlayHint) -> u64,
-) -> Option<InlayHint> {
+pub(crate) fn inlay_hints_resolve(db: &RootDatabase, file_id: FileId, resolve_range: TextRange, hash: u64, config: &InlayHintsConfig<'_>, hasher: impl Fn(&InlayHint) -> u64) -> Option<InlayHint> {
     let _p = tracing::info_span!("inlay_hints_resolve").entered();
     let sema = Semantics::new(db);
     let file_id = sema
         .unwrap_or_else(|| EditionedFileId::current_edition(db, file_id));
     let file = sema.parse(file_id);
     let file = file.syntax();
-
     let scope = sema.scope(file)?;
     let famous_defs = FamousDefs(&sema, scope.krate());
     let mut acc = Vec::new();
-
     let display_target = famous_defs.1.to_display_target(sema.db);
-
     let ctx = &mut InlayHintCtx::default();
     let mut hints = |event| {
         if let Some(node) = handle_event(ctx, event) {
             hints(&mut acc, ctx, &famous_defs, config, file_id, display_target, node);
         }
     };
-
     let mut preorder = file.preorder();
     while let Some(event) = preorder.next() {
         // FIXME: This can miss some hints that require the parent of the range to calculate
     }
 }
 
-// FIXME: At some point when our hir infra is fleshed out enough we should flip this and traverse the
-// HIR instead of the syntax tree.
-fn hints(
-    hints: &mut Vec<InlayHint>,
-    ctx: &mut InlayHintCtx,
-    famous_defs @ FamousDefs(sema, _krate): &FamousDefs<'_, '_>,
-    config: &InlayHintsConfig<'_>,
-    file_id: EditionedFileId,
-    display_target: DisplayTarget,
-    node: SyntaxNode,
-) {
+fn hints(hints: &mut Vec<InlayHint>, ctx: &mut InlayHintCtx, famous_defs @ FamousDefs(sema, _krate): &FamousDefs<'_, '_>, config: &InlayHintsConfig<'_>, file_id: EditionedFileId, display_target: DisplayTarget, node: SyntaxNode) {
     closing_brace::hints(
         hints,
         sema,
     if let Some(any_has_generic_args) = ast::AnyHasGenericArgs::cast(node.clone()) {
         generic_param::hints(hints, famous_defs, config, any_has_generic_args);
     }
-
     match_ast! {
         match node {
             ast::Expr(expr) => {
 
     /// This always reports a resolvable location, so only use this when it is very likely for a
     /// location link to actually resolve but where computing `finish` would be costly.
-    fn lazy_location_opt(
-        &self,
-        finish: impl FnOnce() -> Option<FileRange>,
-    ) -> Option<LazyProperty<FileRange>> {
+    fn lazy_location_opt(&self, finish: impl FnOnce() -> Option<FileRange>) -> Option<LazyProperty<FileRange>> {
         if self.fields_to_resolve.resolve_label_location {
             Some(LazyProperty::Lazy)
         } else {
 }
 
 impl InlayHintLabel {
-    pub fn simple(
-        s: impl Into<String>,
-        tooltip: Option<LazyProperty<InlayTooltip>>,
-        linked_location: Option<LazyProperty<FileRange>>,
-    ) -> InlayHintLabel {
+    pub fn simple(s: impl Into<String>, tooltip: Option<LazyProperty<InlayTooltip>>, linked_location: Option<LazyProperty<FileRange>>) -> InlayHintLabel {
         InlayHintLabel {
             parts: smallvec![InlayHintLabelPart { text: s.into(), linked_location, tooltip }],
         }
     fn start_location_link(&mut self, def: ModuleDefId) {
         never!(self.location.is_some(), "location link is already started");
         self.make_new_part();
-
         self.location = Some(if self.resolve {
             LazyProperty::Lazy
         } else {
     }
 }
 
-fn label_of_ty(
-    famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>,
-    config: &InlayHintsConfig<'_>,
-    ty: &hir::Type<'_>,
-    display_target: DisplayTarget,
-) -> Option<InlayHintLabel> {
+fn label_of_ty(famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>, config: &InlayHintsConfig<'_>, ty: &hir::Type<'_>, display_target: DisplayTarget) -> Option<InlayHintLabel> {
     fn rec(
         sema: &Semantics<'_, RootDatabase>,
         famous_defs: &FamousDefs<'_, '_>,
             }
         })
     }
-
     let mut label_builder = InlayHintLabelBuilder {
         sema,
         last_part: String::new(),
 }
 
 /// Checks if the type is an Iterator from std::iter and returns the iterator trait and the item type of the concrete iterator.
-fn hint_iterator<'db>(
-    sema: &Semantics<'db, RootDatabase>,
-    famous_defs: &FamousDefs<'_, 'db>,
-    ty: &hir::Type<'db>,
-) -> Option<(hir::Trait, hir::TypeAlias, hir::Type<'db>)> {
+fn hint_iterator<'db>(sema: &Semantics<'db, RootDatabase>, famous_defs: &FamousDefs<'_, 'db>, ty: &hir::Type<'db>) -> Option<(hir::Trait, hir::TypeAlias, hir::Type<'db>)> {
     let db = sema.db;
     let strukt = ty.strip_references().as_adt()?;
     let krate = strukt.module(db).krate();
     }
     let iter_trait = famous_defs.core_iter_Iterator()?;
     let iter_mod = famous_defs.core_iter()?;
-
     // Assert that this struct comes from `core::iter`.
     if !(strukt.visibility(db) == hir::Visibility::Public
         && strukt.module(db).path_to_root(db).contains(&iter_mod))
     {
         return None;
     }
-
     if ty.impls_trait(db, iter_trait, &[]) {
         let assoc_type_item = iter_trait.items(db).into_iter().find_map(|item| match item {
             hir::AssocItem::TypeAlias(alias) if alias.name(db) == sym::Item => Some(alias),
             return Some((iter_trait, assoc_type_item, ty));
         }
     }
-
     None
 }
 
-fn ty_to_text_edit(
-    sema: &Semantics<'_, RootDatabase>,
-    config: &InlayHintsConfig<'_>,
-    node_for_hint: &SyntaxNode,
-    ty: &hir::Type<'_>,
-    offset_to_insert_ty: TextSize,
-    additional_edits: &dyn Fn(&mut TextEditBuilder),
-    prefix: impl Into<String>,
-) -> Option<LazyProperty<TextEdit>> {
+fn ty_to_text_edit(sema: &Semantics<'_, RootDatabase>, config: &InlayHintsConfig<'_>, node_for_hint: &SyntaxNode, ty: &hir::Type<'_>, offset_to_insert_ty: TextSize, additional_edits: &dyn Fn(&mut TextEditBuilder), prefix: impl Into<String>) -> Option<LazyProperty<TextEdit>> {
     // FIXME: Limit the length and bail out on excess somehow?
     let rendered = sema
         .scope(node_for_hint)
 
 #[cfg(test)]
 mod tests {
-
     use expect_test::Expect;
     use hir::ClosureStyle;
     use ide_db::MiniCore;
     use itertools::Itertools;
     use test_utils::extract_annotations;
-
     use crate::DiscriminantHints;
     use crate::inlay_hints::{AdjustmentHints, AdjustmentHintsMode};
     use crate::{LifetimeElisionHints, fixture, inlay_hints::InlayHintsConfig};
-
     use super::{ClosureReturnTypeHints, GenericParameterHints, InlayFieldsToResolve};
-
-    pub(super) const DISABLED_CONFIG: InlayHintsConfig<'_> = InlayHintsConfig {
-        discriminant_hints: DiscriminantHints::Never,
-        render_colons: false,
-        type_hints: false,
-        parameter_hints: false,
-        sized_bound: false,
-        generic_parameter_hints: GenericParameterHints {
-            type_hints: false,
-            lifetime_hints: false,
-            const_hints: false,
-        },
-        chaining_hints: false,
-        lifetime_elision_hints: LifetimeElisionHints::Never,
-        closure_return_type_hints: ClosureReturnTypeHints::Never,
-        closure_capture_hints: false,
-        adjustment_hints: AdjustmentHints::Never,
-        adjustment_hints_disable_reborrows: false,
-        adjustment_hints_mode: AdjustmentHintsMode::Prefix,
-        adjustment_hints_hide_outside_unsafe: false,
-        binding_mode_hints: false,
-        hide_named_constructor_hints: false,
-        hide_closure_initialization_hints: false,
-        hide_closure_parameter_hints: false,
-        closure_style: ClosureStyle::ImplFn,
-        param_names_for_lifetime_elision_hints: false,
-        max_length: None,
-        closing_brace_hints_min_lines: None,
-        fields_to_resolve: InlayFieldsToResolve::empty(),
-        implicit_drop_hints: false,
-        range_exclusive_hints: false,
-        minicore: MiniCore::default(),
-    };
-    pub(super) const TEST_CONFIG: InlayHintsConfig<'_> = InlayHintsConfig {
-        type_hints: true,
-        parameter_hints: true,
-        chaining_hints: true,
-        closure_return_type_hints: ClosureReturnTypeHints::WithBlock,
-        binding_mode_hints: true,
-        lifetime_elision_hints: LifetimeElisionHints::Always,
-        ..DISABLED_CONFIG
-    };
-
     #[track_caller]
     pub(super) fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(TEST_CONFIG, ra_fixture);
     }
-
     #[track_caller]
-    pub(super) fn check_with_config(
-        config: InlayHintsConfig<'_>,
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-    ) {
+    pub(super) fn check_with_config(config: InlayHintsConfig<'_>, #[rust_analyzer::rust_fixture] ra_fixture: &str) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let mut expected = extract_annotations(&analysis.file_text(file_id).unwrap());
         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
             .sorted_by_key(|(range, _)| range.start())
             .collect::<Vec<_>>();
         expected.sort_by_key(|(range, _)| range.start());
-
         assert_eq!(expected, actual, "\nExpected:\n{expected:#?}\n\nActual:\n{actual:#?}");
     }
-
     #[track_caller]
-    pub(super) fn check_expect(
-        config: InlayHintsConfig<'_>,
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        expect: Expect,
-    ) {
+    pub(super) fn check_expect(config: InlayHintsConfig<'_>, #[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
         let filtered =
             inlay_hints.into_iter().map(|hint| (hint.range, hint.label)).collect::<Vec<_>>();
         expect.assert_debug_eq(&filtered)
     }
-
     /// Computes inlay hints for the fixture, applies all the provided text edits and then runs
     /// expect test.
     #[track_caller]
-    pub(super) fn check_edit(
-        config: InlayHintsConfig<'_>,
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        expect: Expect,
-    ) {
+    pub(super) fn check_edit(config: InlayHintsConfig<'_>, #[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
-
         let edits = inlay_hints
             .into_iter()
             .filter_map(|hint| hint.text_edit?.computed())
                 acc
             })
             .expect("no edit returned");
-
         let mut actual = analysis.file_text(file_id).unwrap().to_string();
         edits.apply(&mut actual);
         expect.assert_eq(&actual);
     }
-
     #[track_caller]
-    pub(super) fn check_no_edit(
-        config: InlayHintsConfig<'_>,
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-    ) {
+    pub(super) fn check_no_edit(config: InlayHintsConfig<'_>, #[rust_analyzer::rust_fixture] ra_fixture: &str) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
-
         let edits: Vec<_> =
             inlay_hints.into_iter().filter_map(|hint| hint.text_edit?.computed()).collect();
-
         assert!(edits.is_empty(), "unexpected edits: {edits:?}");
     }
-
     #[test]
     fn hints_disabled() {
         check_with_config(
 }"#,
         );
     }
-
     #[test]
     fn regression_18840() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_18898() {
         check(
 "#,
         );
     }
-
     #[test]
     fn closure_dependency_cycle_no_panic() {
         check(
         "#,
         );
     }
-
     #[test]
     fn regression_19610() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_20239() {
         check_with_config(