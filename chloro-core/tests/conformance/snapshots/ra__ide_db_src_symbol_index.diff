COMPARISON DIFF
============================================================

Original size: 17943 bytes
Chloro size:   16897 bytes
Rustfmt size:  17943 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     }
 
     /// Specifies whether we want to include associated items in the result.
-    pub fn assoc_search_mode(&mut self, assoc_mode: AssocSearchMode) {
+    pub fn assoc_search_mode(
+        &mut self,
+        assoc_mode: AssocSearchMode,
+    ) {
         self.assoc_mode = assoc_mode;
     }
 
 }
 
 /// The symbol indices of modules that make up a given crate.
-pub fn crate_symbols(db: &dyn HirDatabase, krate: Crate) -> Box<[&SymbolIndex]> {
+pub fn crate_symbols(
+    db: &dyn HirDatabase,
+    krate: Crate,
+) -> Box<[&SymbolIndex]> {
     let _p = tracing::info_span!("crate_symbols").entered();
     krate.modules(db).into_iter().map(|module| SymbolIndex::module_symbols(db, module)).collect()
 }
 
-// Feature: Workspace Symbol
-//
-// Uses fuzzy-search to find types, modules and functions by name across your
-// project and dependencies. This is **the** most useful feature, which improves code
-// navigation tremendously. It mostly works on top of the built-in LSP
-// functionality, however `#` and `*` symbols can be used to narrow down the
-// search. Specifically,
-//
-// - `Foo` searches for `Foo` type in the current workspace
-// - `foo#` searches for `foo` function in the current workspace
-// - `Foo*` searches for `Foo` type among dependencies, including `stdlib`
-// - `foo#*` searches for `foo` function among dependencies
-//
-// That is, `#` switches from "types" to all symbols, `*` switches from the current
-// workspace to dependencies.
-//
-// Note that filtering does not currently work in VSCode due to the editor never
-// sending the special symbols to the language server. Instead, you can configure
-// the filtering via the `rust-analyzer.workspace.symbol.search.scope` and
-// `rust-analyzer.workspace.symbol.search.kind` settings. Symbols prefixed
-// with `__` are hidden from the search results unless configured otherwise.
-//
-// | Editor  | Shortcut |
-// |---------|-----------|
-// | VS Code | <kbd>Ctrl+T</kbd>
-pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {
+pub fn world_symbols(
+    db: &RootDatabase,
+    query: Query,
+) -> Vec<FileSymbol> {
     let _p = tracing::info_span!("world_symbols", query = ?query.query).entered();
-
     let indices: Vec<_> = if query.libs {
         LibraryRoots::get(db)
             .roots(db)
             crates.into_iter().map(|krate| crate_symbols(db, krate.into())).collect();
         indices.iter().flat_map(|indices| indices.iter().cloned()).collect()
     };
-
     let mut res = vec![];
     query.search::<()>(&indices, |f| {
         res.push(f.clone());
 
 impl SymbolIndex {
     /// The symbol index for a given source root within library_roots.
-    pub fn library_symbols(db: &dyn HirDatabase, source_root_id: SourceRootId) -> &SymbolIndex {
+    pub fn library_symbols(
+        db: &dyn HirDatabase,
+        source_root_id: SourceRootId,
+    ) -> &SymbolIndex {
         // FIXME:
         #[salsa::interned]
         struct InternedSourceRootId {
 
     /// The symbol index for a given module. These modules should only be in source roots that
     /// are inside local_roots.
-    pub fn module_symbols(db: &dyn HirDatabase, module: Module) -> &SymbolIndex {
+    pub fn module_symbols(
+        db: &dyn HirDatabase,
+        module: Module,
+    ) -> &SymbolIndex {
         // FIXME:
         #[salsa::interned]
         struct InternedModuleId {
             id: hir::ModuleId,
         }
-
         #[salsa::tracked(returns(ref))]
         fn module_symbols(db: &dyn HirDatabase, module: InternedModuleId<'_>) -> SymbolIndex {
             let _p = tracing::info_span!("module_symbols").entered();
                 ))
             })
         }
-
         module_symbols(db, InternedModuleId::new(db, hir::ModuleId::from(module)))
     }
 }
 
 impl fmt::Debug for SymbolIndex {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("SymbolIndex").field("n_symbols", &self.symbols.len()).finish()
     }
 }
 
 impl PartialEq for SymbolIndex {
-    fn eq(&self, other: &SymbolIndex) -> bool {
+    fn eq(
+        &self,
+        other: &SymbolIndex,
+    ) -> bool {
         self.symbols == other.symbols
     }
 }
 
-impl Eq for SymbolIndex {}
+impl Eq for SymbolIndex {
+}
 
 impl Hash for SymbolIndex {
-    fn hash<H: Hasher>(&self, hasher: &mut H) {
+    fn hash<H: Hasher>(
+        &self,
+        hasher: &mut H,
+    ) {
         self.symbols.hash(hasher)
     }
 }
             let rhs_chars = rhs.name.as_str().chars().map(|c| c.to_ascii_lowercase());
             lhs_chars.cmp(rhs_chars)
         }
-
         symbols.par_sort_by(cmp);
-
         let mut builder = fst::MapBuilder::memory();
-
         let mut last_batch_start = 0;
-
         for idx in 0..symbols.len() {
             if let Some(next_symbol) = symbols.get(idx + 1)
                 && cmp(&symbols[last_batch_start], next_symbol) == Ordering::Equal
 
             builder.insert(key, value).unwrap();
         }
-
         let map = builder
             .into_inner()
             .and_then(|mut buf| {
         self.map.as_fst().size() + self.symbols.len() * size_of::<FileSymbol>()
     }
 
-    fn range_to_map_value(start: usize, end: usize) -> u64 {
+    fn range_to_map_value(
+        start: usize,
+        end: usize,
+    ) -> u64 {
         debug_assert![start <= (u32::MAX as usize)];
         debug_assert![end <= (u32::MAX as usize)];
-
         ((start as u64) << 32) | end as u64
     }
 
         None
     }
 
-    fn matches_assoc_mode(&self, is_trait_assoc_item: bool) -> bool {
+    fn matches_assoc_mode(
+        &self,
+        is_trait_assoc_item: bool,
+    ) -> bool {
         !matches!(
             (is_trait_assoc_item, self.assoc_mode),
             (true, AssocSearchMode::Exclude) | (false, AssocSearchMode::AssocItemsOnly)
 
 #[cfg(test)]
 mod tests {
-
     use expect_test::expect_file;
     use salsa::Setter;
     use test_fixture::{WORKSPACE, WithFixture};
-
     use super::*;
-
     #[test]
     fn test_symbol_index_collection() {
         let (db, _) = RootDatabase::with_many_files(
 pub(self) use crate::Trait as IsThisJustATrait;
 "#,
         );
-
         let symbols: Vec<_> = Crate::from(db.test_crate())
             .modules(&db)
             .into_iter()
                 (module_id, symbols)
             })
             .collect();
-
         expect_file!["./test_data/test_symbol_index_collection.txt"].assert_debug_eq(&symbols);
     }
-
     #[test]
     fn test_doc_alias() {
         let (db, _) = RootDatabase::with_single_file(
 struct Duplicate;
         "#,
         );
-
         let symbols: Vec<_> = Crate::from(db.test_crate())
             .modules(&db)
             .into_iter()
                 (module_id, symbols)
             })
             .collect();
-
         expect_file!["./test_data/test_doc_alias.txt"].assert_debug_eq(&symbols);
     }
-
     #[test]
     fn test_exclude_imports() {
         let (mut db, _) = RootDatabase::with_many_files(
 pub struct Foo;
 "#,
         );
-
         let mut local_roots = FxHashSet::default();
         local_roots.insert(WORKSPACE);
         LocalRoots::get(&db).set_roots(&mut db).to(local_roots);
-
         let mut query = Query::new("Foo".to_owned());
         let mut symbols = world_symbols(&db, query.clone());
         symbols.sort_by_key(|x| x.is_import);
         expect_file!["./test_data/test_symbols_with_imports.txt"].assert_debug_eq(&symbols);
-
         query.exclude_imports();
         let symbols = world_symbols(&db, query);
         expect_file!["./test_data/test_symbols_exclude_imports.txt"].assert_debug_eq(&symbols);