COMPARISON DIFF
============================================================

Original size: 7323 bytes
Chloro size:   7459 bytes
Rustfmt size:  7435 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 /// ```
 pub struct FamousDefs<'a, 'b>(pub &'a Semantics<'b, RootDatabase>, pub Crate);
 
-#[allow(non_snake_case)]
 impl FamousDefs<'_, '_> {
     pub fn std(&self) -> Option<Crate> {
         self.find_lang_crate(LangCrateOrigin::Std)
     pub fn alloc_string_ToString(&self) -> Option<Trait> {
         self.find_trait("alloc:string:ToString")
     }
+
     pub fn builtin_crates(&self) -> impl Iterator<Item = Crate> {
         IntoIterator::into_iter([
             self.std(),
         .flatten()
     }
 
-    fn find_trait(&self, path: &str) -> Option<Trait> {
+    fn find_trait(
+        &self,
+        path: &str,
+    ) -> Option<Trait> {
         match self.find_def(path)? {
             hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),
             _ => None,
         }
     }
 
-    fn find_macro(&self, path: &str) -> Option<Macro> {
+    fn find_macro(
+        &self,
+        path: &str,
+    ) -> Option<Macro> {
         match self.find_def(path)? {
             hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(it)) => Some(it),
             _ => None,
         }
     }
 
-    fn find_enum(&self, path: &str) -> Option<Enum> {
+    fn find_enum(
+        &self,
+        path: &str,
+    ) -> Option<Enum> {
         match self.find_def(path)? {
             hir::ScopeDef::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(it))) => Some(it),
             _ => None,
         }
     }
 
-    fn find_module(&self, path: &str) -> Option<Module> {
+    fn find_module(
+        &self,
+        path: &str,
+    ) -> Option<Module> {
         match self.find_def(path)? {
             hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(it)) => Some(it),
             _ => None,
         }
     }
 
-    fn find_function(&self, path: &str) -> Option<Function> {
+    fn find_function(
+        &self,
+        path: &str,
+    ) -> Option<Function> {
         match self.find_def(path)? {
             hir::ScopeDef::ModuleDef(hir::ModuleDef::Function(it)) => Some(it),
             _ => None,
         }
     }
 
-    fn find_lang_crate(&self, origin: LangCrateOrigin) -> Option<Crate> {
+    fn find_lang_crate(
+        &self,
+        origin: LangCrateOrigin,
+    ) -> Option<Crate> {
         let krate = self.1;
         let db = self.0.db;
         if krate.origin(db) == CrateOrigin::Lang(origin) {
             return Some(krate);
         }
-
         let res = krate
             .dependencies(db)
             .into_iter()
         Some(res)
     }
 
-    fn find_def(&self, path: &str) -> Option<ScopeDef> {
+    fn find_def(
+        &self,
+        path: &str,
+    ) -> Option<ScopeDef> {
         let db = self.0.db;
         let mut path = path.split(':');
         let trait_ = path.next_back()?;
         for segment in path {
             module = module.children(db).find_map(|child| {
                 let name = child.name(db)?;
-                if name.as_str() == segment {
-                    Some(child)
-                } else {
-                    None
-                }
+                if name.as_str() == segment { Some(child) } else { None }
             })?;
         }
-        let def = module
-            .scope(db, None)
-            .into_iter()
-            .find(|(name, _def)| name.as_str() == trait_)?
-            .1;
+        let def =
+            module.scope(db, None).into_iter().find(|(name, _def)| name.as_str() == trait_)?.1;
         Some(def)
     }
 }