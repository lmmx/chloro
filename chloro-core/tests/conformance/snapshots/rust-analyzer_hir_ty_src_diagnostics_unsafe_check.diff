COMPARISON DIFF
============================================================

Original size: 17194 bytes
Chloro size:   17010 bytes
Rustfmt size:  17194 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 pub fn missing_unsafe(db: &dyn HirDatabase, def: DefWithBodyId) -> MissingUnsafeResult {
     let _p = tracing::info_span!("missing_unsafe").entered();
-
     let is_unsafe = match def {
         DefWithBodyId::FunctionId(it) => db.function_signature(it).is_unsafe(),
         DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) | DefWithBodyId::VariantId(_) => {
             false
         }
     };
-
     let mut res = MissingUnsafeResult { fn_is_unsafe: is_unsafe, ..MissingUnsafeResult::default() };
     let body = db.body(def);
     let infer = db.infer(def);
     };
     let mut visitor = UnsafeVisitor::new(db, &infer, &body, def, &mut callback);
     visitor.walk_expr(body.body_expr);
-
     if !is_unsafe {
         // Unsafety in function parameter patterns (that can only be union destructuring)
         // cannot be inserted into an unsafe block, so even with `unsafe_op_in_unsafe_fn`
             visitor.walk_pat(param);
         }
     }
-
     res
 }
 
         reason: UnsafetyReason,
     },
     /// A lint.
-    DeprecatedSafe2024 { node: ExprId, inside_unsafe_block: InsideUnsafeBlock },
+    DeprecatedSafe2024 {
+        node: ExprId,
+        inside_unsafe_block: InsideUnsafeBlock,
+    },
 }
 
-pub fn unsafe_operations_for_body<'db>(
-    db: &'db dyn HirDatabase,
-    infer: &InferenceResult<'db>,
-    def: DefWithBodyId,
-    body: &Body,
-    callback: &mut dyn FnMut(ExprOrPatId),
-) {
+pub fn unsafe_operations_for_body<'db>(db: &'db dyn HirDatabase, infer: &InferenceResult<'db>, def: DefWithBodyId, body: &Body, callback: &mut dyn FnMut(ExprOrPatId)) {
     let mut visitor_callback = |diag| {
         if let UnsafeDiagnostic::UnsafeOperation { node, .. } = diag {
             callback(node);
     }
 }
 
-pub fn unsafe_operations<'db>(
-    db: &'db dyn HirDatabase,
-    infer: &InferenceResult<'db>,
-    def: DefWithBodyId,
-    body: &Body,
-    current: ExprId,
-    callback: &mut dyn FnMut(ExprOrPatId, InsideUnsafeBlock),
-) {
+pub fn unsafe_operations<'db>(db: &'db dyn HirDatabase, infer: &InferenceResult<'db>, def: DefWithBodyId, body: &Body, current: ExprId, callback: &mut dyn FnMut(ExprOrPatId, InsideUnsafeBlock)) {
     let mut visitor_callback = |diag| {
         if let UnsafeDiagnostic::UnsafeOperation { inside_unsafe_block, node, .. } = diag {
             callback(node, inside_unsafe_block);
     inside_union_destructure: bool,
     callback: &'db mut dyn FnMut(UnsafeDiagnostic),
     def_target_features: TargetFeatures,
-    // FIXME: This needs to be the edition of the span of each call.
     edition: Edition,
     /// On some targets (WASM), calling safe functions with `#[target_feature]` is always safe, even when
     /// the target feature is not enabled. This flag encodes that.
 }
 
 impl<'db> UnsafeVisitor<'db> {
-    fn new(
-        db: &'db dyn HirDatabase,
-        infer: &'db InferenceResult<'db>,
-        body: &'db Body,
-        def: DefWithBodyId,
-        unsafe_expr_cb: &'db mut dyn FnMut(UnsafeDiagnostic),
-    ) -> Self {
+    fn new(db: &'db dyn HirDatabase, infer: &'db InferenceResult<'db>, body: &'db Body, def: DefWithBodyId, unsafe_expr_cb: &'db mut dyn FnMut(UnsafeDiagnostic)) -> Self {
         let resolver = def.resolver(db);
         let def_target_features = match def {
             DefWithBodyId::FunctionId(func) => TargetFeatures::from_attrs(&db.attrs(func.into())),
         }
     }
 
-    fn with_inside_unsafe_block<R>(
-        &mut self,
-        inside_unsafe_block: InsideUnsafeBlock,
-        f: impl FnOnce(&mut Self) -> R,
-    ) -> R {
+    fn with_inside_unsafe_block<R>(&mut self, inside_unsafe_block: InsideUnsafeBlock, f: impl FnOnce(&mut Self) -> R) -> R {
         let old = mem::replace(&mut self.inside_unsafe_block, inside_unsafe_block);
         let result = f(self);
         self.inside_unsafe_block = old;
 
     fn walk_pat(&mut self, current: PatId) {
         let pat = &self.body[current];
-
         if self.inside_union_destructure {
             match pat {
                 Pat::Tuple { .. }
                 Pat::Missing | Pat::Wild | Pat::Or(_) => {}
             }
         }
-
         match pat {
             Pat::Record { .. } => {
                 if let Some((AdtId::UnionId(_), _)) = self.infer[current].as_adt() {
             &Pat::Expr(expr) => self.walk_expr(expr),
             _ => {}
         }
-
         self.body.walk_pats_shallow(current, |pat| self.walk_pat(pat));
     }
 
             Expr::Const(e) => self.walk_expr(*e),
             _ => {}
         }
-
         self.body.walk_child_exprs_without_pats(current, |child| self.walk_expr(child));
     }
 