COMPARISON DIFF
============================================================

Original size: 31299 bytes
Chloro size:   31034 bytes
Rustfmt size:  31299 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 };
 
 use cargo_metadata::PackageId;
+pub(crate) use cargo_metadata::diagnostic::{
+    Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,
+};
 use crossbeam_channel::{Receiver, Sender, select_biased, unbounded};
 use ide_db::FxHashSet;
 use itertools::Itertools;
 use rustc_hash::FxHashMap;
 use serde::Deserialize as _;
 use serde_derive::Deserialize;
-
-pub(crate) use cargo_metadata::diagnostic::{
-    Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,
-};
 use toolchain::Tool;
 use triomphe::Arc;
 
     command::{CargoParser, CommandHandle},
     diagnostics::DiagnosticsGeneration,
 };
-
 #[derive(Clone, Debug, Default, PartialEq, Eq)]
 pub(crate) enum InvocationStrategy {
     Once,
 /// The spawned thread is shut down when this struct is dropped.
 #[derive(Debug)]
 pub(crate) struct FlycheckHandle {
-    // XXX: drop order is significant
     sender: Sender<StateChange>,
     _thread: stdx::thread::JoinHandle,
     id: usize,
 }
 
 impl FlycheckHandle {
-    pub(crate) fn spawn(
-        id: usize,
-        generation: DiagnosticsGeneration,
-        sender: Sender<FlycheckMessage>,
-        config: FlycheckConfig,
-        sysroot_root: Option<AbsPathBuf>,
-        workspace_root: AbsPathBuf,
-        manifest_path: Option<AbsPathBuf>,
-        ws_target_dir: Option<Utf8PathBuf>,
-    ) -> FlycheckHandle {
+    pub(crate) fn spawn(id: usize, generation: DiagnosticsGeneration, sender: Sender<FlycheckMessage>, config: FlycheckConfig, sysroot_root: Option<AbsPathBuf>, workspace_root: AbsPathBuf, manifest_path: Option<AbsPathBuf>, ws_target_dir: Option<Utf8PathBuf>) -> FlycheckHandle {
         let actor = FlycheckActor::new(
             id,
             generation,
     }
 
     /// Schedule a re-start of the cargo check worker to do a package wide check.
-    pub(crate) fn restart_for_package(
-        &self,
-        package: Arc<PackageId>,
-        target: Option<Target>,
-        workspace_deps: Option<FxHashSet<Arc<PackageId>>>,
-    ) {
+    pub(crate) fn restart_for_package(&self, package: Arc<PackageId>, target: Option<Target>, workspace_deps: Option<FxHashSet<Arc<PackageId>>>) {
         let generation = self.generation.fetch_add(1, Ordering::Relaxed) + 1;
         self.sender
             .send(StateChange::Restart {
         diagnostic: Diagnostic,
         package_id: Option<Arc<PackageId>>,
     },
-
     /// Request clearing all outdated diagnostics.
-    ClearDiagnostics { id: usize, kind: ClearDiagnosticsKind },
-
+    ClearDiagnostics {
+        id: usize,
+        kind: ClearDiagnosticsKind,
+    },
     /// Request check progress notification to client
     Progress {
         /// Flycheck instance ID
 
 enum FlycheckScope {
     Workspace,
-    Package { package: Arc<PackageId>, workspace_deps: Option<FxHashSet<Arc<PackageId>>> },
+    Package {
+        package: Arc<PackageId>,
+        workspace_deps: Option<FxHashSet<Arc<PackageId>>>,
+    },
 }
 
 enum StateChange {
 struct FlycheckActor {
     /// The workspace id of this flycheck instance.
     id: usize,
-
     generation: DiagnosticsGeneration,
     sender: Sender<FlycheckMessage>,
     config: FlycheckConfig,
     CheckEvent(Option<CargoCheckMessage>),
 }
 
-pub(crate) const SAVED_FILE_PLACEHOLDER: &str = "$saved_file";
 
 impl FlycheckActor {
-    fn new(
-        id: usize,
-        generation: DiagnosticsGeneration,
-        sender: Sender<FlycheckMessage>,
-        config: FlycheckConfig,
-        sysroot_root: Option<AbsPathBuf>,
-        workspace_root: AbsPathBuf,
-        manifest_path: Option<AbsPathBuf>,
-        ws_target_dir: Option<Utf8PathBuf>,
-    ) -> FlycheckActor {
+    fn new(id: usize, generation: DiagnosticsGeneration, sender: Sender<FlycheckMessage>, config: FlycheckConfig, sysroot_root: Option<AbsPathBuf>, workspace_root: AbsPathBuf, manifest_path: Option<AbsPathBuf>, ws_target_dir: Option<Utf8PathBuf>) -> FlycheckActor {
         tracing::info!(%id, ?workspace_root, "Spawning flycheck");
         FlycheckActor {
             id,
         let Some(command_receiver) = &self.command_receiver else {
             return inbox.recv().ok().map(Event::RequestStateChange);
         };
-
         // Biased to give restarts a preference so check outputs don't block a restart or stop
         select_biased! {
             recv(inbox) -> msg => msg.ok().map(Event::RequestStateChange),
     /// Construct a `Command` object for checking the user's code. If the user
     /// has specified a custom command with placeholders that we cannot fill,
     /// return None.
-    fn check_command(
-        &self,
-        scope: &FlycheckScope,
-        saved_file: Option<&AbsPath>,
-        target: Option<Target>,
-    ) -> Option<Command> {
+    fn check_command(&self, scope: &FlycheckScope, saved_file: Option<&AbsPath>, target: Option<Target>) -> Option<Command> {
         match &self.config {
             FlycheckConfig::CargoCommand { command, options, ansi_color_output } => {
                 let mut cmd =
 #[allow(clippy::large_enum_variant)]
 enum CargoCheckMessage {
     CompilerArtifact(cargo_metadata::Artifact),
-    Diagnostic { diagnostic: Diagnostic, package_id: Option<Arc<PackageId>> },
+    Diagnostic {
+        diagnostic: Diagnostic,
+        package_id: Option<Arc<PackageId>>,
+    },
 }
 
 struct CargoCheckParser;
                 }
             };
         }
-
         error.push_str(line);
         error.push('\n');
         None