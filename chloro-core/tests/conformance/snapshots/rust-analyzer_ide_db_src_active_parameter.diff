COMPARISON DIFF
============================================================

Original size: 6837 bytes
Chloro size:   6714 bytes
Rustfmt size:  6998 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use parser::T;
 use span::TextSize;
 use syntax::{
+    AstNode, NodeOrToken, SyntaxToken,
     ast::{self, AstChildren, HasArgList, HasAttrs, HasName},
-    match_ast, AstNode, NodeOrToken, SyntaxToken,
+    match_ast,
 };
 
 use crate::RootDatabase;
-
 #[derive(Debug)]
 pub struct ActiveParameter<'db> {
     pub ty: Type<'db>,
     }
 
     /// Returns information about the call argument this token is part of.
-    pub fn at_arg(
-        sema: &'db Semantics<'db, RootDatabase>,
-        list: ast::ArgList,
-        at: TextSize,
-    ) -> Option<Self> {
+    pub fn at_arg(sema: &'db Semantics<'db, RootDatabase>, list: ast::ArgList, at: TextSize) -> Option<Self> {
         let (signature, active_parameter) = callable_for_arg_list(sema, list, at)?;
         Self::from_signature_and_active_parameter(sema, signature, active_parameter)
     }
 
-    fn from_signature_and_active_parameter(
-        sema: &Semantics<'db, RootDatabase>,
-        signature: hir::Callable<'db>,
-        active_parameter: Option<usize>,
-    ) -> Option<Self> {
+    fn from_signature_and_active_parameter(sema: &Semantics<'db, RootDatabase>, signature: hir::Callable<'db>, active_parameter: Option<usize>) -> Option<Self> {
         let idx = active_parameter?;
         let mut params = signature.params();
         if idx >= params.len() {
             return None;
         }
         let param = params.swap_remove(idx);
-        Some(ActiveParameter {
-            ty: param.ty().clone(),
-            src: sema.source(param),
-        })
+        Some(ActiveParameter { ty: param.ty().clone(), src: sema.source(param) })
     }
 
     pub fn ident(&self) -> Option<ast::Name> {
-        self.src
-            .as_ref()
-            .and_then(|param| match param.value.as_ref().right()?.pat()? {
-                ast::Pat::IdentPat(ident) => ident.name(),
-                _ => None,
-            })
+        self.src.as_ref().and_then(|param| match param.value.as_ref().right()?.pat()? {
+            ast::Pat::IdentPat(ident) => ident.name(),
+            _ => None,
+        })
     }
 
     pub fn attrs(&self) -> Option<AstChildren<ast::Attr>> {
-        self.src
-            .as_ref()
-            .and_then(|param| Some(param.value.as_ref().right()?.attrs()))
+        self.src.as_ref().and_then(|param| Some(param.value.as_ref().right()?.attrs()))
     }
 }
 
 /// Returns a [`hir::Callable`] this token is a part of and its argument index of said callable.
-pub fn callable_for_token<'db>(
-    sema: &Semantics<'db, RootDatabase>,
-    token: SyntaxToken,
-) -> Option<(hir::Callable<'db>, Option<usize>)> {
+pub fn callable_for_token<'db>(sema: &Semantics<'db, RootDatabase>, token: SyntaxToken) -> Option<(hir::Callable<'db>, Option<usize>)> {
     let offset = token.text_range().start();
     // Find the calling expression and its NameRef
     let parent = token.parent()?;
     let calling_node = parent
         .ancestors()
         .filter_map(ast::CallableExpr::cast)
-        .find(|it| {
-            it.arg_list()
-                .is_some_and(|it| it.syntax().text_range().contains(offset))
-        })?;
-
+        .find(|it| it.arg_list().is_some_and(|it| it.syntax().text_range().contains(offset)))?;
     callable_for_node(sema, &calling_node, offset)
 }
 
 /// Returns a [`hir::Callable`] this token is a part of and its argument index of said callable.
-pub fn callable_for_arg_list<'db>(
-    sema: &Semantics<'db, RootDatabase>,
-    arg_list: ast::ArgList,
-    at: TextSize,
-) -> Option<(hir::Callable<'db>, Option<usize>)> {
+pub fn callable_for_arg_list<'db>(sema: &Semantics<'db, RootDatabase>, arg_list: ast::ArgList, at: TextSize) -> Option<(hir::Callable<'db>, Option<usize>)> {
     debug_assert!(arg_list.syntax().text_range().contains(at));
-    let callable = arg_list
-        .syntax()
-        .parent()
-        .and_then(ast::CallableExpr::cast)?;
+    let callable = arg_list.syntax().parent().and_then(ast::CallableExpr::cast)?;
     callable_for_node(sema, &callable, at)
 }
 
-pub fn callable_for_node<'db>(
-    sema: &Semantics<'db, RootDatabase>,
-    calling_node: &ast::CallableExpr,
-    offset: TextSize,
-) -> Option<(hir::Callable<'db>, Option<usize>)> {
+pub fn callable_for_node<'db>(sema: &Semantics<'db, RootDatabase>, calling_node: &ast::CallableExpr, offset: TextSize) -> Option<(hir::Callable<'db>, Option<usize>)> {
     let callable = match calling_node {
         ast::CallableExpr::Call(call) => sema.resolve_expr_as_callable(&call.expr()?),
         ast::CallableExpr::MethodCall(call) => sema.resolve_method_call_as_callable(call),
     Some((callable, active_param))
 }
 
-pub fn generic_def_for_node(
-    sema: &Semantics<'_, RootDatabase>,
-    generic_arg_list: &ast::GenericArgList,
-    token: &SyntaxToken,
-) -> Option<(hir::GenericDef, usize, bool, Option<hir::Variant>)> {
+pub fn generic_def_for_node(sema: &Semantics<'_, RootDatabase>, generic_arg_list: &ast::GenericArgList, token: &SyntaxToken) -> Option<(hir::GenericDef, usize, bool, Option<hir::Variant>)> {
     let parent = generic_arg_list.syntax().parent()?;
     let mut variant = None;
     let def = match_ast! {
             _ => return None,
         }
     };
-
     let active_param = generic_arg_list
         .syntax()
         .children_with_tokens()
         .filter(|t| t.kind() == T![,])
         .take_while(|t| t.text_range().start() <= token.text_range().start())
         .count();
-
     let first_arg_is_non_lifetime = generic_arg_list
         .generic_args()
         .next()
         .is_some_and(|arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));
-
     Some((def, active_param, first_arg_is_non_lifetime, variant))
 }