COMPARISON DIFF
============================================================

Original size: 31467 bytes
Chloro size:   31571 bytes
Rustfmt size:  31467 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! track of the cumulative total number of lines that have been added to the file during the
 //! session so that we can determine the correct offset to insert content at without re-parsing.
 
+use std::collections::HashMap;
+use std::path::PathBuf;
+use std::{fs, io};
+
+use edtui::{EditorState, Lines};
+
 use crate::edit_plan::{Edit, EditPlan};
 use crate::formats::markdown::MarkdownFormat;
 use crate::input;
 use crate::section::ChunkType;
 use crate::section::{Section, TreeNode};
-use edtui::{EditorState, Lines};
-use std::collections::HashMap;
-use std::path::PathBuf;
-use std::{fs, io};
 
 /// Determines navigation scope and quit behavior based on project size.
 #[derive(PartialEq)]
 impl AppState {
     /// Initialises application state with parsed sections and determines file mode.
     #[must_use]
-    pub fn new(files: Vec<PathBuf>, sections: Vec<Section>, wrap_width: usize) -> Self {
+    pub fn new(
+        files: Vec<PathBuf>,
+        sections: Vec<Section>,
+        wrap_width: usize,
+    ) -> Self {
         let file_mode = if files.len() == 1 {
             FileMode::Single
         } else {
             FileMode::Multi
         };
-
         let tree_nodes = Self::build_tree(&files, &sections);
-
         // Find first navigable node
         let initial_index = tree_nodes.iter().position(|n| n.navigable).unwrap_or(0);
-
         Self {
             sections,
             tree_nodes,
         }
     }
 
-    fn build_tree(files: &[PathBuf], sections: &[Section]) -> Vec<TreeNode> {
+    fn build_tree(
+        files: &[PathBuf],
+        sections: &[Section],
+    ) -> Vec<TreeNode> {
         let mut nodes = Vec::new();
-
         // Determine if this is difftastic mode by checking if multiple sections share the same file_path
         // (in markdown mode, each section has a unique file path or sections are from the same file)
         let mut file_section_counts: HashMap<String, usize> = HashMap::new();
                 .or_insert(0) += 1;
         }
         let is_difftastic = file_section_counts.values().any(|&count| count > 1);
-
         if files.len() == 1 && !is_difftastic {
             // Single markdown file mode: use section level for tree indentation
             for (idx, section) in sections.iter().enumerate() {
                 }
             }
         }
-
         nodes
     }
 
     /// Rebuild tree after sections change (e.g., after save)
     pub fn rebuild_tree(&mut self) {
         self.tree_nodes = Self::build_tree(&self.files, &self.sections);
-
         // Try to maintain current position by finding same section
         if let Some(current_section_idx) = self.get_current_section_index() {
             if let Some(node_idx) = self
 
     fn rebuild_file_offsets(&mut self) {
         self.file_offsets.clear();
-
         if let Some(section_idx) = self.get_current_section_index() {
             if let Some(section) = self.sections.get(section_idx) {
                 let lines_added = self.editor_state.as_ref().map_or(0, |es| es.lines.len());
 
     /// Calculates total lines added before a section to determine correct write position.
     #[must_use]
-    pub fn cumulative_offset(&self, index: usize) -> usize {
+    pub fn cumulative_offset(
+        &self,
+        index: usize,
+    ) -> usize {
         let section = &self.sections[index];
         let target_file = &section.file_path;
         let target_line = section.line_start;
-
         if let Some(file_map) = self.file_offsets.get(target_file) {
             file_map
                 .iter()
     }
 
     /// Restores previously edited content from a saved edit plan.
-    pub fn load_docs(&mut self, plan: EditPlan) {
+    pub fn load_docs(
+        &mut self,
+        plan: EditPlan,
+    ) {
         let mut doc_map: HashMap<String, Vec<String>> = HashMap::new();
         for edit in plan.edits {
             let key = format!(
                 .collect();
             doc_map.insert(key, lines);
         }
-
         // Match edits to sections and pre-populate editor content
         for section in &mut self.sections {
             let key = format!(
     #[must_use]
     pub fn generate_edit_plan(&self) -> EditPlan {
         let mut edits = Vec::new();
-
         for section in &self.sections {
             if let Some(ref doc_lines) = section.section_content {
                 let section_content = doc_lines.join("\n");
                 });
             }
         }
-
         EditPlan { edits }
     }
 
         let Some(section_idx) = self.get_current_section_index() else {
             return;
         };
-
         let section = &self.sections[section_idx];
-
         // Handle difftastic chunks differently
         if let Some(chunk_type) = &section.chunk_type {
             let content = match chunk_type {
             let lines = Lines::from(lines_text.as_str());
             self.editor_state = Some(EditorState::new(lines));
         }
-
         self.current_view = View::Detail;
     }
 
     /// Returns to section list, optionally persisting editor changes.
-    pub fn exit_detail_view(&mut self, save: bool) {
+    pub fn exit_detail_view(
+        &mut self,
+        save: bool,
+    ) {
         if save {
             if let Some(ref editor_state) = self.editor_state {
                 if let Some(section_idx) = self.get_current_section_index() {
         } else {
             return Ok(());
         };
-
         let Some(section_idx) = self.get_current_section_index() else {
             return Ok(());
         };
-
         self.sections[section_idx].section_content = Some(editor_lines.clone());
-
         let section = &self.sections[section_idx];
-
         let raw_content = editor_lines.join("\n");
         let trimmed_content = raw_content.trim();
         let padded_content = format!("\n{trimmed_content}\n\n");
-
         let edit = Edit {
             file_name: section.file_path.clone(),
             line_start: section.line_start,
             section_content: padded_content,
             item_name: section.title.clone(),
         };
-
         let mut plan = EditPlan { edits: vec![edit] };
         plan.apply()?;
-
         // Reload sections
         let format = MarkdownFormat;
         if let Ok(new_sections) =
                 self.rebuild_tree();
             }
         }
-
         self.rebuild_file_offsets();
         self.message = Some("Saved".to_string());
         Ok(())
     pub fn navigate_to_parent(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let parent_section_idx = self.sections[section_idx].parent_index?;
-
         // Find tree node with this section index
         self.tree_nodes
             .iter()
     pub fn navigate_to_first_child(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let first_child_idx = self.sections[section_idx].children_indices.first()?;
-
         self.tree_nodes
             .iter()
             .position(|n| n.section_index == Some(*first_child_idx))
     #[must_use]
     pub fn navigate_to_next_descendant(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
-
         // First try immediate children
         if let Some(first_child) = self.sections[section_idx].children_indices.first() {
             return self
                 .iter()
                 .position(|n| n.section_index == Some(*first_child));
         }
-
         // Otherwise find next section at deeper level
         for i in (section_idx + 1)..self.sections.len() {
             if self.sections[i].level > self.sections[section_idx].level {
                     .position(|n| n.section_index == Some(i));
             }
         }
-
         None
     }
 
     pub fn navigate_to_next_sibling(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let current_level = self.sections[section_idx].level;
-
         for i in (section_idx + 1)..self.sections.len() {
             if self.sections[i].level == current_level {
                 return self
                 break;
             }
         }
-
         None
     }
 
     pub fn navigate_to_prev_sibling(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let current_level = self.sections[section_idx].level;
-
         for i in (0..section_idx).rev() {
             if self.sections[i].level == current_level {
                 return self
                 break;
             }
         }
-
         None
     }
 
     pub fn navigate_to_first_at_level(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let current_level = self.sections[section_idx].level;
-
         for i in 0..self.sections.len() {
             if self.sections[i].level == current_level {
                 return self
                     .position(|n| n.section_index == Some(i));
             }
         }
-
         None
     }
 
     pub fn navigate_to_last_at_level(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let current_level = self.sections[section_idx].level;
-
         for i in (0..self.sections.len()).rev() {
             if self.sections[i].level == current_level {
                 return self
                     .position(|n| n.section_index == Some(i));
             }
         }
-
         None
     }
 
         let indent = self.get_indent();
         self.wrap_width.saturating_sub(indent)
     }
-
     // --- Section List Movement ---
 
     /// Start moving the current section
         if self.move_state != MoveState::Moved {
             return Ok(());
         }
-
         // Group sections by file
         let mut file_sections: HashMap<String, Vec<&Section>> = HashMap::new();
         for section in &self.sections {
                 .or_default()
                 .push(section);
         }
-
         // Process each file
         for (file_path, sections) in file_sections {
             Self::rewrite_file_sections(&file_path, &sections)?;
         }
-
         // Reload sections to get updated positions
         let format = MarkdownFormat;
         let mut new_sections = Vec::new();
                 new_sections.extend(secs);
             }
         }
-
         self.sections = new_sections;
         self.rebuild_tree();
         self.cancel_move();
         self.message = Some("Sections reordered".to_string());
-
         Ok(())
     }
 
     /// Rewrite an entire file with reordered sections
-    fn rewrite_file_sections(file_path: &str, sections: &[&Section]) -> io::Result<()> {
+    fn rewrite_file_sections(
+        file_path: &str,
+        sections: &[&Section],
+    ) -> io::Result<()> {
         let content = fs::read_to_string(file_path)?;
         let mut new_content = String::new();
-
         for section in sections {
             let heading_prefix = "#".repeat(section.level);
             let heading = format!("{} {}", heading_prefix, section.title);
                 new_content.push_str("\n\n");
             }
         }
-
         fs::write(file_path, new_content)?;
         Ok(())
     }