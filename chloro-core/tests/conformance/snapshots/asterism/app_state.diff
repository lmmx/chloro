COMPARISON DIFF
============================================================

Original size: 31467 bytes
Chloro size:   31196 bytes
Rustfmt size:  31467 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! track of the cumulative total number of lines that have been added to the file during the
 //! session so that we can determine the correct offset to insert content at without re-parsing.
 
+#[cfg(test)]
+#[path = "tests/app_state.rs"]
+mod tests;
+
+use std::collections::HashMap;
+use std::path::PathBuf;
+use std::{fs, io};
+
+use edtui::{EditorState, Lines};
+
 use crate::edit_plan::{Edit, EditPlan};
 use crate::formats::markdown::MarkdownFormat;
 use crate::input;
 use crate::section::ChunkType;
 use crate::section::{Section, TreeNode};
-use edtui::{EditorState, Lines};
-use std::collections::HashMap;
-use std::path::PathBuf;
-use std::{fs, io};
 
 /// Determines navigation scope and quit behavior based on project size.
 #[derive(PartialEq)]
         let mut nodes = Vec::new();
 
         // Determine if this is difftastic mode by checking if multiple sections share the same file_path
+
         // (in markdown mode, each section has a unique file path or sections are from the same file)
         let mut file_section_counts: HashMap<String, usize> = HashMap::new();
         for section in sections {
 
         // Try to maintain current position by finding same section
         if let Some(current_section_idx) = self.get_current_section_index() {
-            if let Some(node_idx) = self
-                .tree_nodes
-                .iter()
-                .position(|n| n.section_index == Some(current_section_idx))
-            {
+            if let Some(node_idx) = self.tree_nodes.iter().position(|n| n.section_index == Some(current_section_idx)) {
                 self.current_node_index = node_idx;
             }
         }
     /// Get the current section (if on a section node)
     #[must_use]
     pub fn get_current_section(&self) -> Option<&Section> {
-        self.get_current_section_index()
-            .and_then(|idx| self.sections.get(idx))
+        self.get_current_section_index().and_then(|idx| self.sections.get(idx))
     }
 
     fn rebuild_file_offsets(&mut self) {
         if let Some(section_idx) = self.get_current_section_index() {
             if let Some(section) = self.sections.get(section_idx) {
                 let lines_added = self.editor_state.as_ref().map_or(0, |es| es.lines.len());
-
                 let file_map = self
                     .file_offsets
                     .entry(section.file_path.clone())
                     .or_default();
-
                 file_map.insert(section.line_start, lines_added);
             }
         }
         let target_line = section.line_start;
 
         if let Some(file_map) = self.file_offsets.get(target_file) {
-            file_map
-                .iter()
-                .filter(|(line, _)| **line < target_line)
-                .map(|(_, offset)| offset)
-                .sum()
+            file_map.iter().filter(|(line, _)| **line < target_line).map(|(_, offset)| offset).sum()
         } else {
             0
         }
                 if let Ok(content) = fs::read_to_string(&section.file_path) {
                     let bytes = content.as_bytes();
                     if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {
-                        // Section exists and can be loaded
                     }
                 }
             }
     /// Navigate to next navigable node
     #[must_use]
     pub fn find_next_node(&self) -> Option<usize> {
-        ((self.current_node_index + 1)..self.tree_nodes.len())
-            .find(|&i| self.tree_nodes[i].navigable)
+        ((self.current_node_index + 1)..self.tree_nodes.len()).find(
+            |&i| self.tree_nodes[i].navigable,
+        )
     }
 
     /// Navigate to previous navigable node
     #[must_use]
     pub fn find_prev_node(&self) -> Option<usize> {
-        (0..self.current_node_index)
-            .rev()
-            .find(|&i| self.tree_nodes[i].navigable)
+        (0..self.current_node_index).rev().find(|&i| self.tree_nodes[i].navigable)
     }
 
     /// Moves to the containing section in the document hierarchy.
         let parent_section_idx = self.sections[section_idx].parent_index?;
 
         // Find tree node with this section index
-        self.tree_nodes
-            .iter()
-            .position(|n| n.section_index == Some(parent_section_idx))
+        self.tree_nodes.iter().position(|n| n.section_index == Some(parent_section_idx))
     }
 
     /// Descends to the first child section in the document hierarchy.
         let section_idx = self.get_current_section_index()?;
         let first_child_idx = self.sections[section_idx].children_indices.first()?;
 
-        self.tree_nodes
-            .iter()
-            .position(|n| n.section_index == Some(*first_child_idx))
+        self.tree_nodes.iter().position(|n| n.section_index == Some(*first_child_idx))
     }
 
     /// Finds the next descendant section at any depth in the hierarchy.
         Ok(())
     }
 }
-
-#[cfg(test)]
-#[path = "tests/app_state.rs"]
-mod tests;