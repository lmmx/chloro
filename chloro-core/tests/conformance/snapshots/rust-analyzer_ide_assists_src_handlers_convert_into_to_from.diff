COMPARISON DIFF
============================================================

Original size: 7739 bytes
Chloro size:   7190 bytes
Rustfmt size:  7739 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use ide_db::{famous_defs::FamousDefs, helpers::mod_path_to_ast, traits::resolve_target_trait};
 use syntax::ast::{self, AstNode, HasGenericArgs, HasName};
 
 use crate::{AssistContext, AssistId, Assists};
-
-// FIXME: this should be a diagnostic
-
-// Assist: convert_into_to_from
-//
-// Converts an Into impl to an equivalent From impl.
-//
-// ```
-// # //- minicore: from
-// impl $0Into<Thing> for usize {
-//     fn into(self) -> Thing {
-//         Thing {
-//             b: self.to_string(),
-//             a: self
-//         }
-//     }
-// }
-// ```
-// ->
-// ```
-// impl From<usize> for Thing {
-//     fn from(val: usize) -> Self {
-//         Thing {
-//             b: val.to_string(),
-//             a: val
-//         }
-//     }
-// }
-// ```
 pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let impl_ = ctx.find_node_at_offset::<ast::Impl>()?;
     let src_type = impl_.self_ty()?;
     let ast_trait = impl_.trait_()?;
-
     let module = ctx.sema.scope(impl_.syntax())?.module();
-
     let trait_ = resolve_target_trait(&ctx.sema, &impl_)?;
     if trait_ != FamousDefs(&ctx.sema, module.krate()).core_convert_Into()? {
         return None;
     }
-
     let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
-
     let src_type_path = {
         let src_type_path = src_type.syntax().descendants().find_map(ast::Path::cast)?;
         let src_type_def = match ctx.sema.resolve_path(&src_type_path) {
             module.krate().edition(ctx.db()),
         )
     };
-
     let dest_type = match &ast_trait {
         ast::Type::PathType(path) => {
             path.path()?.segment()?.generic_arg_list()?.generic_args().next()?
         }
         _ => return None,
     };
-
     let into_fn = impl_.assoc_item_list()?.assoc_items().find_map(|item| {
         if let ast::AssocItem::Fn(f) = item
             && f.name()?.text() == "into"
         };
         None
     })?;
-
     let into_fn_name = into_fn.name()?;
     let into_fn_params = into_fn.param_list()?;
     let into_fn_return = into_fn.ret_type()?;
-
     let selfs = into_fn
         .body()?
         .syntax()
         .descendants()
         .filter_map(ast::NameRef::cast)
         .filter(|name| name.text() == "self" || name.text() == "Self");
-
     acc.add(
         AssistId::refactor_rewrite("convert_into_to_from"),
         "Convert Into to From",
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn convert_into_to_from_converts_a_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn convert_into_to_from_converts_enums() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn convert_into_to_from_on_enum_with_lifetimes() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn convert_into_to_from_works_on_references() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn convert_into_to_from_works_on_qualified_structs() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn convert_into_to_from_works_on_qualified_enums() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn convert_into_to_from_not_applicable_on_any_trait_named_into() {
         check_assist_not_applicable(