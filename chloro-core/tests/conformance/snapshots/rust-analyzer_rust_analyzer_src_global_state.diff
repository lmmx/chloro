COMPARISON DIFF
============================================================

Original size: 37899 bytes
Chloro size:   36970 bytes
Rustfmt size:  37899 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     task_pool::{TaskPool, TaskQueue},
     test_runner::{CargoTestHandle, CargoTestMessage},
 };
-
 #[derive(Debug)]
 pub(crate) struct FetchWorkspaceRequest {
     pub(crate) path: Option<AbsPathBuf>,
     pub(crate) build_scripts: Vec<anyhow::Result<WorkspaceBuildScripts>>,
 }
 
-// Enforces drop order
 pub(crate) struct Handle<H, C> {
     pub(crate) handle: H,
     pub(crate) receiver: C,
 }
 
 pub(crate) type ReqHandler = fn(&mut GlobalState, lsp_server::Response);
+
 type ReqQueue = lsp_server::ReqQueue<(String, Instant), ReqHandler>;
 
 /// `GlobalState` is the primary mutable state of the language server
 pub(crate) struct GlobalState {
     sender: Sender<lsp_server::Message>,
     req_queue: ReqQueue,
-
     pub(crate) task_pool: Handle<TaskPool<Task>, Receiver<Task>>,
     pub(crate) fmt_pool: Handle<TaskPool<Task>, Receiver<Task>>,
     pub(crate) cancellation_pool: thread::Pool,
-
     pub(crate) config: Arc<Config>,
     pub(crate) config_errors: Option<ConfigErrors>,
     pub(crate) analysis_host: AnalysisHost,
     /// A mapping that maps a local source root's `SourceRootId` to it parent's `SourceRootId`, if it has one.
     pub(crate) local_roots_parent_map: Arc<FxHashMap<SourceRootId, SourceRootId>>,
     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,
-
-    // status
     pub(crate) shutdown_requested: bool,
     pub(crate) last_reported_status: lsp_ext::ServerStatusParams,
-
-    // proc macros
     pub(crate) proc_macro_clients: Arc<[Option<anyhow::Result<ProcMacroClient>>]>,
     pub(crate) build_deps_changed: bool,
-
-    // Flycheck
     pub(crate) flycheck: Arc<[FlycheckHandle]>,
     pub(crate) flycheck_sender: Sender<FlycheckMessage>,
     pub(crate) flycheck_receiver: Receiver<FlycheckMessage>,
     pub(crate) last_flycheck_error: Option<String>,
-
-    // Test explorer
     pub(crate) test_run_session: Option<Vec<CargoTestHandle>>,
     pub(crate) test_run_sender: Sender<CargoTestMessage>,
     pub(crate) test_run_receiver: Receiver<CargoTestMessage>,
     pub(crate) test_run_remaining_jobs: usize,
-
-    // Project loading
     pub(crate) discover_handle: Option<discover::DiscoverHandle>,
     pub(crate) discover_sender: Sender<discover::DiscoverProjectMessage>,
     pub(crate) discover_receiver: Receiver<discover::DiscoverProjectMessage>,
-
-    // Debouncing channel for fetching the workspace
-    // we want to delay it until the VFS looks stable-ish (and thus is not currently in the middle
-    // of a VCS operation like `git switch`)
     pub(crate) fetch_ws_receiver: Option<(Receiver<Instant>, FetchWorkspaceRequest)>,
-
-    // VFS
     pub(crate) loader: Handle<Box<dyn vfs::loader::Handle>, Receiver<vfs::loader::Message>>,
     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,
     pub(crate) vfs_config_version: u32,
     pub(crate) vfs_progress_config_version: u32,
     pub(crate) vfs_done: bool,
-    // used to track how long VFS loading takes. this can't be on `vfs::loader::Handle`,
-    // as that handle's lifetime is the same as `GlobalState` itself.
     pub(crate) vfs_span: Option<tracing::span::EnteredSpan>,
     pub(crate) wants_to_switch: Option<Cause>,
-
     /// `workspaces` field stores the data we actually use, while the `OpQueue`
     /// stores the result of the last fetch.
     ///
     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,
     pub(crate) crate_graph_file_dependencies: FxHashSet<vfs::VfsPath>,
     pub(crate) detached_files: FxHashSet<ManifestPath>,
-
-    // op queues
     pub(crate) fetch_workspaces_queue: OpQueue<FetchWorkspaceRequest, FetchWorkspaceResponse>,
     pub(crate) fetch_build_data_queue: OpQueue<(), FetchBuildDataResponse>,
     pub(crate) fetch_proc_macros_queue: OpQueue<(ChangeWithProcMacros, Vec<ProcMacroPaths>), bool>,
     pub(crate) prime_caches_queue: OpQueue,
     pub(crate) discover_workspace_queue: OpQueue,
-
     /// A deferred task queue.
     ///
     /// This queue is used for doing database-dependent work inside of sync
     /// This is marked true if we failed to load a crate root file at crate graph creation,
     /// which will usually end up causing a bunch of incorrect diagnostics on startup.
     pub(crate) incomplete_crate_graph: bool,
-
     pub(crate) minicore: MiniCoreRustAnalyzerInternalOnly,
 }
 
-// FIXME: This should move to the VFS once the rewrite is done.
 #[derive(Debug, Clone, Default)]
 pub(crate) struct MiniCoreRustAnalyzerInternalOnly {
     pub(crate) minicore_text: Option<String>,
     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,
     vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,
     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,
-    // used to signal semantic highlighting to fall back to syntax based highlighting until
-    // proc-macros have been loaded
-    // FIXME: Can we derive this from somewhere else?
     pub(crate) proc_macros_loaded: bool,
     pub(crate) flycheck: Arc<[FlycheckHandle]>,
     minicore: MiniCoreRustAnalyzerInternalOnly,
 }
 
-impl std::panic::UnwindSafe for GlobalStateSnapshot {}
+impl std::panic::UnwindSafe for GlobalStateSnapshot {
+}
 
 impl GlobalState {
     pub(crate) fn new(sender: Sender<lsp_server::Message>, config: Config) -> GlobalState {
             let handle = Box::new(handle) as Box<dyn vfs::loader::Handle>;
             Handle { handle, receiver }
         };
-
         let task_pool = {
             let (sender, receiver) = unbounded();
             let handle = TaskPool::new_with_threads(sender, config.main_loop_num_threads());
             Handle { handle, receiver }
         };
         let cancellation_pool = thread::Pool::new(1);
-
         let task_queue = {
             let (sender, receiver) = unbounded();
             TaskQueue { sender, receiver }
         };
-
         let mut analysis_host = AnalysisHost::new(config.lru_parse_query_capacity());
         if let Some(capacities) = config.lru_query_capacities_config() {
             analysis_host.update_lru_capacities(capacities);
         }
         let (flycheck_sender, flycheck_receiver) = unbounded();
         let (test_run_sender, test_run_receiver) = unbounded();
-
         let (discover_sender, discover_receiver) = unbounded();
-
         let mut this = GlobalState {
             sender,
             req_queue: ReqQueue::default(),
         // mapping is not ready until `AnalysisHost::apply_changes` has been called.
         let mut modified_ratoml_files: FxHashMap<FileId, (ChangeKind, vfs::VfsPath)> =
             FxHashMap::default();
-
         let mut change = ChangeWithProcMacros::default();
         let mut guard = self.vfs.write();
         let changed_files = guard.0.take_changes();
         if changed_files.is_empty() {
             return false;
         }
-
         let (change, modified_rust_files, workspace_structure_change) =
             self.cancellation_pool.scoped(|s| {
                 // start cancellation in parallel, this will kick off lru eviction
                 }
                 (change, modified_rust_files, workspace_structure_change)
             });
-
         self.analysis_host.apply_change(change);
         if !modified_ratoml_files.is_empty()
             || !self.config.same_source_root_parent_map(&self.local_roots_parent_map)
                 self.config = Arc::new(config);
             }
         }
-
         // FIXME: `workspace_structure_change` is computed from `should_refresh_for_change` which is
         // path syntax based. That is not sufficient for all cases so we should lift that check out
         // into a `QueuedTask`, see `handle_did_save_text_document`.
                 self.enqueue_workspace_fetch(path, force_crate_graph_reload);
             }
         }
-
         true
     }
 
         }
     }
 
-    pub(crate) fn send_request<R: lsp_types::request::Request>(
-        &mut self,
-        params: R::Params,
-        handler: ReqHandler,
-    ) {
+    pub(crate) fn send_request<R: lsp_types::request::Request>(&mut self, params: R::Params, handler: ReqHandler) {
         let request = self.req_queue.outgoing.register(R::METHOD.to_owned(), params, handler);
         self.send(request.into());
     }
         handler(self, response)
     }
 
-    pub(crate) fn send_notification<N: lsp_types::notification::Notification>(
-        &self,
-        params: N::Params,
-    ) {
+    pub(crate) fn send_notification<N: lsp_types::notification::Notification>(&self, params: N::Params) {
         let not = lsp_server::Notification::new(N::METHOD.to_owned(), params);
         self.send(not.into());
     }
 
-    pub(crate) fn register_request(
-        &mut self,
-        request: &lsp_server::Request,
-        request_received: Instant,
-    ) {
+    pub(crate) fn register_request(&mut self, request: &lsp_server::Request, request_received: Instant) {
         self.req_queue
             .incoming
             .register(request.id.clone(), (request.method.clone(), request_received));
         self.sender.send(message).unwrap();
     }
 
-    pub(crate) fn publish_diagnostics(
-        &mut self,
-        uri: Url,
-        version: Option<i32>,
-        mut diagnostics: Vec<lsp_types::Diagnostic>,
-    ) {
+    pub(crate) fn publish_diagnostics(&mut self, uri: Url, version: Option<i32>, mut diagnostics: Vec<lsp_types::Diagnostic>) {
         // We put this on a separate thread to avoid blocking the main thread with serialization work
         self.task_pool.handle.spawn_with_sender(stdx::thread::ThreadIntent::Worker, {
             let sender = self.sender.clone();
             // FIXME: We should cancel the in-progress fetch here
             return;
         }
-
         self.fetch_ws_receiver = Some((
             crossbeam_channel::after(Duration::from_millis(100)),
             FetchWorkspaceRequest { path: Some(path), force_crate_graph_reload },
         let file_id = self.analysis.crate_root(crate_id).ok()?;
         let path = self.vfs_read().file_path(file_id).clone();
         let path = path.as_path()?;
-
         for workspace in self.workspaces.iter() {
             match &workspace.kind {
                 ProjectWorkspaceKind::Cargo { cargo, .. }
                 ProjectWorkspaceKind::DetachedFile { .. } => {}
             };
         }
-
         None
     }
 
-    pub(crate) fn all_workspace_dependencies_for_package(
-        &self,
-        package: &Arc<PackageId>,
-    ) -> Option<FxHashSet<Arc<PackageId>>> {
+    pub(crate) fn all_workspace_dependencies_for_package(&self, package: &Arc<PackageId>) -> Option<FxHashSet<Arc<PackageId>>> {
         for workspace in self.workspaces.iter() {
             match &workspace.kind {
                 ProjectWorkspaceKind::Cargo { cargo, .. }
 }
 
 /// Returns `None` if the file was excluded.
-pub(crate) fn vfs_path_to_file_id(
-    vfs: &vfs::Vfs,
-    vfs_path: &VfsPath,
-) -> anyhow::Result<Option<FileId>> {
+pub(crate) fn vfs_path_to_file_id(vfs: &vfs::Vfs, vfs_path: &VfsPath) -> anyhow::Result<Option<FileId>> {
     let (file_id, excluded) =
         vfs.file_id(vfs_path).ok_or_else(|| anyhow::format_err!("file not found: {vfs_path}"))?;
     match excluded {