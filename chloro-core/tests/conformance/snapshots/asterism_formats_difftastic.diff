COMPARISON DIFF
============================================================

Original size: 16579 bytes
Chloro size:   14888 bytes
Rustfmt size:  16579 bytes

✗ Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Difftastic format implementation for displaying structural diffs.
 //!
 //! This module provides support for parsing difftastic JSON output and
 //! converting it into sections that can be navigated and edited in asterism.
-
 use crate::formats::Format;
 use crate::section::{ChunkType, Section};
 use ratatui::{
 use std::path::Path;
 use std::{fs, io};
 
-/// Represents a file in difftastic output
 #[derive(Debug, Serialize, Deserialize)]
 pub struct DifftFile {
-    /// Programming language identified by difftastic for syntax highlighting.
     pub language: String,
-    /// File path relative to the comparison root.
     pub path: String,
-    /// Grouped diff hunks, each containing lines that changed together.
     #[serde(default)]
     pub chunks: Option<Vec<Vec<DifftLine>>>,
-    /// Change classification: "unchanged", "changed", "created", or "deleted".
     pub status: String,
 }
 
-/// Represents a line in a diff chunk
+
 #[derive(Debug, Serialize, Deserialize)]
 pub struct DifftLine {
-    /// Left-hand (original) side of the comparison, absent for pure additions.
     #[serde(skip_serializing_if = "Option::is_none")]
     pub lhs: Option<DifftSide>,
-    /// Right-hand (modified) side of the comparison, absent for pure deletions.
     #[serde(skip_serializing_if = "Option::is_none")]
     pub rhs: Option<DifftSide>,
 }
 
-/// Represents one side (left or right) of a diff line
+
 #[derive(Debug, Serialize, Deserialize)]
 pub struct DifftSide {
-    /// Original line position in the source file (1-indexed).
     pub line_number: u32,
-    /// Structural changes within this line, ordered by column position.
     pub changes: Vec<DifftChange>,
 }
 
-/// Represents a change within a line
+
 #[derive(Debug, Serialize, Deserialize)]
 pub struct DifftChange {
-    /// Column offset where this change begins (0-indexed).
     pub start: u32,
-    /// Column offset where this change ends (exclusive).
     pub end: u32,
-    /// Text content of this change segment.
     pub content: String,
-    /// Syntax category for rendering: "delimiter", "string", "keyword", "comment", "type", "normal"
-    /// or "`tree_sitter_error`".
     pub highlight: String,
 }
 
-/// Difftastic format handler
+
 pub struct DifftasticFormat;
 
-impl Format for DifftasticFormat {
-    fn file_extension(&self) -> &'static str {
+
+impl DifftasticFormat {
+    fn file_extension() -> &'static str {
         "diff"
     }
-
-    fn language(&self) -> tree_sitter::Language {
+    fn language() -> tree_sitter::Language {
         // Difftastic doesn't use tree-sitter parsing
         tree_sitter_md::LANGUAGE.into()
     }
-
-    fn section_query(&self) -> &'static str {
+    fn section_query() -> &'static str {
         ""
     }
-
-    fn title_query(&self) -> &'static str {
+    fn title_query() -> &'static str {
         ""
     }
-
-    fn format_section_display(&self, level: usize, title: &str) -> Line<'static> {
+    fn format_section_display(level: usize, title: &str) -> Line<'static> {
         // Check if this is a hunk header with format: (N) @@ -X,Y +A,B @@
         if title.contains("@@") && title.starts_with('(') {
             if let Some(close_paren) = title.find(')') {
                 return Line::from(spans);
             }
         }
-
         // For file nodes or other sections
         let color = if level == 0 {
             Color::Cyan // Files
         } else {
             Color::LightYellow // Hunks
         };
-
         let spans = vec![
             Span::styled("● ", Style::default().fg(color)),
             Span::raw(title.to_string()),
         ];
-
         Line::from(spans)
     }
 }
 
+
 impl DifftasticFormat {
-    /// Determine hunk color from the header string itself
     fn determine_hunk_color_from_header(header: &str) -> Color {
         // Parse @@ -X,Y +A,B @@
         if let Some(hunk_part) = header.strip_prefix("@@").and_then(|s| s.split("@@").next()) {
                 }
             }
         }
-        Color::LightYellow // Modification
+        Color::LightYellow
+        // Modification
     }
 }
 
+
 #[allow(clippy::too_many_arguments)]
-fn create_chunk_section(
-    file_path: &str,
-    title: String,
-    line_num: i64,
-    column_start: i64,
-    column_end: i64,
-    chunk_type: ChunkType,
-    lhs_text: Option<String>,
-    rhs_text: Option<String>,
-) -> Section {
+fn create_chunk_section(file_path: &str, title: String, line_num: i64, column_start: i64, column_end: i64, chunk_type: ChunkType, lhs_text: Option<String>, rhs_text: Option<String>) -> Section {
     Section {
         title,
         level: 2,
     }
 }
 
-/// Parse difftastic JSON output into sections
-///
-/// Files become non-navigable containers, hunks become navigable sections.
-///
-/// # Errors
-///
-/// Returns an error if JSON parsing fails or if the format is invalid.
+
 pub fn parse_difftastic_json(json_str: &str) -> io::Result<Vec<Section>> {
     let files: Vec<DifftFile> = if let Ok(files) = serde_json::from_str::<Vec<DifftFile>>(json_str)
     {
             })
             .collect::<Result<Vec<DifftFile>, io::Error>>()?
     };
-
     let mut sections = Vec::new();
     let mut global_line = 0i64;
-
     for file in &files {
         // Skip unchanged files
         if file.status == "unchanged" {
             global_line += i64::try_from(line_count).unwrap_or(0) + 1;
         }
     }
-
     Ok(sections)
 }
 
-/// Format a change as a proper git diff hunk header
+
 fn format_hunk_header(change: &DifftLine, hunk_num: usize) -> String {
     let (lhs_line, rhs_line) = match (&change.lhs, &change.rhs) {
         (Some(lhs), Some(rhs)) => (lhs.line_number, rhs.line_number),
         (None, Some(rhs)) => (0, rhs.line_number),
         _ => (0, 0),
     };
-
     // Determine chunk size (for now, single line changes)
     let lhs_count = i32::from(change.lhs.is_some());
     let rhs_count = i32::from(change.rhs.is_some());
-
     format!("({hunk_num}) @@ -{lhs_line},{lhs_count} +{rhs_line},{rhs_count} @@")
 }
 
-/// Format a single change for display
+
 fn format_change_content(change: &DifftLine) -> String {
     let mut output = String::new();
-
     match (&change.lhs, &change.rhs) {
         (Some(lhs), Some(rhs)) => {
             // Modified line - show both sides
             output.push_str(" \n");
         }
     }
-
     output
 }
 
+
 fn extract_chunk_text(side: &Value) -> Option<String> {
     side.get("changes")
         .and_then(|c| c.as_array())
         })
 }
 
+
 fn extract_column_range(side: &Value) -> (i64, i64) {
     let changes = side.get("changes").and_then(|c| c.as_array());
-
     let start = changes
         .and_then(|arr| arr.first())
         .and_then(|first| first.get("start"))
         .and_then(serde_json::Value::as_i64)
         .unwrap_or(0);
-
     let end = changes
         .and_then(|arr| arr.last())
         .and_then(|last| last.get("end"))
         .and_then(serde_json::Value::as_i64)
         .unwrap_or(0);
-
     (start, end)
 }
 
-/// Extract the difftastic hunks as sections (same as sections in a markdown etc)
-///
-/// # Errors
-///
-/// Returns an error if the JSON file cannot be read from disk.
+
 pub fn extract_difftastic_sections(json_path: &Path) -> io::Result<Vec<Section>> {
     let content = fs::read_to_string(json_path)?;
     let lines: Vec<Value> = content
         .lines()
         .filter_map(|line| serde_json::from_str(line).ok())
         .collect();
-
     let mut sections = Vec::new();
-
     for value in lines {
         let file_path = value
             .get("path")
             }
         }
     }
-
     Ok(sections)
 }
 
+
 #[cfg(test)]
 #[path = "../tests/difftastic.rs"]
 mod tests;
+