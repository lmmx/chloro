COMPARISON DIFF
============================================================

Original size: 4854 bytes
Chloro size:   4783 bytes
Rustfmt size:  4854 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Code common to structs, unions, and enum variants.
 
-use crate::context::CompletionContext;
 use hir::{HasAttrs, HasCrate, HasVisibility, HirDisplay, StructKind, sym};
 use ide_db::SnippetCap;
 use itertools::Itertools;
 use syntax::SmolStr;
 
+use crate::context::CompletionContext;
+
 /// A rendered struct, union, or enum variant, split into fields for actual
 /// auto-completion (`literal`, using `field: ()`) and display in the
 /// completions menu (`detail`, using `field: type`).
 
 /// Render a record type (or sub-type) to a `RenderedCompound`. Use `None` for
 /// the `name` argument for an anonymous type.
-pub(crate) fn render_record_lit(
-    ctx: &CompletionContext<'_>,
-    snippet_cap: Option<SnippetCap>,
-    fields: &[hir::Field],
-    path: &str,
-) -> RenderedLiteral {
+pub(crate) fn render_record_lit(ctx: &CompletionContext<'_>, snippet_cap: Option<SnippetCap>, fields: &[hir::Field], path: &str) -> RenderedLiteral {
     if snippet_cap.is_none() {
         return RenderedLiteral { literal: path.to_owned(), detail: path.to_owned() };
     }
             fmt_field(format_args!("()"), format_args!(""))
         }
     });
-
     let types = fields.iter().format_with(", ", |field, f| {
         f(&format_args!(
             "{}: {}",
             field.ty(ctx.db).display(ctx.db, ctx.display_target)
         ))
     });
-
     RenderedLiteral {
         literal: format!("{path} {{ {completions} }}"),
         detail: format!("{path} {{ {types} }}"),
 
 /// Render a tuple type (or sub-type) to a `RenderedCompound`. Use `None` for
 /// the `name` argument for an anonymous type.
-pub(crate) fn render_tuple_lit(
-    ctx: &CompletionContext<'_>,
-    snippet_cap: Option<SnippetCap>,
-    fields: &[hir::Field],
-    path: &str,
-) -> RenderedLiteral {
+pub(crate) fn render_tuple_lit(ctx: &CompletionContext<'_>, snippet_cap: Option<SnippetCap>, fields: &[hir::Field], path: &str) -> RenderedLiteral {
     if snippet_cap.is_none() {
         return RenderedLiteral { literal: path.to_owned(), detail: path.to_owned() };
     }
             f(&format_args!("()"))
         }
     });
-
     let types = fields
         .iter()
         .format_with(", ", |field, f| f(&field.ty(ctx.db).display(ctx.db, ctx.display_target)));
-
     RenderedLiteral {
         literal: format!("{path}({completions})"),
         detail: format!("{path}({types})"),
 /// Find all the visible fields in a given list. Returns the list of visible
 /// fields, plus a boolean for whether the list is comprehensive (contains no
 /// private fields and its item is not marked `#[non_exhaustive]`).
-pub(crate) fn visible_fields(
-    ctx: &CompletionContext<'_>,
-    fields: &[hir::Field],
-    item: impl HasAttrs + HasCrate + Copy,
-) -> Option<(Vec<hir::Field>, bool)> {
+pub(crate) fn visible_fields(ctx: &CompletionContext<'_>, fields: &[hir::Field], item: impl HasAttrs + HasCrate + Copy) -> Option<(Vec<hir::Field>, bool)> {
     let module = ctx.module;
     let n_fields = fields.len();
     let fields = fields
 }
 
 /// Format a struct, etc. literal option for display in the completions menu.
-pub(crate) fn format_literal_label(
-    name: &str,
-    kind: StructKind,
-    snippet_cap: Option<SnippetCap>,
-) -> SmolStr {
+pub(crate) fn format_literal_label(name: &str, kind: StructKind, snippet_cap: Option<SnippetCap>) -> SmolStr {
     if snippet_cap.is_none() {
         return name.into();
     }