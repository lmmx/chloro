COMPARISON DIFF
============================================================

Original size: 44130 bytes
Chloro size:   43215 bytes
Rustfmt size:  44130 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! `NameDefinition` keeps information about the element we want to search references for.
 //! The element is represented by `NameKind`. It's located inside some `container` and
 //! has a `visibility`, which defines a search scope.
 //! Note that the reference search is possible for not all of the classified items.
 
-// FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).
-
-use crate::RootDatabase;
-use crate::documentation::{DocsRangeMap, Documentation, HasDocs};
-use crate::famous_defs::FamousDefs;
 use arrayvec::ArrayVec;
 use either::Either;
 use hir::{
     match_ast,
 };
 
-// FIXME: a more precise name would probably be `Symbol`?
+use crate::RootDatabase;
+use crate::documentation::{DocsRangeMap, Documentation, HasDocs};
+use crate::famous_defs::FamousDefs;
+
 #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]
 pub enum Definition {
     Macro(Macro),
         Some(name)
     }
 
-    pub fn docs(
-        &self,
-        db: &RootDatabase,
-        famous_defs: Option<&FamousDefs<'_, '_>>,
-        display_target: DisplayTarget,
-    ) -> Option<Documentation> {
+    pub fn docs(&self, db: &RootDatabase, famous_defs: Option<&FamousDefs<'_, '_>>, display_target: DisplayTarget) -> Option<Documentation> {
         self.docs_with_rangemap(db, famous_defs, display_target).map(|(docs, _)| docs)
     }
 
-    pub fn docs_with_rangemap(
-        &self,
-        db: &RootDatabase,
-        famous_defs: Option<&FamousDefs<'_, '_>>,
-        display_target: DisplayTarget,
-    ) -> Option<(Documentation, Option<DocsRangeMap>)> {
+    pub fn docs_with_rangemap(&self, db: &RootDatabase, famous_defs: Option<&FamousDefs<'_, '_>>, display_target: DisplayTarget) -> Option<(Documentation, Option<DocsRangeMap>)> {
         let docs = match self {
             Definition::Macro(it) => it.docs_with_rangemap(db),
             Definition::Field(it) => it.docs_with_rangemap(db),
             Definition::TupleField(_) => None,
             Definition::InlineAsmRegOrRegClass(_) | Definition::InlineAsmOperand(_) => None,
         };
-
         docs.or_else(|| {
             // docs are missing, for assoc items of trait impls try to fall back to the docs of the
             // original item of the trait
     }
 }
 
-pub fn find_std_module(
-    famous_defs: &FamousDefs<'_, '_>,
-    name: &str,
-    edition: Edition,
-) -> Option<hir::Module> {
+pub fn find_std_module(famous_defs: &FamousDefs<'_, '_>, name: &str, edition: Edition) -> Option<hir::Module> {
     let db = famous_defs.0.db;
     let std_crate = famous_defs.std()?;
     let std_root_module = std_crate.root_module();
     })
 }
 
-// FIXME: IdentClass as a name no longer fits
 #[derive(Debug)]
 pub enum IdentClass<'db> {
     NameClass(NameClass<'db>),
 }
 
 impl<'db> IdentClass<'db> {
-    pub fn classify_node(
-        sema: &Semantics<'db, RootDatabase>,
-        node: &SyntaxNode,
-    ) -> Option<IdentClass<'db>> {
+    pub fn classify_node(sema: &Semantics<'db, RootDatabase>, node: &SyntaxNode) -> Option<IdentClass<'db>> {
         match_ast! {
             match node {
                 ast::Name(name) => NameClass::classify(sema, &name).map(IdentClass::NameClass),
         }
     }
 
-    pub fn classify_token(
-        sema: &Semantics<'db, RootDatabase>,
-        token: &SyntaxToken,
-    ) -> Option<IdentClass<'db>> {
+    pub fn classify_token(sema: &Semantics<'db, RootDatabase>, token: &SyntaxToken) -> Option<IdentClass<'db>> {
         let parent = token.parent()?;
         Self::classify_node(sema, &parent)
     }
 
-    pub fn classify_lifetime(
-        sema: &Semantics<'db, RootDatabase>,
-        lifetime: &ast::Lifetime,
-    ) -> Option<IdentClass<'db>> {
+    pub fn classify_lifetime(sema: &Semantics<'db, RootDatabase>, lifetime: &ast::Lifetime) -> Option<IdentClass<'db>> {
         NameRefClass::classify_lifetime(sema, lifetime)
             .map(IdentClass::NameRefClass)
             .or_else(|| NameClass::classify_lifetime(sema, lifetime).map(IdentClass::NameClass))
         Some(res)
     }
 
-    pub fn classify(
-        sema: &Semantics<'db, RootDatabase>,
-        name: &ast::Name,
-    ) -> Option<NameClass<'db>> {
+    pub fn classify(sema: &Semantics<'db, RootDatabase>, name: &ast::Name) -> Option<NameClass<'db>> {
         let _p = tracing::info_span!("NameClass::classify").entered();
-
         let parent = name.syntax().parent()?;
         let definition = match_ast! {
             match parent {
             }
         };
         return Some(NameClass::Definition(definition));
-
         fn classify_item(
             sema: &Semantics<'_, RootDatabase>,
             item: ast::Item,
             };
             Some(definition)
         }
-
         fn classify_ident_pat<'db>(
             sema: &Semantics<'db, RootDatabase>,
             ident_pat: ast::IdentPat,
             }
             Some(NameClass::Definition(Definition::Local(local)))
         }
-
         fn classify_rename(
             sema: &Semantics<'_, RootDatabase>,
             rename: ast::Rename,
         }
     }
 
-    pub fn classify_lifetime(
-        sema: &Semantics<'db, RootDatabase>,
-        lifetime: &ast::Lifetime,
-    ) -> Option<NameClass<'db>> {
+    pub fn classify_lifetime(sema: &Semantics<'db, RootDatabase>, lifetime: &ast::Lifetime) -> Option<NameClass<'db>> {
         let _p = tracing::info_span!("NameClass::classify_lifetime", ?lifetime).entered();
         let parent = lifetime.syntax().parent()?;
-
         if let Some(it) = ast::LifetimeParam::cast(parent.clone()) {
             sema.to_def(&it).map(Into::into).map(Definition::GenericParam)
         } else if let Some(it) = ast::Label::cast(parent) {
 }
 
 impl OperatorClass {
-    pub fn classify_range_pat(
-        sema: &Semantics<'_, RootDatabase>,
-        range_pat: &ast::RangePat,
-    ) -> Option<OperatorClass> {
+    pub fn classify_range_pat(sema: &Semantics<'_, RootDatabase>, range_pat: &ast::RangePat) -> Option<OperatorClass> {
         sema.resolve_range_pat(range_pat).map(OperatorClass::Range)
     }
 
-    pub fn classify_range_expr(
-        sema: &Semantics<'_, RootDatabase>,
-        range_expr: &ast::RangeExpr,
-    ) -> Option<OperatorClass> {
+    pub fn classify_range_expr(sema: &Semantics<'_, RootDatabase>, range_expr: &ast::RangeExpr) -> Option<OperatorClass> {
         sema.resolve_range_expr(range_expr).map(OperatorClass::Range)
     }
 
-    pub fn classify_await(
-        sema: &Semantics<'_, RootDatabase>,
-        await_expr: &ast::AwaitExpr,
-    ) -> Option<OperatorClass> {
+    pub fn classify_await(sema: &Semantics<'_, RootDatabase>, await_expr: &ast::AwaitExpr) -> Option<OperatorClass> {
         sema.resolve_await_to_poll(await_expr).map(OperatorClass::Await)
     }
 
-    pub fn classify_prefix(
-        sema: &Semantics<'_, RootDatabase>,
-        prefix_expr: &ast::PrefixExpr,
-    ) -> Option<OperatorClass> {
+    pub fn classify_prefix(sema: &Semantics<'_, RootDatabase>, prefix_expr: &ast::PrefixExpr) -> Option<OperatorClass> {
         sema.resolve_prefix_expr(prefix_expr).map(OperatorClass::Prefix)
     }
 
-    pub fn classify_try(
-        sema: &Semantics<'_, RootDatabase>,
-        try_expr: &ast::TryExpr,
-    ) -> Option<OperatorClass> {
+    pub fn classify_try(sema: &Semantics<'_, RootDatabase>, try_expr: &ast::TryExpr) -> Option<OperatorClass> {
         sema.resolve_try_expr(try_expr).map(OperatorClass::Try)
     }
 
-    pub fn classify_index(
-        sema: &Semantics<'_, RootDatabase>,
-        index_expr: &ast::IndexExpr,
-    ) -> Option<OperatorClass> {
+    pub fn classify_index(sema: &Semantics<'_, RootDatabase>, index_expr: &ast::IndexExpr) -> Option<OperatorClass> {
         sema.resolve_index_expr(index_expr).map(OperatorClass::Index)
     }
 
-    pub fn classify_bin(
-        sema: &Semantics<'_, RootDatabase>,
-        bin_expr: &ast::BinExpr,
-    ) -> Option<OperatorClass> {
+    pub fn classify_bin(sema: &Semantics<'_, RootDatabase>, bin_expr: &ast::BinExpr) -> Option<OperatorClass> {
         sema.resolve_bin_expr(bin_expr).map(OperatorClass::Bin)
     }
 }
 }
 
 impl<'db> NameRefClass<'db> {
-    // Note: we don't have unit-tests for this rather important function.
-    // It is primarily exercised via goto definition tests in `ide`.
-    pub fn classify(
-        sema: &Semantics<'db, RootDatabase>,
-        name_ref: &ast::NameRef,
-    ) -> Option<NameRefClass<'db>> {
+    pub fn classify(sema: &Semantics<'db, RootDatabase>, name_ref: &ast::NameRef) -> Option<NameRefClass<'db>> {
         let _p = tracing::info_span!("NameRefClass::classify", ?name_ref).entered();
-
         let parent = name_ref.syntax().parent()?;
-
         if let Some(record_field) = ast::RecordExprField::for_field_name(name_ref)
             && let Some((field, local, _, adt_subst)) =
                 sema.resolve_record_field_with_substitution(&record_field)
             };
             return Some(res);
         }
-
         if let Some(path) = ast::PathSegment::cast(parent.clone()).map(|it| it.parent_path()) {
             if path.parent_path().is_none()
                 && let Some(macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast)
                 .resolve_path_with_subst(&path)
                 .map(|(res, subst)| NameRefClass::Definition(res.into(), subst));
         }
-
         match_ast! {
             match parent {
                 ast::MethodCallExpr(method_call) => {
         }
     }
 
-    pub fn classify_lifetime(
-        sema: &Semantics<'db, RootDatabase>,
-        lifetime: &ast::Lifetime,
-    ) -> Option<NameRefClass<'db>> {
+    pub fn classify_lifetime(sema: &Semantics<'db, RootDatabase>, lifetime: &ast::Lifetime) -> Option<NameRefClass<'db>> {
         let _p = tracing::info_span!("NameRefClass::classify_lifetime", ?lifetime).entered();
         if lifetime.text() == "'static" {
             return Some(NameRefClass::Definition(
         }
     }
 }
-
-impl_from!(
-    Field, Module, Function, Adt, Variant, Const, Static, Trait, TypeAlias, BuiltinType, Local,
-    GenericParam, Label, Macro, ExternCrateDecl
-    for Definition
-);
-
 impl From<Impl> for Definition {
     fn from(impl_: Impl) -> Self {
         Definition::SelfType(impl_)
 
 impl TryFrom<DefWithBody> for Definition {
     type Error = ();
+
     fn try_from(def: DefWithBody) -> Result<Self, Self::Error> {
         match def {
             DefWithBody::Function(it) => Ok(it.into()),
 
 impl TryFrom<Definition> for GenericDef {
     type Error = ();
+
     fn try_from(def: Definition) -> Result<Self, Self::Error> {
         match def {
             Definition::Function(it) => Ok(it.into()),