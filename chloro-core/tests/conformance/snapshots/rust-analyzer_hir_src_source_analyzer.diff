COMPARISON DIFF
============================================================

Original size: 72179 bytes
Chloro size:   70204 bytes
Rustfmt size:  72179 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //!
 //! So, this modules should not be used during hir construction, it exists
 //! purely for "IDE needs".
+
 use std::iter::{self, once};
 
 use either::Either;
         source_map: Arc<BodySourceMap>,
         infer: Option<Arc<InferenceResult<'db>>>,
     },
-    // To be folded into body once it is considered one
     VariantFields {
         def: VariantId,
         store: Arc<ExpressionStore>,
         def: GenericDefId,
         store: Arc<ExpressionStore>,
         source_map: Arc<ExpressionStoreSourceMap>,
-        // infer: Option<Arc<InferenceResult>>,
     },
 }
 
 impl<'db> SourceAnalyzer<'db> {
-    pub(crate) fn new_for_body(
-        db: &'db dyn HirDatabase,
-        def: DefWithBodyId,
-        node: InFile<&SyntaxNode>,
-        offset: Option<TextSize>,
-    ) -> SourceAnalyzer<'db> {
+    pub(crate) fn new_for_body(db: &'db dyn HirDatabase, def: DefWithBodyId, node: InFile<&SyntaxNode>, offset: Option<TextSize>) -> SourceAnalyzer<'db> {
         Self::new_for_body_(db, def, node, offset, Some(db.infer(def)))
     }
 
-    pub(crate) fn new_for_body_no_infer(
-        db: &'db dyn HirDatabase,
-        def: DefWithBodyId,
-        node: InFile<&SyntaxNode>,
-        offset: Option<TextSize>,
-    ) -> SourceAnalyzer<'db> {
+    pub(crate) fn new_for_body_no_infer(db: &'db dyn HirDatabase, def: DefWithBodyId, node: InFile<&SyntaxNode>, offset: Option<TextSize>) -> SourceAnalyzer<'db> {
         Self::new_for_body_(db, def, node, offset, None)
     }
 
-    pub(crate) fn new_for_body_(
-        db: &'db dyn HirDatabase,
-        def: DefWithBodyId,
-        node @ InFile { file_id, .. }: InFile<&SyntaxNode>,
-        offset: Option<TextSize>,
-        infer: Option<Arc<InferenceResult<'db>>>,
-    ) -> SourceAnalyzer<'db> {
+    pub(crate) fn new_for_body_(db: &'db dyn HirDatabase, def: DefWithBodyId, node @ InFile { file_id, .. }: InFile<&SyntaxNode>, offset: Option<TextSize>, infer: Option<Arc<InferenceResult<'db>>>) -> SourceAnalyzer<'db> {
         let (body, source_map) = db.body_with_source_map(def);
         let scopes = db.expr_scopes(def);
         let scope = match offset {
         }
     }
 
-    pub(crate) fn new_generic_def(
-        db: &'db dyn HirDatabase,
-        def: GenericDefId,
-        InFile { file_id, .. }: InFile<&SyntaxNode>,
-        _offset: Option<TextSize>,
-    ) -> SourceAnalyzer<'db> {
+    pub(crate) fn new_generic_def(db: &'db dyn HirDatabase, def: GenericDefId, InFile { file_id, .. }: InFile<&SyntaxNode>, _offset: Option<TextSize>) -> SourceAnalyzer<'db> {
         let (_params, store, source_map) = db.generic_params_and_store_and_source_map(def);
         let resolver = def.resolver(db);
         SourceAnalyzer {
         }
     }
 
-    pub(crate) fn new_variant_body(
-        db: &'db dyn HirDatabase,
-        def: VariantId,
-        InFile { file_id, .. }: InFile<&SyntaxNode>,
-        _offset: Option<TextSize>,
-    ) -> SourceAnalyzer<'db> {
+    pub(crate) fn new_variant_body(db: &'db dyn HirDatabase, def: VariantId, InFile { file_id, .. }: InFile<&SyntaxNode>, _offset: Option<TextSize>) -> SourceAnalyzer<'db> {
         let (fields, source_map) = def.fields_with_source_map(db);
         let resolver = def.resolver(db);
         SourceAnalyzer {
         }
     }
 
-    pub(crate) fn new_for_resolver(
-        resolver: Resolver<'db>,
-        node: InFile<&SyntaxNode>,
-    ) -> SourceAnalyzer<'db> {
+    pub(crate) fn new_for_resolver(resolver: Resolver<'db>, node: InFile<&SyntaxNode>) -> SourceAnalyzer<'db> {
         SourceAnalyzer { resolver, body_or_sig: None, file_id: node.file_id }
     }
 
-    // FIXME: Remove this
-    fn body_(
-        &self,
-    ) -> Option<(DefWithBodyId, &Body, &BodySourceMap, Option<&InferenceResult<'db>>)> {
+    fn body_(&self) -> Option<(DefWithBodyId, &Body, &BodySourceMap, Option<&InferenceResult<'db>>)> {
         self.body_or_sig.as_ref().and_then(|it| match it {
             BodyOrSig::Body { def, body, source_map, infer } => {
                 Some((*def, &**body, &**source_map, infer.as_deref()))
         infer.expr_adjustment(expr_id)
     }
 
-    pub(crate) fn type_of_type(
-        &self,
-        db: &'db dyn HirDatabase,
-        ty: &ast::Type,
-    ) -> Option<Type<'db>> {
+    pub(crate) fn type_of_type(&self, db: &'db dyn HirDatabase, ty: &ast::Type) -> Option<Type<'db>> {
         let type_ref = self.type_id(ty)?;
         let ty = TyLoweringContext::new(
             db,
         Some(Type::new_with_resolver(db, &self.resolver, ty))
     }
 
-    pub(crate) fn type_of_expr(
-        &self,
-        db: &'db dyn HirDatabase,
-        expr: &ast::Expr,
-    ) -> Option<(Type<'db>, Option<Type<'db>>)> {
+    pub(crate) fn type_of_expr(&self, db: &'db dyn HirDatabase, expr: &ast::Expr) -> Option<(Type<'db>, Option<Type<'db>>)> {
         let expr_id = self.expr_id(expr.clone())?;
         let infer = self.infer()?;
         let coerced = expr_id
         Some((mk_ty(ty), coerced.map(mk_ty)))
     }
 
-    pub(crate) fn type_of_pat(
-        &self,
-        db: &'db dyn HirDatabase,
-        pat: &ast::Pat,
-    ) -> Option<(Type<'db>, Option<Type<'db>>)> {
+    pub(crate) fn type_of_pat(&self, db: &'db dyn HirDatabase, pat: &ast::Pat) -> Option<(Type<'db>, Option<Type<'db>>)> {
         let expr_or_pat_id = self.pat_id(pat)?;
         let infer = self.infer()?;
         let coerced = match expr_or_pat_id {
                 infer.pat_adjustment(idx).and_then(|adjusts| adjusts.last().cloned())
             }
         };
-
         let ty = infer[expr_or_pat_id];
         let mk_ty = |ty: Ty<'db>| Type::new_with_resolver(db, &self.resolver, ty);
         Some((mk_ty(ty), coerced.map(mk_ty)))
     }
 
-    pub(crate) fn type_of_binding_in_pat(
-        &self,
-        db: &'db dyn HirDatabase,
-        pat: &ast::IdentPat,
-    ) -> Option<Type<'db>> {
+    pub(crate) fn type_of_binding_in_pat(&self, db: &'db dyn HirDatabase, pat: &ast::IdentPat) -> Option<Type<'db>> {
         let binding_id = self.binding_id_of_pat(pat)?;
         let infer = self.infer()?;
         let ty = infer[binding_id];
         Some(mk_ty(ty))
     }
 
-    pub(crate) fn type_of_self(
-        &self,
-        db: &'db dyn HirDatabase,
-        _param: &ast::SelfParam,
-    ) -> Option<Type<'db>> {
+    pub(crate) fn type_of_self(&self, db: &'db dyn HirDatabase, _param: &ast::SelfParam) -> Option<Type<'db>> {
         let binding = self.body()?.self_param?;
         let ty = self.infer()?[binding];
         Some(Type::new_with_resolver(db, &self.resolver, ty))
     }
 
-    pub(crate) fn binding_mode_of_pat(
-        &self,
-        _db: &'db dyn HirDatabase,
-        pat: &ast::IdentPat,
-    ) -> Option<BindingMode> {
+    pub(crate) fn binding_mode_of_pat(&self, _db: &'db dyn HirDatabase, pat: &ast::IdentPat) -> Option<BindingMode> {
         let id = self.pat_id(&pat.clone().into())?;
         let infer = self.infer()?;
         infer.binding_mode(id.as_pat()?).map(|bm| match bm {
             }
         })
     }
-    pub(crate) fn pattern_adjustments(
-        &self,
-        db: &'db dyn HirDatabase,
-        pat: &ast::Pat,
-    ) -> Option<SmallVec<[Type<'db>; 1]>> {
+
+    pub(crate) fn pattern_adjustments(&self, db: &'db dyn HirDatabase, pat: &ast::Pat) -> Option<SmallVec<[Type<'db>; 1]>> {
         let pat_id = self.pat_id(pat)?;
         let infer = self.infer()?;
         Some(
         )
     }
 
-    pub(crate) fn resolve_method_call_as_callable(
-        &self,
-        db: &'db dyn HirDatabase,
-        call: &ast::MethodCallExpr,
-    ) -> Option<Callable<'db>> {
+    pub(crate) fn resolve_method_call_as_callable(&self, db: &'db dyn HirDatabase, call: &ast::MethodCallExpr) -> Option<Callable<'db>> {
         let expr_id = self.expr_id(call.clone().into())?.as_expr()?;
         let (func, args) = self.infer()?.method_resolution(expr_id)?;
         let interner = DbInterner::new_with(db, None, None);
         Some(res)
     }
 
-    pub(crate) fn resolve_method_call(
-        &self,
-        db: &'db dyn HirDatabase,
-        call: &ast::MethodCallExpr,
-    ) -> Option<Function> {
+    pub(crate) fn resolve_method_call(&self, db: &'db dyn HirDatabase, call: &ast::MethodCallExpr) -> Option<Function> {
         let expr_id = self.expr_id(call.clone().into())?.as_expr()?;
         let (f_in_trait, substs) = self.infer()?.method_resolution(expr_id)?;
-
         Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, substs).into())
     }
 
-    pub(crate) fn resolve_method_call_fallback(
-        &self,
-        db: &'db dyn HirDatabase,
-        call: &ast::MethodCallExpr,
-    ) -> Option<(Either<Function, Field>, Option<GenericSubstitution<'db>>)> {
+    pub(crate) fn resolve_method_call_fallback(&self, db: &'db dyn HirDatabase, call: &ast::MethodCallExpr) -> Option<(Either<Function, Field>, Option<GenericSubstitution<'db>>)> {
         let expr_id = self.expr_id(call.clone().into())?.as_expr()?;
         let inference_result = self.infer()?;
         match inference_result.method_resolution(expr_id) {
         }
     }
 
-    pub(crate) fn resolve_expr_as_callable(
-        &self,
-        db: &'db dyn HirDatabase,
-        call: &ast::Expr,
-    ) -> Option<Callable<'db>> {
+    pub(crate) fn resolve_expr_as_callable(&self, db: &'db dyn HirDatabase, call: &ast::Expr) -> Option<Callable<'db>> {
         let (orig, adjusted) = self.type_of_expr(db, &call.clone())?;
         adjusted.unwrap_or(orig).as_callable(db)
     }
 
-    pub(crate) fn resolve_field(
-        &self,
-        field: &ast::FieldExpr,
-    ) -> Option<Either<Field, TupleField>> {
+    pub(crate) fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Either<Field, TupleField>> {
         let (def, ..) = self.body_()?;
         let expr_id = self.expr_id(field.clone().into())?.as_expr()?;
         self.infer()?.field_resolution(expr_id).map(|it| {
         })
     }
 
-    fn field_subst(
-        &self,
-        field_expr: ExprId,
-        infer: &InferenceResult<'db>,
-        db: &'db dyn HirDatabase,
-    ) -> Option<GenericSubstitution<'db>> {
+    fn field_subst(&self, field_expr: ExprId, infer: &InferenceResult<'db>, db: &'db dyn HirDatabase) -> Option<GenericSubstitution<'db>> {
         let body = self.store()?;
         if let Expr::Field { expr: object_expr, name: _ } = body[field_expr] {
             let (adt, subst) = infer.type_of_expr_with_adjust(object_expr)?.as_adt()?;
         None
     }
 
-    pub(crate) fn resolve_field_fallback(
-        &self,
-        db: &'db dyn HirDatabase,
-        field: &ast::FieldExpr,
-    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)>
-    {
+    pub(crate) fn resolve_field_fallback(&self, db: &'db dyn HirDatabase, field: &ast::FieldExpr) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)> {
         let (def, ..) = self.body_()?;
         let expr_id = self.expr_id(field.clone().into())?.as_expr()?;
         let inference_result = self.infer()?;
         }
     }
 
-    pub(crate) fn resolve_range_pat(
-        &self,
-        db: &'db dyn HirDatabase,
-        range_pat: &ast::RangePat,
-    ) -> Option<StructId> {
+    pub(crate) fn resolve_range_pat(&self, db: &'db dyn HirDatabase, range_pat: &ast::RangePat) -> Option<StructId> {
         let path: ModPath = match (range_pat.op_kind()?, range_pat.start(), range_pat.end()) {
             (RangeOp::Exclusive, None, Some(_)) => path![core::ops::RangeTo],
             (RangeOp::Exclusive, Some(_), None) => path![core::ops::RangeFrom],
         self.resolver.resolve_known_struct(db, &path)
     }
 
-    pub(crate) fn resolve_range_expr(
-        &self,
-        db: &'db dyn HirDatabase,
-        range_expr: &ast::RangeExpr,
-    ) -> Option<StructId> {
+    pub(crate) fn resolve_range_expr(&self, db: &'db dyn HirDatabase, range_expr: &ast::RangeExpr) -> Option<StructId> {
         let path: ModPath = match (range_expr.op_kind()?, range_expr.start(), range_expr.end()) {
             (RangeOp::Exclusive, None, None) => path![core::ops::RangeFull],
             (RangeOp::Exclusive, None, Some(_)) => path![core::ops::RangeTo],
         self.resolver.resolve_known_struct(db, &path)
     }
 
-    pub(crate) fn resolve_await_to_poll(
-        &self,
-        db: &'db dyn HirDatabase,
-        await_expr: &ast::AwaitExpr,
-    ) -> Option<FunctionId> {
+    pub(crate) fn resolve_await_to_poll(&self, db: &'db dyn HirDatabase, await_expr: &ast::AwaitExpr) -> Option<FunctionId> {
         let mut ty = self.ty_of_expr(await_expr.expr()?)?;
-
         let into_future_trait = self
             .resolver
             .resolve_known_trait(db, &path![core::future::IntoFuture])
             .map(Trait::from);
-
         if let Some(into_future_trait) = into_future_trait {
             let type_ = Type::new_with_resolver(db, &self.resolver, ty);
             if type_.impls_trait(db, into_future_trait, &[]) {
                 ty = future_trait.ty;
             }
         }
-
         let poll_fn = LangItem::FuturePoll.resolve_function(db, self.resolver.krate())?;
         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself
         // doesn't have any generic parameters, so we skip building another subst for `poll()`.
         Some(self.resolve_impl_method_or_trait_def(db, poll_fn, substs))
     }
 
-    pub(crate) fn resolve_prefix_expr(
-        &self,
-        db: &'db dyn HirDatabase,
-        prefix_expr: &ast::PrefixExpr,
-    ) -> Option<FunctionId> {
+    pub(crate) fn resolve_prefix_expr(&self, db: &'db dyn HirDatabase, prefix_expr: &ast::PrefixExpr) -> Option<FunctionId> {
         let (_op_trait, op_fn) = match prefix_expr.op_kind()? {
             ast::UnaryOp::Deref => {
                 // This can be either `Deref::deref` or `DerefMut::deref_mut`.
                 self.lang_trait_fn(db, LangItem::Neg, &Name::new_symbol_root(sym::neg))?
             }
         };
-
         let ty = self.ty_of_expr(prefix_expr.expr()?)?;
-
         let interner = DbInterner::new_with(db, None, None);
         // HACK: subst for all methods coincides with that for their trait because the methods
         // don't have any generic parameters, so we skip building another subst for the methods.
         let substs = GenericArgs::new_from_iter(interner, [ty.into()]);
-
         Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))
     }
 
-    pub(crate) fn resolve_index_expr(
-        &self,
-        db: &'db dyn HirDatabase,
-        index_expr: &ast::IndexExpr,
-    ) -> Option<FunctionId> {
+    pub(crate) fn resolve_index_expr(&self, db: &'db dyn HirDatabase, index_expr: &ast::IndexExpr) -> Option<FunctionId> {
         let base_ty = self.ty_of_expr(index_expr.base()?)?;
         let index_ty = self.ty_of_expr(index_expr.index()?)?;
-
         let (_index_trait, index_fn) =
             self.lang_trait_fn(db, LangItem::Index, &Name::new_symbol_root(sym::index))?;
         let op_fn = self
         Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))
     }
 
-    pub(crate) fn resolve_bin_expr(
-        &self,
-        db: &'db dyn HirDatabase,
-        binop_expr: &ast::BinExpr,
-    ) -> Option<FunctionId> {
+    pub(crate) fn resolve_bin_expr(&self, db: &'db dyn HirDatabase, binop_expr: &ast::BinExpr) -> Option<FunctionId> {
         let op = binop_expr.op_kind()?;
         let lhs = self.ty_of_expr(binop_expr.lhs()?)?;
         let rhs = self.ty_of_expr(binop_expr.rhs()?)?;
-
         let (_op_trait, op_fn) = lang_items_for_bin_op(op)
             .and_then(|(name, lang_item)| self.lang_trait_fn(db, lang_item, &name))?;
         // HACK: subst for `index()` coincides with that for `Index` because `index()` itself
         // doesn't have any generic parameters, so we skip building another subst for `index()`.
         let interner = DbInterner::new_with(db, None, None);
         let substs = GenericArgs::new_from_iter(interner, [lhs.into(), rhs.into()]);
-
         Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))
     }
 
-    pub(crate) fn resolve_try_expr(
-        &self,
-        db: &'db dyn HirDatabase,
-        try_expr: &ast::TryExpr,
-    ) -> Option<FunctionId> {
+    pub(crate) fn resolve_try_expr(&self, db: &'db dyn HirDatabase, try_expr: &ast::TryExpr) -> Option<FunctionId> {
         let ty = self.ty_of_expr(try_expr.expr()?)?;
-
         let op_fn = LangItem::TryTraitBranch.resolve_function(db, self.resolver.krate())?;
         // HACK: subst for `branch()` coincides with that for `Try` because `branch()` itself
         // doesn't have any generic parameters, so we skip building another subst for `branch()`.
         let interner = DbInterner::new_with(db, None, None);
         let substs = GenericArgs::new_from_iter(interner, [ty.into()]);
-
         Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))
     }
 
-    pub(crate) fn resolve_record_field(
-        &self,
-        db: &'db dyn HirDatabase,
-        field: &ast::RecordExprField,
-    ) -> Option<(Field, Option<Local>, Type<'db>, GenericSubstitution<'db>)> {
+    pub(crate) fn resolve_record_field(&self, db: &'db dyn HirDatabase, field: &ast::RecordExprField) -> Option<(Field, Option<Local>, Type<'db>, GenericSubstitution<'db>)> {
         let record_expr = ast::RecordExpr::cast(field.syntax().parent().and_then(|p| p.parent())?)?;
         let expr = ast::Expr::from(record_expr);
         let expr_id = self.store_sm()?.node_expr(InFile::new(self.file_id, &expr))?;
         let interner = DbInterner::new_with(db, None, None);
-
         let ast_name = field.field_name()?;
         let local_name = ast_name.as_name();
         let local = if field.name_ref().is_some() {
         ))
     }
 
-    pub(crate) fn resolve_record_pat_field(
-        &self,
-        db: &'db dyn HirDatabase,
-        field: &ast::RecordPatField,
-    ) -> Option<(Field, Type<'db>, GenericSubstitution<'db>)> {
+    pub(crate) fn resolve_record_pat_field(&self, db: &'db dyn HirDatabase, field: &ast::RecordPatField) -> Option<(Field, Type<'db>, GenericSubstitution<'db>)> {
         let interner = DbInterner::new_with(db, None, None);
         let field_name = field.field_name()?.as_name();
         let record_pat = ast::RecordPat::cast(field.syntax().parent().and_then(|p| p.parent())?)?;
         ))
     }
 
-    pub(crate) fn resolve_bind_pat_to_const(
-        &self,
-        db: &'db dyn HirDatabase,
-        pat: &ast::IdentPat,
-    ) -> Option<ModuleDef> {
+    pub(crate) fn resolve_bind_pat_to_const(&self, db: &'db dyn HirDatabase, pat: &ast::IdentPat) -> Option<ModuleDef> {
         let expr_or_pat_id = self.pat_id(&pat.clone().into())?;
         let store = self.store()?;
-
         let path = match expr_or_pat_id {
             ExprOrPatId::ExprId(idx) => match &store[idx] {
                 Expr::Path(path) => path,
                 _ => return None,
             },
         };
-
         let body_owner = self.resolver.body_owner();
         let res = resolve_hir_value_path(db, &self.resolver, body_owner, path, HygieneId::ROOT)?;
         match res {
             .map(crate::TypeParam::from)
     }
 
-    pub(crate) fn resolve_offset_of_field(
-        &self,
-        db: &'db dyn HirDatabase,
-        name_ref: &ast::NameRef,
-    ) -> Option<(Either<crate::Variant, crate::Field>, GenericSubstitution<'db>)> {
+    pub(crate) fn resolve_offset_of_field(&self, db: &'db dyn HirDatabase, name_ref: &ast::NameRef) -> Option<(Either<crate::Variant, crate::Field>, GenericSubstitution<'db>)> {
         let offset_of_expr = ast::OffsetOfExpr::cast(name_ref.syntax().parent()?)?;
         let container = offset_of_expr.ty()?;
         let container = self.type_of_type(db, &container)?;
-
         let trait_env = container.env;
-
         let interner = DbInterner::new_with(db, Some(trait_env.krate), trait_env.block);
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
-
         let mut container = Either::Right(container.ty);
         for field_name in offset_of_expr.fields() {
             if let Either::Right(container) = &mut container {
         None
     }
 
-    pub(crate) fn resolve_path(
-        &self,
-        db: &'db dyn HirDatabase,
-        path: &ast::Path,
-    ) -> Option<(PathResolution, Option<GenericSubstitution<'db>>)> {
+    pub(crate) fn resolve_path(&self, db: &'db dyn HirDatabase, path: &ast::Path) -> Option<(PathResolution, Option<GenericSubstitution<'db>>)> {
         let parent = path.syntax().parent();
         let parent = || parent.clone();
-
         let mut prefer_value_ns = false;
         let resolved = (|| {
             let infer = self.infer()?;
         if resolved.is_some() {
             return resolved;
         }
-
         // FIXME: collectiong here shouldnt be necessary?
         let mut collector = ExprCollector::new(db, self.resolver.module(), self.file_id);
         let hir_path =
             .parent_path()
             .and_then(|p| collector.lower_path(p, &mut ExprCollector::impl_trait_error_allocator));
         let (store, _) = collector.store.finish();
-
         // Case where path is a qualifier of a use tree, e.g. foo::bar::{Baz, Qux} where we are
         // trying to resolve foo::bar.
         if let Some(use_tree) = parent().and_then(ast::UseTree::cast)
             return resolve_hir_path_qualifier(db, &self.resolver, &hir_path, &store)
                 .map(|it| (it, None));
         }
-
         let meta_path = path
             .syntax()
             .ancestors()
             })
             .last()
             .and_then(ast::Meta::cast);
-
         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we are
         // trying to resolve foo::bar.
         if let Some(parent_hir_path) = parent_hir_path {
         }
     }
 
-    pub(crate) fn resolve_hir_path_per_ns(
-        &self,
-        db: &dyn HirDatabase,
-        path: &ast::Path,
-    ) -> Option<PathResolutionPerNs> {
+    pub(crate) fn resolve_hir_path_per_ns(&self, db: &dyn HirDatabase, path: &ast::Path) -> Option<PathResolutionPerNs> {
         let mut collector = ExprCollector::new(db, self.resolver.module(), self.file_id);
         let hir_path =
             collector.lower_path(path.clone(), &mut ExprCollector::impl_trait_error_allocator)?;
         ))
     }
 
-    pub(crate) fn record_literal_missing_fields(
-        &self,
-        db: &'db dyn HirDatabase,
-        literal: &ast::RecordExpr,
-    ) -> Option<Vec<(Field, Type<'db>)>> {
+    pub(crate) fn record_literal_missing_fields(&self, db: &'db dyn HirDatabase, literal: &ast::RecordExpr) -> Option<Vec<(Field, Type<'db>)>> {
         let body = self.store()?;
         let infer = self.infer()?;
-
         let expr_id = self.expr_id(literal.clone().into())?;
         let substs = infer[expr_id].as_adt()?.1;
-
         let (variant, missing_fields, _exhaustive) = match expr_id {
             ExprOrPatId::ExprId(expr_id) => {
                 record_literal_missing_fields(db, infer, expr_id, &body[expr_id])?
         Some(res)
     }
 
-    pub(crate) fn record_pattern_missing_fields(
-        &self,
-        db: &'db dyn HirDatabase,
-        pattern: &ast::RecordPat,
-    ) -> Option<Vec<(Field, Type<'db>)>> {
+    pub(crate) fn record_pattern_missing_fields(&self, db: &'db dyn HirDatabase, pattern: &ast::RecordPat) -> Option<Vec<(Field, Type<'db>)>> {
         let body = self.store()?;
         let infer = self.infer()?;
-
         let pat_id = self.pat_id(&pattern.clone().into())?.as_pat()?;
         let substs = infer[pat_id].as_adt()?.1;
-
         let (variant, missing_fields, _exhaustive) =
             record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;
         let res = self.missing_fields(db, substs, variant, missing_fields);
         Some(res)
     }
 
-    fn missing_fields(
-        &self,
-        db: &'db dyn HirDatabase,
-        substs: GenericArgs<'db>,
-        variant: VariantId,
-        missing_fields: Vec<LocalFieldId>,
-    ) -> Vec<(Field, Type<'db>)> {
+    fn missing_fields(&self, db: &'db dyn HirDatabase, substs: GenericArgs<'db>, variant: VariantId, missing_fields: Vec<LocalFieldId>) -> Vec<(Field, Type<'db>)> {
         let interner = DbInterner::new_with(db, None, None);
         let field_types = db.field_types(variant);
-
         missing_fields
             .into_iter()
             .map(|local_id| {
         infer.variant_resolution_for_expr_or_pat(expr_id)
     }
 
-    pub(crate) fn is_unsafe_macro_call_expr(
-        &self,
-        db: &'db dyn HirDatabase,
-        macro_expr: InFile<&ast::MacroExpr>,
-    ) -> bool {
+    pub(crate) fn is_unsafe_macro_call_expr(&self, db: &'db dyn HirDatabase, macro_expr: InFile<&ast::MacroExpr>) -> bool {
         if let Some((def, body, sm, Some(infer))) = self.body_()
             && let Some(expanded_expr) = sm.macro_expansion_expr(macro_expr)
         {
     }
 
     /// Returns the range of the implicit template argument and its resolution at the given `offset`
-    pub(crate) fn resolve_offset_in_format_args(
-        &self,
-        db: &'db dyn HirDatabase,
-        format_args: InFile<&ast::FormatArgsExpr>,
-        offset: TextSize,
-    ) -> Option<(TextRange, Option<PathResolution>)> {
+    pub(crate) fn resolve_offset_in_format_args(&self, db: &'db dyn HirDatabase, format_args: InFile<&ast::FormatArgsExpr>, offset: TextSize) -> Option<(TextRange, Option<PathResolution>)> {
         let (hygiene, implicits) = self.store_sm()?.implicit_format_args(format_args)?;
         implicits.iter().find(|(range, _)| range.contains_inclusive(offset)).map(|(range, name)| {
             (
         })
     }
 
-    pub(crate) fn resolve_offset_in_asm_template(
-        &self,
-        asm: InFile<&ast::AsmExpr>,
-        line: usize,
-        offset: TextSize,
-    ) -> Option<(DefWithBodyId, (ExprId, TextRange, usize))> {
+    pub(crate) fn resolve_offset_in_asm_template(&self, asm: InFile<&ast::AsmExpr>, line: usize, offset: TextSize) -> Option<(DefWithBodyId, (ExprId, TextRange, usize))> {
         let (def, _, body_source_map, _) = self.body_()?;
         let (expr, args) = body_source_map.asm_template_args(asm)?;
         Some(def).zip(
         )
     }
 
-    pub(crate) fn as_format_args_parts<'a>(
-        &'a self,
-        db: &'a dyn HirDatabase,
-        format_args: InFile<&ast::FormatArgsExpr>,
-    ) -> Option<impl Iterator<Item = (TextRange, Option<PathResolution>)> + 'a> {
+    pub(crate) fn as_format_args_parts<'a>(&'a self, db: &'a dyn HirDatabase, format_args: InFile<&ast::FormatArgsExpr>) -> Option<impl Iterator<Item = (TextRange, Option<PathResolution>)> + 'a> {
         let (hygiene, names) = self.store_sm()?.implicit_format_args(format_args)?;
         Some(names.iter().map(move |(range, name)| {
             (
         }))
     }
 
-    pub(crate) fn as_asm_parts(
-        &self,
-        asm: InFile<&ast::AsmExpr>,
-    ) -> Option<(DefWithBodyId, (ExprId, &[Vec<(TextRange, usize)>]))> {
+    pub(crate) fn as_asm_parts(&self, asm: InFile<&ast::AsmExpr>) -> Option<(DefWithBodyId, (ExprId, &[Vec<(TextRange, usize)>]))> {
         let (def, _, body_source_map, _) = self.body_()?;
         Some(def).zip(body_source_map.asm_template_args(asm))
     }
 
-    fn resolve_impl_method_or_trait_def(
-        &self,
-        db: &'db dyn HirDatabase,
-        func: FunctionId,
-        substs: GenericArgs<'db>,
-    ) -> FunctionId {
+    fn resolve_impl_method_or_trait_def(&self, db: &'db dyn HirDatabase, func: FunctionId, substs: GenericArgs<'db>) -> FunctionId {
         self.resolve_impl_method_or_trait_def_with_subst(db, func, substs).0
     }
 
-    fn resolve_impl_method_or_trait_def_with_subst(
-        &self,
-        db: &'db dyn HirDatabase,
-        func: FunctionId,
-        substs: GenericArgs<'db>,
-    ) -> (FunctionId, GenericArgs<'db>) {
+    fn resolve_impl_method_or_trait_def_with_subst(&self, db: &'db dyn HirDatabase, func: FunctionId, substs: GenericArgs<'db>) -> (FunctionId, GenericArgs<'db>) {
         let owner = match self.resolver.body_owner() {
             Some(it) => it,
             None => return (func, substs),
         db.lookup_impl_method(env, func, substs)
     }
 
-    fn resolve_impl_const_or_trait_def_with_subst(
-        &self,
-        db: &'db dyn HirDatabase,
-        const_id: ConstId,
-        subs: GenericArgs<'db>,
-    ) -> (ConstId, GenericArgs<'db>) {
+    fn resolve_impl_const_or_trait_def_with_subst(&self, db: &'db dyn HirDatabase, const_id: ConstId, subs: GenericArgs<'db>) -> (ConstId, GenericArgs<'db>) {
         let owner = match self.resolver.body_owner() {
             Some(it) => it,
             None => return (const_id, subs),
         method_resolution::lookup_impl_const(&infcx, env, const_id, subs)
     }
 
-    fn lang_trait_fn(
-        &self,
-        db: &'db dyn HirDatabase,
-        lang_trait: LangItem,
-        method_name: &Name,
-    ) -> Option<(TraitId, FunctionId)> {
+    fn lang_trait_fn(&self, db: &'db dyn HirDatabase, lang_trait: LangItem, method_name: &Name) -> Option<(TraitId, FunctionId)> {
         let trait_id = lang_trait.resolve_trait(db, self.resolver.krate())?;
         let fn_id = trait_id.trait_items(db).method_by_name(method_name)?;
         Some((trait_id, fn_id))
     }
 }
 
-fn scope_for(
-    db: &dyn HirDatabase,
-    scopes: &ExprScopes,
-    source_map: &BodySourceMap,
-    node: InFile<&SyntaxNode>,
-) -> Option<ScopeId> {
+fn scope_for(db: &dyn HirDatabase, scopes: &ExprScopes, source_map: &BodySourceMap, node: InFile<&SyntaxNode>) -> Option<ScopeId> {
     node.ancestors_with_macros(db)
         .take_while(|it| {
             let kind = it.kind();
         .find_map(|it| scopes.scope_for(it))
 }
 
-fn scope_for_offset(
-    db: &dyn HirDatabase,
-    scopes: &ExprScopes,
-    source_map: &BodySourceMap,
-    from_file: HirFileId,
-    offset: TextSize,
-) -> Option<ScopeId> {
+fn scope_for_offset(db: &dyn HirDatabase, scopes: &ExprScopes, source_map: &BodySourceMap, from_file: HirFileId, offset: TextSize) -> Option<ScopeId> {
     scopes
         .scope_by_expr()
         .iter()
         })
 }
 
-// XXX: during completion, cursor might be outside of any particular
-// expression. Try to figure out the correct scope...
-fn adjust(
-    db: &dyn HirDatabase,
-    scopes: &ExprScopes,
-    source_map: &BodySourceMap,
-    expr_range: TextRange,
-    from_file: HirFileId,
-    offset: TextSize,
-) -> Option<ScopeId> {
+fn adjust(db: &dyn HirDatabase, scopes: &ExprScopes, source_map: &BodySourceMap, expr_range: TextRange, from_file: HirFileId, offset: TextSize) -> Option<ScopeId> {
     let child_scopes = scopes
         .scope_by_expr()
         .iter()
         .filter(|&(range, _)| {
             range.start() <= offset && expr_range.contains_range(range) && range != expr_range
         });
-
     child_scopes
         .max_by(|&(r1, _), &(r2, _)| {
             if r1.contains_range(r2) {
 }
 
 #[inline]
-pub(crate) fn resolve_hir_path(
-    db: &dyn HirDatabase,
-    resolver: &Resolver<'_>,
-    path: &Path,
-    hygiene: HygieneId,
-    store: Option<&ExpressionStore>,
-) -> Option<PathResolution> {
+pub(crate) fn resolve_hir_path(db: &dyn HirDatabase, resolver: &Resolver<'_>, path: &Path, hygiene: HygieneId, store: Option<&ExpressionStore>) -> Option<PathResolution> {
     resolve_hir_path_(db, resolver, path, false, hygiene, store, false).any()
 }
 
 #[inline]
-pub(crate) fn resolve_hir_path_as_attr_macro(
-    db: &dyn HirDatabase,
-    resolver: &Resolver<'_>,
-    path: &Path,
-) -> Option<Macro> {
+pub(crate) fn resolve_hir_path_as_attr_macro(db: &dyn HirDatabase, resolver: &Resolver<'_>, path: &Path) -> Option<Macro> {
     resolver
         .resolve_path_as_macro(db, path.mod_path()?, Some(MacroSubNs::Attr))
         .map(|(it, _)| it)
         .map(Into::into)
 }
 
-fn resolve_hir_path_(
-    db: &dyn HirDatabase,
-    resolver: &Resolver<'_>,
-    path: &Path,
-    prefer_value_ns: bool,
-    hygiene: HygieneId,
-    store: Option<&ExpressionStore>,
-    resolve_per_ns: bool,
-) -> PathResolutionPerNs {
+fn resolve_hir_path_(db: &dyn HirDatabase, resolver: &Resolver<'_>, path: &Path, prefer_value_ns: bool, hygiene: HygieneId, store: Option<&ExpressionStore>, resolve_per_ns: bool) -> PathResolutionPerNs {
     let types = || {
         let (ty, unresolved) = match path.type_anchor() {
             Some(type_ref) => resolver.generic_def().and_then(|def| {
             None => Some(res),
         }
     };
-
     let body_owner = resolver.body_owner();
     let values = || resolve_hir_value_path(db, resolver, body_owner, path, hygiene);
-
     let items = || {
         resolver
             .resolve_module_path_in_items(db, path.mod_path()?)
             .take_types()
             .map(|it| PathResolution::Def(it.into()))
     };
-
     let macros = || {
         resolver
             .resolve_path_as_macro(db, path.mod_path()?, None)
             .map(|(def, _)| PathResolution::Def(ModuleDef::Macro(def.into())))
     };
-
     if resolve_per_ns {
         PathResolutionPerNs {
             type_ns: types().or_else(items),
     }
 }
 
-fn resolve_hir_value_path(
-    db: &dyn HirDatabase,
-    resolver: &Resolver<'_>,
-    body_owner: Option<DefWithBodyId>,
-    path: &Path,
-    hygiene: HygieneId,
-) -> Option<PathResolution> {
+fn resolve_hir_value_path(db: &dyn HirDatabase, resolver: &Resolver<'_>, body_owner: Option<DefWithBodyId>, path: &Path, hygiene: HygieneId) -> Option<PathResolution> {
     resolver.resolve_path_in_value_ns_fully(db, path, hygiene).and_then(|val| {
         let res = match val {
             ValueNs::LocalBinding(binding_id) => {
 /// }
 /// ```
 /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.
-fn resolve_hir_path_qualifier(
-    db: &dyn HirDatabase,
-    resolver: &Resolver<'_>,
-    path: &Path,
-    store: &ExpressionStore,
-) -> Option<PathResolution> {
+fn resolve_hir_path_qualifier(db: &dyn HirDatabase, resolver: &Resolver<'_>, path: &Path, store: &ExpressionStore) -> Option<PathResolution> {
     (|| {
         let (ty, unresolved) = match path.type_anchor() {
             Some(type_ref) => resolver.generic_def().and_then(|def| {