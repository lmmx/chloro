COMPARISON DIFF
============================================================

Original size: 5600 bytes
Chloro size:   5432 bytes
Rustfmt size:  5891 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use ena::undo_log::UndoLogs;
 use tracing::instrument;
 
-use super::OpaqueHiddenType;
 use crate::next_solver::{
-    infer::snapshot::undo_log::{InferCtxtUndoLogs, UndoLog},
     FxIndexMap, OpaqueTypeKey, Ty,
+    infer::snapshot::undo_log::{InferCtxtUndoLogs, UndoLog},
 };
-
+use super::OpaqueHiddenType;
 #[derive(Default, Debug, Clone)]
 pub(crate) struct OpaqueTypeStorage<'db> {
     opaque_types: FxIndexMap<OpaqueTypeKey<'db>, OpaqueHiddenType<'db>>,
     }
 
     pub(crate) fn is_empty(&self) -> bool {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
         opaque_types.is_empty() && duplicate_entries.is_empty()
     }
 
-    pub(crate) fn take_opaque_types(
-        &mut self,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
-        std::mem::take(opaque_types)
-            .into_iter()
-            .chain(std::mem::take(duplicate_entries))
+    pub(crate) fn take_opaque_types(&mut self) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
+        std::mem::take(opaque_types).into_iter().chain(std::mem::take(duplicate_entries))
     }
 
     pub(crate) fn num_entries(&self) -> OpaqueTypeStorageEntries {
         }
     }
 
-    pub(crate) fn opaque_types_added_since(
-        &self,
-        prev_entries: OpaqueTypeStorageEntries,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+    pub(crate) fn opaque_types_added_since(&self, prev_entries: OpaqueTypeStorageEntries) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
         self.opaque_types
             .iter()
             .skip(prev_entries.opaque_types)
             .map(|(k, v)| (*k, *v))
-            .chain(
-                self.duplicate_entries
-                    .iter()
-                    .skip(prev_entries.duplicate_entries)
-                    .copied(),
-            )
+            .chain(self.duplicate_entries.iter().skip(prev_entries.duplicate_entries).copied())
     }
 
     /// Only returns the opaque types from the lookup table. These are used
     ///
     /// Outside of canonicalization one should generally use `iter_opaque_types`
     /// to also consider duplicate entries.
-    pub(crate) fn iter_lookup_table(
-        &self,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+    pub(crate) fn iter_lookup_table(&self) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
         self.opaque_types.iter().map(|(k, v)| (*k, *v))
     }
 
     /// These have to considered when checking all opaque type uses but are e.g.
     /// irrelevant for canonical inputs as nested queries never meaningfully
     /// accesses them.
-    pub(crate) fn iter_duplicate_entries(
-        &self,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+    pub(crate) fn iter_duplicate_entries(&self) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
         self.duplicate_entries.iter().copied()
     }
 
-    pub(crate) fn iter_opaque_types(
-        &self,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
-        opaque_types
-            .iter()
-            .map(|(k, v)| (*k, *v))
-            .chain(duplicate_entries.iter().copied())
+    pub(crate) fn iter_opaque_types(&self) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
+        opaque_types.iter().map(|(k, v)| (*k, *v)).chain(duplicate_entries.iter().copied())
     }
 
     #[inline]
-    pub(crate) fn with_log<'a>(
-        &'a mut self,
-        undo_log: &'a mut InferCtxtUndoLogs<'db>,
-    ) -> OpaqueTypeTable<'a, 'db> {
-        OpaqueTypeTable {
-            storage: self,
-            undo_log,
-        }
+    pub(crate) fn with_log<'a>(&'a mut self, undo_log: &'a mut InferCtxtUndoLogs<'db>) -> OpaqueTypeTable<'a, 'db> {
+        OpaqueTypeTable { storage: self, undo_log }
     }
 }
 
 pub(crate) struct OpaqueTypeTable<'a, 'db> {
     storage: &'a mut OpaqueTypeStorage<'db>,
-
     undo_log: &'a mut InferCtxtUndoLogs<'db>,
 }
+
 impl<'db> Deref for OpaqueTypeTable<'_, 'db> {
     type Target = OpaqueTypeStorage<'db>;
+
     fn deref(&self) -> &Self::Target {
         self.storage
     }
 
 impl<'a, 'db> OpaqueTypeTable<'a, 'db> {
     #[instrument(skip(self), level = "debug")]
-    pub(crate) fn register(
-        &mut self,
-        key: OpaqueTypeKey<'db>,
-        hidden_type: OpaqueHiddenType<'db>,
-    ) -> Option<Ty<'db>> {
+    pub(crate) fn register(&mut self, key: OpaqueTypeKey<'db>, hidden_type: OpaqueHiddenType<'db>) -> Option<Ty<'db>> {
         if let Some(entry) = self.storage.opaque_types.get_mut(&key) {
             let prev = std::mem::replace(entry, hidden_type);
             self.undo_log.push(UndoLog::OpaqueTypes(key, Some(prev)));
         None
     }
 
-    pub(crate) fn add_duplicate(
-        &mut self,
-        key: OpaqueTypeKey<'db>,
-        hidden_type: OpaqueHiddenType<'db>,
-    ) {
+    pub(crate) fn add_duplicate(&mut self, key: OpaqueTypeKey<'db>, hidden_type: OpaqueHiddenType<'db>) {
         self.storage.duplicate_entries.push((key, hidden_type));
         self.undo_log.push(UndoLog::DuplicateOpaqueType);
     }