COMPARISON DIFF
============================================================

Original size: 19114 bytes
Chloro size:   18873 bytes
Rustfmt size:  19114 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 use crate::{Diagnostic, DiagnosticCode, DiagnosticsContext, fix};
 
-// Diagnostic: missing-fields
-//
-// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.
-//
-// Example:
-//
-// ```rust
-// struct A { a: u8, b: u8 }
-//
-// let a = A { a: 10 };
-// ```
-pub(crate) fn missing_fields(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Diagnostic {
+pub(crate) fn missing_fields(
+    ctx: &DiagnosticsContext<'_>,
+    d: &hir::MissingFields,
+) -> Diagnostic {
     let mut message = String::from("missing structure fields:\n");
     for field in &d.missed_fields {
         format_to!(message, "- {}\n", field.display(ctx.sema.db, ctx.edition));
     }
-
     let ptr = InFile::new(
         d.file,
         d.field_list_parent_path
             .map(SyntaxNodePtr::from)
             .unwrap_or_else(|| d.field_list_parent.into()),
     );
-
     Diagnostic::new_with_syntax_node_ptr(ctx, DiagnosticCode::RustcHardError("E0063"), message, ptr)
         .stable()
         .with_fixes(fixes(ctx, d))
 }
 
-fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Assist>> {
+fn fixes(
+    ctx: &DiagnosticsContext<'_>,
+    d: &hir::MissingFields,
+) -> Option<Vec<Assist>> {
     // Note that although we could add a diagnostics to
     // fill the missing tuple field, e.g :
     // `struct A(usize);`
     if d.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {
         return None;
     }
-
     let root = ctx.sema.db.parse_or_expand(d.file);
-
     let current_module =
         ctx.sema.scope(d.field_list_parent.to_node(&root).syntax()).map(|it| it.module());
     let range = InFile::new(d.file, d.field_list_parent.text_range())
         .original_node_file_range_rooted_opt(ctx.sema.db)?;
-
     let build_text_edit = |new_syntax: &SyntaxNode, old_syntax| {
         let edit = {
             let old_range = ctx.sema.original_range_opt(old_syntax)?;
             range.range,
         )])
     };
-
     match &d.field_list_parent.to_node(&root) {
         Either::Left(field_list_parent) => {
             let missing_fields = ctx.sema.record_literal_missing_fields(field_list_parent);
             ty.display_source_code(db, module.into(), false).ok().unwrap_or_else(|| "_".to_owned())
         }
     };
-
     make::ty(&ty_str)
 }
 
             return Some(make::ext::default_bool());
         }
     }
-
     let krate = ctx
         .sema
         .file_to_module_def(d.file.original_file(ctx.sema.db).file_id(ctx.sema.db))?
         .krate();
     let module = krate.root_module();
-
     // Look for a ::new() associated function
     let has_new_func = ty
         .iterate_assoc_items(ctx.sema.db, krate, |assoc_item| {
             None
         })
         .is_some();
-
     let famous_defs = FamousDefs(&ctx.sema, krate);
     if has_new_func {
         Some(make::ext::expr_ty_new(&make_ty(ty, ctx.sema.db, module, ctx.edition)))
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_diagnostics, check_fix};
-
     #[test]
     fn missing_record_pat_field_diagnostic() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {
         check_diagnostics(
 ",
         )
     }
-
     #[test]
     fn missing_record_pat_field_box() {
         check_diagnostics(
 ",
         )
     }
-
     #[test]
     fn missing_record_pat_field_ref() {
         check_diagnostics(
 ",
         )
     }
-
     #[test]
     fn missing_record_expr_in_assignee_expr() {
         check_diagnostics(
             ",
         );
     }
-
     #[test]
     fn range_mapping_out_of_macros() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_empty() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_zst_fields() {
         check_fix(
 }
 "#,
         );
-
         // make sure the assist doesn't fill non Unit variants
         check_fix(
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_self() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_enum() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_partial() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_new() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_default() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_raw_ident() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_no_diagnostic() {
         check_diagnostics(
         "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_no_diagnostic_on_spread() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_blank_line() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand() {
         cov_mark::check!(field_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand_ty_mismatch() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand_unifies() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_pat_fields() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_pat_fields_partial() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn import_extern_crate_clash_with_inner_item() {
         // This is more of a resolver test, but doesn't really work with the hir_def testsuite.
-
         check_diagnostics(
             r#"
 //- /lib.rs crate:lib deps:jwt