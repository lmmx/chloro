COMPARISON DIFF
============================================================

Original size: 6956 bytes
Chloro size:   6367 bytes
Rustfmt size:  7094 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use rustc_type_ir::IntVid;
 use tracing::debug;
 
+use crate::next_solver::OpaqueTypeKey;
 use crate::next_solver::infer::opaque_types::OpaqueHiddenType;
 use crate::next_solver::infer::unify_key::ConstVidKey;
 use crate::next_solver::infer::unify_key::RegionVidKey;
-use crate::next_solver::infer::{region_constraints, type_variable, InferCtxtInner};
-use crate::next_solver::OpaqueTypeKey;
-
+use crate::next_solver::infer::{InferCtxtInner, region_constraints, type_variable};
 pub struct Snapshot {
     pub(crate) undo_len: usize,
 }
         )*
     }
 }
-
 // Upcast from a single kind of "undoable action" to the general enum
-impl_from! {
-    RegionConstraintCollector(region_constraints::UndoLog<'db>),
-
-    TypeVariables(sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'db>>>),
-    TypeVariables(sv::UndoLog<ut::Delegate<type_variable::TyVidSubKey>>),
-    TypeVariables(type_variable::UndoLog<'db>),
-    IntUnificationTable(sv::UndoLog<ut::Delegate<IntVid>>),
-    FloatUnificationTable(sv::UndoLog<ut::Delegate<FloatVid>>),
-
-    ConstUnificationTable(sv::UndoLog<ut::Delegate<ConstVidKey<'db>>>),
-
-    RegionUnificationTable(sv::UndoLog<ut::Delegate<RegionVidKey<'db>>>),
-}
-
 /// The Rollback trait defines how to rollback a particular action.
 impl<'db> Rollback<UndoLog<'db>> for InferCtxtInner<'db> {
     fn reverse(&mut self, undo: UndoLog<'db>) {
             UndoLog::ConstUnificationTable(undo) => self.const_unification_storage.reverse(undo),
             UndoLog::IntUnificationTable(undo) => self.int_unification_storage.reverse(undo),
             UndoLog::FloatUnificationTable(undo) => self.float_unification_storage.reverse(undo),
-            UndoLog::RegionConstraintCollector(undo) => self
-                .region_constraint_storage
-                .as_mut()
-                .unwrap()
-                .reverse(undo),
-            UndoLog::RegionUnificationTable(undo) => self
-                .region_constraint_storage
-                .as_mut()
-                .unwrap()
-                .unification_table
-                .reverse(undo),
+            UndoLog::RegionConstraintCollector(undo) => {
+                self.region_constraint_storage.as_mut().unwrap().reverse(undo)
+            }
+            UndoLog::RegionUnificationTable(undo) => {
+                self.region_constraint_storage.as_mut().unwrap().unification_table.reverse(undo)
+            }
             UndoLog::PushRegionObligation => {
                 self.region_obligations.pop();
             }
 /// action that is convertible into an UndoLog (per the From impls above).
 impl<'db, T> UndoLogs<T> for InferCtxtUndoLogs<'db>
 where
-    UndoLog<'db>: From<T>,
-{
+    UndoLog<'db>: From<T>, {
     #[inline]
     fn num_open_snapshots(&self) -> usize {
         self.num_open_snapshots
     fn extend<J>(&mut self, undos: J)
     where
         Self: Sized,
-        J: IntoIterator<Item = T>,
-    {
+        J: IntoIterator<Item = T>, {
         if self.in_snapshot() {
             self.logs.extend(undos.into_iter().map(UndoLog::from))
         }
     pub fn rollback_to(&mut self, snapshot: Snapshot) {
         debug!("rollback_to({})", snapshot.undo_len);
         self.undo_log.assert_open_snapshot(&snapshot);
-
         while self.undo_log.logs.len() > snapshot.undo_len {
             let undo = self.undo_log.logs.pop().unwrap();
             self.reverse(undo);
         }
-
         self.type_variable_storage.finalize_rollback();
-
         if self.undo_log.num_open_snapshots == 1 {
             // After the root snapshot the undo log should be empty.
             assert!(snapshot.undo_len == 0);
             assert!(self.undo_log.logs.is_empty());
         }
-
         self.undo_log.num_open_snapshots -= 1;
     }
 
     pub fn commit(&mut self, snapshot: Snapshot) {
         debug!("commit({})", snapshot.undo_len);
-
         if self.undo_log.num_open_snapshots == 1 {
             // The root snapshot. It's safe to clear the undo log because
             // there's no snapshot further out that we might need to roll back
             assert!(snapshot.undo_len == 0);
             self.undo_log.logs.clear();
         }
-
         self.undo_log.num_open_snapshots -= 1;
     }
 }
 impl<'db> InferCtxtUndoLogs<'db> {
     pub(crate) fn start_snapshot(&mut self) -> Snapshot {
         self.num_open_snapshots += 1;
-        Snapshot {
-            undo_len: self.logs.len(),
-        }
+        Snapshot { undo_len: self.logs.len() }
     }
 
-    pub(crate) fn region_constraints_in_snapshot(
-        &self,
-        s: &Snapshot,
-    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'db>> + Clone {
+    pub(crate) fn region_constraints_in_snapshot(&self, s: &Snapshot) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'db>> + Clone {
         self.logs[s.undo_len..].iter().filter_map(|log| match log {
             UndoLog::RegionConstraintCollector(log) => Some(log),
             _ => None,
     }
 
     pub(crate) fn opaque_types_in_snapshot(&self, s: &Snapshot) -> bool {
-        self.logs[s.undo_len..]
-            .iter()
-            .any(|log| matches!(log, UndoLog::OpaqueTypes(..)))
+        self.logs[s.undo_len..].iter().any(|log| matches!(log, UndoLog::OpaqueTypes(..)))
     }
 
     fn assert_open_snapshot(&self, snapshot: &Snapshot) {