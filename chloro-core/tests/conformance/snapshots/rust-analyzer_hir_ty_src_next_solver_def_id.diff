COMPARISON DIFF
============================================================

Original size: 11678 bytes
Chloro size:   11070 bytes
Rustfmt size:  12164 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use stdx::impl_from;
 
 use crate::db::{InternedClosureId, InternedCoroutineId, InternedOpaqueTyId};
-
 use super::DbInterner;
 
 #[derive(Debug, PartialOrd, Ord, Clone, Copy, PartialEq, Eq, Hash, salsa::Supertype)]
     InternedCoroutineId(InternedCoroutineId),
     InternedOpaqueTyId(InternedOpaqueTyId),
     EnumVariantId(EnumVariantId),
-    // FIXME(next-solver): Do we need the separation of `Ctor`? It duplicates some variants.
     Ctor(Ctor),
 }
 
 impl std::fmt::Debug for SolverDefId {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         let interner = DbInterner::conjure();
         let db = interner.db;
         match *self {
-            SolverDefId::AdtId(AdtId::StructId(id)) => f
-                .debug_tuple("AdtId")
-                .field(&db.struct_signature(id).name.as_str())
-                .finish(),
-            SolverDefId::AdtId(AdtId::EnumId(id)) => f
-                .debug_tuple("AdtId")
-                .field(&db.enum_signature(id).name.as_str())
-                .finish(),
-            SolverDefId::AdtId(AdtId::UnionId(id)) => f
-                .debug_tuple("AdtId")
-                .field(&db.union_signature(id).name.as_str())
-                .finish(),
+            SolverDefId::AdtId(AdtId::StructId(id)) => {
+                f.debug_tuple("AdtId").field(&db.struct_signature(id).name.as_str()).finish()
+            }
+            SolverDefId::AdtId(AdtId::EnumId(id)) => {
+                f.debug_tuple("AdtId").field(&db.enum_signature(id).name.as_str()).finish()
+            }
+            SolverDefId::AdtId(AdtId::UnionId(id)) => {
+                f.debug_tuple("AdtId").field(&db.union_signature(id).name.as_str()).finish()
+            }
             SolverDefId::ConstId(id) => f
                 .debug_tuple("ConstId")
-                .field(
-                    &db.const_signature(id)
-                        .name
-                        .as_ref()
-                        .map_or("_", |name| name.as_str()),
-                )
-                .finish(),
-            SolverDefId::FunctionId(id) => f
-                .debug_tuple("FunctionId")
-                .field(&db.function_signature(id).name.as_str())
+                .field(&db.const_signature(id).name.as_ref().map_or("_", |name| name.as_str()))
                 .finish(),
+            SolverDefId::FunctionId(id) => {
+                f.debug_tuple("FunctionId").field(&db.function_signature(id).name.as_str()).finish()
+            }
             SolverDefId::ImplId(id) => f.debug_tuple("ImplId").field(&id).finish(),
-            SolverDefId::StaticId(id) => f
-                .debug_tuple("StaticId")
-                .field(&db.static_signature(id).name.as_str())
-                .finish(),
-            SolverDefId::TraitId(id) => f
-                .debug_tuple("TraitId")
-                .field(&db.trait_signature(id).name.as_str())
-                .finish(),
+            SolverDefId::StaticId(id) => {
+                f.debug_tuple("StaticId").field(&db.static_signature(id).name.as_str()).finish()
+            }
+            SolverDefId::TraitId(id) => {
+                f.debug_tuple("TraitId").field(&db.trait_signature(id).name.as_str()).finish()
+            }
             SolverDefId::TypeAliasId(id) => f
                 .debug_tuple("TypeAliasId")
                 .field(&db.type_alias_signature(id).name.as_str())
                     .field(&format_args!(
                         "\"{}::{}\"",
                         db.enum_signature(parent_enum).name.as_str(),
-                        parent_enum
-                            .enum_variants(db)
-                            .variant_name_by_id(id)
-                            .unwrap()
-                            .as_str()
+                        parent_enum.enum_variants(db).variant_name_by_id(id).unwrap().as_str()
                     ))
                     .finish()
             }
-            SolverDefId::Ctor(Ctor::Struct(id)) => f
-                .debug_tuple("Ctor")
-                .field(&db.struct_signature(id).name.as_str())
-                .finish(),
+            SolverDefId::Ctor(Ctor::Struct(id)) => {
+                f.debug_tuple("Ctor").field(&db.struct_signature(id).name.as_str()).finish()
+            }
             SolverDefId::Ctor(Ctor::Enum(id)) => {
                 let parent_enum = id.loc(db).parent;
                 f.debug_tuple("Ctor")
                     .field(&format_args!(
                         "\"{}::{}\"",
                         db.enum_signature(parent_enum).name.as_str(),
-                        parent_enum
-                            .enum_variants(db)
-                            .variant_name_by_id(id)
-                            .unwrap()
-                            .as_str()
+                        parent_enum.enum_variants(db).variant_name_by_id(id).unwrap().as_str()
                     ))
                     .finish()
             }
         }
     }
 }
-
-impl_from!(
-    AdtId(StructId, EnumId, UnionId),
-    ConstId,
-    FunctionId,
-    ImplId,
-    StaticId,
-    TraitId,
-    TypeAliasId,
-    InternedClosureId,
-    InternedCoroutineId,
-    InternedOpaqueTyId,
-    EnumVariantId,
-    Ctor
-    for SolverDefId
-);
-
 impl From<GenericDefId> for SolverDefId {
     fn from(value: GenericDefId) -> Self {
         match value {
     fn as_local(self) -> Option<SolverDefId> {
         Some(self)
     }
+
     fn is_local(self) -> bool {
         true
     }
         }
     };
 }
-
-declare_id_wrapper!(TraitIdWrapper, TraitId);
-declare_id_wrapper!(TypeAliasIdWrapper, TypeAliasId);
-declare_id_wrapper!(ClosureIdWrapper, InternedClosureId);
-declare_id_wrapper!(CoroutineIdWrapper, InternedCoroutineId);
-declare_id_wrapper!(AdtIdWrapper, AdtId);
-declare_id_wrapper!(ImplIdWrapper, ImplId);
-
 #[derive(Clone, Copy, PartialEq, Eq, Hash)]
 pub struct CallableIdWrapper(pub CallableDefId);
 
 impl std::fmt::Debug for CallableIdWrapper {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         std::fmt::Debug::fmt(&self.0, f)
     }
 }
+
 impl From<CallableIdWrapper> for CallableDefId {
     #[inline]
     fn from(value: CallableIdWrapper) -> CallableDefId {
         value.0
     }
 }
+
 impl From<CallableDefId> for CallableIdWrapper {
     #[inline]
     fn from(value: CallableDefId) -> CallableIdWrapper {
         Self(value)
     }
 }
+
 impl From<CallableIdWrapper> for SolverDefId {
     #[inline]
     fn from(value: CallableIdWrapper) -> SolverDefId {
         }
     }
 }
+
 impl TryFrom<SolverDefId> for CallableIdWrapper {
     type Error = ();
+
     #[inline]
     fn try_from(value: SolverDefId) -> Result<Self, Self::Error> {
         match value {
         }
     }
 }
+
 impl<'db> inherent::DefId<DbInterner<'db>> for CallableIdWrapper {
     fn as_local(self) -> Option<SolverDefId> {
         Some(self.into())
     }
+
     fn is_local(self) -> bool {
         true
     }