COMPARISON DIFF
============================================================

Original size: 10531 bytes
Chloro size:   10455 bytes
Rustfmt size:  11050 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use vfs::AbsPathBuf;
 
 use crate::global_state::GlobalStateSnapshot;
-
 /// A target represents a thing we can build or test.
 ///
 /// We use it to calculate the CLI arguments required to build, run or
 }
 
 impl TargetSpec {
-    pub(crate) fn for_file(
-        global_state_snapshot: &GlobalStateSnapshot,
-        file_id: FileId,
-    ) -> Cancellable<Option<Self>> {
+    pub(crate) fn for_file(global_state_snapshot: &GlobalStateSnapshot, file_id: FileId) -> Cancellable<Option<Self>> {
         let crate_id = match &*global_state_snapshot.analysis.crates_for(file_id)? {
             &[crate_id, ..] => crate_id,
             _ => return Ok(None),
         };
-
         Ok(global_state_snapshot.target_spec_for_crate(crate_id))
     }
 
         match kind {
             RunnableKind::Bin => {
                 for runnable in &self.shell_runnables {
-                    if matches!(
-                        runnable.kind,
-                        project_model::project_json::RunnableKind::Run
-                    ) {
+                    if matches!(runnable.kind, project_model::project_json::RunnableKind::Run) {
                         return Some(runnable.clone());
                     }
                 }
             }
             RunnableKind::Test { test_id, .. } => {
                 for runnable in &self.shell_runnables {
-                    if matches!(
-                        runnable.kind,
-                        project_model::project_json::RunnableKind::TestOne
-                    ) {
+                    if matches!(runnable.kind, project_model::project_json::RunnableKind::TestOne) {
                         let mut runnable = runnable.clone();
 
                         let replaced_args: Vec<_> = runnable
 }
 
 impl CargoTargetSpec {
-    pub(crate) fn runnable_args(
-        snap: &GlobalStateSnapshot,
-        spec: Option<CargoTargetSpec>,
-        kind: &RunnableKind,
-        cfg: &Option<CfgExpr>,
-    ) -> (Vec<String>, Vec<String>) {
+    pub(crate) fn runnable_args(snap: &GlobalStateSnapshot, spec: Option<CargoTargetSpec>, kind: &RunnableKind, cfg: &Option<CfgExpr>) -> (Vec<String>, Vec<String>) {
         let config = snap.config.runnables(None);
         let extra_test_binary_args = config.extra_test_binary_args;
-
         let mut cargo_args = Vec::new();
         let mut executable_args = Vec::new();
-
         match kind {
             RunnableKind::Test { test_id, attr } => {
                 cargo_args.push("test".to_owned());
             }
             RunnableKind::Bin => {
                 let subcommand = match spec {
-                    Some(CargoTargetSpec {
-                        target_kind: TargetKind::Test,
-                        ..
-                    }) => "test",
+                    Some(CargoTargetSpec { target_kind: TargetKind::Test, .. }) => "test",
                     _ => "run",
                 };
                 cargo_args.push(subcommand.to_owned());
             }
         }
-
         let (allowed_features, target_required_features) = if let Some(mut spec) = spec {
             let allowed_features = mem::take(&mut spec.features);
             let required_features = mem::take(&mut spec.required_features);
         } else {
             (Default::default(), Default::default())
         };
-
         let cargo_config = snap.config.cargo(None);
-
         match &cargo_config.features {
             CargoFeatures::All => {
                 cargo_args.push("--all-features".to_owned());
                     cargo_args.push(feature);
                 }
             }
-            CargoFeatures::Selected {
-                features,
-                no_default_features,
-            } => {
+            CargoFeatures::Selected { features, no_default_features } => {
                 let mut feats = Vec::new();
                 if let Some(cfg) = cfg.as_ref() {
                     required_features(cfg, &mut feats);
                 }
 
                 feats.extend(
-                    features
-                        .iter()
-                        .filter(|&feat| allowed_features.contains(feat))
-                        .cloned(),
+                    features.iter().filter(|&feat| allowed_features.contains(feat)).cloned(),
                 );
                 feats.extend(target_required_features);
 
     pub(crate) fn push_to(self, buf: &mut Vec<String>, kind: &RunnableKind) {
         buf.push("--package".to_owned());
         buf.push(self.package);
-
         // Can't mix --doc with other target flags
         if let RunnableKind::DocTest { .. } = kind {
             return;
             features.push(value.to_string())
         }
         CfgExpr::All(preds) => {
-            preds
-                .iter()
-                .for_each(|cfg| required_features(cfg, features));
+            preds.iter().for_each(|cfg| required_features(cfg, features));
         }
         CfgExpr::Any(preds) => {
             for cfg in preds.iter() {
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use ide::Edition;
     use syntax::{
-        ast::{self, AstNode},
         SmolStr,
+        ast::{self, AstNode},
     };
     use syntax_bridge::{
-        dummy_test_span_utils::{DummyTestSpanMap, DUMMY},
-        syntax_node_to_token_tree, DocCommentDesugarMode,
+        DocCommentDesugarMode,
+        dummy_test_span_utils::{DUMMY, DummyTestSpanMap},
+        syntax_node_to_token_tree,
     };
-
     fn check(cfg: &str, expected_features: &[&str]) {
         let cfg_expr = {
             let source_file = ast::SourceFile::parse(cfg, Edition::CURRENT).ok().unwrap();
-            let tt = source_file
-                .syntax()
-                .descendants()
-                .find_map(ast::TokenTree::cast)
-                .unwrap();
+            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();
             let tt = syntax_node_to_token_tree(
                 tt.syntax(),
                 &DummyTestSpanMap,
             );
             CfgExpr::parse(&tt)
         };
-
         let mut features = vec![];
         required_features(&cfg_expr, &mut features);
-
-        let expected_features = expected_features
-            .iter()
-            .map(|&it| SmolStr::new(it))
-            .collect::<Vec<_>>();
-
+        let expected_features =
+            expected_features.iter().map(|&it| SmolStr::new(it)).collect::<Vec<_>>();
         assert_eq!(features, expected_features);
     }
-
     #[test]
     fn test_cfg_expr_minimal_features_needed() {
         check(r#"#![cfg(feature = "baz")]"#, &["baz"]);
-        check(
-            r#"#![cfg(all(feature = "baz", feature = "foo"))]"#,
-            &["baz", "foo"],
-        );
-        check(
-            r#"#![cfg(any(feature = "baz", feature = "foo", unix))]"#,
-            &["baz"],
-        );
+        check(r#"#![cfg(all(feature = "baz", feature = "foo"))]"#, &["baz", "foo"]);
+        check(r#"#![cfg(any(feature = "baz", feature = "foo", unix))]"#, &["baz"]);
         check(r#"#![cfg(foo)]"#, &[]);
     }
 }