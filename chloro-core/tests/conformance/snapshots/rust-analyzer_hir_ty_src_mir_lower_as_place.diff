COMPARISON DIFF
============================================================

Original size: 15480 bytes
Chloro size:   15150 bytes
Rustfmt size:  15480 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! MIR lowering for places
 
 use hir_def::FunctionId;
 use intern::sym;
 use rustc_type_ir::inherent::{AdtDef, Region as _, Ty as _};
 
-use super::*;
 use crate::{
     mir::{MutBorrowKind, Operand, OperandKind},
     next_solver::Region,
 };
-
+use super::*;
 macro_rules! not_supported {
     ($it: expr) => {
         return Err(MirLowerError::NotSupported(format!($it)))
 }
 
 impl<'db> MirLowerCtx<'_, 'db> {
-    fn lower_expr_to_some_place_without_adjust(
-        &mut self,
-        expr_id: ExprId,
-        prev_block: BasicBlockId<'db>,
-    ) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
+    fn lower_expr_to_some_place_without_adjust(&mut self, expr_id: ExprId, prev_block: BasicBlockId<'db>) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
         let ty = self.expr_ty_without_adjust(expr_id);
         let place = self.temp(ty, prev_block, expr_id.into())?;
         let Some(current) =
         Ok(Some((place.into(), current)))
     }
 
-    fn lower_expr_to_some_place_with_adjust(
-        &mut self,
-        expr_id: ExprId,
-        prev_block: BasicBlockId<'db>,
-        adjustments: &[Adjustment<'db>],
-    ) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
+    fn lower_expr_to_some_place_with_adjust(&mut self, expr_id: ExprId, prev_block: BasicBlockId<'db>, adjustments: &[Adjustment<'db>]) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
         let ty = adjustments
             .last()
             .map(|it| it.target)
         Ok(Some((place.into(), current)))
     }
 
-    pub(super) fn lower_expr_as_place_with_adjust(
-        &mut self,
-        current: BasicBlockId<'db>,
-        expr_id: ExprId,
-        upgrade_rvalue: bool,
-        adjustments: &[Adjustment<'db>],
-    ) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
+    pub(super) fn lower_expr_as_place_with_adjust(&mut self, current: BasicBlockId<'db>, expr_id: ExprId, upgrade_rvalue: bool, adjustments: &[Adjustment<'db>]) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
         let try_rvalue = |this: &mut MirLowerCtx<'_, 'db>| {
             if !upgrade_rvalue {
                 return Err(MirLowerError::MutatingRvalue);
         }
     }
 
-    pub(super) fn lower_expr_as_place(
-        &mut self,
-        current: BasicBlockId<'db>,
-        expr_id: ExprId,
-        upgrade_rvalue: bool,
-    ) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
+    pub(super) fn lower_expr_as_place(&mut self, current: BasicBlockId<'db>, expr_id: ExprId, upgrade_rvalue: bool) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
         match self.infer.expr_adjustments.get(&expr_id) {
             Some(a) => self.lower_expr_as_place_with_adjust(current, expr_id, upgrade_rvalue, a),
             None => self.lower_expr_as_place_without_adjust(current, expr_id, upgrade_rvalue),
         }
     }
 
-    pub(super) fn lower_expr_as_place_without_adjust(
-        &mut self,
-        current: BasicBlockId<'db>,
-        expr_id: ExprId,
-        upgrade_rvalue: bool,
-    ) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
+    pub(super) fn lower_expr_as_place_without_adjust(&mut self, current: BasicBlockId<'db>, expr_id: ExprId, upgrade_rvalue: bool) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
         let try_rvalue = |this: &mut MirLowerCtx<'_, 'db>| {
             if !upgrade_rvalue {
                 return Err(MirLowerError::MutatingRvalue);
         }
     }
 
-    fn lower_overloaded_index(
-        &mut self,
-        current: BasicBlockId<'db>,
-        place: Place<'db>,
-        base_ty: Ty<'db>,
-        result_ty: Ty<'db>,
-        index_operand: Operand<'db>,
-        span: MirSpan,
-        index_fn: (FunctionId, GenericArgs<'db>),
-    ) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
+    fn lower_overloaded_index(&mut self, current: BasicBlockId<'db>, place: Place<'db>, base_ty: Ty<'db>, result_ty: Ty<'db>, index_operand: Operand<'db>, span: MirSpan, index_fn: (FunctionId, GenericArgs<'db>)) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
         let mutability = match base_ty.as_reference() {
             Some((_, _, mutability)) => mutability,
             None => Mutability::Not,
         Ok(Some((result, current)))
     }
 
-    fn lower_overloaded_deref(
-        &mut self,
-        current: BasicBlockId<'db>,
-        place: Place<'db>,
-        source_ty: Ty<'db>,
-        target_ty: Ty<'db>,
-        span: MirSpan,
-        mutability: bool,
-    ) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
+    fn lower_overloaded_deref(&mut self, current: BasicBlockId<'db>, place: Place<'db>, source_ty: Ty<'db>, target_ty: Ty<'db>, span: MirSpan, mutability: bool) -> Result<'db, Option<(Place<'db>, BasicBlockId<'db>)>> {
         let (mutability, trait_lang_item, trait_method_name, borrow_kind) = if !mutability {
             (
                 Mutability::Not,