COMPARISON DIFF
============================================================

Original size: 32290 bytes
Chloro size:   30261 bytes
Rustfmt size:  32290 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     span_map::SpanMap,
     tt::{self, DelimSpan, TtElement, TtIter},
 };
-
 macro_rules! register_builtin {
     ( $LAZY:ident: $(($name:ident, $kind: ident) => $expand:ident),* , $EAGER:ident: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {
         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 }
 
 impl BuiltinFnLikeExpander {
-    pub fn expand(
-        &self,
-        db: &dyn ExpandDatabase,
-        id: MacroCallId,
-        tt: &tt::TopSubtree,
-        span: Span,
-    ) -> ExpandResult<tt::TopSubtree> {
+    pub fn expand(&self, db: &dyn ExpandDatabase, id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
         let span = span_with_def_site_ctxt(db, span, id.into(), Edition::CURRENT);
         self.expander()(db, id, tt, span)
     }
 }
 
 impl EagerExpander {
-    pub fn expand(
-        &self,
-        db: &dyn ExpandDatabase,
-        id: MacroCallId,
-        tt: &tt::TopSubtree,
-        span: Span,
-    ) -> ExpandResult<tt::TopSubtree> {
+    pub fn expand(&self, db: &dyn ExpandDatabase, id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
         let span = span_with_def_site_ctxt(db, span, id.into(), Edition::CURRENT);
         self.expander()(db, id, tt, span)
     }
     }
 }
 
-pub fn find_builtin_macro(
-    ident: &name::Name,
-) -> Option<Either<BuiltinFnLikeExpander, EagerExpander>> {
+pub fn find_builtin_macro(ident: &name::Name) -> Option<Either<BuiltinFnLikeExpander, EagerExpander>> {
     find_by_name(ident)
 }
-
-register_builtin! {
-    BuiltinFnLikeExpander:
-    (column, Column) => line_expand,
-    (file, File) => file_expand,
-    (line, Line) => line_expand,
-    (module_path, ModulePath) => module_path_expand,
-    (assert, Assert) => assert_expand,
-    (stringify, Stringify) => stringify_expand,
-    (asm, Asm) => asm_expand,
-    (global_asm, GlobalAsm) => global_asm_expand,
-    (naked_asm, NakedAsm) => naked_asm_expand,
-    (cfg_select, CfgSelect) => cfg_select_expand,
-    (cfg, Cfg) => cfg_expand,
-    (core_panic, CorePanic) => panic_expand,
-    (std_panic, StdPanic) => panic_expand,
-    (unreachable, Unreachable) => unreachable_expand,
-    (log_syntax, LogSyntax) => log_syntax_expand,
-    (trace_macros, TraceMacros) => trace_macros_expand,
-    (format_args, FormatArgs) => format_args_expand,
-    (const_format_args, ConstFormatArgs) => format_args_expand,
-    (format_args_nl, FormatArgsNl) => format_args_nl_expand,
-    (quote, Quote) => quote_expand,
-
-    EagerExpander:
-    (compile_error, CompileError) => compile_error_expand,
-    (concat, Concat) => concat_expand,
-    (concat_bytes, ConcatBytes) => concat_bytes_expand,
-    (include, Include) => include_expand,
-    (include_bytes, IncludeBytes) => include_bytes_expand,
-    (include_str, IncludeStr) => include_str_expand,
-    (env, Env) => env_expand,
-    (option_env, OptionEnv) => option_env_expand
-}
-
 fn mk_pound(span: Span) -> tt::Leaf {
     crate::tt::Leaf::Punct(crate::tt::Punct { char: '#', spacing: crate::tt::Spacing::Alone, span })
 }
 
-fn module_path_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    _tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn module_path_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, _tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     // Just return a dummy result.
     ExpandResult::ok(quote! {span =>
          "module::path"
     })
 }
 
-fn line_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    _tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn line_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, _tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     // dummy implementation for type-checking purposes
     // Note that `line!` and `column!` will never be implemented properly, as they are by definition
     // not incremental
     ))
 }
 
-fn log_syntax_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    _tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn log_syntax_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, _tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     ExpandResult::ok(quote! {span =>})
 }
 
-fn trace_macros_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    _tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn trace_macros_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, _tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     ExpandResult::ok(quote! {span =>})
 }
 
-fn stringify_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn stringify_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let pretty = ::tt::pretty(tt.token_trees().flat_tokens());
-
     let expanded = quote! {span =>
         #pretty
     };
-
     ExpandResult::ok(expanded)
 }
 
-fn assert_expand(
-    db: &dyn ExpandDatabase,
-    id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn assert_expand(db: &dyn ExpandDatabase, id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let call_site_span = span_with_call_site_ctxt(db, span, id.into(), Edition::CURRENT);
-
     let mut iter = tt.iter();
-
     let cond = expect_fragment(
         &mut iter,
         parser::PrefixEntryPoint::Expr,
     );
     _ = iter.expect_char(',');
     let rest = iter.remaining();
-
     let dollar_crate = dollar_crate(span);
     let panic_args = rest.iter();
     let mac = if use_panic_2021(db, span) {
             #mac;
         }
     }};
-
     match cond.err {
         Some(err) => ExpandResult::new(expanded, err.into()),
         None => ExpandResult::ok(expanded),
     }
 }
 
-fn file_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    _tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn file_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, _tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     // FIXME: RA purposefully lacks knowledge of absolute file names
     // so just return "".
     let file_name = "file";
-
     let expanded = quote! {span =>
         #file_name
     };
-
     ExpandResult::ok(expanded)
 }
 
-fn format_args_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn format_args_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let pound = mk_pound(span);
     let mut tt = tt.clone();
     tt.top_subtree_delimiter_mut().kind = tt::DelimiterKind::Parenthesis;
     })
 }
 
-fn format_args_nl_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn format_args_nl_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let pound = mk_pound(span);
     let mut tt = tt.clone();
     tt.top_subtree_delimiter_mut().kind = tt::DelimiterKind::Parenthesis;
     })
 }
 
-fn asm_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn asm_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let mut tt = tt.clone();
     tt.top_subtree_delimiter_mut().kind = tt::DelimiterKind::Parenthesis;
     let pound = mk_pound(span);
     ExpandResult::ok(expanded)
 }
 
-fn global_asm_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn global_asm_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let mut tt = tt.clone();
     tt.top_subtree_delimiter_mut().kind = tt::DelimiterKind::Parenthesis;
     let pound = mk_pound(span);
     ExpandResult::ok(expanded)
 }
 
-fn naked_asm_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn naked_asm_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let mut tt = tt.clone();
     tt.top_subtree_delimiter_mut().kind = tt::DelimiterKind::Parenthesis;
     let pound = mk_pound(span);
     ExpandResult::ok(expanded)
 }
 
-fn cfg_select_expand(
-    db: &dyn ExpandDatabase,
-    id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn cfg_select_expand(db: &dyn ExpandDatabase, id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let loc = db.lookup_intern_macro_call(id);
     let cfg_options = loc.krate.cfg_options(db);
-
     let mut iter = tt.iter();
     let mut expand_to = None;
     while let Some(next) = iter.peek() {
     }
 }
 
-fn cfg_expand(
-    db: &dyn ExpandDatabase,
-    id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn cfg_expand(db: &dyn ExpandDatabase, id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let loc = db.lookup_intern_macro_call(id);
     let expr = CfgExpr::parse(tt);
     let enabled = loc.krate.cfg_options(db).check(&expr) != Some(false);
     ExpandResult::ok(expanded)
 }
 
-fn panic_expand(
-    db: &dyn ExpandDatabase,
-    id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn panic_expand(db: &dyn ExpandDatabase, id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let dollar_crate = dollar_crate(span);
     let call_site_span = span_with_call_site_ctxt(db, span, id.into(), Edition::CURRENT);
-
     let mac = if use_panic_2021(db, call_site_span) { sym::panic_2021 } else { sym::panic_2015 };
-
     // Pass the original arguments
     let subtree = WithDelimiter {
         delimiter: tt::Delimiter {
         },
         token_trees: tt.token_trees(),
     };
-
     // Expand to a macro call `$crate::panic::panic_{edition}`
     let call = quote!(call_site_span =>#dollar_crate::panic::#mac! #subtree);
-
     ExpandResult::ok(call)
 }
 
-fn unreachable_expand(
-    db: &dyn ExpandDatabase,
-    id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn unreachable_expand(db: &dyn ExpandDatabase, id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let dollar_crate = dollar_crate(span);
     let call_site_span = span_with_call_site_ctxt(db, span, id.into(), Edition::CURRENT);
-
     let mac = if use_panic_2021(db, call_site_span) {
         sym::unreachable_2021
     } else {
         sym::unreachable_2015
     };
-
     // Pass the original arguments
     let mut subtree = tt.clone();
     *subtree.top_subtree_delimiter_mut() = tt::Delimiter {
         close: call_site_span,
         kind: tt::DelimiterKind::Parenthesis,
     };
-
     // Expand to a macro call `$crate::panic::panic_{edition}`
     let call = quote!(call_site_span =>#dollar_crate::panic::#mac! #subtree);
-
     ExpandResult::ok(call)
 }
 
     }
 }
 
-fn compile_error_expand(
-    _db: &dyn ExpandDatabase,
-    _id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn compile_error_expand(_db: &dyn ExpandDatabase, _id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let err = match &*tt.0 {
         [
             _,
         ] => ExpandError::other(span, Box::from(unescape_symbol(text).as_str())),
         _ => ExpandError::other(span, "`compile_error!` argument must be a string"),
     };
-
     ExpandResult { value: quote! {span =>}, err: Some(err) }
 }
 
-fn concat_expand(
-    _db: &dyn ExpandDatabase,
-    _arg_id: MacroCallId,
-    tt: &tt::TopSubtree,
-    call_site: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn concat_expand(_db: &dyn ExpandDatabase, _arg_id: MacroCallId, tt: &tt::TopSubtree, call_site: Span) -> ExpandResult<tt::TopSubtree> {
     let mut err = None;
     let mut text = String::new();
     let mut span: Option<Span> = None;
         Some(_) => (),
         None => span = Some(s),
     };
-
     let mut i = 0;
     let mut iter = tt.iter();
     while let Some(mut t) = iter.next() {
     ExpandResult { value: quote!(span =>#text), err }
 }
 
-fn concat_bytes_expand(
-    _db: &dyn ExpandDatabase,
-    _arg_id: MacroCallId,
-    tt: &tt::TopSubtree,
-    call_site: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn concat_bytes_expand(_db: &dyn ExpandDatabase, _arg_id: MacroCallId, tt: &tt::TopSubtree, call_site: Span) -> ExpandResult<tt::TopSubtree> {
     let mut bytes = String::new();
     let mut err = None;
     let mut span: Option<Span> = None;
     }
 }
 
-fn concat_bytes_expand_subtree(
-    tree_iter: TtIter<'_>,
-    bytes: &mut String,
-    mut record_span: impl FnMut(Span),
-    err_span: Span,
-) -> Result<(), ExpandError> {
+fn concat_bytes_expand_subtree(tree_iter: TtIter<'_>, bytes: &mut String, mut record_span: impl FnMut(Span), err_span: Span) -> Result<(), ExpandError> {
     for (ti, tt) in tree_iter.enumerate() {
         match tt {
             TtElement::Leaf(tt::Leaf::Literal(tt::Literal {
     Ok(())
 }
 
-fn relative_file(
-    db: &dyn ExpandDatabase,
-    call_id: MacroCallId,
-    path_str: &str,
-    allow_recursion: bool,
-    err_span: Span,
-) -> Result<EditionedFileId, ExpandError> {
+fn relative_file(db: &dyn ExpandDatabase, call_id: MacroCallId, path_str: &str, allow_recursion: bool, err_span: Span) -> Result<EditionedFileId, ExpandError> {
     let lookup = db.lookup_intern_macro_call(call_id);
     let call_site = lookup.kind.file_id().original_file_respecting_includes(db).file_id(db);
     let path = AnchoredPath { anchor: call_site, path: path_str };
     .map_err(|span| ExpandError::other(span, "expected string literal"))
 }
 
-fn include_expand(
-    db: &dyn ExpandDatabase,
-    arg_id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn include_expand(db: &dyn ExpandDatabase, arg_id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let editioned_file_id = match include_input_to_file_id(db, arg_id, tt) {
         Ok(editioned_file_id) => editioned_file_id,
         Err(e) => {
     ))
 }
 
-pub fn include_input_to_file_id(
-    db: &dyn ExpandDatabase,
-    arg_id: MacroCallId,
-    arg: &tt::TopSubtree,
-) -> Result<EditionedFileId, ExpandError> {
+pub fn include_input_to_file_id(db: &dyn ExpandDatabase, arg_id: MacroCallId, arg: &tt::TopSubtree) -> Result<EditionedFileId, ExpandError> {
     let (s, span) = parse_string(arg)?;
     relative_file(db, arg_id, s.as_str(), false, span)
 }
 
-fn include_bytes_expand(
-    _db: &dyn ExpandDatabase,
-    _arg_id: MacroCallId,
-    _tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn include_bytes_expand(_db: &dyn ExpandDatabase, _arg_id: MacroCallId, _tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     // FIXME: actually read the file here if the user asked for macro expansion
     let res = tt::TopSubtree::invisible_from_leaves(
         span,
     ExpandResult::ok(res)
 }
 
-fn include_str_expand(
-    db: &dyn ExpandDatabase,
-    arg_id: MacroCallId,
-    tt: &tt::TopSubtree,
-    call_site: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn include_str_expand(db: &dyn ExpandDatabase, arg_id: MacroCallId, tt: &tt::TopSubtree, call_site: Span) -> ExpandResult<tt::TopSubtree> {
     let (path, input_span) = match parse_string(tt) {
         Ok(it) => it,
         Err(e) => {
             );
         }
     };
-
     // FIXME: we're not able to read excluded files (which is most of them because
     // it's unusual to `include_str!` a Rust file), but we can return an empty string.
     // Ideally, we'd be able to offer a precise expansion if the user asks for macro
             return ExpandResult::ok(quote!(call_site =>""));
         }
     };
-
     let text = db.file_text(file_id.file_id(db));
     let text = &**text.text(db);
-
     ExpandResult::ok(quote!(call_site =>#text))
 }
 
     krate.env(db).get(key.as_str())
 }
 
-fn env_expand(
-    db: &dyn ExpandDatabase,
-    arg_id: MacroCallId,
-    tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn env_expand(db: &dyn ExpandDatabase, arg_id: MacroCallId, tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     let (key, span) = match parse_string(tt) {
         Ok(it) => it,
         Err(e) => {
             );
         }
     };
-
     let mut err = None;
     let s = get_env_inner(db, arg_id, &key).unwrap_or_else(|| {
         // The only variable rust-analyzer ever sets is `OUT_DIR`, so only diagnose that to avoid
         "UNRESOLVED_ENV_VAR".to_owned()
     });
     let expanded = quote! {span => #s };
-
     ExpandResult { value: expanded, err }
 }
 
-fn option_env_expand(
-    db: &dyn ExpandDatabase,
-    arg_id: MacroCallId,
-    tt: &tt::TopSubtree,
-    call_site: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn option_env_expand(db: &dyn ExpandDatabase, arg_id: MacroCallId, tt: &tt::TopSubtree, call_site: Span) -> ExpandResult<tt::TopSubtree> {
     let (key, span) = match parse_string(tt) {
         Ok(it) => it,
         Err(e) => {
             quote! {call_site => #dollar_crate::option::Option::Some(#s) }
         }
     };
-
     ExpandResult::ok(expanded)
 }
 
-fn quote_expand(
-    _db: &dyn ExpandDatabase,
-    _arg_id: MacroCallId,
-    _tt: &tt::TopSubtree,
-    span: Span,
-) -> ExpandResult<tt::TopSubtree> {
+fn quote_expand(_db: &dyn ExpandDatabase, _arg_id: MacroCallId, _tt: &tt::TopSubtree, span: Span) -> ExpandResult<tt::TopSubtree> {
     ExpandResult::new(
         tt::TopSubtree::empty(tt::DelimSpan { open: span, close: span }),
         ExpandError::other(span, "quote! is not implemented"),