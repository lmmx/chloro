COMPARISON DIFF
============================================================

Original size: 32290 bytes
Chloro size:   30914 bytes
Rustfmt size:  32290 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     }
 }
 
-pub fn find_builtin_macro(
-    ident: &name::Name,
-) -> Option<Either<BuiltinFnLikeExpander, EagerExpander>> {
+pub fn find_builtin_macro(ident: &name::Name) -> Option<Either<BuiltinFnLikeExpander, EagerExpander>> {
     find_by_name(ident)
 }
-
-register_builtin! {
-    BuiltinFnLikeExpander:
-    (column, Column) => line_expand,
-    (file, File) => file_expand,
-    (line, Line) => line_expand,
-    (module_path, ModulePath) => module_path_expand,
-    (assert, Assert) => assert_expand,
-    (stringify, Stringify) => stringify_expand,
-    (asm, Asm) => asm_expand,
-    (global_asm, GlobalAsm) => global_asm_expand,
-    (naked_asm, NakedAsm) => naked_asm_expand,
-    (cfg_select, CfgSelect) => cfg_select_expand,
-    (cfg, Cfg) => cfg_expand,
-    (core_panic, CorePanic) => panic_expand,
-    (std_panic, StdPanic) => panic_expand,
-    (unreachable, Unreachable) => unreachable_expand,
-    (log_syntax, LogSyntax) => log_syntax_expand,
-    (trace_macros, TraceMacros) => trace_macros_expand,
-    (format_args, FormatArgs) => format_args_expand,
-    (const_format_args, ConstFormatArgs) => format_args_expand,
-    (format_args_nl, FormatArgsNl) => format_args_nl_expand,
-    (quote, Quote) => quote_expand,
-
-    EagerExpander:
-    (compile_error, CompileError) => compile_error_expand,
-    (concat, Concat) => concat_expand,
-    (concat_bytes, ConcatBytes) => concat_bytes_expand,
-    (include, Include) => include_expand,
-    (include_bytes, IncludeBytes) => include_bytes_expand,
-    (include_str, IncludeStr) => include_str_expand,
-    (env, Env) => env_expand,
-    (option_env, OptionEnv) => option_env_expand
-}
-
 fn mk_pound(span: Span) -> tt::Leaf {
     crate::tt::Leaf::Punct(crate::tt::Punct { char: '#', spacing: crate::tt::Spacing::Alone, span })
 }
     span: Span,
 ) -> ExpandResult<tt::TopSubtree> {
     let pretty = ::tt::pretty(tt.token_trees().flat_tokens());
-
     let expanded = quote! {span =>
         #pretty
     };
-
     ExpandResult::ok(expanded)
 }
 
     span: Span,
 ) -> ExpandResult<tt::TopSubtree> {
     let call_site_span = span_with_call_site_ctxt(db, span, id.into(), Edition::CURRENT);
-
     let mut iter = tt.iter();
-
     let cond = expect_fragment(
         &mut iter,
         parser::PrefixEntryPoint::Expr,
     );
     _ = iter.expect_char(',');
     let rest = iter.remaining();
-
     let dollar_crate = dollar_crate(span);
     let panic_args = rest.iter();
     let mac = if use_panic_2021(db, span) {
             #mac;
         }
     }};
-
     match cond.err {
         Some(err) => ExpandResult::new(expanded, err.into()),
         None => ExpandResult::ok(expanded),
     // FIXME: RA purposefully lacks knowledge of absolute file names
     // so just return "".
     let file_name = "file";
-
     let expanded = quote! {span =>
         #file_name
     };
-
     ExpandResult::ok(expanded)
 }
 
 ) -> ExpandResult<tt::TopSubtree> {
     let loc = db.lookup_intern_macro_call(id);
     let cfg_options = loc.krate.cfg_options(db);
-
     let mut iter = tt.iter();
     let mut expand_to = None;
     while let Some(next) = iter.peek() {
 ) -> ExpandResult<tt::TopSubtree> {
     let dollar_crate = dollar_crate(span);
     let call_site_span = span_with_call_site_ctxt(db, span, id.into(), Edition::CURRENT);
-
     let mac = if use_panic_2021(db, call_site_span) { sym::panic_2021 } else { sym::panic_2015 };
-
     // Pass the original arguments
     let subtree = WithDelimiter {
         delimiter: tt::Delimiter {
         },
         token_trees: tt.token_trees(),
     };
-
     // Expand to a macro call `$crate::panic::panic_{edition}`
     let call = quote!(call_site_span =>#dollar_crate::panic::#mac! #subtree);
-
     ExpandResult::ok(call)
 }
 
 ) -> ExpandResult<tt::TopSubtree> {
     let dollar_crate = dollar_crate(span);
     let call_site_span = span_with_call_site_ctxt(db, span, id.into(), Edition::CURRENT);
-
     let mac = if use_panic_2021(db, call_site_span) {
         sym::unreachable_2021
     } else {
         sym::unreachable_2015
     };
-
     // Pass the original arguments
     let mut subtree = tt.clone();
     *subtree.top_subtree_delimiter_mut() = tt::Delimiter {
         close: call_site_span,
         kind: tt::DelimiterKind::Parenthesis,
     };
-
     // Expand to a macro call `$crate::panic::panic_{edition}`
     let call = quote!(call_site_span =>#dollar_crate::panic::#mac! #subtree);
-
     ExpandResult::ok(call)
 }
 
 #[allow(clippy::never_loop)]
-fn use_panic_2021(db: &dyn ExpandDatabase, span: Span) -> bool {
+fn use_panic_2021(
+    db: &dyn ExpandDatabase,
+    span: Span,
+) -> bool {
     // To determine the edition, we check the first span up the expansion
     // stack that does not have #[allow_internal_unstable(edition_panic)].
     // (To avoid using the edition of e.g. the assert!() or debug_assert!() definition.)
         ] => ExpandError::other(span, Box::from(unescape_symbol(text).as_str())),
         _ => ExpandError::other(span, "`compile_error!` argument must be a string"),
     };
-
     ExpandResult { value: quote! {span =>}, err: Some(err) }
 }
 
         Some(_) => (),
         None => span = Some(s),
     };
-
     let mut i = 0;
     let mut iter = tt.iter();
     while let Some(mut t) = iter.next() {
             );
         }
     };
-
     // FIXME: we're not able to read excluded files (which is most of them because
     // it's unusual to `include_str!` a Rust file), but we can return an empty string.
     // Ideally, we'd be able to offer a precise expansion if the user asks for macro
             return ExpandResult::ok(quote!(call_site =>""));
         }
     };
-
     let text = db.file_text(file_id.file_id(db));
     let text = &**text.text(db);
-
     ExpandResult::ok(quote!(call_site =>#text))
 }
 
-fn get_env_inner(db: &dyn ExpandDatabase, arg_id: MacroCallId, key: &Symbol) -> Option<String> {
+fn get_env_inner(
+    db: &dyn ExpandDatabase,
+    arg_id: MacroCallId,
+    key: &Symbol,
+) -> Option<String> {
     let krate = db.lookup_intern_macro_call(arg_id).krate;
     krate.env(db).get(key.as_str())
 }
             );
         }
     };
-
     let mut err = None;
     let s = get_env_inner(db, arg_id, &key).unwrap_or_else(|| {
         // The only variable rust-analyzer ever sets is `OUT_DIR`, so only diagnose that to avoid
         "UNRESOLVED_ENV_VAR".to_owned()
     });
     let expanded = quote! {span => #s };
-
     ExpandResult { value: expanded, err }
 }
 
             quote! {call_site => #dollar_crate::option::Option::Some(#s) }
         }
     };
-
     ExpandResult::ok(expanded)
 }
 