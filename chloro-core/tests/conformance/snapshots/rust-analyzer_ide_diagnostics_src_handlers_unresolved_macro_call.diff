COMPARISON DIFF
============================================================

Original size: 2243 bytes
Chloro size:   2081 bytes
Rustfmt size:  2277 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use crate::{Diagnostic, DiagnosticCode, DiagnosticsContext};
 
-// Diagnostic: unresolved-macro-call
-//
-// This diagnostic is triggered if rust-analyzer is unable to resolve the path
-// to a macro in a macro invocation.
 pub(crate) fn unresolved_macro_call(
     ctx: &DiagnosticsContext<'_>,
     d: &hir::UnresolvedMacroCall,
     let bang = if d.is_bang { "!" } else { "" };
     Diagnostic::new(
         DiagnosticCode::RustcHardError("unresolved-macro-call"),
-        format!(
-            "unresolved macro `{}{bang}`",
-            d.path.display(ctx.sema.db, ctx.edition)
-        ),
+        format!("unresolved macro `{}{bang}`", d.path.display(ctx.sema.db, ctx.edition)),
         display_range,
     )
 }
 #[cfg(test)]
 mod tests {
     use crate::tests::check_diagnostics;
-
     #[test]
     fn unresolved_macro_diag() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn test_unresolved_macro_range() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn unresolved_legacy_scope_macro() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn unresolved_module_scope_macro() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn regression_panic_with_inner_attribute_in_presence_of_unresolved_crate() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn no_unresolved_panic_inside_mod_inside_fn() {
         check_diagnostics(