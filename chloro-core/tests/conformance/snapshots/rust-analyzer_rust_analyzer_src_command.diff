COMPARISON DIFF
============================================================

Original size: 6953 bytes
Chloro size:   6808 bytes
Rustfmt size:  7231 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 /// Cargo output is structured as one JSON per line. This trait abstracts parsing one line of
 /// cargo output into a Rust data type
-pub(crate) trait CargoParser<T>: Send + 'static {
-    fn from_line(&self, line: &str, error: &mut String) -> Option<T>;
-    fn from_eof(&self) -> Option<T>;
-}
+fn from_line(&self, line: &str, error: &mut String) -> Option<T>;
+fn from_eof(&self) -> Option<T>;
 
 struct CargoActor<T> {
     parser: Box<dyn CargoParser<T>>,
 }
 
 impl<T: Sized + Send + 'static> CargoActor<T> {
-    fn new(
-        parser: impl CargoParser<T>,
-        sender: Sender<T>,
-        stdout: ChildStdout,
-        stderr: ChildStderr,
-    ) -> Self {
+    fn new(parser: impl CargoParser<T>, sender: Sender<T>, stdout: ChildStdout, stderr: ChildStderr) -> Self {
         let parser = Box::new(parser);
-        CargoActor {
-            parser,
-            sender,
-            stdout,
-            stderr,
-        }
+        CargoActor { parser, sender, stdout, stderr }
     }
 }
 
         // Because cargo only outputs one JSON object per line, we can
         // simply skip a line if it doesn't parse, which just ignores any
         // erroneous output.
-
         let mut stdout = outfile.as_ref().and_then(|path| {
             _ = std::fs::create_dir_all(path);
-            Some(BufWriter::new(
-                std::fs::File::create(path.join("stdout")).ok()?,
-            ))
+            Some(BufWriter::new(std::fs::File::create(path.join("stdout")).ok()?))
         });
         let mut stderr = outfile.as_ref().and_then(|path| {
             _ = std::fs::create_dir_all(path);
-            Some(BufWriter::new(
-                std::fs::File::create(path.join("stderr")).ok()?,
-            ))
+            Some(BufWriter::new(std::fs::File::create(path.join("stderr")).ok()?))
         });
-
         let mut stdout_errors = String::new();
         let mut stderr_errors = String::new();
         let mut read_at_least_one_stdout_message = false;
                 }
             },
         );
-
         let read_at_least_one_message =
             read_at_least_one_stdout_message || read_at_least_one_stderr_message;
         let mut error = stdout_errors;
 }
 
 impl<T: Sized + Send + 'static> CommandHandle<T> {
-    pub(crate) fn spawn(
-        mut command: Command,
-        parser: impl CargoParser<T>,
-        sender: Sender<T>,
-        out_file: Option<Utf8PathBuf>,
-    ) -> std::io::Result<Self> {
-        command
-            .stdout(Stdio::piped())
-            .stderr(Stdio::piped())
-            .stdin(Stdio::null());
-
+    pub(crate) fn spawn(mut command: Command, parser: impl CargoParser<T>, sender: Sender<T>, out_file: Option<Utf8PathBuf>) -> std::io::Result<Self> {
+        command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());
         let program = command.get_program().into();
-        let arguments = command
-            .get_args()
-            .map(|arg| arg.into())
-            .collect::<Vec<OsString>>();
+        let arguments = command.get_args().map(|arg| arg.into()).collect::<Vec<OsString>>();
         let current_dir = command.get_current_dir().map(|arg| arg.to_path_buf());
-
         let mut child = StdCommandWrap::from(command);
         #[cfg(unix)]
         child.wrap(process_wrap::std::ProcessSession);
         #[cfg(windows)]
         child.wrap(process_wrap::std::JobObject);
         let mut child = child.spawn().map(JodGroupChild)?;
-
         let stdout = child.0.stdout().take().unwrap();
         let stderr = child.0.stderr().take().unwrap();
-
         let actor = CargoActor::<T>::new(parser, sender, stdout, stderr);
         let thread =
             stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker, "CommandHandle")
                 .spawn(move || actor.run(out_file))
                 .expect("failed to spawn thread");
-        Ok(CommandHandle {
-            program,
-            arguments,
-            current_dir,
-            child,
-            thread,
-            _phantom: PhantomData,
-        })
+        Ok(CommandHandle { program, arguments, current_dir, child, thread, _phantom: PhantomData })
     }
 
     pub(crate) fn cancel(mut self) {