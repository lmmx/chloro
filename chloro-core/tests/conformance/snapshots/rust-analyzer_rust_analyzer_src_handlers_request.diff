COMPARISON DIFF
============================================================

Original size: 101181 bytes
Chloro size:   99693 bytes
Rustfmt size:  101181 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! This module is responsible for implementing handlers for Language Server
 //! Protocol. This module specifically handles requests.
 
 use std::{fs, io::Write as _, ops::Not, process::Stdio};
 
 use anyhow::Context;
-
 use base64::{Engine, prelude::BASE64_STANDARD};
 use ide::{
     AssistKind, AssistResolveStrategy, Cancellable, CompletionFieldsToResolve, FilePosition,
     test_runner::{CargoTestHandle, TestTarget},
     try_default,
 };
-
 pub(crate) fn handle_workspace_reload(state: &mut GlobalState, _: ()) -> anyhow::Result<()> {
     state.proc_macro_clients = Arc::from_iter([]);
     state.build_deps_changed = false;
-
     let req = FetchWorkspaceRequest { path: None, force_crate_graph_reload: false };
     state.fetch_workspaces_queue.request_op("reload workspace request".to_owned(), req);
     Ok(())
 pub(crate) fn handle_proc_macros_rebuild(state: &mut GlobalState, _: ()) -> anyhow::Result<()> {
     state.proc_macro_clients = Arc::from_iter([]);
     state.build_deps_changed = false;
-
     state.fetch_build_data_queue.request_op("rebuild proc macros request".to_owned(), ());
     Ok(())
 }
 
-pub(crate) fn handle_analyzer_status(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::AnalyzerStatusParams,
-) -> anyhow::Result<String> {
+pub(crate) fn handle_analyzer_status(snap: GlobalStateSnapshot, params: lsp_ext::AnalyzerStatusParams) -> anyhow::Result<String> {
     let _p = tracing::info_span!("handle_analyzer_status").entered();
-
     let mut buf = String::new();
-
     let mut file_id = None;
     if let Some(tdi) = params.text_document {
         match from_proto::file_id(&snap, &tdi.uri) {
             Err(_) => format_to!(buf, "file {} not found in vfs", tdi.uri),
         }
     }
-
     if snap.workspaces.is_empty() {
         buf.push_str("No workspaces\n")
     } else {
             .status(file_id)
             .unwrap_or_else(|_| "Analysis retrieval was cancelled".to_owned()),
     );
-
     buf.push_str("\nVersion: \n");
     format_to!(buf, "{}", crate::version());
-
     buf.push_str("\nConfiguration: \n");
     format_to!(buf, "{:#?}", snap.config);
-
     Ok(buf)
 }
 
 pub(crate) fn handle_memory_usage(_state: &mut GlobalState, _: ()) -> anyhow::Result<String> {
     let _p = tracing::info_span!("handle_memory_usage").entered();
-
     #[cfg(not(feature = "dhat"))]
     {
         Err(anyhow::anyhow!(
     }
 }
 
-pub(crate) fn handle_view_syntax_tree(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::ViewSyntaxTreeParams,
-) -> anyhow::Result<String> {
+pub(crate) fn handle_view_syntax_tree(snap: GlobalStateSnapshot, params: lsp_ext::ViewSyntaxTreeParams) -> anyhow::Result<String> {
     let _p = tracing::info_span!("handle_view_syntax_tree").entered();
     let id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let res = snap.analysis.view_syntax_tree(id)?;
     Ok(res)
 }
 
-pub(crate) fn handle_view_hir(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<String> {
+pub(crate) fn handle_view_hir(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<String> {
     let _p = tracing::info_span!("handle_view_hir").entered();
     let position = try_default!(from_proto::file_position(&snap, params)?);
     let res = snap.analysis.view_hir(position)?;
     Ok(res)
 }
 
-pub(crate) fn handle_view_mir(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<String> {
+pub(crate) fn handle_view_mir(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<String> {
     let _p = tracing::info_span!("handle_view_mir").entered();
     let position = try_default!(from_proto::file_position(&snap, params)?);
     let res = snap.analysis.view_mir(position)?;
     Ok(res)
 }
 
-pub(crate) fn handle_interpret_function(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<String> {
+pub(crate) fn handle_interpret_function(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<String> {
     let _p = tracing::info_span!("handle_interpret_function").entered();
     let position = try_default!(from_proto::file_position(&snap, params)?);
     let res = snap.analysis.interpret_function(position)?;
     Ok(res)
 }
 
-pub(crate) fn handle_view_file_text(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentIdentifier,
-) -> anyhow::Result<String> {
+pub(crate) fn handle_view_file_text(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentIdentifier) -> anyhow::Result<String> {
     let file_id = try_default!(from_proto::file_id(&snap, &params.uri)?);
     Ok(snap.analysis.file_text(file_id)?.to_string())
 }
 
-pub(crate) fn handle_view_item_tree(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::ViewItemTreeParams,
-) -> anyhow::Result<String> {
+pub(crate) fn handle_view_item_tree(snap: GlobalStateSnapshot, params: lsp_ext::ViewItemTreeParams) -> anyhow::Result<String> {
     let _p = tracing::info_span!("handle_view_item_tree").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let res = snap.analysis.view_item_tree(file_id)?;
     Ok(res)
 }
 
-// cargo test requires:
-// - the package is a member of the workspace
-// - the target in the package is not a build script (custom-build)
-// - the package name - the root of the test identifier supplied to this handler can be
-//   a package or a target inside a package.
-// - the target name - if the test identifier is a target, it's needed in addition to the
-//   package name to run the right test
-// - real names - the test identifier uses the namespace form where hyphens are replaced with
-//   underscores. cargo test requires the real name.
-// - the target kind e.g. bin or lib
 fn all_test_targets(cargo: &CargoWorkspace) -> impl Iterator<Item = TestTarget> {
     cargo.packages().filter(|p| cargo[*p].is_member).flat_map(|p| {
         let package = &cargo[p];
     all_test_targets(cargo).find(|t| namespace_root == t.target.replace('-', "_"))
 }
 
-pub(crate) fn handle_run_test(
-    state: &mut GlobalState,
-    params: lsp_ext::RunTestParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_run_test(state: &mut GlobalState, params: lsp_ext::RunTestParams) -> anyhow::Result<()> {
     if let Some(_session) = state.test_run_session.take() {
         state.send_notification::<lsp_ext::EndRunTest>(());
     }
-
     let mut handles = vec![];
     for ws in &*state.workspaces {
         if let ProjectWorkspaceKind::Cargo { cargo, .. } = &ws.kind {
     Ok(())
 }
 
-pub(crate) fn handle_discover_test(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::DiscoverTestParams,
-) -> anyhow::Result<lsp_ext::DiscoverTestResults> {
+pub(crate) fn handle_discover_test(snap: GlobalStateSnapshot, params: lsp_ext::DiscoverTestParams) -> anyhow::Result<lsp_ext::DiscoverTestResults> {
     let _p = tracing::info_span!("handle_discover_test").entered();
     let (tests, scope) = match params.test_id {
         Some(id) => {
         }
         None => (snap.analysis.discover_test_roots()?, None),
     };
-
     Ok(lsp_ext::DiscoverTestResults {
         tests: tests
             .into_iter()
     })
 }
 
-pub(crate) fn handle_view_crate_graph(
-    snap: GlobalStateSnapshot,
-    params: ViewCrateGraphParams,
-) -> anyhow::Result<String> {
+pub(crate) fn handle_view_crate_graph(snap: GlobalStateSnapshot, params: ViewCrateGraphParams) -> anyhow::Result<String> {
     let _p = tracing::info_span!("handle_view_crate_graph").entered();
     let dot = snap.analysis.view_crate_graph(params.full)?.map_err(anyhow::Error::msg)?;
     Ok(dot)
 }
 
-pub(crate) fn handle_expand_macro(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::ExpandMacroParams,
-) -> anyhow::Result<Option<lsp_ext::ExpandedMacro>> {
+pub(crate) fn handle_expand_macro(snap: GlobalStateSnapshot, params: lsp_ext::ExpandMacroParams) -> anyhow::Result<Option<lsp_ext::ExpandedMacro>> {
     let _p = tracing::info_span!("handle_expand_macro").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let line_index = snap.file_line_index(file_id)?;
     let offset = from_proto::offset(&line_index, params.position)?;
-
     let res = snap.analysis.expand_macro(FilePosition { file_id, offset })?;
     Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))
 }
 
-pub(crate) fn handle_selection_range(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::SelectionRangeParams,
-) -> anyhow::Result<Option<Vec<lsp_types::SelectionRange>>> {
+pub(crate) fn handle_selection_range(snap: GlobalStateSnapshot, params: lsp_types::SelectionRangeParams) -> anyhow::Result<Option<Vec<lsp_types::SelectionRange>>> {
     let _p = tracing::info_span!("handle_selection_range").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let line_index = snap.file_line_index(file_id)?;
             Ok(range)
         })
         .collect();
-
     Ok(Some(res?))
 }
 
-pub(crate) fn handle_matching_brace(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::MatchingBraceParams,
-) -> anyhow::Result<Vec<Position>> {
+pub(crate) fn handle_matching_brace(snap: GlobalStateSnapshot, params: lsp_ext::MatchingBraceParams) -> anyhow::Result<Vec<Position>> {
     let _p = tracing::info_span!("handle_matching_brace").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let line_index = snap.file_line_index(file_id)?;
         .collect()
 }
 
-pub(crate) fn handle_join_lines(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::JoinLinesParams,
-) -> anyhow::Result<Vec<lsp_types::TextEdit>> {
+pub(crate) fn handle_join_lines(snap: GlobalStateSnapshot, params: lsp_ext::JoinLinesParams) -> anyhow::Result<Vec<lsp_types::TextEdit>> {
     let _p = tracing::info_span!("handle_join_lines").entered();
-
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let config = snap.config.join_lines();
     let line_index = snap.file_line_index(file_id)?;
-
     let mut res = TextEdit::default();
     for range in params.ranges {
         let range = from_proto::text_range(&line_index, range)?;
             }
         }
     }
-
     Ok(to_proto::text_edit_vec(&line_index, res))
 }
 
-pub(crate) fn handle_on_enter(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {
+pub(crate) fn handle_on_enter(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {
     let _p = tracing::info_span!("handle_on_enter").entered();
     let position = try_default!(from_proto::file_position(&snap, params)?);
     let edit = match snap.analysis.on_enter(position)? {
     Ok(Some(edit))
 }
 
-pub(crate) fn handle_on_type_formatting(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::DocumentOnTypeFormattingParams,
-) -> anyhow::Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {
+pub(crate) fn handle_on_type_formatting(snap: GlobalStateSnapshot, params: lsp_types::DocumentOnTypeFormattingParams) -> anyhow::Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {
     let _p = tracing::info_span!("handle_on_type_formatting").entered();
     let char_typed = params.ch.chars().next().unwrap_or('\0');
     if !snap.config.typing_trigger_chars().contains(char_typed) {
         return Ok(None);
     }
-
     let mut position =
         try_default!(from_proto::file_position(&snap, params.text_document_position)?);
     let line_index = snap.file_line_index(position.file_id)?;
-
     // in `ide`, the `on_type` invariant is that
     // `text.char_at(position) == typed_char`.
     position.offset -= TextSize::of('.');
-
     let text = snap.analysis.file_text(position.file_id)?;
     if stdx::never!(!text[usize::from(position.offset)..].starts_with(char_typed)) {
         return Ok(None);
     }
-
     let edit = snap.analysis.on_char_typed(position, char_typed)?;
     let edit = match edit {
         Some(it) => it,
         None => return Ok(None),
     };
-
     // This should be a single-file edit
     let (_, (text_edit, snippet_edit)) = edit.source_file_edits.into_iter().next().unwrap();
     stdx::always!(snippet_edit.is_none(), "on type formatting shouldn't use structured snippets");
-
     let change = to_proto::snippet_text_edit_vec(
         &line_index,
         edit.is_snippet,
     ))
 }
 
-pub(crate) fn handle_document_diagnostics(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::DocumentDiagnosticParams,
-) -> anyhow::Result<lsp_types::DocumentDiagnosticReportResult> {
+pub(crate) fn handle_document_diagnostics(snap: GlobalStateSnapshot, params: lsp_types::DocumentDiagnosticParams) -> anyhow::Result<lsp_types::DocumentDiagnosticReportResult> {
     let file_id = match from_proto::file_id(&snap, &params.text_document.uri)? {
         Some(it) => it,
         None => return Ok(empty_diagnostic_report()),
     }
     let line_index = snap.file_line_index(file_id)?;
     let supports_related = snap.config.text_document_diagnostic_related_document_support();
-
     let mut related_documents = FxHashMap::default();
     let diagnostics = snap
         .analysis
     ))
 }
 
-pub(crate) fn handle_document_symbol(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::DocumentSymbolParams,
-) -> anyhow::Result<Option<lsp_types::DocumentSymbolResponse>> {
+pub(crate) fn handle_document_symbol(snap: GlobalStateSnapshot, params: lsp_types::DocumentSymbolParams) -> anyhow::Result<Option<lsp_types::DocumentSymbolResponse>> {
     let _p = tracing::info_span!("handle_document_symbol").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let line_index = snap.file_line_index(file_id)?;
-
     let mut symbols: Vec<(lsp_types::DocumentSymbol, Option<usize>)> = Vec::new();
-
     let config = snap.config.document_symbol(None);
-
     let structure_nodes = snap.analysis.file_structure(
         &FileStructureConfig { exclude_locals: config.search_exclude_locals },
         file_id,
     )?;
-
     for node in structure_nodes {
         let mut tags = Vec::new();
         if node.deprecated {
         };
         symbols.push((symbol, node.parent));
     }
-
     // Builds hierarchy from a flat list, in reverse order (so that the indices make sense)
     let document_symbols = {
         let mut acc = Vec::new();
         acc.reverse();
         acc
     };
-
     let res = if snap.config.hierarchical_symbols() {
         document_symbols.into()
     } else {
         symbol_information.into()
     };
     return Ok(Some(res));
-
     fn flatten_document_symbol(
         symbol: &lsp_types::DocumentSymbol,
         container_name: Option<String>,
     }
 }
 
-pub(crate) fn handle_workspace_symbol(
-    snap: GlobalStateSnapshot,
-    params: WorkspaceSymbolParams,
-) -> anyhow::Result<Option<lsp_types::WorkspaceSymbolResponse>> {
+pub(crate) fn handle_workspace_symbol(snap: GlobalStateSnapshot, params: WorkspaceSymbolParams) -> anyhow::Result<Option<lsp_types::WorkspaceSymbolResponse>> {
     let _p = tracing::info_span!("handle_workspace_symbol").entered();
-
     let config = snap.config.workspace_symbol(None);
     let (all_symbols, libs) = decide_search_kind_and_scope(&params, &config);
-
     let query = {
         let query: String = params.query.chars().filter(|&c| c != '#' && c != '*').collect();
         let mut q = Query::new(query);
     if res.is_empty() && !all_symbols {
         res = exec_query(&snap, Query::new(params.query), config.search_limit)?;
     }
-
     return Ok(Some(lsp_types::WorkspaceSymbolResponse::Nested(res)));
-
     fn decide_search_kind_and_scope(
         params: &WorkspaceSymbolParams,
         config: &WorkspaceSymbolConfig,
 
         (all_symbols, libs)
     }
-
     fn exec_query(
         snap: &GlobalStateSnapshot,
         query: Query,
     }
 }
 
-pub(crate) fn handle_will_rename_files(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::RenameFilesParams,
-) -> anyhow::Result<Option<lsp_types::WorkspaceEdit>> {
+pub(crate) fn handle_will_rename_files(snap: GlobalStateSnapshot, params: lsp_types::RenameFilesParams) -> anyhow::Result<Option<lsp_types::WorkspaceEdit>> {
     let _p = tracing::info_span!("handle_will_rename_files").entered();
-
     let source_changes: Vec<SourceChange> = params
         .files
         .into_iter()
             snap.analysis.will_rename_file(file_id?, &new_name).ok()?
         })
         .collect();
-
     // Drop file system edits since we're just renaming things on the same level
     let mut source_changes = source_changes.into_iter();
     let mut source_change = source_changes.next().unwrap_or_default();
     }
 }
 
-pub(crate) fn handle_goto_definition(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::GotoDefinitionParams,
-) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
+pub(crate) fn handle_goto_definition(snap: GlobalStateSnapshot, params: lsp_types::GotoDefinitionParams) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
     let _p = tracing::info_span!("handle_goto_definition").entered();
     let position =
         try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     Ok(Some(res))
 }
 
-pub(crate) fn handle_goto_declaration(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::request::GotoDeclarationParams,
-) -> anyhow::Result<Option<lsp_types::request::GotoDeclarationResponse>> {
+pub(crate) fn handle_goto_declaration(snap: GlobalStateSnapshot, params: lsp_types::request::GotoDeclarationParams) -> anyhow::Result<Option<lsp_types::request::GotoDeclarationResponse>> {
     let _p = tracing::info_span!("handle_goto_declaration").entered();
     let position = try_default!(from_proto::file_position(
         &snap,
     Ok(Some(res))
 }
 
-pub(crate) fn handle_goto_implementation(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::request::GotoImplementationParams,
-) -> anyhow::Result<Option<lsp_types::request::GotoImplementationResponse>> {
+pub(crate) fn handle_goto_implementation(snap: GlobalStateSnapshot, params: lsp_types::request::GotoImplementationParams) -> anyhow::Result<Option<lsp_types::request::GotoImplementationResponse>> {
     let _p = tracing::info_span!("handle_goto_implementation").entered();
     let position =
         try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     Ok(Some(res))
 }
 
-pub(crate) fn handle_goto_type_definition(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::request::GotoTypeDefinitionParams,
-) -> anyhow::Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {
+pub(crate) fn handle_goto_type_definition(snap: GlobalStateSnapshot, params: lsp_types::request::GotoTypeDefinitionParams) -> anyhow::Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {
     let _p = tracing::info_span!("handle_goto_type_definition").entered();
     let position =
         try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     Ok(Some(res))
 }
 
-pub(crate) fn handle_parent_module(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
+pub(crate) fn handle_parent_module(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
     let _p = tracing::info_span!("handle_parent_module").entered();
     if let Ok(file_path) = &params.text_document.uri.to_file_path() {
         if file_path.file_name().unwrap_or_default() == "Cargo.toml" {
             return Ok(Some(res));
         }
     }
-
     // locate parent module by semantics
     let position = try_default!(from_proto::file_position(&snap, params)?);
     let navs = snap.analysis.parent_module(position)?;
     Ok(Some(res))
 }
 
-pub(crate) fn handle_child_modules(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
+pub(crate) fn handle_child_modules(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
     let _p = tracing::info_span!("handle_child_modules").entered();
     // locate child module by semantics
     let position = try_default!(from_proto::file_position(&snap, params)?);
     Ok(Some(res))
 }
 
-pub(crate) fn handle_runnables(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::RunnablesParams,
-) -> anyhow::Result<Vec<lsp_ext::Runnable>> {
+pub(crate) fn handle_runnables(snap: GlobalStateSnapshot, params: lsp_ext::RunnablesParams) -> anyhow::Result<Vec<lsp_ext::Runnable>> {
     let _p = tracing::info_span!("handle_runnables").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let source_root = snap.analysis.source_root_id(file_id).ok();
     let line_index = snap.file_line_index(file_id)?;
     let offset = params.position.and_then(|it| from_proto::offset(&line_index, it).ok());
     let target_spec = TargetSpec::for_file(&snap, file_id)?;
-
     let mut res = Vec::new();
     for runnable in snap.analysis.runnables(file_id)? {
         if should_skip_for_offset(&runnable, offset)
             res.push(runnable);
         }
     }
-
     // Add `cargo check` and `cargo test` for all targets of the whole package
     let config = snap.config.runnables(source_root);
     match target_spec {
     }
 }
 
-pub(crate) fn handle_related_tests(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<Vec<lsp_ext::TestInfo>> {
+pub(crate) fn handle_related_tests(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<Vec<lsp_ext::TestInfo>> {
     let _p = tracing::info_span!("handle_related_tests").entered();
     let position = try_default!(from_proto::file_position(&snap, params)?);
-
     let tests = snap.analysis.related_tests(position, None)?;
     let mut res = Vec::new();
     for it in tests {
             res.push(lsp_ext::TestInfo { runnable })
         }
     }
-
     Ok(res)
 }
 
-pub(crate) fn handle_completion(
-    snap: GlobalStateSnapshot,
-    lsp_types::CompletionParams {
+pub(crate) fn handle_completion(snap: GlobalStateSnapshot, lsp_types::CompletionParams {
         text_document_position,
         context,
         ..
-    }: lsp_types::CompletionParams,
-) -> anyhow::Result<Option<lsp_types::CompletionResponse>> {
+    }: lsp_types::CompletionParams) -> anyhow::Result<Option<lsp_types::CompletionResponse>> {
     let _p = tracing::info_span!("handle_completion").entered();
     let mut position =
         try_default!(from_proto::file_position(&snap, text_document_position.clone())?);
     let line_index = snap.file_line_index(position.file_id)?;
     let completion_trigger_character =
         context.and_then(|ctx| ctx.trigger_character).and_then(|s| s.chars().next());
-
     let source_root = snap.analysis.source_root_id(position.file_id)?;
     let completion_config = &snap.config.completion(Some(source_root), snap.minicore());
     // FIXME: We should fix up the position when retrying the cancelled request instead
         None => return Ok(None),
         Some(items) => items,
     };
-
     let items = to_proto::completion_items(
         &snap.config,
         &completion_config.fields_to_resolve,
         completion_trigger_character,
         items,
     );
-
     let completion_list = lsp_types::CompletionList { is_incomplete: true, items };
     Ok(Some(completion_list.into()))
 }
 
-pub(crate) fn handle_completion_resolve(
-    snap: GlobalStateSnapshot,
-    mut original_completion: CompletionItem,
-) -> anyhow::Result<CompletionItem> {
+pub(crate) fn handle_completion_resolve(snap: GlobalStateSnapshot, mut original_completion: CompletionItem) -> anyhow::Result<CompletionItem> {
     let _p = tracing::info_span!("handle_completion_resolve").entered();
-
     if !all_edits_are_disjoint(&original_completion, &[]) {
         return Err(invalid_params_error(
             "Received a completion with overlapping edits, this is not LSP-compliant".to_owned(),
         )
         .into());
     }
-
     let Some(data) = original_completion.data.take() else {
         return Ok(original_completion);
     };
-
     let resolve_data: lsp_ext::CompletionResolveData = serde_json::from_value(data)?;
-
     let file_id = from_proto::file_id(&snap, &resolve_data.position.text_document.uri)?
         .expect("we never provide completions for excluded files");
     let line_index = snap.file_line_index(file_id)?;
         return Ok(original_completion);
     };
     let source_root = snap.analysis.source_root_id(file_id)?;
-
     let mut forced_resolve_completions_config =
         snap.config.completion(Some(source_root), snap.minicore());
     forced_resolve_completions_config.fields_to_resolve = CompletionFieldsToResolve::empty();
-
     let position = FilePosition { file_id, offset };
     let Some(completions) = snap.analysis.completions(
         &forced_resolve_completions_config,
     let Ok(resolve_data_hash) = BASE64_STANDARD.decode(resolve_data.hash) else {
         return Ok(original_completion);
     };
-
     let Some(corresponding_completion) = completions.into_iter().find(|completion_item| {
         // Avoid computing hashes for items that obviously do not match
         // r-a might append a detail-based suffix to the label, so we cannot check for equality
     }) else {
         return Ok(original_completion);
     };
-
     let mut resolved_completions = to_proto::completion_items(
         &snap.config,
         &forced_resolve_completions_config.fields_to_resolve,
     let Some(mut resolved_completion) = resolved_completions.pop() else {
         return Ok(original_completion);
     };
-
     if !resolve_data.imports.is_empty() {
         let additional_edits = snap
             .analysis
             resolved_completion.additional_text_edits = Some(additional_edits);
         }
     }
-
     Ok(resolved_completion)
 }
 
-pub(crate) fn handle_folding_range(
-    snap: GlobalStateSnapshot,
-    params: FoldingRangeParams,
-) -> anyhow::Result<Option<Vec<FoldingRange>>> {
+pub(crate) fn handle_folding_range(snap: GlobalStateSnapshot, params: FoldingRangeParams) -> anyhow::Result<Option<Vec<FoldingRange>>> {
     let _p = tracing::info_span!("handle_folding_range").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let folds = snap.analysis.folding_ranges(file_id)?;
     Ok(Some(res))
 }
 
-pub(crate) fn handle_signature_help(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::SignatureHelpParams,
-) -> anyhow::Result<Option<lsp_types::SignatureHelp>> {
+pub(crate) fn handle_signature_help(snap: GlobalStateSnapshot, params: lsp_types::SignatureHelpParams) -> anyhow::Result<Option<lsp_types::SignatureHelp>> {
     let _p = tracing::info_span!("handle_signature_help").entered();
     let position =
         try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     Ok(Some(res))
 }
 
-pub(crate) fn handle_hover(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::HoverParams,
-) -> anyhow::Result<Option<lsp_ext::Hover>> {
+pub(crate) fn handle_hover(snap: GlobalStateSnapshot, params: lsp_ext::HoverParams) -> anyhow::Result<Option<lsp_ext::Hover>> {
     let _p = tracing::info_span!("handle_hover").entered();
     let range = match params.position {
         PositionOrRange::Position(position) => Range::new(position, position),
         PositionOrRange::Range(range) => range,
     };
     let file_range = try_default!(from_proto::file_range(&snap, &params.text_document, range)?);
-
     let hover = snap.config.hover(snap.minicore());
     let info = match snap.analysis.hover(&hover, file_range)? {
         None => return Ok(None),
         Some(info) => info,
     };
-
     let line_index = snap.file_line_index(file_range.file_id)?;
     let range = to_proto::range(&line_index, info.range);
     let markup_kind = hover.format;
             prepare_hover_actions(&snap, &info.info.actions)
         },
     };
-
     Ok(Some(hover))
 }
 
-pub(crate) fn handle_prepare_rename(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<Option<PrepareRenameResponse>> {
+pub(crate) fn handle_prepare_rename(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<Option<PrepareRenameResponse>> {
     let _p = tracing::info_span!("handle_prepare_rename").entered();
     let position = try_default!(from_proto::file_position(&snap, params)?);
-
     let change = snap.analysis.prepare_rename(position)?.map_err(to_proto::rename_error)?;
-
     let line_index = snap.file_line_index(position.file_id)?;
     let range = to_proto::range(&line_index, change.range);
     Ok(Some(PrepareRenameResponse::Range(range)))
 }
 
-pub(crate) fn handle_rename(
-    snap: GlobalStateSnapshot,
-    params: RenameParams,
-) -> anyhow::Result<Option<WorkspaceEdit>> {
+pub(crate) fn handle_rename(snap: GlobalStateSnapshot, params: RenameParams) -> anyhow::Result<Option<WorkspaceEdit>> {
     let _p = tracing::info_span!("handle_rename").entered();
     let position = try_default!(from_proto::file_position(&snap, params.text_document_position)?);
-
     let source_root = snap.analysis.source_root_id(position.file_id).ok();
     let config = snap.config.rename(source_root);
     let mut change = snap
         .analysis
         .rename(position, &params.new_name, &config)?
         .map_err(to_proto::rename_error)?;
-
     // this is kind of a hack to prevent double edits from happening when moving files
     // When a module gets renamed by renaming the mod declaration this causes the file to move
     // which in turn will trigger a WillRenameFiles request to the server for which we reply with a
     if !change.file_system_edits.is_empty() && snap.config.will_rename() {
         change.source_file_edits.clear();
     }
-
     let workspace_edit = to_proto::workspace_edit(&snap, change)?;
-
     if let Some(lsp_types::DocumentChanges::Operations(ops)) =
         workspace_edit.document_changes.as_ref()
     {
             }
         }
     }
-
     Ok(Some(workspace_edit))
 }
 
-pub(crate) fn handle_references(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::ReferenceParams,
-) -> anyhow::Result<Option<Vec<Location>>> {
+pub(crate) fn handle_references(snap: GlobalStateSnapshot, params: lsp_types::ReferenceParams) -> anyhow::Result<Option<Vec<Location>>> {
     let _p = tracing::info_span!("handle_references").entered();
     let position = try_default!(from_proto::file_position(&snap, params.text_document_position)?);
-
     let exclude_imports = snap.config.find_all_refs_exclude_imports();
     let exclude_tests = snap.config.find_all_refs_exclude_tests();
-
     let Some(refs) = snap.analysis.find_all_refs(
         position,
         &FindAllRefsConfig { search_scope: None, minicore: snap.minicore() },
     else {
         return Ok(None);
     };
-
     let include_declaration = params.context.include_declaration;
     let locations = refs
         .into_iter()
         .unique()
         .filter_map(|frange| to_proto::location(&snap, frange).ok())
         .collect();
-
     Ok(Some(locations))
 }
 
-pub(crate) fn handle_formatting(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::DocumentFormattingParams,
-) -> anyhow::Result<Option<Vec<lsp_types::TextEdit>>> {
+pub(crate) fn handle_formatting(snap: GlobalStateSnapshot, params: lsp_types::DocumentFormattingParams) -> anyhow::Result<Option<Vec<lsp_types::TextEdit>>> {
     let _p = tracing::info_span!("handle_formatting").entered();
-
     run_rustfmt(&snap, params.text_document, None)
 }
 
-pub(crate) fn handle_range_formatting(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::DocumentRangeFormattingParams,
-) -> anyhow::Result<Option<Vec<lsp_types::TextEdit>>> {
+pub(crate) fn handle_range_formatting(snap: GlobalStateSnapshot, params: lsp_types::DocumentRangeFormattingParams) -> anyhow::Result<Option<Vec<lsp_types::TextEdit>>> {
     let _p = tracing::info_span!("handle_range_formatting").entered();
-
     run_rustfmt(&snap, params.text_document, Some(params.range))
 }
 
-pub(crate) fn handle_code_action(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::CodeActionParams,
-) -> anyhow::Result<Option<Vec<lsp_ext::CodeAction>>> {
+pub(crate) fn handle_code_action(snap: GlobalStateSnapshot, params: lsp_types::CodeActionParams) -> anyhow::Result<Option<Vec<lsp_ext::CodeAction>>> {
     let _p = tracing::info_span!("handle_code_action").entered();
-
     if !snap.config.code_action_literals() {
         // We intentionally don't support command-based actions, as those either
         // require either custom client-code or server-initiated edits. Server
         // initiated edits break causality, so we avoid those.
         return Ok(None);
     }
-
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let line_index = snap.file_line_index(file_id)?;
     let frange = try_default!(from_proto::file_range(&snap, &params.text_document, params.range)?);
     let source_root = snap.analysis.source_root_id(file_id)?;
-
     let mut assists_config = snap.config.assist(Some(source_root));
     assists_config.allowed = params
         .context
         .only
         .clone()
         .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());
-
     let mut res: Vec<lsp_ext::CodeAction> = Vec::new();
-
     let code_action_resolve_cap = snap.config.code_action_resolve();
     let resolve = if code_action_resolve_cap {
         AssistResolveStrategy::None
 
         res.push(code_action)
     }
-
     // Fixes from `cargo check`.
     for fix in snap
         .check_fixes
             res.push(fix.action.clone());
         }
     }
-
     Ok(Some(res))
 }
 
-pub(crate) fn handle_code_action_resolve(
-    snap: GlobalStateSnapshot,
-    mut code_action: lsp_ext::CodeAction,
-) -> anyhow::Result<lsp_ext::CodeAction> {
+pub(crate) fn handle_code_action_resolve(snap: GlobalStateSnapshot, mut code_action: lsp_ext::CodeAction) -> anyhow::Result<lsp_ext::CodeAction> {
     let _p = tracing::info_span!("handle_code_action_resolve").entered();
     let Some(params) = code_action.data.take() else {
         return Ok(code_action);
     };
-
     let file_id = from_proto::file_id(&snap, &params.code_action_params.text_document.uri)?
         .expect("we never provide code actions for excluded files");
     if snap.file_version(file_id) != params.version {
     let range = from_proto::text_range(&line_index, params.code_action_params.range)?;
     let frange = FileRange { file_id, range };
     let source_root = snap.analysis.source_root_id(file_id)?;
-
     let mut assists_config = snap.config.assist(Some(source_root));
     assists_config.allowed = params
         .code_action_params
         .context
         .only
         .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());
-
     let (assist_index, assist_resolve) = match parse_action_id(&params.id) {
         Ok(parsed_data) => parsed_data,
         Err(e) => {
             .into());
         }
     };
-
     let expected_assist_id = assist_resolve.assist_id.clone();
     let expected_kind = assist_resolve.assist_kind;
-
     let assists = snap.analysis.assists_with_fixes(
         &assists_config,
         &snap.config.diagnostic_fixes(Some(source_root)),
         AssistResolveStrategy::Single(assist_resolve),
         frange,
     )?;
-
     let assist = match assists.get(assist_index) {
         Some(assist) => assist,
         None => return Err(invalid_params_error(format!(
     let ca = to_proto::code_action(&snap, &snap.config.client_commands(), assist.clone(), None)?;
     code_action.edit = ca.edit;
     code_action.command = ca.command;
-
     if let Some(edit) = code_action.edit.as_ref()
         && let Some(changes) = edit.document_changes.as_ref()
     {
             }
         }
     }
-
     Ok(code_action)
 }
 
     }
 }
 
-pub(crate) fn handle_code_lens(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::CodeLensParams,
-) -> anyhow::Result<Option<Vec<CodeLens>>> {
+pub(crate) fn handle_code_lens(snap: GlobalStateSnapshot, params: lsp_types::CodeLensParams) -> anyhow::Result<Option<Vec<CodeLens>>> {
     let _p = tracing::info_span!("handle_code_lens").entered();
-
     let lens_config = snap.config.lens();
     if lens_config.none() {
         // early return before any db query!
         return Ok(Some(Vec::default()));
     }
-
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let target_spec = TargetSpec::for_file(&snap, file_id)?;
-
     let annotations = snap.analysis.annotations(
         &lens_config.into_annotation_config(
             target_spec
         ),
         file_id,
     )?;
-
     let mut res = Vec::new();
     for a in annotations {
         to_proto::code_lens(&mut res, &snap, a)?;
     }
-
     Ok(Some(res))
 }
 
-pub(crate) fn handle_code_lens_resolve(
-    snap: GlobalStateSnapshot,
-    mut code_lens: CodeLens,
-) -> anyhow::Result<CodeLens> {
+pub(crate) fn handle_code_lens_resolve(snap: GlobalStateSnapshot, mut code_lens: CodeLens) -> anyhow::Result<CodeLens> {
     let Some(data) = code_lens.data.take() else {
         return Ok(code_lens);
     };
     };
     let config = snap.config.lens().into_annotation_config(false, snap.minicore());
     let annotation = snap.analysis.resolve_annotation(&config, annotation)?;
-
     let mut acc = Vec::new();
     to_proto::code_lens(&mut acc, &snap, annotation)?;
-
     let mut res = match acc.pop() {
         Some(it) if acc.is_empty() => it,
         _ => {
         }
     };
     res.data = None;
-
     Ok(res)
 }
 
-pub(crate) fn handle_document_highlight(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::DocumentHighlightParams,
-) -> anyhow::Result<Option<Vec<lsp_types::DocumentHighlight>>> {
+pub(crate) fn handle_document_highlight(snap: GlobalStateSnapshot, params: lsp_types::DocumentHighlightParams) -> anyhow::Result<Option<Vec<lsp_types::DocumentHighlight>>> {
     let _p = tracing::info_span!("handle_document_highlight").entered();
     let position =
         try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     let line_index = snap.file_line_index(position.file_id)?;
     let source_root = snap.analysis.source_root_id(position.file_id)?;
-
     let refs = match snap
         .analysis
         .highlight_related(snap.config.highlight_related(Some(source_root)), position)?
     Ok(Some(res))
 }
 
-pub(crate) fn handle_ssr(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::SsrParams,
-) -> anyhow::Result<lsp_types::WorkspaceEdit> {
+pub(crate) fn handle_ssr(snap: GlobalStateSnapshot, params: lsp_ext::SsrParams) -> anyhow::Result<lsp_types::WorkspaceEdit> {
     let _p = tracing::info_span!("handle_ssr").entered();
     let selections = try_default!(
         params
     to_proto::workspace_edit(&snap, source_change).map_err(Into::into)
 }
 
-pub(crate) fn handle_inlay_hints(
-    snap: GlobalStateSnapshot,
-    params: InlayHintParams,
-) -> anyhow::Result<Option<Vec<InlayHint>>> {
+pub(crate) fn handle_inlay_hints(snap: GlobalStateSnapshot, params: InlayHintParams) -> anyhow::Result<Option<Vec<InlayHint>>> {
     let _p = tracing::info_span!("handle_inlay_hints").entered();
     let document_uri = &params.text_document.uri;
     let FileRange { file_id, range } = try_default!(from_proto::file_range(
         range.start().min(line_index.index.len()),
         range.end().min(line_index.index.len()),
     );
-
     let inlay_hints_config = snap.config.inlay_hints(snap.minicore());
     Ok(Some(
         snap.analysis
     ))
 }
 
-pub(crate) fn handle_inlay_hints_resolve(
-    snap: GlobalStateSnapshot,
-    mut original_hint: InlayHint,
-) -> anyhow::Result<InlayHint> {
+pub(crate) fn handle_inlay_hints_resolve(snap: GlobalStateSnapshot, mut original_hint: InlayHint) -> anyhow::Result<InlayHint> {
     let _p = tracing::info_span!("handle_inlay_hints_resolve").entered();
-
     let Some(data) = original_hint.data.take() else {
         return Ok(original_hint);
     };
         return Ok(original_hint);
     };
     anyhow::ensure!(snap.file_exists(file_id), "Invalid LSP resolve data");
-
     let line_index = snap.file_line_index(file_id)?;
     let range = from_proto::text_range(&line_index, resolve_data.resolve_range)?;
-
     let mut forced_resolve_inlay_hints_config = snap.config.inlay_hints(snap.minicore());
     forced_resolve_inlay_hints_config.fields_to_resolve = InlayFieldsToResolve::empty();
     let resolve_hints = snap.analysis.inlay_hints_resolve(
             )
         },
     )?;
-
     Ok(resolve_hints
         .and_then(|it| {
             to_proto::inlay_hint(
         .unwrap_or(original_hint))
 }
 
-pub(crate) fn handle_call_hierarchy_prepare(
-    snap: GlobalStateSnapshot,
-    params: CallHierarchyPrepareParams,
-) -> anyhow::Result<Option<Vec<CallHierarchyItem>>> {
+pub(crate) fn handle_call_hierarchy_prepare(snap: GlobalStateSnapshot, params: CallHierarchyPrepareParams) -> anyhow::Result<Option<Vec<CallHierarchyItem>>> {
     let _p = tracing::info_span!("handle_call_hierarchy_prepare").entered();
     let position =
         try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
-
     let config = snap.config.call_hierarchy(snap.minicore());
     let nav_info = match snap.analysis.call_hierarchy(position, &config)? {
         None => return Ok(None),
         Some(it) => it,
     };
-
     let RangeInfo { range: _, info: navs } = nav_info;
     let res = navs
         .into_iter()
         .filter(|it| matches!(it.kind, Some(SymbolKind::Function | SymbolKind::Method)))
         .map(|it| to_proto::call_hierarchy_item(&snap, it))
         .collect::<Cancellable<Vec<_>>>()?;
-
     Ok(Some(res))
 }
 
-pub(crate) fn handle_call_hierarchy_incoming(
-    snap: GlobalStateSnapshot,
-    params: CallHierarchyIncomingCallsParams,
-) -> anyhow::Result<Option<Vec<CallHierarchyIncomingCall>>> {
+pub(crate) fn handle_call_hierarchy_incoming(snap: GlobalStateSnapshot, params: CallHierarchyIncomingCallsParams) -> anyhow::Result<Option<Vec<CallHierarchyIncomingCall>>> {
     let _p = tracing::info_span!("handle_call_hierarchy_incoming").entered();
     let item = params.item;
-
     let doc = TextDocumentIdentifier::new(item.uri);
     let frange = try_default!(from_proto::file_range(&snap, &doc, item.selection_range)?);
     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };
-
     let config = snap.config.call_hierarchy(snap.minicore());
     let call_items = match snap.analysis.incoming_calls(&config, fpos)? {
         None => return Ok(None),
         Some(it) => it,
     };
-
     let mut res = vec![];
-
     for call_item in call_items.into_iter() {
         let file_id = call_item.target.file_id;
         let line_index = snap.file_line_index(file_id)?;
                 .collect(),
         });
     }
-
     Ok(Some(res))
 }
 
-pub(crate) fn handle_call_hierarchy_outgoing(
-    snap: GlobalStateSnapshot,
-    params: CallHierarchyOutgoingCallsParams,
-) -> anyhow::Result<Option<Vec<CallHierarchyOutgoingCall>>> {
+pub(crate) fn handle_call_hierarchy_outgoing(snap: GlobalStateSnapshot, params: CallHierarchyOutgoingCallsParams) -> anyhow::Result<Option<Vec<CallHierarchyOutgoingCall>>> {
     let _p = tracing::info_span!("handle_call_hierarchy_outgoing").entered();
     let item = params.item;
-
     let doc = TextDocumentIdentifier::new(item.uri);
     let frange = try_default!(from_proto::file_range(&snap, &doc, item.selection_range)?);
     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };
     let line_index = snap.file_line_index(fpos.file_id)?;
-
     let config = snap.config.call_hierarchy(snap.minicore());
     let call_items = match snap.analysis.outgoing_calls(&config, fpos)? {
         None => return Ok(None),
         Some(it) => it,
     };
-
     let mut res = vec![];
-
     for call_item in call_items.into_iter() {
         let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;
         res.push(CallHierarchyOutgoingCall {
                 .collect(),
         });
     }
-
     Ok(Some(res))
 }
 
-pub(crate) fn handle_semantic_tokens_full(
-    snap: GlobalStateSnapshot,
-    params: SemanticTokensParams,
-) -> anyhow::Result<Option<SemanticTokensResult>> {
+pub(crate) fn handle_semantic_tokens_full(snap: GlobalStateSnapshot, params: SemanticTokensParams) -> anyhow::Result<Option<SemanticTokensResult>> {
     let _p = tracing::info_span!("handle_semantic_tokens_full").entered();
-
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let text = snap.analysis.file_text(file_id)?;
     let line_index = snap.file_line_index(file_id)?;
-
     let mut highlight_config = snap.config.highlighting_config(snap.minicore());
     // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.
     highlight_config.syntactic_name_ref_highlighting =
         snap.workspaces.is_empty() || !snap.proc_macros_loaded;
-
     let highlights = snap.analysis.highlight(highlight_config, file_id)?;
     let semantic_tokens = to_proto::semantic_tokens(
         &text,
         snap.config.semantics_tokens_augments_syntax_tokens(),
         snap.config.highlighting_non_standard_tokens(),
     );
-
     // Unconditionally cache the tokens
     snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens.clone());
-
     Ok(Some(semantic_tokens.into()))
 }
 
-pub(crate) fn handle_semantic_tokens_full_delta(
-    snap: GlobalStateSnapshot,
-    params: SemanticTokensDeltaParams,
-) -> anyhow::Result<Option<SemanticTokensFullDeltaResult>> {
+pub(crate) fn handle_semantic_tokens_full_delta(snap: GlobalStateSnapshot, params: SemanticTokensDeltaParams) -> anyhow::Result<Option<SemanticTokensFullDeltaResult>> {
     let _p = tracing::info_span!("handle_semantic_tokens_full_delta").entered();
-
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let text = snap.analysis.file_text(file_id)?;
     let line_index = snap.file_line_index(file_id)?;
-
     let mut highlight_config = snap.config.highlighting_config(snap.minicore());
     // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.
     highlight_config.syntactic_name_ref_highlighting =
         snap.workspaces.is_empty() || !snap.proc_macros_loaded;
-
     let highlights = snap.analysis.highlight(highlight_config, file_id)?;
     let semantic_tokens = to_proto::semantic_tokens(
         &text,
         snap.config.semantics_tokens_augments_syntax_tokens(),
         snap.config.highlighting_non_standard_tokens(),
     );
-
     let cached_tokens = snap.semantic_tokens_cache.lock().remove(&params.text_document.uri);
-
     if let Some(cached_tokens @ lsp_types::SemanticTokens { result_id: Some(prev_id), .. }) =
         &cached_tokens
         && *prev_id == params.previous_result_id
         snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens);
         return Ok(Some(delta.into()));
     }
-
     // Clone first to keep the lock short
     let semantic_tokens_clone = semantic_tokens.clone();
     snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens_clone);
-
     Ok(Some(semantic_tokens.into()))
 }
 
-pub(crate) fn handle_semantic_tokens_range(
-    snap: GlobalStateSnapshot,
-    params: SemanticTokensRangeParams,
-) -> anyhow::Result<Option<SemanticTokensRangeResult>> {
+pub(crate) fn handle_semantic_tokens_range(snap: GlobalStateSnapshot, params: SemanticTokensRangeParams) -> anyhow::Result<Option<SemanticTokensRangeResult>> {
     let _p = tracing::info_span!("handle_semantic_tokens_range").entered();
-
     let frange = try_default!(from_proto::file_range(&snap, &params.text_document, params.range)?);
     let text = snap.analysis.file_text(frange.file_id)?;
     let line_index = snap.file_line_index(frange.file_id)?;
-
     let mut highlight_config = snap.config.highlighting_config(snap.minicore());
     // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.
     highlight_config.syntactic_name_ref_highlighting =
         snap.workspaces.is_empty() || !snap.proc_macros_loaded;
-
     let highlights = snap.analysis.highlight_range(highlight_config, frange)?;
     let semantic_tokens = to_proto::semantic_tokens(
         &text,
     Ok(Some(semantic_tokens.into()))
 }
 
-pub(crate) fn handle_open_docs(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<ExternalDocsResponse> {
+pub(crate) fn handle_open_docs(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<ExternalDocsResponse> {
     let _p = tracing::info_span!("handle_open_docs").entered();
     let position = try_default!(from_proto::file_position(&snap, params)?);
-
     let ws_and_sysroot = snap.workspaces.iter().find_map(|ws| match &ws.kind {
         ProjectWorkspaceKind::Cargo { cargo, .. }
         | ProjectWorkspaceKind::DetachedFile { cargo: Some((cargo, _, _)), .. } => {
         ProjectWorkspaceKind::Json { .. } => None,
         ProjectWorkspaceKind::DetachedFile { .. } => None,
     });
-
     let (cargo, sysroot) = match ws_and_sysroot {
         Some((ws, sysroot)) => (Some(ws), Some(sysroot)),
         _ => (None, None),
     };
-
     let sysroot = sysroot.and_then(|p| p.root()).map(|it| it.as_str());
     let target_dir = cargo.map(|cargo| cargo.target_directory()).map(|p| p.as_str());
-
     let Ok(remote_urls) = snap.analysis.external_docs(position, target_dir, sysroot) else {
         return if snap.config.local_docs() {
             Ok(ExternalDocsResponse::WithLocal(Default::default()))
             Ok(ExternalDocsResponse::Simple(None))
         };
     };
-
     let web = remote_urls.web_url.and_then(|it| Url::parse(&it).ok());
     let local = remote_urls.local_url.and_then(|it| Url::parse(&it).ok());
-
     if snap.config.local_docs() {
         Ok(ExternalDocsResponse::WithLocal(ExternalDocsPair { web, local }))
     } else {
     }
 }
 
-pub(crate) fn handle_open_cargo_toml(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::OpenCargoTomlParams,
-) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
+pub(crate) fn handle_open_cargo_toml(snap: GlobalStateSnapshot, params: lsp_ext::OpenCargoTomlParams) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
     let _p = tracing::info_span!("handle_open_cargo_toml").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
-
     let cargo_spec = match TargetSpec::for_file(&snap, file_id)? {
         Some(TargetSpec::Cargo(it)) => it,
         Some(TargetSpec::ProjectJson(_)) | None => return Ok(None),
     };
-
     let cargo_toml_url = to_proto::url_from_abs_path(&cargo_spec.cargo_toml);
     let res: lsp_types::GotoDefinitionResponse =
         Location::new(cargo_toml_url, Range::default()).into();
     Ok(Some(res))
 }
 
-pub(crate) fn handle_move_item(
-    snap: GlobalStateSnapshot,
-    params: lsp_ext::MoveItemParams,
-) -> anyhow::Result<Vec<lsp_ext::SnippetTextEdit>> {
+pub(crate) fn handle_move_item(snap: GlobalStateSnapshot, params: lsp_ext::MoveItemParams) -> anyhow::Result<Vec<lsp_ext::SnippetTextEdit>> {
     let _p = tracing::info_span!("handle_move_item").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let range = try_default!(from_proto::file_range(&snap, &params.text_document, params.range)?);
-
     let direction = match params.direction {
         lsp_ext::MoveItemDirection::Up => ide::Direction::Up,
         lsp_ext::MoveItemDirection::Down => ide::Direction::Down,
     };
-
     match snap.analysis.move_item(range, direction)? {
         Some(text_edit) => {
             let line_index = snap.file_line_index(file_id)?;
     }
 }
 
-pub(crate) fn handle_view_recursive_memory_layout(
-    snap: GlobalStateSnapshot,
-    params: lsp_types::TextDocumentPositionParams,
-) -> anyhow::Result<Option<lsp_ext::RecursiveMemoryLayout>> {
+pub(crate) fn handle_view_recursive_memory_layout(snap: GlobalStateSnapshot, params: lsp_types::TextDocumentPositionParams) -> anyhow::Result<Option<lsp_ext::RecursiveMemoryLayout>> {
     let _p = tracing::info_span!("handle_view_recursive_memory_layout").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let line_index = snap.file_line_index(file_id)?;
     let offset = from_proto::offset(&line_index, params.position)?;
-
     let res = snap.analysis.get_recursive_memory_layout(FilePosition { file_id, offset })?;
     Ok(res.map(|it| lsp_ext::RecursiveMemoryLayout {
         nodes: it
     lsp_ext::CommandLink { tooltip: Some(tooltip), command }
 }
 
-fn show_impl_command_link(
-    snap: &GlobalStateSnapshot,
-    position: &FilePosition,
-    implementations: bool,
-    show_references: bool,
-) -> Option<lsp_ext::CommandLinkGroup> {
+fn show_impl_command_link(snap: &GlobalStateSnapshot, position: &FilePosition, implementations: bool, show_references: bool) -> Option<lsp_ext::CommandLinkGroup> {
     if implementations
         && show_references
         && let Some(nav_data) = snap
     None
 }
 
-fn show_ref_command_link(
-    snap: &GlobalStateSnapshot,
-    position: &FilePosition,
-    references: bool,
-    show_reference: bool,
-) -> Option<lsp_ext::CommandLinkGroup> {
+fn show_ref_command_link(snap: &GlobalStateSnapshot, position: &FilePosition, references: bool, show_reference: bool) -> Option<lsp_ext::CommandLinkGroup> {
     if references
         && show_reference
         && let Some(ref_search_res) = snap
     None
 }
 
-fn runnable_action_links(
-    snap: &GlobalStateSnapshot,
-    runnable: Runnable,
-    hover_actions_config: &HoverActionsConfig,
-    client_commands_config: &ClientCommandsConfig,
-) -> Option<lsp_ext::CommandLinkGroup> {
+fn runnable_action_links(snap: &GlobalStateSnapshot, runnable: Runnable, hover_actions_config: &HoverActionsConfig, client_commands_config: &ClientCommandsConfig) -> Option<lsp_ext::CommandLinkGroup> {
     if !hover_actions_config.runnable() {
         return None;
     }
-
     let target_spec = TargetSpec::for_file(snap, runnable.nav.file_id).ok()?;
     if should_skip_target(&runnable, target_spec.as_ref()) {
         return None;
     }
-
     if !(client_commands_config.run_single || client_commands_config.debug_single) {
         return None;
     }
-
     let title = runnable.title();
     let update_test = runnable.update_test;
     let r = to_proto::runnable(snap, runnable).ok()??;
-
     let mut group = lsp_ext::CommandLinkGroup::default();
-
     if hover_actions_config.run && client_commands_config.run_single {
         let run_command = to_proto::command::run_single(&r, &title);
         group.commands.push(to_command_link(run_command, r.label.clone()));
     }
-
     if hover_actions_config.debug && client_commands_config.debug_single {
         let dbg_command = to_proto::command::debug_single(&r);
         group.commands.push(to_command_link(dbg_command, r.label.clone()));
     }
-
     if hover_actions_config.update_test && client_commands_config.run_single {
         let label = update_test.label();
         if let Some(r) = to_proto::make_update_runnable(&r, update_test) {
             group.commands.push(to_command_link(update_command, r.label));
         }
     }
-
     Some(group)
 }
 
-fn goto_type_action_links(
-    snap: &GlobalStateSnapshot,
-    nav_targets: &[HoverGotoTypeData],
-    hover_actions: &HoverActionsConfig,
-    client_commands: &ClientCommandsConfig,
-) -> Option<lsp_ext::CommandLinkGroup> {
+fn goto_type_action_links(snap: &GlobalStateSnapshot, nav_targets: &[HoverGotoTypeData], hover_actions: &HoverActionsConfig, client_commands: &ClientCommandsConfig) -> Option<lsp_ext::CommandLinkGroup> {
     if !hover_actions.goto_type_def || nav_targets.is_empty() || !client_commands.goto_location {
         return None;
     }
-
     Some(lsp_ext::CommandLinkGroup {
         title: Some("Go to ".into()),
         commands: nav_targets
     })
 }
 
-fn prepare_hover_actions(
-    snap: &GlobalStateSnapshot,
-    actions: &[HoverAction],
-) -> Vec<lsp_ext::CommandLinkGroup> {
+fn prepare_hover_actions(snap: &GlobalStateSnapshot, actions: &[HoverAction]) -> Vec<lsp_ext::CommandLinkGroup> {
     let hover_actions = snap.config.hover_actions();
     let client_commands = snap.config.client_commands();
     actions
     }
 }
 
-fn run_rustfmt(
-    snap: &GlobalStateSnapshot,
-    text_document: TextDocumentIdentifier,
-    range: Option<lsp_types::Range>,
-) -> anyhow::Result<Option<Vec<lsp_types::TextEdit>>> {
+fn run_rustfmt(snap: &GlobalStateSnapshot, text_document: TextDocumentIdentifier, range: Option<lsp_types::Range>) -> anyhow::Result<Option<Vec<lsp_types::TextEdit>>> {
     let file_id = try_default!(from_proto::file_id(snap, &text_document.uri)?);
     let file = snap.analysis.file_text(file_id)?;
-
     // Determine the edition of the crate the file belongs to (if there's multiple, we pick the
     // highest edition).
     let Ok(editions) = snap
         return Ok(None);
     };
     let edition = editions.iter().copied().max();
-
     let line_index = snap.file_line_index(file_id)?;
     let source_root_id = snap.analysis.source_root_id(file_id).ok();
-
     // try to chdir to the file so we can respect `rustfmt.toml`
     // FIXME: use `rustfmt --config-path` once
     // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed
             std::env::current_dir()?
         }
     };
-
     let mut command = match snap.config.rustfmt(source_root_id) {
         RustfmtConfig::Rustfmt { extra_args, enable_range_formatting } => {
             // FIXME: Set RUSTUP_TOOLCHAIN
             cmd
         }
     };
-
     let output = {
         let _p = tracing::info_span!("rustfmt", ?command).entered();
 
 
         rustfmt.wait_with_output()?
     };
-
     let captured_stdout = String::from_utf8(output.stdout)?;
     let captured_stderr = String::from_utf8(output.stderr).unwrap_or_default();
-
     if !output.status.success() {
         let rustfmt_not_installed =
             captured_stderr.contains("not installed") || captured_stderr.contains("not available");
             }
         };
     }
-
     let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);
-
     if line_index.endings != new_line_endings {
         // If line endings are different, send the entire file.
         // Diffing would not work here, as the line endings might be the only
     }
 }
 
-pub(crate) fn fetch_dependency_list(
-    state: GlobalStateSnapshot,
-    _params: FetchDependencyListParams,
-) -> anyhow::Result<FetchDependencyListResult> {
+pub(crate) fn fetch_dependency_list(state: GlobalStateSnapshot, _params: FetchDependencyListParams) -> anyhow::Result<FetchDependencyListResult> {
     let crates = state.analysis.fetch_crates()?;
     let crate_infos = crates
         .into_iter()
     Ok(FetchDependencyListResult { crates: crate_infos })
 }
 
-pub(crate) fn internal_testing_fetch_config(
-    state: GlobalStateSnapshot,
-    params: InternalTestingFetchConfigParams,
-) -> anyhow::Result<Option<InternalTestingFetchConfigResponse>> {
+pub(crate) fn internal_testing_fetch_config(state: GlobalStateSnapshot, params: InternalTestingFetchConfigParams) -> anyhow::Result<Option<InternalTestingFetchConfigResponse>> {
     let source_root = match params.text_document {
         Some(it) => Some(
             state
         )
         .into());
     }
-
     Ok(())
 }
 
 
 pub(crate) fn diff(left: &str, right: &str) -> TextEdit {
     use dissimilar::Chunk;
-
     let chunks = dissimilar::diff(left, right);
-
     let mut builder = TextEdit::builder();
     let mut pos = TextSize::default();
-
     let mut chunks = chunks.into_iter().peekable();
     while let Some(chunk) = chunks.next() {
         if let (Chunk::Delete(deleted), Some(&Chunk::Insert(inserted))) = (chunk, chunks.peek()) {