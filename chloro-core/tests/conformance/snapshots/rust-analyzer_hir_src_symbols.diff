COMPARISON DIFF
============================================================

Original size: 18922 bytes
Chloro size:   18778 bytes
Rustfmt size:  19198 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! File symbol extraction.
 
 use base_db::FxIndexSet;
 use either::Either;
 use hir_def::{
+    AdtId, AssocItemId, Complete, DefWithBodyId, ExternCrateId, HasModule, ImplId, Lookup, MacroId,
+    ModuleDefId, ModuleId, TraitId,
     db::DefDatabase,
     item_scope::{ImportId, ImportOrExternCrate, ImportOrGlob},
     per_ns::Item,
     src::{HasChildSource, HasSource},
     visibility::{Visibility, VisibilityExplicitness},
-    AdtId, AssocItemId, Complete, DefWithBodyId, ExternCrateId, HasModule, ImplId, Lookup, MacroId,
-    ModuleDefId, ModuleId, TraitId,
 };
-use hir_expand::{name::Name, HirFileId};
+use hir_expand::{HirFileId, name::Name};
 use hir_ty::{
     db::HirDatabase,
-    display::{hir_display_with_store, HirDisplay},
+    display::{HirDisplay, hir_display_with_store},
 };
 use intern::Symbol;
 use rustc_hash::FxHashMap;
-use syntax::{ast::HasName, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, ToSmolStr};
+use syntax::{AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, ToSmolStr, ast::HasName};
 
 use crate::{HasCrate, Module, ModuleDef, Semantics};
-
 /// The actual data that is stored in the index. It should be as compact as
 /// possible.
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
         }
     }
 
-    pub fn new_module(
-        db: &dyn HirDatabase,
-        module: Module,
-        collect_pub_only: bool,
-    ) -> Box<[FileSymbol]> {
+    pub fn new_module(db: &dyn HirDatabase, module: Module, collect_pub_only: bool) -> Box<[FileSymbol]> {
         let mut symbol_collector = SymbolCollector::new(db, collect_pub_only);
         symbol_collector.collect(module);
         symbol_collector.finish()
     pub fn collect(&mut self, module: Module) {
         let _p = tracing::info_span!("SymbolCollector::collect", ?module).entered();
         tracing::info!(?module, "SymbolCollector::collect");
-
         // The initial work is the root module we're collecting, additional work will
         // be populated as we traverse the module's definitions.
-        self.work.push(SymbolCollectorWork {
-            module_id: module.into(),
-            parent: None,
-        });
-
+        self.work.push(SymbolCollectorWork { module_id: module.into(), parent: None });
         while let Some(work) = self.work.pop() {
             self.do_work(work);
         }
         let _p = tracing::info_span!("SymbolCollector::do_work", ?work).entered();
         tracing::info!(?work, "SymbolCollector::do_work");
         self.db.unwind_if_revision_cancelled();
-
         let parent_name = work.parent.map(|name| Symbol::intern(name.as_str()));
         self.with_container_name(parent_name, |s| s.collect_from_module(work.module_id));
     }
                 ModuleDefId::EnumVariantId(_) => {}
             }
         };
-
         // Nested trees are very common, so a cache here will hit a lot.
         let import_child_source_cache = &mut FxHashMap::default();
-
         let is_explicit_import = |vis| match vis {
             Visibility::Public => true,
             Visibility::PubCrate(_) => true,
             Visibility::Module(_, VisibilityExplicitness::Explicit) => true,
             Visibility::Module(_, VisibilityExplicitness::Implicit) => false,
         };
-
         let mut push_import = |this: &mut Self, i: ImportId, name: &Name, def: ModuleDefId, vis| {
             if collect_pub_only && vis != Visibility::Public {
                 return;
             let source = import_child_source_cache
                 .entry(i.use_)
                 .or_insert_with(|| i.use_.child_source(this.db));
-            let Some(use_tree_src) = source.value.get(i.idx) else {
-                return;
-            };
+            let Some(use_tree_src) = source.value.get(i.idx) else { return };
             let rename = use_tree_src.rename().and_then(|rename| rename.name());
             let name_syntax = match rename {
                 Some(name) => Some(Either::Left(name)),
-                None if is_explicit_import(vis) => (|| {
-                    use_tree_src
-                        .path()?
-                        .segment()?
-                        .name_ref()
-                        .map(Either::Right)
-                })(),
+                None if is_explicit_import(vis) => {
+                    (|| use_tree_src.path()?.segment()?.name_ref().map(Either::Right))()
+                }
                 None => None,
             };
             let Some(name_syntax) = name_syntax else {
                 do_not_complete: Complete::Yes,
             });
         };
-
         let push_extern_crate =
             |this: &mut Self, i: ExternCrateId, name: &Name, def: ModuleDefId, vis| {
                 if collect_pub_only && vis != Visibility::Public {
                     do_not_complete: Complete::Yes,
                 });
             };
-
         let def_map = module_id.def_map(self.db);
         let scope = &def_map[module_id.local_id].scope;
-
         for impl_id in scope.impls() {
             self.collect_from_impl(impl_id);
         }
-
         for (name, Item { def, vis, import }) in scope.types() {
             if let Some(i) = import {
                 match i {
             // self is a declaration
             push_decl(self, def, name, vis)
         }
-
         for (name, Item { def, vis, import }) in scope.macros() {
             if let Some(i) = import {
                 match i {
             // self is a declaration
             push_decl(self, ModuleDefId::MacroId(def), name, vis)
         }
-
         for (name, Item { def, vis, import }) in scope.values() {
             if let Some(i) = import {
                 match i {
             // self is a declaration
             push_decl(self, def, name, vis)
         }
-
         for const_id in scope.unnamed_consts() {
             self.collect_from_body(const_id, None);
         }
-
         for (name, id) in scope.legacy_macros() {
             for &id in id {
                 if id.module(self.db) == module_id {
         }
         let body_id = body_id.into();
         let body = self.db.body(body_id);
-
         // Descend into the blocks and enqueue collection of all modules within.
         for (_, def_map) in body.blocks(self.db) {
             for (id, _) in def_map.modules() {
             hir_display_with_store(impl_data.self_ty, &impl_data.store)
                 .display(
                     self.db,
-                    crate::Impl::from(impl_id)
-                        .krate(self.db)
-                        .to_display_target(self.db),
+                    crate::Impl::from(impl_id).krate(self.db).to_display_target(self.db),
                 )
                 .to_smolstr(),
         );
         }
     }
 
-    fn push_assoc_item(
-        &mut self,
-        assoc_item_id: AssocItemId,
-        name: &Name,
-        trait_do_not_complete: Option<Complete>,
-    ) {
+    fn push_assoc_item(&mut self, assoc_item_id: AssocItemId, name: &Name, trait_do_not_complete: Option<Complete>) {
         match assoc_item_id {
             AssocItemId::FunctionId(id) => self.push_decl(id, name, true, trait_do_not_complete),
             AssocItemId::ConstId(id) => self.push_decl(id, name, true, trait_do_not_complete),
         };
     }
 
-    fn push_decl<L>(
-        &mut self,
-        id: L,
-        name: &Name,
-        is_assoc: bool,
-        trait_do_not_complete: Option<Complete>,
-    ) -> Complete
+    fn push_decl<L>(&mut self, id: L, name: &Name, is_assoc: bool, trait_do_not_complete: Option<Complete>) -> Complete
     where
         L: Lookup<Database = dyn DefDatabase> + Into<ModuleDefId>,
         <L as Lookup>::Data: HasSource,
-        <<L as Lookup>::Data as HasSource>::Value: HasName,
-    {
+        <<L as Lookup>::Data as HasSource>::Value: HasName, {
         let loc = id.lookup(self.db);
         let source = loc.source(self.db);
-        let Some(name_node) = source.value.name() else {
-            return Complete::Yes;
-        };
+        let Some(name_node) = source.value.name() else { return Complete::Yes };
         let def = ModuleDef::from(id.into());
         let dec_loc = DeclarationLocation {
             hir_file_id: source.file_id,
             ptr: SyntaxNodePtr::new(source.value.syntax()),
             name_ptr: AstPtr::new(&name_node).wrap_left(),
         };
-
         let mut do_not_complete = Complete::Yes;
-
         if let Some(attrs) = def.attrs(self.db) {
             do_not_complete = Complete::extract(matches!(def, ModuleDef::Trait(_)), &attrs);
             if let Some(trait_do_not_complete) = trait_do_not_complete {
                 });
             }
         }
-
         self.symbols.insert(FileSymbol {
             name: name.symbol().clone(),
             def,
             is_import: false,
             do_not_complete,
         });
-
         do_not_complete
     }
 
     fn push_module(&mut self, module_id: ModuleId, name: &Name) {
         let def_map = module_id.def_map(self.db);
         let module_data = &def_map[module_id.local_id];
-        let Some(declaration) = module_data.origin.declaration() else {
-            return;
-        };
+        let Some(declaration) = module_data.origin.declaration() else { return };
         let module = declaration.to_node(self.db);
-        let Some(name_node) = module.name() else {
-            return;
-        };
+        let Some(name_node) = module.name() else { return };
         let dec_loc = DeclarationLocation {
             hir_file_id: declaration.file_id,
             ptr: SyntaxNodePtr::new(module.syntax()),
             name_ptr: AstPtr::new(&name_node).wrap_left(),
         };
-
         let def = ModuleDef::Module(module_id.into());
-
         let mut do_not_complete = Complete::Yes;
         if let Some(attrs) = def.attrs(self.db) {
             do_not_complete = Complete::extract(matches!(def, ModuleDef::Trait(_)), &attrs);
                 });
             }
         }
-
         self.symbols.insert(FileSymbol {
             name: name.symbol().clone(),
             def: ModuleDef::Module(module_id.into()),