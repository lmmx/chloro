COMPARISON DIFF
============================================================

Original size: 29385 bytes
Chloro size:   29220 bytes
Rustfmt size:  29385 bytes

✗ Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //!
 //! The correct behavior in such cases is probably to show a dialog to the user.
 //! Our current behavior is ¯\_(ツ)_/¯.
+
 use std::fmt::{self, Display};
 
-use crate::{
-    source_change::ChangeAnnotation,
-    text_edit::{TextEdit, TextEditBuilder},
-};
+pub use _bail as bail;
+pub use _format_err as format_err;
 use base_db::AnchoredPathBuf;
 use either::Either;
 use hir::{FieldSource, FileRange, InFile, ModuleSource, Name, Semantics, sym};
     syntax_helpers::node_ext::expr_as_name_ref,
     traits::convert_to_def_in_trait,
 };
+use crate::{
+    source_change::ChangeAnnotation,
+    text_edit::{TextEdit, TextEditBuilder},
+};
 
 pub type Result<T, E = RenameError> = std::result::Result<T, E>;
 
     ($fmt:expr) => { RenameError(format!($fmt)) };
     ($fmt:expr, $($arg:tt)+) => { RenameError(format!($fmt, $($arg)+)) }
 }
-pub use _format_err as format_err;
 
 #[macro_export]
 macro_rules! _bail {
     ($($tokens:tt)*) => { return Err(format_err!($($tokens)*)) }
 }
-pub use _bail as bail;
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub enum RenameDefinition {
 }
 
 impl Definition {
-    pub fn rename(
-        &self,
-        sema: &Semantics<'_, RootDatabase>,
-        new_name: &str,
-        rename_definition: RenameDefinition,
-    ) -> Result<SourceChange> {
+    pub fn rename(&self, sema: &Semantics<'_, RootDatabase>, new_name: &str, rename_definition: RenameDefinition) -> Result<SourceChange> {
         // self.krate() returns None if
         // self is a built-in attr, built-in type or tool module.
         // it is not allowed for these defs to be renamed.
         } else {
             Edition::LATEST
         };
-
         match *self {
             Definition::Module(module) => rename_mod(sema, module, new_name),
             Definition::ToolModule(_) => {
             Definition::DeriveHelper(_) => return None,
         };
         return res;
-
         fn name_range<D>(
             def: D,
             sema: &Semantics<'_, RootDatabase>,
     }
 }
 
-fn rename_mod(
-    sema: &Semantics<'_, RootDatabase>,
-    module: hir::Module,
-    new_name: &str,
-) -> Result<SourceChange> {
+fn rename_mod(sema: &Semantics<'_, RootDatabase>, module: hir::Module, new_name: &str) -> Result<SourceChange> {
     let mut source_change = SourceChange::default();
-
     if module.is_crate_root() {
         return Ok(source_change);
     }
-
     let InFile { file_id, value: def_source } = module.definition_source(sema.db);
     let edition = file_id.edition(sema.db);
     let (new_name, kind) = IdentifierKind::classify(edition, new_name)?;
             })
         }
     }
-
     if let Some(src) = module.declaration_source(sema.db) {
         let file_id = src.file_id.original_file(sema.db);
         match src.value.name() {
             _ => never!("Module source node is missing a name"),
         }
     }
-
     let def = Definition::Module(module);
     let usages = def.usages(sema).all();
     let ref_edits = usages.iter().map(|(file_id, references)| {
         )
     });
     source_change.extend(ref_edits);
-
     Ok(source_change)
 }
 
-fn rename_reference(
-    sema: &Semantics<'_, RootDatabase>,
-    def: Definition,
-    new_name: &str,
-    rename_definition: RenameDefinition,
-    edition: Edition,
-) -> Result<SourceChange> {
+fn rename_reference(sema: &Semantics<'_, RootDatabase>, def: Definition, new_name: &str, rename_definition: RenameDefinition, edition: Edition) -> Result<SourceChange> {
     let (mut new_name, ident_kind) = IdentifierKind::classify(edition, new_name)?;
-
     if matches!(
         def,
         Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)
             }
         }
     }
-
     let def = convert_to_def_in_trait(sema.db, def);
     let usages = def.usages(sema).all();
-
     if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {
         cov_mark::hit!(rename_underscore_multiple);
         bail!("Cannot rename reference to `_` as it is being referenced multiple times");
     Ok(source_change)
 }
 
-pub fn source_edit_from_references(
-    db: &RootDatabase,
-    references: &[FileReference],
-    def: Definition,
-    new_name: &Name,
-    edition: Edition,
-) -> TextEdit {
+pub fn source_edit_from_references(db: &RootDatabase, references: &[FileReference], def: Definition, new_name: &Name, edition: Edition) -> TextEdit {
     let name_display = new_name.display(db, edition);
     let mut edit = TextEdit::builder();
     // macros can cause multiple refs to occur for the same text range, so keep track of what we have edited so far
             edited_ranges.push(range.start());
         }
     }
-
     edit.finish()
 }
 
-fn source_edit_from_name(
-    edit: &mut TextEditBuilder,
-    name: &ast::Name,
-    new_name: &dyn Display,
-) -> bool {
+fn source_edit_from_name(edit: &mut TextEditBuilder, name: &ast::Name, new_name: &dyn Display) -> bool {
     if ast::RecordPatField::for_field_name(name).is_some()
         && let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast)
     {
         edit.insert(ident_pat.syntax().text_range().start(), format!("{new_name}: "));
         return true;
     }
-
     false
 }
 
-fn source_edit_from_name_ref(
-    edit: &mut TextEditBuilder,
-    name_ref: &ast::NameRef,
-    new_name: &dyn Display,
-    def: Definition,
-) -> bool {
+fn source_edit_from_name_ref(edit: &mut TextEditBuilder, name_ref: &ast::NameRef, new_name: &dyn Display, def: Definition) -> bool {
     if name_ref.super_token().is_some() {
         return true;
     }
-
     if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {
         let rcf_name_ref = record_field.name_ref();
         let rcf_expr = record_field.expr();
     false
 }
 
-fn source_edit_from_def(
-    sema: &Semantics<'_, RootDatabase>,
-    def: Definition,
-    new_name: &Name,
-    source_change: &mut SourceChange,
-) -> Result<(FileId, TextEdit)> {
+fn source_edit_from_def(sema: &Semantics<'_, RootDatabase>, def: Definition, new_name: &Name, source_change: &mut SourceChange) -> Result<(FileId, TextEdit)> {
     let mut edit = TextEdit::builder();
     if let Definition::Local(local) = def {
         let mut file_id = None;