COMPARISON DIFF
============================================================

Original size: 13159 bytes
Chloro size:   12783 bytes
Rustfmt size:  13159 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
         util::sizedness_fast_path,
     },
 };
-
 use super::{
     DbInterner, ErrorGuaranteed, GenericArg, SolverDefId, Span,
     infer::{DbInternerInferExt, InferCtxt, canonical::instantiate::CanonicalExt},
 
 impl<'db> SolverDelegate for SolverContext<'db> {
     type Interner = DbInterner<'db>;
+
     type Infcx = InferCtxt<'db>;
 
     fn cx(&self) -> Self::Interner {
         self.0.interner
     }
 
-    fn build_with_canonical<V>(
-        cx: Self::Interner,
-        canonical: &rustc_type_ir::CanonicalQueryInput<Self::Interner, V>,
-    ) -> (Self, V, rustc_type_ir::CanonicalVarValues<Self::Interner>)
+    fn build_with_canonical<V>(cx: Self::Interner, canonical: &rustc_type_ir::CanonicalQueryInput<Self::Interner, V>) -> (Self, V, rustc_type_ir::CanonicalVarValues<Self::Interner>)
     where
-        V: rustc_type_ir::TypeFoldable<Self::Interner>,
-    {
+        V: rustc_type_ir::TypeFoldable<Self::Interner>, {
         let (infcx, value, vars) = cx.infer_ctxt().build_with_canonical(canonical);
         (SolverContext(infcx), value, vars)
     }
         }
     }
 
-    fn leak_check(
-        &self,
-        _max_input_universe: rustc_type_ir::UniverseIndex,
-    ) -> Result<(), NoSolution> {
+    fn leak_check(&self, _max_input_universe: rustc_type_ir::UniverseIndex) -> Result<(), NoSolution> {
         Ok(())
     }
 
-    fn well_formed_goals(
-        &self,
-        _param_env: ParamEnv<'db>,
-        _arg: <Self::Interner as rustc_type_ir::Interner>::Term,
-    ) -> Option<
+    fn well_formed_goals(&self, _param_env: ParamEnv<'db>, _arg: <Self::Interner as rustc_type_ir::Interner>::Term) -> Option<
         Vec<
             rustc_type_ir::solve::Goal<
                 Self::Interner,
         None
     }
 
-    fn make_deduplicated_outlives_constraints(
-        &self,
-    ) -> Vec<
+    fn make_deduplicated_outlives_constraints(&self) -> Vec<
         rustc_type_ir::OutlivesPredicate<
             Self::Interner,
             <Self::Interner as rustc_type_ir::Interner>::GenericArg,
         vec![]
     }
 
-    fn instantiate_canonical<V>(
-        &self,
-        canonical: rustc_type_ir::Canonical<Self::Interner, V>,
-        values: rustc_type_ir::CanonicalVarValues<Self::Interner>,
-    ) -> V
+    fn instantiate_canonical<V>(&self, canonical: rustc_type_ir::Canonical<Self::Interner, V>, values: rustc_type_ir::CanonicalVarValues<Self::Interner>) -> V
     where
-        V: rustc_type_ir::TypeFoldable<Self::Interner>,
-    {
+        V: rustc_type_ir::TypeFoldable<Self::Interner>, {
         canonical.instantiate(self.cx(), &values)
     }
 
-    fn instantiate_canonical_var(
-        &self,
-        kind: CanonicalVarKind<'db>,
-        _span: <Self::Interner as Interner>::Span,
-        var_values: &[GenericArg<'db>],
-        universe_map: impl Fn(rustc_type_ir::UniverseIndex) -> rustc_type_ir::UniverseIndex,
-    ) -> GenericArg<'db> {
+    fn instantiate_canonical_var(&self, kind: CanonicalVarKind<'db>, _span: <Self::Interner as Interner>::Span, var_values: &[GenericArg<'db>], universe_map: impl Fn(rustc_type_ir::UniverseIndex) -> rustc_type_ir::UniverseIndex) -> GenericArg<'db> {
         self.0.instantiate_canonical_var(kind, var_values, universe_map)
     }
 
-    fn add_item_bounds_for_hidden_type(
-        &self,
-        def_id: SolverDefId,
-        args: GenericArgs<'db>,
-        param_env: ParamEnv<'db>,
-        hidden_ty: Ty<'db>,
-        goals: &mut Vec<Goal<'db, Predicate<'db>>>,
-    ) {
+    fn add_item_bounds_for_hidden_type(&self, def_id: SolverDefId, args: GenericArgs<'db>, param_env: ParamEnv<'db>, hidden_ty: Ty<'db>, goals: &mut Vec<Goal<'db, Predicate<'db>>>) {
         let interner = self.interner;
         let opaque_id = def_id.expect_opaque_ty();
         // Require that the hidden type is well-formed. We have to
         // lifetime for its member constraints which then results in
         // unexpected region errors.
         goals.push(Goal::new(interner, param_env, ClauseKind::WellFormed(hidden_ty.into())));
-
         let replace_opaques_in = |clause: Clause<'db>| {
             fold_tys(interner, clause, |ty| match ty.kind() {
                 // Replace all other mentions of the same opaque type with the hidden type,
                 _ => ty,
             })
         };
-
         let db = interner.db;
         let (opaques_table, opaque_idx) = match opaque_id.loc(db) {
             ImplTraitId::ReturnTypeImplTrait(func, opaque_idx) => {
         }
     }
 
-    fn fetch_eligible_assoc_item(
-        &self,
-        _goal_trait_ref: rustc_type_ir::TraitRef<Self::Interner>,
-        trait_assoc_def_id: SolverDefId,
-        impl_id: ImplIdWrapper,
-    ) -> Result<Option<SolverDefId>, ErrorGuaranteed> {
+    fn fetch_eligible_assoc_item(&self, _goal_trait_ref: rustc_type_ir::TraitRef<Self::Interner>, trait_assoc_def_id: SolverDefId, impl_id: ImplIdWrapper) -> Result<Option<SolverDefId>, ErrorGuaranteed> {
         let impl_items = impl_id.0.impl_items(self.0.interner.db());
         let id = match trait_assoc_def_id {
             SolverDefId::TypeAliasId(trait_assoc_id) => {
         Ok(id)
     }
 
-    fn is_transmutable(
-        &self,
-        _dst: Ty<'db>,
-        _src: Ty<'db>,
-        _assume: <Self::Interner as rustc_type_ir::Interner>::Const,
-    ) -> Result<Certainty, NoSolution> {
+    fn is_transmutable(&self, _dst: Ty<'db>, _src: Ty<'db>, _assume: <Self::Interner as rustc_type_ir::Interner>::Const) -> Result<Certainty, NoSolution> {
         unimplemented!()
     }
 
-    fn evaluate_const(
-        &self,
-        _param_env: ParamEnv<'db>,
-        uv: rustc_type_ir::UnevaluatedConst<Self::Interner>,
-    ) -> Option<<Self::Interner as rustc_type_ir::Interner>::Const> {
+    fn evaluate_const(&self, _param_env: ParamEnv<'db>, uv: rustc_type_ir::UnevaluatedConst<Self::Interner>) -> Option<<Self::Interner as rustc_type_ir::Interner>::Const> {
         let c = match uv.def {
             SolverDefId::ConstId(c) => GeneralConstId::ConstId(c),
             SolverDefId::StaticId(c) => GeneralConstId::StaticId(c),
         Some(ec)
     }
 
-    fn compute_goal_fast_path(
-        &self,
-        goal: rustc_type_ir::solve::Goal<
+    fn compute_goal_fast_path(&self, goal: rustc_type_ir::solve::Goal<
             Self::Interner,
             <Self::Interner as rustc_type_ir::Interner>::Predicate,
-        >,
-        _span: <Self::Interner as rustc_type_ir::Interner>::Span,
-    ) -> Option<Certainty> {
+        >, _span: <Self::Interner as rustc_type_ir::Interner>::Span) -> Option<Certainty> {
         if let Some(trait_pred) = goal.predicate.as_trait_clause() {
             if self.shallow_resolve(trait_pred.self_ty().skip_binder()).is_ty_var()
                 // We don't do this fast path when opaques are defined since we may
                 }
             }
         }
-
         let pred = goal.predicate.kind();
         match pred.no_bound_vars()? {
             PredicateKind::Clause(ClauseKind::RegionOutlives(_outlives)) => Some(Certainty::Yes),