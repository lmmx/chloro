COMPARISON DIFF
============================================================

Original size: 5559 bytes
Chloro size:   5464 bytes
Rustfmt size:  5644 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Fold impls for the next-trait-solver.
 
 use rustc_type_ir::{
-    inherent::IntoKind, BoundVarIndexKind, DebruijnIndex, RegionKind, TypeFoldable, TypeFolder,
-    TypeSuperFoldable, TypeVisitableExt,
+    BoundVarIndexKind, DebruijnIndex, RegionKind, TypeFoldable, TypeFolder, TypeSuperFoldable,
+    TypeVisitableExt, inherent::IntoKind,
 };
 
 use crate::next_solver::BoundConst;
-
 use super::{
     Binder, BoundRegion, BoundTy, Const, ConstKind, DbInterner, Predicate, Region, Ty, TyKind,
 };
 /// Any implementation must make sure that each bound variable always
 /// gets mapped to the same result. `BoundVarReplacer` caches by using
 /// a `DelayedMap` which does not cache the first few types it encounters.
-pub trait BoundVarReplacerDelegate<'db> {
-    fn replace_region(&mut self, br: BoundRegion) -> Region<'db>;
-    fn replace_ty(&mut self, bt: BoundTy) -> Ty<'db>;
-    fn replace_const(&mut self, bv: BoundConst) -> Const<'db>;
-}
+fn replace_region(&mut self, br: BoundRegion) -> Region<'db>;
+fn replace_ty(&mut self, bt: BoundTy) -> Ty<'db>;
+fn replace_const(&mut self, bv: BoundConst) -> Const<'db>;
 
 /// A simple delegate taking 3 mutable functions. The used functions must
 /// always return the same result for each bound variable, no matter how
     fn replace_region(&mut self, br: BoundRegion) -> Region<'db> {
         (self.regions)(br)
     }
+
     fn replace_ty(&mut self, bt: BoundTy) -> Ty<'db> {
         (self.types)(bt)
     }
+
     fn replace_const(&mut self, bv: BoundConst) -> Const<'db> {
         (self.consts)(bv)
     }
     /// As with `RegionFolder`, represents the index of a binder *just outside*
     /// the ones we have visited.
     current_index: DebruijnIndex,
-
     delegate: D,
 }
 
 impl<'db, D: BoundVarReplacerDelegate<'db>> BoundVarReplacer<'db, D> {
     pub(crate) fn new(tcx: DbInterner<'db>, delegate: D) -> Self {
-        BoundVarReplacer {
-            interner: tcx,
-            current_index: DebruijnIndex::ZERO,
-            delegate,
-        }
+        BoundVarReplacer { interner: tcx, current_index: DebruijnIndex::ZERO, delegate }
     }
 }
 
 impl<'db, D> TypeFolder<DbInterner<'db>> for BoundVarReplacer<'db, D>
 where
-    D: BoundVarReplacerDelegate<'db>,
-{
+    D: BoundVarReplacerDelegate<'db>, {
     fn cx(&self) -> DbInterner<'db> {
         self.interner
     }
 
-    fn fold_binder<T: TypeFoldable<DbInterner<'db>>>(
-        &mut self,
-        t: Binder<'db, T>,
-    ) -> Binder<'db, T> {
+    fn fold_binder<T: TypeFoldable<DbInterner<'db>>>(&mut self, t: Binder<'db, T>) -> Binder<'db, T> {
         self.current_index.shift_in(1);
         let t = t.super_fold_with(self);
         self.current_index.shift_out(1);
     }
 
     fn fold_predicate(&mut self, p: Predicate<'db>) -> Predicate<'db> {
-        if p.has_vars_bound_at_or_above(self.current_index) {
-            p.super_fold_with(self)
-        } else {
-            p
-        }
+        if p.has_vars_bound_at_or_above(self.current_index) { p.super_fold_with(self) } else { p }
     }
 }
 
-pub fn fold_tys<'db, T: TypeFoldable<DbInterner<'db>>>(
-    interner: DbInterner<'db>,
-    t: T,
-    callback: impl FnMut(Ty<'db>) -> Ty<'db>,
-) -> T {
+pub fn fold_tys<'db, T: TypeFoldable<DbInterner<'db>>>(interner: DbInterner<'db>, t: T, callback: impl FnMut(Ty<'db>) -> Ty<'db>) -> T {
     struct Folder<'db, F> {
         interner: DbInterner<'db>,
         callback: F,
             (self.callback)(t)
         }
     }
-
     t.fold_with(&mut Folder { interner, callback })
 }