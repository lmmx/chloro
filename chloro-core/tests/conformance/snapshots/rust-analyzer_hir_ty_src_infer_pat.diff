COMPARISON DIFF
============================================================

Original size: 25364 bytes
Chloro size:   24844 bytes
Rustfmt size:  25364 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     /// Infers type for tuple struct pattern or its corresponding assignee expression.
     ///
     /// Ellipses found in the original pattern or expression must be filtered out.
-    pub(super) fn infer_tuple_struct_pat_like(
-        &mut self,
-        path: Option<&Path>,
-        expected: Ty<'db>,
-        default_bm: BindingMode,
-        id: PatId,
-        ellipsis: Option<u32>,
-        subs: &[PatId],
-        decl: Option<DeclContext>,
-    ) -> Ty<'db> {
+    pub(super) fn infer_tuple_struct_pat_like(&mut self, path: Option<&Path>, expected: Ty<'db>, default_bm: BindingMode, id: PatId, ellipsis: Option<u32>, subs: &[PatId], decl: Option<DeclContext>) -> Ty<'db> {
         let (ty, def) = self.resolve_variant(id.into(), path, true);
         let var_data = def.map(|it| it.fields(self.db));
         if let Some(variant) = def {
                 });
             }
         }
-
         self.unify(ty, expected);
-
         match def {
             _ if subs.is_empty() => {}
             Some(def) => {
                 }
             }
         }
-
         ty
     }
 
     /// Infers type for record pattern or its corresponding assignee expression.
-    pub(super) fn infer_record_pat_like(
-        &mut self,
-        path: Option<&Path>,
-        expected: Ty<'db>,
-        default_bm: BindingMode,
-        id: PatId,
-        subs: impl ExactSizeIterator<Item = (Name, PatId)>,
-        decl: Option<DeclContext>,
-    ) -> Ty<'db> {
+    pub(super) fn infer_record_pat_like(&mut self, path: Option<&Path>, expected: Ty<'db>, default_bm: BindingMode, id: PatId, subs: impl ExactSizeIterator<Item = (Name, PatId)>, decl: Option<DeclContext>) -> Ty<'db> {
         let (ty, def) = self.resolve_variant(id.into(), path, false);
         if let Some(variant) = def {
             self.write_variant_resolution(id.into(), variant);
         }
-
         self.unify(ty, expected);
-
         match def {
             _ if subs.len() == 0 => {}
             Some(def) => {
                 }
             }
         }
-
         ty
     }
 
     /// Infers type for tuple pattern or its corresponding assignee expression.
     ///
     /// Ellipses found in the original pattern or expression must be filtered out.
-    pub(super) fn infer_tuple_pat_like(
-        &mut self,
-        expected: Ty<'db>,
-        default_bm: BindingMode,
-        ellipsis: Option<u32>,
-        subs: &[PatId],
-        decl: Option<DeclContext>,
-    ) -> Ty<'db> {
+    pub(super) fn infer_tuple_pat_like(&mut self, expected: Ty<'db>, default_bm: BindingMode, ellipsis: Option<u32>, subs: &[PatId], decl: Option<DeclContext>) -> Ty<'db> {
         let expected = self.table.structurally_resolve_type(expected);
         let expectations = match expected.kind() {
             TyKind::Tuple(parameters) => parameters,
             _ => self.types.empty_tys,
         };
-
         let ((pre, post), n_uncovered_patterns) = match ellipsis {
             Some(idx) => {
                 (subs.split_at(idx as usize), expectations.len().saturating_sub(subs.len()))
         };
         let mut expectations_iter =
             expectations.iter().chain(repeat_with(|| self.table.next_ty_var()));
-
         let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + subs.len());
-
         inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns + subs.len()));
-
         // Process pre
         for (ty, pat) in inner_tys.iter_mut().zip(pre) {
             *ty = self.infer_pat(*pat, *ty, default_bm, decl);
         }
-
         // Process post
         for (ty, pat) in inner_tys.iter_mut().skip(pre.len() + n_uncovered_patterns).zip(post) {
             *ty = self.infer_pat(*pat, *ty, default_bm, decl);
         }
-
         Ty::new_tup_from_iter(self.interner(), inner_tys.into_iter())
     }
 
     /// The resolver needs to be updated to the surrounding expression when inside assignment
     /// (because there, `Pat::Path` can refer to a variable).
-    pub(super) fn infer_top_pat(
-        &mut self,
-        pat: PatId,
-        expected: Ty<'db>,
-        decl: Option<DeclContext>,
-    ) {
+    pub(super) fn infer_top_pat(&mut self, pat: PatId, expected: Ty<'db>, decl: Option<DeclContext>) {
         self.infer_pat(pat, expected, BindingMode::default(), decl);
     }
 
-    fn infer_pat(
-        &mut self,
-        pat: PatId,
-        expected: Ty<'db>,
-        mut default_bm: BindingMode,
-        decl: Option<DeclContext>,
-    ) -> Ty<'db> {
+    fn infer_pat(&mut self, pat: PatId, expected: Ty<'db>, mut default_bm: BindingMode, decl: Option<DeclContext>) -> Ty<'db> {
         let mut expected = self.table.structurally_resolve_type(expected);
-
         if matches!(&self.body[pat], Pat::Ref { .. }) || self.inside_assignment {
             cov_mark::hit!(match_ergonomics_ref);
             // When you encounter a `&pat` pattern, reset to Move.
                 self.result.pat_adjustments.insert(pat, pat_adjustments);
             }
         }
-
         // Lose mutability.
         let default_bm = default_bm;
         let expected = expected;
-
         let ty = match &self.body[pat] {
             Pat::Tuple { args, ellipsis } => {
                 self.infer_tuple_pat_like(expected, default_bm, *ellipsis, args, decl)
             .unwrap_or(&self.result.type_of_pat[pat])
     }
 
-    fn infer_ref_pat(
-        &mut self,
-        inner_pat: PatId,
-        mutability: Mutability,
-        expected: Ty<'db>,
-        default_bm: BindingMode,
-        decl: Option<DeclContext>,
-    ) -> Ty<'db> {
+    fn infer_ref_pat(&mut self, inner_pat: PatId, mutability: Mutability, expected: Ty<'db>, default_bm: BindingMode, decl: Option<DeclContext>) -> Ty<'db> {
         let (expectation_type, expectation_lt) = match expected.kind() {
             TyKind::Ref(lifetime, inner_ty, _exp_mut) => (inner_ty, lifetime),
             _ => {
         Ty::new_ref(self.interner(), expectation_lt, subty, mutability)
     }
 
-    fn infer_bind_pat(
-        &mut self,
-        pat: PatId,
-        binding: BindingId,
-        default_bm: BindingMode,
-        subpat: Option<PatId>,
-        expected: Ty<'db>,
-        decl: Option<DeclContext>,
-    ) -> Ty<'db> {
+    fn infer_bind_pat(&mut self, pat: PatId, binding: BindingId, default_bm: BindingMode, subpat: Option<PatId>, expected: Ty<'db>, decl: Option<DeclContext>) -> Ty<'db> {
         let Binding { mode, .. } = self.body[binding];
         let mode = if mode == BindingAnnotation::Unannotated {
             default_bm
             BindingMode::convert(mode)
         };
         self.result.binding_modes.insert(pat, mode);
-
         let inner_ty = match subpat {
             Some(subpat) => self.infer_pat(subpat, expected, default_bm, decl),
             None => expected,
         };
         let inner_ty = self.insert_type_vars_shallow(inner_ty);
-
         let bound_ty = match mode {
             BindingMode::Ref(mutability) => {
                 let inner_lt = self.table.next_region_var();
         inner_ty
     }
 
-    fn infer_slice_pat(
-        &mut self,
-        expected: Ty<'db>,
-        prefix: &[PatId],
-        slice: Option<PatId>,
-        suffix: &[PatId],
-        default_bm: BindingMode,
-        decl: Option<DeclContext>,
-    ) -> Ty<'db> {
+    fn infer_slice_pat(&mut self, expected: Ty<'db>, prefix: &[PatId], slice: Option<PatId>, suffix: &[PatId], default_bm: BindingMode, decl: Option<DeclContext>) -> Ty<'db> {
         let expected = self.table.structurally_resolve_type(expected);
-
         // If `expected` is an infer ty, we try to equate it to an array if the given pattern
         // allows it. See issue #16609
         if self.pat_is_irrefutable(decl)
         {
             self.unify(expected, resolved_array_ty);
         }
-
         let expected = self.table.try_structurally_resolve_type(expected);
         let elem_ty = match expected.kind() {
             TyKind::Array(st, _) | TyKind::Slice(st) => st,
             _ => self.err_ty(),
         };
-
         for &pat_id in prefix.iter().chain(suffix.iter()) {
             self.infer_pat(pat_id, elem_ty, default_bm, decl);
         }
-
         if let Some(slice_pat_id) = slice {
             let rest_pat_ty = match expected.kind() {
                 TyKind::Array(_, length) => {
             };
             self.infer_pat(slice_pat_id, rest_pat_ty, default_bm, decl);
         }
-
         match expected.kind() {
             TyKind::Array(_, const_) => {
                 Ty::new_array_with_const_len(self.interner(), elem_ty, const_)
                 return ty;
             }
         }
-
         self.infer_expr(expr, &Expectation::has_type(expected), ExprIsRead::Yes)
     }
 
         }
     }
 
-    fn try_resolve_slice_ty_to_array_ty(
-        &mut self,
-        before: &[PatId],
-        suffix: &[PatId],
-        slice: Option<PatId>,
-    ) -> Option<Ty<'db>> {
+    fn try_resolve_slice_ty_to_array_ty(&mut self, before: &[PatId], suffix: &[PatId], slice: Option<PatId>) -> Option<Ty<'db>> {
         if slice.is_some() {
             return None;
         }
-
         let len = before.len() + suffix.len();
         let size = consteval::usize_const(self.db, Some(len as u128), self.owner.krate(self.db));
-
         let elem_ty = self.table.next_ty_var();
         let array_ty = Ty::new_array_with_const_len(self.interner(), elem_ty, size);
         Some(array_ty)