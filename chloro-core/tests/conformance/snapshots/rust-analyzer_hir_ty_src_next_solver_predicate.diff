COMPARISON DIFF
============================================================

Original size: 32384 bytes
Chloro size:   31343 bytes
Rustfmt size:  32663 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Things related to predicates.
 
 use std::cmp::Ordering;
 
 use macros::{TypeFoldable, TypeVisitable};
 use rustc_type_ir::{
-    self as ty,
+    self as ty, CollectAndApply, DebruijnIndex, EarlyBinder, FlagComputation, Flags,
+    PredicatePolarity, TypeFlags, TypeFoldable, TypeSuperFoldable, TypeSuperVisitable,
+    TypeVisitable, Upcast, UpcastFrom, WithCachedTypeInfo,
     elaborate::Elaboratable,
     error::{ExpectedFound, TypeError},
     inherent::{IntoKind, SliceLike},
-    CollectAndApply, DebruijnIndex, EarlyBinder, FlagComputation, Flags, PredicatePolarity,
-    TypeFlags, TypeFoldable, TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, Upcast,
-    UpcastFrom, WithCachedTypeInfo,
 };
 use smallvec::SmallVec;
 
 use crate::next_solver::{InternedWrapperNoDebug, TraitIdWrapper};
-
-use super::{interned_vec_db, Binder, BoundVarKinds, DbInterner, Region, Ty};
+use super::{Binder, BoundVarKinds, DbInterner, Region, Ty, interned_vec_db};
 
 pub type BoundExistentialPredicate<'db> = Binder<'db, ExistentialPredicate<'db>>;
 
 pub type TraitRef<'db> = ty::TraitRef<DbInterner<'db>>;
+
 pub type AliasTerm<'db> = ty::AliasTerm<DbInterner<'db>>;
+
 pub type ProjectionPredicate<'db> = ty::ProjectionPredicate<DbInterner<'db>>;
+
 pub type ExistentialPredicate<'db> = ty::ExistentialPredicate<DbInterner<'db>>;
+
 pub type ExistentialTraitRef<'db> = ty::ExistentialTraitRef<DbInterner<'db>>;
+
 pub type ExistentialProjection<'db> = ty::ExistentialProjection<DbInterner<'db>>;
+
 pub type TraitPredicate<'db> = ty::TraitPredicate<DbInterner<'db>>;
+
 pub type ClauseKind<'db> = ty::ClauseKind<DbInterner<'db>>;
+
 pub type PredicateKind<'db> = ty::PredicateKind<DbInterner<'db>>;
+
 pub type NormalizesTo<'db> = ty::NormalizesTo<DbInterner<'db>>;
+
 pub type CoercePredicate<'db> = ty::CoercePredicate<DbInterner<'db>>;
+
 pub type SubtypePredicate<'db> = ty::SubtypePredicate<DbInterner<'db>>;
+
 pub type OutlivesPredicate<'db, T> = ty::OutlivesPredicate<DbInterner<'db>, T>;
+
 pub type RegionOutlivesPredicate<'db> = OutlivesPredicate<'db, Region<'db>>;
+
 pub type TypeOutlivesPredicate<'db> = OutlivesPredicate<'db, Ty<'db>>;
+
 pub type PolyTraitPredicate<'db> = Binder<'db, TraitPredicate<'db>>;
+
 pub type PolyRegionOutlivesPredicate<'db> = Binder<'db, RegionOutlivesPredicate<'db>>;
+
 pub type PolyTypeOutlivesPredicate<'db> = Binder<'db, TypeOutlivesPredicate<'db>>;
+
 pub type PolySubtypePredicate<'db> = Binder<'db, SubtypePredicate<'db>>;
+
 pub type PolyCoercePredicate<'db> = Binder<'db, CoercePredicate<'db>>;
+
 pub type PolyProjectionPredicate<'db> = Binder<'db, ProjectionPredicate<'db>>;
+
 pub type PolyTraitRef<'db> = Binder<'db, TraitRef<'db>>;
+
 pub type PolyExistentialTraitRef<'db> = Binder<'db, ExistentialTraitRef<'db>>;
+
 pub type PolyExistentialProjection<'db> = Binder<'db, ExistentialProjection<'db>>;
 
 /// Compares via an ordering that will not change if modules are reordered or other changes are
 /// made to the tree. In particular, this ordering is preserved across incremental compilations.
-fn stable_cmp_existential_predicate<'db>(
-    a: &ExistentialPredicate<'db>,
-    b: &ExistentialPredicate<'db>,
-) -> Ordering {
+fn stable_cmp_existential_predicate<'db>(a: &ExistentialPredicate<'db>, b: &ExistentialPredicate<'db>) -> Ordering {
     // FIXME: this is actual unstable - see impl in predicate.rs in `rustc_middle`
     match (a, b) {
         (ExistentialPredicate::Trait(_), ExistentialPredicate::Trait(_)) => Ordering::Equal,
         (ExistentialPredicate::AutoTrait(_), _) => Ordering::Greater,
     }
 }
-interned_vec_db!(BoundExistentialPredicates, BoundExistentialPredicate);
-
-impl<'db> rustc_type_ir::inherent::BoundExistentialPredicates<DbInterner<'db>>
-    for BoundExistentialPredicates<'db>
-{
+impl<'db> rustc_type_ir::inherent::BoundExistentialPredicates<DbInterner<'db>> for BoundExistentialPredicates<'db> {
     fn principal_def_id(self) -> Option<TraitIdWrapper> {
-        self.principal()
-            .map(|trait_ref| trait_ref.skip_binder().def_id)
+        self.principal().map(|trait_ref| trait_ref.skip_binder().def_id)
     }
 
-    fn principal(
-        self,
-    ) -> Option<
+    fn principal(self) -> Option<
         rustc_type_ir::Binder<DbInterner<'db>, rustc_type_ir::ExistentialTraitRef<DbInterner<'db>>>,
     > {
         self.inner()[0]
     }
 
     fn auto_traits(self) -> impl IntoIterator<Item = TraitIdWrapper> {
-        self.iter()
-            .filter_map(|predicate| match predicate.skip_binder() {
-                ExistentialPredicate::AutoTrait(did) => Some(did),
-                _ => None,
-            })
+        self.iter().filter_map(|predicate| match predicate.skip_binder() {
+            ExistentialPredicate::AutoTrait(did) => Some(did),
+            _ => None,
+        })
     }
 
-    fn projection_bounds(
-        self,
-    ) -> impl IntoIterator<
+    fn projection_bounds(self) -> impl IntoIterator<
         Item = rustc_type_ir::Binder<
             DbInterner<'db>,
             rustc_type_ir::ExistentialProjection<DbInterner<'db>>,
 }
 
 impl<'db> rustc_type_ir::relate::Relate<DbInterner<'db>> for BoundExistentialPredicates<'db> {
-    fn relate<R: rustc_type_ir::relate::TypeRelation<DbInterner<'db>>>(
-        relation: &mut R,
-        a: Self,
-        b: Self,
-    ) -> rustc_type_ir::relate::RelateResult<DbInterner<'db>, Self> {
+    fn relate<R: rustc_type_ir::relate::TypeRelation<DbInterner<'db>>>(relation: &mut R, a: Self, b: Self) -> rustc_type_ir::relate::RelateResult<DbInterner<'db>, Self> {
         let interner = relation.cx();
-
         // We need to perform this deduplication as we sometimes generate duplicate projections in `a`.
         let mut a_v: Vec<_> = a.into_iter().collect();
         let mut b_v: Vec<_> = b.into_iter().collect();
         if a_v.len() != b_v.len() {
             return Err(TypeError::ExistentialMismatch(ExpectedFound::new(a, b)));
         }
-
         let v = std::iter::zip(a_v, b_v).map(
             |(ep_a, ep_b): (
                 Binder<'_, ty::ExistentialPredicate<_>>,
                 match (ep_a.skip_binder(), ep_b.skip_binder()) {
                     (ty::ExistentialPredicate::Trait(a), ty::ExistentialPredicate::Trait(b)) => {
                         Ok(ep_a.rebind(ty::ExistentialPredicate::Trait(
-                            relation
-                                .relate(ep_a.rebind(a), ep_b.rebind(b))?
-                                .skip_binder(),
+                            relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),
                         )))
                     }
                     (
                         ty::ExistentialPredicate::Projection(a),
                         ty::ExistentialPredicate::Projection(b),
                     ) => Ok(ep_a.rebind(ty::ExistentialPredicate::Projection(
-                        relation
-                            .relate(ep_a.rebind(a), ep_b.rebind(b))?
-                            .skip_binder(),
+                        relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),
                     ))),
                     (
                         ty::ExistentialPredicate::AutoTrait(a),
                 }
             },
         );
-
         CollectAndApply::collect_and_apply(v, |g| {
             BoundExistentialPredicates::new_from_iter(interner, g.iter().cloned())
         })
     }
 }
 
-impl<'db> std::fmt::Debug
-    for InternedWrapperNoDebug<WithCachedTypeInfo<Binder<'db, PredicateKind<'db>>>>
-{
+impl<'db> std::fmt::Debug for InternedWrapperNoDebug<WithCachedTypeInfo<Binder<'db, PredicateKind<'db>>>> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         write!(f, "Binder<")?;
         match self.0.internee.skip_binder() {
                 _ => None,
             })
             .transpose()?;
-
         Some(Predicate::new(DbInterner::conjure(), kind))
     }
 }
 
-// FIXME: should make a "header" in interned_vec
-
 #[derive(Debug, Clone)]
 pub struct InternedClausesWrapper<'db>(SmallVec<[Clause<'db>; 2]>, TypeFlags, DebruijnIndex);
 
     }
 }
 
-impl<'db> Eq for InternedClausesWrapper<'db> {}
+impl<'db> Eq for InternedClausesWrapper<'db> {
+}
 
 impl<'db> std::hash::Hash for InternedClausesWrapper<'db> {
     fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
 }
 
 impl<'db> Clauses<'db> {
-    pub fn new_from_iter(
-        interner: DbInterner<'db>,
-        data: impl IntoIterator<Item = Clause<'db>>,
-    ) -> Self {
+    pub fn new_from_iter(interner: DbInterner<'db>, data: impl IntoIterator<Item = Clause<'db>>) -> Self {
         let clauses: SmallVec<_> = data.into_iter().collect();
         let flags = FlagComputation::<DbInterner<'db>>::for_clauses(&clauses);
         let wrapper = InternedClausesWrapper(clauses, flags.flags, flags.outer_exclusive_binder);
     }
 }
 
-impl<'db> rustc_type_ir::inherent::Clauses<DbInterner<'db>> for Clauses<'db> {}
+impl<'db> rustc_type_ir::inherent::Clauses<DbInterner<'db>> for Clauses<'db> {
+}
 
 impl<'db> rustc_type_ir::inherent::SliceLike for Clauses<'db> {
     type Item = Clause<'db>;
 
 impl<'db> IntoIterator for Clauses<'db> {
     type Item = Clause<'db>;
+
     type IntoIter = <Self as rustc_type_ir::inherent::SliceLike>::IntoIter;
 
     fn into_iter(self) -> Self::IntoIter {
 }
 
 impl<'db> rustc_type_ir::TypeSuperFoldable<DbInterner<'db>> for Clauses<'db> {
-    fn try_super_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(
-        self,
-        folder: &mut F,
-    ) -> Result<Self, F::Error> {
+    fn try_super_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Result<Self, F::Error> {
         let mut clauses: SmallVec<[_; 2]> = SmallVec::with_capacity(self.inner().0.len());
         for c in self {
             clauses.push(c.try_fold_with(folder)?);
         Ok(Clauses::new_from_iter(folder.cx(), clauses))
     }
 
-    fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
-        self,
-        folder: &mut F,
-    ) -> Self {
+    fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         let mut clauses: SmallVec<[_; 2]> = SmallVec::with_capacity(self.inner().0.len());
         for c in self {
             clauses.push(c.fold_with(folder));
 }
 
 impl<'db> rustc_type_ir::TypeFoldable<DbInterner<'db>> for Clauses<'db> {
-    fn try_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(
-        self,
-        folder: &mut F,
-    ) -> Result<Self, F::Error> {
+    fn try_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Result<Self, F::Error> {
         use rustc_type_ir::inherent::SliceLike as _;
-        let inner: smallvec::SmallVec<[_; 2]> = self
-            .iter()
-            .map(|v| v.try_fold_with(folder))
-            .collect::<Result<_, _>>()?;
+        let inner: smallvec::SmallVec<[_; 2]> =
+            self.iter().map(|v| v.try_fold_with(folder)).collect::<Result<_, _>>()?;
         Ok(Clauses::new_from_iter(folder.cx(), inner))
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         use rustc_type_ir::inherent::SliceLike as _;
         let inner: smallvec::SmallVec<[_; 2]> = self.iter().map(|v| v.fold_with(folder)).collect();
 }
 
 impl<'db> rustc_type_ir::TypeVisitable<DbInterner<'db>> for Clauses<'db> {
-    fn visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(
-        &self,
-        visitor: &mut V,
-    ) -> V::Result {
+    fn visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(&self, visitor: &mut V) -> V::Result {
         use rustc_ast_ir::visit::VisitorResult;
         use rustc_type_ir::inherent::SliceLike as _;
         rustc_ast_ir::walk_visitable_list!(visitor, self.as_slice().iter());
 }
 
 impl<'db> rustc_type_ir::TypeSuperVisitable<DbInterner<'db>> for Clauses<'db> {
-    fn super_visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(
-        &self,
-        visitor: &mut V,
-    ) -> V::Result {
+    fn super_visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(&self, visitor: &mut V) -> V::Result {
         self.as_slice().visit_with(visitor)
     }
 }
 
-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)] // TODO implement Debug by hand
+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
 pub struct Clause<'db>(pub(crate) Predicate<'db>);
 
-// We could cram the reveal into the clauses like rustc does, probably
 #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, TypeVisitable, TypeFoldable)]
 pub struct ParamEnv<'db> {
     pub(crate) clauses: Clauses<'db>,
 
 impl<'db> ParamEnv<'db> {
     pub fn empty() -> Self {
-        ParamEnv {
-            clauses: Clauses::new_from_iter(DbInterner::conjure(), []),
-        }
+        ParamEnv { clauses: Clauses::new_from_iter(DbInterner::conjure(), []) }
     }
 }
 
 }
 
 impl<'db> TypeVisitable<DbInterner<'db>> for Predicate<'db> {
-    fn visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(
-        &self,
-        visitor: &mut V,
-    ) -> V::Result {
+    fn visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(&self, visitor: &mut V) -> V::Result {
         visitor.visit_predicate(*self)
     }
 }
 
 impl<'db> TypeSuperVisitable<DbInterner<'db>> for Predicate<'db> {
-    fn super_visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(
-        &self,
-        visitor: &mut V,
-    ) -> V::Result {
+    fn super_visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(&self, visitor: &mut V) -> V::Result {
         (*self).kind().visit_with(visitor)
     }
 }
 
 impl<'db> TypeFoldable<DbInterner<'db>> for Predicate<'db> {
-    fn try_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(
-        self,
-        folder: &mut F,
-    ) -> Result<Self, F::Error> {
+    fn try_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Result<Self, F::Error> {
         folder.try_fold_predicate(self)
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         folder.fold_predicate(self)
     }
 }
 
 impl<'db> TypeSuperFoldable<DbInterner<'db>> for Predicate<'db> {
-    fn try_super_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(
-        self,
-        folder: &mut F,
-    ) -> Result<Self, F::Error> {
+    fn try_super_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Result<Self, F::Error> {
         let new = self.kind().try_fold_with(folder)?;
         Ok(Predicate::new(folder.cx(), new))
     }
-    fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
-        self,
-        folder: &mut F,
-    ) -> Self {
+
+    fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         let new = self.kind().fold_with(folder);
         Predicate::new(folder.cx(), new)
     }
         clause.as_predicate()
     }
 
-    fn child_with_derived_cause(
-        &self,
-        clause: <DbInterner<'db> as rustc_type_ir::Interner>::Clause,
-        _span: <DbInterner<'db> as rustc_type_ir::Interner>::Span,
-        _parent_trait_pred: rustc_type_ir::Binder<
+    fn child_with_derived_cause(&self, clause: <DbInterner<'db> as rustc_type_ir::Interner>::Clause, _span: <DbInterner<'db> as rustc_type_ir::Interner>::Span, _parent_trait_pred: rustc_type_ir::Binder<
             DbInterner<'db>,
             rustc_type_ir::TraitPredicate<DbInterner<'db>>,
-        >,
-        _index: usize,
-    ) -> Self {
+        >, _index: usize) -> Self {
         clause.as_predicate()
     }
 }
         Binder::dummy(from).upcast(interner)
     }
 }
-impl<'db>
-    UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::PredicateKind<DbInterner<'db>>>>
-    for Predicate<'db>
-{
-    fn upcast_from(
-        from: ty::Binder<DbInterner<'db>, ty::PredicateKind<DbInterner<'db>>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::PredicateKind<DbInterner<'db>>>> for Predicate<'db> {
+    fn upcast_from(from: ty::Binder<DbInterner<'db>, ty::PredicateKind<DbInterner<'db>>>, interner: DbInterner<'db>) -> Self {
         Predicate::new(interner, from)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>> for Predicate<'db> {
     fn upcast_from(from: ty::ClauseKind<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Binder::dummy(PredicateKind::Clause(from)).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>>
-    for Predicate<'db>
-{
-    fn upcast_from(
-        from: ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>> for Predicate<'db> {
+    fn upcast_from(from: ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>, interner: DbInterner<'db>) -> Self {
         from.map_bound(PredicateKind::Clause).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, Clause<'db>> for Predicate<'db> {
     fn upcast_from(from: Clause<'db>, _interner: DbInterner<'db>) -> Self {
         from.0
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::NormalizesTo<DbInterner<'db>>> for Predicate<'db> {
     fn upcast_from(from: ty::NormalizesTo<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         PredicateKind::NormalizesTo(from).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>> for Predicate<'db> {
     fn upcast_from(from: ty::TraitRef<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Binder::dummy(from).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>>
-    for Predicate<'db>
-{
-    fn upcast_from(
-        from: ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>> for Predicate<'db> {
+    fn upcast_from(from: ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>, interner: DbInterner<'db>) -> Self {
         from.map_bound(|trait_ref| TraitPredicate {
             trait_ref,
             polarity: PredicatePolarity::Positive,
         .upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, Binder<'db, ty::TraitPredicate<DbInterner<'db>>>>
-    for Predicate<'db>
-{
-    fn upcast_from(
-        from: Binder<'db, ty::TraitPredicate<DbInterner<'db>>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
-        from.map_bound(|it| PredicateKind::Clause(ClauseKind::Trait(it)))
-            .upcast(interner)
+
+impl<'db> UpcastFrom<DbInterner<'db>, Binder<'db, ty::TraitPredicate<DbInterner<'db>>>> for Predicate<'db> {
+    fn upcast_from(from: Binder<'db, ty::TraitPredicate<DbInterner<'db>>>, interner: DbInterner<'db>) -> Self {
+        from.map_bound(|it| PredicateKind::Clause(ClauseKind::Trait(it))).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, Binder<'db, ProjectionPredicate<'db>>> for Predicate<'db> {
     fn upcast_from(from: Binder<'db, ProjectionPredicate<'db>>, interner: DbInterner<'db>) -> Self {
-        from.map_bound(|it| PredicateKind::Clause(ClauseKind::Projection(it)))
-            .upcast(interner)
+        from.map_bound(|it| PredicateKind::Clause(ClauseKind::Projection(it))).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ProjectionPredicate<'db>> for Predicate<'db> {
     fn upcast_from(from: ProjectionPredicate<'db>, interner: DbInterner<'db>) -> Self {
         PredicateKind::Clause(ClauseKind::Projection(from)).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>> for Predicate<'db> {
     fn upcast_from(from: ty::TraitPredicate<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         PredicateKind::Clause(ClauseKind::Trait(from)).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>>
-    for Predicate<'db>
-{
-    fn upcast_from(
-        from: ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>> for Predicate<'db> {
+    fn upcast_from(from: ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>, interner: DbInterner<'db>) -> Self {
         PredicateKind::Clause(ClauseKind::TypeOutlives(from)).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>>
-    for Predicate<'db>
-{
-    fn upcast_from(
-        from: ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>> for Predicate<'db> {
+    fn upcast_from(from: ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>, interner: DbInterner<'db>) -> Self {
         PredicateKind::Clause(ClauseKind::RegionOutlives(from)).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>>
-    for Clause<'db>
-{
-    fn upcast_from(
-        from: ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>> for Clause<'db> {
+    fn upcast_from(from: ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>>
-    for Clause<'db>
-{
-    fn upcast_from(
-        from: ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>> for Clause<'db> {
+    fn upcast_from(from: ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
 
 impl<'db> UpcastFrom<DbInterner<'db>, PolyRegionOutlivesPredicate<'db>> for Predicate<'db> {
     fn upcast_from(from: PolyRegionOutlivesPredicate<'db>, tcx: DbInterner<'db>) -> Self {
-        from.map_bound(|p| PredicateKind::Clause(ClauseKind::RegionOutlives(p)))
-            .upcast(tcx)
+        from.map_bound(|p| PredicateKind::Clause(ClauseKind::RegionOutlives(p))).upcast(tcx)
     }
 }
 
 }
 
 impl<'db> TypeVisitable<DbInterner<'db>> for Clause<'db> {
-    fn visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(
-        &self,
-        visitor: &mut V,
-    ) -> V::Result {
+    fn visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(&self, visitor: &mut V) -> V::Result {
         visitor.visit_predicate((*self).as_predicate())
     }
 }
 
 impl<'db> TypeFoldable<DbInterner<'db>> for Clause<'db> {
-    fn try_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(
-        self,
-        folder: &mut F,
-    ) -> Result<Self, F::Error> {
-        Ok(folder
-            .try_fold_predicate(self.as_predicate())?
-            .expect_clause())
+    fn try_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Result<Self, F::Error> {
+        Ok(folder.try_fold_predicate(self.as_predicate())?.expect_clause())
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         folder.fold_predicate(self.as_predicate()).expect_clause()
     }
         clause
     }
 
-    fn child_with_derived_cause(
-        &self,
-        clause: <DbInterner<'db> as rustc_type_ir::Interner>::Clause,
-        _span: <DbInterner<'db> as rustc_type_ir::Interner>::Span,
-        _parent_trait_pred: rustc_type_ir::Binder<
+    fn child_with_derived_cause(&self, clause: <DbInterner<'db> as rustc_type_ir::Interner>::Clause, _span: <DbInterner<'db> as rustc_type_ir::Interner>::Span, _parent_trait_pred: rustc_type_ir::Binder<
             DbInterner<'db>,
             rustc_type_ir::TraitPredicate<DbInterner<'db>>,
-        >,
-        _index: usize,
-    ) -> Self {
+        >, _index: usize) -> Self {
         clause
     }
 }
 
-impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>>
-    for Clause<'db>
-{
-    fn upcast_from(
-        from: ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>> for Clause<'db> {
+    fn upcast_from(from: ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>, interner: DbInterner<'db>) -> Self {
         Clause(from.map_bound(PredicateKind::Clause).upcast(interner))
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>> for Clause<'db> {
     fn upcast_from(from: ty::TraitRef<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>>
-    for Clause<'db>
-{
-    fn upcast_from(
-        from: ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>> for Clause<'db> {
+    fn upcast_from(from: ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>> for Clause<'db> {
     fn upcast_from(from: ty::TraitPredicate<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
-impl<'db>
-    UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>>>
-    for Clause<'db>
-{
-    fn upcast_from(
-        from: ty::Binder<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>>> for Clause<'db> {
+    fn upcast_from(from: ty::Binder<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::ProjectionPredicate<DbInterner<'db>>> for Clause<'db> {
-    fn upcast_from(
-        from: ty::ProjectionPredicate<DbInterner<'db>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+    fn upcast_from(from: ty::ProjectionPredicate<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
-impl<'db>
-    UpcastFrom<
+
+impl<'db> UpcastFrom<
         DbInterner<'db>,
         ty::Binder<DbInterner<'db>, ty::ProjectionPredicate<DbInterner<'db>>>,
-    > for Clause<'db>
-{
-    fn upcast_from(
-        from: ty::Binder<DbInterner<'db>, ty::ProjectionPredicate<DbInterner<'db>>>,
-        interner: DbInterner<'db>,
-    ) -> Self {
+    > for Clause<'db> {
+    fn upcast_from(from: ty::Binder<DbInterner<'db>, ty::ProjectionPredicate<DbInterner<'db>>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
         self.0
     }
 
-    fn instantiate_supertrait(
-        self,
-        cx: DbInterner<'db>,
-        trait_ref: rustc_type_ir::Binder<DbInterner<'db>, rustc_type_ir::TraitRef<DbInterner<'db>>>,
-    ) -> Self {
+    fn instantiate_supertrait(self, cx: DbInterner<'db>, trait_ref: rustc_type_ir::Binder<DbInterner<'db>, rustc_type_ir::TraitRef<DbInterner<'db>>>) -> Self {
         tracing::debug!(?self, ?trait_ref);
         // See the rustc impl for a long comment
         let bound_pred = self.kind();
         // 3) ['x] + ['b] -> ['x, 'b]
         let bound_vars =
             BoundVarKinds::new_from_iter(cx, trait_bound_vars.iter().chain(pred_bound_vars.iter()));
-
         let predicate: Predicate<'db> =
             ty::Binder::bind_with_vars(PredicateKind::Clause(new), bound_vars).upcast(cx);
         predicate.expect_clause()