COMPARISON DIFF
============================================================

Original size: 12531 bytes
Chloro size:   11305 bytes
Rustfmt size:  12665 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! A simplified version of quote-crate like quasi quote macro
-#![allow(clippy::crate_in_macro_def)]
 
-use intern::{sym, Symbol};
+use intern::{Symbol, sym};
+pub use quote;
+pub use quote_impl__ as __quote;
 use span::Span;
 use syntax::ToSmolStr;
 use tt::IdentIsRaw;
 
 use crate::{name::Name, tt::TopSubtreeBuilder};
 
+#![allow(clippy::crate_in_macro_def)]
 pub(crate) fn dollar_crate(span: Span) -> tt::Ident<Span> {
-    tt::Ident {
-        sym: sym::dollar_crate,
-        span,
-        is_raw: tt::IdentIsRaw::No,
-    }
+    tt::Ident { sym: sym::dollar_crate, span, is_raw: tt::IdentIsRaw::No }
 }
 
 // A helper macro quote macro
         $crate::builtin::quote::__quote!($span $builder $($tail)*);
     }};
 }
-pub use quote_impl__ as __quote;
 
 /// FIXME:
 /// It probably should implement in proc-macro
         }
     }
 }
-pub use quote;
-
-pub trait ToTokenTree {
-    fn to_tokens(self, span: Span, builder: &mut TopSubtreeBuilder);
-}
 
+fn to_tokens(
+    self,
+    span: Span,
+    builder: &mut TopSubtreeBuilder,
+);
 /// Wraps `TokenTreesView` with a delimiter (a subtree, but without allocating).
 pub struct WithDelimiter<'a> {
     pub delimiter: crate::tt::Delimiter,
 }
 
 impl ToTokenTree for WithDelimiter<'_> {
-    fn to_tokens(self, span: Span, builder: &mut TopSubtreeBuilder) {
+    fn to_tokens(
+        self,
+        span: Span,
+        builder: &mut TopSubtreeBuilder,
+    ) {
         builder.open(self.delimiter.kind, self.delimiter.open);
         self.token_trees.to_tokens(span, builder);
         builder.close(self.delimiter.close);
 }
 
 impl ToTokenTree for crate::tt::TokenTreesView<'_> {
-    fn to_tokens(self, _: Span, builder: &mut TopSubtreeBuilder) {
+    fn to_tokens(
+        self,
+        _: Span,
+        builder: &mut TopSubtreeBuilder,
+    ) {
         builder.extend_with_tt(self);
     }
 }
 
 impl ToTokenTree for crate::tt::SubtreeView<'_> {
-    fn to_tokens(self, _: Span, builder: &mut TopSubtreeBuilder) {
+    fn to_tokens(
+        self,
+        _: Span,
+        builder: &mut TopSubtreeBuilder,
+    ) {
         builder.extend_with_tt(self.as_token_trees());
     }
 }
 
 impl ToTokenTree for crate::tt::TopSubtree {
-    fn to_tokens(self, _: Span, builder: &mut TopSubtreeBuilder) {
+    fn to_tokens(
+        self,
+        _: Span,
+        builder: &mut TopSubtreeBuilder,
+    ) {
         builder.extend_tt_dangerous(self.0);
     }
 }
 
 impl ToTokenTree for crate::tt::TtElement<'_> {
-    fn to_tokens(self, _: Span, builder: &mut TopSubtreeBuilder) {
+    fn to_tokens(
+        self,
+        _: Span,
+        builder: &mut TopSubtreeBuilder,
+    ) {
         match self {
             crate::tt::TtElement::Leaf(leaf) => builder.push(leaf.clone()),
             crate::tt::TtElement::Subtree(subtree, subtree_iter) => {
         )*
     }
 }
+
 impl<T: ToTokenTree + Clone> ToTokenTree for &T {
-    fn to_tokens(self, span: Span, builder: &mut TopSubtreeBuilder) {
+    fn to_tokens(
+        self,
+        span: Span,
+        builder: &mut TopSubtreeBuilder,
+    ) {
         self.clone().to_tokens(span, builder);
     }
 }
-
-impl_to_to_tokentrees! {
-    span: u32 => self { crate::tt::Literal{symbol: Symbol::integer(self as _), span, kind: tt::LitKind::Integer, suffix: None } };
-    span: usize => self { crate::tt::Literal{symbol: Symbol::integer(self as _), span, kind: tt::LitKind::Integer, suffix: None } };
-    span: i32 => self { crate::tt::Literal{symbol: Symbol::integer(self as _), span, kind: tt::LitKind::Integer, suffix: None } };
-    span: bool => self { crate::tt::Ident{sym: if self { sym::true_ } else { sym::false_ }, span, is_raw: tt::IdentIsRaw::No } };
-    _span: crate::tt::Leaf => self { self };
-    _span: crate::tt::Literal => self { self };
-    _span: crate::tt::Ident => self { self };
-    _span: crate::tt::Punct => self { self };
-    span: &str => self { crate::tt::Literal{symbol: Symbol::intern(&self.escape_default().to_smolstr()), span, kind: tt::LitKind::Str, suffix: None }};
-    span: String => self { crate::tt::Literal{symbol: Symbol::intern(&self.escape_default().to_smolstr()), span, kind: tt::LitKind::Str, suffix: None }};
-    span: Name => self {
-        let (is_raw, s) = IdentIsRaw::split_from_symbol(self.as_str());
-        crate::tt::Ident{sym: Symbol::intern(s), span, is_raw }
-    };
-    span: Symbol => self {
-        let (is_raw, s) = IdentIsRaw::split_from_symbol(self.as_str());
-        crate::tt::Ident{sym: Symbol::intern(s), span, is_raw }
-    };
-}
-
 #[cfg(test)]
 mod tests {
     use crate::tt;
     use ::tt::IdentIsRaw;
     use expect_test::expect;
     use intern::Symbol;
-    use span::{Edition, SpanAnchor, SyntaxContext, ROOT_ERASED_FILE_AST_ID};
+    use span::{Edition, ROOT_ERASED_FILE_AST_ID, SpanAnchor, SyntaxContext};
     use syntax::{TextRange, TextSize};
-
     const DUMMY: tt::Span = tt::Span {
         range: TextRange::empty(TextSize::new(0)),
         anchor: SpanAnchor {
         },
         ctx: SyntaxContext::root(Edition::CURRENT),
     };
-
     #[test]
     fn test_quote_delimiters() {
         assert_eq!(quote!(DUMMY =>{}).to_string(), "{}");
         assert_eq!(quote!(DUMMY =>()).to_string(), "()");
         assert_eq!(quote!(DUMMY =>[]).to_string(), "[]");
     }
-
     #[test]
     fn test_quote_idents() {
         assert_eq!(quote!(DUMMY =>32).to_string(), "32");
         assert_eq!(quote!(DUMMY =>struct).to_string(), "struct");
     }
-
     #[test]
     fn test_quote_hash_simple_literal() {
         let a = 20;
         let s: String = "hello".into();
         assert_eq!(quote!(DUMMY =>#s).to_string(), "\"hello\"");
     }
-
     fn mk_ident(name: &str) -> crate::tt::Ident {
         let (is_raw, s) = IdentIsRaw::split_from_symbol(name);
-        crate::tt::Ident {
-            sym: Symbol::intern(s),
-            span: DUMMY,
-            is_raw,
-        }
+        crate::tt::Ident { sym: Symbol::intern(s), span: DUMMY, is_raw }
     }
-
     #[test]
     fn test_quote_hash_token_tree() {
         let a = mk_ident("hello");
-
         let quoted = quote!(DUMMY =>#a);
         assert_eq!(quoted.to_string(), "hello");
         let t = format!("{quoted:#?}");
               IDENT   hello 937550:Root[0000, 0]@0..0#ROOT2024"#]]
         .assert_eq(&t);
     }
-
     #[test]
     fn test_quote_simple_derive_copy() {
         let name = mk_ident("Foo");
-
         let quoted = quote! {DUMMY =>
             impl Clone for #name {
                 fn clone(&self) -> Self {
                 }
             }
         };
-
-        assert_eq!(
-            quoted.to_string(),
-            "impl Clone for Foo {fn clone (& self) -> Self {Self {}}}"
-        );
+        assert_eq!(quoted.to_string(), "impl Clone for Foo {fn clone (& self) -> Self {Self {}}}");
     }
-
     #[test]
     fn test_quote_derive_copy_hack() {
         // Assume the given struct is:
         // }
         let struct_name = mk_ident("Foo");
         let fields = [mk_ident("name"), mk_ident("id")];
-        let fields = fields
-            .iter()
-            .map(|it| quote!(DUMMY =>#it: self.#it.clone(), ));
-
+        let fields = fields.iter().map(|it| quote!(DUMMY =>#it: self.#it.clone(), ));
         let mut builder = tt::TopSubtreeBuilder::new(crate::tt::Delimiter {
             kind: crate::tt::DelimiterKind::Brace,
             open: DUMMY,
         });
         fields.for_each(|field| builder.extend_with_tt(field.view().as_token_trees()));
         let list = builder.build();
-
         let quoted = quote! {DUMMY =>
             impl Clone for #struct_name {
                 fn clone(&self) -> Self {
                 }
             }
         };
-
         assert_eq!(
             quoted.to_string(),
             "impl Clone for Foo {fn clone (& self) -> Self {Self {name : self . name . clone () , id : self . id . clone () ,}}}"