COMPARISON DIFF
============================================================

Original size: 9897 bytes
Chloro size:   9530 bytes
Rustfmt size:  10040 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use thin_vec::ThinVec;
 
 use crate::{
+    LifetimeParamId, TypeParamId,
     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},
     expr_store::{
-        path::{GenericArg, Path},
         ExpressionStore,
+        path::{GenericArg, Path},
     },
     hir::{ExprId, Literal},
-    LifetimeParamId, TypeParamId,
 };
 
 #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
 
 impl Mutability {
     pub fn from_mutable(mutable: bool) -> Mutability {
-        if mutable {
-            Mutability::Mut
-        } else {
-            Mutability::Shared
-        }
+        if mutable { Mutability::Mut } else { Mutability::Shared }
     }
 
     pub fn as_keyword_for_ref(self) -> &'static str {
 
 impl Rawness {
     pub fn from_raw(is_raw: bool) -> Rawness {
-        if is_raw {
-            Rawness::RawPtr
-        } else {
-            Rawness::Ref
-        }
+        if is_raw { Rawness::RawPtr } else { Rawness::Ref }
     }
 
     pub fn is_raw(&self) -> bool {
     }
 }
 
-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
 /// A `TypeRefId` that is guaranteed to always be `TypeRef::Path`. We use this for things like
 /// impl's trait, that are always paths but need to be traced back to source code.
+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
 pub struct PathId(TypeRefId);
 
 impl PathId {
 impl FnType {
     #[inline]
     pub fn split_params_and_ret(&self) -> (&[(Option<Name>, TypeRefId)], TypeRefId) {
-        let (ret, params) = self
-            .params
-            .split_last()
-            .expect("should have at least return type");
+        let (ret, params) = self.params.split_last().expect("should have at least return type");
         (params, ret.1)
     }
 }
     Tuple(ThinVec<TypeRefId>),
     Path(Path),
     RawPtr(TypeRefId, Mutability),
-    // FIXME: Unbox this once `Idx` has a niche,
-    // as `RefType` should shrink by 4 bytes then
     Reference(Box<RefType>),
     Array(ArrayType),
     Slice(TypeRefId),
 }
 
 #[cfg(all(target_arch = "x86_64", target_pointer_width = "64"))]
-const _: () = assert!(size_of::<TypeRef>() == 24);
+const () = assert!(size_of::<TypeRef>() == 24);
 
 pub type TypeRefId = Idx<TypeRef>;
 
 }
 
 #[cfg(target_pointer_width = "64")]
-const _: [(); 16] = [(); size_of::<TypeBound>()];
+const [(); 16] = [(); size_of::<TypeBound>()];
 
 #[derive(Clone, PartialEq, Eq, Hash, Debug)]
 pub enum UseArgRef {
         TypeRef::Tuple(ThinVec::new())
     }
 
-    pub fn walk(this: TypeRefId, map: &ExpressionStore, f: &mut impl FnMut(&TypeRef)) {
+    pub fn walk(
+        this: TypeRefId,
+        map: &ExpressionStore,
+        f: &mut impl FnMut(&TypeRef),
+    ) {
         go(this, f, map);
-
         fn go(type_ref: TypeRefId, f: &mut impl FnMut(&TypeRef), map: &ExpressionStore) {
             let type_ref = &map[type_ref];
             f(type_ref);
             match type_ref {
-                TypeRef::Fn(fn_) => fn_
-                    .params
-                    .iter()
-                    .for_each(|&(_, param_type)| go(param_type, f, map)),
+                TypeRef::Fn(fn_) => {
+                    fn_.params.iter().for_each(|&(_, param_type)| go(param_type, f, map))
+                }
                 TypeRef::Tuple(types) => types.iter().for_each(|&t| go(t, f, map)),
                 TypeRef::RawPtr(type_ref, _) | TypeRef::Slice(type_ref) => go(*type_ref, f, map),
                 TypeRef::Reference(it) => go(it.ty, f, map),
                 TypeRef::Never | TypeRef::Placeholder | TypeRef::Error | TypeRef::TypeParam(_) => {}
             };
         }
-
         fn go_path(path: &Path, f: &mut impl FnMut(&TypeRef), map: &ExpressionStore) {
             if let Some(type_ref) = path.type_anchor() {
                 go(type_ref, f, map);
 }
 
 impl TypeBound {
-    pub fn as_path<'a>(&self, map: &'a ExpressionStore) -> Option<(&'a Path, TraitBoundModifier)> {
+    pub fn as_path<'a>(
+        &self,
+        map: &'a ExpressionStore,
+    ) -> Option<(&'a Path, TraitBoundModifier)> {
         match self {
             &TypeBound::Path(p, m) => Some((&map[p], m)),
             &TypeBound::ForLifetime(_, p) => Some((&map[p], TraitBoundModifier::None)),
     UInt(u128),
     Bool(bool),
     Char(char),
-
     /// Case of an unknown value that rustc might know but we don't
-    // FIXME: this is a hack to get around chalk not being able to represent unevaluatable
-    // constants
-    // https://github.com/rust-lang/rust-analyzer/pull/8813#issuecomment-840679177
-    // https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/Handling.20non.20evaluatable.20constants'.20equality/near/238386348
     Unknown,
 }
 
 }
 
 impl std::fmt::Display for LiteralConstRef {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> Result<(), std::fmt::Error> {
         match self {
             LiteralConstRef::Int(num) => num.fmt(f),
             LiteralConstRef::UInt(num) => num.fmt(f),