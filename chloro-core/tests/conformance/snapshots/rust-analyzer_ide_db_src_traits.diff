COMPARISON DIFF
============================================================

Original size: 8057 bytes
Chloro size:   8110 bytes
Rustfmt size:  8222 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Functionality for obtaining data related to traits from the DB.
 
-use crate::{defs::Definition, RootDatabase};
-use hir::{db::HirDatabase, AsAssocItem, Semantics};
+use hir::{AsAssocItem, Semantics, db::HirDatabase};
 use rustc_hash::FxHashSet;
-use syntax::{ast, AstNode};
+use syntax::{AstNode, ast};
+
+use crate::{RootDatabase, defs::Definition};
 
 /// Given the `impl` block, attempts to find the trait this `impl` corresponds to.
 pub fn resolve_target_trait(
     sema: &Semantics<'_, RootDatabase>,
     impl_def: &ast::Impl,
 ) -> Option<hir::Trait> {
-    let ast_path = impl_def
-        .trait_()
-        .map(|it| it.syntax().clone())
-        .and_then(ast::PathType::cast)?
-        .path()?;
-
+    let ast_path =
+        impl_def.trait_().map(|it| it.syntax().clone()).and_then(ast::PathType::cast)?.path()?;
     match sema.resolve_path(&ast_path) {
         Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def),
         _ => None,
         Some(it) => it,
         None => return vec![],
     };
-
     // Names must be unique between constants and functions. However, type aliases
     // may share the same name as a function or constant.
     let mut impl_fns_consts = FxHashSet::default();
     let mut impl_type = FxHashSet::default();
     let edition = imp.module(sema.db).krate().edition(sema.db);
-
     for item in imp.items(sema.db) {
         match item {
             hir::AssocItem::Function(it) => {
             }
         }
     }
-
     resolve_target_trait(sema, impl_def).map_or(vec![], |target_trait| {
         target_trait
             .items(sema.db)
 }
 
 /// Converts associated trait impl items to their trait definition counterpart
-pub(crate) fn convert_to_def_in_trait(db: &dyn HirDatabase, def: Definition) -> Definition {
+pub(crate) fn convert_to_def_in_trait(
+    db: &dyn HirDatabase,
+    def: Definition,
+) -> Definition {
     (|| {
         let assoc = def.as_assoc_item(db)?;
         let trait_ = assoc.implemented_trait(db)?;
 }
 
 /// If this is an trait (impl) assoc item, returns the assoc item of the corresponding trait definition.
-pub(crate) fn as_trait_assoc_def(db: &dyn HirDatabase, def: Definition) -> Option<Definition> {
+pub(crate) fn as_trait_assoc_def(
+    db: &dyn HirDatabase,
+    def: Definition,
+) -> Option<Definition> {
     let assoc = def.as_assoc_item(db)?;
     let trait_ = match assoc.container(db) {
         hir::AssocItemContainer::Trait(_) => return Some(def),
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{expect, Expect};
+    use expect_test::{Expect, expect};
     use hir::FilePosition;
     use hir::Semantics;
     use span::Edition;
     use syntax::ast::{self, AstNode};
     use test_fixture::ChangeFixture;
-
     use crate::RootDatabase;
-
     /// Creates analysis from a multi-file fixture, returns positions marked with $0.
     pub(crate) fn position(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let mut database = RootDatabase::default();
         let change_fixture = ChangeFixture::parse(&database, ra_fixture);
         database.apply_change(change_fixture.change);
-        let (file_id, range_or_offset) = change_fixture
-            .file_position
-            .expect("expected a marker ($0)");
+        let (file_id, range_or_offset) =
+            change_fixture.file_position.expect("expected a marker ($0)");
         let offset = range_or_offset.expect_offset();
         (database, FilePosition { file_id, offset })
     }
-
-    fn check_trait(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+    fn check_trait(
+        #[rust_analyzer::rust_fixture] ra_fixture: &str,
+        expect: Expect,
+    ) {
         let (db, position) = position(ra_fixture);
         let sema = Semantics::new(&db);
-
         let file = sema.parse(position.file_id);
-        let impl_block: ast::Impl = sema
-            .find_node_at_offset_with_descend(file.syntax(), position.offset)
-            .unwrap();
+        let impl_block: ast::Impl =
+            sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();
         let trait_ = crate::traits::resolve_target_trait(&sema, &impl_block);
         let actual = match trait_ {
             Some(trait_) => trait_.name(&db).display(&db, Edition::CURRENT).to_string(),
         };
         expect.assert_eq(&actual);
     }
-
-    fn check_missing_assoc(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+    fn check_missing_assoc(
+        #[rust_analyzer::rust_fixture] ra_fixture: &str,
+        expect: Expect,
+    ) {
         let (db, position) = position(ra_fixture);
         let sema = Semantics::new(&db);
-
         let file = sema.parse(position.file_id);
-        let impl_block: ast::Impl = sema
-            .find_node_at_offset_with_descend(file.syntax(), position.offset)
-            .unwrap();
+        let impl_block: ast::Impl =
+            sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();
         let items = crate::traits::get_missing_assoc_items(&sema, &impl_block);
         let actual = items
             .into_iter()
-            .map(|item| {
-                item.name(&db)
-                    .unwrap()
-                    .display(&db, Edition::CURRENT)
-                    .to_string()
-            })
+            .map(|item| item.name(&db).unwrap().display(&db, Edition::CURRENT).to_string())
             .collect::<Vec<_>>()
             .join("\n");
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn resolve_trait() {
         check_trait(
             expect![[""]],
         );
     }
-
     #[test]
     fn missing_assoc_items() {
         check_missing_assoc(
                 FOO
                 bar"#]],
         );
-
         check_missing_assoc(
             r#"
 pub trait Foo {
             expect![[r#"
                 bar"#]],
         );
-
         check_missing_assoc(
             r#"
 pub trait Foo {
 }"#,
             expect![[r#""#]],
         );
-
         check_missing_assoc(
             r#"
 pub struct Foo;
 }"#,
             expect![[r#""#]],
         );
-
         check_missing_assoc(
             r#"
 trait Tr {