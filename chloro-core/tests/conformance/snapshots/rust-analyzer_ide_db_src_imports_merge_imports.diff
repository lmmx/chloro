COMPARISON DIFF
============================================================

Original size: 35928 bytes
Chloro size:   35680 bytes
Rustfmt size:  36357 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Handle syntactic aspects of merging UseTrees.
+
 use std::cmp::Ordering;
 
 use itertools::{EitherOrBoth, Itertools};
 use parser::T;
 use syntax::{
-    algo,
+    Direction, SyntaxElement, algo,
     ast::{
-        self, edit_in_place::Removable, make, AstNode, HasAttrs, HasName, HasVisibility,
-        PathSegmentKind,
+        self, AstNode, HasAttrs, HasName, HasVisibility, PathSegmentKind, edit_in_place::Removable,
+        make,
     },
     ted::{self, Position},
-    Direction, SyntaxElement,
 };
 
 use crate::syntax_helpers::node_ext::vis_eq;
 
 /// Merge `rhs` into `lhs` keeping both intact.
 /// Returned AST is mutable.
-pub fn try_merge_imports(
-    lhs: &ast::Use,
-    rhs: &ast::Use,
-    merge_behavior: MergeBehavior,
-) -> Option<ast::Use> {
+pub fn try_merge_imports(lhs: &ast::Use, rhs: &ast::Use, merge_behavior: MergeBehavior) -> Option<ast::Use> {
     // don't merge imports with different visibilities
     if !eq_visibility(lhs.visibility(), rhs.visibility()) {
         return None;
     if !eq_attrs(lhs.attrs(), rhs.attrs()) {
         return None;
     }
-
     let lhs = lhs.clone_subtree().clone_for_update();
     let rhs = rhs.clone_subtree().clone_for_update();
     let lhs_tree = lhs.use_tree()?;
     let rhs_tree = rhs.use_tree()?;
     try_merge_trees_mut(&lhs_tree, &rhs_tree, merge_behavior)?;
-
     // Ignore `None` result because normalization should not affect the merge result.
     try_normalize_use_tree_mut(&lhs_tree, merge_behavior.into());
-
     Some(lhs)
 }
 
 /// Merge `rhs` into `lhs` keeping both intact.
 /// Returned AST is mutable.
-pub fn try_merge_trees(
-    lhs: &ast::UseTree,
-    rhs: &ast::UseTree,
-    merge: MergeBehavior,
-) -> Option<ast::UseTree> {
+pub fn try_merge_trees(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior) -> Option<ast::UseTree> {
     let lhs = lhs.clone_subtree().clone_for_update();
     let rhs = rhs.clone_subtree().clone_for_update();
     try_merge_trees_mut(&lhs, &rhs, merge)?;
-
     // Ignore `None` result because normalization should not affect the merge result.
     try_normalize_use_tree_mut(&lhs, merge.into());
-
     Some(lhs)
 }
 
     // Sorts the use trees similar to rustfmt's algorithm for ordering imports
     // (see `use_tree_cmp` doc).
     use_trees.sort_unstable_by(use_tree_cmp);
-    for rhs_t in rhs
-        .use_tree_list()
-        .into_iter()
-        .flat_map(|list| list.use_trees())
-    {
+    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {
         if !merge.is_tree_allowed(&rhs_t) {
             return None;
         }
 }
 
 /// Normalizes a use tree (see [`try_normalize_import`] doc).
-pub fn try_normalize_use_tree(
-    use_tree: &ast::UseTree,
-    style: NormalizationStyle,
-) -> Option<ast::UseTree> {
+pub fn try_normalize_use_tree(use_tree: &ast::UseTree, style: NormalizationStyle) -> Option<ast::UseTree> {
     let use_tree = use_tree.clone_subtree().clone_for_update();
     try_normalize_use_tree_mut(&use_tree, style)?;
     Some(use_tree)
 }
 
-pub fn try_normalize_use_tree_mut(
-    use_tree: &ast::UseTree,
-    style: NormalizationStyle,
-) -> Option<()> {
+pub fn try_normalize_use_tree_mut(use_tree: &ast::UseTree, style: NormalizationStyle) -> Option<()> {
     if style == NormalizationStyle::One {
         let mut modified = false;
         modified |= use_tree.wrap_in_tree_list().is_some();
                     inner_use_tree_list.syntax(),
                 );
             } else if single_subtree.star_token().is_some() {
-                ted::insert_raw(
-                    Position::last_child_of(use_tree.syntax()),
-                    make::token(T![*]),
-                );
+                ted::insert_raw(Position::last_child_of(use_tree.syntax()), make::token(T![*]));
             } else if let Some(rename) = single_subtree.rename() {
                 ted::insert_raw(
                     Position::last_child_of(use_tree.syntax()),
 /// or tree list equality is confirmed, otherwise (i.e. if either `strict` is false or at least
 /// one of the trees does *not* have tree list), this potentially recursive step is skipped,
 /// and only the presence of a glob pattern or an alias is used to determine the ordering.
-fn use_tree_cmp_by_tree_list_glob_or_alias(
-    a: &ast::UseTree,
-    b: &ast::UseTree,
-    strict: bool,
-) -> Ordering {
+fn use_tree_cmp_by_tree_list_glob_or_alias(a: &ast::UseTree, b: &ast::UseTree, strict: bool) -> Ordering {
     let cmp_by_glob_or_alias = || match (a.star_token().is_some(), b.star_token().is_some()) {
         (true, false) => Ordering::Greater,
         (false, true) => Ordering::Less,
                 ),
         },
     };
-
     match (a.use_tree_list(), b.use_tree_list()) {
         (Some(_), None) => Ordering::Greater,
         (None, Some(_)) => Ordering::Less,
     }
 }
 
-pub fn eq_attrs(
-    attrs0: impl Iterator<Item = ast::Attr>,
-    attrs1: impl Iterator<Item = ast::Attr>,
-) -> bool {
+pub fn eq_attrs(attrs0: impl Iterator<Item = ast::Attr>, attrs1: impl Iterator<Item = ast::Attr>) -> bool {
     // FIXME order of attributes should not matter
     let attrs0 = attrs0
         .flat_map(|attr| attr.syntax().descendants_with_tokens())
 }
 
 fn remove_subtree_if_only_self(use_tree: &ast::UseTree) {
-    let Some(single_subtree) = get_single_subtree(use_tree) else {
-        return;
-    };
+    let Some(single_subtree) = get_single_subtree(use_tree) else { return };
     match (use_tree.path(), single_subtree.path()) {
         (Some(_), Some(inner)) if path_is_self(&inner) => {
             ted::remove_all_iter(single_subtree.syntax().children_with_tokens());
     }
 }
 
-// Taken from rustfmt
-// https://github.com/rust-lang/rustfmt/blob/0332da01486508710f2a542111e40513bfb215aa/src/sort.rs
 mod version_sort {
     // Original rustfmt code contains some clippy lints.
     // Suppress them to minimize changes from upstream.
     #![allow(clippy::all)]
-
     use std::cmp::Ordering;
-
     use itertools::{EitherOrBoth, Itertools};
-
     struct VersionChunkIter<'a> {
         ident: &'a str,
         start: usize,
     }
-
     impl<'a> VersionChunkIter<'a> {
         pub(crate) fn new(ident: &'a str) -> Self {
             Self { ident, start: 0 }
         }
 
-        fn parse_numeric_chunk(
-            &mut self,
-            mut chars: std::str::CharIndices<'a>,
-        ) -> Option<VersionChunk<'a>> {
+        fn parse_numeric_chunk(&mut self, mut chars: std::str::CharIndices<'a>) -> Option<VersionChunk<'a>> {
             let mut end = self.start;
             let mut is_end_of_chunk = false;
-
             while let Some((idx, c)) = chars.next() {
                 end = self.start + idx;
 
                 is_end_of_chunk = true;
                 break;
             }
-
             let source = if is_end_of_chunk {
                 let value = &self.ident[self.start..end];
                 self.start = end;
                 self.start = self.ident.len();
                 value
             };
-
             let zeros = source.chars().take_while(|c| *c == '0').count();
             let value = source.parse::<usize>().ok()?;
-
-            Some(VersionChunk::Number {
-                value,
-                zeros,
-                source,
-            })
+            Some(VersionChunk::Number { value, zeros, source })
         }
 
-        fn parse_str_chunk(
-            &mut self,
-            mut chars: std::str::CharIndices<'a>,
-        ) -> Option<VersionChunk<'a>> {
+        fn parse_str_chunk(&mut self, mut chars: std::str::CharIndices<'a>) -> Option<VersionChunk<'a>> {
             let mut end = self.start;
             let mut is_end_of_chunk = false;
-
             while let Some((idx, c)) = chars.next() {
                 end = self.start + idx;
 
                 is_end_of_chunk = true;
                 break;
             }
-
             let source = if is_end_of_chunk {
                 let value = &self.ident[self.start..end];
                 self.start = end;
                 self.start = self.ident.len();
                 value
             };
-
             Some(VersionChunk::Str(source))
         }
     }
-
     impl<'a> Iterator for VersionChunkIter<'a> {
         type Item = VersionChunk<'a>;
 
         fn next(&mut self) -> Option<Self::Item> {
             let mut chars = self.ident[self.start..].char_indices();
             let (_, next) = chars.next()?;
-
             if next == '_' {
                 self.start = self.start + next.len_utf8();
                 return Some(VersionChunk::Underscore);
             }
-
             if next.is_ascii_digit() {
                 return self.parse_numeric_chunk(chars);
             }
-
             self.parse_str_chunk(chars)
         }
     }
-
     /// Represents a chunk in the version-sort algorithm
     #[derive(Debug, PartialEq, Eq)]
     enum VersionChunk<'a> {
             source: &'a str,
         },
     }
-
     /// Determine which side of the version-sort comparison had more leading zeros.
     #[derive(Debug, PartialEq, Eq)]
     enum MoreLeadingZeros {
         Right,
         Equal,
     }
-
     pub(super) fn version_sort(a: &str, b: &str) -> Ordering {
         let iter_a = VersionChunkIter::new(a);
         let iter_b = VersionChunkIter::new(b);
         let mut more_leading_zeros = MoreLeadingZeros::Equal;
-
         for either_or_both in iter_a.zip_longest(iter_b) {
             match either_or_both {
                 EitherOrBoth::Left(_) => return std::cmp::Ordering::Greater,
                         }
                     }
                     (
-                        VersionChunk::Number {
-                            value: va,
-                            zeros: lza,
-                            ..
-                        },
-                        VersionChunk::Number {
-                            value: vb,
-                            zeros: lzb,
-                            ..
-                        },
+                        VersionChunk::Number { value: va, zeros: lza, .. },
+                        VersionChunk::Number { value: vb, zeros: lzb, .. },
                     ) => match va.cmp(&vb) {
                         std::cmp::Ordering::Equal => {
                             if lza == lzb {
                 },
             }
         }
-
         match more_leading_zeros {
             MoreLeadingZeros::Equal => std::cmp::Ordering::Equal,
             MoreLeadingZeros::Left => std::cmp::Ordering::Less,