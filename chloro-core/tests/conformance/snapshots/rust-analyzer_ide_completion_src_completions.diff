COMPARISON DIFF
============================================================

Original size: 25726 bytes
Chloro size:   24590 bytes
Rustfmt size:  25726 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! This module defines an accumulator for completions which are going to be presented to user.
 
-pub(crate) mod attribute;
-pub(crate) mod dot;
-pub(crate) mod env_vars;
-pub(crate) mod expr;
-pub(crate) mod extern_abi;
-pub(crate) mod extern_crate;
-pub(crate) mod field;
-pub(crate) mod flyimport;
-pub(crate) mod fn_param;
-pub(crate) mod format_string;
-pub(crate) mod item_list;
-pub(crate) mod keyword;
-pub(crate) mod lifetime;
-pub(crate) mod mod_;
-pub(crate) mod pattern;
-pub(crate) mod postfix;
-pub(crate) mod ra_fixture;
-pub(crate) mod record;
-pub(crate) mod snippet;
-pub(crate) mod r#type;
-pub(crate) mod use_;
-pub(crate) mod vis;
-
 use std::iter;
 
 use hir::{HasAttrs, Name, ScopeDef, Variant, sym};
         union_literal::render_union_literal,
     },
 };
+pub(crate) mod attribute;
+
+pub(crate) mod dot;
+
+pub(crate) mod env_vars;
+
+pub(crate) mod expr;
+
+pub(crate) mod extern_abi;
+
+pub(crate) mod extern_crate;
+
+pub(crate) mod field;
+
+pub(crate) mod flyimport;
+
+pub(crate) mod fn_param;
+
+pub(crate) mod format_string;
+
+pub(crate) mod item_list;
+
+pub(crate) mod keyword;
+
+pub(crate) mod lifetime;
+
+pub(crate) mod mod_;
+
+pub(crate) mod pattern;
+
+pub(crate) mod postfix;
+
+pub(crate) mod ra_fixture;
+
+pub(crate) mod record;
+
+pub(crate) mod snippet;
+
+pub(crate) mod r#type;
+
+pub(crate) mod use_;
+
+pub(crate) mod vis;
 
 /// Represents an in-progress set of completions being built.
 #[derive(Debug, Default)]
 
     pub(crate) fn add_nameref_keywords_with_colon(&mut self, ctx: &CompletionContext<'_>) {
         ["self::", "crate::"].into_iter().for_each(|kw| self.add_keyword(ctx, kw));
-
         if ctx.depth_from_crate_root > 0 {
             self.add_keyword(ctx, "super::");
         }
 
     pub(crate) fn add_nameref_keywords(&mut self, ctx: &CompletionContext<'_>) {
         ["self", "crate"].into_iter().for_each(|kw| self.add_keyword(ctx, kw));
-
         if ctx.depth_from_crate_root > 0 {
             self.add_keyword(ctx, "super");
         }
         self.add_keyword_snippet(ctx, "for", "for<$1>");
     }
 
-    pub(crate) fn add_super_keyword(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        super_chain_len: Option<usize>,
-    ) {
+    pub(crate) fn add_super_keyword(&mut self, ctx: &CompletionContext<'_>, super_chain_len: Option<usize>) {
         if let Some(len) = super_chain_len
             && len > 0
             && len < ctx.depth_from_crate_root
         }
     }
 
-    pub(crate) fn add_keyword_snippet_expr(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        incomplete_let: bool,
-        kw: &str,
-        snippet: &str,
-    ) {
+    pub(crate) fn add_keyword_snippet_expr(&mut self, ctx: &CompletionContext<'_>, incomplete_let: bool, kw: &str, snippet: &str) {
         let mut item =
             CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw, ctx.edition);
-
         match ctx.config.snippet_cap {
             Some(cap) => {
                 if incomplete_let && snippet.ends_with('}') {
         item.add_to(self, ctx.db);
     }
 
-    pub(crate) fn add_keyword_snippet(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        kw: &str,
-        snippet: &str,
-    ) {
+    pub(crate) fn add_keyword_snippet(&mut self, ctx: &CompletionContext<'_>, kw: &str, snippet: &str) {
         let mut item =
             CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw, ctx.edition);
-
         match ctx.config.snippet_cap {
             Some(cap) => item.insert_snippet(cap, snippet),
             None => item.insert_text(if snippet.contains('$') { kw } else { snippet }),
         item.add_to(self, ctx.db);
     }
 
-    pub(crate) fn add_expr(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        expr: &hir::term_search::Expr<'_>,
-    ) {
+    pub(crate) fn add_expr(&mut self, ctx: &CompletionContext<'_>, expr: &hir::term_search::Expr<'_>) {
         if let Some(item) = render_expr(ctx, expr) {
             item.add_to(self, ctx.db)
         }
     }
 
-    pub(crate) fn add_crate_roots(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-    ) {
+    pub(crate) fn add_crate_roots(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>) {
         ctx.process_all_names(&mut |name, res, doc_aliases| match res {
             ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root() => {
                 self.add_module(ctx, path_ctx, m, name, doc_aliases);
         });
     }
 
-    pub(crate) fn add_path_resolution(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-        local_name: hir::Name,
-        resolution: hir::ScopeDef,
-        doc_aliases: Vec<syntax::SmolStr>,
-    ) {
+    pub(crate) fn add_path_resolution(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>, local_name: hir::Name, resolution: hir::ScopeDef, doc_aliases: Vec<syntax::SmolStr>) {
         let is_private_editable = match ctx.def_is_visible(&resolution) {
             Visible::Yes => false,
             Visible::Editable => true,
         );
     }
 
-    pub(crate) fn add_pattern_resolution(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        pattern_ctx: &PatternContext,
-        local_name: hir::Name,
-        resolution: hir::ScopeDef,
-    ) {
+    pub(crate) fn add_pattern_resolution(&mut self, ctx: &CompletionContext<'_>, pattern_ctx: &PatternContext, local_name: hir::Name, resolution: hir::ScopeDef) {
         let is_private_editable = match ctx.def_is_visible(&resolution) {
             Visible::Yes => false,
             Visible::Editable => true,
         );
     }
 
-    pub(crate) fn add_enum_variants(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-        e: hir::Enum,
-    ) {
+    pub(crate) fn add_enum_variants(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>, e: hir::Enum) {
         if !ctx.check_stability_and_hidden(e) {
             return;
         }
             .for_each(|variant| self.add_enum_variant(ctx, path_ctx, variant, None));
     }
 
-    pub(crate) fn add_module(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-        module: hir::Module,
-        local_name: hir::Name,
-        doc_aliases: Vec<syntax::SmolStr>,
-    ) {
+    pub(crate) fn add_module(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>, module: hir::Module, local_name: hir::Name, doc_aliases: Vec<syntax::SmolStr>) {
         self.add_path_resolution(
             ctx,
             path_ctx,
         );
     }
 
-    pub(crate) fn add_macro(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-        mac: hir::Macro,
-        local_name: hir::Name,
-    ) {
+    pub(crate) fn add_macro(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>, mac: hir::Macro, local_name: hir::Name) {
         let is_private_editable = match ctx.is_visible(&mac) {
             Visible::Yes => false,
             Visible::Editable => true,
         );
     }
 
-    pub(crate) fn add_function(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-        func: hir::Function,
-        local_name: Option<hir::Name>,
-    ) {
+    pub(crate) fn add_function(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>, func: hir::Function, local_name: Option<hir::Name>) {
         let is_private_editable = match ctx.is_visible(&func) {
             Visible::Yes => false,
             Visible::Editable => true,
         );
     }
 
-    pub(crate) fn add_method(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        dot_access: &DotAccess<'_>,
-        func: hir::Function,
-        receiver: Option<SmolStr>,
-        local_name: Option<hir::Name>,
-    ) {
+    pub(crate) fn add_method(&mut self, ctx: &CompletionContext<'_>, dot_access: &DotAccess<'_>, func: hir::Function, receiver: Option<SmolStr>, local_name: Option<hir::Name>) {
         let is_private_editable = match ctx.is_visible(&func) {
             Visible::Yes => false,
             Visible::Editable => true,
         );
     }
 
-    pub(crate) fn add_method_with_import(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        dot_access: &DotAccess<'_>,
-        func: hir::Function,
-        import: LocatedImport,
-    ) {
+    pub(crate) fn add_method_with_import(&mut self, ctx: &CompletionContext<'_>, dot_access: &DotAccess<'_>, func: hir::Function, import: LocatedImport) {
         let is_private_editable = match ctx.is_visible(&func) {
             Visible::Yes => false,
             Visible::Editable => true,
         ));
     }
 
-    pub(crate) fn add_type_alias(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        type_alias: hir::TypeAlias,
-    ) {
+    pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext<'_>, type_alias: hir::TypeAlias) {
         let is_private_editable = match ctx.is_visible(&type_alias) {
             Visible::Yes => false,
             Visible::Editable => true,
         ));
     }
 
-    pub(crate) fn add_type_alias_with_eq(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        type_alias: hir::TypeAlias,
-    ) {
+    pub(crate) fn add_type_alias_with_eq(&mut self, ctx: &CompletionContext<'_>, type_alias: hir::TypeAlias) {
         if !ctx.check_stability(Some(&type_alias.attrs(ctx.db))) {
             return;
         }
         self.add_opt(render_type_alias_with_eq(RenderContext::new(ctx), type_alias));
     }
 
-    pub(crate) fn add_qualified_enum_variant(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-        variant: hir::Variant,
-        path: hir::ModPath,
-    ) {
+    pub(crate) fn add_qualified_enum_variant(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>, variant: hir::Variant, path: hir::ModPath) {
         if !ctx.check_stability_and_hidden(variant) {
             return;
         }
         }
     }
 
-    pub(crate) fn add_enum_variant(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-        variant: hir::Variant,
-        local_name: Option<hir::Name>,
-    ) {
+    pub(crate) fn add_enum_variant(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>, variant: hir::Variant, local_name: Option<hir::Name>) {
         if !ctx.check_stability_and_hidden(variant) {
             return;
         }
             self.add_variant_pat(ctx, pat_ctx, Some(path_ctx), variant, local_name);
             return;
         }
-
         if let Some(builder) =
             render_variant_lit(RenderContext::new(ctx), path_ctx, local_name, variant, None)
         {
         }
     }
 
-    pub(crate) fn add_field(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        dot_access: &DotAccess<'_>,
-        receiver: Option<SmolStr>,
-        field: hir::Field,
-        ty: &hir::Type<'_>,
-    ) {
+    pub(crate) fn add_field(&mut self, ctx: &CompletionContext<'_>, dot_access: &DotAccess<'_>, receiver: Option<SmolStr>, field: hir::Field, ty: &hir::Type<'_>) {
         let is_private_editable = match ctx.is_visible(&field) {
             Visible::Yes => false,
             Visible::Editable => true,
         self.add(item);
     }
 
-    pub(crate) fn add_struct_literal(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        path_ctx: &PathCompletionCtx<'_>,
-        strukt: hir::Struct,
-        path: Option<hir::ModPath>,
-        local_name: Option<hir::Name>,
-    ) {
+    pub(crate) fn add_struct_literal(&mut self, ctx: &CompletionContext<'_>, path_ctx: &PathCompletionCtx<'_>, strukt: hir::Struct, path: Option<hir::ModPath>, local_name: Option<hir::Name>) {
         let is_private_editable = match ctx.is_visible(&strukt) {
             Visible::Yes => false,
             Visible::Editable => true,
         }
     }
 
-    pub(crate) fn add_union_literal(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        un: hir::Union,
-        path: Option<hir::ModPath>,
-        local_name: Option<hir::Name>,
-    ) {
+    pub(crate) fn add_union_literal(&mut self, ctx: &CompletionContext<'_>, un: hir::Union, path: Option<hir::ModPath>, local_name: Option<hir::Name>) {
         let is_private_editable = match ctx.is_visible(&un) {
             Visible::Yes => false,
             Visible::Editable => true,
         self.add_opt(item);
     }
 
-    pub(crate) fn add_tuple_field(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        receiver: Option<SmolStr>,
-        field: usize,
-        ty: &hir::Type<'_>,
-    ) {
+    pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext<'_>, receiver: Option<SmolStr>, field: usize, ty: &hir::Type<'_>) {
         // Only used for (unnamed) tuples, whose all fields *are* stable. No need to check
         // stability here.
         let item = render_tuple_field(RenderContext::new(ctx), receiver, field, ty);
         .add_to(self, ctx.db)
     }
 
-    pub(crate) fn add_variant_pat(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        pattern_ctx: &PatternContext,
-        path_ctx: Option<&PathCompletionCtx<'_>>,
-        variant: hir::Variant,
-        local_name: Option<hir::Name>,
-    ) {
+    pub(crate) fn add_variant_pat(&mut self, ctx: &CompletionContext<'_>, pattern_ctx: &PatternContext, path_ctx: Option<&PathCompletionCtx<'_>>, variant: hir::Variant, local_name: Option<hir::Name>) {
         if !ctx.check_stability_and_hidden(variant) {
             return;
         }
         ));
     }
 
-    pub(crate) fn add_qualified_variant_pat(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        pattern_ctx: &PatternContext,
-        variant: hir::Variant,
-        path: hir::ModPath,
-    ) {
+    pub(crate) fn add_qualified_variant_pat(&mut self, ctx: &CompletionContext<'_>, pattern_ctx: &PatternContext, variant: hir::Variant, path: hir::ModPath) {
         if !ctx.check_stability_and_hidden(variant) {
             return;
         }
         ));
     }
 
-    pub(crate) fn add_struct_pat(
-        &mut self,
-        ctx: &CompletionContext<'_>,
-        pattern_ctx: &PatternContext,
-        strukt: hir::Struct,
-        local_name: Option<hir::Name>,
-    ) {
+    pub(crate) fn add_struct_pat(&mut self, ctx: &CompletionContext<'_>, pattern_ctx: &PatternContext, strukt: hir::Struct, local_name: Option<hir::Name>) {
         let is_private_editable = match ctx.is_visible(&strukt) {
             Visible::Yes => false,
             Visible::Editable => true,
 
 /// Calls the callback for each variant of the provided enum with the path to the variant.
 /// Skips variants that are visible with single segment paths.
-fn enum_variants_with_paths(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    enum_: hir::Enum,
-    impl_: Option<&ast::Impl>,
-    cb: impl Fn(&mut Completions, &CompletionContext<'_>, hir::Variant, hir::ModPath),
-) {
+fn enum_variants_with_paths(acc: &mut Completions, ctx: &CompletionContext<'_>, enum_: hir::Enum, impl_: Option<&ast::Impl>, cb: impl Fn(&mut Completions, &CompletionContext<'_>, hir::Variant, hir::ModPath)) {
     let mut process_variant = |variant: Variant| {
         let self_path = hir::ModPath::from_segments(
             hir::PathKind::Plain,
 
         cb(acc, ctx, variant, self_path);
     };
-
     let variants = enum_.variants(ctx.db);
-
     if let Some(impl_) = impl_.and_then(|impl_| ctx.sema.to_def(impl_))
         && impl_.self_ty(ctx.db).as_adt() == Some(hir::Adt::Enum(enum_))
     {
         variants.iter().for_each(|variant| process_variant(*variant));
     }
-
     for variant in variants {
         if let Some(path) = ctx.module.find_path(
             ctx.db,
     }
 }
 
-pub(super) fn complete_name(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    NameContext { name, kind }: &NameContext,
-) {
+pub(super) fn complete_name(acc: &mut Completions, ctx: &CompletionContext<'_>, NameContext { name, kind }: &NameContext) {
     match kind {
         NameKind::Const => {
             item_list::trait_impl::complete_trait_impl_const(acc, ctx, name);
     }
 }
 
-pub(super) fn complete_name_ref(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    NameRefContext { nameref, kind }: &NameRefContext<'_>,
-) {
+pub(super) fn complete_name_ref(acc: &mut Completions, ctx: &CompletionContext<'_>, NameRefContext { nameref, kind }: &NameRefContext<'_>) {
     match kind {
         NameRefKind::Path(path_ctx) => {
             flyimport::import_on_the_fly_path(acc, ctx, path_ctx);
     }
 }
 
-fn complete_patterns(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    pattern_ctx: &PatternContext,
-) {
+fn complete_patterns(acc: &mut Completions, ctx: &CompletionContext<'_>, pattern_ctx: &PatternContext) {
     flyimport::import_on_the_fly_pat(acc, ctx, pattern_ctx);
     fn_param::complete_fn_param(acc, ctx, pattern_ctx);
     pattern::complete_pattern(acc, ctx, pattern_ctx);