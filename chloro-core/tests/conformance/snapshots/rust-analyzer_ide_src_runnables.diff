COMPARISON DIFF
============================================================

Original size: 50564 bytes
Chloro size:   48629 bytes
Rustfmt size:  50564 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     pub cfg: Option<CfgExpr>,
     pub update_test: UpdateTest,
 }
-
-impl_empty_upmap_from_ra_fixture!(RunnableKind, UpdateTest);
-
 #[derive(Debug, Clone, Hash, PartialEq, Eq)]
 pub enum TestId {
     Name(SmolStr),
 
 #[derive(Debug, Clone, Hash, PartialEq, Eq)]
 pub enum RunnableKind {
-    TestMod { path: String },
-    Test { test_id: TestId, attr: TestAttr },
-    Bench { test_id: TestId },
-    DocTest { test_id: TestId },
+    TestMod {
+        path: String,
+    },
+    Test {
+        test_id: TestId,
+        attr: TestAttr,
+    },
+    Bench {
+        test_id: TestId,
+    },
+    DocTest {
+        test_id: TestId,
+    },
     Bin,
 }
 
     }
 }
 
-// Feature: Run
-//
-// Shows a popup suggesting to run a test/benchmark/binary **at the current cursor
-// location**. Super useful for repeatedly running just a single test. Do bind this
-// to a shortcut!
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Run** |
-//
-// ![Run](https://user-images.githubusercontent.com/48062697/113065583-055aae80-91b1-11eb-958f-d67efcaf6a2f.gif)
 pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {
     let sema = Semantics::new(db);
-
     let mut res = Vec::new();
     // Record all runnables that come from macro expansions here instead.
     // In case an expansion creates multiple runnables we want to name them to avoid emitting a bunch of equally named runnables.
             });
         }
     });
-
     sema.file_to_module_defs(file_id)
         .map(|it| runnable_mod_outline_definition(&sema, it))
         .for_each(|it| add_opt(it, None));
-
     res.extend(in_macro_expansion.into_iter().flat_map(|(_, runnables)| {
         let use_name_in_title = runnables.len() != 1;
         runnables.into_iter().map(move |mut r| {
     res
 }
 
-// Feature: Related Tests
-//
-// Provides a sneak peek of all tests where the current item is used.
-//
-// The simplest way to use this feature is via the context menu. Right-click on
-// the selected item. The context menu opens. Select **Peek Related Tests**.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Peek Related Tests** |
-pub(crate) fn related_tests(
-    db: &RootDatabase,
-    position: FilePosition,
-    search_scope: Option<SearchScope>,
-) -> Vec<Runnable> {
+pub(crate) fn related_tests(db: &RootDatabase, position: FilePosition, search_scope: Option<SearchScope>) -> Vec<Runnable> {
     let sema = Semantics::new(db);
     let mut res: FxIndexSet<Runnable> = FxIndexSet::default();
     let syntax = sema.parse_guess_edition(position.file_id).syntax().clone();
-
     find_related_tests(&sema, &syntax, position, search_scope, &mut res);
-
     res.into_iter().sorted_by(cmp_runnables).collect()
 }
 
-fn cmp_runnables(
-    Runnable { nav, kind, .. }: &Runnable,
-    Runnable { nav: nav_b, kind: kind_b, .. }: &Runnable,
-) -> std::cmp::Ordering {
+fn cmp_runnables(Runnable { nav, kind, .. }: &Runnable, Runnable { nav: nav_b, kind: kind_b, .. }: &Runnable) -> std::cmp::Ordering {
     // full_range.start < focus_range.start < name, should give us a decent unique ordering
     nav.full_range
         .start()
         .then_with(|| nav.name.as_str().cmp(nav_b.name.as_str()))
 }
 
-fn find_related_tests(
-    sema: &Semantics<'_, RootDatabase>,
-    syntax: &SyntaxNode,
-    position: FilePosition,
-    search_scope: Option<SearchScope>,
-    tests: &mut FxIndexSet<Runnable>,
-) {
+fn find_related_tests(sema: &Semantics<'_, RootDatabase>, syntax: &SyntaxNode, position: FilePosition, search_scope: Option<SearchScope>, tests: &mut FxIndexSet<Runnable>) {
     // FIXME: why is this using references::find_defs, this should use ide_db::search
     let defs = match references::find_defs(sema, syntax, position.offset) {
         Some(defs) => defs,
     }
 }
 
-fn find_related_tests_in_module(
-    sema: &Semantics<'_, RootDatabase>,
-    syntax: &SyntaxNode,
-    fn_def: &ast::Fn,
-    parent_module: &hir::Module,
-    tests: &mut FxIndexSet<Runnable>,
-) {
+fn find_related_tests_in_module(sema: &Semantics<'_, RootDatabase>, syntax: &SyntaxNode, fn_def: &ast::Fn, parent_module: &hir::Module, tests: &mut FxIndexSet<Runnable>) {
     let fn_name = match fn_def.name() {
         Some(it) => it,
         _ => return,
     };
     let mod_source = parent_module.definition_source_range(sema.db);
-
     let file_id = mod_source.file_id.original_file(sema.db);
     let mod_scope = SearchScope::file_range(hir::FileRange { file_id, range: mod_source.value });
     let fn_pos = FilePosition {
     })
 }
 
-pub(crate) fn runnable_fn(
-    sema: &Semantics<'_, RootDatabase>,
-    def: hir::Function,
-) -> Option<Runnable> {
+pub(crate) fn runnable_fn(sema: &Semantics<'_, RootDatabase>, def: hir::Function) -> Option<Runnable> {
     let edition = def.krate(sema.db).edition(sema.db);
     let under_cfg_test = has_cfg_test(def.module(sema.db).attrs(sema.db));
     let kind = if !under_cfg_test && def.is_main(sema.db) {
             return None;
         }
     };
-
     let fn_source = sema.source(def)?;
     let nav = NavigationTarget::from_named(
         sema.db,
         SymbolKind::Function,
     )
     .call_site();
-
     let file_range = fn_source.syntax().original_file_range_with_macro_call_input(sema.db);
     let update_test = UpdateTest::find_snapshot_macro(sema, file_range);
-
     let cfg = def.attrs(sema.db).cfg();
     Some(Runnable { use_name_in_title: false, nav, kind, cfg, update_test })
 }
 
-pub(crate) fn runnable_mod(
-    sema: &Semantics<'_, RootDatabase>,
-    def: hir::Module,
-) -> Option<Runnable> {
+pub(crate) fn runnable_mod(sema: &Semantics<'_, RootDatabase>, def: hir::Module) -> Option<Runnable> {
     if !has_test_function_or_multiple_test_submodules(sema, &def, has_cfg_test(def.attrs(sema.db)))
     {
         return None;
             })
         })
         .join("::");
-
     let attrs = def.attrs(sema.db);
     let cfg = attrs.cfg();
     let nav = NavigationTarget::from_module_to_decl(sema.db, def).call_site();
-
     let module_source = sema.module_definition_node(def);
     let module_syntax = module_source.file_syntax(sema.db);
     let file_range = hir::FileRange {
         range: module_syntax.text_range(),
     };
     let update_test = UpdateTest::find_snapshot_macro(sema, file_range);
-
     Some(Runnable {
         use_name_in_title: false,
         nav,
     })
 }
 
-pub(crate) fn runnable_impl(
-    sema: &Semantics<'_, RootDatabase>,
-    def: &hir::Impl,
-) -> Option<Runnable> {
+pub(crate) fn runnable_impl(sema: &Semantics<'_, RootDatabase>, def: &hir::Impl) -> Option<Runnable> {
     let display_target = def.module(sema.db).krate().to_display_target(sema.db);
     let edition = display_target.edition;
     let attrs = def.attrs(sema.db);
     let mut test_id = format!("{}{params}", adt_name.display(sema.db, edition));
     test_id.retain(|c| c != ' ');
     let test_id = TestId::Path(test_id);
-
     let impl_source = sema.source(*def)?;
     let impl_syntax = impl_source.syntax();
     let file_range = impl_syntax.original_file_range_with_macro_call_input(sema.db);
     let update_test = UpdateTest::find_snapshot_macro(sema, file_range);
-
     Some(Runnable {
         use_name_in_title: false,
         nav,
 }
 
 /// Creates a test mod runnable for outline modules at the top of their definition.
-fn runnable_mod_outline_definition(
-    sema: &Semantics<'_, RootDatabase>,
-    def: hir::Module,
-) -> Option<Runnable> {
+fn runnable_mod_outline_definition(sema: &Semantics<'_, RootDatabase>, def: hir::Module) -> Option<Runnable> {
     def.as_source_file_id(sema.db)?;
-
     if !has_test_function_or_multiple_test_submodules(sema, &def, has_cfg_test(def.attrs(sema.db)))
     {
         return None;
             })
         })
         .join("::");
-
     let attrs = def.attrs(sema.db);
     let cfg = attrs.cfg();
-
     let mod_source = sema.module_definition_node(def);
     let mod_syntax = mod_source.file_syntax(sema.db);
     let file_range = hir::FileRange {
         range: mod_syntax.text_range(),
     };
     let update_test = UpdateTest::find_snapshot_macro(sema, file_range);
-
     Some(Runnable {
         use_name_in_title: false,
         nav: def.to_nav(sema.db).call_site(),
         format_to!(path, "{}", def_name.display(db, edition));
         Some(path)
     })();
-
     let test_id = path
         .map_or_else(|| TestId::Name(def_name.display_no_db(edition).to_smolstr()), TestId::Path);
-
     let mut nav = match def {
         Definition::Module(def) => NavigationTarget::from_module_to_decl(db, def),
         def => def.try_to_nav(sema)?,
     const RUSTDOC_FENCES: [&str; 2] = ["```", "~~~"];
     const RUSTDOC_CODE_BLOCK_ATTRIBUTES_RUNNABLE: &[&str] =
         &["", "rust", "should_panic", "edition2015", "edition2018", "edition2021"];
-
     docs_from_attrs(attrs).is_some_and(|doc| {
         let mut in_code_block = false;
 
     })
 }
 
-// We could create runnables for modules with number_of_test_submodules > 0,
-// but that bloats the runnables for no real benefit, since all tests can be run by the submodule already
-fn has_test_function_or_multiple_test_submodules(
-    sema: &Semantics<'_, RootDatabase>,
-    module: &hir::Module,
-    consider_exported_main: bool,
-) -> bool {
+fn has_test_function_or_multiple_test_submodules(sema: &Semantics<'_, RootDatabase>, module: &hir::Module, consider_exported_main: bool) -> bool {
     let mut number_of_test_submodules = 0;
-
     for item in module.declarations(sema.db) {
         match item {
             hir::ModuleDef::Function(f) => {
             _ => (),
         }
     }
-
     number_of_test_submodules > 1
 }
 
     pub snapbox: bool,
 }
 
-static SNAPSHOT_TEST_MACROS: OnceLock<FxHashMap<&str, Vec<[Symbol; 2]>>> = OnceLock::new();
 
 impl UpdateTest {
-    const EXPECT_CRATE: &str = "expect_test";
-    const EXPECT_MACROS: &[&str] = &["expect", "expect_file"];
 
-    const INSTA_CRATE: &str = "insta";
-    const INSTA_MACROS: &[&str] = &[
-        "assert_snapshot",
-        "assert_debug_snapshot",
-        "assert_display_snapshot",
-        "assert_json_snapshot",
-        "assert_yaml_snapshot",
-        "assert_ron_snapshot",
-        "assert_toml_snapshot",
-        "assert_csv_snapshot",
-        "assert_compact_json_snapshot",
-        "assert_compact_debug_snapshot",
-        "assert_binary_snapshot",
-    ];
 
-    const SNAPBOX_CRATE: &str = "snapbox";
-    const SNAPBOX_MACROS: &[&str] = &["assert_data_eq", "file", "str"];
+
+
+
 
     fn find_snapshot_macro(sema: &Semantics<'_, RootDatabase>, file_range: hir::FileRange) -> Self {
         fn init<'a>(
             }
             map.insert(krate_name, res);
         }
-
         let mod_paths = SNAPSHOT_TEST_MACROS.get_or_init(|| {
             let mut map = FxHashMap::default();
             init(Self::EXPECT_CRATE, Self::EXPECT_MACROS, &mut map);
             init(Self::SNAPBOX_CRATE, Self::SNAPBOX_MACROS, &mut map);
             map
         });
-
         let search_scope = SearchScope::file_range(file_range);
         let find_macro = |paths: &[[Symbol; 2]]| {
             for path in paths {
             }
             false
         };
-
         UpdateTest {
             expect_test: find_macro(mod_paths.get(Self::EXPECT_CRATE).unwrap()),
             insta: find_macro(mod_paths.get(Self::INSTA_CRATE).unwrap()),
         if self.snapbox {
             builder.push("Snapbox");
         }
-
         let res: SmolStr = builder.join(" + ").into();
         if res.is_empty() {
             None
 #[cfg(test)]
 mod tests {
     use expect_test::{Expect, expect};
-
     use crate::fixture;
-
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, position) = fixture::position(ra_fixture);
         let result = analysis
             .collect::<Vec<_>>();
         expect.assert_debug_eq(&result);
     }
-
     fn check_tests(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, position) = fixture::position(ra_fixture);
         let tests = analysis.related_tests(position, None).unwrap();
         let navigation_targets = tests.into_iter().map(|runnable| runnable.nav).collect::<Vec<_>>();
         expect.assert_debug_eq(&navigation_targets);
     }
-
     #[test]
     fn test_runnables() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_and_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_const() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_types_and_const() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn only_modules_with_test_functions_or_more_than_one_test_submodule_have_runners() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_with_feature() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_with_features() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_no_test_function_in_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_doc_runnables_impl_mod() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn big_mac() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn dont_recurse_in_outline_submodules() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn outline_submodule1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn outline_submodule2() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn attributed_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn find_no_tests() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_direct_fn_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_direct_struct_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_indirect_fn_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn tests_are_unique() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_type_const_value() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn doc_test_type_params() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn doc_test_macro_export_mbe() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_paths_with_raw_ident() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn exported_main_is_test_in_cfg_test_mod() {
         check(