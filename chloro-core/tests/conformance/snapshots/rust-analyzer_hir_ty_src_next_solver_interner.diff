COMPARISON DIFF
============================================================

Original size: 82113 bytes
Chloro size:   81678 bytes
Rustfmt size:  84055 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Things related to the Interner in the next-trait-solver.
 
 use std::{fmt, ops::ControlFlow};
 
-pub use tls_cache::clear_tls_solver_cache;
-pub use tls_db::{attach_db, attach_db_allow_change, with_attached_db};
-
 use base_db::Crate;
 use hir_def::{
-    lang_item::LangItem,
-    signatures::{FieldData, FnFlags, ImplFlags, StructFlags, TraitFlags},
     AdtId, AttrDefId, BlockId, CallableDefId, DefWithBodyId, EnumVariantId, ItemContainerId,
     StructId, UnionId, VariantId,
+    lang_item::LangItem,
+    signatures::{FieldData, FnFlags, ImplFlags, StructFlags, TraitFlags},
 };
 use la_arena::Idx;
 use rustc_abi::{ReprFlags, ReprOptions};
 use rustc_hash::FxHashSet;
 use rustc_index::bit_set::DenseBitSet;
 use rustc_type_ir::{
+    AliasTermKind, AliasTyKind, BoundVar, CollectAndApply, CoroutineWitnessTypes, DebruijnIndex,
+    EarlyBinder, FlagComputation, Flags, GenericArgKind, ImplPolarity, InferTy, Interner, TraitRef,
+    TypeVisitableExt, UniverseIndex, Upcast, Variance,
     elaborate::elaborate,
     error::TypeError,
     inherent::{self, GenericsOf, IntoKind, SliceLike as _, Span as _, Ty as _},
     lang_items::{SolverAdtLangItem, SolverLangItem, SolverTraitLangItem},
     solve::SizedTraitKind,
-    AliasTermKind, AliasTyKind, BoundVar, CollectAndApply, CoroutineWitnessTypes, DebruijnIndex,
-    EarlyBinder, FlagComputation, Flags, GenericArgKind, ImplPolarity, InferTy, Interner, TraitRef,
-    TypeVisitableExt, UniverseIndex, Upcast, Variance,
 };
+pub use tls_cache::clear_tls_solver_cache;
+pub use tls_db::{attach_db, attach_db_allow_change, with_attached_db};
 
+pub use crate::_interned_vec_db as interned_vec_db;
+pub use crate::_interned_vec_nolifetime_salsa as interned_vec_nolifetime_salsa;
 use crate::{
+    FnAbi,
     db::{HirDatabase, InternedCoroutine, InternedCoroutineId},
-    method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},
+    method_resolution::{ALL_FLOAT_FPS, ALL_INT_FPS, TyFingerprint},
     next_solver::{
-        util::{explicit_item_bounds, for_trait_impls, ContainsTypeErrors},
         AdtIdWrapper, BoundConst, CallableIdWrapper, CanonicalVarKind, ClosureIdWrapper,
         CoroutineIdWrapper, Ctor, FnSig, FxIndexMap, ImplIdWrapper, OpaqueTypeKey,
         RegionAssumptions, SolverContext, SolverDefIds, TraitIdWrapper, TypeAliasIdWrapper,
+        util::{ContainsTypeErrors, explicit_item_bounds, for_trait_impls},
     },
-    FnAbi,
 };
-
 use super::{
-    abi::Safety,
-    fold::{BoundVarReplacer, BoundVarReplacerDelegate, FnMutDelegate},
-    generics::{generics, Generics},
-    region::{
-        BoundRegion, BoundRegionKind, EarlyParamRegion, LateParamRegion, PlaceholderRegion, Region,
-    },
-    util::sizedness_constraint_for_ty,
     Binder, BoundExistentialPredicates, BoundTy, BoundTyKind, Clause, ClauseKind, Clauses, Const,
     ErrorGuaranteed, ExprConst, ExternalConstraints, GenericArg, GenericArgs, ParamConst, ParamEnv,
     ParamTy, PlaceholderConst, PlaceholderTy, PredefinedOpaques, Predicate, SolverDefId, Term, Ty,
     TyKind, Tys, Valtree, ValueConst,
+    abi::Safety,
+    fold::{BoundVarReplacer, BoundVarReplacerDelegate, FnMutDelegate},
+    generics::{Generics, generics},
+    region::{
+        BoundRegion, BoundRegionKind, EarlyParamRegion, LateParamRegion, PlaceholderRegion, Region,
+    },
+    util::sizedness_constraint_for_ty,
 };
 
 #[derive(PartialEq, Eq, Hash, PartialOrd, Ord, Clone)]
                 folder: &mut F,
             ) -> Result<Self, F::Error> {
                 use rustc_type_ir::inherent::SliceLike as _;
-                let inner: smallvec::SmallVec<[_; 2]> = self
-                    .iter()
-                    .map(|v| v.try_fold_with(folder))
-                    .collect::<Result<_, _>>()?;
+                let inner: smallvec::SmallVec<[_; 2]> =
+                    self.iter().map(|v| v.try_fold_with(folder)).collect::<Result<_, _>>()?;
                 Ok($name::new_(folder.cx().db(), inner))
             }
             fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
                 interner: DbInterner<'db>,
                 data: impl IntoIterator<Item = $ty>,
             ) -> Self {
-                $name::new_(
-                    interner.db(),
-                    data.into_iter().collect::<smallvec::SmallVec<[_; 2]>>(),
-                )
+                $name::new_(interner.db(), data.into_iter().collect::<smallvec::SmallVec<[_; 2]>>())
             }
 
             pub fn inner(&self) -> &smallvec::SmallVec<[$ty; 2]> {
     };
 }
 
-pub use crate::_interned_vec_nolifetime_salsa as interned_vec_nolifetime_salsa;
-
 #[macro_export]
 #[doc(hidden)]
 macro_rules! _interned_vec_db {
                 folder: &mut F,
             ) -> Result<Self, F::Error> {
                 use rustc_type_ir::inherent::SliceLike as _;
-                let inner: smallvec::SmallVec<[_; 2]> = self
-                    .iter()
-                    .map(|v| v.try_fold_with(folder))
-                    .collect::<Result<_, _>>()?;
+                let inner: smallvec::SmallVec<[_; 2]> =
+                    self.iter().map(|v| v.try_fold_with(folder)).collect::<Result<_, _>>()?;
                 Ok($name::new_(folder.cx().db(), inner))
             }
             fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
                 interner: DbInterner<'db>,
                 data: impl IntoIterator<Item = $ty<'db>>,
             ) -> Self {
-                $name::new_(
-                    interner.db(),
-                    data.into_iter().collect::<smallvec::SmallVec<[_; 2]>>(),
-                )
+                $name::new_(interner.db(), data.into_iter().collect::<smallvec::SmallVec<[_; 2]>>())
             }
 
             pub fn inner(&self) -> &smallvec::SmallVec<[$ty<'db>; 2]> {
     };
 }
 
-pub use crate::_interned_vec_db as interned_vec_db;
-
 #[derive(Debug, Copy, Clone)]
 pub struct DbInterner<'db> {
     pub(crate) db: &'db dyn HirDatabase,
     pub(crate) block: Option<BlockId>,
 }
 
-// FIXME: very wrong, see https://github.com/rust-lang/rust/pull/144808
-unsafe impl Send for DbInterner<'_> {}
-unsafe impl Sync for DbInterner<'_> {}
+unsafe impl Send for DbInterner<'_> {
+}
+
+unsafe impl Sync for DbInterner<'_> {
+}
 
 impl<'db> DbInterner<'db> {
-    // FIXME(next-solver): remove this method
     pub fn conjure() -> DbInterner<'db> {
         crate::with_attached_db(|db| DbInterner {
             db: unsafe { std::mem::transmute::<&dyn HirDatabase, &'db dyn HirDatabase>(db) },
     }
 }
 
-// This is intentionally left as `()`
 #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
 pub struct Span(());
 
         Span(())
     }
 }
-
-interned_vec_nolifetime_salsa!(BoundVarKinds, BoundVarKind, nofold);
-
 #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
 pub enum BoundVarKind {
     Ty(BoundTyKind),
         }
     }
 }
-
-interned_vec_db!(CanonicalVars, CanonicalVarKind, nofold);
-
 pub struct DepNodeIndex;
 
 #[derive(Debug)]
 }
 
 impl<T: std::fmt::Debug> std::fmt::Debug for Placeholder<T> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> fmt::Result {
         if self.universe == UniverseIndex::ROOT {
             write!(f, "!{:?}", self.bound)
         } else {
 
 #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
 pub struct AllocId;
-
-interned_vec_nolifetime_salsa!(VariancesOf, Variance, nofold);
-
 #[derive(Debug, Clone, Eq, PartialEq, Hash)]
 pub struct VariantIdx(usize);
 
-// FIXME: could/should store actual data?
 #[derive(Debug, Clone, Eq, PartialEq, Hash)]
 pub enum VariantDef {
     Struct(StructId),
         }
     }
 
-    pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Idx<FieldData>, FieldData)> {
+    pub fn fields(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Vec<(Idx<FieldData>, FieldData)> {
         let id: VariantId = match self {
             VariantDef::Struct(it) => (*it).into(),
             VariantDef::Union(it) => (*it).into(),
             VariantDef::Enum(it) => (*it).into(),
         };
-        id.fields(db)
-            .fields()
-            .iter()
-            .map(|(id, data)| (id, data.clone()))
-            .collect()
+        id.fields(db).fields().iter().map(|(id, data)| (id, data.clone())).collect()
     }
 }
 
-/*
-/// Definition of a variant -- a struct's fields or an enum variant.
-#[derive(Debug, HashStable, TyEncodable, TyDecodable)]
-pub struct VariantDef {
-    /// `DefId` that identifies the variant itself.
-    /// If this variant belongs to a struct or union, then this is a copy of its `DefId`.
-    pub def_id: DefId,
-    /// `DefId` that identifies the variant's constructor.
-    /// If this variant is a struct variant, then this is `None`.
-    pub ctor: Option<(CtorKind, DefId)>,
-    /// Variant or struct name, maybe empty for anonymous adt (struct or union).
-    pub name: Symbol,
-    /// Discriminant of this variant.
-    pub discr: VariantDiscr,
-    /// Fields of this variant.
-    pub fields: IndexVec<FieldIdx, FieldDef>,
-    /// The error guarantees from parser, if any.
-    tainted: Option<ErrorGuaranteed>,
-    /// Flags of the variant (e.g. is field list non-exhaustive)?
-    flags: VariantFlags,
-}
-*/
-
 #[derive(Debug, Clone, Eq, PartialEq, Hash)]
 pub struct AdtFlags {
     is_enum: bool,
     repr: ReprOptions,
 }
 
-// We're gonna cheat a little bit and implement `Hash` on only the `DefId` and
-// accept there might be collisions for def ids from different crates (or across
-// different tests, oh my).
 impl std::hash::Hash for AdtDefInner {
     #[inline]
-    fn hash<H: std::hash::Hasher>(&self, s: &mut H) {
+    fn hash<H: std::hash::Hasher>(
+        &self,
+        s: &mut H,
+    ) {
         self.id.hash(s)
     }
 }
 }
 
 impl AdtDef {
-    pub fn new<'db>(def_id: AdtId, interner: DbInterner<'db>) -> Self {
+    pub fn new<'db>(
+        def_id: AdtId,
+        interner: DbInterner<'db>,
+    ) -> Self {
         let db = interner.db();
         let (flags, variants, repr) = match def_id {
             AdtId::StructId(struct_id) => {
                 (flags, variants, repr)
             }
         };
-
-        AdtDef::new_(
-            db,
-            AdtDefInner {
-                id: def_id,
-                variants,
-                flags,
-                repr,
-            },
-        )
+        AdtDef::new_(db, AdtDefInner { id: def_id, variants, flags, repr })
     }
 
     pub fn inner(&self) -> &AdtDefInner {
         };
         let id: VariantId = struct_id.into();
         let field_types = interner.db().field_types(id);
-
         field_types.iter().last().map(|f| *f.1)
     }
 
         let db = interner.db();
         // FIXME: this is disabled just to match the behavior with chalk right now
         let _field_tys = |id: VariantId| {
-            db.field_types(id)
-                .iter()
-                .map(|(_, ty)| ty.skip_binder())
-                .collect::<Vec<_>>()
+            db.field_types(id).iter().map(|(_, ty)| ty.skip_binder()).collect::<Vec<_>>()
         };
         let field_tys = |_id: VariantId| vec![];
         let tys: Vec<_> = match self.inner().id {
                 .flat_map(|&(variant_id, _, _)| field_tys(variant_id.into()))
                 .collect(),
         };
-
         EarlyBinder::bind(tys)
     }
 
         sizedness: SizedTraitKind,
     ) -> Option<EarlyBinder<DbInterner<'db>, Ty<'db>>> {
         if self.is_struct() {
-            let tail_ty = self
-                .all_field_tys(interner)
-                .skip_binder()
-                .into_iter()
-                .last()?;
+            let tail_ty = self.all_field_tys(interner).skip_binder().into_iter().last()?;
 
             let constraint_ty = sizedness_constraint_for_ty(interner, sizedness, tail_ty)?;
 
 }
 
 impl fmt::Debug for AdtDef {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         crate::with_attached_db(|db| match self.inner().id {
             AdtId::StructId(struct_id) => {
                 let data = db.struct_signature(struct_id);
         false
     }
 
-    fn feature_bound_holds_in_crate(self, _symbol: ()) -> bool {
+    fn feature_bound_holds_in_crate(
+        self,
+        _symbol: (),
+    ) -> bool {
         false
     }
 }
 }
 
 impl<'db> std::fmt::Debug for InternedWrapperNoDebug<PatternKind<'db>> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         self.0.fmt(f)
     }
 }
 
 impl<'db> Pattern<'db> {
-    pub fn new(interner: DbInterner<'db>, kind: PatternKind<'db>) -> Self {
+    pub fn new(
+        interner: DbInterner<'db>,
+        kind: PatternKind<'db>,
+    ) -> Self {
         Pattern::new_(interner.db(), InternedWrapperNoDebug(kind))
     }
 
 
     fn outer_exclusive_binder(&self) -> rustc_type_ir::DebruijnIndex {
         match self.inner() {
-            PatternKind::Range { start, end } => start
-                .outer_exclusive_binder()
-                .max(end.outer_exclusive_binder()),
+            PatternKind::Range { start, end } => {
+                start.outer_exclusive_binder().max(end.outer_exclusive_binder())
+            }
             PatternKind::Or(pats) => {
                 let mut idx = pats.as_slice()[0].outer_exclusive_binder();
                 for pat in pats.as_slice()[1..].iter() {
 
 impl<'db> rustc_type_ir::inherent::IntoKind for Pattern<'db> {
     type Kind = rustc_type_ir::PatternKind<DbInterner<'db>>;
+
     fn kind(self) -> Self::Kind {
         *self.inner()
     }
         let tcx = relation.cx();
         match (a.kind(), b.kind()) {
             (
-                PatternKind::Range {
-                    start: start_a,
-                    end: end_a,
-                },
-                PatternKind::Range {
-                    start: start_b,
-                    end: end_b,
-                },
+                PatternKind::Range { start: start_a, end: end_a },
+                PatternKind::Range { start: start_b, end: end_b },
             ) => {
                 let start = relation.relate(start_a, start_b)?;
                 let end = relation.relate(end_a, end_b)?;
         }
     }
 }
-
-interned_vec_db!(PatList, Pattern);
-
 macro_rules! as_lang_item {
     (
         $solver_enum:ident, $var:ident;
 
 impl<'db> Interner for DbInterner<'db> {
     type DefId = SolverDefId;
+
     type LocalDefId = SolverDefId;
+
     type LocalDefIds = SolverDefIds<'db>;
+
     type TraitId = TraitIdWrapper;
+
     type ForeignId = TypeAliasIdWrapper;
+
     type FunctionId = CallableIdWrapper;
+
     type ClosureId = ClosureIdWrapper;
+
     type CoroutineClosureId = CoroutineIdWrapper;
+
     type CoroutineId = CoroutineIdWrapper;
+
     type AdtId = AdtIdWrapper;
+
     type ImplId = ImplIdWrapper;
+
     type Span = Span;
 
     type GenericArgs = GenericArgs<'db>;
+
     type GenericArgsSlice = GenericArgs<'db>;
+
     type GenericArg = GenericArg<'db>;
 
     type Term = Term<'db>;
 
     type BoundVarKinds = BoundVarKinds<'db>;
+
     type BoundVarKind = BoundVarKind;
 
     type PredefinedOpaques = PredefinedOpaques<'db>;
     type Tracked<T: fmt::Debug + Clone> = Tracked<T>;
 
     type Ty = Ty<'db>;
+
     type Tys = Tys<'db>;
+
     type FnInputTys = Tys<'db>;
+
     type ParamTy = ParamTy;
+
     type BoundTy = BoundTy;
+
     type PlaceholderTy = PlaceholderTy;
+
     type Symbol = ();
 
     type ErrorGuaranteed = ErrorGuaranteed;
+
     type BoundExistentialPredicates = BoundExistentialPredicates<'db>;
+
     type AllocId = AllocId;
+
     type Pat = Pattern<'db>;
+
     type PatList = PatList<'db>;
+
     type Safety = Safety;
+
     type Abi = FnAbi;
 
     type Const = Const<'db>;
+
     type PlaceholderConst = PlaceholderConst;
+
     type ParamConst = ParamConst;
+
     type BoundConst = BoundConst;
+
     type ValueConst = ValueConst<'db>;
+
     type ValTree = Valtree<'db>;
+
     type ExprConst = ExprConst;
 
     type Region = Region<'db>;
+
     type EarlyParamRegion = EarlyParamRegion;
+
     type LateParamRegion = LateParamRegion;
+
     type BoundRegion = BoundRegion;
+
     type PlaceholderRegion = PlaceholderRegion;
 
     type RegionAssumptions = RegionAssumptions<'db>;
 
     type ParamEnv = ParamEnv<'db>;
+
     type Predicate = Predicate<'db>;
+
     type Clause = Clause<'db>;
+
     type Clauses = Clauses<'db>;
 
     type GenericsOf = Generics;
 
     type Features = Features;
 
-    fn mk_args(self, args: &[Self::GenericArg]) -> Self::GenericArgs {
+    fn mk_args(
+        self,
+        args: &[Self::GenericArg],
+    ) -> Self::GenericArgs {
         GenericArgs::new_from_iter(self, args.iter().cloned())
     }
 
-    fn mk_args_from_iter<I, T>(self, args: I) -> T::Output
+    fn mk_args_from_iter<I, T>(
+        self,
+        args: I,
+    ) -> T::Output
     where
         I: Iterator<Item = T>,
-        T: rustc_type_ir::CollectAndApply<Self::GenericArg, Self::GenericArgs>,
-    {
+        T: rustc_type_ir::CollectAndApply<Self::GenericArg, Self::GenericArgs>, {
         CollectAndApply::collect_and_apply(args, |g| {
             GenericArgs::new_from_iter(self, g.iter().cloned())
         })
         Tracked(data)
     }
 
-    fn get_tracked<T: fmt::Debug + Clone>(self, tracked: &Self::Tracked<T>) -> T {
+    fn get_tracked<T: fmt::Debug + Clone>(
+        self,
+        tracked: &Self::Tracked<T>,
+    ) -> T {
         tracked.0.clone()
     }
 
-    fn with_cached_task<T>(self, task: impl FnOnce() -> T) -> (T, Self::DepNodeIndex) {
+    fn with_cached_task<T>(
+        self,
+        task: impl FnOnce() -> T,
+    ) -> (T, Self::DepNodeIndex) {
         (task(), DepNodeIndex)
     }
 
         panic!("evaluation shouldn't be concurrent yet")
     }
 
-    fn expand_abstract_consts<T: rustc_type_ir::TypeFoldable<Self>>(self, _: T) -> T {
+    fn expand_abstract_consts<T: rustc_type_ir::TypeFoldable<Self>>(
+        self,
+        _: T,
+    ) -> T {
         unreachable!("only used by the old trait solver in rustc");
     }
 
-    fn generics_of(self, def_id: Self::DefId) -> Self::GenericsOf {
+    fn generics_of(
+        self,
+        def_id: Self::DefId,
+    ) -> Self::GenericsOf {
         generics(self.db(), def_id)
     }
 
-    fn variances_of(self, def_id: Self::DefId) -> Self::VariancesOf {
+    fn variances_of(
+        self,
+        def_id: Self::DefId,
+    ) -> Self::VariancesOf {
         let generic_def = match def_id {
             SolverDefId::Ctor(Ctor::Enum(def_id)) | SolverDefId::EnumVariantId(def_id) => {
                 def_id.loc(self.db).parent.into()
         self.db.variances_of(generic_def)
     }
 
-    fn type_of(self, def_id: Self::DefId) -> EarlyBinder<Self, Self::Ty> {
+    fn type_of(
+        self,
+        def_id: Self::DefId,
+    ) -> EarlyBinder<Self, Self::Ty> {
         match def_id {
             SolverDefId::TypeAliasId(id) => {
                 use hir_def::Lookup;
                     Ctor::Struct(id) => id.into(),
                     Ctor::Enum(id) => id.into(),
                 };
-                self.db
-                    .value_ty(id)
-                    .expect("`SolverDefId::Ctor` should have a function-like ctor")
+                self.db.value_ty(id).expect("`SolverDefId::Ctor` should have a function-like ctor")
             }
             _ => panic!("Unexpected def_id `{def_id:?}` provided for `type_of`"),
         }
     }
 
-    fn adt_def(self, def_id: Self::AdtId) -> Self::AdtDef {
+    fn adt_def(
+        self,
+        def_id: Self::AdtId,
+    ) -> Self::AdtDef {
         AdtDef::new(def_id.0, self)
     }
 
-    fn alias_ty_kind(self, alias: rustc_type_ir::AliasTy<Self>) -> AliasTyKind {
+    fn alias_ty_kind(
+        self,
+        alias: rustc_type_ir::AliasTy<Self>,
+    ) -> AliasTyKind {
         match alias.def_id {
             SolverDefId::InternedOpaqueTyId(_) => AliasTyKind::Opaque,
             SolverDefId::TypeAliasId(type_alias) => match type_alias.loc(self.db).container {
         let trait_generics = self.generics_of(trait_def_id);
         let trait_args = GenericArgs::new_from_iter(
             self,
-            args.as_slice()[0..trait_generics.own_params.len()]
-                .iter()
-                .cloned(),
+            args.as_slice()[0..trait_generics.own_params.len()].iter().cloned(),
         );
         let alias_args =
             GenericArgs::new_from_iter(self, args.iter().skip(trait_generics.own_params.len()));
-        (
-            TraitRef::new_from_args(self, trait_def_id.try_into().unwrap(), trait_args),
-            alias_args,
-        )
+        (TraitRef::new_from_args(self, trait_def_id.try_into().unwrap(), trait_args), alias_args)
     }
 
-    fn check_args_compatible(self, _def_id: Self::DefId, _args: Self::GenericArgs) -> bool {
+    fn check_args_compatible(
+        self,
+        _def_id: Self::DefId,
+        _args: Self::GenericArgs,
+    ) -> bool {
         // FIXME
         true
     }
 
-    fn debug_assert_args_compatible(self, _def_id: Self::DefId, _args: Self::GenericArgs) {}
+    fn debug_assert_args_compatible(
+        self,
+        _def_id: Self::DefId,
+        _args: Self::GenericArgs,
+    ) {
+    }
 
     fn debug_assert_existential_args_compatible(
         self,
     ) {
     }
 
-    fn mk_type_list_from_iter<I, T>(self, args: I) -> T::Output
+    fn mk_type_list_from_iter<I, T>(
+        self,
+        args: I,
+    ) -> T::Output
     where
         I: Iterator<Item = T>,
-        T: rustc_type_ir::CollectAndApply<Self::Ty, Self::Tys>,
-    {
+        T: rustc_type_ir::CollectAndApply<Self::Ty, Self::Tys>, {
         CollectAndApply::collect_and_apply(args, |g| Tys::new_from_iter(self, g.iter().cloned()))
     }
 
-    fn parent(self, def_id: Self::DefId) -> Self::DefId {
+    fn parent(
+        self,
+        def_id: Self::DefId,
+    ) -> Self::DefId {
         use hir_def::Lookup;
-
         let container = match def_id {
             SolverDefId::FunctionId(it) => it.lookup(self.db()).container,
             SolverDefId::TypeAliasId(it) => it.lookup(self.db()).container,
             | SolverDefId::Ctor(..)
             | SolverDefId::InternedOpaqueTyId(..) => panic!(),
         };
-
         match container {
             ItemContainerId::ImplId(it) => it.into(),
             ItemContainerId::TraitId(it) => it.into(),
         self.db().callable_item_signature(def_id.0)
     }
 
-    fn coroutine_movability(self, def_id: Self::CoroutineId) -> rustc_ast_ir::Movability {
+    fn coroutine_movability(
+        self,
+        def_id: Self::CoroutineId,
+    ) -> rustc_ast_ir::Movability {
         // FIXME: Make this a query? I don't believe this can be accessed from bodies other than
         // the current infer query, except with revealed opaques - is it rare enough to not matter?
         let InternedCoroutine(owner, expr_id) = def_id.0.loc(self.db);
         }
     }
 
-    fn coroutine_for_closure(self, def_id: Self::CoroutineClosureId) -> Self::CoroutineId {
+    fn coroutine_for_closure(
+        self,
+        def_id: Self::CoroutineClosureId,
+    ) -> Self::CoroutineId {
         def_id
     }
 
-    fn generics_require_sized_self(self, def_id: Self::DefId) -> bool {
+    fn generics_require_sized_self(
+        self,
+        def_id: Self::DefId,
+    ) -> bool {
         let sized_trait =
             LangItem::Sized.resolve_trait(self.db(), self.krate.expect("Must have self.krate"));
         let Some(sized_id) = sized_trait else {
             return false; /* No Sized trait, can't require it! */
         };
         let sized_def_id = sized_id.into();
-
         // Search for a predicate like `Self : Sized` amongst the trait bounds.
         let predicates = self.predicates_of(def_id);
         elaborate(self, predicates.iter_identity()).any(|pred| match pred.kind().skip_binder() {
         explicit_item_bounds(self, def_id).map_bound(|bounds| {
             Clauses::new_from_iter(
                 self,
-                elaborate(self, bounds)
-                    .filter_only_self()
-                    .collect::<Vec<_>>(),
+                elaborate(self, bounds).filter_only_self().collect::<Vec<_>>(),
             )
         })
     }
         def_id: Self::DefId,
     ) -> EarlyBinder<Self, impl IntoIterator<Item = Self::Clause>> {
         let all_bounds: FxHashSet<_> = self.item_bounds(def_id).skip_binder().into_iter().collect();
-        let own_bounds: FxHashSet<_> = self
-            .item_self_bounds(def_id)
-            .skip_binder()
-            .into_iter()
-            .collect();
+        let own_bounds: FxHashSet<_> =
+            self.item_self_bounds(def_id).skip_binder().into_iter().collect();
         if all_bounds.len() == own_bounds.len() {
             EarlyBinder::bind(Clauses::new_from_iter(self, []))
         } else {
         self,
         def_id: Self::DefId,
     ) -> EarlyBinder<Self, impl IntoIterator<Item = Self::Clause>> {
-        let predicates = self
-            .db()
-            .generic_predicates_without_parent(def_id.try_into().unwrap());
+        let predicates = self.db().generic_predicates_without_parent(def_id.try_into().unwrap());
         let predicates: Vec<_> = predicates.iter().cloned().collect();
         EarlyBinder::bind(predicates.into_iter())
     }
             rustc_type_ir::TyKind::Param(param) => param.index == 0,
             _ => false,
         };
-
         let predicates: Vec<(Clause<'db>, Span)> = self
             .db()
             .generic_predicates(def_id.0.into())
                 _ => false,
             }
         }
-
         let predicates: Vec<(Clause<'db>, Span)> = self
             .db()
             .generic_predicates(def_id.try_into().unwrap())
         self,
         impl_id: Self::ImplId,
     ) -> EarlyBinder<Self, impl IntoIterator<Item = Self::Clause>> {
-        let trait_ref = self
-            .db()
-            .impl_trait(impl_id.0)
-            .expect("expected an impl of trait");
+        let trait_ref = self.db().impl_trait(impl_id.0).expect("expected an impl of trait");
         trait_ref.map_bound(|trait_ref| {
             let clause: Clause<'_> = trait_ref.upcast(self);
             Clauses::new_from_iter(
         EarlyBinder::bind([unimplemented!()])
     }
 
-    fn has_target_features(self, _def_id: Self::FunctionId) -> bool {
+    fn has_target_features(
+        self,
+        _def_id: Self::FunctionId,
+    ) -> bool {
         false
     }
 
-    fn require_lang_item(self, lang_item: SolverLangItem) -> Self::DefId {
+    fn require_lang_item(
+        self,
+        lang_item: SolverLangItem,
+    ) -> Self::DefId {
         let lang_item = match lang_item {
             SolverLangItem::AsyncFnKindUpvars => unimplemented!(),
             SolverLangItem::AsyncFnOnceOutput => LangItem::AsyncFnOnceOutput,
         }
     }
 
-    fn require_trait_lang_item(self, lang_item: SolverTraitLangItem) -> TraitIdWrapper {
+    fn require_trait_lang_item(
+        self,
+        lang_item: SolverTraitLangItem,
+    ) -> TraitIdWrapper {
         let lang_item = match lang_item {
             SolverTraitLangItem::AsyncFn => LangItem::AsyncFn,
             SolverTraitLangItem::AsyncFnKindHelper => unimplemented!(),
             .into()
     }
 
-    fn require_adt_lang_item(self, lang_item: SolverAdtLangItem) -> AdtIdWrapper {
+    fn require_adt_lang_item(
+        self,
+        lang_item: SolverAdtLangItem,
+    ) -> AdtIdWrapper {
         let lang_item = match lang_item {
             SolverAdtLangItem::Option => LangItem::Option,
             SolverAdtLangItem::Poll => LangItem::Poll,
             .into()
     }
 
-    fn is_lang_item(self, def_id: Self::DefId, lang_item: SolverLangItem) -> bool {
-        self.as_lang_item(def_id).map_or(false, |l| {
-            std::mem::discriminant(&l) == std::mem::discriminant(&lang_item)
-        })
+    fn is_lang_item(
+        self,
+        def_id: Self::DefId,
+        lang_item: SolverLangItem,
+    ) -> bool {
+        self.as_lang_item(def_id)
+            .map_or(false, |l| std::mem::discriminant(&l) == std::mem::discriminant(&lang_item))
     }
 
-    fn is_trait_lang_item(self, def_id: Self::TraitId, lang_item: SolverTraitLangItem) -> bool {
-        self.as_trait_lang_item(def_id).map_or(false, |l| {
-            std::mem::discriminant(&l) == std::mem::discriminant(&lang_item)
-        })
+    fn is_trait_lang_item(
+        self,
+        def_id: Self::TraitId,
+        lang_item: SolverTraitLangItem,
+    ) -> bool {
+        self.as_trait_lang_item(def_id)
+            .map_or(false, |l| std::mem::discriminant(&l) == std::mem::discriminant(&lang_item))
     }
 
-    fn is_adt_lang_item(self, def_id: Self::AdtId, lang_item: SolverAdtLangItem) -> bool {
+    fn is_adt_lang_item(
+        self,
+        def_id: Self::AdtId,
+        lang_item: SolverAdtLangItem,
+    ) -> bool {
         // FIXME: derive PartialEq on SolverTraitLangItem
-        self.as_adt_lang_item(def_id).map_or(false, |l| {
-            std::mem::discriminant(&l) == std::mem::discriminant(&lang_item)
-        })
+        self.as_adt_lang_item(def_id)
+            .map_or(false, |l| std::mem::discriminant(&l) == std::mem::discriminant(&lang_item))
     }
 
-    fn as_lang_item(self, def_id: Self::DefId) -> Option<SolverLangItem> {
+    fn as_lang_item(
+        self,
+        def_id: Self::DefId,
+    ) -> Option<SolverLangItem> {
         let def_id: AttrDefId = match def_id {
             SolverDefId::TraitId(id) => id.into(),
             SolverDefId::TypeAliasId(id) => id.into(),
         )
     }
 
-    fn as_trait_lang_item(self, def_id: Self::TraitId) -> Option<SolverTraitLangItem> {
+    fn as_trait_lang_item(
+        self,
+        def_id: Self::TraitId,
+    ) -> Option<SolverTraitLangItem> {
         let def_id: AttrDefId = def_id.0.into();
         let lang_item = self.db().lang_attr(def_id)?;
         as_lang_item!(
         )
     }
 
-    fn as_adt_lang_item(self, def_id: Self::AdtId) -> Option<SolverAdtLangItem> {
+    fn as_adt_lang_item(
+        self,
+        def_id: Self::AdtId,
+    ) -> Option<SolverAdtLangItem> {
         let def_id: AttrDefId = def_id.0.into();
         let lang_item = self.db().lang_attr(def_id)?;
         as_lang_item!(
         )
     }
 
-    fn associated_type_def_ids(self, def_id: Self::DefId) -> impl IntoIterator<Item = Self::DefId> {
+    fn associated_type_def_ids(
+        self,
+        def_id: Self::DefId,
+    ) -> impl IntoIterator<Item = Self::DefId> {
         let trait_ = match def_id {
             SolverDefId::TraitId(id) => id,
             _ => unreachable!(),
         };
-        trait_
-            .trait_items(self.db())
-            .associated_types()
-            .map(|id| id.into())
+        trait_.trait_items(self.db()).associated_types().map(|id| id.into())
     }
 
     fn for_each_relevant_impl(
             TyKind::Infer(InferTy::FloatVar(..)) => &ALL_FLOAT_FPS,
             _ => self_ty_fp.as_slice(),
         };
-
         if fps.is_empty() {
             _ = for_trait_impls(
                 self.db(),
                     for i in impls.for_trait(trait_) {
                         use rustc_type_ir::TypeVisitable;
                         let contains_errors = self.db().impl_trait(i).map_or(false, |b| {
-                            b.skip_binder()
-                                .visit_with(&mut ContainsTypeErrors)
-                                .is_break()
+                            b.skip_binder().visit_with(&mut ContainsTypeErrors).is_break()
                         });
                         if contains_errors {
                             continue;
                         for i in impls.for_trait_and_self_ty(trait_, *fp) {
                             use rustc_type_ir::TypeVisitable;
                             let contains_errors = self.db().impl_trait(i).map_or(false, |b| {
-                                b.skip_binder()
-                                    .visit_with(&mut ContainsTypeErrors)
-                                    .is_break()
+                                b.skip_binder().visit_with(&mut ContainsTypeErrors).is_break()
                             });
                             if contains_errors {
                                 continue;
         }
     }
 
-    fn for_each_blanket_impl(self, trait_def_id: Self::TraitId, mut f: impl FnMut(Self::ImplId)) {
+    fn for_each_blanket_impl(
+        self,
+        trait_def_id: Self::TraitId,
+        mut f: impl FnMut(Self::ImplId),
+    ) {
         let Some(krate) = self.krate else { return };
-
         for impls in self.db.trait_impls_in_deps(krate).iter() {
             for impl_id in impls.for_trait(trait_def_id.0) {
                 let impl_data = self.db.impl_signature(impl_id);
         }
     }
 
-    fn has_item_definition(self, _def_id: Self::DefId) -> bool {
+    fn has_item_definition(
+        self,
+        _def_id: Self::DefId,
+    ) -> bool {
         // FIXME(next-solver): should check if the associated item has a value.
         true
     }
 
-    fn impl_is_default(self, impl_def_id: Self::ImplId) -> bool {
+    fn impl_is_default(
+        self,
+        impl_def_id: Self::ImplId,
+    ) -> bool {
         self.db.impl_signature(impl_def_id.0).is_default()
     }
 
             .expect("invalid impl passed to trait solver")
     }
 
-    fn impl_polarity(self, impl_id: Self::ImplId) -> rustc_type_ir::ImplPolarity {
+    fn impl_polarity(
+        self,
+        impl_id: Self::ImplId,
+    ) -> rustc_type_ir::ImplPolarity {
         let impl_data = self.db().impl_signature(impl_id.0);
         if impl_data.flags.contains(ImplFlags::NEGATIVE) {
             ImplPolarity::Negative
         }
     }
 
-    fn trait_is_auto(self, trait_: Self::TraitId) -> bool {
+    fn trait_is_auto(
+        self,
+        trait_: Self::TraitId,
+    ) -> bool {
         let trait_data = self.db().trait_signature(trait_.0);
         trait_data.flags.contains(TraitFlags::AUTO)
     }
 
-    fn trait_is_alias(self, trait_: Self::TraitId) -> bool {
+    fn trait_is_alias(
+        self,
+        trait_: Self::TraitId,
+    ) -> bool {
         let trait_data = self.db().trait_signature(trait_.0);
         trait_data.flags.contains(TraitFlags::ALIAS)
     }
 
-    fn trait_is_dyn_compatible(self, trait_: Self::TraitId) -> bool {
+    fn trait_is_dyn_compatible(
+        self,
+        trait_: Self::TraitId,
+    ) -> bool {
         crate::dyn_compatibility::dyn_compatibility(self.db(), trait_.0).is_none()
     }
 
-    fn trait_is_fundamental(self, trait_: Self::TraitId) -> bool {
+    fn trait_is_fundamental(
+        self,
+        trait_: Self::TraitId,
+    ) -> bool {
         let trait_data = self.db().trait_signature(trait_.0);
         trait_data.flags.contains(TraitFlags::FUNDAMENTAL)
     }
 
-    fn trait_may_be_implemented_via_object(self, _trait_def_id: Self::TraitId) -> bool {
+    fn trait_may_be_implemented_via_object(
+        self,
+        _trait_def_id: Self::TraitId,
+    ) -> bool {
         // FIXME(next-solver): should check the `TraitFlags` for
         // the `#[rustc_do_not_implement_via_object]` flag
         true
     }
 
-    fn is_impl_trait_in_trait(self, _def_id: Self::DefId) -> bool {
+    fn is_impl_trait_in_trait(
+        self,
+        _def_id: Self::DefId,
+    ) -> bool {
         // FIXME(next-solver)
         false
     }
 
-    fn delay_bug(self, msg: impl ToString) -> Self::ErrorGuaranteed {
+    fn delay_bug(
+        self,
+        msg: impl ToString,
+    ) -> Self::ErrorGuaranteed {
         panic!("Bug encountered in next-trait-solver: {}", msg.to_string())
     }
 
-    fn is_general_coroutine(self, def_id: Self::CoroutineId) -> bool {
+    fn is_general_coroutine(
+        self,
+        def_id: Self::CoroutineId,
+    ) -> bool {
         // FIXME: Make this a query? I don't believe this can be accessed from bodies other than
         // the current infer query, except with revealed opaques - is it rare enough to not matter?
         let InternedCoroutine(owner, expr_id) = def_id.0.loc(self.db);
         )
     }
 
-    fn coroutine_is_async(self, def_id: Self::CoroutineId) -> bool {
+    fn coroutine_is_async(
+        self,
+        def_id: Self::CoroutineId,
+    ) -> bool {
         // FIXME: Make this a query? I don't believe this can be accessed from bodies other than
         // the current infer query, except with revealed opaques - is it rare enough to not matter?
         let InternedCoroutine(owner, expr_id) = def_id.0.loc(self.db);
         let body = self.db.body(owner);
         matches!(
             body[expr_id],
-            hir_def::hir::Expr::Closure {
-                closure_kind: hir_def::hir::ClosureKind::Async,
-                ..
-            } | hir_def::hir::Expr::Async { .. }
+            hir_def::hir::Expr::Closure { closure_kind: hir_def::hir::ClosureKind::Async, .. }
+                | hir_def::hir::Expr::Async { .. }
         )
     }
 
-    fn coroutine_is_gen(self, _coroutine_def_id: Self::CoroutineId) -> bool {
+    fn coroutine_is_gen(
+        self,
+        _coroutine_def_id: Self::CoroutineId,
+    ) -> bool {
         // We don't handle gen coroutines yet.
         false
     }
 
-    fn coroutine_is_async_gen(self, _coroutine_def_id: Self::CoroutineId) -> bool {
+    fn coroutine_is_async_gen(
+        self,
+        _coroutine_def_id: Self::CoroutineId,
+    ) -> bool {
         // We don't handle gen coroutines yet.
         false
     }
 
-    fn unsizing_params_for_adt(self, id: Self::AdtId) -> Self::UnsizingParams {
+    fn unsizing_params_for_adt(
+        self,
+        id: Self::AdtId,
+    ) -> Self::UnsizingParams {
         let def = AdtDef::new(id.0, self);
         let num_params = self.generics_of(id.into()).count();
-
         let maybe_unsizing_param_idx = |arg: GenericArg<'db>| match arg.kind() {
             GenericArgKind::Type(ty) => match ty.kind() {
                 rustc_type_ir::TyKind::Param(p) => Some(p.index),
                 _ => None,
             },
         };
-
         // The last field of the structure has to exist and contain type/const parameters.
         let variant = def.non_enum_variant();
         let fields = variant.fields(self.db());
         let Some((tail_field, prefix_fields)) = fields.split_last() else {
             return UnsizingParams(DenseBitSet::new_empty(num_params));
         };
-
         let field_types = self.db().field_types(variant.id());
         let mut unsizing_params = DenseBitSet::new_empty(num_params);
         let ty = field_types[tail_field.0];
                 unsizing_params.insert(i);
             }
         }
-
         // Ensure none of the other fields mention the parameters used
         // in unsizing.
         for field in prefix_fields {
                 }
             }
         }
-
         UnsizingParams(unsizing_params)
     }
 
                 Const::new_bound(self.interner, DebruijnIndex::ZERO, BoundConst { var })
             }
         }
-
         let mut map = Default::default();
-        let delegate = Anonymize {
-            interner: self,
-            map: &mut map,
-        };
+        let delegate = Anonymize { interner: self, map: &mut map };
         let inner = self.replace_escaping_bound_vars_uncached(value.skip_binder(), delegate);
         let bound_vars = CollectAndApply::collect_and_apply(map.into_values(), |xs| {
             BoundVarKinds::new_from_iter(self, xs.iter().cloned())
         Binder::bind_with_vars(inner, bound_vars)
     }
 
-    fn opaque_types_defined_by(self, def_id: Self::LocalDefId) -> Self::LocalDefIds {
+    fn opaque_types_defined_by(
+        self,
+        def_id: Self::LocalDefId,
+    ) -> Self::LocalDefIds {
         let Ok(def_id) = DefWithBodyId::try_from(def_id) else {
             return SolverDefIds::default();
         };
         SolverDefIds::new_from_iter(self, result)
     }
 
-    fn opaque_types_and_coroutines_defined_by(self, def_id: Self::LocalDefId) -> Self::LocalDefIds {
+    fn opaque_types_and_coroutines_defined_by(
+        self,
+        def_id: Self::LocalDefId,
+    ) -> Self::LocalDefIds {
         let Ok(def_id) = DefWithBodyId::try_from(def_id) else {
             return SolverDefIds::default();
         };
         let mut result = Vec::new();
-
         crate::opaques::opaque_types_defined_by(self.db, def_id, &mut result);
-
         // Collect coroutines.
         let body = self.db.body(def_id);
         body.exprs().for_each(|(expr_id, expr)| {
                 result.push(coroutine.into());
             }
         });
-
         SolverDefIds::new_from_iter(self, result)
     }
 
-    fn alias_has_const_conditions(self, _def_id: Self::DefId) -> bool {
+    fn alias_has_const_conditions(
+        self,
+        _def_id: Self::DefId,
+    ) -> bool {
         // FIXME(next-solver)
         false
     }
         EarlyBinder::bind([])
     }
 
-    fn fn_is_const(self, id: Self::FunctionId) -> bool {
+    fn fn_is_const(
+        self,
+        id: Self::FunctionId,
+    ) -> bool {
         let id = match id.0 {
             CallableDefId::FunctionId(id) => id,
             _ => return false,
         };
-        self.db()
-            .function_signature(id)
-            .flags
-            .contains(FnFlags::CONST)
+        self.db().function_signature(id).flags.contains(FnFlags::CONST)
     }
 
-    fn impl_is_const(self, _def_id: Self::ImplId) -> bool {
+    fn impl_is_const(
+        self,
+        _def_id: Self::ImplId,
+    ) -> bool {
         false
     }
 
         None
     }
 
-    fn type_of_opaque_hir_typeck(self, def_id: Self::LocalDefId) -> EarlyBinder<Self, Self::Ty> {
+    fn type_of_opaque_hir_typeck(
+        self,
+        def_id: Self::LocalDefId,
+    ) -> EarlyBinder<Self, Self::Ty> {
         match def_id {
             SolverDefId::InternedOpaqueTyId(opaque) => {
                 let impl_trait_id = self.db().lookup_intern_impl_trait_id(opaque);
         }))
     }
 
-    fn is_default_trait(self, def_id: Self::TraitId) -> bool {
-        self.as_trait_lang_item(def_id)
-            .map_or(false, |l| matches!(l, SolverTraitLangItem::Sized))
+    fn is_default_trait(
+        self,
+        def_id: Self::TraitId,
+    ) -> bool {
+        self.as_trait_lang_item(def_id).map_or(false, |l| matches!(l, SolverTraitLangItem::Sized))
     }
 
-    fn trait_is_coinductive(self, trait_: Self::TraitId) -> bool {
-        self.db()
-            .trait_signature(trait_.0)
-            .flags
-            .contains(TraitFlags::COINDUCTIVE)
+    fn trait_is_coinductive(
+        self,
+        trait_: Self::TraitId,
+    ) -> bool {
+        self.db().trait_signature(trait_.0).flags.contains(TraitFlags::COINDUCTIVE)
     }
 
-    fn trait_is_unsafe(self, trait_: Self::TraitId) -> bool {
-        self.db()
-            .trait_signature(trait_.0)
-            .flags
-            .contains(TraitFlags::UNSAFE)
+    fn trait_is_unsafe(
+        self,
+        trait_: Self::TraitId,
+    ) -> bool {
+        self.db().trait_signature(trait_.0).flags.contains(TraitFlags::UNSAFE)
     }
 
-    fn impl_self_is_guaranteed_unsized(self, _def_id: Self::ImplId) -> bool {
+    fn impl_self_is_guaranteed_unsized(
+        self,
+        _def_id: Self::ImplId,
+    ) -> bool {
         false
     }
 
     }
 
     type Probe = rustc_type_ir::solve::inspect::Probe<DbInterner<'db>>;
-    fn mk_probe(self, probe: rustc_type_ir::solve::inspect::Probe<Self>) -> Self::Probe {
+
+    fn mk_probe(
+        self,
+        probe: rustc_type_ir::solve::inspect::Probe<Self>,
+    ) -> Self::Probe {
         probe
     }
+
     fn evaluate_root_goal_for_proof_tree_raw(
         self,
         canonical_goal: rustc_type_ir::solve::CanonicalInput<Self>,
         >(self, canonical_goal)
     }
 
-    fn is_sizedness_trait(self, def_id: Self::TraitId) -> bool {
+    fn is_sizedness_trait(
+        self,
+        def_id: Self::TraitId,
+    ) -> bool {
         matches!(
             self.as_trait_lang_item(def_id),
             Some(SolverTraitLangItem::Sized | SolverTraitLangItem::MetaSized)
 }
 
 impl<'db> DbInterner<'db> {
-    pub fn shift_bound_var_indices<T>(self, bound_vars: usize, value: T) -> T
+    pub fn shift_bound_var_indices<T>(
+        self,
+        bound_vars: usize,
+        value: T,
+    ) -> T
     where
-        T: rustc_type_ir::TypeFoldable<Self>,
-    {
+        T: rustc_type_ir::TypeFoldable<Self>, {
         let shift_bv = |bv: BoundVar| BoundVar::from_usize(bv.as_usize() + bound_vars);
         self.replace_escaping_bound_vars_uncached(
             value,
                     Region::new_bound(
                         self,
                         DebruijnIndex::ZERO,
-                        BoundRegion {
-                            var: shift_bv(r.var),
-                            kind: r.kind,
-                        },
+                        BoundRegion { var: shift_bv(r.var), kind: r.kind },
                     )
                 },
                 types: &mut |t: BoundTy| {
                     Ty::new_bound(
                         self,
                         DebruijnIndex::ZERO,
-                        BoundTy {
-                            var: shift_bv(t.var),
-                            kind: t.kind,
-                        },
+                        BoundTy { var: shift_bv(t.var), kind: t.kind },
                     )
                 },
                 consts: &mut |c| {
-                    Const::new_bound(
-                        self,
-                        DebruijnIndex::ZERO,
-                        BoundConst {
-                            var: shift_bv(c.var),
-                        },
-                    )
+                    Const::new_bound(self, DebruijnIndex::ZERO, BoundConst { var: shift_bv(c.var) })
                 },
             },
         )
         abi: FnAbi,
     ) -> FnSig<'db>
     where
-        I: IntoIterator<Item = Ty<'db>>,
-    {
+        I: IntoIterator<Item = Ty<'db>>, {
         FnSig {
             inputs_and_output: Tys::new_from_iter(
                 self,
         )+
     };
 }
-
-TrivialTypeTraversalImpls! {
-    SolverDefId,
-    TraitIdWrapper,
-    TypeAliasIdWrapper,
-    CallableIdWrapper,
-    ClosureIdWrapper,
-    CoroutineIdWrapper,
-    AdtIdWrapper,
-    ImplIdWrapper,
-    Pattern<'db>,
-    Safety,
-    FnAbi,
-    Span,
-    ParamConst,
-    ParamTy,
-    BoundRegion,
-    BoundVar,
-    Placeholder<BoundRegion>,
-    Placeholder<BoundTy>,
-    Placeholder<BoundVar>,
-}
-
 mod tls_db {
     use std::{cell::Cell, ptr::NonNull};
-
     use crate::db::HirDatabase;
-
     struct Attached {
         database: Cell<Option<NonNull<dyn HirDatabase>>>,
     }
-
     impl Attached {
         #[inline]
-        fn attach<R>(&self, db: &dyn HirDatabase, op: impl FnOnce() -> R) -> R {
+        fn attach<R>(
+            &self,
+            db: &dyn HirDatabase,
+            op: impl FnOnce() -> R,
+        ) -> R {
             struct DbGuard<'s> {
                 state: Option<&'s Attached>,
             }
-
             impl<'s> DbGuard<'s> {
                 #[inline]
                 fn new(attached: &'s Attached, db: &dyn HirDatabase) -> Self {
                         None => {
                             // Otherwise, set the database.
                             attached.database.set(Some(NonNull::from(db)));
-                            Self {
-                                state: Some(attached),
-                            }
+                            Self { state: Some(attached) }
                         }
                     }
                 }
             }
-
             impl Drop for DbGuard<'_> {
                 #[inline]
                 fn drop(&mut self) {
                     }
                 }
             }
-
             let _guard = DbGuard::new(self, db);
             op()
         }
 
         #[inline]
-        fn attach_allow_change<R>(&self, db: &dyn HirDatabase, op: impl FnOnce() -> R) -> R {
+        fn attach_allow_change<R>(
+            &self,
+            db: &dyn HirDatabase,
+            op: impl FnOnce() -> R,
+        ) -> R {
             struct DbGuard<'s> {
                 state: &'s Attached,
                 prev: Option<NonNull<dyn HirDatabase>>,
             }
-
             impl<'s> DbGuard<'s> {
                 #[inline]
                 fn new(attached: &'s Attached, db: &dyn HirDatabase) -> Self {
                     let prev = attached.database.replace(Some(NonNull::from(db)));
-                    Self {
-                        state: attached,
-                        prev,
-                    }
+                    Self { state: attached, prev }
                 }
             }
-
             impl Drop for DbGuard<'_> {
                 #[inline]
                 fn drop(&mut self) {
                     self.state.database.set(self.prev);
                 }
             }
-
             let _guard = DbGuard::new(self, db);
             op()
         }
 
         #[inline]
-        fn with<R>(&self, op: impl FnOnce(&dyn HirDatabase) -> R) -> R {
-            let db = self
-                .database
-                .get()
-                .expect("Try to use attached db, but not db is attached");
-
+        fn with<R>(
+            &self,
+            op: impl FnOnce(&dyn HirDatabase) -> R,
+        ) -> R {
+            let db = self.database.get().expect("Try to use attached db, but not db is attached");
             // SAFETY: The db is attached, so it must be valid.
             op(unsafe { db.as_ref() })
         }
     }
-
-    thread_local! {
-        static GLOBAL_DB: Attached = const { Attached { database: Cell::new(None) } };
-    }
-
     #[inline]
-    pub fn attach_db<R>(db: &dyn HirDatabase, op: impl FnOnce() -> R) -> R {
+    pub fn attach_db<R>(
+        db: &dyn HirDatabase,
+        op: impl FnOnce() -> R,
+    ) -> R {
         GLOBAL_DB.with(|global_db| global_db.attach(db, op))
     }
-
     #[inline]
-    pub fn attach_db_allow_change<R>(db: &dyn HirDatabase, op: impl FnOnce() -> R) -> R {
+    pub fn attach_db_allow_change<R>(
+        db: &dyn HirDatabase,
+        op: impl FnOnce() -> R,
+    ) -> R {
         GLOBAL_DB.with(|global_db| global_db.attach_allow_change(db, op))
     }
-
     #[inline]
     pub fn with_attached_db<R>(op: impl FnOnce(&dyn HirDatabase) -> R) -> R {
         GLOBAL_DB.with(
 
 mod tls_cache {
     use crate::db::HirDatabase;
-
     use super::DbInterner;
     use base_db::Nonce;
     use rustc_type_ir::search_graph::GlobalCache;
     use salsa::Revision;
     use std::cell::RefCell;
-
     struct Cache {
         cache: GlobalCache<DbInterner<'static>>,
         revision: Revision,
         db_nonce: Nonce,
     }
-
-    thread_local! {
-        static GLOBAL_CACHE: RefCell<Option<Cache>> = const { RefCell::new(None) };
-    }
-
     pub(super) fn with_cache<'db, T>(
         db: &'db dyn HirDatabase,
         f: impl FnOnce(&mut GlobalCache<DbInterner<'db>>) -> T,
             let handle = match handle {
                 Some(handle) => {
                     if handle.revision != revision || db_nonce != handle.db_nonce {
-                        *handle = Cache {
-                            cache: GlobalCache::default(),
-                            revision,
-                            db_nonce,
-                        };
+                        *handle = Cache { cache: GlobalCache::default(), revision, db_nonce };
                     }
                     handle
                 }
-                None => handle.insert(Cache {
-                    cache: GlobalCache::default(),
-                    revision,
-                    db_nonce,
-                }),
+                None => handle.insert(Cache { cache: GlobalCache::default(), revision, db_nonce }),
             };
 
             // SAFETY: No idea
             })
         })
     }
-
     /// Clears the thread-local trait solver cache.
     ///
     /// Should be called before getting memory usage estimations, as the solver cache