COMPARISON DIFF
============================================================

Original size: 18777 bytes
Chloro size:   18291 bytes
Rustfmt size:  18816 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use std::{iter::once, mem};
 
 use hir::Semantics;
 use ide_db::syntax_helpers::tree_diff::diff;
 use ide_db::text_edit::{TextEdit, TextEditBuilder};
-use ide_db::{helpers::pick_best_token, FileRange, RootDatabase};
+use ide_db::{FileRange, RootDatabase, helpers::pick_best_token};
 use itertools::Itertools;
-use syntax::{ast, match_ast, AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange};
+use syntax::{AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, ast, match_ast};
 
 #[derive(Copy, Clone, Debug)]
 pub enum Direction {
     Down,
 }
 
-// Feature: Move Item
-//
-// Move item under cursor or selection up and down.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Move item up**
-// | VS Code | **rust-analyzer: Move item down**
-//
-// ![Move Item](https://user-images.githubusercontent.com/48062697/113065576-04298180-91b1-11eb-91ce-4505e99ed598.gif)
-pub(crate) fn move_item(
-    db: &RootDatabase,
-    range: FileRange,
-    direction: Direction,
-) -> Option<TextEdit> {
+pub(crate) fn move_item(db: &RootDatabase, range: FileRange, direction: Direction) -> Option<TextEdit> {
     let sema = Semantics::new(db);
     let file = sema.parse_guess_edition(range.file_id);
-
     let item = if range.range.is_empty() {
         SyntaxElement::Token(pick_best_token(
             file.syntax().token_at_offset(range.range.start()),
     } else {
         file.syntax().covering_element(range.range)
     };
-
     find_ancestors(item, direction, range.range)
 }
 
         SyntaxElement::Node(node) => node,
         SyntaxElement::Token(token) => token.parent()?,
     };
-
     let movable = [
         SyntaxKind::ARG_LIST,
         SyntaxKind::GENERIC_PARAM_LIST,
         SyntaxKind::MACRO_RULES,
         SyntaxKind::MACRO_DEF,
     ];
-
     let ancestor = once(root.clone())
         .chain(root.ancestors())
         .find(|ancestor| movable.contains(&ancestor.kind()))?;
-
     move_in_direction(&ancestor, direction, range)
 }
 
-fn move_in_direction(
-    node: &SyntaxNode,
-    direction: Direction,
-    range: TextRange,
-) -> Option<TextEdit> {
+fn move_in_direction(node: &SyntaxNode, direction: Direction, range: TextRange) -> Option<TextEdit> {
     match_ast! {
         match node {
             ast::ArgList(it) => swap_sibling_in_list(node, it.args(), range, direction),
     }
 }
 
-fn swap_sibling_in_list<A: AstNode + Clone, I: Iterator<Item = A>>(
-    node: &SyntaxNode,
-    list: I,
-    range: TextRange,
-    direction: Direction,
-) -> Option<TextEdit> {
+fn swap_sibling_in_list<A: AstNode + Clone, I: Iterator<Item = A>>(node: &SyntaxNode, list: I, range: TextRange, direction: Direction) -> Option<TextEdit> {
     let list_lookup = list.tuple_windows().find(|(l, r)| match direction {
         Direction::Up => r.syntax().text_range().contains_range(range),
         Direction::Down => l.syntax().text_range().contains_range(range),
     });
-
     if let Some((l, r)) = list_lookup {
         Some(replace_nodes(range, l.syntax(), r.syntax()))
     } else {
     }
 }
 
-fn replace_nodes<'a>(
-    range: TextRange,
-    mut first: &'a SyntaxNode,
-    mut second: &'a SyntaxNode,
-) -> TextEdit {
+fn replace_nodes<'a>(range: TextRange, mut first: &'a SyntaxNode, mut second: &'a SyntaxNode) -> TextEdit {
     let cursor_offset = if range.is_empty() {
         // FIXME: `applySnippetTextEdits` does not support non-empty selection ranges
         if first.text_range().contains_range(range) {
     } else {
         None
     };
-
     let first_with_cursor = match cursor_offset {
         Some(offset) => {
             let mut item_text = first.text().to_string();
         }
         None => first.text().to_string(),
     };
-
     let mut edit = TextEditBuilder::default();
-
     diff(first, second).into_text_edit(&mut edit);
     edit.replace(second.text_range(), first_with_cursor);
-
     edit.finish()
 }
 
 #[cfg(test)]
 mod tests {
     use crate::fixture;
-    use expect_test::{expect, Expect};
-
+    use expect_test::{Expect, expect};
     use crate::Direction;
-
-    fn check(
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        expect: Expect,
-        direction: Direction,
-    ) {
+    fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect, direction: Direction) {
         let (analysis, range) = fixture::range(ra_fixture);
-        let edit = analysis
-            .move_item(range, direction)
-            .unwrap()
-            .unwrap_or_default();
+        let edit = analysis.move_item(range, direction).unwrap().unwrap_or_default();
         let mut file = analysis.file_text(range.file_id).unwrap().to_string();
         edit.apply(&mut file);
         expect.assert_eq(&file);
     }
-
     #[test]
     fn test_moves_match_arm_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_match_arm_down() {
         check(
             Direction::Down,
         );
     }
-
     #[test]
     fn test_nowhere_to_move() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_let_stmt_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_expr_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_nowhere_to_move_stmt() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_move_item() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_move_impl_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_move_use_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_match_expr_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_param() {
         check(
             Direction::Down,
         );
     }
-
     #[test]
     fn test_moves_arg_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_arg_down() {
         check(
             Direction::Down,
         );
     }
-
     #[test]
     fn test_nowhere_to_move_arg() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_generic_param_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_generic_arg_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_variant_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_type_bound_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_prioritizes_trait_items() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_weird_nesting() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_cursor_at_item_start() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_cursor_at_item_end() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn handles_empty_file() {
         check(r#"$0$0"#, expect![[r#""#]], Direction::Up);