COMPARISON DIFF
============================================================

Original size: 13045 bytes
Chloro size:   11810 bytes
Rustfmt size:  13263 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use std::cmp::Ordering;
 
 use itertools::Itertools;
-
 use syntax::{
-    ast::{self, HasName},
     AstNode, SyntaxNode,
+    ast::{self, HasName},
 };
 
-use crate::{utils::get_methods, AssistContext, AssistId, Assists};
+use crate::{AssistContext, AssistId, Assists, utils::get_methods};
 
-// Assist: sort_items
-//
-// Sorts item members alphabetically: fields, enum variants and methods.
-//
-// ```
-// struct $0Foo$0 { second: u32, first: String }
-// ```
-// ->
-// ```
-// struct Foo { first: String, second: u32 }
-// ```
-// ---
-// ```
-// trait $0Bar$0 {
-//     fn second(&self) -> u32;
-//     fn first(&self) -> String;
-// }
-// ```
-// ->
-// ```
-// trait Bar {
-//     fn first(&self) -> String;
-//     fn second(&self) -> u32;
-// }
-// ```
-// ---
-// ```
-// struct Baz;
-// impl $0Baz$0 {
-//     fn second(&self) -> u32;
-//     fn first(&self) -> String;
-// }
-// ```
-// ->
-// ```
-// struct Baz;
-// impl Baz {
-//     fn first(&self) -> String;
-//     fn second(&self) -> u32;
-// }
-// ```
-// ---
-// There is a difference between sorting enum variants:
-//
-// ```
-// enum $0Animal$0 {
-//   Dog(String, f64),
-//   Cat { weight: f64, name: String },
-// }
-// ```
-// ->
-// ```
-// enum Animal {
-//   Cat { weight: f64, name: String },
-//   Dog(String, f64),
-// }
-// ```
-// and sorting a single enum struct variant:
-//
-// ```
-// enum Animal {
-//   Dog(String, f64),
-//   Cat $0{ weight: f64, name: String }$0,
-// }
-// ```
-// ->
-// ```
-// enum Animal {
-//   Dog(String, f64),
-//   Cat { name: String, weight: f64 },
-// }
-// ```
-pub(crate) fn sort_items(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn sort_items(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     if ctx.has_empty_selection() {
         cov_mark::hit!(not_applicable_if_no_selection);
         return None;
     }
-
     if let Some(struct_ast) = ctx.find_node_at_offset::<ast::Struct>() {
         add_sort_field_list_assist(acc, struct_ast.field_list())
     } else if let Some(union_ast) = ctx.find_node_at_offset::<ast::Union>() {
         new: Vec<T>,
         target: &SyntaxNode,
     ) -> Option<()> {
-        self.add(
-            AssistId::refactor_rewrite("sort_items"),
-            label,
-            target.text_range(),
-            |builder| {
-                let mut editor = builder.make_editor(target);
+        self.add(AssistId::refactor_rewrite("sort_items"), label, target.text_range(), |builder| {
+            let mut editor = builder.make_editor(target);
 
-                old.into_iter()
-                    .zip(new)
-                    .for_each(|(old, new)| editor.replace(old.syntax(), new.syntax()));
+            old.into_iter()
+                .zip(new)
+                .for_each(|(old, new)| editor.replace(old.syntax(), new.syntax()));
 
-                builder.add_file_edits(builder.file_id, editor)
-            },
-        )
+            builder.add_file_edits(builder.file_id, editor)
+        })
     }
 }
 
-fn add_sort_field_list_assist(acc: &mut Assists, field_list: Option<ast::FieldList>) -> Option<()> {
+fn add_sort_field_list_assist(
+    acc: &mut Assists,
+    field_list: Option<ast::FieldList>,
+) -> Option<()> {
     match field_list {
         Some(ast::FieldList::RecordFieldList(it)) => add_sort_fields_assist(acc, it),
         _ => {
     item_list: ast::AssocItemList,
 ) -> Option<()> {
     let selection = ctx.selection_trimmed();
-
     // ignore assist if the selection intersects with an associated item.
-    if item_list
-        .assoc_items()
-        .any(|item| item.syntax().text_range().intersect(selection).is_some())
+    if item_list.assoc_items().any(|item| item.syntax().text_range().intersect(selection).is_some())
     {
         return None;
     }
-
     let methods = get_methods(&item_list);
     let sorted = sort_by_name(&methods);
-
     if methods == sorted {
         cov_mark::hit!(not_applicable_if_sorted_or_empty_or_single);
         return None;
     }
-
-    acc.add_rewrite(
-        "Sort methods alphabetically",
-        methods,
-        sorted,
-        item_list.syntax(),
-    )
+    acc.add_rewrite("Sort methods alphabetically", methods, sorted, item_list.syntax())
 }
 
 fn add_sort_fields_assist(
 ) -> Option<()> {
     let fields: Vec<_> = record_field_list.fields().collect();
     let sorted = sort_by_name(&fields);
-
     if fields == sorted {
         cov_mark::hit!(not_applicable_if_sorted_or_empty_or_single);
         return None;
     }
-
-    acc.add_rewrite(
-        "Sort fields alphabetically",
-        fields,
-        sorted,
-        record_field_list.syntax(),
-    )
+    acc.add_rewrite("Sort fields alphabetically", fields, sorted, record_field_list.syntax())
 }
 
-fn add_sort_variants_assist(acc: &mut Assists, variant_list: ast::VariantList) -> Option<()> {
+fn add_sort_variants_assist(
+    acc: &mut Assists,
+    variant_list: ast::VariantList,
+) -> Option<()> {
     let variants: Vec<_> = variant_list.variants().collect();
     let sorted = sort_by_name(&variants);
-
     if variants == sorted {
         cov_mark::hit!(not_applicable_if_sorted_or_empty_or_single);
         return None;
     }
-
-    acc.add_rewrite(
-        "Sort variants alphabetically",
-        variants,
-        sorted,
-        variant_list.syntax(),
-    )
+    acc.add_rewrite("Sort variants alphabetically", variants, sorted, variant_list.syntax())
 }
 
 fn sort_by_name<T: HasName + Clone>(initial: &[T]) -> Vec<T> {
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn not_applicable_if_selection_in_fn_body() {
         check_assist_not_applicable(
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_selection_at_associated_const() {
         check_assist_not_applicable(
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_selection_overlaps_nodes() {
         check_assist_not_applicable(
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_no_selection() {
         cov_mark::check!(not_applicable_if_no_selection);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_selection_in_trait_fn_body() {
         check_assist_not_applicable(
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_trait_empty() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_impl_empty() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_struct_empty() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_struct_empty2() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_enum_empty() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_trait_sorted() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_impl_sorted() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_struct_sorted() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_union_sorted() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn not_applicable_if_enum_sorted() {
         cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);
-
         check_assist_not_applicable(
             sort_items,
             r#"
         "#,
         )
     }
-
     #[test]
     fn sort_trait() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_impl() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_struct() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_struct_inside_a_function() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_generic_struct_with_lifetime() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_struct_fields_diff_len() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_union() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_enum() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_struct_enum_variant_fields() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn sort_struct_enum_variant() {
         check_assist(