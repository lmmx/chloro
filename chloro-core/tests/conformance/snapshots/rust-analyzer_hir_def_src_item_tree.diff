COMPARISON DIFF
============================================================

Original size: 23100 bytes
Chloro size:   21786 bytes
Rustfmt size:  23685 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! In general, any item in the `ItemTree` stores its `AstId`, which allows mapping it back to its
 //! surface syntax.
 
-mod lower;
-mod pretty;
-#[cfg(test)]
-mod tests;
-
 use std::{
     fmt::{self, Debug},
     hash::Hash,
 use ast::{AstNode, StructKind};
 use base_db::Crate;
 use hir_expand::{
+    ExpandTo, HirFileId,
     attrs::RawAttrs,
     mod_path::{ModPath, PathKind},
     name::Name,
-    ExpandTo, HirFileId,
 };
 use intern::Interned;
 use la_arena::{Idx, RawIdx};
 use rustc_hash::FxHashMap;
 use span::{AstIdNode, Edition, FileAstId, SyntaxContext};
 use stdx::never;
-use syntax::{ast, match_ast, SyntaxKind};
+use syntax::{SyntaxKind, ast, match_ast};
 use thin_vec::ThinVec;
 use triomphe::Arc;
 
-use crate::{attr::Attrs, db::DefDatabase, BlockId, Lookup};
-
 pub(crate) use crate::item_tree::lower::{lower_use_tree, visibility_from_ast};
+use crate::{BlockId, Lookup, attr::Attrs, db::DefDatabase};
+
+mod lower;
+
+mod pretty;
+
+#[cfg(test)]
+mod tests;
 
 #[derive(Copy, Clone, Eq, PartialEq)]
 pub(crate) struct RawVisibilityId(u32);
 
 impl RawVisibilityId {
-    const PUB: Self = RawVisibilityId(u32::MAX);
-    const PRIV_IMPLICIT: Self = RawVisibilityId(u32::MAX - 1);
-    const PRIV_EXPLICIT: Self = RawVisibilityId(u32::MAX - 2);
-    const PUB_CRATE: Self = RawVisibilityId(u32::MAX - 3);
+
+
+
 }
 
 impl fmt::Debug for RawVisibilityId {
 pub(crate) fn file_item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {
     let _p = tracing::info_span!("file_item_tree_query", ?file_id).entered();
     static EMPTY: OnceLock<Arc<ItemTree>> = OnceLock::new();
-
     let ctx = lower::Ctx::new(db, file_id);
     let syntax = db.parse_or_expand(file_id);
     let mut item_tree = match_ast! {
             },
         }
     };
-    let ItemTree {
-        top_level,
-        top_attrs,
-        attrs,
-        vis,
-        big_data,
-        small_data,
-    } = &item_tree;
+    let ItemTree { top_level, top_attrs, attrs, vis, big_data, small_data } = &item_tree;
     if small_data.is_empty()
         && big_data.is_empty()
         && top_level.is_empty()
                     small_data: FxHashMap::default(),
                     big_data: FxHashMap::default(),
                     top_attrs: RawAttrs::EMPTY,
-                    vis: ItemVisibilities {
-                        arena: ThinVec::new(),
-                    },
+                    vis: ItemVisibilities { arena: ThinVec::new() },
                 })
             })
             .clone()
 pub(crate) fn block_item_tree_query(db: &dyn DefDatabase, block: BlockId) -> Arc<ItemTree> {
     let _p = tracing::info_span!("block_item_tree_query", ?block).entered();
     static EMPTY: OnceLock<Arc<ItemTree>> = OnceLock::new();
-
     let loc = block.lookup(db);
     let block = loc.ast_id.to_node(db);
-
     let ctx = lower::Ctx::new(db, loc.ast_id.file_id);
     let mut item_tree = ctx.lower_block(&block);
-    let ItemTree {
-        top_level,
-        top_attrs,
-        attrs,
-        vis,
-        big_data,
-        small_data,
-    } = &item_tree;
+    let ItemTree { top_level, top_attrs, attrs, vis, big_data, small_data } = &item_tree;
     if small_data.is_empty()
         && big_data.is_empty()
         && top_level.is_empty()
                     small_data: FxHashMap::default(),
                     big_data: FxHashMap::default(),
                     top_attrs: RawAttrs::EMPTY,
-                    vis: ItemVisibilities {
-                        arena: ThinVec::new(),
-                    },
+                    vis: ItemVisibilities { arena: ThinVec::new() },
                 })
             })
             .clone()
         Arc::new(item_tree)
     }
 }
+
 /// The item tree of a source file.
 #[derive(Debug, Default, Eq, PartialEq)]
 pub struct ItemTree {
         self.attrs.get(&of).unwrap_or(&RawAttrs::EMPTY)
     }
 
-    pub(crate) fn attrs(
-        &self,
-        db: &dyn DefDatabase,
-        krate: Crate,
-        of: FileAstId<ast::Item>,
-    ) -> Attrs {
+    pub(crate) fn attrs(&self, db: &dyn DefDatabase, krate: Crate, of: FileAstId<ast::Item>) -> Attrs {
         Attrs::expand_cfg_attr(db, krate, self.raw_attrs(of).clone())
     }
 
                 _ => {}
             }
         }
-        ItemTreeDataStats {
-            traits,
-            impls,
-            mods,
-            macro_calls,
-            macro_rules,
-        }
+        ItemTreeDataStats { traits, impls, mods, macro_calls, macro_rules }
     }
 
     pub fn pretty_print(&self, db: &dyn DefDatabase, edition: Edition) -> String {
     }
 
     fn shrink_to_fit(&mut self) {
-        let ItemTree {
-            top_level: _,
-            attrs,
-            big_data,
-            small_data,
-            vis: _,
-            top_attrs: _,
-        } = self;
+        let ItemTree { top_level: _, attrs, big_data, small_data, vis: _, top_attrs: _ } = self;
         attrs.shrink_to_fit();
         big_data.shrink_to_fit();
         small_data.shrink_to_fit();
 // small as possible which is why we split them in two, most common ones are 3 usize but some rarer
 // ones are 5.
 #[cfg(target_pointer_width = "64")]
-const _: [(); std::mem::size_of::<BigModItem>()] = [(); std::mem::size_of::<[usize; 5]>()];
+
 #[cfg(target_pointer_width = "64")]
-const _: [(); std::mem::size_of::<SmallModItem>()] = [(); std::mem::size_of::<[usize; 3]>()];
 
 #[derive(Default, Debug, Eq, PartialEq)]
 pub struct ItemTreeDataStats {
 }
 
 /// Trait implemented by all nodes in the item tree.
-pub(crate) trait ItemTreeNode: Clone {
-    type Source: AstIdNode;
-}
+type Source;
 
 #[allow(type_alias_bounds)]
 pub(crate) type ItemTreeAstId<T: ItemTreeNode> = FileAstId<T::Source>;
         )+
     };
 }
-
-mod_items! {
-ModItemId ->
-    Const in small_data -> ast::Const,
-    Enum in small_data -> ast::Enum,
-    ExternBlock in small_data -> ast::ExternBlock,
-    ExternCrate in big_data -> ast::ExternCrate,
-    Function in small_data -> ast::Fn,
-    Impl in small_data -> ast::Impl,
-    Macro2 in small_data -> ast::MacroDef,
-    MacroCall in small_data -> ast::MacroCall,
-    MacroRules in small_data -> ast::MacroRules,
-    Mod in big_data -> ast::Module,
-    Static in small_data -> ast::Static,
-    Struct in small_data -> ast::Struct,
-    Trait in small_data -> ast::Trait,
-    TypeAlias in small_data -> ast::TypeAlias,
-    Union in small_data -> ast::Union,
-    Use in big_data -> ast::Use,
-}
-
 impl Index<RawVisibilityId> for ItemTree {
     type Output = RawVisibility;
+
     fn index(&self, index: RawVisibilityId) -> &Self::Output {
         static VIS_PUB: RawVisibility = RawVisibility::Public;
         static VIS_PRIV_IMPLICIT: RawVisibility =
         static VIS_PRIV_EXPLICIT: RawVisibility =
             RawVisibility::PubSelf(VisibilityExplicitness::Explicit);
         static VIS_PUB_CRATE: RawVisibility = RawVisibility::PubCrate;
-
         match index {
             RawVisibilityId::PRIV_IMPLICIT => &VIS_PRIV_IMPLICIT,
             RawVisibilityId::PRIV_EXPLICIT => &VIS_PRIV_EXPLICIT,
     kind: UseTreeKind,
 }
 
-// FIXME: Would be nice to encode `None` into this
-// We could just use a `Name` where `_` well means `_` ..
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum ImportAlias {
     /// Unnamed alias, as in `use Foo as _;`
 
 impl ImportAlias {
     pub fn display(&self, edition: Edition) -> impl fmt::Display + '_ {
-        ImportAliasDisplay {
-            value: self,
-            edition,
-        }
+        ImportAliasDisplay { value: self, edition }
     }
 }
 
         path: Interned<ModPath>,
         alias: Option<ImportAlias>,
     },
-
     /// ```ignore
     /// use *;  // (invalid, but can occur in nested tree)
     /// use path::*;
     /// ```
-    Glob { path: Option<Interned<ModPath>> },
-
+    Glob {
+        path: Option<Interned<ModPath>>,
+    },
     /// ```ignore
     /// use prefix::{self, Item, ...};
     /// ```
 }
 
 #[derive(Debug, Clone, Eq, PartialEq)]
-pub struct Impl {}
+pub struct Impl {
+}
 
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub struct TypeAlias {
 #[derive(Debug, Clone, Eq, PartialEq)]
 pub(crate) enum ModKind {
     /// `mod m { ... }`
-    Inline { items: Box<[ModItemId]> },
+    Inline {
+        items: Box<[ModItemId]>,
+    },
     /// `mod m;`
     Outline,
 }
 
 impl Use {
     /// Expands the `UseTree` into individually imported `ModPath`s.
-    pub fn expand(
-        &self,
-        mut cb: impl FnMut(Idx<ast::UseTree>, ModPath, ImportKind, Option<ImportAlias>),
-    ) {
+    pub fn expand(&self, mut cb: impl FnMut(Idx<ast::UseTree>, ModPath, ImportKind, Option<ImportAlias>)) {
         self.use_tree.expand_impl(None, &mut 0, &mut cb)
     }
 }
         &self.kind
     }
 
-    fn expand_impl(
-        &self,
-        prefix: Option<ModPath>,
-        counting_index: &mut u32,
-        cb: &mut impl FnMut(Idx<ast::UseTree>, ModPath, ImportKind, Option<ImportAlias>),
-    ) {
+    fn expand_impl(&self, prefix: Option<ModPath>, counting_index: &mut u32, cb: &mut impl FnMut(Idx<ast::UseTree>, ModPath, ImportKind, Option<ImportAlias>)) {
         fn concat_mod_paths(
             prefix: Option<ModPath>,
             path: &ModPath,
                 (Some(_), _) => None,
             }
         }
-
         match &self.kind {
             UseTreeKind::Single { path, alias } => {
                 if let Some((path, kind)) = concat_mod_paths(prefix, path) {
-                    cb(
-                        Idx::from_raw(RawIdx::from_u32(*counting_index)),
-                        path,
-                        kind,
-                        alias.clone(),
-                    );
+                    cb(Idx::from_raw(RawIdx::from_u32(*counting_index)), path, kind, alias.clone());
                 }
             }
             UseTreeKind::Glob { path: Some(path) } => {
                     );
                 }
             }
-            UseTreeKind::Prefixed {
-                prefix: additional_prefix,
-                list,
-            } => {
+            UseTreeKind::Prefixed { prefix: additional_prefix, list } => {
                 let prefix = match additional_prefix {
                     Some(path) => match concat_mod_paths(prefix, path) {
                         Some((path, ImportKind::Plain)) => Some(path),