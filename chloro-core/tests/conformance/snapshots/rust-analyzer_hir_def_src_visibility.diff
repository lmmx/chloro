COMPARISON DIFF
============================================================

Original size: 13679 bytes
Chloro size:   13539 bytes
Rustfmt size:  13851 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use syntax::ast::{self, HasVisibility};
 use triomphe::Arc;
 
-use crate::{
-    db::DefDatabase, nameres::DefMap, resolver::HasResolver, src::HasSource, AssocItemId,
-    HasModule, ItemContainerId, LocalFieldId, LocalModuleId, ModuleId, TraitId, VariantId,
-};
-
 pub use crate::item_tree::{RawVisibility, VisibilityExplicitness};
-
+use crate::{
+    AssocItemId, HasModule, ItemContainerId, LocalFieldId, LocalModuleId, ModuleId, TraitId,
+    VariantId, db::DefDatabase, nameres::DefMap, resolver::HasResolver, src::HasSource,
+};
 /// Visibility of an item, with the path resolved.
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
 pub enum Visibility {
 }
 
 impl Visibility {
-    pub fn resolve(
-        db: &dyn DefDatabase,
-        resolver: &crate::resolver::Resolver<'_>,
-        raw_vis: &RawVisibility,
-    ) -> Self {
+    pub fn resolve(db: &dyn DefDatabase, resolver: &crate::resolver::Resolver<'_>, raw_vis: &RawVisibility) -> Self {
         // we fall back to public visibility (i.e. fail open) if the path can't be resolved
-        resolver
-            .resolve_visibility(db, raw_vis)
-            .unwrap_or(Visibility::Public)
+        resolver.resolve_visibility(db, raw_vis).unwrap_or(Visibility::Public)
     }
 
     pub(crate) fn is_visible_from_other_crate(self) -> bool {
         Self::is_visible_from_def_map_(db, def_map, to_module, from_module.local_id)
     }
 
-    pub(crate) fn is_visible_from_def_map(
-        self,
-        db: &dyn DefDatabase,
-        def_map: &DefMap,
-        from_module: LocalModuleId,
-    ) -> bool {
+    pub(crate) fn is_visible_from_def_map(self, db: &dyn DefDatabase, def_map: &DefMap, from_module: LocalModuleId) -> bool {
         let to_module = match self {
             Visibility::Module(m, _) => m,
             Visibility::PubCrate(krate) => return def_map.krate() == krate,
         if def_map.krate() != to_module.krate {
             return false;
         }
-
         if from_module == to_module.local_id && def_map.block_id() == to_module.block {
             // if the modules are the same, visibility is trivially satisfied
             return true;
         Self::is_visible_from_def_map_(db, def_map, to_module, from_module)
     }
 
-    fn is_visible_from_def_map_(
-        db: &dyn DefDatabase,
-        def_map: &DefMap,
-        mut to_module: ModuleId,
-        mut from_module: LocalModuleId,
-    ) -> bool {
+    fn is_visible_from_def_map_(db: &dyn DefDatabase, def_map: &DefMap, mut to_module: ModuleId, mut from_module: LocalModuleId) -> bool {
         debug_assert_eq!(to_module.krate, def_map.krate());
         // `to_module` might be the root module of a block expression. Those have the same
         // visibility as the containing module (even though no items are directly nameable from
         // there, getting this right is important for method resolution).
         // In that case, we adjust the visibility of `to_module` to point to the containing module.
-
         // Additional complication: `to_module` might be in `from_module`'s `DefMap`, which we're
         // currently computing, so we must not call the `def_map` query for it.
         let def_map_block = def_map.block_id();
             }
             break;
         }
-
         // from_module needs to be a descendant of to_module
         let mut def_map = def_map;
         let mut parent_arc;
             }
             (Visibility::Module(mod_, exp), Visibility::PubCrate(krate))
             | (Visibility::PubCrate(krate), Visibility::Module(mod_, exp)) => {
-                if mod_.krate == krate {
-                    Some(Visibility::Module(mod_, exp))
-                } else {
-                    None
-                }
+                if mod_.krate == krate { Some(Visibility::Module(mod_, exp)) } else { None }
             }
             (Visibility::Module(mod_a, expl_a), Visibility::Module(mod_b, expl_b)) => {
                 if mod_a == mod_b {
 }
 
 /// Resolve visibility of all specific fields of a struct or union variant.
-pub(crate) fn field_visibilities_query(
-    db: &dyn DefDatabase,
-    variant_id: VariantId,
-) -> Arc<ArenaMap<LocalFieldId, Visibility>> {
+pub(crate) fn field_visibilities_query(db: &dyn DefDatabase, variant_id: VariantId) -> Arc<ArenaMap<LocalFieldId, Visibility>> {
     let variant_fields = variant_id.fields(db);
     let fields = variant_fields.fields();
     if fields.is_empty() {
     let resolver = variant_id.module(db).resolver(db);
     let mut res = ArenaMap::default();
     for (field_id, field_data) in fields.iter() {
-        res.insert(
-            field_id,
-            Visibility::resolve(db, &resolver, &field_data.visibility),
-        );
+        res.insert(field_id, Visibility::resolve(db, &resolver, &field_data.visibility));
     }
     res.shrink_to_fit();
     Arc::new(res)
 }
 
-pub fn visibility_from_ast(
-    db: &dyn DefDatabase,
-    has_resolver: impl HasResolver + HasModule,
-    ast_vis: InFile<Option<ast::Visibility>>,
-) -> Visibility {
+pub fn visibility_from_ast(db: &dyn DefDatabase, has_resolver: impl HasResolver + HasModule, ast_vis: InFile<Option<ast::Visibility>>) -> Visibility {
     let mut span_map = None;
     let raw_vis = crate::item_tree::visibility_from_ast(db, ast_vis.value, &mut |range| {
-        span_map
-            .get_or_insert_with(|| db.span_map(ast_vis.file_id))
-            .span_for_range(range)
-            .ctx
+        span_map.get_or_insert_with(|| db.span_map(ast_vis.file_id)).span_for_range(range).ctx
     });
     match raw_vis {
         RawVisibility::PubSelf(explicitness) => {