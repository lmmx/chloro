COMPARISON DIFF
============================================================

Original size: 22455 bytes
Chloro size:   22345 bytes
Rustfmt size:  22455 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     Ok(())
 }
 
-pub(crate) fn handle_work_done_progress_cancel(
-    state: &mut GlobalState,
-    params: WorkDoneProgressCancelParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_work_done_progress_cancel(state: &mut GlobalState, params: WorkDoneProgressCancelParams) -> anyhow::Result<()> {
     if let lsp_types::NumberOrString::String(s) = &params.token
         && let Some(id) = s.strip_prefix("rust-analyzer/flycheck/")
         && let Ok(id) = id.parse::<u32>()
     {
         flycheck.cancel();
     }
-
     // Just ignore this. It is OK to continue sending progress
     // notifications for this token, as the client can't know when
     // we accepted notification.
     Ok(())
 }
 
-pub(crate) fn handle_did_open_text_document(
-    state: &mut GlobalState,
-    params: DidOpenTextDocumentParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_did_open_text_document(state: &mut GlobalState, params: DidOpenTextDocumentParams) -> anyhow::Result<()> {
     let _p = tracing::info_span!("handle_did_open_text_document").entered();
-
     if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {
         let already_exists = state
             .mem_docs
     Ok(())
 }
 
-pub(crate) fn handle_did_change_text_document(
-    state: &mut GlobalState,
-    params: DidChangeTextDocumentParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_did_change_text_document(state: &mut GlobalState, params: DidChangeTextDocumentParams) -> anyhow::Result<()> {
     let _p = tracing::info_span!("handle_did_change_text_document").entered();
-
     if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {
         let Some(DocumentData { version, data }) = state.mem_docs.get_mut(&path) else {
             tracing::error!(?path, "unexpected DidChangeTextDocument");
     Ok(())
 }
 
-pub(crate) fn handle_did_close_text_document(
-    state: &mut GlobalState,
-    params: DidCloseTextDocumentParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_did_close_text_document(state: &mut GlobalState, params: DidCloseTextDocumentParams) -> anyhow::Result<()> {
     let _p = tracing::info_span!("handle_did_close_text_document").entered();
-
     if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {
         if state.mem_docs.remove(&path).is_err() {
             tracing::error!("orphan DidCloseTextDocument: {}", path);
     Ok(())
 }
 
-pub(crate) fn handle_did_save_text_document(
-    state: &mut GlobalState,
-    params: DidSaveTextDocumentParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_did_save_text_document(state: &mut GlobalState, params: DidSaveTextDocumentParams) -> anyhow::Result<()> {
     if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {
         let snap = state.snapshot();
         let file_id = try_default!(snap.vfs_path_to_file_id(&vfs_path)?);
             flycheck.restart_workspace(None);
         }
     }
-
     Ok(())
 }
 
-pub(crate) fn handle_did_change_configuration(
-    state: &mut GlobalState,
-    _params: DidChangeConfigurationParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_did_change_configuration(state: &mut GlobalState, _params: DidChangeConfigurationParams) -> anyhow::Result<()> {
     // As stated in https://github.com/microsoft/language-server-protocol/issues/676,
     // this notification's parameters should be ignored and the actual config queried separately.
     state.send_request::<lsp_types::request::WorkspaceConfiguration>(
             }
         },
     );
-
     Ok(())
 }
 
-pub(crate) fn handle_did_change_workspace_folders(
-    state: &mut GlobalState,
-    params: DidChangeWorkspaceFoldersParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_did_change_workspace_folders(state: &mut GlobalState, params: DidChangeWorkspaceFoldersParams) -> anyhow::Result<()> {
     let config = Arc::make_mut(&mut state.config);
-
     for workspace in params.event.removed {
         let Ok(path) = workspace.uri.to_file_path() else { continue };
         let Ok(path) = Utf8PathBuf::from_path_buf(path) else { continue };
         let Ok(path) = AbsPathBuf::try_from(path) else { continue };
         config.remove_workspace(&path);
     }
-
     let added = params
         .event
         .added
         .filter_map(|it| Utf8PathBuf::from_path_buf(it).ok())
         .filter_map(|it| AbsPathBuf::try_from(it).ok());
     config.add_workspaces(added);
-
     if !config.has_linked_projects() && config.detached_files().is_empty() {
         config.rediscover_workspaces();
 
         let req = FetchWorkspaceRequest { path: None, force_crate_graph_reload: false };
         state.fetch_workspaces_queue.request_op("client workspaces changed".to_owned(), req);
     }
-
     Ok(())
 }
 
-pub(crate) fn handle_did_change_watched_files(
-    state: &mut GlobalState,
-    params: DidChangeWatchedFilesParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_did_change_watched_files(state: &mut GlobalState, params: DidChangeWatchedFilesParams) -> anyhow::Result<()> {
     for change in params.changes.iter().unique_by(|&it| &it.uri) {
         if let Ok(path) = from_proto::abs_path(&change.uri) {
             state.loader.handle.invalidate(path);
 
 fn run_flycheck(state: &mut GlobalState, vfs_path: VfsPath) -> bool {
     let _p = tracing::info_span!("run_flycheck").entered();
-
     let file_id = state.vfs.read().0.file_id(&vfs_path);
     if let Some((file_id, vfs::FileExcluded::No)) = file_id {
         let world = state.snapshot();
     Ok(())
 }
 
-pub(crate) fn handle_run_flycheck(
-    state: &mut GlobalState,
-    params: RunFlycheckParams,
-) -> anyhow::Result<()> {
+pub(crate) fn handle_run_flycheck(state: &mut GlobalState, params: RunFlycheckParams) -> anyhow::Result<()> {
     let _p = tracing::info_span!("handle_run_flycheck").entered();
     if let Some(text_document) = params.text_document
         && let Ok(vfs_path) = from_proto::vfs_path(&text_document.uri)