COMPARISON DIFF
============================================================

Original size: 8324 bytes
Chloro size:   7971 bytes
Rustfmt size:  8412 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Trait solving using next trait solver.
 
 use core::fmt;
 use std::hash::Hash;
 
 use base_db::Crate;
-use hir_def::{lang_item::LangItem, BlockId, TraitId};
+use hir_def::{BlockId, TraitId, lang_item::LangItem};
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_next_trait_solver::solve::{HasChanged, SolverDelegateEvalExt};
 use rustc_type_ir::{
+    TypingMode,
     inherent::{IntoKind, Span as _},
     solve::Certainty,
-    TypingMode,
 };
 use triomphe::Arc;
 
 use crate::{
     db::HirDatabase,
     next_solver::{
-        infer::{traits::ObligationCause, DbInternerInferExt, InferCtxt},
-        obligation_ctxt::ObligationCtxt,
         Canonical, DbInterner, GenericArgs, Goal, ParamEnv, Predicate, SolverContext, Span, Ty,
         TyKind,
+        infer::{DbInternerInferExt, InferCtxt, traits::ObligationCause},
+        obligation_ctxt::ObligationCtxt,
     },
 };
 
 pub struct TraitEnvironment<'db> {
     pub krate: Crate,
     pub block: Option<BlockId>,
-    // FIXME make this a BTreeMap
     traits_from_clauses: Box<[(Ty<'db>, TraitId)]>,
     pub env: ParamEnv<'db>,
 }
         })
     }
 
-    pub fn new(
-        krate: Crate,
-        block: Option<BlockId>,
-        traits_from_clauses: Box<[(Ty<'db>, TraitId)]>,
-        env: ParamEnv<'db>,
-    ) -> Arc<Self> {
-        Arc::new(TraitEnvironment {
-            krate,
-            block,
-            traits_from_clauses,
-            env,
-        })
+    pub fn new(krate: Crate, block: Option<BlockId>, traits_from_clauses: Box<[(Ty<'db>, TraitId)]>, env: ParamEnv<'db>) -> Arc<Self> {
+        Arc::new(TraitEnvironment { krate, block, traits_from_clauses, env })
     }
 
-    // pub fn with_block(self: &mut Arc<Self>, block: BlockId) {
     pub fn with_block(this: &mut Arc<Self>, block: BlockId) {
         Arc::make_mut(this).block = Some(block);
     }
 }
 
 /// This should be used in `hir` only.
-pub fn structurally_normalize_ty<'db>(
-    infcx: &InferCtxt<'db>,
-    ty: Ty<'db>,
-    env: Arc<TraitEnvironment<'db>>,
-) -> Ty<'db> {
-    let TyKind::Alias(..) = ty.kind() else {
-        return ty;
-    };
+pub fn structurally_normalize_ty<'db>(infcx: &InferCtxt<'db>, ty: Ty<'db>, env: Arc<TraitEnvironment<'db>>) -> Ty<'db> {
+    let TyKind::Alias(..) = ty.kind() else { return ty };
     let mut ocx = ObligationCtxt::new(infcx);
-    let ty = ocx
-        .structurally_normalize_ty(&ObligationCause::dummy(), env.env, ty)
-        .unwrap_or(ty);
+    let ty = ocx.structurally_normalize_ty(&ObligationCause::dummy(), env.env, ty).unwrap_or(ty);
     ty.replace_infer_with_error(infcx.interner)
 }
 
     }
 }
 
-pub fn next_trait_solve_canonical_in_ctxt<'db>(
-    infer_ctxt: &InferCtxt<'db>,
-    goal: Canonical<'db, Goal<'db, Predicate<'db>>>,
-) -> NextTraitSolveResult {
+pub fn next_trait_solve_canonical_in_ctxt<'db>(infer_ctxt: &InferCtxt<'db>, goal: Canonical<'db, Goal<'db, Predicate<'db>>>) -> NextTraitSolveResult {
     infer_ctxt.probe(|_| {
         let context = <&SolverContext<'db>>::from(infer_ctxt);
 
 }
 
 /// Solve a trait goal using next trait solver.
-pub fn next_trait_solve_in_ctxt<'db, 'a>(
-    infer_ctxt: &'a InferCtxt<'db>,
-    goal: Goal<'db, Predicate<'db>>,
-) -> Result<(HasChanged, Certainty), rustc_type_ir::solve::NoSolution> {
+pub fn next_trait_solve_in_ctxt<'db, 'a>(infer_ctxt: &'a InferCtxt<'db>, goal: Goal<'db, Predicate<'db>>) -> Result<(HasChanged, Certainty), rustc_type_ir::solve::NoSolution> {
     tracing::info!(?goal);
-
     let context = <&SolverContext<'db>>::from(infer_ctxt);
-
     let res = context.evaluate_root_goal(goal, Span::dummy(), None);
-
     let res = res.map(|r| (r.has_changed, r.certainty));
-
     tracing::debug!("solve_nextsolver({:?}) => {:?}", goal, res);
-
     res
 }
 
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
 pub enum FnTrait {
-    // Warning: Order is important. If something implements `x` it should also implement
-    // `y` if `y <= x`.
     FnOnce,
     FnMut,
     Fn,
-
     AsyncFnOnce,
     AsyncFnMut,
     AsyncFn,
 }
 
 /// This should not be used in `hir-ty`, only in `hir`.
-pub fn implements_trait_unique<'db>(
-    ty: Ty<'db>,
-    db: &'db dyn HirDatabase,
-    env: Arc<TraitEnvironment<'db>>,
-    trait_: TraitId,
-) -> bool {
+pub fn implements_trait_unique<'db>(ty: Ty<'db>, db: &'db dyn HirDatabase, env: Arc<TraitEnvironment<'db>>, trait_: TraitId) -> bool {
     implements_trait_unique_impl(db, env, trait_, &mut |infcx| {
         infcx.fill_rest_fresh_args(trait_.into(), [ty.into()])
     })
 }
 
 /// This should not be used in `hir-ty`, only in `hir`.
-pub fn implements_trait_unique_with_args<'db>(
-    db: &'db dyn HirDatabase,
-    env: Arc<TraitEnvironment<'db>>,
-    trait_: TraitId,
-    args: GenericArgs<'db>,
-) -> bool {
+pub fn implements_trait_unique_with_args<'db>(db: &'db dyn HirDatabase, env: Arc<TraitEnvironment<'db>>, trait_: TraitId, args: GenericArgs<'db>) -> bool {
     implements_trait_unique_impl(db, env, trait_, &mut |_| args)
 }
 
-fn implements_trait_unique_impl<'db>(
-    db: &'db dyn HirDatabase,
-    env: Arc<TraitEnvironment<'db>>,
-    trait_: TraitId,
-    create_args: &mut dyn FnMut(&InferCtxt<'db>) -> GenericArgs<'db>,
-) -> bool {
+fn implements_trait_unique_impl<'db>(db: &'db dyn HirDatabase, env: Arc<TraitEnvironment<'db>>, trait_: TraitId, create_args: &mut dyn FnMut(&InferCtxt<'db>) -> GenericArgs<'db>) -> bool {
     let interner = DbInterner::new_with(db, Some(env.krate), env.block);
     // FIXME(next-solver): I believe this should be `PostAnalysis`.
     let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
-
     let args = create_args(&infcx);
     let trait_ref = rustc_type_ir::TraitRef::new_from_args(interner, trait_.into(), args);
     let goal = Goal::new(interner, env.env, trait_ref);
-
     let result = crate::traits::next_trait_solve_in_ctxt(&infcx, goal);
     matches!(result, Ok((_, Certainty::Yes)))
 }