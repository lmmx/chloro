COMPARISON DIFF
============================================================

Original size: 20372 bytes
Chloro size:   20251 bytes
Rustfmt size:  20372 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
             })
             .flat_map(|item| self.lower_mod_item(&item))
             .collect();
-
         if let Some(ast::Expr::MacroExpr(tail_macro)) = stmts.expr()
             && let Some(call) = tail_macro.macro_call()
         {
                 self.top_level.push(mod_item);
             }
         }
-
         self.tree.vis.arena = self.visibilities.into_iter().collect();
         self.tree.top_level = self.top_level.into_boxed_slice();
         self.tree
         };
         let attrs = RawAttrs::new(self.db, item, self.span_map());
         self.add_attrs(mod_item.ast_id(), attrs);
-
         Some(mod_item)
     }
 
         let shape = adt_shape(strukt.kind());
         let res = Struct { name, visibility, shape };
         self.tree.small_data.insert(ast_id.upcast(), SmallModItem::Struct(res));
-
         Some(ast_id)
     }
 
     fn lower_function(&mut self, func: &ast::Fn) -> Option<ItemTreeAstId<Function>> {
         let visibility = self.lower_visibility(func);
         let name = func.name()?.as_name();
-
         let ast_id = self.source_ast_id_map.ast_id(func);
-
         let res = Function { name, visibility };
-
         self.tree.small_data.insert(ast_id.upcast(), SmallModItem::Function(res));
         Some(ast_id)
     }
 
-    fn lower_type_alias(
-        &mut self,
-        type_alias: &ast::TypeAlias,
-    ) -> Option<ItemTreeAstId<TypeAlias>> {
+    fn lower_type_alias(&mut self, type_alias: &ast::TypeAlias) -> Option<ItemTreeAstId<TypeAlias>> {
         let name = type_alias.name()?.as_name();
         let visibility = self.lower_visibility(type_alias);
         let ast_id = self.source_ast_id_map.ast_id(type_alias);
         let name = trait_def.name()?.as_name();
         let visibility = self.lower_visibility(trait_def);
         let ast_id = self.source_ast_id_map.ast_id(trait_def);
-
         let def = Trait { name, visibility };
         self.tree.small_data.insert(ast_id.upcast(), SmallModItem::Trait(def));
         Some(ast_id)
         let (use_tree, _) = lower_use_tree(self.db, use_item.use_tree()?, &mut |range| {
             self.span_map().span_for_range(range).ctx
         })?;
-
         let res = Use { visibility, use_tree };
         self.tree.big_data.insert(ast_id.upcast(), BigModItem::Use(res));
         Some(ast_id)
     }
 
-    fn lower_extern_crate(
-        &mut self,
-        extern_crate: &ast::ExternCrate,
-    ) -> Option<ItemTreeAstId<ExternCrate>> {
+    fn lower_extern_crate(&mut self, extern_crate: &ast::ExternCrate) -> Option<ItemTreeAstId<ExternCrate>> {
         let name = extern_crate.name_ref()?.as_name();
         let alias = extern_crate.rename().map(|a| {
             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)
         });
         let visibility = self.lower_visibility(extern_crate);
         let ast_id = self.source_ast_id_map.ast_id(extern_crate);
-
         let res = ExternCrate { name, alias, visibility };
         self.tree.big_data.insert(ast_id.upcast(), BigModItem::ExternCrate(res));
         Some(ast_id)
     fn lower_macro_rules(&mut self, m: &ast::MacroRules) -> Option<ItemTreeAstId<MacroRules>> {
         let name = m.name()?;
         let ast_id = self.source_ast_id_map.ast_id(m);
-
         let res = MacroRules { name: name.as_name() };
         self.tree.small_data.insert(ast_id.upcast(), SmallModItem::MacroRules(res));
         Some(ast_id)
 
     fn lower_macro_def(&mut self, m: &ast::MacroDef) -> Option<ItemTreeAstId<Macro2>> {
         let name = m.name()?;
-
         let ast_id = self.source_ast_id_map.ast_id(m);
         let visibility = self.lower_visibility(m);
-
         let res = Macro2 { name: name.as_name(), visibility };
         self.tree.small_data.insert(ast_id.upcast(), SmallModItem::Macro2(res));
         Some(ast_id)
                 })
                 .collect()
         });
-
         let res = ExternBlock { children };
         self.tree.small_data.insert(ast_id.upcast(), SmallModItem::ExternBlock(res));
         ast_id
 }
 
 impl UseTreeLowering<'_> {
-    fn lower_use_tree(
-        &mut self,
-        tree: ast::UseTree,
-        span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext,
-    ) -> Option<UseTree> {
+    fn lower_use_tree(&mut self, tree: ast::UseTree, span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext) -> Option<UseTree> {
         if let Some(use_tree_list) = tree.use_tree_list() {
             let prefix = match tree.path() {
                 // E.g. use something::{{{inner}}};
     }
 }
 
-pub(crate) fn lower_use_tree(
-    db: &dyn DefDatabase,
-    tree: ast::UseTree,
-    span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext,
-) -> Option<(UseTree, Arena<ast::UseTree>)> {
+pub(crate) fn lower_use_tree(db: &dyn DefDatabase, tree: ast::UseTree, span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext) -> Option<(UseTree, Arena<ast::UseTree>)> {
     let mut lowering = UseTreeLowering { db, mapping: Arena::new() };
     let tree = lowering.lower_use_tree(tree, span_for_range)?;
     Some((tree, lowering.mapping))
     RawVisibility::PubSelf(VisibilityExplicitness::Implicit)
 }
 
-pub(crate) fn visibility_from_ast(
-    db: &dyn DefDatabase,
-    node: Option<ast::Visibility>,
-    span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext,
-) -> RawVisibility {
+pub(crate) fn visibility_from_ast(db: &dyn DefDatabase, node: Option<ast::Visibility>, span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext) -> RawVisibility {
     let Some(node) = node else { return private_vis() };
     let path = match node.kind() {
         ast::VisibilityKind::In(path) => {