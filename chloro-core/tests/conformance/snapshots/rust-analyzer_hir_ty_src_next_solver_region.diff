COMPARISON DIFF
============================================================

Original size: 11497 bytes
Chloro size:   11180 bytes
Rustfmt size:  11829 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Things related to regions.
 
 use hir_def::LifetimeParamId;
 use intern::Symbol;
 use rustc_type_ir::{
+    BoundVar, BoundVarIndexKind, DebruijnIndex, Flags, INNERMOST, RegionVid, TypeFlags,
+    TypeFoldable, TypeVisitable,
     inherent::{IntoKind, PlaceholderLike, SliceLike},
     relate::Relate,
-    BoundVar, BoundVarIndexKind, DebruijnIndex, Flags, RegionVid, TypeFlags, TypeFoldable,
-    TypeVisitable, INNERMOST,
 };
 
 use crate::next_solver::{GenericArg, OutlivesPredicate};
-
 use super::{
-    interned_vec_db,
+    ErrorGuaranteed, SolverDefId, interned_vec_db,
     interner::{BoundVarKind, DbInterner, Placeholder},
-    ErrorGuaranteed, SolverDefId,
 };
-
 pub type RegionKind<'db> = rustc_type_ir::RegionKind<DbInterner<'db>>;
 
 #[salsa::interned(constructor = new_)]
         })
     }
 
-    pub fn new_early_param(
-        interner: DbInterner<'db>,
-        early_bound_region: EarlyParamRegion,
-    ) -> Self {
+    pub fn new_early_param(interner: DbInterner<'db>, early_bound_region: EarlyParamRegion) -> Self {
         Region::new(interner, RegionKind::ReEarlyParam(early_bound_region))
     }
 
         Region::new(interner, RegionKind::ReErased)
     }
 
-    pub fn new_bound(
-        interner: DbInterner<'db>,
-        index: DebruijnIndex,
-        bound: BoundRegion,
-    ) -> Region<'db> {
-        Region::new(
-            interner,
-            RegionKind::ReBound(BoundVarIndexKind::Bound(index), bound),
-        )
+    pub fn new_bound(interner: DbInterner<'db>, index: DebruijnIndex, bound: BoundRegion) -> Region<'db> {
+        Region::new(interner, RegionKind::ReBound(BoundVarIndexKind::Bound(index), bound))
     }
 
     pub fn is_placeholder(&self) -> bool {
 
     pub fn type_flags(&self) -> TypeFlags {
         let mut flags = TypeFlags::empty();
-
         match &self.inner() {
             RegionKind::ReVar(..) => {
                 flags |= TypeFlags::HAS_FREE_REGIONS;
                 flags |= TypeFlags::HAS_ERROR;
             }
         }
-
         flags
     }
 }
 
 #[derive(Copy, Clone, PartialEq, Eq, Hash)]
 pub struct EarlyParamRegion {
-    // FIXME: See `ParamTy`.
     pub id: LifetimeParamId,
     pub index: u32,
 }
 
-#[derive(Copy, Clone, PartialEq, Eq, Hash)]
 /// The parameter representation of late-bound function parameters, "some region
 /// at least as big as the scope `fr.scope`".
 ///
 /// between others we use the `DefId` of the parameter. For this reason the `bound_region` field
 /// should basically always be `BoundRegionKind::Named` as otherwise there is no way of telling
 /// different parameters apart.
+#[derive(Copy, Clone, PartialEq, Eq, Hash)]
 pub struct LateParamRegion {
     pub scope: SolverDefId,
     pub bound_region: BoundRegionKind,
 pub enum BoundRegionKind {
     /// An anonymous region parameter for a given fn (&T)
     Anon,
-
     /// Named region parameters for functions (a in &'a T)
     ///
     /// The `DefId` is needed to distinguish free regions in
     /// the event of shadowing.
     Named(SolverDefId),
-
     /// Anonymous region for the implicit env pointer parameter
     /// to a closure
     ClosureEnv,
 }
 
 impl<'db> TypeVisitable<DbInterner<'db>> for Region<'db> {
-    fn visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(
-        &self,
-        visitor: &mut V,
-    ) -> V::Result {
+    fn visit_with<V: rustc_type_ir::TypeVisitor<DbInterner<'db>>>(&self, visitor: &mut V) -> V::Result {
         visitor.visit_region(*self)
     }
 }
 
 impl<'db> TypeFoldable<DbInterner<'db>> for Region<'db> {
-    fn try_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(
-        self,
-        folder: &mut F,
-    ) -> Result<Self, F::Error> {
+    fn try_fold_with<F: rustc_type_ir::FallibleTypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Result<Self, F::Error> {
         folder.try_fold_region(self)
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         folder.fold_region(self)
     }
 }
 
 impl<'db> Relate<DbInterner<'db>> for Region<'db> {
-    fn relate<R: rustc_type_ir::relate::TypeRelation<DbInterner<'db>>>(
-        relation: &mut R,
-        a: Self,
-        b: Self,
-    ) -> rustc_type_ir::relate::RelateResult<DbInterner<'db>, Self> {
+    fn relate<R: rustc_type_ir::relate::TypeRelation<DbInterner<'db>>>(relation: &mut R, a: Self, b: Self) -> rustc_type_ir::relate::RelateResult<DbInterner<'db>, Self> {
         relation.regions(a, b)
     }
 }
 }
 
 impl<'db> rustc_type_ir::inherent::Region<DbInterner<'db>> for Region<'db> {
-    fn new_bound(
-        interner: DbInterner<'db>,
-        debruijn: rustc_type_ir::DebruijnIndex,
-        var: BoundRegion,
-    ) -> Self {
-        Region::new(
-            interner,
-            RegionKind::ReBound(BoundVarIndexKind::Bound(debruijn), var),
-        )
+    fn new_bound(interner: DbInterner<'db>, debruijn: rustc_type_ir::DebruijnIndex, var: BoundRegion) -> Self {
+        Region::new(interner, RegionKind::ReBound(BoundVarIndexKind::Bound(debruijn), var))
     }
 
-    fn new_anon_bound(
-        interner: DbInterner<'db>,
-        debruijn: rustc_type_ir::DebruijnIndex,
-        var: rustc_type_ir::BoundVar,
-    ) -> Self {
+    fn new_anon_bound(interner: DbInterner<'db>, debruijn: rustc_type_ir::DebruijnIndex, var: rustc_type_ir::BoundVar) -> Self {
         Region::new(
             interner,
             RegionKind::ReBound(
                 BoundVarIndexKind::Bound(debruijn),
-                BoundRegion {
-                    var,
-                    kind: BoundRegionKind::Anon,
-                },
+                BoundRegion { var, kind: BoundRegionKind::Anon },
             ),
         )
     }
             interner,
             RegionKind::ReBound(
                 BoundVarIndexKind::Canonical,
-                BoundRegion {
-                    var,
-                    kind: BoundRegionKind::Anon,
-                },
+                BoundRegion { var, kind: BoundRegionKind::Anon },
             ),
         )
     }
         Region::new(interner, RegionKind::ReStatic)
     }
 
-    fn new_placeholder(
-        interner: DbInterner<'db>,
-        var: <DbInterner<'db> as rustc_type_ir::Interner>::PlaceholderRegion,
-    ) -> Self {
+    fn new_placeholder(interner: DbInterner<'db>, var: <DbInterner<'db> as rustc_type_ir::Interner>::PlaceholderRegion) -> Self {
         Region::new(interner, RegionKind::RePlaceholder(var))
     }
 }
     }
 
     fn with_updated_universe(self, ui: rustc_type_ir::UniverseIndex) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: self.bound,
-        }
+        Placeholder { universe: ui, bound: self.bound }
     }
 
     fn new(ui: rustc_type_ir::UniverseIndex, bound: Self::Bound) -> Self {
-        Placeholder {
-            universe: ui,
-            bound,
-        }
+        Placeholder { universe: ui, bound }
     }
 
     fn new_anon(ui: rustc_type_ir::UniverseIndex, var: rustc_type_ir::BoundVar) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: BoundRegion {
-                var,
-                kind: BoundRegionKind::Anon,
-            },
-        }
+        Placeholder { universe: ui, bound: BoundRegion { var, kind: BoundRegionKind::Anon } }
     }
 }
 
 type GenericArgOutlivesPredicate<'db> = OutlivesPredicate<'db, GenericArg<'db>>;
-
-interned_vec_db!(RegionAssumptions, GenericArgOutlivesPredicate);