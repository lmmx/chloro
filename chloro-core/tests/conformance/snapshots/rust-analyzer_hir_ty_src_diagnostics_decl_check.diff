COMPARISON DIFF
============================================================

Original size: 23115 bytes
Chloro size:   23513 bytes
Rustfmt size:  23115 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! - match arm bindings (e.g. `foo @ Some(_)`)
 //! - modules (e.g. `mod foo { ... }` or `mod foo;`)
 
-mod case_conv;
-
 use std::fmt;
 
 use hir_def::{
 };
 
 use crate::db::HirDatabase;
-
 use self::case_conv::{to_camel_case, to_lower_snake_case, to_upper_snake_case};
 
-pub fn incorrect_case(db: &dyn HirDatabase, owner: ModuleDefId) -> Vec<IncorrectCase> {
+mod case_conv;
+
+pub fn incorrect_case(
+    db: &dyn HirDatabase,
+    owner: ModuleDefId,
+) -> Vec<IncorrectCase> {
     let _p = tracing::info_span!("incorrect_case").entered();
     let mut validator = DeclValidator::new(db);
     validator.validate_item(owner);
 }
 
 impl fmt::Display for CaseType {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         let repr = match self {
             CaseType::LowerSnakeCase => "snake_case",
             CaseType::UpperSnakeCase => "UPPER_SNAKE_CASE",
             CaseType::UpperCamelCase => "UpperCamelCase",
         };
-
         repr.fmt(f)
     }
 }
 }
 
 impl fmt::Display for IdentType {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         let repr = match self {
             IdentType::Constant => "Constant",
             IdentType::Enum => "Enum",
             IdentType::Variable => "Variable",
             IdentType::Variant => "Variant",
         };
-
         repr.fmt(f)
     }
 }
         DeclValidator { db, sink: Vec::new() }
     }
 
-    pub(super) fn validate_item(&mut self, item: ModuleDefId) {
+    pub(super) fn validate_item(
+        &mut self,
+        item: ModuleDefId,
+    ) {
         match item {
             ModuleDefId::ModuleId(module_id) => self.validate_module(module_id),
             ModuleDefId::TraitId(trait_id) => self.validate_trait(trait_id),
         }
     }
 
-    fn validate_adt(&mut self, adt: AdtId) {
+    fn validate_adt(
+        &mut self,
+        adt: AdtId,
+    ) {
         match adt {
             AdtId::StructId(struct_id) => self.validate_struct(struct_id),
             AdtId::EnumId(enum_id) => self.validate_enum(enum_id),
         }
     }
 
-    fn validate_module(&mut self, module_id: ModuleId) {
+    fn validate_module(
+        &mut self,
+        module_id: ModuleId,
+    ) {
         // Check the module name.
         let Some(module_name) = module_id.name(self.db) else { return };
         let Some(module_name_replacement) =
         );
     }
 
-    fn validate_trait(&mut self, trait_id: TraitId) {
+    fn validate_trait(
+        &mut self,
+        trait_id: TraitId,
+    ) {
         // Check the trait name.
         let data = self.db.trait_signature(trait_id);
         self.create_incorrect_case_diagnostic_for_item_name(
         );
     }
 
-    fn validate_func(&mut self, func: FunctionId) {
+    fn validate_func(
+        &mut self,
+        func: FunctionId,
+    ) {
         let container = func.lookup(self.db).container;
         if matches!(container, ItemContainerId::ExternBlockId(_)) {
             cov_mark::hit!(extern_func_incorrect_case_ignored);
             return;
         }
-
         // Check the function name.
         // Skipped if function is an associated item of a trait implementation.
         if !self.is_trait_impl_container(container) {
         } else {
             cov_mark::hit!(trait_impl_assoc_func_name_incorrect_case_ignored);
         }
-
         // Check the patterns inside the function body.
         self.validate_func_body(func);
     }
 
     /// Check incorrect names for patterns inside the function body.
     /// This includes function parameters except for trait implementation associated functions.
-    fn validate_func_body(&mut self, func: FunctionId) {
+    fn validate_func_body(
+        &mut self,
+        func: FunctionId,
+    ) {
         let body = self.db.body(func.into());
         let edition = self.edition(func);
         let mut pats_replacements = body
                 _ => None,
             })
             .peekable();
-
         // XXX: only look at source_map if we do have missing fields
         if pats_replacements.peek().is_none() {
             return;
         }
-
         let source_map = self.db.body_with_source_map(func.into()).1;
         for (id, replacement) in pats_replacements {
             let Ok(source_ptr) = source_map.pat_syntax(id) else {
         }
     }
 
-    fn edition(&self, id: impl HasModule) -> span::Edition {
+    fn edition(
+        &self,
+        id: impl HasModule,
+    ) -> span::Edition {
         let krate = id.krate(self.db);
         krate.data(self.db).edition
     }
 
-    fn validate_struct(&mut self, struct_id: StructId) {
+    fn validate_struct(
+        &mut self,
+        struct_id: StructId,
+    ) {
         // Check the structure name.
         let data = self.db.struct_signature(struct_id);
         self.create_incorrect_case_diagnostic_for_item_name(
             CaseType::UpperCamelCase,
             IdentType::Structure,
         );
-
         // Check the field names.
         self.validate_struct_fields(struct_id);
     }
 
     /// Check incorrect names for struct fields.
-    fn validate_struct_fields(&mut self, struct_id: StructId) {
+    fn validate_struct_fields(
+        &mut self,
+        struct_id: StructId,
+    ) {
         let data = struct_id.fields(self.db);
         if data.shape != FieldsShape::Record {
             return;
                 )
             })
             .peekable();
-
         // XXX: Only look at sources if we do have incorrect names.
         if struct_fields_replacements.peek().is_none() {
             return;
         }
-
         let struct_loc = struct_id.lookup(self.db);
         let struct_src = struct_loc.source(self.db);
-
         let Some(ast::FieldList::RecordFieldList(struct_fields_list)) =
             struct_src.value.field_list()
         else {
         }
     }
 
-    fn validate_enum(&mut self, enum_id: EnumId) {
+    fn validate_enum(
+        &mut self,
+        enum_id: EnumId,
+    ) {
         let data = self.db.enum_signature(enum_id);
-
         // Check the enum name.
         self.create_incorrect_case_diagnostic_for_item_name(
             enum_id,
             CaseType::UpperCamelCase,
             IdentType::Enum,
         );
-
         // Check the variant names.
         self.validate_enum_variants(enum_id)
     }
 
     /// Check incorrect names for enum variants.
-    fn validate_enum_variants(&mut self, enum_id: EnumId) {
+    fn validate_enum_variants(
+        &mut self,
+        enum_id: EnumId,
+    ) {
         let data = enum_id.enum_variants(self.db);
-
         for (variant_id, _, _) in data.variants.iter() {
             self.validate_enum_variant_fields(*variant_id);
         }
-
         let edition = self.edition(enum_id);
         let mut enum_variants_replacements = data
             .variants
                 })
             })
             .peekable();
-
         // XXX: only look at sources if we do have incorrect names
         if enum_variants_replacements.peek().is_none() {
             return;
         }
-
         let enum_loc = enum_id.lookup(self.db);
         let enum_src = enum_loc.source(self.db);
-
         let Some(enum_variants_list) = enum_src.value.variant_list() else {
             always!(
                 enum_variants_replacements.peek().is_none(),
     }
 
     /// Check incorrect names for fields of enum variant.
-    fn validate_enum_variant_fields(&mut self, variant_id: EnumVariantId) {
+    fn validate_enum_variant_fields(
+        &mut self,
+        variant_id: EnumVariantId,
+    ) {
         let variant_data = variant_id.fields(self.db);
         if variant_data.shape != FieldsShape::Record {
             return;
                 )
             })
             .peekable();
-
         // XXX: only look at sources if we do have incorrect names
         if variant_field_replacements.peek().is_none() {
             return;
         }
-
         let variant_loc = variant_id.lookup(self.db);
         let variant_src = variant_loc.source(self.db);
-
         let Some(ast::FieldList::RecordFieldList(variant_fields_list)) =
             variant_src.value.field_list()
         else {
         }
     }
 
-    fn validate_const(&mut self, const_id: ConstId) {
+    fn validate_const(
+        &mut self,
+        const_id: ConstId,
+    ) {
         let container = const_id.lookup(self.db).container;
         if self.is_trait_impl_container(container) {
             cov_mark::hit!(trait_impl_assoc_const_incorrect_case_ignored);
             return;
         }
-
         let data = self.db.const_signature(const_id);
         let Some(name) = &data.name else {
             return;
         );
     }
 
-    fn validate_static(&mut self, static_id: StaticId) {
+    fn validate_static(
+        &mut self,
+        static_id: StaticId,
+    ) {
         let data = self.db.static_signature(static_id);
         if data.flags.contains(StaticFlags::EXTERN) {
             cov_mark::hit!(extern_static_incorrect_case_ignored);
             return;
         }
-
         self.create_incorrect_case_diagnostic_for_item_name(
             static_id,
             &data.name,
         );
     }
 
-    fn validate_type_alias(&mut self, type_alias_id: TypeAliasId) {
+    fn validate_type_alias(
+        &mut self,
+        type_alias_id: TypeAliasId,
+    ) {
         let container = type_alias_id.lookup(self.db).container;
         if self.is_trait_impl_container(container) {
             cov_mark::hit!(trait_impl_assoc_type_incorrect_case_ignored);
             return;
         }
-
         // Check the type alias name.
         let data = self.db.type_alias_signature(type_alias_id);
         self.create_incorrect_case_diagnostic_for_item_name(
         name: &Name,
         expected_case: CaseType,
         ident_type: IdentType,
-    ) where
+    )
+    where
         N: AstNode + HasName + fmt::Debug,
         S: HasSource<Value = N>,
-        L: Lookup<Data = S, Database = dyn DefDatabase> + HasModule + Copy,
-    {
+        L: Lookup<Data = S, Database = dyn DefDatabase> + HasModule + Copy, {
         let to_expected_case_type = match expected_case {
             CaseType::LowerSnakeCase => to_lower_snake_case,
             CaseType::UpperSnakeCase => to_upper_snake_case,
         else {
             return;
         };
-
         let item_loc = item_id.lookup(self.db);
         let item_src = item_loc.source(self.db);
         self.create_incorrect_case_diagnostic_for_ast_node(
         file_id: HirFileId,
         node: &T,
         ident_type: IdentType,
-    ) where
-        T: AstNode + HasName + fmt::Debug,
-    {
+    )
+    where
+        T: AstNode + HasName + fmt::Debug, {
         let Some(name_ast) = node.name() else {
             never!(
                 "Replacement ({:?}) was generated for a {:?} without a name: {:?}",
             );
             return;
         };
-
         let edition = file_id.original_file(self.db).edition(self.db);
         let diagnostic = IncorrectCase {
             file: file_id,
             ident_text: replacement.current_name.display(self.db, edition).to_string(),
             suggested_text: replacement.suggested_text,
         };
-
         self.sink.push(diagnostic);
     }
 
-    fn is_trait_impl_container(&self, container_id: ItemContainerId) -> bool {
+    fn is_trait_impl_container(
+        &self,
+        container_id: ItemContainerId,
+    ) -> bool {
         if let ItemContainerId::ImplId(impl_id) = container_id
             && self.db.impl_trait(impl_id).is_some()
         {