COMPARISON DIFF
============================================================

Original size: 23115 bytes
Chloro size:   22994 bytes
Rustfmt size:  23115 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! - match arm bindings (e.g. `foo @ Some(_)`)
 //! - modules (e.g. `mod foo { ... }` or `mod foo;`)
 
-mod case_conv;
-
 use std::fmt;
 
 use hir_def::{
 };
 
 use crate::db::HirDatabase;
-
 use self::case_conv::{to_camel_case, to_lower_snake_case, to_upper_snake_case};
 
+mod case_conv;
+
 pub fn incorrect_case(db: &dyn HirDatabase, owner: ModuleDefId) -> Vec<IncorrectCase> {
     let _p = tracing::info_span!("incorrect_case").entered();
     let mut validator = DeclValidator::new(db);
             CaseType::UpperSnakeCase => "UPPER_SNAKE_CASE",
             CaseType::UpperCamelCase => "UpperCamelCase",
         };
-
         repr.fmt(f)
     }
 }
             IdentType::Variable => "Variable",
             IdentType::Variant => "Variant",
         };
-
         repr.fmt(f)
     }
 }
             cov_mark::hit!(extern_func_incorrect_case_ignored);
             return;
         }
-
         // Check the function name.
         // Skipped if function is an associated item of a trait implementation.
         if !self.is_trait_impl_container(container) {
         } else {
             cov_mark::hit!(trait_impl_assoc_func_name_incorrect_case_ignored);
         }
-
         // Check the patterns inside the function body.
         self.validate_func_body(func);
     }
                 _ => None,
             })
             .peekable();
-
         // XXX: only look at source_map if we do have missing fields
         if pats_replacements.peek().is_none() {
             return;
         }
-
         let source_map = self.db.body_with_source_map(func.into()).1;
         for (id, replacement) in pats_replacements {
             let Ok(source_ptr) = source_map.pat_syntax(id) else {
             CaseType::UpperCamelCase,
             IdentType::Structure,
         );
-
         // Check the field names.
         self.validate_struct_fields(struct_id);
     }
                 )
             })
             .peekable();
-
         // XXX: Only look at sources if we do have incorrect names.
         if struct_fields_replacements.peek().is_none() {
             return;
         }
-
         let struct_loc = struct_id.lookup(self.db);
         let struct_src = struct_loc.source(self.db);
-
         let Some(ast::FieldList::RecordFieldList(struct_fields_list)) =
             struct_src.value.field_list()
         else {
 
     fn validate_enum(&mut self, enum_id: EnumId) {
         let data = self.db.enum_signature(enum_id);
-
         // Check the enum name.
         self.create_incorrect_case_diagnostic_for_item_name(
             enum_id,
             CaseType::UpperCamelCase,
             IdentType::Enum,
         );
-
         // Check the variant names.
         self.validate_enum_variants(enum_id)
     }
     /// Check incorrect names for enum variants.
     fn validate_enum_variants(&mut self, enum_id: EnumId) {
         let data = enum_id.enum_variants(self.db);
-
         for (variant_id, _, _) in data.variants.iter() {
             self.validate_enum_variant_fields(*variant_id);
         }
-
         let edition = self.edition(enum_id);
         let mut enum_variants_replacements = data
             .variants
                 })
             })
             .peekable();
-
         // XXX: only look at sources if we do have incorrect names
         if enum_variants_replacements.peek().is_none() {
             return;
         }
-
         let enum_loc = enum_id.lookup(self.db);
         let enum_src = enum_loc.source(self.db);
-
         let Some(enum_variants_list) = enum_src.value.variant_list() else {
             always!(
                 enum_variants_replacements.peek().is_none(),
                 )
             })
             .peekable();
-
         // XXX: only look at sources if we do have incorrect names
         if variant_field_replacements.peek().is_none() {
             return;
         }
-
         let variant_loc = variant_id.lookup(self.db);
         let variant_src = variant_loc.source(self.db);
-
         let Some(ast::FieldList::RecordFieldList(variant_fields_list)) =
             variant_src.value.field_list()
         else {
             cov_mark::hit!(trait_impl_assoc_const_incorrect_case_ignored);
             return;
         }
-
         let data = self.db.const_signature(const_id);
         let Some(name) = &data.name else {
             return;
             cov_mark::hit!(extern_static_incorrect_case_ignored);
             return;
         }
-
         self.create_incorrect_case_diagnostic_for_item_name(
             static_id,
             &data.name,
             cov_mark::hit!(trait_impl_assoc_type_incorrect_case_ignored);
             return;
         }
-
         // Check the type alias name.
         let data = self.db.type_alias_signature(type_alias_id);
         self.create_incorrect_case_diagnostic_for_item_name(
         );
     }
 
-    fn create_incorrect_case_diagnostic_for_item_name<N, S, L>(
-        &mut self,
-        item_id: L,
-        name: &Name,
-        expected_case: CaseType,
-        ident_type: IdentType,
-    ) where
+    fn create_incorrect_case_diagnostic_for_item_name<N, S, L>(&mut self, item_id: L, name: &Name, expected_case: CaseType, ident_type: IdentType)
+    where
         N: AstNode + HasName + fmt::Debug,
         S: HasSource<Value = N>,
-        L: Lookup<Data = S, Database = dyn DefDatabase> + HasModule + Copy,
-    {
+        L: Lookup<Data = S, Database = dyn DefDatabase> + HasModule + Copy, {
         let to_expected_case_type = match expected_case {
             CaseType::LowerSnakeCase => to_lower_snake_case,
             CaseType::UpperSnakeCase => to_upper_snake_case,
         else {
             return;
         };
-
         let item_loc = item_id.lookup(self.db);
         let item_src = item_loc.source(self.db);
         self.create_incorrect_case_diagnostic_for_ast_node(
         );
     }
 
-    fn create_incorrect_case_diagnostic_for_ast_node<T>(
-        &mut self,
-        replacement: Replacement,
-        file_id: HirFileId,
-        node: &T,
-        ident_type: IdentType,
-    ) where
-        T: AstNode + HasName + fmt::Debug,
-    {
+    fn create_incorrect_case_diagnostic_for_ast_node<T>(&mut self, replacement: Replacement, file_id: HirFileId, node: &T, ident_type: IdentType)
+    where
+        T: AstNode + HasName + fmt::Debug, {
         let Some(name_ast) = node.name() else {
             never!(
                 "Replacement ({:?}) was generated for a {:?} without a name: {:?}",
             );
             return;
         };
-
         let edition = file_id.original_file(self.db).edition(self.db);
         let diagnostic = IncorrectCase {
             file: file_id,
             ident_text: replacement.current_name.display(self.db, edition).to_string(),
             suggested_text: replacement.suggested_text,
         };
-
         self.sink.push(diagnostic);
     }
 