COMPARISON DIFF
============================================================

Original size: 33616 bytes
Chloro size:   33583 bytes
Rustfmt size:  33768 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! This module contains functions to generate default trait impl function bodies where possible.
 
 use hir::TraitRef;
-use syntax::ast::{self, edit::AstNodeEdit, make, AstNode, BinaryOp, CmpOp, HasName, LogicOp};
-
+use syntax::ast::{self, AstNode, BinaryOp, CmpOp, HasName, LogicOp, edit::AstNodeEdit, make};
 /// Generate custom trait bodies without default implementation where possible.
 ///
 /// If `func` is defined within an existing impl block, pass [`TraitRef`]. Otherwise pass `None`.
 /// Returns `Option` so that we can use `?` rather than `if let Some`. Returning
 /// `None` means that generating a custom trait body failed, and the body will remain
 /// as `todo!` instead.
-pub(crate) fn gen_trait_fn_body(
-    func: &ast::Fn,
-    trait_path: &ast::Path,
-    adt: &ast::Adt,
-    trait_ref: Option<TraitRef<'_>>,
-) -> Option<ast::BlockExpr> {
+pub(crate) fn gen_trait_fn_body(func: &ast::Fn, trait_path: &ast::Path, adt: &ast::Adt, trait_ref: Option<TraitRef<'_>>) -> Option<ast::BlockExpr> {
     let _ = func.body()?;
     match trait_path.segment()?.name_ref()?.text().as_str() {
         "Clone" => {
         let expr = make::expr_method_call(target, method, make::arg_list(Some(arg))).into();
         make::expr_stmt(expr).into()
     }
-
     let body = match adt {
         // `Hash` cannot be derived for unions, so no default impl can be provided.
         ast::Adt::Union(_) => return None,
             None => return None,
         },
     };
-
     Some(body)
 }
 
 fn gen_partial_eq(adt: &ast::Adt, trait_ref: Option<TraitRef<'_>>) -> Option<ast::BlockExpr> {
     fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {
         match expr {
-            Some(expr) => Some(make::expr_bin_op(
-                expr,
-                BinaryOp::LogicOp(LogicOp::And),
-                cmp,
-            )),
+            Some(expr) => Some(make::expr_bin_op(expr, BinaryOp::LogicOp(LogicOp::And), cmp)),
             None => Some(cmp),
         }
     }
-
     fn gen_record_pat_field(field_name: &str, pat_name: &str) -> ast::RecordPatField {
         let pat = make::ext::simple_ident_pat(make::name(pat_name));
         let name_ref = make::name_ref(field_name);
         make::record_pat_field(name_ref, pat.into())
     }
-
     fn gen_record_pat(record_name: ast::Path, fields: Vec<ast::RecordPatField>) -> ast::RecordPat {
         let list = make::record_pat_field_list(fields, None);
         make::record_pat_with_fields(record_name, list)
     }
-
     fn gen_variant_path(variant: &ast::Variant) -> Option<ast::Path> {
         make::ext::path_from_idents(["Self", &variant.name()?.to_string()])
     }
-
     fn gen_tuple_field(field_name: &str) -> ast::Pat {
         ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))
     }
-
     // Check that self type and rhs type match. We don't know how to implement the method
     // automatically otherwise.
     if let Some(trait_ref) = trait_ref {
             return None;
         }
     }
-
     let body = match adt {
         // `PartialEq` cannot be derived for unions, so no default impl can be provided.
         ast::Adt::Union(_) => return None,
             }
         },
     };
-
     Some(body)
 }
 
     fn gen_partial_eq_match(match_target: ast::Expr) -> Option<ast::Stmt> {
         let mut arms = vec![];
 
-        let variant_name = make::path_pat(make::ext::path_from_idents([
-            "core", "cmp", "Ordering", "Equal",
-        ])?);
+        let variant_name =
+            make::path_pat(make::ext::path_from_idents(["core", "cmp", "Ordering", "Equal"])?);
         let lhs = make::tuple_struct_pat(make::ext::path_from_idents(["Some"])?, [variant_name]);
-        arms.push(make::match_arm(
-            lhs.into(),
-            None,
-            make::expr_empty_block().into(),
-        ));
+        arms.push(make::match_arm(lhs.into(), None, make::expr_empty_block().into()));
 
         arms.push(make::match_arm(
             make::ident_pat(false, false, make::name("ord")).into(),
         let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));
         Some(make::expr_stmt(make::expr_match(match_target, list).into()).into())
     }
-
     fn gen_partial_cmp_call(lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {
         let rhs = make::expr_ref(rhs, false);
         let method = make::name_ref("partial_cmp");
         make::expr_method_call(lhs, method, make::arg_list(Some(rhs))).into()
     }
-
     // Check that self type and rhs type match. We don't know how to implement the method
     // automatically otherwise.
     if let Some(trait_ref) = trait_ref {
             return None;
         }
     }
-
     let body = match adt {
         // `PartialOrd` cannot be derived for unions, so no default impl can be provided.
         ast::Adt::Union(_) => return None,
             }
         },
     };
-
     Some(body)
 }
 
 fn make_discriminant() -> Option<ast::Expr> {
-    Some(make::expr_path(make::ext::path_from_idents([
-        "core",
-        "mem",
-        "discriminant",
-    ])?))
+    Some(make::expr_path(make::ext::path_from_idents(["core", "mem", "discriminant"])?))
 }