COMPARISON DIFF
============================================================

Original size: 5732 bytes
Chloro size:   5386 bytes
Rustfmt size:  5732 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use ide_db::assists::AssistId;
 use syntax::{
-    ast::{self, syntax_factory::SyntaxFactory},
     AstNode, SyntaxToken, T,
+    ast::{self, syntax_factory::SyntaxFactory},
 };
 
 use crate::{AssistContext, Assists};
 
-// Assist: toggle_macro_delimiter
-//
-// Change macro delimiters in the order of `( -> { -> [ -> (`.
-//
-// ```
-// macro_rules! sth {
-//     () => {};
-// }
-//
-// sth!$0( );
-// ```
-// ->
-// ```
-// macro_rules! sth {
-//     () => {};
-// }
-//
-// sth!{ }
-// ```
-pub(crate) fn toggle_macro_delimiter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn toggle_macro_delimiter(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     #[derive(Debug)]
     enum MacroDelims {
         LPar,
         LCur,
         RCur,
     }
-
     let makro = ctx.find_node_at_offset::<ast::MacroCall>()?;
-
     let cursor_offset = ctx.offset();
     let semicolon = macro_semicolon(&makro);
     let token_tree = makro.token_tree()?;
-
     let ltoken = token_tree.left_delimiter_token()?;
     let rtoken = token_tree.right_delimiter_token()?;
-
     if !ltoken.text_range().contains(cursor_offset) && !rtoken.text_range().contains(cursor_offset)
     {
         return None;
     }
-
     let token = match ltoken.kind() {
         T!['{'] => MacroDelims::LCur,
         T!['('] => MacroDelims::LPar,
         T!['}'] => MacroDelims::RCur,
         _ => return None,
     };
-
     acc.add(
         AssistId::refactor("toggle_macro_delimiter"),
         match token {
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_par() {
         check_assist(
 sth!{ }
             "#,
         );
-
         check_assist(
             toggle_macro_delimiter,
             r#"
             "#,
         );
     }
-
     #[test]
     fn test_braces() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn test_brackets() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn test_indent() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn test_unrelated_par() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn test_longer_macros() {
         check_assist(
 "#,
         )
     }
-
-    // FIXME @alibektas : Inner macro_call is not seen as such. So this doesn't work.
     #[test]
     fn test_nested_macros() {
         check_assist_not_applicable(