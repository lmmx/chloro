COMPARISON DIFF
============================================================

Original size: 144317 bytes
Chloro size:   142367 bytes
Rustfmt size:  144317 bytes

✗ Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`
 //! representation.
 
-mod asm;
-mod generics;
-mod path;
-
 use std::mem;
 
 use base_db::FxIndexSet;
         RefType, TraitBoundModifier, TraitRef, TypeBound, TypeRef, TypeRefId, UseArgRef,
     },
 };
-
 pub use self::path::hir_segment_to_ast_segment;
 
-pub(super) fn lower_body(
-    db: &dyn DefDatabase,
-    owner: DefWithBodyId,
-    current_file_id: HirFileId,
-    module: ModuleId,
-    parameters: Option<ast::ParamList>,
-    body: Option<ast::Expr>,
-    is_async_fn: bool,
-) -> (Body, BodySourceMap) {
+mod asm;
+
+mod generics;
+
+mod path;
+
+pub(super) fn lower_body(db: &dyn DefDatabase, owner: DefWithBodyId, current_file_id: HirFileId, module: ModuleId, parameters: Option<ast::ParamList>, body: Option<ast::Expr>, is_async_fn: bool) -> (Body, BodySourceMap) {
     // We cannot leave the root span map empty and let any identifier from it be treated as root,
     // because when inside nested macros `SyntaxContextId`s from the outer macro will be interleaved
     // with the inner macro, and that will cause confusion because they won't be the same as `ROOT`
     // even though they should be the same. Also, when the body comes from multiple expansions, their
     // hygiene is different.
-
     let mut self_param = None;
     let mut source_map_self_param = None;
     let mut params = vec![];
     let mut collector = ExprCollector::new(db, module, current_file_id);
-
     let skip_body = match owner {
         DefWithBodyId::FunctionId(it) => db.attrs(it.into()),
         DefWithBodyId::StaticId(it) => db.attrs(it.into()),
             BodySourceMap { self_param: source_map_self_param, store: source_map },
         );
     }
-
     if let Some(param_list) = parameters {
         if let Some(self_param_syn) = param_list.self_param().filter(|it| collector.check_cfg(it)) {
             let is_mutable =
             }
         }
     };
-
     let body_expr = collector.collect(
         body,
         if is_async_fn {
             }
         },
     );
-
     let (store, source_map) = collector.store.finish();
     (
         Body { store, params: params.into_boxed_slice(), self_param, body_expr },
     )
 }
 
-pub(crate) fn lower_type_ref(
-    db: &dyn DefDatabase,
-    module: ModuleId,
-    type_ref: InFile<Option<ast::Type>>,
-) -> (ExpressionStore, ExpressionStoreSourceMap, TypeRefId) {
+pub(crate) fn lower_type_ref(db: &dyn DefDatabase, module: ModuleId, type_ref: InFile<Option<ast::Type>>) -> (ExpressionStore, ExpressionStoreSourceMap, TypeRefId) {
     let mut expr_collector = ExprCollector::new(db, module, type_ref.file_id);
     let type_ref =
         expr_collector.lower_type_ref_opt(type_ref.value, &mut ExprCollector::impl_trait_allocator);
     (store, source_map, type_ref)
 }
 
-pub(crate) fn lower_generic_params(
-    db: &dyn DefDatabase,
-    module: ModuleId,
-    def: GenericDefId,
-    file_id: HirFileId,
-    param_list: Option<ast::GenericParamList>,
-    where_clause: Option<ast::WhereClause>,
-) -> (Arc<ExpressionStore>, Arc<GenericParams>, ExpressionStoreSourceMap) {
+pub(crate) fn lower_generic_params(db: &dyn DefDatabase, module: ModuleId, def: GenericDefId, file_id: HirFileId, param_list: Option<ast::GenericParamList>, where_clause: Option<ast::WhereClause>) -> (Arc<ExpressionStore>, Arc<GenericParams>, ExpressionStoreSourceMap) {
     let mut expr_collector = ExprCollector::new(db, module, file_id);
     let mut collector = generics::GenericParamsCollector::new(def);
     collector.lower(&mut expr_collector, param_list, where_clause);
     (Arc::new(store), params, source_map)
 }
 
-pub(crate) fn lower_impl(
-    db: &dyn DefDatabase,
-    module: ModuleId,
-    impl_syntax: InFile<ast::Impl>,
-    impl_id: ImplId,
-) -> (ExpressionStore, ExpressionStoreSourceMap, TypeRefId, Option<TraitRef>, Arc<GenericParams>) {
+pub(crate) fn lower_impl(db: &dyn DefDatabase, module: ModuleId, impl_syntax: InFile<ast::Impl>, impl_id: ImplId) -> (ExpressionStore, ExpressionStoreSourceMap, TypeRefId, Option<TraitRef>, Arc<GenericParams>) {
     let mut expr_collector = ExprCollector::new(db, module, impl_syntax.file_id);
     let self_ty =
         expr_collector.lower_type_ref_opt_disallow_impl_trait(impl_syntax.value.self_ty());
     (store, source_map, self_ty, trait_, params)
 }
 
-pub(crate) fn lower_trait(
-    db: &dyn DefDatabase,
-    module: ModuleId,
-    trait_syntax: InFile<ast::Trait>,
-    trait_id: TraitId,
-) -> (ExpressionStore, ExpressionStoreSourceMap, Arc<GenericParams>) {
+pub(crate) fn lower_trait(db: &dyn DefDatabase, module: ModuleId, trait_syntax: InFile<ast::Trait>, trait_id: TraitId) -> (ExpressionStore, ExpressionStoreSourceMap, Arc<GenericParams>) {
     let mut expr_collector = ExprCollector::new(db, module, trait_syntax.file_id);
     let mut collector = generics::GenericParamsCollector::with_self_param(
         &mut expr_collector,
     (store, source_map, params)
 }
 
-pub(crate) fn lower_type_alias(
-    db: &dyn DefDatabase,
-    module: ModuleId,
-    alias: InFile<ast::TypeAlias>,
-    type_alias_id: TypeAliasId,
-) -> (
+pub(crate) fn lower_type_alias(db: &dyn DefDatabase, module: ModuleId, alias: InFile<ast::TypeAlias>, type_alias_id: TypeAliasId) -> (
     ExpressionStore,
     ExpressionStoreSourceMap,
     Arc<GenericParams>,
     (store, source_map, params, bounds, type_ref)
 }
 
-pub(crate) fn lower_function(
-    db: &dyn DefDatabase,
-    module: ModuleId,
-    fn_: InFile<ast::Fn>,
-    function_id: FunctionId,
-) -> (
+pub(crate) fn lower_function(db: &dyn DefDatabase, module: ModuleId, fn_: InFile<ast::Fn>, function_id: FunctionId) -> (
     ExpressionStore,
     ExpressionStoreSourceMap,
     Arc<GenericParams>,
     let return_type = fn_.value.ret_type().map(|ret_type| {
         expr_collector.lower_type_ref_opt(ret_type.ty(), &mut ExprCollector::impl_trait_allocator)
     });
-
     let return_type = if fn_.value.async_token().is_some() {
         let path = hir_expand::mod_path::path![core::future::Future];
         let mut generic_args: Vec<_> =
     local_def_map: &'db LocalDefMap,
     module: ModuleId,
     pub store: ExpressionStoreBuilder,
-
-    // state stuff
-    // Prevent nested impl traits like `impl Foo<impl Bar>`.
     outer_impl_trait: bool,
-
     is_lowering_coroutine: bool,
-
     /// Legacy (`macro_rules!`) macros can have multiple definitions and shadow each other,
     /// and we need to find the current definition. So we track the number of definitions we saw.
     current_block_legacy_macro_defs_count: FxHashMap<Name, usize>,
-
     current_try_block_label: Option<LabelId>,
-
     label_ribs: Vec<LabelRib>,
     current_binding_owner: Option<ExprId>,
-
     awaitable_context: Option<Awaitable>,
 }
 
 }
 
 impl BindingList {
-    fn find(
-        &mut self,
-        ec: &mut ExprCollector<'_>,
-        name: Name,
-        hygiene: HygieneId,
-        mode: BindingAnnotation,
-    ) -> BindingId {
+    fn find(&mut self, ec: &mut ExprCollector<'_>, name: Name, hygiene: HygieneId, mode: BindingAnnotation) -> BindingId {
         let id = *self
             .map
             .entry((name, hygiene))
 }
 
 impl ExprCollector<'_> {
-    pub fn new(
-        db: &dyn DefDatabase,
-        module: ModuleId,
-        current_file_id: HirFileId,
-    ) -> ExprCollector<'_> {
+    pub fn new(db: &dyn DefDatabase, module: ModuleId, current_file_id: HirFileId) -> ExprCollector<'_> {
         let (def_map, local_def_map) = module.local_def_map(db);
         let expander = Expander::new(db, current_file_id, def_map);
         ExprCollector {
     }
 
     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.
-    pub fn lower_type_ref(
-        &mut self,
-        node: ast::Type,
-        impl_trait_lower_fn: ImplTraitLowerFn<'_>,
-    ) -> TypeRefId {
+    pub fn lower_type_ref(&mut self, node: ast::Type, impl_trait_lower_fn: ImplTraitLowerFn<'_>) -> TypeRefId {
         let ty = match &node {
             ast::Type::ParenType(inner) => {
                 return self.lower_type_ref_opt(inner.ty(), impl_trait_lower_fn);
         self.lower_type_ref(node, &mut Self::impl_trait_error_allocator)
     }
 
-    pub(crate) fn lower_type_ref_opt(
-        &mut self,
-        node: Option<ast::Type>,
-        impl_trait_lower_fn: ImplTraitLowerFn<'_>,
-    ) -> TypeRefId {
+    pub(crate) fn lower_type_ref_opt(&mut self, node: Option<ast::Type>, impl_trait_lower_fn: ImplTraitLowerFn<'_>) -> TypeRefId {
         match node {
             Some(node) => self.lower_type_ref(node, impl_trait_lower_fn),
             None => self.alloc_error_type(),
         }
     }
 
-    pub(crate) fn lower_type_ref_opt_disallow_impl_trait(
-        &mut self,
-        node: Option<ast::Type>,
-    ) -> TypeRefId {
+    pub(crate) fn lower_type_ref_opt_disallow_impl_trait(&mut self, node: Option<ast::Type>) -> TypeRefId {
         self.lower_type_ref_opt(node, &mut Self::impl_trait_error_allocator)
     }
 
         id
     }
 
-    fn alloc_lifetime_ref(
-        &mut self,
-        lifetime_ref: LifetimeRef,
-        node: LifetimePtr,
-    ) -> LifetimeRefId {
+    fn alloc_lifetime_ref(&mut self, lifetime_ref: LifetimeRef, node: LifetimePtr) -> LifetimeRefId {
         let id = self.store.lifetimes.alloc(lifetime_ref);
         let ptr = self.expander.in_file(node);
         self.store.lifetime_map_back.insert(id, ptr);
         self.store.types.alloc(TypeRef::Error)
     }
 
-    pub fn lower_path(
-        &mut self,
-        ast: ast::Path,
-        impl_trait_lower_fn: ImplTraitLowerFn<'_>,
-    ) -> Option<Path> {
+    pub fn lower_path(&mut self, ast: ast::Path, impl_trait_lower_fn: ImplTraitLowerFn<'_>) -> Option<Path> {
         super::lower::path::lower_path(self, ast, impl_trait_lower_fn)
     }
 
-    fn with_outer_impl_trait_scope<R>(
-        &mut self,
-        impl_trait: bool,
-        f: impl FnOnce(&mut Self) -> R,
-    ) -> R {
+    fn with_outer_impl_trait_scope<R>(&mut self, impl_trait: bool, f: impl FnOnce(&mut Self) -> R) -> R {
         let old = mem::replace(&mut self.outer_impl_trait, impl_trait);
         let result = f(self);
         self.outer_impl_trait = old;
         result
     }
 
-    pub fn impl_trait_error_allocator(
-        ec: &mut ExprCollector<'_>,
-        ptr: TypePtr,
-        _: ThinVec<TypeBound>,
-    ) -> TypeRefId {
+    pub fn impl_trait_error_allocator(ec: &mut ExprCollector<'_>, ptr: TypePtr, _: ThinVec<TypeBound>) -> TypeRefId {
         ec.alloc_type_ref(TypeRef::Error, ptr)
     }
 
-    fn impl_trait_allocator(
-        ec: &mut ExprCollector<'_>,
-        ptr: TypePtr,
-        bounds: ThinVec<TypeBound>,
-    ) -> TypeRefId {
+    fn impl_trait_allocator(ec: &mut ExprCollector<'_>, ptr: TypePtr, bounds: ThinVec<TypeBound>) -> TypeRefId {
         ec.alloc_type_ref(TypeRef::ImplTrait(bounds), ptr)
     }
 
 
     /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)
     /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).
-    pub fn lower_generic_args_from_fn_path(
-        &mut self,
-        args: Option<ast::ParenthesizedArgList>,
-        ret_type: Option<ast::RetType>,
-        impl_trait_lower_fn: ImplTraitLowerFn<'_>,
-    ) -> Option<GenericArgs> {
+    pub fn lower_generic_args_from_fn_path(&mut self, args: Option<ast::ParenthesizedArgList>, ret_type: Option<ast::RetType>, impl_trait_lower_fn: ImplTraitLowerFn<'_>) -> Option<GenericArgs> {
         let params = args?;
         let mut param_types = Vec::new();
         for param in params.type_args() {
         })
     }
 
-    pub(super) fn lower_generic_args(
-        &mut self,
-        node: ast::GenericArgList,
-        impl_trait_lower_fn: ImplTraitLowerFn<'_>,
-    ) -> Option<GenericArgs> {
+    pub(super) fn lower_generic_args(&mut self, node: ast::GenericArgList, impl_trait_lower_fn: ImplTraitLowerFn<'_>) -> Option<GenericArgs> {
         // This needs to be kept in sync with `hir_generic_arg_to_ast()`.
         let mut args = Vec::new();
         let mut bindings = Vec::new();
                 }
             }
         }
-
         if args.is_empty() && bindings.is_empty() {
             return None;
         }
         })
     }
 
-    fn type_bounds_from_ast(
-        &mut self,
-        type_bounds_opt: Option<ast::TypeBoundList>,
-        impl_trait_lower_fn: ImplTraitLowerFn<'_>,
-    ) -> ThinVec<TypeBound> {
+    fn type_bounds_from_ast(&mut self, type_bounds_opt: Option<ast::TypeBoundList>, impl_trait_lower_fn: ImplTraitLowerFn<'_>) -> ThinVec<TypeBound> {
         if let Some(type_bounds) = type_bounds_opt {
             ThinVec::from_iter(Vec::from_iter(
                 type_bounds.bounds().map(|it| self.lower_type_bound(it, impl_trait_lower_fn)),
         }
     }
 
-    fn lower_path_type(
-        &mut self,
-        path_type: &ast::PathType,
-        impl_trait_lower_fn: ImplTraitLowerFn<'_>,
-    ) -> Option<Path> {
+    fn lower_path_type(&mut self, path_type: &ast::PathType, impl_trait_lower_fn: ImplTraitLowerFn<'_>) -> Option<Path> {
         let path = self.lower_path(path_type.path()?, impl_trait_lower_fn)?;
         Some(path)
     }
 
-    fn lower_type_bound(
-        &mut self,
-        node: ast::TypeBound,
-        impl_trait_lower_fn: ImplTraitLowerFn<'_>,
-    ) -> TypeBound {
+    fn lower_type_bound(&mut self, node: ast::TypeBound, impl_trait_lower_fn: ImplTraitLowerFn<'_>) -> TypeBound {
         match node.kind() {
             ast::TypeBoundKind::PathType(binder, path_type) => {
                 let binder = match binder.and_then(|it| it.generic_param_list()) {
         if !self.check_cfg(&expr) {
             return None;
         }
-
         // FIXME: Move some of these arms out into separate methods for clarity
         Some(match expr {
             ast::Expr::IfExpr(e) => {
             return None;
         }
         let syntax_ptr = AstPtr::new(expr);
-
         let result = match expr {
             ast::Expr::UnderscoreExpr(_) => self.alloc_pat_from_expr(Pat::Wild, syntax_ptr),
             ast::Expr::ParenExpr(e) => {
             _ => return None,
         };
         return Some(result);
-
         fn collect_path(this: &mut ExprCollector<'_>, expr: ast::Expr) -> Option<ast::PathExpr> {
             match expr {
                 ast::Expr::PathExpr(e) => Some(e),
                 _ => None,
             }
         }
-
         fn collect_possibly_rest(
             this: &mut ExprCollector<'_>,
             expr: ast::Expr,
                 _ => Either::Left(this.collect_expr_as_pat(expr)),
             }
         }
-
         fn collect_tuple(
             this: &mut ExprCollector<'_>,
             fields: ast::AstChildren<ast::Expr>,
         }
     }
 
-    fn initialize_binding_owner(
-        &mut self,
-        syntax_ptr: AstPtr<ast::Expr>,
-    ) -> (ExprId, Option<ExprId>) {
+    fn initialize_binding_owner(&mut self, syntax_ptr: AstPtr<ast::Expr>) -> (ExprId, Option<ExprId>) {
         let result_expr_id = self.alloc_expr(Expr::Missing, syntax_ptr);
         let prev_binding_owner = self.current_binding_owner.take();
         self.current_binding_owner = Some(result_expr_id);
-
         (result_expr_id, prev_binding_owner)
     }
 
     /// it is used only for const blocks and repeat expressions, which are also hacky and ideally should have
     /// their own body. Don't add more usage for this function so that we can remove this function after
     /// separating those bodies.
-    fn collect_as_a_binding_owner_bad(
-        &mut self,
-        job: impl FnOnce(&mut ExprCollector<'_>) -> ExprId,
-        syntax_ptr: AstPtr<ast::Expr>,
-    ) -> ExprId {
+    fn collect_as_a_binding_owner_bad(&mut self, job: impl FnOnce(&mut ExprCollector<'_>) -> ExprId, syntax_ptr: AstPtr<ast::Expr>) -> ExprId {
         let (id, prev_owner) = self.initialize_binding_owner(syntax_ptr);
         let tmp = job(self);
         self.store.exprs[id] = mem::replace(&mut self.store.exprs[tmp], Expr::Missing);
             name: Name::generate_new_name(self.store.labels.len()),
         });
         let old_label = self.current_try_block_label.replace(label);
-
         let ptr = AstPtr::new(&e).upcast();
         let (btail, expr_id) = self.with_labeled_rib(label, HygieneId::ROOT, |this| {
             let mut btail = None;
             });
             (btail, block)
         });
-
         let callee = self
             .alloc_expr_desugared_with_ptr(try_from_output.map_or(Expr::Missing, Expr::Path), ptr);
         let next_tail = match btail {
             (self.hygiene_id_for(label.syntax().text_range()), self.collect_label(label))
         });
         let body = self.collect_labelled_block_opt(label, e.loop_body());
-
         // Labels can also be used in the condition expression, like this:
         // ```
         // fn main() {
             }),
             None => self.collect_expr_opt(e.condition()),
         };
-
         let break_expr = self.alloc_expr(Expr::Break { expr: None, label: None }, syntax_ptr);
         let if_expr = self.alloc_expr(
             Expr::If { condition, then_branch: body, else_branch: Some(break_expr) },
         self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)
     }
 
-    fn collect_macro_call<T, U>(
-        &mut self,
-        mcall: ast::MacroCall,
-        syntax_ptr: AstPtr<ast::MacroCall>,
-        record_diagnostics: bool,
-        collector: impl FnOnce(&mut Self, Option<T>) -> U,
-    ) -> U
+    fn collect_macro_call<T, U>(&mut self, mcall: ast::MacroCall, syntax_ptr: AstPtr<ast::MacroCall>, record_diagnostics: bool, collector: impl FnOnce(&mut Self, Option<T>) -> U) -> U
     where
-        T: ast::AstNode,
-    {
+        T: ast::AstNode, {
         let macro_call_ptr = self.expander.in_file(syntax_ptr);
         let module = self.module.local_id;
-
         let block_call = self.def_map.modules[self.module.local_id].scope.macro_invoc(
             self.expander.in_file(self.expander.ast_id_map().ast_id_for_ptr(syntax_ptr)),
         );
                 )
             }
         };
-
         let res = match res {
             Ok(res) => res,
             Err(UnresolvedMacro { path }) => {
             }
         };
         // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
-
         match res.value {
             Some((mark, expansion)) => {
                 // Keep collecting even with expansion errors so we can provide completions and
         }
     }
 
-    fn collect_macro_as_stmt(
-        &mut self,
-        statements: &mut Vec<Statement>,
-        mac: ast::MacroExpr,
-    ) -> Option<ExprId> {
+    fn collect_macro_as_stmt(&mut self, statements: &mut Vec<Statement>, mac: ast::MacroExpr) -> Option<ExprId> {
         let mac_call = mac.macro_call()?;
         let syntax_ptr = AstPtr::new(&ast::Expr::from(mac));
         let macro_ptr = AstPtr::new(&mac_call);
         })
     }
 
-    fn collect_block_(
-        &mut self,
-        block: ast::BlockExpr,
-        mk_block: impl FnOnce(Option<BlockId>, Box<[Statement]>, Option<ExprId>) -> Expr,
-    ) -> ExprId {
+    fn collect_block_(&mut self, block: ast::BlockExpr, mk_block: impl FnOnce(Option<BlockId>, Box<[Statement]>, Option<ExprId>) -> Expr) -> ExprId {
         let block_id = self.expander.ast_id_map().ast_id_for_block(&block).map(|file_local_id| {
             let ast_id = self.expander.in_file(file_local_id);
             self.db.intern_block(BlockLoc { ast_id, module: self.module })
         });
-
         let (module, def_map) =
             match block_id.map(|block_id| (block_def_map(self.db, block_id), block_id)) {
                 Some((def_map, block_id)) => {
         let prev_def_map = mem::replace(&mut self.def_map, def_map);
         let prev_local_module = mem::replace(&mut self.module, module);
         let prev_legacy_macros_count = mem::take(&mut self.current_block_legacy_macro_defs_count);
-
         let mut statements = Vec::new();
         block.statements().for_each(|s| self.collect_stmt(&mut statements, s));
         let tail = block.tail_expr().and_then(|e| match e {
             statements.push(stmt);
             None
         });
-
         let syntax_node_ptr = AstPtr::new(&block.into());
         let expr_id = self
             .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);
-
         self.def_map = prev_def_map;
         self.module = prev_local_module;
         self.current_block_legacy_macro_defs_count = prev_legacy_macros_count;
         }
     }
 
-    fn collect_labelled_block_opt(
-        &mut self,
-        label: Option<(HygieneId, LabelId)>,
-        expr: Option<ast::BlockExpr>,
-    ) -> ExprId {
+    fn collect_labelled_block_opt(&mut self, label: Option<(HygieneId, LabelId)>, expr: Option<ast::BlockExpr>) -> ExprId {
         match label {
             Some((hygiene, label)) => {
                 self.with_labeled_rib(label, hygiene, |this| this.collect_block_opt(expr))
             None => self.collect_block_opt(expr),
         }
     }
-
     // region: patterns
 
     fn collect_pat_top(&mut self, pat: Option<ast::Pat>) -> PatId {
         }
     }
 
-    fn collect_tuple_pat(
-        &mut self,
-        args: AstChildren<ast::Pat>,
-        has_leading_comma: bool,
-        binding_list: &mut BindingList,
-    ) -> (Box<[PatId]>, Option<u32>) {
+    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>, has_leading_comma: bool, binding_list: &mut BindingList) -> (Box<[PatId]>, Option<u32>) {
         let args: Vec<_> = args.map(|p| self.collect_pat_possibly_rest(p, binding_list)).collect();
         // Find the location of the `..`, if there is one. Note that we do not
         // consider the possibility of there being multiple `..` here.
         let ellipsis = args.iter().position(|p| p.is_right()).map(|it| it as u32);
-
         // We want to skip the `..` pattern here, since we account for it above.
         let mut args: Vec<_> = args.into_iter().filter_map(Either::left).collect();
         // if there is a leading comma, the user is most likely to type out a leading pattern
         if has_leading_comma {
             args.insert(0, self.missing_pat());
         }
-
         (args.into_boxed_slice(), ellipsis)
     }
 
-    // `collect_pat` rejects `ast::Pat::RestPat`, but it should be handled in some cases that
-    // it is the macro expansion result of an arg sub-pattern in a slice or tuple pattern.
-    fn collect_pat_possibly_rest(
-        &mut self,
-        pat: ast::Pat,
-        binding_list: &mut BindingList,
-    ) -> Either<PatId, ()> {
+    fn collect_pat_possibly_rest(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> Either<PatId, ()> {
         match &pat {
             ast::Pat::RestPat(_) => Either::Right(()),
             ast::Pat::MacroPat(mac) => match mac.macro_call() {
             _ => Either::Left(self.collect_pat(pat, binding_list)),
         }
     }
-
     // endregion: patterns
 
     /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when
     fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {
         self.store.binding_definitions.entry(binding_id).or_default().push(pat_id);
     }
-
     // region: labels
 
     fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {
         self.alloc_label(label, AstPtr::new(&ast_label))
     }
 
-    fn resolve_label(
-        &self,
-        lifetime: Option<ast::Lifetime>,
-    ) -> Result<Option<LabelId>, ExpressionStoreDiagnostics> {
+    fn resolve_label(&self, lifetime: Option<ast::Lifetime>) -> Result<Option<LabelId>, ExpressionStoreDiagnostics> {
         let Some(lifetime) = lifetime else { return Ok(None) };
         let mut hygiene_id =
             self.expander.hygiene_for_range(self.db, lifetime.syntax().text_range());
             })
         };
         let name = Name::new_lifetime(&lifetime.text());
-
         for (rib_idx, rib) in self.label_ribs.iter().enumerate().rev() {
             match &rib.kind {
                 RibKind::Normal(label_name, id, label_hygiene) => {
                 _ => {}
             }
         }
-
         Err(ExpressionStoreDiagnostics::UndeclaredLabel {
             name,
             node: self.expander.in_file(AstPtr::new(&lifetime)),
         res
     }
 
-    fn with_labeled_rib<T>(
-        &mut self,
-        label: LabelId,
-        hygiene: HygieneId,
-        f: impl FnOnce(&mut Self) -> T,
-    ) -> T {
+    fn with_labeled_rib<T>(&mut self, label: LabelId, hygiene: HygieneId, f: impl FnOnce(&mut Self) -> T) -> T {
         self.label_ribs.push(LabelRib::new(RibKind::Normal(
             self.store.labels[label].name.clone(),
             label,
         res
     }
 
-    fn with_opt_labeled_rib<T>(
-        &mut self,
-        label: Option<(HygieneId, LabelId)>,
-        f: impl FnOnce(&mut Self) -> T,
-    ) -> T {
+    fn with_opt_labeled_rib<T>(&mut self, label: Option<(HygieneId, LabelId)>, f: impl FnOnce(&mut Self) -> T) -> T {
         match label {
             None => f(self),
             Some((hygiene, label)) => self.with_labeled_rib(label, hygiene, f),
     }
     // endregion: labels
 
-    // region: format
     fn expand_macros_to_string(&mut self, expr: ast::Expr) -> Option<(ast::String, bool)> {
         let m = match expr {
             ast::Expr::MacroExpr(m) => m,
         Some((exp, false))
     }
 
-    fn collect_format_args(
-        &mut self,
-        f: ast::FormatArgsExpr,
-        syntax_ptr: AstPtr<ast::Expr>,
-    ) -> ExprId {
+    fn collect_format_args(&mut self, f: ast::FormatArgsExpr, syntax_ptr: AstPtr<ast::Expr>) -> ExprId {
         let mut args = FormatArgumentsCollector::default();
         f.args().for_each(|arg| {
             args.add(FormatArgument {
                 HygieneId::ROOT,
             ),
         };
-
         // Create a list of all _unique_ (argument, format trait) combinations.
         // E.g. "{0} {0:x} {0} {1}" -> [(0, Display), (0, LowerHex), (1, Display)]
         let mut argmap = FxIndexSet::default();
                 argmap.insert((index, ArgumentType::Format(placeholder.format_trait)));
             }
         }
-
         let lit_pieces = fmt
             .template
             .iter()
                 mutability: Mutability::Shared,
             })
         };
-
         // Assume that rustc version >= 1.89.0 iff lang item `format_arguments` exists
         // but `format_unsafe_arg` does not
         let fmt_args =
         let fmt_unsafe_arg =
             || crate::lang_item::lang_item(self.db, self.module.krate(), LangItem::FormatUnsafeArg);
         let use_format_args_since_1_89_0 = fmt_args().is_some() && fmt_unsafe_arg().is_none();
-
         let idx = if use_format_args_since_1_89_0 {
             self.collect_format_args_impl(syntax_ptr, fmt, argmap, lit_pieces, format_options)
         } else {
                 format_options,
             )
         };
-
         self.store
             .template_map
             .get_or_insert_with(Default::default)
     }
 
     /// `format_args!` expansion implementation for rustc versions < `1.89.0`
-    fn collect_format_args_before_1_89_0_impl(
-        &mut self,
-        syntax_ptr: AstPtr<ast::Expr>,
-        fmt: FormatArgs,
-        argmap: FxIndexSet<(usize, ArgumentType)>,
-        lit_pieces: ExprId,
-        format_options: ExprId,
-    ) -> ExprId {
+    fn collect_format_args_before_1_89_0_impl(&mut self, syntax_ptr: AstPtr<ast::Expr>, fmt: FormatArgs, argmap: FxIndexSet<(usize, ArgumentType)>, lit_pieces: ExprId, format_options: ExprId) -> ExprId {
         let arguments = &*fmt.arguments.arguments;
-
         let args = if arguments.is_empty() {
             let expr = self
                 .alloc_expr_desugared(Expr::Array(Array::ElementList { elements: Box::default() }));
                 mutability: Mutability::Shared,
             })
         };
-
         // Generate:
         //     <core::fmt::Arguments>::new_v1_formatted(
         //         lit_pieces,
         //         format_options,
         //         unsafe { ::core::fmt::UnsafeArg::new() }
         //     )
-
         let new_v1_formatted = LangItem::FormatArguments.ty_rel_path(
             self.db,
             self.module.krate(),
         );
         let new_v1_formatted =
             self.alloc_expr_desugared(new_v1_formatted.map_or(Expr::Missing, Expr::Path));
-
         let unsafe_arg_new =
             self.alloc_expr_desugared(unsafe_arg_new.map_or(Expr::Missing, Expr::Path));
         let unsafe_arg_new =
                 label: None,
             });
         }
-
         self.alloc_expr(
             Expr::Call {
                 callee: new_v1_formatted,
 
     /// `format_args!` expansion implementation for rustc versions >= `1.89.0`,
     /// especially since [this PR](https://github.com/rust-lang/rust/pull/140748)
-    fn collect_format_args_impl(
-        &mut self,
-        syntax_ptr: AstPtr<ast::Expr>,
-        fmt: FormatArgs,
-        argmap: FxIndexSet<(usize, ArgumentType)>,
-        lit_pieces: ExprId,
-        format_options: ExprId,
-    ) -> ExprId {
+    fn collect_format_args_impl(&mut self, syntax_ptr: AstPtr<ast::Expr>, fmt: FormatArgs, argmap: FxIndexSet<(usize, ArgumentType)>, lit_pieces: ExprId, format_options: ExprId) -> ExprId {
         let arguments = &*fmt.arguments.arguments;
-
         let (let_stmts, args) = if arguments.is_empty() {
             (
                 // Generate:
             };
             (vec![let_stmt1, let_stmt2], self.alloc_expr_desugared(Expr::Path(args_name.into())))
         };
-
         // Generate:
         //     &args
         let args = self.alloc_expr_desugared(Expr::Ref {
             rawness: Rawness::Ref,
             mutability: Mutability::Shared,
         });
-
         let call_block = {
             // Generate:
             //     unsafe {
 
             Expr::Unsafe { id: None, statements: Box::default(), tail: Some(call) }
         };
-
         if !let_stmts.is_empty() {
             // Generate:
             //     {
     ///         <core::fmt::rt::Count::…>, // precision
     ///     )
     /// ```
-    fn make_format_spec(
-        &mut self,
-        placeholder: &FormatPlaceholder,
-        argmap: &mut FxIndexSet<(usize, ArgumentType)>,
-    ) -> ExprId {
+    fn make_format_spec(&mut self, placeholder: &FormatPlaceholder, argmap: &mut FxIndexSet<(usize, ArgumentType)>) -> ExprId {
         let position = match placeholder.argument.index {
             Ok(arg_index) => {
                 let (i, _) =
             zero_pad,
             debug_hex,
         } = &placeholder.format_options;
-
         let precision_expr = self.make_count(precision, argmap);
         let width_expr = self.make_count(width, argmap);
-
         if self.module.krate().workspace_data(self.db).is_atleast_187() {
             // These need to match the constants in library/core/src/fmt/rt.rs.
             let align = match alignment {
     /// ```text
     ///     <core::fmt::rt::Count>::Implied
     /// ```
-    fn make_count(
-        &mut self,
-        count: &Option<FormatCount>,
-        argmap: &mut FxIndexSet<(usize, ArgumentType)>,
-    ) -> ExprId {
+    fn make_count(&mut self, count: &Option<FormatCount>, argmap: &mut FxIndexSet<(usize, ArgumentType)>) -> ExprId {
         match count {
             Some(FormatCount::Literal(n)) => {
                 let args = self.alloc_expr_desugared(Expr::Literal(Literal::Uint(
     fn make_argument(&mut self, arg: ExprId, ty: ArgumentType) -> ExprId {
         use ArgumentType::*;
         use FormatTrait::*;
-
         let new_fn = match LangItem::FormatArgument.ty_rel_path(
             self.db,
             self.module.krate(),
         };
         self.alloc_expr_desugared(Expr::Call { callee: new_fn, args: Box::new([arg]) })
     }
-
     // endregion: format
 
     fn lang_path(&self, lang: LangItem) -> Option<Path> {
         self.store.expr_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed.
-    // Migrate to alloc_expr_desugared_with_ptr and then rename back
+
     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {
         self.store.exprs.alloc(expr)
     }
+
     fn alloc_expr_desugared_with_ptr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         // self.store.expr_map.insert(src, id);
         id
     }
+
     fn missing_expr(&mut self) -> ExprId {
         self.alloc_expr_desugared(Expr::Missing)
     }
 
-    fn alloc_binding(
-        &mut self,
-        name: Name,
-        mode: BindingAnnotation,
-        hygiene: HygieneId,
-    ) -> BindingId {
+    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation, hygiene: HygieneId) -> BindingId {
         let binding = self.store.bindings.alloc(Binding { name, mode, problems: None, hygiene });
         if let Some(owner) = self.current_binding_owner {
             self.store.binding_owners.insert(binding, owner);
         self.store.pat_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.
+
     fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {
         self.store.pats.alloc(pat)
     }
+
     fn missing_pat(&mut self) -> PatId {
         self.store.pats.alloc(Pat::Missing)
     }
         self.store.label_map.insert(src, id);
         id
     }
-    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.
+
     fn alloc_label_desugared(&mut self, label: Label) -> LabelId {
         self.store.labels.alloc(label)
     }
         self.awaitable_context.as_ref().unwrap_or(&Awaitable::No("unknown"))
     }
 
-    fn with_awaitable_block<T>(
-        &mut self,
-        awaitable: Awaitable,
-        f: impl FnOnce(&mut Self) -> T,
-    ) -> T {
+    fn with_awaitable_block<T>(&mut self, awaitable: Awaitable, f: impl FnOnce(&mut Self) -> T) -> T {
         let orig = self.awaitable_context.replace(awaitable);
         let res = f(self);
         self.awaitable_context = orig;
 }
 
 /// This function find the AST fragment that corresponds to an `AssociatedTypeBinding` in the HIR.
-pub fn hir_assoc_type_binding_to_ast(
-    segment_args: &ast::GenericArgList,
-    binding_idx: u32,
-) -> Option<ast::AssocTypeArg> {
+pub fn hir_assoc_type_binding_to_ast(segment_args: &ast::GenericArgList, binding_idx: u32) -> Option<ast::AssocTypeArg> {
     segment_args
         .generic_args()
         .filter_map(|arg| match arg {
 }
 
 /// This function find the AST generic argument from the one in the HIR. Does not support the `Self` argument.
-pub fn hir_generic_arg_to_ast(
-    args: &ast::GenericArgList,
-    arg_idx: u32,
-    has_self_arg: bool,
-) -> Option<ast::GenericArg> {
+pub fn hir_generic_arg_to_ast(args: &ast::GenericArgList, arg_idx: u32, has_self_arg: bool) -> Option<ast::GenericArg> {
     args.generic_args()
         .filter(|arg| match arg {
             ast::GenericArg::AssocTypeArg(_) => false,