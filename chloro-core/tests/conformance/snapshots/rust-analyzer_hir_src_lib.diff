COMPARISON DIFF
============================================================

Original size: 227843 bytes
Chloro size:   223735 bytes
Rustfmt size:  227843 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! from the ide with completions, hovers, etc. It is a (soft, internal) boundary:
 //! <https://www.tedinski.com/2018/02/06/system-boundaries.html>.
 
-#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
-#![recursion_limit = "512"]
-
-extern crate ra_ap_rustc_type_ir as rustc_type_ir;
-
-mod attrs;
-mod from_id;
-mod has_source;
-mod semantics;
-mod source_analyzer;
-
-pub mod db;
-pub mod diagnostics;
-pub mod symbols;
-pub mod term_search;
-
-mod display;
-
-#[doc(hidden)]
-pub use hir_def::ModuleId;
-
 use std::{
     fmt,
     mem::discriminant,
 use arrayvec::ArrayVec;
 use base_db::{CrateDisplayName, CrateOrigin, LangCrateOrigin};
 use either::Either;
+pub use hir_def::ModuleId;
 use hir_def::{
     AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
     CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
     AstId, MacroCallKind, RenderedExpandError, ValueResult, attrs::collect_attrs,
     proc_macro::ProcMacroKind,
 };
+pub use hir_ty::next_solver;
+pub use hir_ty::setup_tracing;
 use hir_ty::{
     TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId, all_super_traits, autoderef,
     check_orphan_rules,
     format_smolstr,
 };
 use triomphe::{Arc, ThinArc};
-
-use crate::db::{DefDatabase, HirDatabase};
-
-pub use crate::{
-    attrs::{HasAttrs, resolve_doc_path_on},
-    diagnostics::*,
-    has_source::HasSource,
-    semantics::{
-        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
-        VisibleTraits,
-    },
-};
-
-// Be careful with these re-exports.
-//
-// `hir` is the boundary between the compiler and the IDE. It should try hard to
-// isolate the compiler from the ide, to allow the two to be refactored
-// independently. Re-exporting something from the compiler is the sure way to
-// breach the boundary.
-//
-// Generally, a refactoring which *removes* a name from this list is a good
-// idea!
 pub use {
     cfg::{CfgAtom, CfgExpr, CfgOptions},
     hir_def::{
     },
     intern::{Symbol, sym},
 };
-
-// These are negative re-exports: pub using these names is forbidden, they
-// should remain private to hir internals.
-#[allow(unused)]
 use {
     hir_def::expr_store::path::Path,
     hir_expand::{
     },
 };
 
+use crate::db::{DefDatabase, HirDatabase};
+pub use crate::{
+    attrs::{HasAttrs, resolve_doc_path_on},
+    diagnostics::*,
+    has_source::HasSource,
+    semantics::{
+        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
+        VisibleTraits,
+    },
+};
+#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
+#![recursion_limit = "512"]
+mod attrs;
+
+mod from_id;
+
+mod has_source;
+
+mod semantics;
+
+mod source_analyzer;
+
+pub mod db;
+
+pub mod diagnostics;
+
+pub mod symbols;
+
+pub mod term_search;
+
+mod display;
+
 /// hir::Crate describes a single crate. It's the main interface with which
 /// a crate's dependencies interact. Mostly, it should be just a proxy for the
 /// root module.
             .collect()
     }
 
-    pub fn transitive_reverse_dependencies(
-        self,
-        db: &dyn HirDatabase,
-    ) -> impl Iterator<Item = Crate> {
+    pub fn transitive_reverse_dependencies(self, db: &dyn HirDatabase) -> impl Iterator<Item = Crate> {
         db.transitive_rev_deps(self.id).into_iter().map(|id| Crate { id })
     }
 
         self.id.extra_data(db).display_name.clone()
     }
 
-    pub fn query_external_importables(
-        self,
-        db: &dyn DefDatabase,
-        query: import_map::Query,
-    ) -> impl Iterator<Item = (Either<ModuleDef, Macro>, Complete)> {
+    pub fn query_external_importables(self, db: &dyn DefDatabase, query: import_map::Query) -> impl Iterator<Item = (Either<ModuleDef, Macro>, Complete)> {
         let _p = tracing::info_span!("query_external_importables").entered();
         import_map::search_dependencies(db, self.into(), &query).into_iter().map(
             |(item, do_not_complete)| {
     Module(Module),
     Function(Function),
     Adt(Adt),
-    // Can't be directly declared, but can be imported.
-    // FIXME: Rename to `EnumVariant`
     Variant(Variant),
     Const(Const),
     Static(Static),
     BuiltinType(BuiltinType),
     Macro(Macro),
 }
-impl_from!(
-    Module,
-    Function,
-    Adt(Struct, Enum, Union),
-    Variant,
-    Const,
-    Static,
-    Trait,
-    TypeAlias,
-    BuiltinType,
-    Macro
-    for ModuleDef
-);
-
 impl From<VariantDef> for ModuleDef {
     fn from(var: VariantDef) -> Self {
         match var {
         Some(segments.iter().map(|it| it.display(db, edition)).join("::"))
     }
 
-    pub fn canonical_module_path(
-        &self,
-        db: &dyn HirDatabase,
-    ) -> Option<impl Iterator<Item = Module>> {
+    pub fn canonical_module_path(&self, db: &dyn HirDatabase) -> Option<impl Iterator<Item = Module>> {
         self.module(db).map(|it| it.path_to_root(db).into_iter().rev())
     }
 
         Some(name)
     }
 
-    pub fn diagnostics<'db>(
-        self,
-        db: &'db dyn HirDatabase,
-        style_lints: bool,
-    ) -> Vec<AnyDiagnostic<'db>> {
+    pub fn diagnostics<'db>(self, db: &'db dyn HirDatabase, style_lints: bool) -> Vec<AnyDiagnostic<'db>> {
         let id = match self {
             ModuleDef::Adt(it) => match it {
                 Adt::Struct(it) => it.id.into(),
             ModuleDef::Variant(it) => it.id.into(),
             ModuleDef::BuiltinType(_) | ModuleDef::Macro(_) => return Vec::new(),
         };
-
         let mut acc = Vec::new();
-
         match self.as_def_with_body() {
             Some(def) => {
                 def.diagnostics(db, &mut acc, style_lints);
                 }
             }
         }
-
         if let Some(def) = self.as_self_generic_def() {
             def.diagnostics(db, &mut acc);
         }
-
         acc
     }
 
     }
 
     /// Returns a `ModuleScope`: a set of items, visible in this module.
-    pub fn scope(
-        self,
-        db: &dyn HirDatabase,
-        visible_from: Option<Module>,
-    ) -> Vec<(Name, ScopeDef)> {
+    pub fn scope(self, db: &dyn HirDatabase, visible_from: Option<Module>) -> Vec<(Name, ScopeDef)> {
         self.id.def_map(db)[self.id.local_id]
             .scope
             .entries()
             .collect()
     }
 
-    pub fn resolve_mod_path(
-        &self,
-        db: &dyn HirDatabase,
-        segments: impl IntoIterator<Item = Name>,
-    ) -> Option<impl Iterator<Item = ItemInNs>> {
+    pub fn resolve_mod_path(&self, db: &dyn HirDatabase, segments: impl IntoIterator<Item = Name>) -> Option<impl Iterator<Item = ItemInNs>> {
         let items = self
             .id
             .resolver(db)
     }
 
     /// Fills `acc` with the module's diagnostics.
-    pub fn diagnostics<'db>(
-        self,
-        db: &'db dyn HirDatabase,
-        acc: &mut Vec<AnyDiagnostic<'db>>,
-        style_lints: bool,
-    ) {
+    pub fn diagnostics<'db>(self, db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>, style_lints: bool) {
         let _p = tracing::info_span!("diagnostics", name = ?self.name(db)).entered();
         let edition = self.id.krate().data(db).edition;
         let def_map = self.id.def_map(db);
             }
             emit_def_diagnostic(db, acc, diag, edition);
         }
-
         if !self.id.is_block_module() {
             // These are reported by the body of block modules
             let scope = &def_map[self.id.local_id].scope;
             scope.all_macro_calls().for_each(|it| macro_call_diagnostics(db, it, acc));
         }
-
         for def in self.declarations(db) {
             match def {
                 ModuleDef::Module(m) => {
             }
         }
         self.legacy_macros(db).into_iter().for_each(|m| emit_macro_def_diagnostics(db, acc, m));
-
         let inherent_impls = db.inherent_impls_in_crate(self.id.krate());
-
         let interner = DbInterner::new_with(db, Some(self.id.krate()), self.id.containing_block());
         let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
-
         let mut impl_assoc_items_scratch = vec![];
         for impl_def in self.impl_defs(db) {
             GenericDef::Impl(impl_def).diagnostics(db, acc);
 
     /// Finds a path that can be used to refer to the given item from within
     /// this module, if possible.
-    pub fn find_path(
-        self,
-        db: &dyn DefDatabase,
-        item: impl Into<ItemInNs>,
-        cfg: FindPathConfig,
-    ) -> Option<ModPath> {
+    pub fn find_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>, cfg: FindPathConfig) -> Option<ModPath> {
         hir_def::find_path::find_path(
             db,
             item.into().into(),
 
     /// Finds a path that can be used to refer to the given item from within
     /// this module, if possible. This is used for returning import paths for use-statements.
-    pub fn find_use_path(
-        self,
-        db: &dyn DefDatabase,
-        item: impl Into<ItemInNs>,
-        prefix_kind: PrefixKind,
-        cfg: FindPathConfig,
-    ) -> Option<ModPath> {
+    pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>, prefix_kind: PrefixKind, cfg: FindPathConfig) -> Option<ModPath> {
         hir_def::find_path::find_path(db, item.into().into(), self.into(), prefix_kind, true, cfg)
     }
 }
 
-fn macro_call_diagnostics<'db>(
-    db: &'db dyn HirDatabase,
-    macro_call_id: MacroCallId,
-    acc: &mut Vec<AnyDiagnostic<'db>>,
-) {
+fn macro_call_diagnostics<'db>(db: &'db dyn HirDatabase, macro_call_id: MacroCallId, acc: &mut Vec<AnyDiagnostic<'db>>) {
     let Some(e) = db.parse_macro_expansion_error(macro_call_id) else {
         return;
     };
         };
         acc.push(MacroError { node, precise_location, message, error, kind }.into());
     }
-
     if !parse_errors.is_empty() {
         let loc = db.lookup_intern_macro_call(macro_call_id);
         let (node, precise_location) = precise_macro_call_location(&loc.kind, db);
     }
 }
 
-fn emit_macro_def_diagnostics<'db>(
-    db: &'db dyn HirDatabase,
-    acc: &mut Vec<AnyDiagnostic<'db>>,
-    m: Macro,
-) {
+fn emit_macro_def_diagnostics<'db>(db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>, m: Macro) {
     let id = db.macro_def(m.id);
     if let hir_expand::db::TokenExpander::DeclarativeMacro(expander) = db.macro_expander(id)
         && let Some(e) = expander.mac.err()
     }
 }
 
-fn emit_def_diagnostic<'db>(
-    db: &'db dyn HirDatabase,
-    acc: &mut Vec<AnyDiagnostic<'db>>,
-    diag: &DefDiagnostic,
-    edition: Edition,
-) {
+fn emit_def_diagnostic<'db>(db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>, diag: &DefDiagnostic, edition: Edition) {
     emit_def_diagnostic_(db, acc, &diag.kind, edition)
 }
 
-fn emit_def_diagnostic_<'db>(
-    db: &'db dyn HirDatabase,
-    acc: &mut Vec<AnyDiagnostic<'db>>,
-    diag: &DefDiagnosticKind,
-    edition: Edition,
-) {
+fn emit_def_diagnostic_<'db>(db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>, diag: &DefDiagnosticKind, edition: Edition) {
     match diag {
         DefDiagnosticKind::UnresolvedModule { ast: declaration, candidates } => {
             let decl = declaration.to_ptr(db);
     }
 }
 
-fn precise_macro_call_location(
-    ast: &MacroCallKind,
-    db: &dyn HirDatabase,
-) -> (InFile<SyntaxNodePtr>, Option<TextRange>) {
+fn precise_macro_call_location(ast: &MacroCallKind, db: &dyn HirDatabase) -> (InFile<SyntaxNodePtr>, Option<TextRange>) {
     // FIXME: maybe we actually want slightly different ranges for the different macro diagnostics
     // - e.g. the full attribute for macro errors, but only the name for name resolution
     match ast {
     pub fn ty(&self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let var_id = self.inner.parent.into();
         let field = db.field_types(var_id)[self.inner.id];
         let ty = field.instantiate(interner, self.args);
 impl AstNode for FieldSource {
     fn can_cast(kind: syntax::SyntaxKind) -> bool
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         ast::RecordField::can_cast(kind) || ast::TupleField::can_cast(kind)
     }
 
     fn cast(syntax: SyntaxNode) -> Option<Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         if ast::RecordField::can_cast(syntax.kind()) {
             <ast::RecordField as AstNode>::cast(syntax).map(FieldSource::Named)
         } else if ast::TupleField::can_cast(syntax.kind()) {
         TypeNs::new(db, var_id, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
-    pub fn ty_with_args<'db>(
-        &self,
-        db: &'db dyn HirDatabase,
-        generics: impl Iterator<Item = Type<'db>>,
-    ) -> Type<'db> {
+    pub fn ty_with_args<'db>(&self, db: &'db dyn HirDatabase, generics: impl Iterator<Item = Type<'db>>) -> Type<'db> {
         let var_id = self.parent.into();
         let def_id: AdtId = match self.parent {
             VariantDef::Struct(it) => it.id.into(),
     pub fn ty(self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let ty = db.ty(self.inner.id.into());
         TypeNs::new(db, self.inner.id, ty.instantiate(interner, self.args))
     }
             .map(|(id, _)| Field { parent: self.into(), id })
             .collect()
     }
+
     pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
     pub fn ty(self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let ty = db.ty(self.inner.id.into());
         TypeNs::new(db, self.inner.id, ty.instantiate(interner, self.args))
     }
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Variant {
     pub(crate) id: EnumVariantId,
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct InstantiatedVariant<'db> {
     pub(crate) inner: Variant,
     Union(Union),
     Enum(Enum),
 }
-impl_from!(Struct, Union, Enum for Adt);
-
 impl Adt {
     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {
         has_non_default_type_params(db, self.into())
 
     /// Turns this ADT into a type with the given type parameters. This isn't
     /// the greatest API, FIXME find a better one.
-    pub fn ty_with_args<'db>(
-        self,
-        db: &'db dyn HirDatabase,
-        args: impl IntoIterator<Item = Type<'db>>,
-    ) -> Type<'db> {
+    pub fn ty_with_args<'db>(self, db: &'db dyn HirDatabase, args: impl IntoIterator<Item = Type<'db>>) -> Type<'db> {
         let id = AdtId::from(self);
         let interner = DbInterner::new_with(db, None, None);
         let ty = Ty::new_adt(
     Union(Union),
     Variant(Variant),
 }
-impl_from!(Struct, Union, Variant for VariantDef);
-
 impl VariantDef {
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
         match self {
     Const(Const),
     Variant(Variant),
 }
-impl_from!(Function, Const, Static, Variant for DefWithBody);
-
 impl DefWithBody {
     pub fn module(self, db: &dyn HirDatabase) -> Module {
         match self {
         }
     }
 
-    pub fn diagnostics<'db>(
-        self,
-        db: &'db dyn HirDatabase,
-        acc: &mut Vec<AnyDiagnostic<'db>>,
-        style_lints: bool,
-    ) {
+    pub fn diagnostics<'db>(self, db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>, style_lints: bool) {
         let krate = self.module(db).id.krate();
-
         let (body, source_map) = db.body_with_source_map(self.into());
         let sig_source_map = match self {
             DefWithBody::Function(id) => db.function_signature_with_source_map(id.into()).1,
                 db.enum_signature_with_source_map(enum_id).1
             }
         };
-
         for (_, def_map) in body.blocks(db) {
             Module { id: def_map.module_id(DefMap::ROOT) }.diagnostics(db, acc, style_lints);
         }
-
         expr_store_diagnostics(db, acc, &source_map);
-
         let infer = db.infer(self.into());
         for d in infer.diagnostics() {
             acc.extend(AnyDiagnostic::inference_diagnostic(
                 &sig_source_map,
             ));
         }
-
         for (pat_or_expr, mismatch) in infer.type_mismatches() {
             let expr_or_pat = match pat_or_expr {
                 ExprOrPatId::ExprId(expr) => source_map.expr_syntax(expr).map(Either::Left),
                 .into(),
             );
         }
-
         let missing_unsafe = hir_ty::diagnostics::missing_unsafe(db, self.into());
         for (node, reason) in missing_unsafe.unsafe_exprs {
             match source_map.expr_or_pat_syntax(node) {
                 Err(SyntheticSyntax) => never!("synthetic DeprecatedSafe2024"),
             }
         }
-
         if let Ok(borrowck_results) = db.borrowck(self.into()) {
             for borrowck_result in borrowck_results.iter() {
                 let mir_body = &borrowck_result.mir_body;
                 }
             }
         }
-
         for diagnostic in BodyValidationDiagnostic::collect(db, self.into(), style_lints) {
             acc.extend(AnyDiagnostic::body_validation_diagnostic(db, diagnostic, &source_map));
         }
-
         let def: ModuleDef = match self {
             DefWithBody::Function(it) => it.into(),
             DefWithBody::Static(it) => it.into(),
     }
 }
 
-fn expr_store_diagnostics<'db>(
-    db: &'db dyn HirDatabase,
-    acc: &mut Vec<AnyDiagnostic<'db>>,
-    source_map: &ExpressionStoreSourceMap,
-) {
+fn expr_store_diagnostics<'db>(db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>, source_map: &ExpressionStoreSourceMap) {
     for diag in source_map.diagnostics() {
         acc.push(match diag {
             ExpressionStoreDiagnostics::InactiveCode { node, cfg, opts } => {
             }
         });
     }
-
     source_map
         .macro_calls()
         .for_each(|(_ast_id, call_id)| macro_call_diagnostics(db, call_id, acc));
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Function {
     pub(crate) id: FunctionId,
         let ty = Ty::new_fn_ptr(interner, callable_sig);
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
-
     // FIXME: Find a better API to express all combinations here, perhaps we should have `PreInstantiationType`?
 
     /// Get this function's return type
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
-    pub fn ret_type_with_args<'db>(
-        self,
-        db: &'db dyn HirDatabase,
-        generics: impl Iterator<Item = Type<'db>>,
-    ) -> Type<'db> {
+    pub fn ret_type_with_args<'db>(self, db: &'db dyn HirDatabase, generics: impl Iterator<Item = Type<'db>>) -> Type<'db> {
         let resolver = self.id.resolver(db);
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(interner, self.id.into(), generics.map(|ty| ty.ty));
-
         let interner = DbInterner::new_with(db, None, None);
         let ty = db
             .callable_item_signature(self.id.into())
             .collect()
     }
 
-    // FIXME: Find better API to also handle const generics
-    pub fn params_without_self_with_args<'db>(
-        self,
-        db: &'db dyn HirDatabase,
-        generics: impl Iterator<Item = Type<'db>>,
-    ) -> Vec<Param<'db>> {
+    pub fn params_without_self_with_args<'db>(self, db: &'db dyn HirDatabase, generics: impl Iterator<Item = Type<'db>>) -> Vec<Param<'db>> {
         let environment = db.trait_environment(self.id.into());
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(interner, self.id.into(), generics.map(|ty| ty.ty));
         if self.is_async(db) {
             return true;
         }
-
         let ret_type = self.ret_type(db);
         let Some(impl_traits) = ret_type.as_impl_traits(db) else { return false };
         let Some(future_trait_id) = LangItem::Future.resolve_trait(db, self.ty(db).env.krate)
         let Some(sized_trait_id) = LangItem::Sized.resolve_trait(db, self.ty(db).env.krate) else {
             return false;
         };
-
         let mut has_impl_future = false;
         impl_traits
             .filter(|t| {
         db.attrs(self.id.into()).is_unstable()
     }
 
-    pub fn is_unsafe_to_call(
-        self,
-        db: &dyn HirDatabase,
-        caller: Option<Function>,
-        call_edition: Edition,
-    ) -> bool {
+    pub fn is_unsafe_to_call(self, db: &dyn HirDatabase, caller: Option<Function>, call_edition: Edition) -> bool {
         let (target_features, target_feature_is_safe_in_target) = caller
             .map(|caller| {
                 let target_features =
         def_map.fn_as_proc_macro(self.id).map(|id| Macro { id: id.into() })
     }
 
-    pub fn eval(
-        self,
-        db: &dyn HirDatabase,
-        span_formatter: impl Fn(FileId, TextRange) -> String,
-    ) -> Result<String, ConstEvalError<'_>> {
+    pub fn eval(self, db: &dyn HirDatabase, span_formatter: impl Fn(FileId, TextRange) -> String) -> Result<String, ConstEvalError<'_>> {
         let interner = DbInterner::new_with(db, None, None);
         let body = db.monomorphized_mir_body(
             self.id.into(),
     }
 }
 
-// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum Access {
     Shared,
             _ => None,
         }
     }
-
     // pub fn parent_closure(&self) -> Option<Closure> {
     //     self.func.as_ref().right().cloned()
     // }
         Type { env: environment, ty }
     }
 
-    // FIXME: Find better API to also handle const generics
-    pub fn ty_with_args<'db>(
-        &self,
-        db: &'db dyn HirDatabase,
-        generics: impl Iterator<Item = Type<'db>>,
-    ) -> Type<'db> {
+    pub fn ty_with_args<'db>(&self, db: &'db dyn HirDatabase, generics: impl Iterator<Item = Type<'db>>) -> Type<'db> {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(interner, self.func.into(), generics.map(|ty| ty.ty));
         let callable_sig =
         db.trait_signature(self.id).flags.contains(TraitFlags::UNSAFE)
     }
 
-    pub fn type_or_const_param_count(
-        &self,
-        db: &dyn HirDatabase,
-        count_required_only: bool,
-    ) -> usize {
+    pub fn type_or_const_param_count(&self, db: &dyn HirDatabase, count_required_only: bool) -> usize {
         db.generic_params(self.id.into())
             .iter_type_or_consts()
             .filter(|(_, ty)| !matches!(ty, TypeOrConstParamData::TypeParamData(ty) if ty.provenance != TypeParamProvenance::TypeParamList))
         hir_ty::dyn_compatibility::dyn_compatibility(db, self.id)
     }
 
-    pub fn dyn_compatibility_all_violations(
-        &self,
-        db: &dyn HirDatabase,
-    ) -> Option<Vec<DynCompatibilityViolation>> {
+    pub fn dyn_compatibility_all_violations(&self, db: &dyn HirDatabase) -> Option<Vec<DynCompatibilityViolation>> {
         let mut violations = vec![];
         _ = hir_ty::dyn_compatibility::dyn_compatibility_with_callback(
             db,
 }
 
 impl BuiltinType {
-    // Constructors are added on demand, feel free to add more.
     pub fn str() -> BuiltinType {
         BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }
     }
     TypeAlias(TypeAlias),
 }
 
-pub trait AsExternAssocItem {
-    fn as_extern_assoc_item(self, db: &dyn HirDatabase) -> Option<ExternAssocItem>;
-}
+fn as_extern_assoc_item(self, db: &dyn HirDatabase) -> Option<ExternAssocItem>;
 
 impl AsExternAssocItem for Function {
     fn as_extern_assoc_item(self, db: &dyn HirDatabase) -> Option<ExternAssocItem> {
     Impl(Impl),
 }
 
-pub trait AsAssocItem {
-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem>;
-}
+fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem>;
 
 impl AsAssocItem for Function {
     fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {
     }
 }
 
-fn as_assoc_item<'db, ID, DEF, LOC>(
-    db: &(dyn HirDatabase + 'db),
-    ctor: impl FnOnce(DEF) -> AssocItem,
-    id: ID,
-) -> Option<AssocItem>
+fn as_assoc_item<'db, ID, DEF, LOC>(db: &(dyn HirDatabase + 'db), ctor: impl FnOnce(DEF) -> AssocItem, id: ID) -> Option<AssocItem>
 where
     ID: Lookup<Database = dyn DefDatabase, Data = AssocItemLoc<LOC>>,
     DEF: From<ID>,
-    LOC: AstIdNode,
-{
+    LOC: AstIdNode, {
     match id.lookup(db).container {
         ItemContainerId::TraitId(_) | ItemContainerId::ImplId(_) => Some(ctor(DEF::from(id))),
         ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => None,
     }
 }
 
-fn as_extern_assoc_item<'db, ID, DEF, LOC>(
-    db: &(dyn HirDatabase + 'db),
-    ctor: impl FnOnce(DEF) -> ExternAssocItem,
-    id: ID,
-) -> Option<ExternAssocItem>
+fn as_extern_assoc_item<'db, ID, DEF, LOC>(db: &(dyn HirDatabase + 'db), ctor: impl FnOnce(DEF) -> ExternAssocItem, id: ID) -> Option<ExternAssocItem>
 where
     ID: Lookup<Database = dyn DefDatabase, Data = AssocItemLoc<LOC>>,
     DEF: From<ID>,
-    LOC: AstIdNode,
-{
+    LOC: AstIdNode, {
     match id.lookup(db).container {
         ItemContainerId::ExternBlockId(_) => Some(ctor(DEF::from(id))),
         ItemContainerId::TraitId(_) | ItemContainerId::ImplId(_) | ItemContainerId::ModuleId(_) => {
         }
     }
 
-    pub fn diagnostics<'db>(
-        self,
-        db: &'db dyn HirDatabase,
-        acc: &mut Vec<AnyDiagnostic<'db>>,
-        style_lints: bool,
-    ) {
+    pub fn diagnostics<'db>(self, db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>, style_lints: bool) {
         match self {
             AssocItem::Function(func) => {
                 GenericDef::Function(func).diagnostics(db, acc);
     Trait(Trait),
     TypeAlias(TypeAlias),
     Impl(Impl),
-    // consts can have type parameters from their parents (i.e. associated consts of traits)
     Const(Const),
     Static(Static),
 }
-impl_from!(
-    Function,
-    Adt(Struct, Enum, Union),
-    Trait,
-    TypeAlias,
-    Impl,
-    Const,
-    Static
-    for GenericDef
-);
-
 impl GenericDef {
     pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {
         let generics = db.generic_params(self.into());
 
     pub fn diagnostics<'db>(self, db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>) {
         let def = self.id();
-
         let generics = db.generic_params(def);
-
         if generics.is_empty() && generics.has_no_predicates() {
             return;
         }
-
         let source_map = match def {
             GenericDefId::AdtId(AdtId::EnumId(it)) => db.enum_signature_with_source_map(it).1,
             GenericDefId::AdtId(AdtId::StructId(it)) => db.struct_signature_with_source_map(it).1,
             GenericDefId::TraitId(it) => db.trait_signature_with_source_map(it).1,
             GenericDefId::TypeAliasId(it) => db.type_alias_signature_with_source_map(it).1,
         };
-
         expr_store_diagnostics(db, acc, &source_map);
         push_ty_diagnostics(db, acc, db.generic_defaults_with_diagnostics(def).1, &source_map);
         push_ty_diagnostics(
     }
 }
 
-// We cannot call this `Substitution` unfortunately...
 #[derive(Debug)]
 pub struct GenericSubstitution<'db> {
     def: GenericDefId,
     ConstParam(ConstParam),
     LifetimeParam(LifetimeParam),
 }
-impl_from!(TypeParam, ConstParam, LifetimeParam for GenericParam);
-
 impl GenericParam {
     pub fn module(self, db: &dyn HirDatabase) -> Module {
         match self {
         Type::new(db, self.id.parent(), db.const_param_ty_ns(self.id))
     }
 
-    pub fn default(
-        self,
-        db: &dyn HirDatabase,
-        display_target: DisplayTarget,
-    ) -> Option<ast::ConstArg> {
+    pub fn default(self, db: &dyn HirDatabase, display_target: DisplayTarget) -> Option<ast::ConstArg> {
         let arg = generic_arg_from_param(db, self.id.into())?;
         known_const_to_ast(arg.konst()?, db, display_target)
     }
     pub fn all_in_crate(db: &dyn HirDatabase, krate: Crate) -> Vec<Impl> {
         let inherent = db.inherent_impls_in_crate(krate.id);
         let trait_ = db.trait_impls_in_crate(krate.id);
-
         inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()
     }
 
             Some(def_crates) => def_crates,
             None => return Vec::new(),
         };
-
         let filter = |impl_def: &Impl| {
             let self_ty = impl_def.self_ty(db);
             let rref = self_ty.remove_ref();
             ty.equals_ctor(rref.as_ref().map_or(self_ty.ty, |it| it.ty))
         };
-
         let fp = TyFingerprint::for_inherent_impl(ty);
         let fp = match fp {
             Some(fp) => fp,
             None => return Vec::new(),
         };
-
         let mut all = Vec::new();
         def_crates.iter().for_each(|&id| {
             all.extend(
                     .filter(filter),
             )
         });
-
         for id in def_crates
             .iter()
             .flat_map(|&id| Crate { id }.transitive_reverse_dependencies(db))
                     .filter(filter),
             );
         }
-
         if let Some(block) = ty.as_adt().and_then(|(def, _)| def.module(db).containing_block()) {
             if let Some(inherent_impls) = db.inherent_impls_in_block(block) {
                 all.extend(
                 );
             }
         }
-
         all
     }
 
 
     pub fn as_builtin_derive_path(self, db: &dyn HirDatabase) -> Option<InMacroFile<ast::Path>> {
         let src = self.source(db)?;
-
         let macro_file = src.file_id.macro_file()?;
         let loc = macro_file.lookup(db);
         let (derive_attr, derive_index) = match loc.kind {
 }
 
 impl<'db> TraitRef<'db> {
-    pub(crate) fn new_with_resolver(
-        db: &'db dyn HirDatabase,
-        resolver: &Resolver<'_>,
-        trait_ref: hir_ty::next_solver::TraitRef<'db>,
-    ) -> Self {
+    pub(crate) fn new_with_resolver(db: &'db dyn HirDatabase, resolver: &Resolver<'_>, trait_ref: hir_ty::next_solver::TraitRef<'db>) -> Self {
         let env = resolver
             .generic_def()
             .map_or_else(|| TraitEnvironment::empty(resolver.krate()), |d| db.trait_environment(d));
 impl CaptureUsages {
     pub fn sources(&self, db: &dyn HirDatabase) -> Vec<CaptureUsageSource> {
         let (body, source_map) = db.body_with_source_map(self.parent);
-
         let mut result = Vec::with_capacity(self.spans.len());
         for &span in self.spans.iter() {
             let is_ref = span.is_ref_span(&body);
 }
 
 impl<'db> Type<'db> {
-    pub(crate) fn new_with_resolver(
-        db: &'db dyn HirDatabase,
-        resolver: &Resolver<'_>,
-        ty: Ty<'db>,
-    ) -> Self {
+    pub(crate) fn new_with_resolver(db: &'db dyn HirDatabase, resolver: &Resolver<'_>, ty: Ty<'db>) -> Self {
         Type::new_with_resolver_inner(db, resolver, ty)
     }
 
-    pub(crate) fn new_with_resolver_inner(
-        db: &'db dyn HirDatabase,
-        resolver: &Resolver<'_>,
-        ty: Ty<'db>,
-    ) -> Self {
+    pub(crate) fn new_with_resolver_inner(db: &'db dyn HirDatabase, resolver: &Resolver<'_>, ty: Ty<'db>) -> Self {
         let environment = resolver
             .generic_def()
             .map_or_else(|| TraitEnvironment::empty(resolver.krate()), |d| db.trait_environment(d));
         Type::new(db, def, ty.instantiate(interner, args))
     }
 
-    // FIXME: We shouldn't leak `TyKind::Param`s.
     fn from_def_params(db: &'db dyn HirDatabase, def: impl Into<TyDefId> + HasResolver) -> Self {
         let ty = db.ty(def.into());
         Type::new(db, def, ty.instantiate_identity())
     }
 
-    fn from_value_def(
-        db: &'db dyn HirDatabase,
-        def: impl Into<ValueTyDefId> + HasResolver,
-    ) -> Self {
+    fn from_value_def(db: &'db dyn HirDatabase, def: impl Into<ValueTyDefId> + HasResolver) -> Self {
         let interner = DbInterner::new_with(db, None, None);
         let Some(ty) = db.value_ty(def.into()) else {
             return Type::new(db, def, Ty::new_error(interner, ErrorGuaranteed));
     pub fn contains_reference(&self, db: &'db dyn HirDatabase) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         return self.ty.visit_with(&mut Visitor { interner }).is_break();
-
         fn is_phantom_data(db: &dyn HirDatabase, adt_id: AdtId) -> bool {
             match adt_id {
                 AdtId::StructId(s) => {
                 AdtId::UnionId(_) | AdtId::EnumId(_) => false,
             }
         }
-
         struct Visitor<'db> {
             interner: DbInterner<'db>,
         }
-
         impl<'db> TypeVisitor<DbInterner<'db>> for Visitor<'db> {
             type Result = ControlFlow<()>;
 
         self.derived(self.ty.strip_references())
     }
 
-    // FIXME: This is the same as `remove_ref()`, remove one of these methods.
     pub fn strip_reference(&self) -> Self {
         self.derived(self.ty.strip_reference())
     }
                 Some(into_future_trait.id)
             })
             .or_else(|| LangItem::Future.resolve_trait(db, self.env.krate))?;
-
         if !traits::implements_trait_unique(self.ty, db, self.env.clone(), trait_) {
             return None;
         }
-
         let output_assoc_type =
             trait_.trait_items(db).associated_type_by_name(&Name::new_symbol_root(sym::Output))?;
         self.normalize_trait_assoc_type(db, &[], output_assoc_type.into())
                 Some(into_iter_trait.id)
             },
         )?;
-
         if !traits::implements_trait_unique(self.ty, db, self.env.clone(), trait_) {
             return None;
         }
-
         let into_iter_assoc_type = trait_
             .trait_items(db)
             .associated_type_by_name(&Name::new_symbol_root(sym::IntoIter))?;
             Some(it) => it,
             None => return false,
         };
-
         traits::implements_trait_unique(self.ty, db, self.env.clone(), fnonce_trait)
     }
 
-    // FIXME: Find better API that also handles const generics
     pub fn impls_trait(&self, db: &'db dyn HirDatabase, trait_: Trait, args: &[Type<'db>]) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(
         traits::implements_trait_unique_with_args(db, self.env.clone(), trait_.id, args)
     }
 
-    pub fn normalize_trait_assoc_type(
-        &self,
-        db: &'db dyn HirDatabase,
-        args: &[Type<'db>],
-        alias: TypeAlias,
-    ) -> Option<Type<'db>> {
+    pub fn normalize_trait_assoc_type(&self, db: &'db dyn HirDatabase, args: &[Type<'db>], alias: TypeAlias) -> Option<Type<'db>> {
         let interner = DbInterner::new_with(db, Some(self.env.krate), self.env.block);
         let args = generic_args_from_tys(
             interner,
             AliasTyKind::Projection,
             AliasTy::new(interner, alias.id.into(), args),
         );
-
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
         let ty = structurally_normalize_ty(&infcx, projection, self.env.clone());
         if ty.is_ty_error() { None } else { Some(self.derived(ty)) }
                 });
             }
         };
-
         let sig = self.ty.callable_sig(interner)?;
         Some(Callable { ty: self.clone(), sig, callee, is_bound_method: false })
     }
             TyKind::Adt(adt_def, ..) => adt_def.def_id().0,
             _ => return false,
         };
-
         let adt = adt_id.into();
         match adt {
             Adt::Struct(s) => s.repr(db).unwrap_or_default().pack.is_some(),
             }
             _ => return Vec::new(),
         };
-
         db.field_types(variant_id)
             .iter()
             .map(|(local_id, ty)| {
 
     /// Returns types that this type dereferences to (including this type itself). The returned
     /// iterator won't yield the same type more than once even if the deref chain contains a cycle.
-    pub fn autoderef(
-        &self,
-        db: &'db dyn HirDatabase,
-    ) -> impl Iterator<Item = Type<'db>> + use<'_, 'db> {
+    pub fn autoderef(&self, db: &'db dyn HirDatabase) -> impl Iterator<Item = Type<'db>> + use<'_, 'db> {
         self.autoderef_(db).map(move |ty| self.derived(ty))
     }
 
         autoderef(db, self.env.clone(), canonical)
     }
 
-    // This would be nicer if it just returned an iterator, but that runs into
-    // lifetime problems, because we need to borrow temp `CrateImplDefs`.
-    pub fn iterate_assoc_items<T>(
-        &self,
-        db: &'db dyn HirDatabase,
-        krate: Crate,
-        mut callback: impl FnMut(AssocItem) -> Option<T>,
-    ) -> Option<T> {
+    pub fn iterate_assoc_items<T>(&self, db: &'db dyn HirDatabase, krate: Crate, mut callback: impl FnMut(AssocItem) -> Option<T>) -> Option<T> {
         let mut slot = None;
         self.iterate_assoc_items_dyn(db, krate, &mut |assoc_item_id| {
             slot = callback(assoc_item_id.into());
         slot
     }
 
-    fn iterate_assoc_items_dyn(
-        &self,
-        db: &'db dyn HirDatabase,
-        krate: Crate,
-        callback: &mut dyn FnMut(AssocItemId) -> bool,
-    ) {
+    fn iterate_assoc_items_dyn(&self, db: &'db dyn HirDatabase, krate: Crate, callback: &mut dyn FnMut(AssocItemId) -> bool) {
         let ty_ns = self.ty;
         let def_crates = match method_resolution::def_crates(db, ty_ns, krate.id) {
             Some(it) => it,
     /// - "U"
     /// - "12"
     /// ```
-    pub fn type_and_const_arguments<'a>(
-        &'a self,
-        db: &'a dyn HirDatabase,
-        display_target: DisplayTarget,
-    ) -> impl Iterator<Item = SmolStr> + 'a {
+    pub fn type_and_const_arguments<'a>(&'a self, db: &'a dyn HirDatabase, display_target: DisplayTarget) -> impl Iterator<Item = SmolStr> + 'a {
         self.ty
             .strip_references()
             .as_adt()
     }
 
     /// Combines lifetime indicators, type and constant parameters into a single `Iterator`
-    pub fn generic_parameters<'a>(
-        &'a self,
-        db: &'a dyn HirDatabase,
-        display_target: DisplayTarget,
-    ) -> impl Iterator<Item = SmolStr> + 'a {
+    pub fn generic_parameters<'a>(&'a self, db: &'a dyn HirDatabase, display_target: DisplayTarget) -> impl Iterator<Item = SmolStr> + 'a {
         // iterate the lifetime
         self.as_adt()
             .and_then(|a| {
             .chain(self.type_and_const_arguments(db, display_target))
     }
 
-    pub fn iterate_method_candidates_with_traits<T>(
-        &self,
-        db: &'db dyn HirDatabase,
-        scope: &SemanticsScope<'_>,
-        traits_in_scope: &FxHashSet<TraitId>,
-        with_local_impls: Option<Module>,
-        name: Option<&Name>,
-        mut callback: impl FnMut(Function) -> Option<T>,
-    ) -> Option<T> {
+    pub fn iterate_method_candidates_with_traits<T>(&self, db: &'db dyn HirDatabase, scope: &SemanticsScope<'_>, traits_in_scope: &FxHashSet<TraitId>, with_local_impls: Option<Module>, name: Option<&Name>, mut callback: impl FnMut(Function) -> Option<T>) -> Option<T> {
         let _p = tracing::info_span!("iterate_method_candidates_with_traits").entered();
         let mut slot = None;
         self.iterate_method_candidates_split_inherent(
         slot
     }
 
-    pub fn iterate_method_candidates<T>(
-        &self,
-        db: &'db dyn HirDatabase,
-        scope: &SemanticsScope<'_>,
-        with_local_impls: Option<Module>,
-        name: Option<&Name>,
-        callback: impl FnMut(Function) -> Option<T>,
-    ) -> Option<T> {
+    pub fn iterate_method_candidates<T>(&self, db: &'db dyn HirDatabase, scope: &SemanticsScope<'_>, with_local_impls: Option<Module>, name: Option<&Name>, callback: impl FnMut(Function) -> Option<T>) -> Option<T> {
         self.iterate_method_candidates_with_traits(
             db,
             scope,
     ///
     /// Note that inherent methods may actually be trait methods! For example, in `dyn Trait`, the trait's methods
     /// are considered inherent methods.
-    pub fn iterate_method_candidates_split_inherent(
-        &self,
-        db: &'db dyn HirDatabase,
-        scope: &SemanticsScope<'_>,
-        traits_in_scope: &FxHashSet<TraitId>,
-        with_local_impls: Option<Module>,
-        name: Option<&Name>,
-        callback: impl MethodCandidateCallback,
-    ) {
+    pub fn iterate_method_candidates_split_inherent(&self, db: &'db dyn HirDatabase, scope: &SemanticsScope<'_>, traits_in_scope: &FxHashSet<TraitId>, with_local_impls: Option<Module>, name: Option<&Name>, callback: impl MethodCandidateCallback) {
         struct Callback<T>(T);
-
         impl<T: MethodCandidateCallback> method_resolution::MethodCandidateCallback for Callback<T> {
             fn on_inherent_method(
                 &mut self,
                 }
             }
         }
-
         let _p = tracing::info_span!(
             "iterate_method_candidates_dyn",
             with_local_impls = traits_in_scope.len(),
         let interner = DbInterner::new_with(db, None, None);
         // There should be no inference vars in types passed here
         let canonical = hir_ty::replace_errors_with_variables(interner, &self.ty);
-
         let krate = scope.krate();
         let environment = scope
             .resolver()
             .generic_def()
             .map_or_else(|| TraitEnvironment::empty(krate.id), |d| db.trait_environment(d));
-
         _ = method_resolution::iterate_method_candidates_dyn(
             &canonical,
             db,
     }
 
     #[tracing::instrument(skip_all, fields(name = ?name))]
-    pub fn iterate_path_candidates<T>(
-        &self,
-        db: &'db dyn HirDatabase,
-        scope: &SemanticsScope<'_>,
-        traits_in_scope: &FxHashSet<TraitId>,
-        with_local_impls: Option<Module>,
-        name: Option<&Name>,
-        mut callback: impl FnMut(AssocItem) -> Option<T>,
-    ) -> Option<T> {
+    pub fn iterate_path_candidates<T>(&self, db: &'db dyn HirDatabase, scope: &SemanticsScope<'_>, traits_in_scope: &FxHashSet<TraitId>, with_local_impls: Option<Module>, name: Option<&Name>, mut callback: impl FnMut(AssocItem) -> Option<T>) -> Option<T> {
         let _p = tracing::info_span!("iterate_path_candidates").entered();
         let mut slot = None;
-
         self.iterate_path_candidates_split_inherent(
             db,
             scope,
     /// For example, when `dyn Trait` is a receiver, _trait_'s methods would be considered
     /// to be inherent methods.
     #[tracing::instrument(skip_all, fields(name = ?name))]
-    pub fn iterate_path_candidates_split_inherent(
-        &self,
-        db: &'db dyn HirDatabase,
-        scope: &SemanticsScope<'_>,
-        traits_in_scope: &FxHashSet<TraitId>,
-        with_local_impls: Option<Module>,
-        name: Option<&Name>,
-        callback: impl PathCandidateCallback,
-    ) {
+    pub fn iterate_path_candidates_split_inherent(&self, db: &'db dyn HirDatabase, scope: &SemanticsScope<'_>, traits_in_scope: &FxHashSet<TraitId>, with_local_impls: Option<Module>, name: Option<&Name>, callback: impl PathCandidateCallback) {
         struct Callback<T>(T);
-
         impl<T: PathCandidateCallback> method_resolution::MethodCandidateCallback for Callback<T> {
             fn on_inherent_method(
                 &mut self,
                 self.0.on_trait_item(item.into())
             }
         }
-
         let interner = DbInterner::new_with(db, None, None);
         let canonical = hir_ty::replace_errors_with_variables(interner, &self.ty);
-
         let krate = scope.krate();
         let environment = scope
             .resolver()
             .generic_def()
             .map_or_else(|| TraitEnvironment::empty(krate.id), |d| db.trait_environment(d));
-
         _ = method_resolution::iterate_path_candidates(
             &canonical,
             db,
 
     /// If a type can be represented as `dyn Trait`, returns all traits accessible via this type,
     /// or an empty iterator otherwise.
-    pub fn applicable_inherent_traits(
-        &self,
-        db: &'db dyn HirDatabase,
-    ) -> impl Iterator<Item = Trait> {
+    pub fn applicable_inherent_traits(&self, db: &'db dyn HirDatabase) -> impl Iterator<Item = Trait> {
         let _p = tracing::info_span!("applicable_inherent_traits").entered();
         self.autoderef_(db)
             .filter_map(|ty| ty.dyn_trait())
                 ty.super_visit_with(self);
             }
         }
-
         let mut visitor =
             Visitor { db, env: self.env.clone(), callback, visited: FxHashSet::default() };
         self.ty.visit_with(&mut visitor);
     }
+
     /// Check if type unifies with another type.
     ///
     /// Note that we consider placeholder types to unify with everything.
         Type { env: self.env.clone(), ty: self.ty }
     }
 
-    // FIXME: Find better API that also handles const generics
     pub fn impls_trait(&self, infcx: InferCtxt<'db>, trait_: Trait, args: &[TypeNs<'db>]) -> bool {
         let args = GenericArgs::new_from_iter(
             infcx.interner,
             [self.ty].into_iter().chain(args.iter().map(|t| t.ty)).map(|t| t.into()),
         );
         let trait_ref = hir_ty::next_solver::TraitRef::new(infcx.interner, trait_.id.into(), args);
-
         let pred_kind = rustc_type_ir::Binder::dummy(rustc_type_ir::PredicateKind::Clause(
             rustc_type_ir::ClauseKind::Trait(rustc_type_ir::TraitPredicate {
                 trait_ref,
     }
 }
 
-// FIXME: Document this
 #[derive(Debug)]
 pub struct Callable<'db> {
     ty: Type<'db>,
             Callee::FnImpl(fn_) => CallableKind::FnImpl(fn_),
         }
     }
+
     pub fn receiver_param(&self, db: &'db dyn HirDatabase) -> Option<(SelfParam, Type<'db>)> {
         let func = match self.callee {
             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,
             self.ty.derived(self.sig.skip_binder().inputs_and_output.inputs()[0]),
         ))
     }
+
     pub fn n_params(&self) -> usize {
         self.sig.skip_binder().inputs_and_output.inputs().len()
             - if self.is_bound_method { 1 } else { 0 }
     }
+
     pub fn params(&self) -> Vec<Param<'db>> {
         self.sig
             .skip_binder()
             .map(|(idx, ty)| Param { func: self.callee.clone(), idx, ty })
             .collect()
     }
+
     pub fn return_type(&self) -> Type<'db> {
         self.ty.derived(self.sig.skip_binder().output())
     }
+
     pub fn sig(&self) -> impl Eq {
         &self.sig
     }
         }
     }
 
-    pub fn largest_padding(
-        &self,
-        field_size: &mut impl FnMut(usize) -> Option<u64>,
-    ) -> Option<u64> {
+    pub fn largest_padding(&self, field_size: &mut impl FnMut(usize) -> Option<u64>) -> Option<u64> {
         match self.0.fields {
             layout::FieldsShape::Primitive => None,
             layout::FieldsShape::Union(_) => None,
 impl ScopeDef {
     pub fn all_items(def: PerNs) -> ArrayVec<Self, 3> {
         let mut items = ArrayVec::new();
-
         match (def.take_types(), def.take_values()) {
             (Some(m1), None) => items.push(ScopeDef::ModuleDef(m1.into())),
             (None, Some(m2)) => items.push(ScopeDef::ModuleDef(m2.into())),
             }
             (None, None) => {}
         };
-
         if let Some(macro_def_id) = def.take_macros() {
             items.push(ScopeDef::ModuleDef(ModuleDef::Macro(macro_def_id.into())));
         }
-
         if items.is_empty() {
             items.push(ScopeDef::Unknown);
         }
-
         items
     }
 
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 pub struct OverloadedDeref(pub Mutability);
 
-pub trait HasVisibility {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility;
-    fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {
-        let vis = self.visibility(db);
-        vis.is_visible_from(db, module.id)
-    }
+fn visibility(&self, db: &dyn HirDatabase) -> Visibility;
+fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {
+    let vis = self.visibility(db);
+    vis.is_visible_from(db, module.id)
 }
 
 /// Trait for obtaining the defining crate of an item.
-pub trait HasCrate {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate;
-}
+fn krate(&self, db: &dyn HirDatabase) -> Crate;
 
 impl<T: hir_def::HasModule> HasCrate for T {
     fn krate(&self, db: &dyn HirDatabase) -> Crate {
     }
 }
 
-pub trait HasContainer {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer;
-}
+fn container(&self, db: &dyn HirDatabase) -> ItemContainer;
 
 impl HasContainer for ExternCrateDecl {
     fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
     SelfType(Trait),
 }
 
-fn push_ty_diagnostics<'db>(
-    db: &'db dyn HirDatabase,
-    acc: &mut Vec<AnyDiagnostic<'db>>,
-    diagnostics: Option<ThinArc<(), TyLoweringDiagnostic>>,
-    source_map: &ExpressionStoreSourceMap,
-) {
+fn push_ty_diagnostics<'db>(db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>, diagnostics: Option<ThinArc<(), TyLoweringDiagnostic>>, source_map: &ExpressionStoreSourceMap) {
     if let Some(diagnostics) = diagnostics {
         acc.extend(
             diagnostics
     }
 }
 
-pub trait MethodCandidateCallback {
-    fn on_inherent_method(&mut self, f: Function) -> ControlFlow<()>;
-
-    fn on_trait_method(&mut self, f: Function) -> ControlFlow<()>;
-}
+fn on_inherent_method(&mut self, f: Function) -> ControlFlow<()>;
+fn on_trait_method(&mut self, f: Function) -> ControlFlow<()>;
 
 impl<F> MethodCandidateCallback for F
 where
-    F: FnMut(Function) -> ControlFlow<()>,
-{
+    F: FnMut(Function) -> ControlFlow<()>, {
     fn on_inherent_method(&mut self, f: Function) -> ControlFlow<()> {
         self(f)
     }
     }
 }
 
-pub trait PathCandidateCallback {
-    fn on_inherent_item(&mut self, item: AssocItem) -> ControlFlow<()>;
-
-    fn on_trait_item(&mut self, item: AssocItem) -> ControlFlow<()>;
-}
+fn on_inherent_item(&mut self, item: AssocItem) -> ControlFlow<()>;
+fn on_trait_item(&mut self, item: AssocItem) -> ControlFlow<()>;
 
 impl<F> PathCandidateCallback for F
 where
-    F: FnMut(AssocItem) -> ControlFlow<()>,
-{
+    F: FnMut(AssocItem) -> ControlFlow<()>, {
     fn on_inherent_item(&mut self, item: AssocItem) -> ControlFlow<()> {
         self(item)
     }
     }
 }
 
-pub fn resolve_absolute_path<'a, I: Iterator<Item = Symbol> + Clone + 'a>(
-    db: &'a dyn HirDatabase,
-    mut segments: I,
-) -> impl Iterator<Item = ItemInNs> + use<'a, I> {
+pub fn resolve_absolute_path<'a, I: Iterator<Item = Symbol> + Clone + 'a>(db: &'a dyn HirDatabase, mut segments: I) -> impl Iterator<Item = ItemInNs> + use<'a, I> {
     segments
         .next()
         .into_iter()
     name.map_or_else(Name::missing, |name| name.as_name())
 }
 
-fn generic_args_from_tys<'db>(
-    interner: DbInterner<'db>,
-    def_id: SolverDefId,
-    args: impl IntoIterator<Item = Ty<'db>>,
-) -> GenericArgs<'db> {
+fn generic_args_from_tys<'db>(interner: DbInterner<'db>, def_id: SolverDefId, args: impl IntoIterator<Item = Ty<'db>>) -> GenericArgs<'db> {
     let mut args = args.into_iter();
     GenericArgs::for_item(interner, def_id, |_, id, _| {
         if matches!(id, GenericParamId::TypeParamId(_))
             defaults.get(param).is_none()
         })
 }
-
-pub use hir_ty::next_solver;
-pub use hir_ty::setup_tracing;