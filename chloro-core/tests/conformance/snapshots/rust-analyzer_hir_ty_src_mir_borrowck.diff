COMPARISON DIFF
============================================================

Original size: 25852 bytes
Chloro size:   25564 bytes
Rustfmt size:  25852 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! MIR borrow checker, which is used in diagnostics like `unused_mut`
 
-// Currently it is an ad-hoc implementation, only useful for mutability analysis. Feel free to remove all of these
-// if needed for implementing a proper borrow checker.
-
 use std::iter;
 
 use hir_def::{DefWithBodyId, HasModule};
         infer::{DbInternerInferExt, InferCtxt},
     },
 };
-
 use super::{
     BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, MutBorrowKind, Operand,
     Place, ProjectionElem, Rvalue, StatementKind, TerminatorKind,
 };
-
-#[derive(Debug, Clone, PartialEq, Eq)]
 /// Stores spans which implies that the local should be mutable.
+#[derive(Debug, Clone, PartialEq, Eq)]
 pub enum MutabilityReason {
-    Mut { spans: Vec<MirSpan> },
+    Mut {
+        spans: Vec<MirSpan>,
+    },
     Not,
     Unused,
 }
     pub borrow_regions: Vec<BorrowRegion<'db>>,
 }
 
-fn all_mir_bodies<'db>(
-    db: &'db dyn HirDatabase,
-    def: DefWithBodyId,
-    mut cb: impl FnMut(Arc<MirBody<'db>>),
-) -> Result<(), MirLowerError<'db>> {
+fn all_mir_bodies<'db>(db: &'db dyn HirDatabase, def: DefWithBodyId, mut cb: impl FnMut(Arc<MirBody<'db>>)) -> Result<(), MirLowerError<'db>> {
     fn for_closure<'db>(
         db: &'db dyn HirDatabase,
         c: InternedClosureId,
     }
 }
 
-pub fn borrowck_query<'db>(
-    db: &'db dyn HirDatabase,
-    def: DefWithBodyId,
-) -> Result<Arc<[BorrowckResult<'db>]>, MirLowerError<'db>> {
+pub fn borrowck_query<'db>(db: &'db dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<[BorrowckResult<'db>]>, MirLowerError<'db>> {
     let _p = tracing::info_span!("borrowck_query").entered();
     let module = def.module(db);
     let interner = DbInterner::new_with(db, Some(module.krate()), module.containing_block());
     Ok(res.into())
 }
 
-fn make_fetch_closure_field<'db>(
-    db: &'db dyn HirDatabase,
-) -> impl FnOnce(InternedClosureId, GenericArgs<'db>, usize) -> Ty<'db> + use<'db> {
+fn make_fetch_closure_field<'db>(db: &'db dyn HirDatabase) -> impl FnOnce(InternedClosureId, GenericArgs<'db>, usize) -> Ty<'db> + use<'db> {
     |c: InternedClosureId, subst: GenericArgs<'db>, f: usize| {
         let InternedClosure(def, _) = db.lookup_intern_closure(c);
         let infer = db.infer(def);
     }
 }
 
-fn moved_out_of_ref<'db>(
-    infcx: &InferCtxt<'db>,
-    env: &TraitEnvironment<'db>,
-    body: &MirBody<'db>,
-) -> Vec<MovedOutOfRef<'db>> {
+fn moved_out_of_ref<'db>(infcx: &InferCtxt<'db>, env: &TraitEnvironment<'db>, body: &MirBody<'db>) -> Vec<MovedOutOfRef<'db>> {
     let db = infcx.interner.db;
     let mut result = vec![];
     let mut for_operand = |op: &Operand<'db>, span: MirSpan| match op.kind {
     result
 }
 
-fn partially_moved<'db>(
-    infcx: &InferCtxt<'db>,
-    env: &TraitEnvironment<'db>,
-    body: &MirBody<'db>,
-) -> Vec<PartiallyMoved<'db>> {
+fn partially_moved<'db>(infcx: &InferCtxt<'db>, env: &TraitEnvironment<'db>, body: &MirBody<'db>) -> Vec<PartiallyMoved<'db>> {
     let db = infcx.interner.db;
     let mut result = vec![];
     let mut for_operand = |op: &Operand<'db>, span: MirSpan| match op.kind {
             None => (),
         }
     }
-
     borrows.into_values().collect()
 }
 
     Indirect,
 }
 
-fn place_case<'db>(
-    infcx: &InferCtxt<'db>,
-    body: &MirBody<'db>,
-    lvalue: &Place<'db>,
-) -> ProjectionCase {
+fn place_case<'db>(infcx: &InferCtxt<'db>, body: &MirBody<'db>, lvalue: &Place<'db>) -> ProjectionCase {
     let db = infcx.interner.db;
     let mut is_part_of = false;
     let mut ty = body.locals[lvalue.local].ty;
 /// Returns a map from basic blocks to the set of locals that might be ever initialized before
 /// the start of the block. Only `StorageDead` can remove something from this map, and we ignore
 /// `Uninit` and `drop` and similar after initialization.
-fn ever_initialized_map<'db>(
-    db: &'db dyn HirDatabase,
-    body: &MirBody<'db>,
-) -> ArenaMap<BasicBlockId<'db>, ArenaMap<LocalId<'db>, bool>> {
+fn ever_initialized_map<'db>(db: &'db dyn HirDatabase, body: &MirBody<'db>) -> ArenaMap<BasicBlockId<'db>, ArenaMap<LocalId<'db>, bool>> {
     let mut result: ArenaMap<BasicBlockId<'db>, ArenaMap<LocalId<'db>, bool>> =
         body.basic_blocks.iter().map(|it| (it.0, ArenaMap::default())).collect();
     fn dfs<'db>(
     result
 }
 
-fn push_mut_span<'db>(
-    local: LocalId<'db>,
-    span: MirSpan,
-    result: &mut ArenaMap<LocalId<'db>, MutabilityReason>,
-) {
+fn push_mut_span<'db>(local: LocalId<'db>, span: MirSpan, result: &mut ArenaMap<LocalId<'db>, MutabilityReason>) {
     match &mut result[local] {
         MutabilityReason::Mut { spans } => spans.push(span),
         it @ (MutabilityReason::Not | MutabilityReason::Unused) => {
     };
 }
 
-fn record_usage_for_operand<'db>(
-    arg: &Operand<'db>,
-    result: &mut ArenaMap<LocalId<'db>, MutabilityReason>,
-) {
+fn record_usage_for_operand<'db>(arg: &Operand<'db>, result: &mut ArenaMap<LocalId<'db>, MutabilityReason>) {
     if let OperandKind::Copy(p) | OperandKind::Move(p) = arg.kind {
         record_usage(p.local, result);
     }
 }
 
-fn mutability_of_locals<'db>(
-    infcx: &InferCtxt<'db>,
-    body: &MirBody<'db>,
-) -> ArenaMap<LocalId<'db>, MutabilityReason> {
+fn mutability_of_locals<'db>(infcx: &InferCtxt<'db>, body: &MirBody<'db>) -> ArenaMap<LocalId<'db>, MutabilityReason> {
     let db = infcx.interner.db;
     let mut result: ArenaMap<LocalId<'db>, MutabilityReason> =
         body.locals.iter().map(|it| (it.0, MutabilityReason::Unused)).collect();
-
     let ever_init_maps = ever_initialized_map(db, body);
     for (block_id, mut ever_init_map) in ever_init_maps.into_iter() {
         let block = &body.basic_blocks[block_id];