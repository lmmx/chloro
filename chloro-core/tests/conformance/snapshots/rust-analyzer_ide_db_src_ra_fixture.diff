COMPARISON DIFF
============================================================

Original size: 18130 bytes
Chloro size:   17236 bytes
Rustfmt size:  18477 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Working with the fixtures in r-a tests, and providing IDE services for them.
 
 use std::hash::{BuildHasher, Hash};
 
 use hir::{CfgExpr, FilePositionWrapper, FileRangeWrapper, Semantics, Symbol};
 use smallvec::SmallVec;
+pub use span::FileId;
 use span::{TextRange, TextSize};
 use syntax::{
-    ast::{self, IsString},
     AstToken, SmolStr,
+    ast::{self, IsString},
 };
 
 use crate::{
-    active_parameter::ActiveParameter, documentation::Documentation, range_mapper::RangeMapper,
-    search::ReferenceCategory, MiniCore, RootDatabase, SymbolKind,
+    MiniCore, RootDatabase, SymbolKind, active_parameter::ActiveParameter,
+    documentation::Documentation, range_mapper::RangeMapper, search::ReferenceCategory,
 };
 
-pub use span::FileId;
-
 impl RootDatabase {
     fn from_ra_fixture(
         text: &str,
     virtual_file_id_to_line: Vec<usize>,
     mapper: RangeMapper,
     literal: ast::String,
-    // `minicore` etc..
     sysroot_files: Vec<FileId>,
     combined_len: TextSize,
 }
         if !literal.is_raw() {
             return None;
         }
-
         let active_parameter = ActiveParameter::at_token(sema, expanded.syntax().clone())?;
         let has_rust_fixture_attr = active_parameter.attrs().is_some_and(|attrs| {
             attrs.filter_map(|attr| attr.as_simple_path()).any(|path| {
             return None;
         }
         let value = literal.value().ok()?;
-
         let mut mapper = RangeMapper::default();
-
         // This is used for the `Injector`, to resolve precise location in the string literal,
         // which will then be used to resolve precise location in the enclosing file.
         let mut offset_with_indent = TextSize::new(0);
         // Besides indentation, we also skip `$0` cursors for this, since they are not included
         // in the virtual files.
         let mut offset_without_indent = TextSize::new(0);
-
         let mut text = &*value;
         if let Some(t) = text.strip_prefix('\n') {
             offset_with_indent += TextSize::of("\n");
                 }
             }
         }
-
         let combined = mapper.take_text();
         let combined_len = TextSize::of(&combined);
         let (analysis, tmp_file_ids, sysroot_files) =
             RootDatabase::from_ra_fixture(&combined, minicore).ok()?;
-
         // We use a `Vec` because we know the `FileId`s will always be close.
         let mut virtual_file_id_to_line = Vec::new();
         for &(file_id, line) in &tmp_file_ids {
             virtual_file_id_to_line.resize(file_id.index() as usize + 1, usize::MAX);
             virtual_file_id_to_line[file_id.index() as usize] = line;
         }
-
         Some(RaFixtureAnalysis {
             db: analysis,
             tmp_file_ids,
     }
 
     /// This returns `None` for minicore or other sysroot files.
-    fn virtual_file_id_to_line(&self, file_id: FileId) -> Option<usize> {
+    fn virtual_file_id_to_line(
+        &self,
+        file_id: FileId,
+    ) -> Option<usize> {
         if self.is_sysroot_file(file_id) {
             None
         } else {
         }
     }
 
-    pub fn map_offset_down(&self, offset: TextSize) -> Option<(FileId, TextSize)> {
+    pub fn map_offset_down(
+        &self,
+        offset: TextSize,
+    ) -> Option<(FileId, TextSize)> {
         let inside_literal_range = self.literal.map_offset_down(offset)?;
         let combined_offset = self.mapper.map_offset_down(inside_literal_range)?;
         // There is usually a small number of files, so a linear search is smaller and faster.
         let (_, &(file_id, file_line)) =
-            self.tmp_file_ids
-                .iter()
-                .enumerate()
-                .find(|&(idx, &(_, file_line))| {
-                    let file_start = self.line_offsets[file_line];
-                    let file_end = self
-                        .tmp_file_ids
-                        .get(idx + 1)
-                        .map(|&(_, next_file_line)| self.line_offsets[next_file_line])
-                        .unwrap_or_else(|| self.combined_len);
-                    TextRange::new(file_start, file_end).contains(combined_offset)
-                })?;
+            self.tmp_file_ids.iter().enumerate().find(|&(idx, &(_, file_line))| {
+                let file_start = self.line_offsets[file_line];
+                let file_end = self
+                    .tmp_file_ids
+                    .get(idx + 1)
+                    .map(|&(_, next_file_line)| self.line_offsets[next_file_line])
+                    .unwrap_or_else(|| self.combined_len);
+                TextRange::new(file_start, file_end).contains(combined_offset)
+            })?;
         let file_line_offset = self.line_offsets[file_line];
         let file_offset = combined_offset - file_line_offset;
         Some((file_id, file_offset))
     }
 
-    pub fn map_range_down(&self, range: TextRange) -> Option<(FileId, TextRange)> {
+    pub fn map_range_down(
+        &self,
+        range: TextRange,
+    ) -> Option<(FileId, TextRange)> {
         let (start_file_id, start_offset) = self.map_offset_down(range.start())?;
         let (end_file_id, end_offset) = self.map_offset_down(range.end())?;
         if start_file_id != end_file_id {
             .filter_map(|range| self.literal.map_range_up(range))
     }
 
-    pub fn map_offset_up(&self, virtual_file: FileId, offset: TextSize) -> Option<TextSize> {
-        self.map_range_up(virtual_file, TextRange::empty(offset))
-            .next()
-            .map(|range| range.start())
+    pub fn map_offset_up(
+        &self,
+        virtual_file: FileId,
+        offset: TextSize,
+    ) -> Option<TextSize> {
+        self.map_range_up(virtual_file, TextRange::empty(offset)).next().map(|range| range.start())
     }
 
-    pub fn is_sysroot_file(&self, file_id: FileId) -> bool {
+    pub fn is_sysroot_file(
+        &self,
+        file_id: FileId,
+    ) -> bool {
         self.sysroot_files.contains(&file_id)
     }
 }
 
-pub trait UpmapFromRaFixture: Sized {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()>;
-}
+fn upmap_from_ra_fixture(
+    self,
+    analysis: &RaFixtureAnalysis,
+    virtual_file_id: FileId,
+    real_file_id: FileId,
+) -> Result<Self, ()>;
 
-trait IsEmpty {
-    fn is_empty(&self) -> bool;
-}
+fn is_empty(&self) -> bool;
 
 impl<T> IsEmpty for Vec<T> {
     fn is_empty(&self) -> bool {
     }
 }
 
-#[allow(clippy::disallowed_types)]
 impl<K, V, S> IsEmpty for std::collections::HashMap<K, V, S> {
     fn is_empty(&self) -> bool {
         self.is_empty()
 ) -> Result<Collection, ()>
 where
     T: UpmapFromRaFixture,
-    Collection: IntoIterator<Item = T> + FromIterator<T> + IsEmpty,
-{
+    Collection: IntoIterator<Item = T> + FromIterator<T> + IsEmpty, {
     if collection.is_empty() {
         // The collection was already empty, don't mark it as failing just because of that.
         return Ok(collection);
     }
     let result = collection
         .into_iter()
-        .filter_map(|item| {
-            item.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)
-                .ok()
-        })
+        .filter_map(|item| item.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id).ok())
         .collect::<Collection>();
     if result.is_empty() {
         // The collection was emptied by the upmapping - all items errored, therefore mark it as erroring as well.
     }
 }
 
-#[allow(clippy::disallowed_types)]
-impl<K: UpmapFromRaFixture + Hash + Eq, V: UpmapFromRaFixture, S: BuildHasher + Default>
-    UpmapFromRaFixture for std::collections::HashMap<K, V, S>
-{
+impl<K: UpmapFromRaFixture + Hash + Eq, V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture for std::collections::HashMap<K, V, S> {
     fn upmap_from_ra_fixture(
         self,
         analysis: &RaFixtureAnalysis,
     }
 }
 
-// A map of `FileId`s is treated as associating the ranges in the values with the keys.
-#[allow(clippy::disallowed_types)]
-impl<V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture
-    for std::collections::HashMap<FileId, V, S>
-{
+impl<V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture for std::collections::HashMap<FileId, V, S> {
     fn upmap_from_ra_fixture(
         self,
         analysis: &RaFixtureAnalysis,
             .filter_map(|(virtual_file_id, value)| {
                 Some((
                     real_file_id,
-                    value
-                        .upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)
-                        .ok()?,
+                    value.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id).ok()?,
                 ))
             })
             .collect::<std::collections::HashMap<_, _, _>>();
-        if result.is_empty() {
-            Err(())
-        } else {
-            Ok(result)
-        }
+        if result.is_empty() { Err(()) } else { Ok(result) }
     }
 }
 
         impl_tuple!( $($rest,)* );
     };
 }
-impl_tuple!(A, B, C, D, E,);
-
 impl UpmapFromRaFixture for TextSize {
     fn upmap_from_ra_fixture(
         self,
         virtual_file_id: FileId,
         _real_file_id: FileId,
     ) -> Result<Self, ()> {
-        analysis
-            .map_range_up(virtual_file_id, self)
-            .next()
-            .ok_or(())
+        analysis.map_range_up(virtual_file_id, self).next().ok_or(())
     }
 }
 
-// Deliberately do not implement that, as it's easy to get things misbehave and be treated with the wrong FileId:
-//
-// impl UpmapFromRaFixture for FileId {
-//     fn upmap_from_ra_fixture(
-//         self,
-//         _analysis: &RaFixtureAnalysis,
-//         _virtual_file_id: FileId,
-//         real_file_id: FileId,
-//     ) -> Result<Self, ()> {
-//         Ok(real_file_id)
-//     }
-// }
-
 impl UpmapFromRaFixture for FilePositionWrapper<FileId> {
     fn upmap_from_ra_fixture(
         self,
     ) -> Result<Self, ()> {
         Ok(FilePositionWrapper {
             file_id: real_file_id,
-            offset: self
-                .offset
-                .upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
+            offset: self.offset.upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
         })
     }
 }
     ) -> Result<Self, ()> {
         Ok(FileRangeWrapper {
             file_id: real_file_id,
-            range: self
-                .range
-                .upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
+            range: self.range.upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
         })
     }
 }
         )*
     };
 }
-
-impl_empty_upmap_from_ra_fixture!(
-    bool,
-    i8,
-    i16,
-    i32,
-    i64,
-    i128,
-    u8,
-    u16,
-    u32,
-    u64,
-    u128,
-    f32,
-    f64,
-    &str,
-    String,
-    Symbol,
-    SmolStr,
-    Documentation,
-    SymbolKind,
-    CfgExpr,
-    ReferenceCategory,
-);