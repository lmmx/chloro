COMPARISON DIFF
============================================================

Original size: 18130 bytes
Chloro size:   16622 bytes
Rustfmt size:  18477 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Working with the fixtures in r-a tests, and providing IDE services for them.
 
 use std::hash::{BuildHasher, Hash};
 
 use hir::{CfgExpr, FilePositionWrapper, FileRangeWrapper, Semantics, Symbol};
 use smallvec::SmallVec;
+pub use span::FileId;
 use span::{TextRange, TextSize};
 use syntax::{
-    ast::{self, IsString},
     AstToken, SmolStr,
+    ast::{self, IsString},
 };
 
 use crate::{
-    active_parameter::ActiveParameter, documentation::Documentation, range_mapper::RangeMapper,
-    search::ReferenceCategory, MiniCore, RootDatabase, SymbolKind,
+    MiniCore, RootDatabase, SymbolKind, active_parameter::ActiveParameter,
+    documentation::Documentation, range_mapper::RangeMapper, search::ReferenceCategory,
 };
-
-pub use span::FileId;
-
 impl RootDatabase {
-    fn from_ra_fixture(
-        text: &str,
-        minicore: MiniCore<'_>,
-    ) -> Result<(RootDatabase, Vec<(FileId, usize)>, Vec<FileId>), ()> {
+    fn from_ra_fixture(text: &str, minicore: MiniCore<'_>) -> Result<(RootDatabase, Vec<(FileId, usize)>, Vec<FileId>), ()> {
         // We don't want a mistake in the fixture to crash r-a, so we wrap this in `catch_unwind()`.
         std::panic::catch_unwind(|| {
             let mut db = RootDatabase::default();
     virtual_file_id_to_line: Vec<usize>,
     mapper: RangeMapper,
     literal: ast::String,
-    // `minicore` etc..
     sysroot_files: Vec<FileId>,
     combined_len: TextSize,
 }
 
 impl RaFixtureAnalysis {
-    pub fn analyze_ra_fixture(
-        sema: &Semantics<'_, RootDatabase>,
-        literal: ast::String,
-        expanded: &ast::String,
-        minicore: MiniCore<'_>,
-        on_cursor: &mut dyn FnMut(TextRange),
-    ) -> Option<RaFixtureAnalysis> {
+    pub fn analyze_ra_fixture(sema: &Semantics<'_, RootDatabase>, literal: ast::String, expanded: &ast::String, minicore: MiniCore<'_>, on_cursor: &mut dyn FnMut(TextRange)) -> Option<RaFixtureAnalysis> {
         if !literal.is_raw() {
             return None;
         }
-
         let active_parameter = ActiveParameter::at_token(sema, expanded.syntax().clone())?;
         let has_rust_fixture_attr = active_parameter.attrs().is_some_and(|attrs| {
             attrs.filter_map(|attr| attr.as_simple_path()).any(|path| {
             return None;
         }
         let value = literal.value().ok()?;
-
         let mut mapper = RangeMapper::default();
-
         // This is used for the `Injector`, to resolve precise location in the string literal,
         // which will then be used to resolve precise location in the enclosing file.
         let mut offset_with_indent = TextSize::new(0);
         // Besides indentation, we also skip `$0` cursors for this, since they are not included
         // in the virtual files.
         let mut offset_without_indent = TextSize::new(0);
-
         let mut text = &*value;
         if let Some(t) = text.strip_prefix('\n') {
             offset_with_indent += TextSize::of("\n");
                 }
             }
         }
-
         let combined = mapper.take_text();
         let combined_len = TextSize::of(&combined);
         let (analysis, tmp_file_ids, sysroot_files) =
             RootDatabase::from_ra_fixture(&combined, minicore).ok()?;
-
         // We use a `Vec` because we know the `FileId`s will always be close.
         let mut virtual_file_id_to_line = Vec::new();
         for &(file_id, line) in &tmp_file_ids {
             virtual_file_id_to_line.resize(file_id.index() as usize + 1, usize::MAX);
             virtual_file_id_to_line[file_id.index() as usize] = line;
         }
-
         Some(RaFixtureAnalysis {
             db: analysis,
             tmp_file_ids,
         let combined_offset = self.mapper.map_offset_down(inside_literal_range)?;
         // There is usually a small number of files, so a linear search is smaller and faster.
         let (_, &(file_id, file_line)) =
-            self.tmp_file_ids
-                .iter()
-                .enumerate()
-                .find(|&(idx, &(_, file_line))| {
-                    let file_start = self.line_offsets[file_line];
-                    let file_end = self
-                        .tmp_file_ids
-                        .get(idx + 1)
-                        .map(|&(_, next_file_line)| self.line_offsets[next_file_line])
-                        .unwrap_or_else(|| self.combined_len);
-                    TextRange::new(file_start, file_end).contains(combined_offset)
-                })?;
+            self.tmp_file_ids.iter().enumerate().find(|&(idx, &(_, file_line))| {
+                let file_start = self.line_offsets[file_line];
+                let file_end = self
+                    .tmp_file_ids
+                    .get(idx + 1)
+                    .map(|&(_, next_file_line)| self.line_offsets[next_file_line])
+                    .unwrap_or_else(|| self.combined_len);
+                TextRange::new(file_start, file_end).contains(combined_offset)
+            })?;
         let file_line_offset = self.line_offsets[file_line];
         let file_offset = combined_offset - file_line_offset;
         Some((file_id, file_offset))
         }
     }
 
-    pub fn map_range_up(
-        &self,
-        virtual_file: FileId,
-        range: TextRange,
-    ) -> impl Iterator<Item = TextRange> {
+    pub fn map_range_up(&self, virtual_file: FileId, range: TextRange) -> impl Iterator<Item = TextRange> {
         // This could be `None` if the file is empty.
         self.virtual_file_id_to_line(virtual_file)
             .and_then(|line| self.line_offsets.get(line))
     }
 
     pub fn map_offset_up(&self, virtual_file: FileId, offset: TextSize) -> Option<TextSize> {
-        self.map_range_up(virtual_file, TextRange::empty(offset))
-            .next()
-            .map(|range| range.start())
+        self.map_range_up(virtual_file, TextRange::empty(offset)).next().map(|range| range.start())
     }
 
     pub fn is_sysroot_file(&self, file_id: FileId) -> bool {
     }
 }
 
-pub trait UpmapFromRaFixture: Sized {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()>;
-}
+fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, virtual_file_id: FileId, real_file_id: FileId) -> Result<Self, ()>;
 
-trait IsEmpty {
-    fn is_empty(&self) -> bool;
-}
+fn is_empty(&self) -> bool;
 
 impl<T> IsEmpty for Vec<T> {
     fn is_empty(&self) -> bool {
     }
 }
 
-#[allow(clippy::disallowed_types)]
 impl<K, V, S> IsEmpty for std::collections::HashMap<K, V, S> {
     fn is_empty(&self) -> bool {
         self.is_empty()
     }
 }
 
-fn upmap_collection<T, Collection>(
-    collection: Collection,
-    analysis: &RaFixtureAnalysis,
-    virtual_file_id: FileId,
-    real_file_id: FileId,
-) -> Result<Collection, ()>
+fn upmap_collection<T, Collection>(collection: Collection, analysis: &RaFixtureAnalysis, virtual_file_id: FileId, real_file_id: FileId) -> Result<Collection, ()>
 where
     T: UpmapFromRaFixture,
-    Collection: IntoIterator<Item = T> + FromIterator<T> + IsEmpty,
-{
+    Collection: IntoIterator<Item = T> + FromIterator<T> + IsEmpty, {
     if collection.is_empty() {
         // The collection was already empty, don't mark it as failing just because of that.
         return Ok(collection);
     }
     let result = collection
         .into_iter()
-        .filter_map(|item| {
-            item.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)
-                .ok()
-        })
+        .filter_map(|item| item.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id).ok())
         .collect::<Collection>();
     if result.is_empty() {
         // The collection was emptied by the upmapping - all items errored, therefore mark it as erroring as well.
 }
 
 impl<T: UpmapFromRaFixture> UpmapFromRaFixture for Option<T> {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()> {
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, virtual_file_id: FileId, real_file_id: FileId) -> Result<Self, ()> {
         Ok(match self {
             Some(it) => Some(it.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)?),
             None => None,
 }
 
 impl<T: UpmapFromRaFixture> UpmapFromRaFixture for Vec<T> {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()> {
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, virtual_file_id: FileId, real_file_id: FileId) -> Result<Self, ()> {
         upmap_collection(self, analysis, virtual_file_id, real_file_id)
     }
 }
 
 impl<T: UpmapFromRaFixture, const N: usize> UpmapFromRaFixture for SmallVec<[T; N]> {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()> {
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, virtual_file_id: FileId, real_file_id: FileId) -> Result<Self, ()> {
         upmap_collection(self, analysis, virtual_file_id, real_file_id)
     }
 }
 
-#[allow(clippy::disallowed_types)]
-impl<K: UpmapFromRaFixture + Hash + Eq, V: UpmapFromRaFixture, S: BuildHasher + Default>
-    UpmapFromRaFixture for std::collections::HashMap<K, V, S>
-{
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()> {
+impl<K: UpmapFromRaFixture + Hash + Eq, V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture for std::collections::HashMap<K, V, S> {
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, virtual_file_id: FileId, real_file_id: FileId) -> Result<Self, ()> {
         upmap_collection(self, analysis, virtual_file_id, real_file_id)
     }
 }
 
-// A map of `FileId`s is treated as associating the ranges in the values with the keys.
-#[allow(clippy::disallowed_types)]
-impl<V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture
-    for std::collections::HashMap<FileId, V, S>
-{
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        _virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()> {
+impl<V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture for std::collections::HashMap<FileId, V, S> {
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, _virtual_file_id: FileId, real_file_id: FileId) -> Result<Self, ()> {
         if self.is_empty() {
             return Ok(self);
         }
             .filter_map(|(virtual_file_id, value)| {
                 Some((
                     real_file_id,
-                    value
-                        .upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)
-                        .ok()?,
+                    value.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id).ok()?,
                 ))
             })
             .collect::<std::collections::HashMap<_, _, _>>();
-        if result.is_empty() {
-            Err(())
-        } else {
-            Ok(result)
-        }
+        if result.is_empty() { Err(()) } else { Ok(result) }
     }
 }
 
         impl_tuple!( $($rest,)* );
     };
 }
-impl_tuple!(A, B, C, D, E,);
-
 impl UpmapFromRaFixture for TextSize {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        virtual_file_id: FileId,
-        _real_file_id: FileId,
-    ) -> Result<Self, ()> {
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, virtual_file_id: FileId, _real_file_id: FileId) -> Result<Self, ()> {
         analysis.map_offset_up(virtual_file_id, self).ok_or(())
     }
 }
 
 impl UpmapFromRaFixture for TextRange {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        virtual_file_id: FileId,
-        _real_file_id: FileId,
-    ) -> Result<Self, ()> {
-        analysis
-            .map_range_up(virtual_file_id, self)
-            .next()
-            .ok_or(())
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, virtual_file_id: FileId, _real_file_id: FileId) -> Result<Self, ()> {
+        analysis.map_range_up(virtual_file_id, self).next().ok_or(())
     }
 }
 
-// Deliberately do not implement that, as it's easy to get things misbehave and be treated with the wrong FileId:
-//
-// impl UpmapFromRaFixture for FileId {
-//     fn upmap_from_ra_fixture(
-//         self,
-//         _analysis: &RaFixtureAnalysis,
-//         _virtual_file_id: FileId,
-//         real_file_id: FileId,
-//     ) -> Result<Self, ()> {
-//         Ok(real_file_id)
-//     }
-// }
-
 impl UpmapFromRaFixture for FilePositionWrapper<FileId> {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        _virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()> {
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, _virtual_file_id: FileId, real_file_id: FileId) -> Result<Self, ()> {
         Ok(FilePositionWrapper {
             file_id: real_file_id,
-            offset: self
-                .offset
-                .upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
+            offset: self.offset.upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
         })
     }
 }
 
 impl UpmapFromRaFixture for FileRangeWrapper<FileId> {
-    fn upmap_from_ra_fixture(
-        self,
-        analysis: &RaFixtureAnalysis,
-        _virtual_file_id: FileId,
-        real_file_id: FileId,
-    ) -> Result<Self, ()> {
+    fn upmap_from_ra_fixture(self, analysis: &RaFixtureAnalysis, _virtual_file_id: FileId, real_file_id: FileId) -> Result<Self, ()> {
         Ok(FileRangeWrapper {
             file_id: real_file_id,
-            range: self
-                .range
-                .upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
+            range: self.range.upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
         })
     }
 }
         )*
     };
 }
-
-impl_empty_upmap_from_ra_fixture!(
-    bool,
-    i8,
-    i16,
-    i32,
-    i64,
-    i128,
-    u8,
-    u16,
-    u32,
-    u64,
-    u128,
-    f32,
-    f64,
-    &str,
-    String,
-    Symbol,
-    SmolStr,
-    Documentation,
-    SymbolKind,
-    CfgExpr,
-    ReferenceCategory,
-);