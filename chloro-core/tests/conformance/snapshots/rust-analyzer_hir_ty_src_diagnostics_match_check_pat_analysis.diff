COMPARISON DIFF
============================================================

Original size: 21126 bytes
Chloro size:   20713 bytes
Rustfmt size:  22047 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Interface with `rustc_pattern_analysis`.
 
 use std::{cell::LazyCell, fmt};
 
+use Constructor::*;
 use hir_def::{EnumId, EnumVariantId, HasModule, LocalFieldId, ModuleId, VariantId};
 use intern::sym;
 use rustc_pattern_analysis::{
-    constructor::{Constructor, ConstructorSet, VariantVisibility},
-    usefulness::{compute_match_usefulness, PlaceValidity, UsefulnessReport},
     IndexVec, PatCx, PrivateUninhabitedField,
+    constructor::{Constructor, ConstructorSet, VariantVisibility},
+    usefulness::{PlaceValidity, UsefulnessReport, compute_match_usefulness},
 };
 use rustc_type_ir::inherent::{AdtDef, IntoKind, SliceLike};
-use smallvec::{smallvec, SmallVec};
+use smallvec::{SmallVec, smallvec};
 use stdx::never;
 use triomphe::Arc;
 
 use crate::{
+    TraitEnvironment,
     db::HirDatabase,
     inhabitedness::{is_enum_variant_uninhabited_from, is_ty_uninhabited_from},
     next_solver::{
-        infer::{traits::ObligationCause, InferCtxt},
         Ty, TyKind,
+        infer::{InferCtxt, traits::ObligationCause},
     },
-    TraitEnvironment,
 };
-
 use super::{FieldPat, Pat, PatKind};
 
-use Constructor::*;
+pub(crate) type DeconstructedPat<'a, 'db> = rustc_pattern_analysis::pat::DeconstructedPat<MatchCheckCtx<'a, 'db>>;
 
-// Re-export r-a-specific versions of all these types.
-pub(crate) type DeconstructedPat<'a, 'db> =
-    rustc_pattern_analysis::pat::DeconstructedPat<MatchCheckCtx<'a, 'db>>;
-pub(crate) type MatchArm<'a, 'b, 'db> =
-    rustc_pattern_analysis::MatchArm<'b, MatchCheckCtx<'a, 'db>>;
-pub(crate) type WitnessPat<'a, 'db> =
-    rustc_pattern_analysis::pat::WitnessPat<MatchCheckCtx<'a, 'db>>;
+pub(crate) type MatchArm<'a, 'b, 'db> = rustc_pattern_analysis::MatchArm<'b, MatchCheckCtx<'a, 'db>>;
+
+pub(crate) type WitnessPat<'a, 'db> = rustc_pattern_analysis::pat::WitnessPat<MatchCheckCtx<'a, 'db>>;
 
 /// [Constructor] uses this in unimplemented variants.
 /// It allows porting match expressions from upstream algorithm without losing semantics.
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub(crate) enum Void {}
+pub(crate) enum Void {
+}
 
 /// An index type for enum variants. This ranges from 0 to `variants.len()`, whereas `EnumVariantId`
 /// can take arbitrary large values (and hence mustn't be used with `IndexVec`/`BitSet`).
 }
 
 impl<'a, 'db> MatchCheckCtx<'a, 'db> {
-    pub(crate) fn new(
-        module: ModuleId,
-        infcx: &'a InferCtxt<'db>,
-        env: Arc<TraitEnvironment<'db>>,
-    ) -> Self {
+    pub(crate) fn new(module: ModuleId, infcx: &'a InferCtxt<'db>, env: Arc<TraitEnvironment<'db>>) -> Self {
         let db = infcx.interner.db;
         let def_map = module.crate_def_map(db);
         let exhaustive_patterns = def_map.is_unstable_feature_enabled(&sym::exhaustive_patterns);
-        Self {
-            module,
-            db,
-            exhaustive_patterns,
-            env,
-            infcx,
-        }
+        Self { module, db, exhaustive_patterns, env, infcx }
     }
 
-    pub(crate) fn compute_match_usefulness<'b>(
-        &self,
-        arms: &[MatchArm<'a, 'b, 'db>],
-        scrut_ty: Ty<'db>,
-        known_valid_scrutinee: Option<bool>,
-    ) -> Result<UsefulnessReport<'b, Self>, ()> {
+    pub(crate) fn compute_match_usefulness<'b>(&self, arms: &[MatchArm<'a, 'b, 'db>], scrut_ty: Ty<'db>, known_valid_scrutinee: Option<bool>) -> Result<UsefulnessReport<'b, Self>, ()> {
         if scrut_ty.references_non_lt_error() {
             return Err(());
         }
                 return Err(());
             }
         }
-
         let place_validity = PlaceValidity::from_bool(known_valid_scrutinee.unwrap_or(true));
         // Measured to take ~100ms on modern hardware.
         let complexity_limit = 500000;
     /// Returns whether the given ADT is from another crate declared `#[non_exhaustive]`.
     fn is_foreign_non_exhaustive(&self, adt: hir_def::AdtId) -> bool {
         let is_local = adt.krate(self.db) == self.module.krate();
-        !is_local
-            && self
-                .db
-                .attrs(adt.into())
-                .by_key(sym::non_exhaustive)
-                .exists()
+        !is_local && self.db.attrs(adt.into()).by_key(sym::non_exhaustive).exists()
     }
 
-    fn variant_id_for_adt(
-        db: &'db dyn HirDatabase,
-        ctor: &Constructor<Self>,
-        adt: hir_def::AdtId,
-    ) -> Option<VariantId> {
+    fn variant_id_for_adt(db: &'db dyn HirDatabase, ctor: &Constructor<Self>, adt: hir_def::AdtId) -> Option<VariantId> {
         match ctor {
             Variant(id) => {
                 let hir_def::AdtId::EnumId(eid) = adt else {
         }
     }
 
-    // This lists the fields of a variant along with their types.
-    fn list_variant_fields(
-        &self,
-        ty: Ty<'db>,
-        variant: VariantId,
-    ) -> impl Iterator<Item = (LocalFieldId, Ty<'db>)> {
+    fn list_variant_fields(&self, ty: Ty<'db>, variant: VariantId) -> impl Iterator<Item = (LocalFieldId, Ty<'db>)> {
         let (_, substs) = ty.as_adt().unwrap();
-
         let field_tys = self.db.field_types(variant);
         let fields_len = variant.fields(self.db).fields().len() as u32;
-
-        (0..fields_len)
-            .map(|idx| LocalFieldId::from_raw(idx.into()))
-            .map(move |fid| {
-                let ty = field_tys[fid].instantiate(self.infcx.interner, substs);
-                let ty = self
-                    .infcx
-                    .at(&ObligationCause::dummy(), self.env.env)
-                    .deeply_normalize(ty)
-                    .unwrap_or(ty);
-                (fid, ty)
-            })
+        (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).map(move |fid| {
+            let ty = field_tys[fid].instantiate(self.infcx.interner, substs);
+            let ty = self
+                .infcx
+                .at(&ObligationCause::dummy(), self.env.env)
+                .deeply_normalize(ty)
+                .unwrap_or(ty);
+            (fid, ty)
+        })
     }
 
     pub(crate) fn lower_pat(&self, pat: &Pat<'db>) -> DeconstructedPat<'a, 'db> {
         let ctor;
         let mut fields: Vec<_>;
         let arity;
-
         match pat.kind.as_ref() {
-            PatKind::Binding {
-                subpattern: Some(subpat),
-                ..
-            } => return self.lower_pat(subpat),
-            PatKind::Binding {
-                subpattern: None, ..
-            }
-            | PatKind::Wild => {
+            PatKind::Binding { subpattern: Some(subpat), .. } => return self.lower_pat(subpat),
+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => {
                 ctor = Wildcard;
                 fields = Vec::new();
                 arity = 0;
                 ctor = match pat.ty.kind() {
                     TyKind::Ref(..) => Ref,
                     _ => {
-                        never!(
-                            "pattern has unexpected type: pat: {:?}, ty: {:?}",
-                            pat,
-                            &pat.ty
-                        );
+                        never!("pattern has unexpected type: pat: {:?}, ty: {:?}", pat, &pat.ty);
                         Wildcard
                     }
                 };
                         arity = variant.fields(self.db).fields().len();
                     }
                     _ => {
-                        never!(
-                            "pattern has unexpected type: pat: {:?}, ty: {:?}",
-                            pat,
-                            &pat.ty
-                        );
+                        never!("pattern has unexpected type: pat: {:?}, ty: {:?}", pat, &pat.ty);
                         ctor = Wildcard;
                         fields.clear();
                         arity = 0;
                         .collect();
 
                     if let VariantId::EnumVariantId(enum_variant) = variant {
-                        PatKind::Variant {
-                            substs,
-                            enum_variant,
-                            subpatterns,
-                        }
+                        PatKind::Variant { substs, enum_variant, subpatterns }
                     } else {
                         PatKind::Leaf { subpatterns }
                     }
             // be careful to reconstruct the correct constant pattern here. However a string
             // literal pattern will never be reported as a non-exhaustiveness witness, so we
             // ignore this issue.
-            Ref => PatKind::Deref {
-                subpattern: subpatterns.next().unwrap(),
-            },
+            Ref => PatKind::Deref { subpattern: subpatterns.next().unwrap() },
             Slice(_) => unimplemented!(),
             DerefPattern(_) => unimplemented!(),
             &Str(void) => match void {},
                 PatKind::Wild
             }
         };
-        Pat {
-            ty: *pat.ty(),
-            kind: Box::new(kind),
-        }
+        Pat { ty: *pat.ty(), kind: Box::new(kind) }
     }
 }
 
 impl<'a, 'db> PatCx for MatchCheckCtx<'a, 'db> {
     type Error = ();
+
     type Ty = Ty<'db>;
+
     type VariantIdx = EnumVariantContiguousIndex;
+
     type StrLit = Void;
+
     type ArmData = ();
+
     type PatData = ();
 
     fn is_exhaustive_patterns_feature_on(&self) -> bool {
         self.exhaustive_patterns
     }
 
-    fn ctor_arity(
-        &self,
-        ctor: &rustc_pattern_analysis::constructor::Constructor<Self>,
-        ty: &Self::Ty,
-    ) -> usize {
+    fn ctor_arity(&self, ctor: &rustc_pattern_analysis::constructor::Constructor<Self>, ty: &Self::Ty) -> usize {
         match ctor {
             Struct | Variant(_) | UnionField => match ty.kind() {
                 TyKind::Tuple(tys) => tys.len(),
         }
     }
 
-    fn ctor_sub_tys(
-        &self,
-        ctor: &rustc_pattern_analysis::constructor::Constructor<Self>,
-        ty: &Self::Ty,
-    ) -> impl ExactSizeIterator<Item = (Self::Ty, PrivateUninhabitedField)> {
+    fn ctor_sub_tys(&self, ctor: &rustc_pattern_analysis::constructor::Constructor<Self>, ty: &Self::Ty) -> impl ExactSizeIterator<Item = (Self::Ty, PrivateUninhabitedField)> {
         let single = |ty| smallvec![(ty, PrivateUninhabitedField(false))];
         let tys: SmallVec<[_; 2]> = match ctor {
             Struct | Variant(_) | UnionField => match ty.kind() {
-                TyKind::Tuple(substs) => substs
-                    .iter()
-                    .map(|ty| (ty, PrivateUninhabitedField(false)))
-                    .collect(),
+                TyKind::Tuple(substs) => {
+                    substs.iter().map(|ty| (ty, PrivateUninhabitedField(false))).collect()
+                }
                 TyKind::Ref(_, rty, _) => single(rty),
                 TyKind::Adt(adt_def, ..) => {
                     let adt = adt_def.def_id().0;
                         .collect()
                 }
                 ty_kind => {
-                    never!(
-                        "Unexpected type for `{:?}` constructor: {:?}",
-                        ctor,
-                        ty_kind
-                    );
+                    never!("Unexpected type for `{:?}` constructor: {:?}", ctor, ty_kind);
                     single(*ty)
                 }
             },
             Ref => match ty.kind() {
                 TyKind::Ref(_, rty, _) => single(rty),
                 ty_kind => {
-                    never!(
-                        "Unexpected type for `{:?}` constructor: {:?}",
-                        ctor,
-                        ty_kind
-                    );
+                    never!("Unexpected type for `{:?}` constructor: {:?}", ctor, ty_kind);
                     single(*ty)
                 }
             },
         tys.into_iter()
     }
 
-    fn ctors_for_ty(
-        &self,
-        ty: &Self::Ty,
-    ) -> Result<rustc_pattern_analysis::constructor::ConstructorSet<Self>, Self::Error> {
+    fn ctors_for_ty(&self, ty: &Self::Ty) -> Result<rustc_pattern_analysis::constructor::ConstructorSet<Self>, Self::Error> {
         let cx = self;
-
         // Unhandled types are treated as non-exhaustive. Being explicit here instead of falling
         // to catchall arm to ease further implementation.
         let unhandled = || ConstructorSet::Unlistable;
-
         // This determines the set of all possible constructors for the type `ty`. For numbers,
         // arrays and slices we use ranges and variable-length slices when appropriate.
         //
                         }
                     }
                     hir_def::AdtId::UnionId(_) => ConstructorSet::Union,
-                    hir_def::AdtId::StructId(_) => ConstructorSet::Struct {
-                        empty: cx.is_uninhabited(*ty),
-                    },
+                    hir_def::AdtId::StructId(_) => {
+                        ConstructorSet::Struct { empty: cx.is_uninhabited(*ty) }
+                    }
                 }
             }
-            TyKind::Tuple(..) => ConstructorSet::Struct {
-                empty: cx.is_uninhabited(*ty),
-            },
+            TyKind::Tuple(..) => ConstructorSet::Struct { empty: cx.is_uninhabited(*ty) },
             TyKind::Ref(..) => ConstructorSet::Ref,
             TyKind::Never => ConstructorSet::NoConstructors,
             // This type is one for which we cannot list constructors, like `str` or `f64`.
         })
     }
 
-    fn write_variant_name(
-        f: &mut fmt::Formatter<'_>,
-        _ctor: &Constructor<Self>,
-        _ty: &Self::Ty,
-    ) -> fmt::Result {
+    fn write_variant_name(f: &mut fmt::Formatter<'_>, _ctor: &Constructor<Self>, _ty: &Self::Ty) -> fmt::Result {
         write!(f, "<write_variant_name unsupported>")
         // We lack the database here ...
         // let variant = ty.as_adt().and_then(|(adt, _)| Self::variant_id_for_adt(db, ctor, adt));
-
         // if let Some(variant) = variant {
         //     match variant {
         //         VariantId::EnumVariantId(v) => {
         Err(())
     }
 
-    fn report_mixed_deref_pat_ctors(
-        &self,
-        _deref_pat: &DeconstructedPat<'a, 'db>,
-        _normal_pat: &DeconstructedPat<'a, 'db>,
-    ) {
+    fn report_mixed_deref_pat_ctors(&self, _deref_pat: &DeconstructedPat<'a, 'db>, _normal_pat: &DeconstructedPat<'a, 'db>) {
         // FIXME(deref_patterns): This could report an error comparable to the one in rustc.
     }
 }