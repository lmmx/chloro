COMPARISON DIFF
============================================================

Original size: 77855 bytes
Chloro size:   77677 bytes
Rustfmt size:  77855 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! This module provides the functionality needed to convert diagnostics from
 //! `cargo check` json format to the LSP diagnostic format.
 
-use crate::flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};
 use itertools::Itertools;
 use rustc_hash::FxHashMap;
 use smallvec::SmallVec;
 use stdx::format_to;
 use vfs::{AbsPath, AbsPathBuf};
 
+use crate::flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};
 use crate::{
     global_state::GlobalStateSnapshot, line_index::PositionEncoding,
     lsp::to_proto::url_from_abs_path, lsp_ext,
 };
-
 use super::{DiagnosticsMapConfig, Fix};
 
 /// Determines the LSP severity from a diagnostic
-fn diagnostic_severity(
-    config: &DiagnosticsMapConfig,
-    level: crate::flycheck::DiagnosticLevel,
-    code: Option<&crate::flycheck::DiagnosticCode>,
-) -> Option<lsp_types::DiagnosticSeverity> {
+fn diagnostic_severity(config: &DiagnosticsMapConfig, level: crate::flycheck::DiagnosticLevel, code: Option<&crate::flycheck::DiagnosticCode>) -> Option<lsp_types::DiagnosticSeverity> {
     let res = match level {
         DiagnosticLevel::Ice => lsp_types::DiagnosticSeverity::ERROR,
         DiagnosticLevel::Error => lsp_types::DiagnosticSeverity::ERROR,
 }
 
 /// Converts a Rust span to a LSP location
-fn location(
-    config: &DiagnosticsMapConfig,
-    workspace_root: &AbsPath,
-    span: &DiagnosticSpan,
-    snap: &GlobalStateSnapshot,
-) -> lsp_types::Location {
+fn location(config: &DiagnosticsMapConfig, workspace_root: &AbsPath, span: &DiagnosticSpan, snap: &GlobalStateSnapshot) -> lsp_types::Location {
     let file_name = resolve_path(config, workspace_root, &span.file_name);
     let uri = url_from_abs_path(&file_name);
-
     let range = {
         let position_encoding = snap.config.negotiated_encoding();
         lsp_types::Range::new(
     lsp_types::Location::new(uri, range)
 }
 
-fn position(
-    position_encoding: &PositionEncoding,
-    span: &DiagnosticSpan,
-    line_number: usize,
-    column_offset_utf32: usize,
-) -> lsp_types::Position {
+fn position(position_encoding: &PositionEncoding, span: &DiagnosticSpan, line_number: usize, column_offset_utf32: usize) -> lsp_types::Position {
     let line_index = line_number - span.line_start;
-
     let column_offset_encoded = match span.text.get(line_index) {
         // Fast path.
         Some(line) if line.text.is_ascii() => column_offset_utf32,
         }
         None => column_offset_utf32,
     };
-
     lsp_types::Position {
         line: (line_number as u32).saturating_sub(1),
         character: column_offset_encoded as u32,
 ///
 /// This takes locations pointing into the standard library, or generally outside the current
 /// workspace into account and tries to avoid those, in case macros are involved.
-fn primary_location(
-    config: &DiagnosticsMapConfig,
-    workspace_root: &AbsPath,
-    span: &DiagnosticSpan,
-    snap: &GlobalStateSnapshot,
-) -> lsp_types::Location {
+fn primary_location(config: &DiagnosticsMapConfig, workspace_root: &AbsPath, span: &DiagnosticSpan, snap: &GlobalStateSnapshot) -> lsp_types::Location {
     let span_stack = std::iter::successors(Some(span), |span| Some(&span.expansion.as_ref()?.span));
     for span in span_stack.clone() {
         let abs_path = resolve_path(config, workspace_root, &span.file_name);
             return location(config, workspace_root, span, snap);
         }
     }
-
     // Fall back to the outermost macro invocation if no suitable span comes up.
     let last_span = span_stack.last().unwrap();
     location(config, workspace_root, last_span, snap)
 /// Converts a secondary Rust span to a LSP related information
 ///
 /// If the span is unlabelled this will return `None`.
-fn diagnostic_related_information(
-    config: &DiagnosticsMapConfig,
-    workspace_root: &AbsPath,
-    span: DiagnosticSpan,
-    snap: &GlobalStateSnapshot,
-) -> Option<lsp_types::DiagnosticRelatedInformation> {
+fn diagnostic_related_information(config: &DiagnosticsMapConfig, workspace_root: &AbsPath, span: DiagnosticSpan, snap: &GlobalStateSnapshot) -> Option<lsp_types::DiagnosticRelatedInformation> {
     let location = location(config, workspace_root, &span, snap);
     let message = span.label?;
     Some(lsp_types::DiagnosticRelatedInformation { location, message })
 
 /// Resolves paths applying any matching path prefix remappings, and then
 /// joining the path to the workspace root.
-fn resolve_path(
-    config: &DiagnosticsMapConfig,
-    workspace_root: &AbsPath,
-    file_name: &str,
-) -> AbsPathBuf {
+fn resolve_path(config: &DiagnosticsMapConfig, workspace_root: &AbsPath, file_name: &str) -> AbsPathBuf {
     match config
         .remap_prefix
         .iter()
     MessageLine(String),
 }
 
-fn map_rust_child_diagnostic(
-    config: &DiagnosticsMapConfig,
-    workspace_root: &AbsPath,
-    rd: &crate::flycheck::Diagnostic,
-    snap: &GlobalStateSnapshot,
-) -> MappedRustChildDiagnostic {
+fn map_rust_child_diagnostic(config: &DiagnosticsMapConfig, workspace_root: &AbsPath, rd: &crate::flycheck::Diagnostic, snap: &GlobalStateSnapshot) -> MappedRustChildDiagnostic {
     let spans: SmallVec<[&DiagnosticSpan; 1]> = rd.spans.iter().filter(|s| s.is_primary).collect();
     if spans.is_empty() {
         // `rustc` uses these spanless children as a way to print multi-line
         // messages
         return MappedRustChildDiagnostic::MessageLine(rd.message.clone());
     }
-
     let mut edit_map: FxHashMap<lsp_types::Url, Vec<lsp_types::TextEdit>> = FxHashMap::default();
     let mut suggested_replacements = Vec::new();
     let mut is_preferred = true;
                 matches!(span.suggestion_applicability, Some(Applicability::MachineApplicable));
         }
     }
-
     // rustc renders suggestion diagnostics by appending the suggested replacement, so do the same
     // here, otherwise the diagnostic text is missing useful information.
     let mut message = rd.message.clone();
             suggested_replacements.iter().map(|suggestion| format!("`{suggestion}`")).join(", ");
         message.push_str(&suggestions);
     }
-
     let suggested_fix = if edit_map.is_empty() {
         None
     } else {
 ///    `relatedInformation` or additional message lines.
 ///
 /// If the diagnostic has no primary span this will return `None`
-pub(crate) fn map_rust_diagnostic_to_lsp(
-    config: &DiagnosticsMapConfig,
-    crate::flycheck::Diagnostic {
+pub(crate) fn map_rust_diagnostic_to_lsp(config: &DiagnosticsMapConfig, crate::flycheck::Diagnostic {
         mut message,
         code: diagnostic_code,
         level,
         children,
         rendered,
         ..
-    }: crate::flycheck::Diagnostic,
-    workspace_root: &AbsPath,
-    snap: &GlobalStateSnapshot,
-) -> Vec<MappedRustDiagnostic> {
+    }: crate::flycheck::Diagnostic, workspace_root: &AbsPath, snap: &GlobalStateSnapshot) -> Vec<MappedRustDiagnostic> {
     let (primary_spans, secondary_spans): (
         SmallVec<[DiagnosticSpan; 1]>,
         SmallVec<[DiagnosticSpan; 1]>,
     if primary_spans.is_empty() {
         return Vec::new();
     }
-
     let mut code = diagnostic_code.as_ref().map(|c| &*c.code);
-
     if let Some(code_val) = code
         && config.check_ignore.contains(code_val)
     {
         return Vec::new();
     }
-
     let severity = diagnostic_severity(config, level, diagnostic_code.as_ref());
-
     let mut source = "rustc";
     if let Some(code_val) = code {
         // See if this is an RFC #2103 scoped lint (e.g. from Clippy)
             code = Some(c);
         }
     }
-
     let mut needs_primary_span_label = true;
     let mut subdiagnostics = Vec::new();
-
     for secondary_span in secondary_spans {
         let related = diagnostic_related_information(config, workspace_root, secondary_span, snap);
         if let Some(related) = related {
             subdiagnostics.push(SubDiagnostic { related, suggested_fix: None });
         }
     }
-
     for child in &children {
         let child = map_rust_child_diagnostic(config, workspace_root, child, snap);
         match child {
         }
     }
     let message = message;
-
     let mut tag = None;
     if let Some(code) = &diagnostic_code {
         match &*code.code {
             _ => {}
         }
     }
-
     let code_description = match source {
         "rustc" => rustc_code_description(code),
         "clippy" => clippy_code_description(code),
     };
     // Each primary diagnostic span may result in multiple LSP diagnostics.
     let mut diagnostics = Vec::new();
-
     for primary_span in primary_spans {
         let primary_location = primary_location(config, workspace_root, &primary_span, snap);
         let message = {
 #[cfg(not(windows))]
 mod tests {
     use crate::{config::Config, global_state::GlobalState};
-
     use super::*;
-
     use expect_test::{ExpectFile, expect_file};
     use lsp_types::ClientCapabilities;
     use paths::Utf8Path;
-
     fn check(diagnostics_json: &str, expect: ExpectFile) {
         check_with_config(DiagnosticsMapConfig::default(), diagnostics_json, expect)
     }
-
     fn check_with_config(config: DiagnosticsMapConfig, diagnostics_json: &str, expect: ExpectFile) {
         let diagnostic: crate::flycheck::Diagnostic =
             serde_json::from_str(diagnostics_json).unwrap();
         actual.iter_mut().for_each(|diag| diag.diagnostic.data = None);
         expect.assert_debug_eq(&actual)
     }
-
     #[test]
     fn rustc_incompatible_type_for_trait() {
         check(
             expect_file!["./test_data/rustc_incompatible_type_for_trait.txt"],
         );
     }
-
     #[test]
     fn rustc_unused_variable() {
         check(
             expect_file!["./test_data/rustc_unused_variable.txt"],
         );
     }
-
     #[test]
     #[cfg(not(windows))]
     fn rustc_unused_variable_as_info() {
             expect_file!["./test_data/rustc_unused_variable_as_info.txt"],
         );
     }
-
     #[test]
     #[cfg(not(windows))]
     fn rustc_unused_variable_as_hint() {
             expect_file!["./test_data/rustc_unused_variable_as_hint.txt"],
         );
     }
-
     #[test]
     fn rustc_wrong_number_of_parameters() {
         check(
             expect_file!["./test_data/rustc_wrong_number_of_parameters.txt"],
         );
     }
-
     #[test]
     fn clippy_pass_by_ref() {
         check(
             expect_file!["./test_data/clippy_pass_by_ref.txt"],
         );
     }
-
     #[test]
     fn rustc_range_map_lsp_position() {
         check(
             expect_file!("./test_data/rustc_range_map_lsp_position.txt"),
         )
     }
-
     #[test]
     fn rustc_mismatched_type() {
         check(
             expect_file!["./test_data/rustc_mismatched_type.txt"],
         );
     }
-
     #[test]
     fn handles_macro_location() {
         check(
             expect_file!["./test_data/handles_macro_location.txt"],
         );
     }
-
     #[test]
     fn macro_compiler_error() {
         check(
             expect_file!["./test_data/macro_compiler_error.txt"],
         );
     }
-
     #[test]
     fn snap_multi_line_fix() {
         check(
             expect_file!["./test_data/snap_multi_line_fix.txt"],
         );
     }
-
     #[test]
     fn reasonable_line_numbers_from_empty_file() {
         check(