COMPARISON DIFF
============================================================

Original size: 45288 bytes
Chloro size:   43754 bytes
Rustfmt size:  45288 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 };
 
 mod gen_trait_fn_body;
+
 pub(crate) mod ref_field_expr;
 
 pub(crate) fn unwrap_trivial_block(block_expr: ast::BlockExpr) -> ast::Expr {
     {
         return None;
     }
-
     if let Some(expr) = stmt_list.tail_expr() {
         if has_anything_else(expr.syntax()) {
             return None;
     No,
 }
 
-pub fn filter_assoc_items(
-    sema: &Semantics<'_, RootDatabase>,
-    items: &[hir::AssocItem],
-    default_methods: DefaultMethods,
-    ignore_items: IgnoreAssocItems,
-) -> Vec<InFile<ast::AssocItem>> {
+pub fn filter_assoc_items(sema: &Semantics<'_, RootDatabase>, items: &[hir::AssocItem], default_methods: DefaultMethods, ignore_items: IgnoreAssocItems) -> Vec<InFile<ast::AssocItem>> {
     return items
         .iter()
         .copied()
             _ => default_methods == DefaultMethods::No,
         })
         .collect();
-
     fn has_def_name(item: &InFile<ast::AssocItem>) -> bool {
         match &item.value {
             ast::AssocItem::Fn(def) => def.name(),
 /// then inserts into `impl_`. Returns the modified `impl_` and the first associated item that got
 /// inserted.
 #[must_use]
-pub fn add_trait_assoc_items_to_impl(
-    sema: &Semantics<'_, RootDatabase>,
-    config: &AssistConfig,
-    original_items: &[InFile<ast::AssocItem>],
-    trait_: hir::Trait,
-    impl_: &ast::Impl,
-    target_scope: &hir::SemanticsScope<'_>,
-) -> Vec<ast::AssocItem> {
+pub fn add_trait_assoc_items_to_impl(sema: &Semantics<'_, RootDatabase>, config: &AssistConfig, original_items: &[InFile<ast::AssocItem>], trait_: hir::Trait, impl_: &ast::Impl, target_scope: &hir::SemanticsScope<'_>) -> Vec<ast::AssocItem> {
     let new_indent_level = IndentLevel::from_node(impl_.syntax()) + 1;
     original_items
         .iter()
     invert_special_case(make, &expr).unwrap_or_else(|| make.expr_prefix(T![!], expr).into())
 }
 
-// FIXME: Migrate usages of this function to the above function and remove this.
 pub(crate) fn invert_boolean_expression_legacy(expr: ast::Expr) -> ast::Expr {
     invert_special_case_legacy(&expr).unwrap_or_else(|| make::expr_prefix(T![!], expr).into())
 }
 
 pub(crate) fn does_pat_match_variant(pat: &ast::Pat, var: &ast::Pat) -> bool {
     let first_node_text = |pat: &ast::Pat| pat.syntax().first_child().map(|node| node.text());
-
     let pat_head = match pat {
         ast::Pat::IdentPat(bind_pat) => match bind_pat.pat() {
             Some(p) => first_node_text(&p),
         },
         pat => first_node_text(pat),
     };
-
     let var_head = first_node_text(var);
-
     pat_head == var_head
 }
 
     })
 }
 
-fn check_pat_variant_nested_or_literal_with_depth(
-    ctx: &AssistContext<'_>,
-    pat: &ast::Pat,
-    depth_after_refutable: usize,
-) -> bool {
+fn check_pat_variant_nested_or_literal_with_depth(ctx: &AssistContext<'_>, pat: &ast::Pat, depth_after_refutable: usize) -> bool {
     if depth_after_refutable > 1 {
         return true;
     }
-
     match pat {
         ast::Pat::RestPat(_) | ast::Pat::WildcardPat(_) | ast::Pat::RefPat(_) => false,
 
     }
 }
 
-// Uses a syntax-driven approach to find any impl blocks for the struct that
-// exist within the module/file
-//
-// Returns `None` if we've found an existing fn
-//
-// FIXME: change the new fn checking to a more semantic approach when that's more
-// viable (e.g. we process proc macros, etc)
-// FIXME: this partially overlaps with `find_impl_block_*`
-
 /// `find_struct_impl` looks for impl of a struct, but this also has additional feature
 /// where it takes a list of function names and check if they exist inside impl_, if
 /// even one match is found, it returns None.
 ///  - `None`: an impl exists, but one of the function names within the impl matches one of the provided names.
 ///  - `Some(None)`: no impl exists.
 ///  - `Some(Some(_))`: an impl exists, with no matching function names.
-pub(crate) fn find_struct_impl(
-    ctx: &AssistContext<'_>,
-    adt: &ast::Adt,
-    names: &[String],
-) -> Option<Option<ast::Impl>> {
+pub(crate) fn find_struct_impl(ctx: &AssistContext<'_>, adt: &ast::Adt, names: &[String]) -> Option<Option<ast::Impl>> {
     let db = ctx.db();
     let module = adt.syntax().parent()?;
-
     let struct_def = ctx.sema.to_def(adt)?;
-
     let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {
         let blk = ctx.sema.to_def(&impl_blk)?;
 
 
         if !(same_ty && not_trait_impl) { None } else { Some(impl_blk) }
     });
-
     if let Some(ref impl_blk) = block
         && has_any_fn(impl_blk, names)
     {
         return None;
     }
-
     Some(block)
 }
 
             }
         }
     }
-
     false
 }
 
 /// Find the end of the `impl` block for the given `ast::Impl`.
-//
-// FIXME: this partially overlaps with `find_struct_impl`
 pub(crate) fn find_impl_block_end(impl_def: ast::Impl, buf: &mut String) -> Option<TextSize> {
     buf.push('\n');
     let end = impl_def
 
 /// Generates the surrounding `impl Type { <code> }` including type and lifetime
 /// parameters.
-// FIXME: migrate remaining uses to `generate_impl`
 pub(crate) fn generate_impl_text(adt: &ast::Adt, code: &str) -> String {
     generate_impl_text_inner(adt, None, true, code)
 }
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-// FIXME: migrate remaining uses to `generate_trait_impl`
 #[allow(dead_code)]
 pub(crate) fn generate_trait_impl_text(adt: &ast::Adt, trait_text: &str, code: &str) -> String {
     generate_impl_text_inner(adt, Some(trait_text), true, code)
 /// and lifetime parameters, with `impl`'s generic parameters' bounds kept as-is.
 ///
 /// This is useful for traits like `From<T>`, since `impl<T> From<T> for U<T>` doesn't require `T: From<T>`.
-// FIXME: migrate remaining uses to `generate_trait_impl_intransitive`
-pub(crate) fn generate_trait_impl_text_intransitive(
-    adt: &ast::Adt,
-    trait_text: &str,
-    code: &str,
-) -> String {
+pub(crate) fn generate_trait_impl_text_intransitive(adt: &ast::Adt, trait_text: &str, code: &str) -> String {
     generate_impl_text_inner(adt, Some(trait_text), false, code)
 }
 
-fn generate_impl_text_inner(
-    adt: &ast::Adt,
-    trait_text: Option<&str>,
-    trait_is_transitive: bool,
-    code: &str,
-) -> String {
+fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, trait_is_transitive: bool, code: &str) -> String {
     // Ensure lifetime params are before type & const params
     let generic_params = adt.generic_param_list().map(|generic_params| {
         let lifetime_params =
 
         make::generic_param_list(itertools::chain(lifetime_params, ty_or_const_params))
     });
-
     // FIXME: use syntax::make & mutable AST apis instead
     // `trait_text` and `code` can't be opaque blobs of text
     let mut buf = String::with_capacity(code.len());
-
     // Copy any cfg attrs from the original adt
     buf.push_str("\n\n");
     let cfg_attrs = adt
         .attrs()
         .filter(|attr| attr.as_simple_call().map(|(name, _arg)| name == "cfg").unwrap_or(false));
     cfg_attrs.for_each(|attr| buf.push_str(&format!("{attr}\n")));
-
     // `impl{generic_params} {trait_text} for {name}{generic_params.to_generic_args()}`
     buf.push_str("impl");
     if let Some(generic_params) = &generic_params {
     if let Some(generic_params) = generic_params {
         format_to!(buf, "{}", generic_params.to_generic_args());
     }
-
     match adt.where_clause() {
         Some(where_clause) => {
             format_to!(buf, "\n{where_clause}\n{{\n{code}\n}}");
             format_to!(buf, " {{\n{code}\n}}");
         }
     }
-
     buf
 }
 
 /// Generates the corresponding `impl Type {}` including type and lifetime
 /// parameters.
-pub(crate) fn generate_impl_with_item(
-    adt: &ast::Adt,
-    body: Option<ast::AssocItemList>,
-) -> ast::Impl {
+pub(crate) fn generate_impl_with_item(adt: &ast::Adt, body: Option<ast::AssocItemList>) -> ast::Impl {
     generate_impl_inner(false, adt, None, true, body)
 }
 
     generate_impl_inner(false, adt, Some(trait_), false, None)
 }
 
-fn generate_impl_inner(
-    is_unsafe: bool,
-    adt: &ast::Adt,
-    trait_: Option<ast::Type>,
-    trait_is_transitive: bool,
-    body: Option<ast::AssocItemList>,
-) -> ast::Impl {
+fn generate_impl_inner(is_unsafe: bool, adt: &ast::Adt, trait_: Option<ast::Type>, trait_is_transitive: bool, body: Option<ast::AssocItemList>) -> ast::Impl {
     // Ensure lifetime params are before type & const params
     let generic_params = adt.generic_param_list().map(|generic_params| {
         let lifetime_params =
     let generic_args =
         generic_params.as_ref().map(|params| params.to_generic_args().clone_for_update());
     let ty = make::ty_path(make::ext::ident_path(&adt.name().unwrap().text()));
-
     let cfg_attrs =
         adt.attrs().filter(|attr| attr.as_simple_call().is_some_and(|(name, _arg)| name == "cfg"));
     match trait_ {
     .clone_for_update()
 }
 
-pub(crate) fn add_method_to_adt(
-    builder: &mut SourceChangeBuilder,
-    adt: &ast::Adt,
-    impl_def: Option<ast::Impl>,
-    method: &str,
-) {
+pub(crate) fn add_method_to_adt(builder: &mut SourceChangeBuilder, adt: &ast::Adt, impl_def: Option<ast::Impl>, method: &str) {
     let mut buf = String::with_capacity(method.len() + 2);
     if impl_def.is_some() {
         buf.push('\n');
     }
     buf.push_str(method);
-
     let start_offset = impl_def
         .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))
         .unwrap_or_else(|| {
             buf = generate_impl_text(adt, &buf);
             adt.syntax().text_range().end()
         });
-
     builder.insert(start_offset, buf);
 }
 
 
 #[derive(Debug)]
 enum ReferenceConversionType {
-    // reference can be stripped if the type is Copy
     Copy,
-    // &String -> &str
     AsRefStr,
-    // &Vec<T> -> &[T]
     AsRefSlice,
-    // &Box<T> -> &T
     Dereferenced,
-    // &Option<T> -> Option<&T>
     Option,
-    // &Result<T, E> -> Result<&T, &E>
     Result,
 }
 
 impl<'db> ReferenceConversion<'db> {
-    pub(crate) fn convert_type(
-        &self,
-        db: &'db dyn HirDatabase,
-        display_target: DisplayTarget,
-    ) -> ast::Type {
+    pub(crate) fn convert_type(&self, db: &'db dyn HirDatabase, display_target: DisplayTarget) -> ast::Type {
         let ty = match self.conversion {
             ReferenceConversionType::Copy => self.ty.display(db, display_target).to_string(),
             ReferenceConversionType::AsRefStr => "&str".to_owned(),
                 format!("Result<&{first_type_argument_name}, &{second_type_argument_name}>")
             }
         };
-
         make::ty(&ty)
     }
 
     pub(crate) fn getter(&self, field_name: String) -> ast::Expr {
         let expr = make::expr_field(make::ext::expr_self(), &field_name);
-
         match self.conversion {
             ReferenceConversionType::Copy => expr,
             ReferenceConversionType::AsRefStr
     }
 }
 
-// FIXME: It should return a new hir::Type, but currently constructing new types is too cumbersome
-//        and all users of this function operate on string type names, so they can do the conversion
-//        itself themselves.
-pub(crate) fn convert_reference_type<'db>(
-    ty: hir::Type<'db>,
-    db: &'db RootDatabase,
-    famous_defs: &FamousDefs<'_, 'db>,
-) -> Option<ReferenceConversion<'db>> {
+pub(crate) fn convert_reference_type<'db>(ty: hir::Type<'db>, db: &'db RootDatabase, famous_defs: &FamousDefs<'_, 'db>) -> Option<ReferenceConversion<'db>> {
     handle_copy(&ty, db)
         .or_else(|| handle_as_ref_str(&ty, db, famous_defs))
         .or_else(|| handle_as_ref_slice(&ty, db, famous_defs))
     ty_ref.could_coerce_to(db, &target_ref)
 }
 
-fn handle_copy(
-    ty: &hir::Type<'_>,
-    db: &dyn HirDatabase,
-) -> Option<(ReferenceConversionType, bool)> {
+fn handle_copy(ty: &hir::Type<'_>, db: &dyn HirDatabase) -> Option<(ReferenceConversionType, bool)> {
     ty.is_copy(db).then_some((ReferenceConversionType::Copy, true))
 }
 
-fn handle_as_ref_str(
-    ty: &hir::Type<'_>,
-    db: &dyn HirDatabase,
-    famous_defs: &FamousDefs<'_, '_>,
-) -> Option<(ReferenceConversionType, bool)> {
+fn handle_as_ref_str(ty: &hir::Type<'_>, db: &dyn HirDatabase, famous_defs: &FamousDefs<'_, '_>) -> Option<(ReferenceConversionType, bool)> {
     let str_type = hir::BuiltinType::str().ty(db);
-
     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&str_type))
         .then_some((ReferenceConversionType::AsRefStr, could_deref_to_target(ty, &str_type, db)))
 }
 
-fn handle_as_ref_slice(
-    ty: &hir::Type<'_>,
-    db: &dyn HirDatabase,
-    famous_defs: &FamousDefs<'_, '_>,
-) -> Option<(ReferenceConversionType, bool)> {
+fn handle_as_ref_slice(ty: &hir::Type<'_>, db: &dyn HirDatabase, famous_defs: &FamousDefs<'_, '_>) -> Option<(ReferenceConversionType, bool)> {
     let type_argument = ty.type_arguments().next()?;
     let slice_type = hir::Type::new_slice(type_argument);
-
     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&slice_type)).then_some((
         ReferenceConversionType::AsRefSlice,
         could_deref_to_target(ty, &slice_type, db),
     ))
 }
 
-fn handle_dereferenced(
-    ty: &hir::Type<'_>,
-    db: &dyn HirDatabase,
-    famous_defs: &FamousDefs<'_, '_>,
-) -> Option<(ReferenceConversionType, bool)> {
+fn handle_dereferenced(ty: &hir::Type<'_>, db: &dyn HirDatabase, famous_defs: &FamousDefs<'_, '_>) -> Option<(ReferenceConversionType, bool)> {
     let type_argument = ty.type_arguments().next()?;
-
     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&type_argument))
         .then_some((
             ReferenceConversionType::Dereferenced,
         ))
 }
 
-fn handle_option_as_ref(
-    ty: &hir::Type<'_>,
-    db: &dyn HirDatabase,
-    famous_defs: &FamousDefs<'_, '_>,
-) -> Option<(ReferenceConversionType, bool)> {
+fn handle_option_as_ref(ty: &hir::Type<'_>, db: &dyn HirDatabase, famous_defs: &FamousDefs<'_, '_>) -> Option<(ReferenceConversionType, bool)> {
     if ty.as_adt() == famous_defs.core_option_Option()?.ty(db).as_adt() {
         Some((ReferenceConversionType::Option, false))
     } else {
     }
 }
 
-fn handle_result_as_ref(
-    ty: &hir::Type<'_>,
-    db: &dyn HirDatabase,
-    famous_defs: &FamousDefs<'_, '_>,
-) -> Option<(ReferenceConversionType, bool)> {
+fn handle_result_as_ref(ty: &hir::Type<'_>, db: &dyn HirDatabase, famous_defs: &FamousDefs<'_, '_>) -> Option<(ReferenceConversionType, bool)> {
     if ty.as_adt() == famous_defs.core_result_Result()?.ty(db).as_adt() {
         Some((ReferenceConversionType::Result, false))
     } else {
     }
     res
 }
+
 #[test]
 fn test_required_hashes() {
     assert_eq!(0, required_hashes("abc"));
 pub(crate) fn string_suffix(s: &str) -> Option<&str> {
     s.rfind(['"', '\'', '#']).map(|i| &s[i + 1..])
 }
+
 #[test]
 fn test_string_suffix() {
     assert_eq!(Some(""), string_suffix(r#""abc""#));
 pub(crate) fn string_prefix(s: &str) -> Option<&str> {
     s.split_once(['"', '\'', '#']).map(|(prefix, _)| prefix)
 }
+
 #[test]
 fn test_string_prefix() {
     assert_eq!(Some(""), string_prefix(r#""abc""#));
 }
 
 /// Replaces the record expression, handling field shorthands including inside macros.
-pub(crate) fn replace_record_field_expr(
-    ctx: &AssistContext<'_>,
-    edit: &mut SourceChangeBuilder,
-    record_field: ast::RecordExprField,
-    initializer: ast::Expr,
-) {
+pub(crate) fn replace_record_field_expr(ctx: &AssistContext<'_>, edit: &mut SourceChangeBuilder, record_field: ast::RecordExprField, initializer: ast::Expr) {
     if let Some(ast::Expr::PathExpr(path_expr)) = record_field.expr() {
         // replace field shorthand
         let file_range = ctx.sema.original_range(path_expr.syntax());
 /// Assumes that the input syntax node is a valid syntax tree.
 pub(crate) fn tt_from_syntax(node: SyntaxNode) -> Vec<NodeOrToken<ast::TokenTree, SyntaxToken>> {
     let mut tt_stack = vec![(None, vec![])];
-
     for element in node.descendants_with_tokens() {
         let NodeOrToken::Token(token) = element else { continue };
 
             }
         }
     }
-
     tt_stack.pop().expect("parent token tree was closed before it was completed").1
 }
 
     is_const
 }
 
-// FIXME: #20460 When hir-ty can analyze the `never` statement at the end of block, remove it
-pub(crate) fn is_never_block(
-    sema: &Semantics<'_, RootDatabase>,
-    block_expr: &ast::BlockExpr,
-) -> bool {
+pub(crate) fn is_never_block(sema: &Semantics<'_, RootDatabase>, block_expr: &ast::BlockExpr) -> bool {
     if let Some(tail_expr) = block_expr.tail_expr() {
         sema.type_of_expr(&tail_expr).is_some_and(|ty| ty.original.is_never())
     } else if let Some(ast::Stmt::ExprStmt(expr_stmt)) = block_expr.statements().last()