COMPARISON DIFF
============================================================

Original size: 10170 bytes
Chloro size:   9727 bytes
Rustfmt size:  10229 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use hir::{
-    sym::{self},
     Name,
+    sym::{self},
 };
 use ide_db::{famous_defs::FamousDefs, syntax_helpers::suggest_name};
 use syntax::{
-    ast::{self, edit::IndentLevel, make, syntax_factory::SyntaxFactory, HasLoopBody},
-    syntax_editor::Position,
     AstNode,
+    ast::{self, HasLoopBody, edit::IndentLevel, make, syntax_factory::SyntaxFactory},
+    syntax_editor::Position,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: convert_for_loop_to_while_let
-//
-// Converts a for loop into a while let on the Iterator.
-//
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     for$0 v in x {
-//         let y = v * 2;
-//     };
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     let mut tmp = x.into_iter();
-//     while let Some(v) = tmp.next() {
-//         let y = v * 2;
-//     };
-// }
-// ```
-pub(crate) fn convert_for_loop_to_while_let(
-    acc: &mut Assists,
-    ctx: &AssistContext<'_>,
-) -> Option<()> {
+pub(crate) fn convert_for_loop_to_while_let(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let for_loop = ctx.find_node_at_offset::<ast::ForExpr>()?;
     let iterable = for_loop.iterable()?;
     let pat = for_loop.pat()?;
         cov_mark::hit!(not_available_in_body);
         return None;
     }
-
     acc.add(
         AssistId::refactor_rewrite("convert_for_loop_to_while_let"),
         "Replace this for loop with `while let`",
             {
                 (expr, Some(make.name_ref(method.as_str())))
             } else if let ast::Expr::RefExpr(_) = iterable {
-                (
-                    make::expr_paren(iterable).into(),
-                    Some(make.name_ref("into_iter")),
-                )
+                (make::expr_paren(iterable).into(), Some(make.name_ref("into_iter")))
             } else {
                 (iterable, Some(make.name_ref("into_iter")))
             };
 /// If iterable is a reference where the expression behind the reference implements a method
 /// returning an Iterator called iter or iter_mut (depending on the type of reference) then return
 /// the expression behind the reference and the method name
-fn is_ref_and_impls_iter_method(
-    sema: &hir::Semantics<'_, ide_db::RootDatabase>,
-    iterable: &ast::Expr,
-) -> Option<(ast::Expr, hir::Name)> {
+fn is_ref_and_impls_iter_method(sema: &hir::Semantics<'_, ide_db::RootDatabase>, iterable: &ast::Expr) -> Option<(ast::Expr, hir::Name)> {
     let ref_expr = match iterable {
         ast::Expr::RefExpr(r) => r,
         _ => return None,
     let scope = sema.scope(iterable.syntax())?;
     let krate = scope.krate();
     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;
-
     let has_wanted_method = ty
         .iterate_method_candidates(sema.db, &scope, None, Some(&wanted_method), |func| {
             if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {
     if !has_wanted_method {
         return None;
     }
-
     Some((expr_behind_ref, wanted_method))
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn each_to_for_simple_for() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_in_range() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn each_to_for_not_available_in_body() {
         cov_mark::check!(not_available_in_body);
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_no_iter_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_no_iter_method_mut() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut_behind_var() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_already_impls_iterator() {
         cov_mark::check!(test_already_impls_iterator);