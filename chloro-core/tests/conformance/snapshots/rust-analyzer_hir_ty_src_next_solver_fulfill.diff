COMPARISON DIFF
============================================================

Original size: 12418 bytes
Chloro size:   12198 bytes
Rustfmt size:  12418 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Fulfill loop for next-solver.
 
-mod errors;
-
 use std::{mem, ops::ControlFlow};
 
 use rustc_hash::FxHashSet;
     },
     inspect::ProofTreeVisitor,
 };
+mod errors;
 
-type PendingObligations<'db> =
-    Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
+type PendingObligations<'db> = Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
 
 /// A trait engine using the new trait solver.
 ///
 #[derive(Debug, Clone)]
 pub struct FulfillmentCtxt<'db> {
     obligations: ObligationStorage<'db>,
-
     /// The snapshot in which this context was created. Using the context
     /// outside of this snapshot leads to subtle bugs if the snapshot
     /// gets rolled back. Because of this we explicitly check that we only
 }
 
 impl<'db> ObligationStorage<'db> {
-    fn register(
-        &mut self,
-        obligation: PredicateObligation<'db>,
-        stalled_on: Option<GoalStalledOn<DbInterner<'db>>>,
-    ) {
+    fn register(&mut self, obligation: PredicateObligation<'db>, stalled_on: Option<GoalStalledOn<DbInterner<'db>>>) {
         self.pending.push((obligation, stalled_on));
     }
 
         obligations
     }
 
-    fn drain_pending(
-        &mut self,
-        cond: impl Fn(&PredicateObligation<'db>) -> bool,
-    ) -> PendingObligations<'db> {
+    fn drain_pending(&mut self, cond: impl Fn(&PredicateObligation<'db>) -> bool) -> PendingObligations<'db> {
         let (not_stalled, pending) =
             mem::take(&mut self.pending).into_iter().partition(|(o, _)| cond(o));
         self.pending = pending;
 
 impl<'db> FulfillmentCtxt<'db> {
     #[tracing::instrument(level = "trace", skip(self, _infcx))]
-    pub(crate) fn register_predicate_obligation(
-        &mut self,
-        _infcx: &InferCtxt<'db>,
-        obligation: PredicateObligation<'db>,
-    ) {
+    pub(crate) fn register_predicate_obligation(&mut self, _infcx: &InferCtxt<'db>, obligation: PredicateObligation<'db>) {
         // FIXME: See the comment in `try_evaluate_obligations()`.
         // assert_eq!(self.usable_in_snapshot, infcx.num_open_snapshots());
         self.obligations.register(obligation, None);
     }
 
-    pub(crate) fn register_predicate_obligations(
-        &mut self,
-        _infcx: &InferCtxt<'db>,
-        obligations: impl IntoIterator<Item = PredicateObligation<'db>>,
-    ) {
+    pub(crate) fn register_predicate_obligations(&mut self, _infcx: &InferCtxt<'db>, obligations: impl IntoIterator<Item = PredicateObligation<'db>>) {
         // FIXME: See the comment in `try_evaluate_obligations()`.
         // assert_eq!(self.usable_in_snapshot, infcx.num_open_snapshots());
         obligations.into_iter().for_each(|obligation| self.obligations.register(obligation, None));
     }
 
-    pub(crate) fn collect_remaining_errors(
-        &mut self,
-        _infcx: &InferCtxt<'db>,
-    ) -> Vec<NextSolverError<'db>> {
+    pub(crate) fn collect_remaining_errors(&mut self, _infcx: &InferCtxt<'db>) -> Vec<NextSolverError<'db>> {
         self.obligations
             .pending
             .drain(..)
             .collect()
     }
 
-    pub(crate) fn try_evaluate_obligations(
-        &mut self,
-        infcx: &InferCtxt<'db>,
-    ) -> Vec<NextSolverError<'db>> {
+    pub(crate) fn try_evaluate_obligations(&mut self, infcx: &InferCtxt<'db>) -> Vec<NextSolverError<'db>> {
         // FIXME(next-solver): We should bring this assertion back. Currently it panics because
         // there are places which use `InferenceTable` and open a snapshot and register obligations
         // and select. They should use a different `ObligationCtxt` instead. Then we'll be also able
                 break;
             }
         }
-
         errors
     }
 
-    pub(crate) fn evaluate_obligations_error_on_ambiguity(
-        &mut self,
-        infcx: &InferCtxt<'db>,
-    ) -> Vec<NextSolverError<'db>> {
+    pub(crate) fn evaluate_obligations_error_on_ambiguity(&mut self, infcx: &InferCtxt<'db>) -> Vec<NextSolverError<'db>> {
         let errors = self.try_evaluate_obligations(infcx);
         if !errors.is_empty() {
             return errors;
         }
-
         self.collect_remaining_errors(infcx)
     }
 
         self.obligations.clone_pending()
     }
 
-    pub(crate) fn drain_stalled_obligations_for_coroutines(
-        &mut self,
-        infcx: &InferCtxt<'db>,
-    ) -> PredicateObligations<'db> {
+    pub(crate) fn drain_stalled_obligations_for_coroutines(&mut self, infcx: &InferCtxt<'db>) -> PredicateObligations<'db> {
         let stalled_coroutines = match infcx.typing_mode() {
             TypingMode::Analysis { defining_opaque_types_and_generators } => {
                 defining_opaque_types_and_generators
             | TypingMode::PostAnalysis => return Default::default(),
         };
         let stalled_coroutines = stalled_coroutines.inner();
-
         if stalled_coroutines.is_empty() {
             return Default::default();
         }
-
         self.obligations
             .drain_pending(|obl| {
                 infcx.probe(|_| {
 
     fn visit_goal(&mut self, inspect_goal: &super::inspect::InspectGoal<'_, 'db>) -> Self::Result {
         inspect_goal.goal().predicate.visit_with(self)?;
-
         if let Some(candidate) = inspect_goal.unique_applicable_candidate() {
             candidate.visit_nested_no_probe(self)
         } else {
         if !self.cache.insert(ty) {
             return ControlFlow::Continue(());
         }
-
         if let TyKind::Coroutine(def_id, _) = ty.kind()
             && self.stalled_coroutines.contains(&def_id.into())
         {