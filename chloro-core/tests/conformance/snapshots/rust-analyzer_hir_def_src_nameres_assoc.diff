COMPARISON DIFF
============================================================

Original size: 14069 bytes
Chloro size:   13827 bytes
Rustfmt size:  14657 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Expansion of associated items
 
 use std::mem;
 
 use cfg::CfgOptions;
 use hir_expand::{
+    AstId, ExpandTo, HirFileId, InFile, Intern, Lookup, MacroCallKind, MacroDefKind,
     mod_path::ModPath,
     name::{AsName, Name},
     span_map::SpanMap,
-    AstId, ExpandTo, HirFileId, InFile, Intern, Lookup, MacroCallKind, MacroDefKind,
 };
 use intern::Interned;
 use span::AstIdMap;
 use syntax::{
-    ast::{self, HasModuleItem, HasName},
     AstNode,
+    ast::{self, HasModuleItem, HasName},
 };
 use thin_vec::ThinVec;
 use triomphe::Arc;
 
 use crate::{
+    AssocItemId, AstIdWithPath, ConstLoc, FunctionId, FunctionLoc, ImplId, ItemContainerId,
+    ItemLoc, MacroCallId, ModuleId, TraitId, TypeAliasId, TypeAliasLoc,
     attr::Attrs,
     db::DefDatabase,
     macro_call_as_call_id,
     nameres::{
+        DefMap, LocalDefMap, MacroSubNs,
         attr_resolution::ResolvedAttr,
         diagnostics::{DefDiagnostic, DefDiagnostics},
-        DefMap, LocalDefMap, MacroSubNs,
     },
-    AssocItemId, AstIdWithPath, ConstLoc, FunctionId, FunctionLoc, ImplId, ItemContainerId,
-    ItemLoc, MacroCallId, ModuleId, TraitId, TypeAliasId, TypeAliasLoc,
 };
-
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub struct TraitItems {
     pub items: Box<[(Name, AssocItemId)]>,
-    // `ThinVec` as the vec is usually empty anyways
     pub macro_calls: ThinVec<(AstId<ast::Item>, MacroCallId)>,
 }
 
-#[salsa::tracked]
 impl TraitItems {
     #[inline]
     pub(crate) fn query(db: &dyn DefDatabase, tr: TraitId) -> &TraitItems {
     }
 
     #[salsa::tracked(returns(ref))]
-    pub fn query_with_diagnostics(
-        db: &dyn DefDatabase,
-        tr: TraitId,
-    ) -> (TraitItems, DefDiagnostics) {
-        let ItemLoc {
-            container: module_id,
-            id: ast_id,
-        } = tr.lookup(db);
+    pub fn query_with_diagnostics(db: &dyn DefDatabase, tr: TraitId) -> (TraitItems, DefDiagnostics) {
+        let ItemLoc { container: module_id, id: ast_id } = tr.lookup(db);
         let ast_id_map = db.ast_id_map(ast_id.file_id);
         let source = ast_id.with_value(ast_id_map.get(ast_id.value)).to_node(db);
         if source.eq_token().is_some() {
             // FIXME(trait-alias) probably needs special handling here
             return (
-                TraitItems {
-                    macro_calls: ThinVec::new(),
-                    items: Box::default(),
-                },
+                TraitItems { macro_calls: ThinVec::new(), items: Box::default() },
                 DefDiagnostics::new(vec![]),
             );
         }
-
         let collector =
             AssocItemCollector::new(db, module_id, ItemContainerId::TraitId(tr), ast_id.file_id);
         let (items, macro_calls, diagnostics) = collector.collect(source.assoc_item_list());
-
-        (
-            TraitItems { macro_calls, items },
-            DefDiagnostics::new(diagnostics),
-        )
+        (TraitItems { macro_calls, items }, DefDiagnostics::new(diagnostics))
     }
 
     pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {
     }
 
     pub fn assoc_item_by_name(&self, name: &Name) -> Option<AssocItemId> {
-        self.items
-            .iter()
-            .find_map(|&(ref item_name, item)| match item {
-                AssocItemId::FunctionId(_) if item_name == name => Some(item),
-                AssocItemId::TypeAliasId(_) if item_name == name => Some(item),
-                AssocItemId::ConstId(_) if item_name == name => Some(item),
-                _ => None,
-            })
+        self.items.iter().find_map(|&(ref item_name, item)| match item {
+            AssocItemId::FunctionId(_) if item_name == name => Some(item),
+            AssocItemId::TypeAliasId(_) if item_name == name => Some(item),
+            AssocItemId::ConstId(_) if item_name == name => Some(item),
+            _ => None,
+        })
     }
 
     pub fn macro_calls(&self) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {
 #[derive(Debug, PartialEq, Eq)]
 pub struct ImplItems {
     pub items: Box<[(Name, AssocItemId)]>,
-    // `ThinVec` as the vec is usually empty anyways
     pub macro_calls: ThinVec<(AstId<ast::Item>, MacroCallId)>,
 }
 
-#[salsa::tracked]
 impl ImplItems {
     #[salsa::tracked(returns(ref))]
     pub fn of(db: &dyn DefDatabase, id: ImplId) -> (ImplItems, DefDiagnostics) {
         let _p = tracing::info_span!("impl_items_with_diagnostics_query").entered();
-        let ItemLoc {
-            container: module_id,
-            id: ast_id,
-        } = id.lookup(db);
-
+        let ItemLoc { container: module_id, id: ast_id } = id.lookup(db);
         let collector =
             AssocItemCollector::new(db, module_id, ItemContainerId::ImplId(id), ast_id.file_id);
-        let source = ast_id
-            .with_value(collector.ast_id_map.get(ast_id.value))
-            .to_node(db);
+        let source = ast_id.with_value(collector.ast_id_map.get(ast_id.value)).to_node(db);
         let (items, macro_calls, diagnostics) = collector.collect(source.assoc_item_list());
-
-        (
-            ImplItems { items, macro_calls },
-            DefDiagnostics::new(diagnostics),
-        )
+        (ImplItems { items, macro_calls }, DefDiagnostics::new(diagnostics))
     }
 }
 
     file_id: HirFileId,
     diagnostics: Vec<DefDiagnostic>,
     container: ItemContainerId,
-
     depth: usize,
     items: Vec<(Name, AssocItemId)>,
     macro_calls: ThinVec<(AstId<ast::Item>, MacroCallId)>,
 }
 
 impl<'a> AssocItemCollector<'a> {
-    fn new(
-        db: &'a dyn DefDatabase,
-        module_id: ModuleId,
-        container: ItemContainerId,
-        file_id: HirFileId,
-    ) -> Self {
+    fn new(db: &'a dyn DefDatabase, module_id: ModuleId, container: ItemContainerId, file_id: HirFileId) -> Self {
         let (def_map, local_def_map) = module_id.local_def_map(db);
         Self {
             db,
         }
     }
 
-    fn collect(
-        mut self,
-        item_list: Option<ast::AssocItemList>,
-    ) -> (
-        Box<[(Name, AssocItemId)]>,
-        ThinVec<(AstId<ast::Item>, MacroCallId)>,
-        Vec<DefDiagnostic>,
-    ) {
+    fn collect(mut self, item_list: Option<ast::AssocItemList>) -> (Box<[(Name, AssocItemId)]>, ThinVec<(AstId<ast::Item>, MacroCallId)>, Vec<DefDiagnostic>) {
         if let Some(item_list) = item_list {
             for item in item_list.assoc_items() {
                 self.collect_item(item);
             }
         }
         self.macro_calls.shrink_to_fit();
-        (
-            self.items.into_boxed_slice(),
-            self.macro_calls,
-            self.diagnostics,
-        )
+        (self.items.into_boxed_slice(), self.macro_calls, self.diagnostics)
     }
 
     fn collect_item(&mut self, item: ast::AssocItem) {
             return;
         }
         let ast_id = InFile::new(self.file_id, ast_id.upcast());
-
         'attrs: for attr in &*attrs {
-            let ast_id_with_path = AstIdWithPath {
-                path: attr.path.clone(),
-                ast_id,
-            };
+            let ast_id_with_path = AstIdWithPath { path: attr.path.clone(), ast_id };
 
             match self.def_map.resolve_attr_macro(
                 self.local_def_map,
                 Err(_) => {
                     self.diagnostics.push(DefDiagnostic::unresolved_macro_call(
                         self.module_id.local_id,
-                        MacroCallKind::Attr {
-                            ast_id,
-                            attr_args: None,
-                            invoc_attr_index: attr.id,
-                        },
+                        MacroCallKind::Attr { ast_id, attr_args: None, invoc_attr_index: attr.id },
                         attr.path().clone(),
                     ));
                 }
             }
         }
-
         self.record_item(item);
     }
 
                 self.items.push((name.as_name(), def.into()));
             }
             ast::AssocItem::TypeAlias(type_alias) => {
-                let Some(name) = type_alias.name() else {
-                    return;
-                };
+                let Some(name) = type_alias.name() else { return };
                 let ast_id = self.ast_id_map.ast_id(&type_alias);
                 let def = TypeAliasLoc {
                     container: self.container,
             ast::AssocItem::Const(konst) => {
                 let Some(name) = konst.name() else { return };
                 let ast_id = self.ast_id_map.ast_id(&konst);
-                let def = ConstLoc {
-                    container: self.container,
-                    id: InFile::new(self.file_id, ast_id),
-                }
-                .intern(self.db);
+                let def =
+                    ConstLoc { container: self.container, id: InFile::new(self.file_id, ast_id) }
+                        .intern(self.db);
                 self.items.push((name.as_name(), def.into()));
             }
             ast::AssocItem::MacroCall(call) => {
                     self.module_id.krate(),
                     resolver,
                     &mut |ptr, call_id| {
-                        self.macro_calls
-                            .push((ptr.map(|(_, it)| it.upcast()), call_id))
+                        self.macro_calls.push((ptr.map(|(_, it)| it.upcast()), call_id))
                     },
                 ) {
                     // FIXME: Expansion error?
             tracing::warn!("macro expansion is too deep");
             return;
         }
-
         let (syntax, span_map) = self.db.parse_macro_expansion(macro_call_id).value;
         let old_file_id = mem::replace(&mut self.file_id, macro_call_id.into());
         let old_ast_id_map = mem::replace(&mut self.ast_id_map, self.db.ast_id_map(self.file_id));
         let old_span_map = mem::replace(&mut self.span_map, SpanMap::ExpansionSpanMap(span_map));
         self.depth += 1;
-
         let items = ast::MacroItems::cast(syntax.syntax_node()).expect("not `MacroItems`");
         for item in items.items() {
             let item = match item {
             };
             self.collect_item(item);
         }
-
         self.depth -= 1;
         self.file_id = old_file_id;
         self.ast_id_map = old_ast_id_map;