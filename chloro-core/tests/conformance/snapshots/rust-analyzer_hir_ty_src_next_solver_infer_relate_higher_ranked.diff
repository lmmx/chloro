COMPARISON DIFF
============================================================

Original size: 3643 bytes
Chloro size:   3632 bytes
Rustfmt size:  3850 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     #[instrument(level = "debug", skip(self), ret)]
     pub fn enter_forall_and_leak_universe<T>(&self, binder: Binder<'db, T>) -> T
     where
-        T: TypeFoldable<DbInterner<'db>> + Clone,
-    {
+        T: TypeFoldable<DbInterner<'db>> + Clone, {
         if let Some(inner) = binder.clone().no_bound_vars() {
             return inner;
         }
-
         let next_universe = self.create_next_universe();
-
         let delegate = FnMutDelegate {
             regions: &mut |br: BoundRegion| {
                 Region::new_placeholder(
                     self.interner,
-                    PlaceholderRegion {
-                        universe: next_universe,
-                        bound: br,
-                    },
+                    PlaceholderRegion { universe: next_universe, bound: br },
                 )
             },
             types: &mut |bound_ty: BoundTy| {
                 Ty::new_placeholder(
                     self.interner,
-                    PlaceholderTy {
-                        universe: next_universe,
-                        bound: bound_ty,
-                    },
+                    PlaceholderTy { universe: next_universe, bound: bound_ty },
                 )
             },
             consts: &mut |bound: BoundConst| {
                 Const::new_placeholder(
                     self.interner,
-                    PlaceholderConst {
-                        universe: next_universe,
-                        bound,
-                    },
+                    PlaceholderConst { universe: next_universe, bound },
                 )
             },
         };
-
         debug!(?next_universe);
         self.interner.replace_bound_vars_uncached(binder, delegate)
     }
     #[instrument(level = "debug", skip(self, f))]
     pub fn enter_forall<T, U>(&self, forall: Binder<'db, T>, f: impl FnOnce(T) -> U) -> U
     where
-        T: TypeFoldable<DbInterner<'db>> + Clone,
-    {
+        T: TypeFoldable<DbInterner<'db>> + Clone, {
         // FIXME: currently we do nothing to prevent placeholders with the new universe being
         // used after exiting `f`. For example region subtyping can result in outlives constraints
         // that name placeholders created in this function. Nested goals from type relations can