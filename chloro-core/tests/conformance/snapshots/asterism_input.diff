COMPARISON DIFF
============================================================

Original size: 7367 bytes
Chloro size:   7358 bytes
Rustfmt size:  7367 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 fn find_in_directory(dir: &Path, extensions: &[String]) -> io::Result<Vec<PathBuf>> {
     let mut results = Vec::new();
-
     if let Ok(entries) = fs::read_dir(dir) {
         for entry in entries.flatten() {
             let path = entry.path();
             }
         }
     }
-
     Ok(results)
 }
 
 /// Returns an error if file reading or parsing fails.
 pub fn extract_sections<F: Format>(file_path: &Path, format: &F) -> io::Result<Vec<Section>> {
     let content = fs::read_to_string(file_path)?;
-
     let mut parser = Parser::new();
     parser
         .set_language(&format.language())
         .map_err(|e| io::Error::other(format!("Language error: {e}")))?;
-
     let tree = parser
         .parse(&content, None)
         .ok_or_else(|| io::Error::other("Parse failed"))?;
-
     let section_query = Query::new(&format.language(), format.section_query())
         .map_err(|e| io::Error::other(format!("Query error: {e}")))?;
-
     let title_query = Query::new(&format.language(), format.title_query())
         .map_err(|e| io::Error::other(format!("Query error: {e}")))?;
-
     // Collect all heading nodes by traversing the entire tree
     let mut headings: Vec<tree_sitter::Node> = Vec::new();
     let mut cursor = QueryCursor::new();
     let mut matches = cursor.matches(&section_query, tree.root_node(), content.as_bytes());
-
     while let Some(m) = matches.next() {
         if let Some(c) = m.captures.first() {
             headings.push(c.node);
         }
     }
-
     let mut sections = Vec::new();
-
     for (i, heading) in headings.iter().enumerate() {
         // Determine level from the heading marker child node
         let mut level = 1;
             rhs_content: None,
         });
     }
-
     // Build parent/child relationships
     build_hierarchy(&mut sections);
-
     Ok(sections)
 }
 
 fn build_hierarchy(sections: &mut [Section]) {
-    let mut stack: Vec<(usize, usize)> = Vec::new(); // (index, level)
-
+    let mut stack: Vec<(usize, usize)> = Vec::new();
+    // (index, level)
     for i in 0..sections.len() {
         let current_level = sections[i].level;
 