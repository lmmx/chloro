COMPARISON DIFF
============================================================

Original size: 15570 bytes
Chloro size:   15259 bytes
Rustfmt size:  15570 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! See [RequestDispatcher].
+
 use std::{
     fmt::{self, Debug},
     panic, thread,
     main_loop::Task,
     version::version,
 };
-
 /// A visitor for routing a raw JSON request to an appropriate handler function.
 ///
 /// Most requests are read-only and async and are handled on the threadpool
     /// Dispatches the request onto the current thread, given full access to
     /// mutable global state. Unlike all other methods here, this one isn't
     /// guarded by `catch_unwind`, so, please, don't make bugs :-)
-    pub(crate) fn on_sync_mut<R>(
-        &mut self,
-        f: fn(&mut GlobalState, R::Params) -> anyhow::Result<R::Result>,
-    ) -> &mut Self
+    pub(crate) fn on_sync_mut<R>(&mut self, f: fn(&mut GlobalState, R::Params) -> anyhow::Result<R::Result>) -> &mut Self
     where
         R: lsp_types::request::Request,
         R::Params: DeserializeOwned + panic::UnwindSafe + fmt::Debug,
-        R::Result: Serialize,
-    {
+        R::Result: Serialize, {
         let (req, params, panic_context) = match self.parse::<R>() {
             Some(it) => it,
             None => return self,
         if let Ok(response) = result_to_response::<R>(req.id, result) {
             self.global_state.respond(response);
         }
-
         self
     }
 
     /// Dispatches the request onto the current thread.
-    pub(crate) fn on_sync<R>(
-        &mut self,
-        f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>,
-    ) -> &mut Self
+    pub(crate) fn on_sync<R>(&mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>) -> &mut Self
     where
         R: lsp_types::request::Request,
         R::Params: DeserializeOwned + panic::UnwindSafe + fmt::Debug,
-        R::Result: Serialize,
-    {
+        R::Result: Serialize, {
         let (req, params, panic_context) = match self.parse::<R>() {
             Some(it) => it,
             None => return self,
             tracing::info_span!("request", method = ?req.method, "request_id" = ?req.id).entered();
         tracing::debug!(?params);
         let global_state_snapshot = self.global_state.snapshot();
-
         let result = panic::catch_unwind(move || {
             let _pctx = DbPanicContext::enter(panic_context);
             f(global_state_snapshot, params)
         });
-
         if let Ok(response) = thread_result_to_response::<R>(req.id, result) {
             self.global_state.respond(response);
         }
-
         self
     }
 
     /// Dispatches a non-latency-sensitive request onto the thread pool. When the VFS is marked not
     /// ready this will return a default constructed [`R::Result`].
-    pub(crate) fn on<const ALLOW_RETRYING: bool, R>(
-        &mut self,
-        f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>,
-    ) -> &mut Self
+    pub(crate) fn on<const ALLOW_RETRYING: bool, R>(&mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>) -> &mut Self
     where
         R: lsp_types::request::Request<
                 Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
                 Result: Serialize + Default,
-            > + 'static,
-    {
+            > + 'static, {
         if !self.global_state.vfs_done {
             if let Some(lsp_server::Request { id, .. }) =
                 self.req.take_if(|it| it.method == R::METHOD)
 
     /// Dispatches a non-latency-sensitive request onto the thread pool. When the VFS is marked not
     /// ready this will return a `default` constructed [`R::Result`].
-    pub(crate) fn on_with_vfs_default<R>(
-        &mut self,
-        f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>,
-        default: impl FnOnce() -> R::Result,
-        on_cancelled: fn() -> ResponseError,
-    ) -> &mut Self
+    pub(crate) fn on_with_vfs_default<R>(&mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, default: impl FnOnce() -> R::Result, on_cancelled: fn() -> ResponseError) -> &mut Self
     where
         R: lsp_types::request::Request<
                 Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
                 Result: Serialize,
-            > + 'static,
-    {
+            > + 'static, {
         if !self.global_state.vfs_done || self.global_state.incomplete_crate_graph {
             if let Some(lsp_server::Request { id, .. }) =
                 self.req.take_if(|it| it.method == R::METHOD)
 
     /// Dispatches a non-latency-sensitive request onto the thread pool. When the VFS is marked not
     /// ready this will return the parameter as is.
-    pub(crate) fn on_identity<const ALLOW_RETRYING: bool, R, Params>(
-        &mut self,
-        f: fn(GlobalStateSnapshot, Params) -> anyhow::Result<R::Result>,
-    ) -> &mut Self
+    pub(crate) fn on_identity<const ALLOW_RETRYING: bool, R, Params>(&mut self, f: fn(GlobalStateSnapshot, Params) -> anyhow::Result<R::Result>) -> &mut Self
     where
         R: lsp_types::request::Request<Params = Params, Result = Params> + 'static,
-        Params: Serialize + DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
-    {
+        Params: Serialize + DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, {
         if !self.global_state.vfs_done {
             if let Some((request, params, _)) = self.parse::<R>() {
                 self.global_state.respond(lsp_server::Response::new_ok(request.id, &params))
 
     /// Dispatches a latency-sensitive request onto the thread pool. When the VFS is marked not
     /// ready this will return a default constructed [`R::Result`].
-    pub(crate) fn on_latency_sensitive<const ALLOW_RETRYING: bool, R>(
-        &mut self,
-        f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>,
-    ) -> &mut Self
+    pub(crate) fn on_latency_sensitive<const ALLOW_RETRYING: bool, R>(&mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>) -> &mut Self
     where
         R: lsp_types::request::Request<
                 Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
                 Result: Serialize + Default,
-            > + 'static,
-    {
+            > + 'static, {
         if !self.global_state.vfs_done {
             if let Some(lsp_server::Request { id, .. }) =
                 self.req.take_if(|it| it.method == R::METHOD)
     /// Formatting requests should never block on waiting a for task thread to open up, editors will wait
     /// on the response and a late formatting update might mess with the document and user.
     /// We can't run this on the main thread though as we invoke rustfmt which may take arbitrary time to complete!
-    pub(crate) fn on_fmt_thread<R>(
-        &mut self,
-        f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>,
-    ) -> &mut Self
+    pub(crate) fn on_fmt_thread<R>(&mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>) -> &mut Self
     where
         R: lsp_types::request::Request + 'static,
         R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
-        R::Result: Serialize,
-    {
+        R::Result: Serialize, {
         self.on_with_thread_intent::<true, false, R>(
             ThreadIntent::LatencySensitive,
             f,
         }
     }
 
-    fn on_with_thread_intent<const RUSTFMT: bool, const ALLOW_RETRYING: bool, R>(
-        &mut self,
-        intent: ThreadIntent,
-        f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>,
-        on_cancelled: fn() -> ResponseError,
-    ) -> &mut Self
+    fn on_with_thread_intent<const RUSTFMT: bool, const ALLOW_RETRYING: bool, R>(&mut self, intent: ThreadIntent, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, on_cancelled: fn() -> ResponseError) -> &mut Self
     where
         R: lsp_types::request::Request + 'static,
         R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
-        R::Result: Serialize,
-    {
+        R::Result: Serialize, {
         let (req, params, panic_context) = match self.parse::<R>() {
             Some(it) => it,
             None => return self,
         let _guard =
             tracing::info_span!("request", method = ?req.method, "request_id" = ?req.id).entered();
         tracing::debug!(?params);
-
         let world = self.global_state.snapshot();
         if RUSTFMT {
             &mut self.global_state.fmt_pool.handle
                 }
             }
         });
-
         self
     }
 
     fn parse<R>(&mut self) -> Option<(lsp_server::Request, R::Params, String)>
     where
         R: lsp_types::request::Request,
-        R::Params: DeserializeOwned + fmt::Debug,
-    {
+        R::Params: DeserializeOwned + fmt::Debug, {
         let req = self.req.take_if(|it| it.method == R::METHOD)?;
         let res = crate::from_json(R::METHOD, &req.params);
         match res {
     }
 }
 
-fn thread_result_to_response<R>(
-    id: lsp_server::RequestId,
-    result: thread::Result<anyhow::Result<R::Result>>,
-) -> Result<lsp_server::Response, HandlerCancelledError>
+fn thread_result_to_response<R>(id: lsp_server::RequestId, result: thread::Result<anyhow::Result<R::Result>>) -> Result<lsp_server::Response, HandlerCancelledError>
 where
     R: lsp_types::request::Request,
     R::Params: DeserializeOwned,
-    R::Result: Serialize,
-{
+    R::Result: Serialize, {
     match result {
         Ok(result) => result_to_response::<R>(id, result),
         Err(panic) => {
     }
 }
 
-fn result_to_response<R>(
-    id: lsp_server::RequestId,
-    result: anyhow::Result<R::Result>,
-) -> Result<lsp_server::Response, HandlerCancelledError>
+fn result_to_response<R>(id: lsp_server::RequestId, result: anyhow::Result<R::Result>) -> Result<lsp_server::Response, HandlerCancelledError>
 where
     R: lsp_types::request::Request,
     R::Params: DeserializeOwned,
-    R::Result: Serialize,
-{
+    R::Result: Serialize, {
     let res = match result {
         Ok(resp) => lsp_server::Response::new_ok(id, &resp),
         Err(e) => match e.downcast::<LspError>() {
 }
 
 impl NotificationDispatcher<'_> {
-    pub(crate) fn on_sync_mut<N>(
-        &mut self,
-        f: fn(&mut GlobalState, N::Params) -> anyhow::Result<()>,
-    ) -> &mut Self
+    pub(crate) fn on_sync_mut<N>(&mut self, f: fn(&mut GlobalState, N::Params) -> anyhow::Result<()>) -> &mut Self
     where
         N: lsp_types::notification::Notification,
-        N::Params: DeserializeOwned + Send + Debug,
-    {
+        N::Params: DeserializeOwned + Send + Debug, {
         let not = match self.not.take() {
             Some(it) => it,
             None => return self,
         };
-
         let _guard = tracing::info_span!("notification", method = ?not.method).entered();
-
         let params = match not.extract::<N::Params>(N::METHOD) {
             Ok(it) => it,
             Err(ExtractError::JsonError { method, error }) => {
                 return self;
             }
         };
-
         tracing::debug!(?params);
-
         let _pctx =
             DbPanicContext::enter(format!("\nversion: {}\nnotification: {}", version(), N::METHOD));
         if let Err(e) = f(self.global_state, params) {