COMPARISON DIFF
============================================================

Original size: 27466 bytes
Chloro size:   27457 bytes
Rustfmt size:  27512 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use expect_test::expect;
-
 use itertools::Itertools;
 use span::Edition;
 
 use super::*;
-
 #[test]
 fn macro_rules_are_globally_visible() {
     check(
 fn unresolved_attributes_fall_back_track_per_file_moditems() {
     // Tests that we track per-file ModItems when ignoring an unresolved attribute.
     // Just tracking the `ModItem` leads to `Foo` getting ignored.
-
     check(
         r#"
         //- /main.rs crate:main
 #[test]
 fn proc_macro_censoring() {
     // Make sure that only proc macros are publicly exported from proc-macro crates.
-
     check(
         r#"
 //- /main.rs crate:main deps:macros
     );
     let krate = *db.all_crates().last().expect("no crate graph present");
     let def_map = crate_def_map(&db, krate);
-
     assert_eq!(def_map.data.exported_derives.len(), 1);
     match def_map.data.exported_derives.values().next() {
         Some(helpers) => match &**helpers {
-            [attr] => assert_eq!(
-                attr.display(&db, Edition::CURRENT).to_string(),
-                "helper_attr"
-            ),
+            [attr] => assert_eq!(attr.display(&db, Edition::CURRENT).to_string(), "helper_attr"),
             _ => unreachable!(),
         },
         _ => unreachable!(),
 fn eager_macro_correctly_resolves_contents() {
     // Eager macros resolve any contained macros when expanded. This should work correctly with the
     // usual name resolution rules, so both of these `include!`s should include the right file.
-
     check(
         r#"
 //- /lib.rs
     );
     let krate = *db.all_crates().last().expect("no crate graph present");
     let def_map = crate_def_map(&db, krate);
-
     let root_module = &def_map[DefMap::ROOT].scope;
     assert!(
         root_module.legacy_macros().count() == 0,
         "`#[macro_use]` shouldn't bring macros into textual macro scope",
     );
-
     let actual = def_map
         .macro_use_prelude
         .keys()
         .map(|name| name.display(&db, Edition::CURRENT).to_string())
         .sorted()
         .join("\n");
-
     expect![[r#"
         legacy
         macro20