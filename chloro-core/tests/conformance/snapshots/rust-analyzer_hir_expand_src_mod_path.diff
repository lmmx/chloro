COMPARISON DIFF
============================================================

Original size: 13520 bytes
Chloro size:   13300 bytes
Rustfmt size:  13520 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     iter,
 };
 
+use base_db::Crate;
+use intern::sym;
+use smallvec::SmallVec;
+use span::{Edition, SyntaxContext};
+use syntax::{AstNode, ast};
+
+pub use crate::__path as path;
+pub use crate::__tool_path as tool_path;
+pub use crate::name as __name;
 use crate::{
     db::ExpandDatabase,
     hygiene::Transparency,
     name::{AsName, Name},
     tt,
 };
-use base_db::Crate;
-use intern::sym;
-use smallvec::SmallVec;
-use span::{Edition, SyntaxContext};
-use syntax::{AstNode, ast};
 
 #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
 pub struct ModPath {
     Crate,
     /// Absolute path (::foo)
     Abs,
-    // FIXME: Can we remove this somehow?
     /// `$crate` from macro expansion
     DollarCrate(Crate),
 }
 
 impl PathKind {
-    pub const SELF: PathKind = PathKind::Super(0);
 }
 
 impl ModPath {
-    pub fn from_src(
-        db: &dyn ExpandDatabase,
-        path: ast::Path,
-        span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext,
-    ) -> Option<ModPath> {
+    pub fn from_src(db: &dyn ExpandDatabase, path: ast::Path, span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext) -> Option<ModPath> {
         convert_path(db, path, span_for_range)
     }
 
         if self.kind != PathKind::Plain {
             return None;
         }
-
         match &*self.segments {
             [name] => Some(name),
             _ => None,
         }
     }
-    pub fn display_verbatim<'a>(
-        &'a self,
-        db: &'a dyn crate::db::ExpandDatabase,
-    ) -> impl fmt::Display + 'a {
+
+    pub fn display_verbatim<'a>(&'a self, db: &'a dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {
         Display { db, path: self, edition: None }
     }
 
-    pub fn display<'a>(
-        &'a self,
-        db: &'a dyn crate::db::ExpandDatabase,
-        edition: Edition,
-    ) -> impl fmt::Display + 'a {
+    pub fn display<'a>(&'a self, db: &'a dyn crate::db::ExpandDatabase, edition: Edition) -> impl fmt::Display + 'a {
         Display { db, path: self, edition: Some(edition) }
     }
 }
     }
 }
 
-fn display_fmt_path(
-    db: &dyn ExpandDatabase,
-    path: &ModPath,
-    f: &mut fmt::Formatter<'_>,
-    edition: Option<Edition>,
-) -> fmt::Result {
+fn display_fmt_path(db: &dyn ExpandDatabase, path: &ModPath, f: &mut fmt::Formatter<'_>, edition: Option<Edition>) -> fmt::Result {
     let mut first_segment = true;
     let mut add_segment = |s| -> fmt::Result {
         if !first_segment {
     Ok(())
 }
 
-fn convert_path(
-    db: &dyn ExpandDatabase,
-    path: ast::Path,
-    span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext,
-) -> Option<ModPath> {
+fn convert_path(db: &dyn ExpandDatabase, path: ast::Path, span_for_range: &mut dyn FnMut(::tt::TextRange) -> SyntaxContext) -> Option<ModPath> {
     let mut segments = path.segments();
-
     let segment = &segments.next()?;
     let handle_super_kw = &mut |init_deg| {
         let mut deg = init_deg;
 
         Some(ModPath::from_segments(PathKind::Super(deg), next_segment))
     };
-
     let mut mod_path = match segment.kind()? {
         ast::PathSegmentKind::Name(name_ref) => {
             if name_ref.text() == "$crate" {
             return None;
         }
     };
-
     for segment in segments {
         let name = match segment.kind()? {
             ast::PathSegmentKind::Name(name) => name.as_name(),
         };
         mod_path.segments.push(name);
     }
-
     // handle local_inner_macros :
     // Basically, even in rustc it is quite hacky:
     // https://github.com/rust-lang/rust/blob/614f273e9388ddd7804d5cbc80b8865068a3744e/src/librustc_resolve/macros.rs#L456
             }
         }
     }
-
     Some(mod_path)
 }
 
     while let Some((mark, Transparency::SemiTransparent)) = iter.next() {
         result_mark = Some(mark);
     }
-
     result_mark.map(|call| db.lookup_intern_macro_call(call.into()).def.krate)
 }
 
-pub use crate::name as __name;
-
 #[macro_export]
 macro_rules! __known_path {
     (core::iter::IntoIterator) => {};
     });
 }
 
-pub use crate::__path as path;
-
 #[macro_export]
 macro_rules! __tool_path {
     ($start:ident $(:: $seg:ident)*) => ({
         ])
     });
 }
-
-pub use crate::__tool_path as tool_path;