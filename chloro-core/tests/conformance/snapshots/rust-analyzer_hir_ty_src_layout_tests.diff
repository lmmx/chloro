COMPARISON DIFF
============================================================

Original size: 15972 bytes
Chloro size:   15899 bytes
Rustfmt size:  15995 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use base_db::target::TargetData;
 use either::Either;
 use hir_def::db::DefDatabase;
-use project_model::{toolchain_info::QueryConfig, Sysroot};
+use project_model::{Sysroot, toolchain_info::QueryConfig};
 use rustc_hash::FxHashMap;
 use rustc_type_ir::inherent::GenericArgs as _;
 use syntax::ToSmolStr;
     setup_tracing,
     test_db::TestDB,
 };
-
 mod closure;
 
 fn current_machine_target_data() -> TargetData {
     .unwrap()
 }
 
-fn eval_goal(
-    #[rust_analyzer::rust_fixture] ra_fixture: &str,
-    minicore: &str,
-) -> Result<Arc<Layout>, LayoutError> {
+fn eval_goal(#[rust_analyzer::rust_fixture] ra_fixture: &str, minicore: &str) -> Result<Arc<Layout>, LayoutError> {
     let _tracing = setup_tracing();
     let target_data = current_machine_target_data();
     let target_data_layout = target_data.data_layout;
     let ra_fixture = format!(
         "//- target_data_layout: {target_data_layout}\n{minicore}//- /main.rs crate:test\n{ra_fixture}",
     );
-
     let (db, file_ids) = TestDB::with_many_files(&ra_fixture);
     let adt_or_type_alias_id = file_ids
         .into_iter()
 }
 
 /// A version of `eval_goal` for types that can not be expressed in ADTs, like closures and `impl Trait`
-fn eval_expr(
-    #[rust_analyzer::rust_fixture] ra_fixture: &str,
-    minicore: &str,
-) -> Result<Arc<Layout>, LayoutError> {
+fn eval_expr(#[rust_analyzer::rust_fixture] ra_fixture: &str, minicore: &str) -> Result<Arc<Layout>, LayoutError> {
     let _tracing = setup_tracing();
     let target_data = current_machine_target_data();
     let target_data_layout = target_data.data_layout;
     let ra_fixture = format!(
         "//- target_data_layout: {target_data_layout}\n{minicore}//- /main.rs crate:test\nfn main(){{let goal = {{{ra_fixture}}};}}",
     );
-
     let (db, file_id) = TestDB::with_single_file(&ra_fixture);
     crate::attach_db(&db, || {
         let module_id = db.module_for_file(file_id.file_id(&db));
 }
 
 #[track_caller]
-fn check_size_and_align(
-    #[rust_analyzer::rust_fixture] ra_fixture: &str,
-    minicore: &str,
-    size: u64,
-    align: u64,
-) {
+fn check_size_and_align(#[rust_analyzer::rust_fixture] ra_fixture: &str, minicore: &str, size: u64, align: u64) {
     let l = eval_goal(ra_fixture, minicore).unwrap();
     assert_eq!(l.size.bytes(), size, "size mismatch");
     assert_eq!(l.align.bytes(), align, "align mismatch");
 }
 
 #[track_caller]
-fn check_size_and_align_expr(
-    #[rust_analyzer::rust_fixture] ra_fixture: &str,
-    minicore: &str,
-    size: u64,
-    align: u64,
-) {
+fn check_size_and_align_expr(#[rust_analyzer::rust_fixture] ra_fixture: &str, minicore: &str, size: u64, align: u64) {
     let l = eval_expr(ra_fixture, minicore).unwrap();
     assert_eq!(l.size.bytes(), size, "size mismatch");
     assert_eq!(l.align.bytes(), align, "align mismatch");
         struct BoxLike<T: ?Sized>(*mut T);
         struct Goal(BoxLike<Goal>);
     }
-    check_fail(
-        r#"struct Goal(Goal);"#,
-        LayoutError::RecursiveTypeWithoutIndirection,
-    );
+    check_fail(r#"struct Goal(Goal);"#, LayoutError::RecursiveTypeWithoutIndirection);
     check_fail(
         r#"
         struct Foo<T>(Foo<T>);
         #[repr(Rust, packed(4))]
         struct Goal(i32);
     }
-
     check_size_and_align("#[repr(Rust, packed(5))] struct Goal(i32);", "", 4, 1);
 }
 
 }
 
 #[test]
-// FIXME
 #[should_panic]
 fn const_eval_complex() {
     size_and_align! {