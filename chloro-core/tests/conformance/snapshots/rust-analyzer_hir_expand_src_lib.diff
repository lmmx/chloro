COMPARISON DIFF
============================================================

Original size: 40650 bytes
Chloro size:   39285 bytes
Rustfmt size:  40650 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! `hir_expand` deals with macro expansion.
 //!
 //! Specifically, it implements a concept of `MacroFile` -- a file whose syntax
 //! tree originates not from the text of some `FileId`, but from some macro
 //! expansion.
-#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
-
-pub use intern;
-
-pub mod attrs;
-pub mod builtin;
-pub mod change;
-pub mod db;
-pub mod declarative;
-pub mod eager;
-pub mod files;
-pub mod hygiene;
-pub mod inert_attr_macro;
-pub mod mod_path;
-pub mod name;
-pub mod proc_macro;
-pub mod span_map;
-
-mod cfg_process;
-mod fixup;
-mod prettify_macro_expansion_;
-
-use attrs::collect_attrs;
-use rustc_hash::FxHashMap;
-use salsa::plumbing::{AsId, FromId};
-use stdx::TupleExt;
-use triomphe::Arc;
 
 use core::fmt;
 use std::hash::Hash;
 
+use attrs::collect_attrs;
 use base_db::Crate;
+pub use base_db::EditionedFileId;
 use either::Either;
+pub use intern;
+pub use mbe::{DeclarativeMacro, ValueResult};
+use rustc_hash::FxHashMap;
+use salsa::plumbing::{AsId, FromId};
 use span::{Edition, ErasedFileAstId, FileAstId, Span, SpanAnchor, SyntaxContext};
+use stdx::TupleExt;
 use syntax::{
     SyntaxNode, SyntaxToken, TextRange, TextSize,
     ast::{self, AstNode},
 };
+use triomphe::Arc;
 
 use crate::{
     attrs::AttrId,
     proc_macro::{CustomProcMacroExpander, ProcMacroKind},
     span_map::{ExpansionSpanMap, SpanMap},
 };
-
 pub use crate::{
     cfg_process::check_cfg_attr_value,
     files::{AstId, ErasedAstId, FileRange, InFile, InMacroFile, InRealFile},
     prettify_macro_expansion_::prettify_macro_expansion,
 };
 
-pub use base_db::EditionedFileId;
-pub use mbe::{DeclarativeMacro, ValueResult};
+#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
+pub mod attrs;
+
+pub mod builtin;
+
+pub mod change;
+
+pub mod db;
+
+pub mod declarative;
+
+pub mod eager;
+
+pub mod files;
+
+pub mod hygiene;
+
+pub mod inert_attr_macro;
+
+pub mod mod_path;
+
+pub mod name;
+
+pub mod proc_macro;
+
+pub mod span_map;
+
+mod cfg_process;
+
+mod fixup;
+
+mod prettify_macro_expansion_;
 
 pub mod tt {
     pub use span::Span;
     pub use tt::{DelimiterKind, IdentIsRaw, LitKind, Spacing, token_to_literal};
-
     pub type Delimiter = ::tt::Delimiter<Span>;
     pub type DelimSpan = ::tt::DelimSpan<Span>;
     pub type Subtree = ::tt::Subtree<Span>;
 }
 
 // ideally these would be defined in base-db, but the orphan rule doesn't let us
-pub trait Intern {
-    type Database: ?Sized;
-    type ID;
-    fn intern(self, db: &Self::Database) -> Self::ID;
-}
-
-pub trait Lookup {
-    type Database: ?Sized;
-    type Data;
-    fn lookup(&self, db: &Self::Database) -> Self::Data;
-}
-
-impl_intern_lookup!(
-    ExpandDatabase,
-    MacroCallId,
-    MacroCallLoc,
-    intern_macro_call,
-    lookup_intern_macro_call
-);
+type Database;
+type ID;
+fn intern(self, db: &Self::Database) -> Self::ID;
 
+type Database;
+type Data;
+fn lookup(&self, db: &Self::Database) -> Self::Data;
 pub type ExpandResult<T> = ValueResult<T, ExpandError>;
 
 #[derive(Debug, PartialEq, Eq, Clone, Hash)]
     pub fn new(span: Span, kind: ExpandErrorKind) -> Self {
         ExpandError { inner: Arc::new((kind, span)) }
     }
+
     pub fn other(span: Span, msg: impl Into<Box<str>>) -> Self {
         ExpandError { inner: Arc::new((ExpandErrorKind::Other(msg.into()), span)) }
     }
+
     pub fn kind(&self) -> &ExpandErrorKind {
         &self.inner.0
     }
+
     pub fn span(&self) -> Span {
         self.inner.1
     }
 }
 
 impl RenderedExpandError {
-    const GENERAL_KIND: &str = "macro-error";
-    const DISABLED: &str = "proc-macro-disabled";
-    const ATTR_EXP_DISABLED: &str = "attribute-expansion-disabled";
+
+
 }
 
 impl ExpandErrorKind {
         ExpandError { inner: Arc::new((ExpandErrorKind::Mbe(mbe.inner.1.clone()), mbe.inner.0)) }
     }
 }
+
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub struct MacroCallLoc {
     pub def: MacroDefId,
         expand_to: ExpandTo,
         /// Some if this is a macro call for an eager macro. Note that this is `None`
         /// for the eager input macro file.
-        // FIXME: This is being interned, subtrees can vary quickly differing just slightly causing
-        // leakage problems here
         eager: Option<Arc<EagerCallInfo>>,
     },
     Derive {
     },
     Attr {
         ast_id: AstId<ast::Item>,
-        // FIXME: This shouldn't be here, we can derive this from `invoc_attr_index`
-        // but we need to fix the `cfg_attr` handling first.
         attr_args: Option<Arc<tt::TopSubtree>>,
         /// Syntactical index of the invoking `#[attribute]`.
         ///
             HirFileId::MacroFile(m) => db.lookup_intern_macro_call(m).def.edition,
         }
     }
+
     pub fn original_file(self, db: &dyn ExpandDatabase) -> EditionedFileId {
         let mut file_id = self;
         loop {
         Some(db.lookup_intern_macro_call(self.macro_file()?).to_node(db))
     }
 
-    pub fn as_builtin_derive_attr_node(
-        &self,
-        db: &dyn ExpandDatabase,
-    ) -> Option<InFile<ast::Attr>> {
+    pub fn as_builtin_derive_attr_node(&self, db: &dyn ExpandDatabase) -> Option<InFile<ast::Attr>> {
         let macro_file = self.macro_file()?;
         let loc = db.lookup_intern_macro_call(macro_file);
         let attr = match loc.def.kind {
     pub fn call_node(self, db: &dyn ExpandDatabase) -> InFile<SyntaxNode> {
         db.lookup_intern_macro_call(self).to_node(db)
     }
+
     pub fn expansion_level(self, db: &dyn ExpandDatabase) -> u32 {
         let mut level = 0;
         let mut macro_file = self;
             };
         }
     }
+
     pub fn parent(self, db: &dyn ExpandDatabase) -> HirFileId {
         db.lookup_intern_macro_call(self).kind.file_id()
     }
 }
 
 impl MacroDefId {
-    pub fn make_call(
-        self,
-        db: &dyn ExpandDatabase,
-        krate: Crate,
-        kind: MacroCallKind,
-        ctxt: SyntaxContext,
-    ) -> MacroCallId {
+    pub fn make_call(self, db: &dyn ExpandDatabase, krate: Crate, kind: MacroCallKind, ctxt: SyntaxContext) -> MacroCallId {
         db.intern_macro_call(MacroCallLoc { def: self, krate, kind, ctxt })
     }
 
         }
     }
 
-    pub fn include_file_id(
-        &self,
-        db: &dyn ExpandDatabase,
-        macro_call_id: MacroCallId,
-    ) -> Option<EditionedFileId> {
+    pub fn include_file_id(&self, db: &dyn ExpandDatabase, macro_call_id: MacroCallId) -> Option<EditionedFileId> {
         if self.def.is_include()
             && let MacroCallKind::FnLike { eager: Some(eager), .. } = &self.kind
             && let Ok(it) = include_input_to_file_id(db, macro_call_id, &eager.arg)
         {
             return Some(it);
         }
-
         None
     }
 }
                 HirFileId::FileId(file_id) => break file_id,
             }
         };
-
         let range = match kind {
             MacroCallKind::FnLike { ast_id, .. } => ast_id.to_ptr(db).text_range(),
             MacroCallKind::Derive { ast_id, .. } => ast_id.to_ptr(db).text_range(),
             MacroCallKind::Attr { ast_id, .. } => ast_id.to_ptr(db).text_range(),
         };
-
         FileRange { range, file_id }
     }
 
                 HirFileId::FileId(file_id) => break file_id,
             }
         };
-
         let range = match kind {
             MacroCallKind::FnLike { ast_id, .. } => {
                 let node = ast_id.to_node(db);
                     .text_range()
             }
         };
-
         FileRange { range, file_id }
     }
 
 }
 
 /// ExpansionInfo mainly describes how to map text range between src and expanded macro
-// FIXME: can be expensive to create, we should check the use sites and maybe replace them with
-// simpler function calls if the map is only used once
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct ExpansionInfo {
     expanded: InMacroFile<SyntaxNode>,
     /// Maps the passed in file range down into a macro expansion if it is the input to a macro call.
     ///
     /// Note this does a linear search through the entire backing vector of the spanmap.
-    // FIXME: Consider adding a reverse map to ExpansionInfo to get rid of the linear search which
-    // potentially results in quadratic look ups (notably this might improve semantic highlighting perf)
-    pub fn map_range_down_exact(
-        &self,
-        span: Span,
-    ) -> Option<InMacroFile<impl Iterator<Item = (SyntaxToken, SyntaxContext)> + '_>> {
+    pub fn map_range_down_exact(&self, span: Span) -> Option<InMacroFile<impl Iterator<Item = (SyntaxToken, SyntaxContext)> + '_>> {
         let tokens = self.exp_map.ranges_with_span_exact(span).flat_map(move |(range, ctx)| {
             self.expanded.value.covering_element(range).into_token().zip(Some(ctx))
         });
-
         Some(InMacroFile::new(self.expanded.file_id, tokens))
     }
 
     /// Unlike [`map_range_down_exact`], this will consider spans that contain the given span.
     ///
     /// Note this does a linear search through the entire backing vector of the spanmap.
-    pub fn map_range_down(
-        &self,
-        span: Span,
-    ) -> Option<InMacroFile<impl Iterator<Item = (SyntaxToken, SyntaxContext)> + '_>> {
+    pub fn map_range_down(&self, span: Span) -> Option<InMacroFile<impl Iterator<Item = (SyntaxToken, SyntaxContext)> + '_>> {
         let tokens = self.exp_map.ranges_with_span(span).flat_map(move |(range, ctx)| {
             self.expanded.value.covering_element(range).into_token().zip(Some(ctx))
         });
-
         Some(InMacroFile::new(self.expanded.file_id, tokens))
     }
 
     /// Looks up the span at the given offset.
-    pub fn span_for_offset(
-        &self,
-        db: &dyn ExpandDatabase,
-        offset: TextSize,
-    ) -> (FileRange, SyntaxContext) {
+    pub fn span_for_offset(&self, db: &dyn ExpandDatabase, offset: TextSize) -> (FileRange, SyntaxContext) {
         debug_assert!(self.expanded.value.text_range().contains(offset));
         span_for_offset(db, &self.exp_map, offset)
     }
 
     /// Maps up the text range out of the expansion hierarchy back into the original file its from.
-    pub fn map_node_range_up(
-        &self,
-        db: &dyn ExpandDatabase,
-        range: TextRange,
-    ) -> Option<(FileRange, SyntaxContext)> {
+    pub fn map_node_range_up(&self, db: &dyn ExpandDatabase, range: TextRange) -> Option<(FileRange, SyntaxContext)> {
         debug_assert!(self.expanded.value.text_range().contains_range(range));
         map_node_range_up(db, &self.exp_map, range)
     }
     ///
     /// Note that this may return multiple ranges as we lose the precise association between input to output
     /// and as such we may consider inputs that are unrelated.
-    pub fn map_range_up_once(
-        &self,
-        db: &dyn ExpandDatabase,
-        token: TextRange,
-    ) -> InFile<smallvec::SmallVec<[TextRange; 1]>> {
+    pub fn map_range_up_once(&self, db: &dyn ExpandDatabase, token: TextRange) -> InFile<smallvec::SmallVec<[TextRange; 1]>> {
         debug_assert!(self.expanded.value.text_range().contains_range(token));
         let span = self.exp_map.span_at(token.start());
         match &self.arg_map {
     pub fn new(db: &dyn ExpandDatabase, macro_file: MacroCallId) -> ExpansionInfo {
         let _p = tracing::info_span!("ExpansionInfo::new").entered();
         let loc = db.lookup_intern_macro_call(macro_file);
-
         let arg_tt = loc.kind.arg(db);
         let arg_map = db.span_map(arg_tt.file_id);
-
         let (parse, exp_map) = db.parse_macro_expansion(macro_file).value;
         let expanded = InMacroFile { file_id: macro_file, value: parse.syntax_node() };
-
         ExpansionInfo { expanded, loc, arg: arg_tt, exp_map, arg_map }
     }
 }
 /// Maps up the text range out of the expansion hierarchy back into the original file its from only
 /// considering the root spans contained.
 /// Unlike [`map_node_range_up`], this will not return `None` if any anchors or syntax contexts differ.
-pub fn map_node_range_up_rooted(
-    db: &dyn ExpandDatabase,
-    exp_map: &ExpansionSpanMap,
-    range: TextRange,
-) -> Option<FileRange> {
+pub fn map_node_range_up_rooted(db: &dyn ExpandDatabase, exp_map: &ExpansionSpanMap, range: TextRange) -> Option<FileRange> {
     let mut spans = exp_map.spans_for_range(range).filter(|span| span.ctx.is_root());
     let Span { range, anchor, ctx: _ } = spans.next()?;
     let mut start = range.start();
     let mut end = range.end();
-
     for span in spans {
         if span.anchor != anchor {
             return None;
 /// Maps up the text range out of the expansion hierarchy back into the original file its from.
 ///
 /// this will return `None` if any anchors or syntax contexts differ.
-pub fn map_node_range_up(
-    db: &dyn ExpandDatabase,
-    exp_map: &ExpansionSpanMap,
-    range: TextRange,
-) -> Option<(FileRange, SyntaxContext)> {
+pub fn map_node_range_up(db: &dyn ExpandDatabase, exp_map: &ExpansionSpanMap, range: TextRange) -> Option<(FileRange, SyntaxContext)> {
     let mut spans = exp_map.spans_for_range(range);
     let Span { range, anchor, ctx } = spans.next()?;
     let mut start = range.start();
     let mut end = range.end();
-
     for span in spans {
         if span.anchor != anchor || span.ctx != ctx {
             return None;
 
 /// Maps up the text range out of the expansion hierarchy back into the original file its from.
 /// This version will aggregate the ranges of all spans with the same anchor and syntax context.
-pub fn map_node_range_up_aggregated(
-    db: &dyn ExpandDatabase,
-    exp_map: &ExpansionSpanMap,
-    range: TextRange,
-) -> FxHashMap<(SpanAnchor, SyntaxContext), TextRange> {
+pub fn map_node_range_up_aggregated(db: &dyn ExpandDatabase, exp_map: &ExpansionSpanMap, range: TextRange) -> FxHashMap<(SpanAnchor, SyntaxContext), TextRange> {
     let mut map = FxHashMap::default();
     for span in exp_map.spans_for_range(range) {
         let range = map.entry((span.anchor, span.ctx)).or_insert_with(|| span.range);
 }
 
 /// Looks up the span at the given offset.
-pub fn span_for_offset(
-    db: &dyn ExpandDatabase,
-    exp_map: &ExpansionSpanMap,
-    offset: TextSize,
-) -> (FileRange, SyntaxContext) {
+pub fn span_for_offset(db: &dyn ExpandDatabase, exp_map: &ExpansionSpanMap, offset: TextSize) -> (FileRange, SyntaxContext) {
     let span = exp_map.span_at(offset);
     let file_id = EditionedFileId::from_span(db, span.anchor.file_id);
     let anchor_offset =
 impl ExpandTo {
     pub fn from_call_site(call: &ast::MacroCall) -> ExpandTo {
         use syntax::SyntaxKind::*;
-
         let syn = call.syntax();
-
         let parent = match syn.parent() {
             Some(it) => it,
             None => return ExpandTo::Statements,
         };
-
         // FIXME: macros in statement position are treated as expression statements, they should
         // probably be their own statement kind. The *grand*parent indicates what's valid.
         if parent.kind() == MACRO_EXPR
         {
             return ExpandTo::Statements;
         }
-
         match parent.kind() {
             MACRO_ITEMS | SOURCE_FILE | ITEM_LIST => ExpandTo::Items,
             MACRO_STMTS | EXPR_STMT | STMT_LIST => ExpandTo::Statements,
         }
     }
 }
-
-intern::impl_internable!(ModPath, attrs::AttrInput);
-
 #[salsa_macros::interned(no_lifetime, debug, revisions = usize::MAX)]
 #[doc(alias = "MacroFileId")]
 pub struct MacroCallId {
         *self == HirFileId::from(other)
     }
 }
+
 impl PartialEq<HirFileId> for EditionedFileId {
     fn eq(&self, &other: &HirFileId) -> bool {
         other == HirFileId::from(*self)