COMPARISON DIFF
============================================================

Original size: 99713 bytes
Chloro size:   97978 bytes
Rustfmt size:  99713 bytes

✗ Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     utils::{self, detect_variant_from_bytes},
 };
 
-pub trait HirWrite: fmt::Write {
-    fn start_location_link(&mut self, _location: ModuleDefId) {}
-    fn end_location_link(&mut self) {}
+fn start_location_link(&mut self, _location: ModuleDefId) {
+}
+fn end_location_link(&mut self) {
 }
 
-// String will ignore link metadata
-impl HirWrite for String {}
+impl HirWrite for String {
+}
 
-// `core::Formatter` will ignore metadata
-impl HirWrite for fmt::Formatter<'_> {}
+impl HirWrite for fmt::Formatter<'_> {
+}
 
 pub struct HirFormatter<'a, 'db> {
     /// The database handle
     bounds_formatting_ctx: BoundsFormattingCtx<'db>,
 }
 
-// FIXME: To consider, ref and dyn trait lifetimes can be omitted if they are `'_`, path args should
-// not be when in signatures
-// So this enum does not encode this well enough
-// Also 'static can be omitted for ref and dyn trait lifetimes in static/const item types
-// FIXME: Also named lifetimes may be rendered in places where their name is not in scope?
 #[derive(Copy, Clone)]
 pub enum DisplayLifetime {
     Always,
         ///     T::FooAssoc: Baz<<T::FooAssoc as Bar>::BarAssoc> + Bar
         /// ```
         /// So, record the projection types met while formatting bounds and
-        //. prevent recursing into their bounds to avoid infinite loops.
         projection_tys_met: FxHashSet<AliasTy<'db>>,
     },
     #[default]
         self.fmt.end_location_link();
     }
 
-    fn format_bounds_with<T, F: FnOnce(&mut Self) -> T>(
-        &mut self,
-        target: AliasTy<'db>,
-        format_bounds: F,
-    ) -> T {
+    fn format_bounds_with<T, F: FnOnce(&mut Self) -> T>(&mut self, target: AliasTy<'db>, format_bounds: F) -> T {
         match self.bounds_formatting_ctx {
             BoundsFormattingCtx::Entered { ref mut projection_tys_met } => {
                 projection_tys_met.insert(target);
     }
 }
 
-pub trait HirDisplay<'db> {
-    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError>;
-
-    /// Returns a `Display`able type that is human-readable.
-    fn into_displayable<'a>(
-        &'a self,
-        db: &'db dyn HirDatabase,
-        max_size: Option<usize>,
-        limited_size: Option<usize>,
-        omit_verbose_types: bool,
-        display_target: DisplayTarget,
-        display_kind: DisplayKind,
-        closure_style: ClosureStyle,
-        show_container_bounds: bool,
-    ) -> HirDisplayWrapper<'a, 'db, Self>
-    where
-        Self: Sized,
-    {
-        assert!(
+fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError>;
+/// Returns a `Display`able type that is human-readable.
+fn into_displayable<'a>(&'a self, db: &'db dyn HirDatabase, max_size: Option<usize>, limited_size: Option<usize>, omit_verbose_types: bool, display_target: DisplayTarget, display_kind: DisplayKind, closure_style: ClosureStyle, show_container_bounds: bool) -> HirDisplayWrapper<'a, 'db, Self>
+where
+        Self: Sized, {
+    assert!(
             !matches!(display_kind, DisplayKind::SourceCode { .. }),
             "HirDisplayWrapper cannot fail with DisplaySourceCodeError, use HirDisplay::hir_fmt directly instead"
         );
-        HirDisplayWrapper {
+    HirDisplayWrapper {
             db,
             t: self,
             max_size,
             show_container_bounds,
             display_lifetimes: DisplayLifetime::OnlyNamedOrStatic,
         }
-    }
-
-    /// Returns a `Display`able type that is human-readable.
-    /// Use this for showing types to the user (e.g. diagnostics)
-    fn display<'a>(
-        &'a self,
-        db: &'db dyn HirDatabase,
-        display_target: DisplayTarget,
-    ) -> HirDisplayWrapper<'a, 'db, Self>
-    where
-        Self: Sized,
-    {
-        HirDisplayWrapper {
+}
+/// Returns a `Display`able type that is human-readable.
+/// Use this for showing types to the user (e.g. diagnostics)
+fn display<'a>(&'a self, db: &'db dyn HirDatabase, display_target: DisplayTarget) -> HirDisplayWrapper<'a, 'db, Self>
+where
+        Self: Sized, {
+    HirDisplayWrapper {
             db,
             t: self,
             max_size: None,
             show_container_bounds: false,
             display_lifetimes: DisplayLifetime::OnlyNamedOrStatic,
         }
-    }
-
-    /// Returns a `Display`able type that is human-readable and tries to be succinct.
-    /// Use this for showing types to the user where space is constrained (e.g. doc popups)
-    fn display_truncated<'a>(
-        &'a self,
-        db: &'db dyn HirDatabase,
-        max_size: Option<usize>,
-        display_target: DisplayTarget,
-    ) -> HirDisplayWrapper<'a, 'db, Self>
-    where
-        Self: Sized,
-    {
-        HirDisplayWrapper {
+}
+/// Returns a `Display`able type that is human-readable and tries to be succinct.
+/// Use this for showing types to the user where space is constrained (e.g. doc popups)
+fn display_truncated<'a>(&'a self, db: &'db dyn HirDatabase, max_size: Option<usize>, display_target: DisplayTarget) -> HirDisplayWrapper<'a, 'db, Self>
+where
+        Self: Sized, {
+    HirDisplayWrapper {
             db,
             t: self,
             max_size,
             show_container_bounds: false,
             display_lifetimes: DisplayLifetime::OnlyNamedOrStatic,
         }
-    }
-
-    /// Returns a `Display`able type that is human-readable and tries to limit the number of items inside.
-    /// Use this for showing definitions which may contain too many items, like `trait`, `struct`, `enum`
-    fn display_limited<'a>(
-        &'a self,
-        db: &'db dyn HirDatabase,
-        limited_size: Option<usize>,
-        display_target: DisplayTarget,
-    ) -> HirDisplayWrapper<'a, 'db, Self>
-    where
-        Self: Sized,
-    {
-        HirDisplayWrapper {
+}
+/// Returns a `Display`able type that is human-readable and tries to limit the number of items inside.
+/// Use this for showing definitions which may contain too many items, like `trait`, `struct`, `enum`
+fn display_limited<'a>(&'a self, db: &'db dyn HirDatabase, limited_size: Option<usize>, display_target: DisplayTarget) -> HirDisplayWrapper<'a, 'db, Self>
+where
+        Self: Sized, {
+    HirDisplayWrapper {
             db,
             t: self,
             max_size: None,
             show_container_bounds: false,
             display_lifetimes: DisplayLifetime::OnlyNamedOrStatic,
         }
-    }
-
-    /// Returns a String representation of `self` that can be inserted into the given module.
-    /// Use this when generating code (e.g. assists)
-    fn display_source_code<'a>(
-        &'a self,
-        db: &'db dyn HirDatabase,
-        module_id: ModuleId,
-        allow_opaque: bool,
-    ) -> Result<String, DisplaySourceCodeError> {
-        let mut result = String::new();
-        let interner =
+}
+/// Returns a String representation of `self` that can be inserted into the given module.
+/// Use this when generating code (e.g. assists)
+fn display_source_code<'a>(&'a self, db: &'db dyn HirDatabase, module_id: ModuleId, allow_opaque: bool) -> Result<String, DisplaySourceCodeError> {
+    let mut result = String::new();
+    let interner =
             DbInterner::new_with(db, Some(module_id.krate()), module_id.containing_block());
-        match self.hir_fmt(&mut HirFormatter {
+    match self.hir_fmt(&mut HirFormatter {
             db,
             interner,
             fmt: &mut result,
             Err(HirDisplayError::FmtError) => panic!("Writing to String can't fail!"),
             Err(HirDisplayError::DisplaySourceCodeError(e)) => return Err(e),
         };
-        Ok(result)
-    }
-
-    /// Returns a String representation of `self` for test purposes
-    fn display_test<'a>(
-        &'a self,
-        db: &'db dyn HirDatabase,
-        display_target: DisplayTarget,
-    ) -> HirDisplayWrapper<'a, 'db, Self>
-    where
-        Self: Sized,
-    {
-        HirDisplayWrapper {
+    Ok(result)
+}
+/// Returns a String representation of `self` for test purposes
+fn display_test<'a>(&'a self, db: &'db dyn HirDatabase, display_target: DisplayTarget) -> HirDisplayWrapper<'a, 'db, Self>
+where
+        Self: Sized, {
+    HirDisplayWrapper {
             db,
             t: self,
             max_size: None,
             show_container_bounds: false,
             display_lifetimes: DisplayLifetime::Always,
         }
-    }
-
-    /// Returns a String representation of `self` that shows the constraint from
-    /// the container for functions
-    fn display_with_container_bounds<'a>(
-        &'a self,
-        db: &'db dyn HirDatabase,
-        show_container_bounds: bool,
-        display_target: DisplayTarget,
-    ) -> HirDisplayWrapper<'a, 'db, Self>
-    where
-        Self: Sized,
-    {
-        HirDisplayWrapper {
+}
+/// Returns a String representation of `self` that shows the constraint from
+/// the container for functions
+fn display_with_container_bounds<'a>(&'a self, db: &'db dyn HirDatabase, show_container_bounds: bool, display_target: DisplayTarget) -> HirDisplayWrapper<'a, 'db, Self>
+where
+        Self: Sized, {
+    HirDisplayWrapper {
             db,
             t: self,
             max_size: None,
             show_container_bounds,
             display_lifetimes: DisplayLifetime::OnlyNamedOrStatic,
         }
-    }
 }
 
 impl<'db> HirFormatter<'_, 'db> {
         self.display_target.edition
     }
 
-    pub fn write_joined<T: HirDisplay<'db>>(
-        &mut self,
-        iter: impl IntoIterator<Item = T>,
-        sep: &str,
-    ) -> Result<(), HirDisplayError> {
+    pub fn write_joined<T: HirDisplay<'db>>(&mut self, iter: impl IntoIterator<Item = T>, sep: &str) -> Result<(), HirDisplayError> {
         let mut first = true;
         for e in iter {
             if !first {
         self.buf.clear();
         fmt::write(&mut self.buf, args)?;
         self.curr_size += self.buf.len();
-
         // Then we write to the internal formatter from the buffer
         self.fmt.write_str(&self.buf).map_err(HirDisplayError::from)
     }
     Diagnostics,
     /// Display types for inserting them in source files.
     /// The generated code should compile, so paths need to be qualified.
-    SourceCode { target_module_id: ModuleId, allow_opaque: bool },
+    SourceCode {
+        target_module_id: ModuleId,
+        allow_opaque: bool,
+    },
     /// Only for test purpose to keep real types
     Test,
 }
     /// `FmtError` is required to be compatible with std::fmt::Display
     FmtError,
 }
+
 impl From<fmt::Error> for HirDisplayError {
     fn from(_: fmt::Error) -> Self {
         Self::FmtError
 
 impl<'db, T> fmt::Display for HirDisplayWrapper<'_, 'db, T>
 where
-    T: HirDisplay<'db>,
-{
+    T: HirDisplay<'db>, {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         match self.write_to(f) {
             Ok(()) => Ok(()),
     }
 }
 
-const TYPE_HINT_TRUNCATION: &str = "…";
 
 impl<'db, T: HirDisplay<'db>> HirDisplay<'db> for &T {
     fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError> {
     }
 }
 
-fn write_projection<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    alias: &AliasTy<'db>,
-) -> Result<(), HirDisplayError> {
+fn write_projection<'db>(f: &mut HirFormatter<'_, 'db>, alias: &AliasTy<'db>) -> Result<(), HirDisplayError> {
     if f.should_truncate() {
         return write!(f, "{TYPE_HINT_TRUNCATION}");
     }
     let trait_ref = alias.trait_ref(f.interner);
     let self_ty = trait_ref.self_ty();
-
     // if we are projection on a type parameter, check if the projection target has bounds
     // itself, if so, we render them directly as `impl Bound` instead of the less useful
     // `<Param as Trait>::Assoc`
             });
         }
     }
-
     write!(f, "<")?;
     self_ty.hir_fmt(f)?;
     write!(f, " as ")?;
     }
 }
 
-fn render_const_scalar<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    b: &[u8],
-    memory_map: &MemoryMap<'db>,
-    ty: Ty<'db>,
-) -> Result<(), HirDisplayError> {
+fn render_const_scalar<'db>(f: &mut HirFormatter<'_, 'db>, b: &[u8], memory_map: &MemoryMap<'db>, ty: Ty<'db>) -> Result<(), HirDisplayError> {
     let trait_env = TraitEnvironment::empty(f.krate());
     let infcx = f.interner.infer_ctxt().build(TypingMode::PostAnalysis);
     let ty = infcx.at(&ObligationCause::new(), trait_env.env).deeply_normalize(ty).unwrap_or(ty);
     render_const_scalar_inner(f, b, memory_map, ty, trait_env)
 }
 
-fn render_const_scalar_inner<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    b: &[u8],
-    memory_map: &MemoryMap<'db>,
-    ty: Ty<'db>,
-    trait_env: Arc<TraitEnvironment<'db>>,
-) -> Result<(), HirDisplayError> {
+fn render_const_scalar_inner<'db>(f: &mut HirFormatter<'_, 'db>, b: &[u8], memory_map: &MemoryMap<'db>, ty: Ty<'db>, trait_env: Arc<TraitEnvironment<'db>>) -> Result<(), HirDisplayError> {
     use TyKind;
     match ty.kind() {
         TyKind::Bool => write!(f, "{}", b[0] != 0),
     }
 }
 
-fn render_variant_after_name<'db>(
-    data: &VariantFields,
-    f: &mut HirFormatter<'_, 'db>,
-    field_types: &ArenaMap<LocalFieldId, EarlyBinder<'db, Ty<'db>>>,
-    trait_env: Arc<TraitEnvironment<'db>>,
-    layout: &Layout,
-    args: GenericArgs<'db>,
-    b: &[u8],
-    memory_map: &MemoryMap<'db>,
-) -> Result<(), HirDisplayError> {
+fn render_variant_after_name<'db>(data: &VariantFields, f: &mut HirFormatter<'_, 'db>, field_types: &ArenaMap<LocalFieldId, EarlyBinder<'db, Ty<'db>>>, trait_env: Arc<TraitEnvironment<'db>>, layout: &Layout, args: GenericArgs<'db>, b: &[u8], memory_map: &MemoryMap<'db>) -> Result<(), HirDisplayError> {
     match data.shape {
         FieldsShape::Record | FieldsShape::Tuple => {
             let render_field = |f: &mut HirFormatter<'_, 'db>, id: LocalFieldId| {
 }
 
 impl<'db> HirDisplay<'db> for Ty<'db> {
-    fn hir_fmt(
-        &self,
-        f @ &mut HirFormatter { db, .. }: &mut HirFormatter<'_, 'db>,
-    ) -> Result<(), HirDisplayError> {
+    fn hir_fmt(&self, f @ &mut HirFormatter { db, .. }: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError> {
         let interner = f.interner;
         if f.should_truncate() {
             return write!(f, "{TYPE_HINT_TRUNCATION}");
         }
-
         use TyKind;
         match self.kind() {
             TyKind::Never => write!(f, "!")?,
     }
 }
 
-fn hir_fmt_generics<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    parameters: &[GenericArg<'db>],
-    generic_def: Option<hir_def::GenericDefId>,
-    self_: Option<Ty<'db>>,
-) -> Result<(), HirDisplayError> {
+fn hir_fmt_generics<'db>(f: &mut HirFormatter<'_, 'db>, parameters: &[GenericArg<'db>], generic_def: Option<hir_def::GenericDefId>, self_: Option<Ty<'db>>) -> Result<(), HirDisplayError> {
     if parameters.is_empty() {
         return Ok(());
     }
-
     let parameters_to_write = generic_args_sans_defaults(f, generic_def, parameters);
-
     if !parameters_to_write.is_empty() {
         write!(f, "<")?;
         hir_fmt_generic_arguments(f, parameters_to_write, self_)?;
         write!(f, ">")?;
     }
-
     Ok(())
 }
 
-fn generic_args_sans_defaults<'ga, 'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    generic_def: Option<hir_def::GenericDefId>,
-    parameters: &'ga [GenericArg<'db>],
-) -> &'ga [GenericArg<'db>] {
+fn generic_args_sans_defaults<'ga, 'db>(f: &mut HirFormatter<'_, 'db>, generic_def: Option<hir_def::GenericDefId>, parameters: &'ga [GenericArg<'db>]) -> &'ga [GenericArg<'db>] {
     if f.display_kind.is_source_code() || f.omit_verbose_types() {
         match generic_def.map(|generic_def_id| f.db.generic_defaults(generic_def_id)) {
             None => parameters,
     }
 }
 
-fn hir_fmt_generic_args<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    parameters: &[GenericArg<'db>],
-    generic_def: Option<hir_def::GenericDefId>,
-    self_: Option<Ty<'db>>,
-) -> Result<(), HirDisplayError> {
+fn hir_fmt_generic_args<'db>(f: &mut HirFormatter<'_, 'db>, parameters: &[GenericArg<'db>], generic_def: Option<hir_def::GenericDefId>, self_: Option<Ty<'db>>) -> Result<(), HirDisplayError> {
     if parameters.is_empty() {
         return Ok(());
     }
-
     let parameters_to_write = generic_args_sans_defaults(f, generic_def, parameters);
-
     if !parameters_to_write.is_empty() {
         write!(f, "<")?;
         hir_fmt_generic_arguments(f, parameters_to_write, self_)?;
         write!(f, ">")?;
     }
-
     Ok(())
 }
 
-fn hir_fmt_generic_arguments<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    parameters: &[GenericArg<'db>],
-    self_: Option<Ty<'db>>,
-) -> Result<(), HirDisplayError> {
+fn hir_fmt_generic_arguments<'db>(f: &mut HirFormatter<'_, 'db>, parameters: &[GenericArg<'db>], self_: Option<Ty<'db>>) -> Result<(), HirDisplayError> {
     let mut first = true;
     let lifetime_offset = parameters.iter().position(|arg| arg.region().is_some());
-
     let (ty_or_const, lifetimes) = match lifetime_offset {
         Some(offset) => parameters.split_at(offset),
         None => (parameters, &[][..]),
     Ok(())
 }
 
-fn hir_fmt_tys<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    tys: &[Ty<'db>],
-    self_: Option<Ty<'db>>,
-) -> Result<(), HirDisplayError> {
+fn hir_fmt_tys<'db>(f: &mut HirFormatter<'_, 'db>, tys: &[Ty<'db>], self_: Option<Ty<'db>>) -> Result<(), HirDisplayError> {
     let mut first = true;
-
     for ty in tys {
         if !mem::take(&mut first) {
             write!(f, ", ")?;
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum SizedByDefault {
     NotSized,
-    Sized { anchor: Crate },
+    Sized {
+        anchor: Crate,
+    },
 }
 
 impl SizedByDefault {
     }
 }
 
-pub fn write_bounds_like_dyn_trait_with_prefix<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    prefix: &str,
-    this: Either<Ty<'db>, Region<'db>>,
-    predicates: &[Clause<'db>],
-    default_sized: SizedByDefault,
-) -> Result<(), HirDisplayError> {
+pub fn write_bounds_like_dyn_trait_with_prefix<'db>(f: &mut HirFormatter<'_, 'db>, prefix: &str, this: Either<Ty<'db>, Region<'db>>, predicates: &[Clause<'db>], default_sized: SizedByDefault) -> Result<(), HirDisplayError> {
     write!(f, "{prefix}")?;
     if !predicates.is_empty()
         || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })
     }
 }
 
-fn write_bounds_like_dyn_trait<'db>(
-    f: &mut HirFormatter<'_, 'db>,
-    this: Either<Ty<'db>, Region<'db>>,
-    predicates: &[Clause<'db>],
-    default_sized: SizedByDefault,
-) -> Result<(), HirDisplayError> {
+fn write_bounds_like_dyn_trait<'db>(f: &mut HirFormatter<'_, 'db>, this: Either<Ty<'db>, Region<'db>>, predicates: &[Clause<'db>], default_sized: SizedByDefault) -> Result<(), HirDisplayError> {
     // Note: This code is written to produce nice results (i.e.
     // corresponding to surface Rust) for types that can occur in
     // actual Rust. It will have weird results if the predicates
     }
 }
 
-pub fn write_visibility<'db>(
-    module_id: ModuleId,
-    vis: Visibility,
-    f: &mut HirFormatter<'_, 'db>,
-) -> Result<(), HirDisplayError> {
+pub fn write_visibility<'db>(module_id: ModuleId, vis: Visibility, f: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError> {
     match vis {
         Visibility::Public => write!(f, "pub "),
         Visibility::PubCrate(_) => write!(f, "pub(crate) "),
     }
 }
 
-pub trait HirDisplayWithExpressionStore<'db> {
-    fn hir_fmt(
-        &self,
-        f: &mut HirFormatter<'_, 'db>,
-        store: &ExpressionStore,
-    ) -> Result<(), HirDisplayError>;
-}
+fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>, store: &ExpressionStore) -> Result<(), HirDisplayError>;
 
-impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db>
-    for &'_ T
-{
-    fn hir_fmt(
-        &self,
-        f: &mut HirFormatter<'_, 'db>,
-        store: &ExpressionStore,
-    ) -> Result<(), HirDisplayError> {
+impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db> for &'_ T {
+    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>, store: &ExpressionStore) -> Result<(), HirDisplayError> {
         T::hir_fmt(&**self, f, store)
     }
 }
 
-pub fn hir_display_with_store<'a, 'db, T: HirDisplayWithExpressionStore<'db> + 'a>(
-    value: T,
-    store: &'a ExpressionStore,
-) -> impl HirDisplay<'db> + 'a {
+pub fn hir_display_with_store<'a, 'db, T: HirDisplayWithExpressionStore<'db> + 'a>(value: T, store: &'a ExpressionStore) -> impl HirDisplay<'db> + 'a {
     ExpressionStoreAdapter(value, store)
 }
 
         T::hir_fmt(&self.0, f, self.1)
     }
 }
+
 impl<'db> HirDisplayWithExpressionStore<'db> for LifetimeRefId {
-    fn hir_fmt(
-        &self,
-        f: &mut HirFormatter<'_, 'db>,
-        store: &ExpressionStore,
-    ) -> Result<(), HirDisplayError> {
+    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>, store: &ExpressionStore) -> Result<(), HirDisplayError> {
         match &store[*self] {
             LifetimeRef::Named(name) => write!(f, "{}", name.display(f.db, f.edition())),
             LifetimeRef::Static => write!(f, "'static"),
 }
 
 impl<'db> HirDisplayWithExpressionStore<'db> for TypeRefId {
-    fn hir_fmt(
-        &self,
-        f: &mut HirFormatter<'_, 'db>,
-        store: &ExpressionStore,
-    ) -> Result<(), HirDisplayError> {
+    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>, store: &ExpressionStore) -> Result<(), HirDisplayError> {
         match &store[*self] {
             TypeRef::Never => write!(f, "!")?,
             TypeRef::TypeParam(param) => {
 }
 
 impl<'db> HirDisplayWithExpressionStore<'db> for ConstRef {
-    fn hir_fmt(
-        &self,
-        f: &mut HirFormatter<'_, 'db>,
-        _store: &ExpressionStore,
-    ) -> Result<(), HirDisplayError> {
+    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>, _store: &ExpressionStore) -> Result<(), HirDisplayError> {
         // FIXME
         write!(f, "{{const}}")?;
-
         Ok(())
     }
 }
 
 impl<'db> HirDisplayWithExpressionStore<'db> for TypeBound {
-    fn hir_fmt(
-        &self,
-        f: &mut HirFormatter<'_, 'db>,
-        store: &ExpressionStore,
-    ) -> Result<(), HirDisplayError> {
+    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>, store: &ExpressionStore) -> Result<(), HirDisplayError> {
         match self {
             &TypeBound::Path(path, modifier) => {
                 match modifier {
 }
 
 impl<'db> HirDisplayWithExpressionStore<'db> for Path {
-    fn hir_fmt(
-        &self,
-        f: &mut HirFormatter<'_, 'db>,
-        store: &ExpressionStore,
-    ) -> Result<(), HirDisplayError> {
+    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>, store: &ExpressionStore) -> Result<(), HirDisplayError> {
         match (self.type_anchor(), self.kind()) {
             (Some(anchor), _) => {
                 write!(f, "<")?;
                 write!(f, "{name}")?
             }
         }
-
         // Convert trait's `Self` bound back to the surface syntax. Note there is no associated
         // trait, so there can only be one path segment that `has_self_type`. The `Self` type
         // itself can contain further qualified path through, which will be handled by recursive
             write!(f, " as ")?;
             // Now format the path of the trait...
         }
-
         for (seg_idx, segment) in self.segments().iter().enumerate() {
             if !matches!(self.kind(), PathKind::Plain) || seg_idx > 0 {
                 write!(f, "::")?;
                 }
             }
         }
-
         Ok(())
     }
 }
 
 impl<'db> HirDisplayWithExpressionStore<'db> for hir_def::expr_store::path::GenericArg {
-    fn hir_fmt(
-        &self,
-        f: &mut HirFormatter<'_, 'db>,
-        store: &ExpressionStore,
-    ) -> Result<(), HirDisplayError> {
+    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>, store: &ExpressionStore) -> Result<(), HirDisplayError> {
         match self {
             hir_def::expr_store::path::GenericArg::Type(ty) => ty.hir_fmt(f, store),
             hir_def::expr_store::path::GenericArg::Const(_c) => {