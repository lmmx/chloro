COMPARISON DIFF
============================================================

Original size: 25126 bytes
Chloro size:   24451 bytes
Rustfmt size:  25126 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     lang_item::LangItem,
     resolver::{HasResolver, ValueNs},
 };
+pub(crate) use hir_def::{
+    LocalFieldId, VariantId,
+    expr_store::Body,
+    hir::{Expr, ExprId, MatchArm, Pat, PatId, Statement},
+};
 use intern::sym;
 use itertools::Itertools;
 use rustc_hash::FxHashSet;
     },
 };
 
-pub(crate) use hir_def::{
-    LocalFieldId, VariantId,
-    expr_store::Body,
-    hir::{Expr, ExprId, MatchArm, Pat, PatId, Statement},
-};
-
 pub enum BodyValidationDiagnostic {
     RecordMissingFields {
         record: Either<ExprId, PatId>,
 }
 
 impl BodyValidationDiagnostic {
-    pub fn collect(
-        db: &dyn HirDatabase,
-        owner: DefWithBodyId,
-        validate_lints: bool,
-    ) -> Vec<BodyValidationDiagnostic> {
+    pub fn collect(db: &dyn HirDatabase, owner: DefWithBodyId, validate_lints: bool) -> Vec<BodyValidationDiagnostic> {
         let _p = tracing::info_span!("BodyValidationDiagnostic::collect").entered();
         let infer = db.infer(owner);
         let body = db.body(owner);
         let mut filter_map_next_checker = None;
         // we'll pass &mut self while iterating over body.exprs, so they need to be disjoint
         let body = Arc::clone(&self.body);
-
         if matches!(self.owner, DefWithBodyId::FunctionId(_)) {
             self.check_for_trailing_return(body.body_expr, &body);
         }
-
         for (id, expr) in body.exprs() {
             if let Some((variant, missed_fields, true)) =
                 record_literal_missing_fields(db, &self.infer, id, expr)
                 _ => {}
             }
         }
-
         for (id, pat) in body.pats() {
             if let Some((variant, missed_fields, true)) =
                 record_pattern_missing_fields(db, &self.infer, id, pat)
         }
     }
 
-    fn validate_call(
-        &mut self,
-        call_id: ExprId,
-        expr: &Expr,
-        filter_map_next_checker: &mut Option<FilterMapNextChecker<'db>>,
-    ) {
+    fn validate_call(&mut self, call_id: ExprId, expr: &Expr, filter_map_next_checker: &mut Option<FilterMapNextChecker<'db>>) {
         if !self.validate_lints {
             return;
         }
         // Check that the number of arguments matches the number of parameters.
-
         if self.infer.expr_type_mismatches().next().is_some() {
             // FIXME: Due to shortcomings in the current type system implementation, only emit
             // this diagnostic if there are no type mismatches in the containing function.
         if scrut_ty.references_non_lt_error() {
             return;
         }
-
         let cx = MatchCheckCtx::new(self.owner.module(self.db()), &self.infcx, self.env.clone());
-
         let pattern_arena = Arena::new();
         let mut m_arms = Vec::with_capacity(arms.len());
         let mut has_lowering_errors = false;
             cov_mark::hit!(validate_match_bailed_out);
             return;
         }
-
         let known_valid_scrutinee = Some(self.is_known_valid_scrutinee(scrutinee_expr));
         let report =
             match cx.compute_match_usefulness(m_arms.as_slice(), scrut_ty, known_valid_scrutinee) {
                 Ok(report) => report,
                 Err(()) => return,
             };
-
         // FIXME Report unreachable arms
         // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200
-
         let witnesses = report.non_exhaustiveness_witnesses;
         if !witnesses.is_empty() {
             self.diagnostics.push(BodyValidationDiagnostic::MissingMatchArms {
         }
     }
 
-    // [rustc's `is_known_valid_scrutinee`](https://github.com/rust-lang/rust/blob/c9bd03cb724e13cca96ad320733046cbdb16fbbe/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L288)
-    //
-    // While the above function in rustc uses thir exprs, r-a doesn't have them.
-    // So, the logic here is getting same result as "hir lowering + match with lowered thir"
-    // with "hir only"
     fn is_known_valid_scrutinee(&self, scrutinee_expr: ExprId) -> bool {
         let db = self.db();
-
         if self
             .infer
             .expr_adjustments
         {
             return false;
         }
-
         match &self.body[scrutinee_expr] {
             Expr::UnaryOp { op: UnaryOp::Deref, .. } => false,
             Expr::Path(path) => {
         }
     }
 
-    fn lower_pattern<'a>(
-        &self,
-        cx: &MatchCheckCtx<'a, 'db>,
-        pat: PatId,
-        have_errors: &mut bool,
-    ) -> DeconstructedPat<'a, 'db> {
+    fn lower_pattern<'a>(&self, cx: &MatchCheckCtx<'a, 'db>, pat: PatId, have_errors: &mut bool) -> DeconstructedPat<'a, 'db> {
         let mut patcx = match_check::PatCtxt::new(self.db(), &self.infer, &self.body);
         let pattern = patcx.lower_pattern(pat);
         let pattern = cx.lower_pat(&pattern);
         }
     }
 
-    // check for instances of .filter_map(..).next()
-    fn check(
-        &mut self,
-        current_expr_id: ExprId,
-        receiver_expr_id: &ExprId,
-        function_id: &hir_def::FunctionId,
-    ) -> Option<()> {
+    fn check(&mut self, current_expr_id: ExprId, receiver_expr_id: &ExprId, function_id: &hir_def::FunctionId) -> Option<()> {
         if *function_id == self.filter_map_function_id? {
             self.prev_filter_map_expr_id = Some(current_expr_id);
             return None;
         }
-
         if *function_id == self.next_function_id?
             && let Some(prev_filter_map_expr_id) = self.prev_filter_map_expr_id
         {
                 return Some(());
             }
         }
-
         self.prev_filter_map_expr_id = None;
         None
     }
 }
 
-pub fn record_literal_missing_fields(
-    db: &dyn HirDatabase,
-    infer: &InferenceResult<'_>,
-    id: ExprId,
-    expr: &Expr,
-) -> Option<(VariantId, Vec<LocalFieldId>, /*exhaustive*/ bool)> {
+pub fn record_literal_missing_fields(db: &dyn HirDatabase, infer: &InferenceResult<'_>, id: ExprId, expr: &Expr) -> Option<(VariantId, Vec<LocalFieldId>, /*exhaustive*/ bool)> {
     let (fields, exhaustive) = match expr {
         Expr::RecordLit { fields, spread, .. } => (fields, spread.is_none()),
         _ => return None,
     };
-
     let variant_def = infer.variant_resolution_for_expr(id)?;
     if let VariantId::UnionId(_) = variant_def {
         return None;
     }
-
     let variant_data = variant_def.fields(db);
-
     let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();
     let missed_fields: Vec<LocalFieldId> = variant_data
         .fields()
     Some((variant_def, missed_fields, exhaustive))
 }
 
-pub fn record_pattern_missing_fields(
-    db: &dyn HirDatabase,
-    infer: &InferenceResult<'_>,
-    id: PatId,
-    pat: &Pat,
-) -> Option<(VariantId, Vec<LocalFieldId>, /*exhaustive*/ bool)> {
+pub fn record_pattern_missing_fields(db: &dyn HirDatabase, infer: &InferenceResult<'_>, id: PatId, pat: &Pat) -> Option<(VariantId, Vec<LocalFieldId>, /*exhaustive*/ bool)> {
     let (fields, exhaustive) = match pat {
         Pat::Record { path: _, args, ellipsis } => (args, !ellipsis),
         _ => return None,
     };
-
     let variant_def = infer.variant_resolution_for_pat(id)?;
     if let VariantId::UnionId(_) = variant_def {
         return None;
     }
-
     let variant_data = variant_def.fields(db);
-
     let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();
     let missed_fields: Vec<LocalFieldId> = variant_data
         .fields()
             }
         }
     }
-
     let mut has_type_mismatches = false;
     walk(pat, body, infer, &mut has_type_mismatches);
     !has_type_mismatches
 }
 
-fn missing_match_arms<'a, 'db>(
-    cx: &MatchCheckCtx<'a, 'db>,
-    scrut_ty: Ty<'a>,
-    witnesses: Vec<WitnessPat<'a, 'db>>,
-    arms_is_empty: bool,
-    krate: Crate,
-) -> String {
+fn missing_match_arms<'a, 'db>(cx: &MatchCheckCtx<'a, 'db>, scrut_ty: Ty<'a>, witnesses: Vec<WitnessPat<'a, 'db>>, arms_is_empty: bool, krate: Crate) -> String {
     struct DisplayWitness<'a, 'b, 'db>(
         &'a WitnessPat<'b, 'db>,
         &'a MatchCheckCtx<'b, 'db>,
             write!(f, "{}", pat.display(cx.db, display_target))
         }
     }
-
     let non_empty_enum = match scrut_ty.as_adt() {
         Some((AdtId::EnumId(e), _)) => !e.enum_variants(cx.db).variants.is_empty(),
         _ => false,