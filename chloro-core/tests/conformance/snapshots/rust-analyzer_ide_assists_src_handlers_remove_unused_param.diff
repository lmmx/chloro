COMPARISON DIFF
============================================================

Original size: 10526 bytes
Chloro size:   10208 bytes
Rustfmt size:  10803 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
-use ide_db::{defs::Definition, search::FileReference, EditionedFileId};
+use SyntaxKind::WHITESPACE;
+use ide_db::{EditionedFileId, defs::Definition, search::FileReference};
 use syntax::{
+    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, T, TextRange,
     algo::{find_node_at_range, least_common_ancestor_element},
     ast::{self, HasArgList},
     syntax_editor::Element,
-    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, T,
 };
 
-use SyntaxKind::WHITESPACE;
-
 use crate::{
-    assist_context::SourceChangeBuilder, utils::next_prev, AssistContext, AssistId, Assists,
+    AssistContext, AssistId, Assists, assist_context::SourceChangeBuilder, utils::next_prev,
 };
-
-// Assist: remove_unused_param
-//
-// Removes unused function parameter.
-//
-// ```
-// fn frobnicate(x: i32$0) {}
-//
-// fn main() {
-//     frobnicate(92);
-// }
-// ```
-// ->
-// ```
-// fn frobnicate() {}
-//
-// fn main() {
-//     frobnicate();
-// }
-// ```
 pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let param: ast::Param = ctx.find_node_at_offset()?;
     let ident_pat = match param.pat()? {
         _ => return None,
     };
     let func = param.syntax().ancestors().find_map(ast::Fn::cast)?;
-    let is_self_present = param
-        .syntax()
-        .parent()?
-        .children()
-        .find_map(ast::SelfParam::cast)
-        .is_some();
-
+    let is_self_present =
+        param.syntax().parent()?.children().find_map(ast::SelfParam::cast).is_some();
     // check if fn is in impl Trait for ..
     if func
         .syntax()
         cov_mark::hit!(trait_impl);
         return None;
     }
-
     let mut param_position = func.param_list()?.params().position(|it| it == param)?;
     // param_list() does not take the self param into consideration, hence this additional check
     // is required. For associated functions, param_position is incremented here. For inherent
         let func = ctx.sema.to_def(&func)?;
         Definition::Function(func)
     };
-
     let param_def = {
         let local = ctx.sema.to_def(&ident_pat)?;
         Definition::Local(local)
                 editor.delete(element);
             }
             for (file_id, references) in fn_def.usages(&ctx.sema).all() {
-                process_usages(
-                    ctx,
-                    builder,
-                    file_id,
-                    references,
-                    param_position,
-                    is_self_present,
-                );
+                process_usages(ctx, builder, file_id, references, param_position, is_self_present);
             }
             builder.add_file_edits(ctx.vfs_file_id(), editor);
         },
     )
 }
 
-fn process_usages(
-    ctx: &AssistContext<'_>,
-    builder: &mut SourceChangeBuilder,
-    editioned_file_id: EditionedFileId,
-    references: Vec<FileReference>,
-    arg_to_remove: usize,
-    is_self_present: bool,
-) {
+fn process_usages(ctx: &AssistContext<'_>, builder: &mut SourceChangeBuilder, editioned_file_id: EditionedFileId, references: Vec<FileReference>, arg_to_remove: usize, is_self_present: bool) {
     let source_file = ctx.sema.parse(editioned_file_id);
     let file_id = editioned_file_id.file_id(ctx.db());
     builder.edit_file(file_id);
     let possible_ranges = references
         .into_iter()
         .filter_map(|usage| process_usage(&source_file, usage, arg_to_remove, is_self_present));
-
     for element_range in possible_ranges {
-        let Some(SyntaxElement::Node(parent)) = element_range.iter().cloned().reduce(|a, b| {
-            least_common_ancestor_element(&a, &b)
-                .unwrap()
-                .syntax_element()
-        }) else {
+        let Some(SyntaxElement::Node(parent)) = element_range
+            .iter()
+            .cloned()
+            .reduce(|a, b| least_common_ancestor_element(&a, &b).unwrap().syntax_element())
+        else {
             continue;
         };
         let mut editor = builder.make_editor(&parent);
     }
 }
 
-fn process_usage(
-    source_file: &SourceFile,
-    FileReference { range, .. }: FileReference,
-    mut arg_to_remove: usize,
-    is_self_present: bool,
-) -> Option<Vec<SyntaxElement>> {
+fn process_usage(source_file: &SourceFile, FileReference { range, .. }: FileReference, mut arg_to_remove: usize, is_self_present: bool) -> Option<Vec<SyntaxElement>> {
     let call_expr_opt: Option<ast::CallExpr> = find_node_at_range(source_file.syntax(), range);
     if let Some(call_expr) = call_expr_opt {
         let call_expr_range = call_expr.expr()?.syntax().text_range();
         let arg = call_expr.arg_list()?.args().nth(arg_to_remove)?;
         return Some(elements_to_remove(arg.syntax()));
     }
-
     let method_call_expr_opt: Option<ast::MethodCallExpr> =
         find_node_at_range(source_file.syntax(), range);
     if let Some(method_call_expr) = method_call_expr_opt {
         let arg = method_call_expr.arg_list()?.args().nth(arg_to_remove)?;
         return Some(elements_to_remove(arg.syntax()));
     }
-
     None
 }
 
     });
     if let Some((dir, token)) = up_to_comma {
         let after = token.siblings_with_tokens(dir).nth(1).unwrap();
-        let mut result: Vec<_> = node
-            .siblings_with_tokens(dir)
-            .take_while(|it| it != &after)
-            .collect();
+        let mut result: Vec<_> =
+            node.siblings_with_tokens(dir).take_while(|it| it != &after).collect();
         if node.next_sibling().is_some() {
             result.extend(
-                token
-                    .siblings_with_tokens(dir)
-                    .skip(1)
-                    .take_while(|it| it.kind() == WHITESPACE),
+                token.siblings_with_tokens(dir).skip(1).take_while(|it| it.kind() == WHITESPACE),
             );
         }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn remove_unused() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_first_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_single_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_surrounded_by_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_qualified_call() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_turbofished_func() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_generic_unused_param_func() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn keep_used() {
         cov_mark::check!(keep_used);
 "#,
         );
     }
-
     #[test]
     fn trait_impl() {
         cov_mark::check!(trait_impl);
 "#,
         );
     }
-
     #[test]
     fn remove_across_files() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_remove_method_param() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn nested_call() {
         check_assist(