COMPARISON DIFF
============================================================

Original size: 9578 bytes
Chloro size:   9505 bytes
Rustfmt size:  9883 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Tools to work with expressions present in format string literals for the `format_args!` family of macros.
 //! Primarily meant for assists and completions.
-
 /// Enum for representing extracted format string args.
 /// Can either be extracted expressions (which includes identifiers),
 /// or placeholders `{}`.
         .collect()
 }
 
-// FIXME Remove this, we have this information in the HIR now
 /// Parser for a format-like string. It is more allowing in terms of string contents,
 /// as we expect variable placeholders to be filled with expressions.
 ///
         MaybeIncorrect,
         FormatOpts,
     }
-
     let mut state = State::NotArg;
     let mut current_expr = String::new();
     let mut extracted_expressions = Vec::new();
     let mut output = String::new();
-
     // Count of open braces inside of an expression.
     // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.
     // "{MyStruct { val_a: 0, val_b: 1 }}".
     let mut inexpr_open_count = 0;
-
     let mut chars = input.chars().peekable();
     while let Some(chr) = chars.next() {
         match (state, chr) {
                     // if the expression consists of a single number, like "0" or "12", it can refer to
                     // format args in the order they are specified.
                     // see: https://doc.rust-lang.org/std/fmt/#positional-parameters
-                    if trimmed
-                        .chars()
-                        .fold(true, |only_num, c| c.is_ascii_digit() && only_num)
-                    {
+                    if trimmed.chars().fold(true, |only_num, c| c.is_ascii_digit() && only_num) {
                         output.push_str(trimmed);
                     } else if matches!(state, State::Expr) {
                         extracted_expressions.push(Arg::Expr(trimmed.into()));
             }
         }
     }
-
     if state != State::NotArg {
         return Err(());
     }
-
     Ok((output, extracted_expressions))
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-    use expect_test::{expect, Expect};
-
+    use expect_test::{Expect, expect};
     fn check(input: &str, expect: &Expect) {
         let (output, exprs) = parse_format_exprs(input).unwrap_or(("-".to_owned(), vec![]));
         let outcome_repr = if !exprs.is_empty() {
         } else {
             output
         };
-
         expect.assert_eq(&outcome_repr);
     }
-
     #[test]
     fn format_str_parser() {
         let test_vector = &[
             ("no expressions", expect![["no expressions"]]),
-            (
-                r"no expressions with \$0$1",
-                expect![r"no expressions with \$0$1"],
-            ),
+            (r"no expressions with \$0$1", expect![r"no expressions with \$0$1"]),
             ("{expr} is {2 + 2}", expect![["{expr} is {}; 2 + 2"]]),
             ("{expr:?}", expect![["{expr:?}"]]),
             ("{expr:1$}", expect![[r"{expr:1$}"]]),
             ("{correct}}}", expect![["{correct}}}"]]),
             ("{correct}}}}}", expect![["{correct}}}}}"]]),
             ("{incorrect}}", expect![["-"]]),
-            (
-                "placeholders {} {}",
-                expect![["placeholders {} {}; $1, $2"]],
-            ),
-            (
-                "mixed {} {2 + 2} {}",
-                expect![["mixed {} {} {}; $1, 2 + 2, $2"]],
-            ),
+            ("placeholders {} {}", expect![["placeholders {} {}; $1, $2"]]),
+            ("mixed {} {2 + 2} {}", expect![["mixed {} {} {}; $1, 2 + 2, $2"]]),
             (
                 "{SomeStruct { val_a: 0, val_b: 1 }}",
                 expect![["{}; SomeStruct { val_a: 0, val_b: 1 }"]],
             ),
-            (
-                "{expr:?} is {2.32f64:.5}",
-                expect![["{expr:?} is {:.5}; 2.32f64"]],
-            ),
+            ("{expr:?} is {2.32f64:.5}", expect![["{expr:?} is {:.5}; 2.32f64"]]),
             (
                 "{SomeStruct { val_a: 0, val_b: 1 }:?}",
                 expect![["{:?}; SomeStruct { val_a: 0, val_b: 1 }"]],
             ),
             ("{     2 + 2        }", expect![["{}; 2 + 2"]]),
-            (
-                "{strsim::jaro_winkle(a)}",
-                expect![["{}; strsim::jaro_winkle(a)"]],
-            ),
+            ("{strsim::jaro_winkle(a)}", expect![["{}; strsim::jaro_winkle(a)"]]),
             ("{foo::bar::baz()}", expect![["{}; foo::bar::baz()"]]),
             ("{foo::bar():?}", expect![["{:?}; foo::bar()"]]),
         ];
-
         for (input, output) in test_vector {
             check(input, output)
         }
     }
-
     #[test]
     fn arg_type() {
         assert_eq!(