COMPARISON DIFF
============================================================

Original size: 6478 bytes
Chloro size:   6639 bytes
Rustfmt size:  6513 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     CrateGraphBuilder, CratesMap, FileSourceRootInput, FileText, Nonce, RootQueryDb,
     SourceDatabase, SourceRoot, SourceRootId, SourceRootInput,
 };
-
-use hir_def::{db::DefDatabase, nameres::crate_def_map, ModuleId};
+use hir_def::{ModuleId, db::DefDatabase, nameres::crate_def_map};
 use hir_expand::EditionedFileId;
 use rustc_hash::FxHashMap;
 use salsa::Durability;
 }
 
 impl fmt::Debug for TestDB {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("TestDB").finish()
     }
 }
 
-#[salsa_macros::db]
 impl SourceDatabase for TestDB {
-    fn file_text(&self, file_id: base_db::FileId) -> FileText {
+    fn file_text(
+        &self,
+        file_id: base_db::FileId,
+    ) -> FileText {
         self.files.file_text(file_id)
     }
 
-    fn set_file_text(&mut self, file_id: base_db::FileId, text: &str) {
+    fn set_file_text(
+        &mut self,
+        file_id: base_db::FileId,
+        text: &str,
+    ) {
         let files = Arc::clone(&self.files);
         files.set_file_text(self, file_id, text);
     }
     }
 
     /// Source root of the file.
-    fn source_root(&self, source_root_id: SourceRootId) -> SourceRootInput {
+    fn source_root(
+        &self,
+        source_root_id: SourceRootId,
+    ) -> SourceRootInput {
         self.files.source_root(source_root_id)
     }
 
         files.set_source_root_with_durability(self, source_root_id, source_root, durability);
     }
 
-    fn file_source_root(&self, id: base_db::FileId) -> FileSourceRootInput {
+    fn file_source_root(
+        &self,
+        id: base_db::FileId,
+    ) -> FileSourceRootInput {
         self.files.file_source_root(id)
     }
 
     }
 
     fn nonce_and_revision(&self) -> (Nonce, salsa::Revision) {
-        (
-            self.nonce,
-            salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision(),
-        )
+        (self.nonce, salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision())
     }
 }
 
-#[salsa_macros::db]
-impl salsa::Database for TestDB {}
+impl salsa::Database for TestDB {
+}
 
-impl panic::RefUnwindSafe for TestDB {}
+impl panic::RefUnwindSafe for TestDB {
+}
 
 impl TestDB {
-    pub(crate) fn module_for_file_opt(&self, file_id: impl Into<FileId>) -> Option<ModuleId> {
+    pub(crate) fn module_for_file_opt(
+        &self,
+        file_id: impl Into<FileId>,
+    ) -> Option<ModuleId> {
         let file_id = file_id.into();
         for &krate in self.relevant_crates(file_id).iter() {
             let crate_def_map = crate_def_map(self, krate);
         None
     }
 
-    pub(crate) fn module_for_file(&self, file_id: impl Into<FileId>) -> ModuleId {
+    pub(crate) fn module_for_file(
+        &self,
+        file_id: impl Into<FileId>,
+    ) -> ModuleId {
         self.module_for_file_opt(file_id.into()).unwrap()
     }
 
-    pub(crate) fn extract_annotations(
-        &self,
-    ) -> FxHashMap<EditionedFileId, Vec<(TextRange, String)>> {
+    pub(crate) fn extract_annotations(&self) -> FxHashMap<EditionedFileId, Vec<(TextRange, String)>> {
         let mut files = Vec::new();
         for &krate in self.all_crates().iter() {
             let crate_def_map = crate_def_map(self, krate);
 }
 
 impl TestDB {
-    pub(crate) fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event> {
+    pub(crate) fn log(
+        &self,
+        f: impl FnOnce(),
+    ) -> Vec<salsa::Event> {
         *self.events.lock().unwrap() = Some(Vec::new());
         f();
         self.events.lock().unwrap().take().unwrap()
     }
 
-    pub(crate) fn log_executed(&self, f: impl FnOnce()) -> (Vec<String>, Vec<salsa::Event>) {
+    pub(crate) fn log_executed(
+        &self,
+        f: impl FnOnce(),
+    ) -> (Vec<String>, Vec<salsa::Event>) {
         let events = self.log(f);
         let executed = events
             .iter()