COMPARISON DIFF
============================================================

Original size: 95826 bytes
Chloro size:   93829 bytes
Rustfmt size:  95826 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     },
     traits::FnTrait,
 };
-
 use super::OperandKind;
 
 mod as_place;
+
 mod pattern_matching;
+
 #[cfg(test)]
 mod tests;
 
     infcx: InferCtxt<'db>,
 }
 
-// FIXME: Make this smaller, its stored in database queries
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum MirLowerError<'db> {
     ConstEvalError(Box<str>, Box<ConstEvalError<'db>>),
     UnresolvedLabel,
     UnresolvedUpvar(Place<'db>),
     InaccessibleLocal,
-
-    // monomorphization errors:
     GenericArgNotProvided(GenericParamId, GenericArgs<'db>),
 }
 
 /// A token to ensuring that each drop scope is popped at most once, thanks to the compiler that checks moves.
 struct DropScopeToken;
+
 impl DropScopeToken {
-    fn pop_and_drop<'db>(
-        self,
-        ctx: &mut MirLowerCtx<'_, 'db>,
-        current: BasicBlockId<'db>,
-        span: MirSpan,
-    ) -> BasicBlockId<'db> {
+    fn pop_and_drop<'db>(self, ctx: &mut MirLowerCtx<'_, 'db>, current: BasicBlockId<'db>, span: MirSpan) -> BasicBlockId<'db> {
         std::mem::forget(self);
         ctx.pop_drop_scope_internal(current, span)
     }
 }
 
 impl Drop for DropScopeToken {
-    fn drop(&mut self) {}
+    fn drop(&mut self) {
+    }
 }
 
-// Uncomment this to make `DropScopeToken` a drop bomb. Unfortunately we can't do this in release, since
-// in cases that mir lowering fails, we don't handle (and don't need to handle) drop scopes so it will be
-// actually reached. `pop_drop_scope_assert_finished` will also detect this case, but doesn't show useful
-// stack trace.
-//
-// impl Drop for DropScopeToken {
-//     fn drop(&mut self) {
-//         never!("Drop scope doesn't popped");
-//     }
-// }
-
 impl MirLowerError<'_> {
-    pub fn pretty_print(
-        &self,
-        f: &mut String,
-        db: &dyn HirDatabase,
-        span_formatter: impl Fn(FileId, TextRange) -> String,
-        display_target: DisplayTarget,
-    ) -> std::result::Result<(), std::fmt::Error> {
+    pub fn pretty_print(&self, f: &mut String, db: &dyn HirDatabase, span_formatter: impl Fn(FileId, TextRange) -> String, display_target: DisplayTarget) -> std::result::Result<(), std::fmt::Error> {
         match self {
             MirLowerError::ConstEvalError(name, e) => {
                 writeln!(f, "In evaluating constant {name}")?;
 }
 
 impl MirLowerError<'_> {
-    fn unresolved_path(
-        db: &dyn HirDatabase,
-        p: &Path,
-        display_target: DisplayTarget,
-        store: &ExpressionStore,
-    ) -> Self {
+    fn unresolved_path(db: &dyn HirDatabase, p: &Path, display_target: DisplayTarget, store: &ExpressionStore) -> Self {
         Self::UnresolvedName(
             hir_display_with_store(p, store).display(db, display_target).to_string(),
         )
 type Result<'db, T> = std::result::Result<T, MirLowerError<'db>>;
 
 impl<'a, 'db> MirLowerCtx<'a, 'db> {
-    fn new(
-        db: &'db dyn HirDatabase,
-        owner: DefWithBodyId,
-        body: &'a Body,
-        infer: &'a InferenceResult<'db>,
-    ) -> Self {
+    fn new(db: &'db dyn HirDatabase, owner: DefWithBodyId, body: &'a Body, infer: &'a InferenceResult<'db>) -> Self {
         let mut basic_blocks = Arena::new();
         let start_block = basic_blocks.alloc(BasicBlock {
             statements: vec![],
         let interner = DbInterner::new_with(db, Some(env.krate), env.block);
         // FIXME(next-solver): Is `non_body_analysis()` correct here? Don't we want to reveal opaque types defined by this body?
         let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
-
         MirLowerCtx {
             result: mir,
             db,
         self.infcx.interner
     }
 
-    fn temp(
-        &mut self,
-        ty: Ty<'db>,
-        current: BasicBlockId<'db>,
-        span: MirSpan,
-    ) -> Result<'db, LocalId<'db>> {
+    fn temp(&mut self, ty: Ty<'db>, current: BasicBlockId<'db>, span: MirSpan) -> Result<'db, LocalId<'db>> {
         if matches!(ty.kind(), TyKind::Slice(_) | TyKind::Dynamic(..)) {
             return Err(MirLowerError::UnsizedTemporary(ty));
         }
         Ok(l)
     }
 
-    fn lower_expr_to_some_operand(
-        &mut self,
-        expr_id: ExprId,
-        current: BasicBlockId<'db>,
-    ) -> Result<'db, Option<(Operand<'db>, BasicBlockId<'db>)>> {
+    fn lower_expr_to_some_operand(&mut self, expr_id: ExprId, current: BasicBlockId<'db>) -> Result<'db, Option<(Operand<'db>, BasicBlockId<'db>)>> {
         if !self.has_adjustments(expr_id)
             && let Expr::Literal(l) = &self.body[expr_id]
         {
         Ok(Some((Operand { kind: OperandKind::Copy(p), span: Some(expr_id.into()) }, current)))
     }
 
-    fn lower_expr_to_place_with_adjust(
-        &mut self,
-        expr_id: ExprId,
-        place: Place<'db>,
-        current: BasicBlockId<'db>,
-        adjustments: &[Adjustment<'db>],
-    ) -> Result<'db, Option<BasicBlockId<'db>>> {
+    fn lower_expr_to_place_with_adjust(&mut self, expr_id: ExprId, place: Place<'db>, current: BasicBlockId<'db>, adjustments: &[Adjustment<'db>]) -> Result<'db, Option<BasicBlockId<'db>>> {
         match adjustments.split_last() {
             Some((last, rest)) => match &last.kind {
                 Adjust::NeverToAny => {
         }
     }
 
-    fn lower_expr_to_place(
-        &mut self,
-        expr_id: ExprId,
-        place: Place<'db>,
-        prev_block: BasicBlockId<'db>,
-    ) -> Result<'db, Option<BasicBlockId<'db>>> {
+    fn lower_expr_to_place(&mut self, expr_id: ExprId, place: Place<'db>, prev_block: BasicBlockId<'db>) -> Result<'db, Option<BasicBlockId<'db>>> {
         if let Some(adjustments) = self.infer.expr_adjustments.get(&expr_id) {
             return self.lower_expr_to_place_with_adjust(expr_id, place, prev_block, adjustments);
         }
         self.lower_expr_to_place_without_adjust(expr_id, place, prev_block)
     }
 
-    fn lower_expr_to_place_without_adjust(
-        &mut self,
-        expr_id: ExprId,
-        place: Place<'db>,
-        mut current: BasicBlockId<'db>,
-    ) -> Result<'db, Option<BasicBlockId<'db>>> {
+    fn lower_expr_to_place_without_adjust(&mut self, expr_id: ExprId, place: Place<'db>, mut current: BasicBlockId<'db>) -> Result<'db, Option<BasicBlockId<'db>>> {
         match &self.body[expr_id] {
             Expr::OffsetOf(_) => {
                 not_supported!("builtin#offset_of")
         }
     }
 
-    fn push_field_projection(
-        &mut self,
-        place: &mut Place<'db>,
-        expr_id: ExprId,
-    ) -> Result<'db, ()> {
+    fn push_field_projection(&mut self, place: &mut Place<'db>, expr_id: ExprId) -> Result<'db, ()> {
         if let Expr::Field { expr, name } = &self.body[expr_id] {
             if let TyKind::Tuple(..) = self.expr_ty_after_adjustments(*expr).kind() {
                 let index =
         Ok(())
     }
 
-    fn lower_literal_or_const_to_operand(
-        &mut self,
-        ty: Ty<'db>,
-        loc: &ExprId,
-    ) -> Result<'db, Operand<'db>> {
+    fn lower_literal_or_const_to_operand(&mut self, ty: Ty<'db>, loc: &ExprId) -> Result<'db, Operand<'db>> {
         match &self.body[*loc] {
             Expr::Literal(l) => self.lower_literal_to_operand(ty, l),
             Expr::Path(c) => {
         self.result.basic_blocks.alloc(BasicBlock::default())
     }
 
-    fn lower_const(
-        &mut self,
-        const_id: GeneralConstId,
-        prev_block: BasicBlockId<'db>,
-        place: Place<'db>,
-        subst: GenericArgs<'db>,
-        span: MirSpan,
-    ) -> Result<'db, ()> {
+    fn lower_const(&mut self, const_id: GeneralConstId, prev_block: BasicBlockId<'db>, place: Place<'db>, subst: GenericArgs<'db>, span: MirSpan) -> Result<'db, ()> {
         let c = self.lower_const_to_operand(subst, const_id)?;
         self.push_assignment(prev_block, place, c.into(), span);
         Ok(())
     }
 
-    fn lower_const_to_operand(
-        &mut self,
-        subst: GenericArgs<'db>,
-        const_id: GeneralConstId,
-    ) -> Result<'db, Operand<'db>> {
+    fn lower_const_to_operand(&mut self, subst: GenericArgs<'db>, const_id: GeneralConstId) -> Result<'db, Operand<'db>> {
         let konst = if subst.len() != 0 {
             // We can't evaluate constant with substitution now, as generics are not monomorphized in lowering.
             Const::new_unevaluated(
         Ok(Operand { kind: OperandKind::Constant { konst, ty }, span: None })
     }
 
-    fn write_bytes_to_place(
-        &mut self,
-        prev_block: BasicBlockId<'db>,
-        place: Place<'db>,
-        cv: Box<[u8]>,
-        ty: Ty<'db>,
-        span: MirSpan,
-    ) -> Result<'db, ()> {
+    fn write_bytes_to_place(&mut self, prev_block: BasicBlockId<'db>, place: Place<'db>, cv: Box<[u8]>, ty: Ty<'db>, span: MirSpan) -> Result<'db, ()> {
         self.push_assignment(prev_block, place, Operand::from_bytes(cv, ty).into(), span);
         Ok(())
     }
 
-    fn lower_enum_variant(
-        &mut self,
-        variant_id: EnumVariantId,
-        prev_block: BasicBlockId<'db>,
-        place: Place<'db>,
-        ty: Ty<'db>,
-        fields: Box<[Operand<'db>]>,
-        span: MirSpan,
-    ) -> Result<'db, BasicBlockId<'db>> {
+    fn lower_enum_variant(&mut self, variant_id: EnumVariantId, prev_block: BasicBlockId<'db>, place: Place<'db>, ty: Ty<'db>, fields: Box<[Operand<'db>]>, span: MirSpan) -> Result<'db, BasicBlockId<'db>> {
         let subst = match ty.kind() {
             TyKind::Adt(_, subst) => subst,
             _ => implementation_error!("Non ADT enum"),
         Ok(prev_block)
     }
 
-    fn lower_call_and_args(
-        &mut self,
-        func: Operand<'db>,
-        args: impl Iterator<Item = ExprId>,
-        place: Place<'db>,
-        mut current: BasicBlockId<'db>,
-        is_uninhabited: bool,
-        span: MirSpan,
-    ) -> Result<'db, Option<BasicBlockId<'db>>> {
+    fn lower_call_and_args(&mut self, func: Operand<'db>, args: impl Iterator<Item = ExprId>, place: Place<'db>, mut current: BasicBlockId<'db>, is_uninhabited: bool, span: MirSpan) -> Result<'db, Option<BasicBlockId<'db>>> {
         let Some(args) = args
             .map(|arg| {
                 if let Some((temp, c)) = self.lower_expr_to_some_operand(arg, current)? {
         self.lower_call(func, args.into(), place, current, is_uninhabited, span)
     }
 
-    fn lower_call(
-        &mut self,
-        func: Operand<'db>,
-        args: Box<[Operand<'db>]>,
-        place: Place<'db>,
-        current: BasicBlockId<'db>,
-        is_uninhabited: bool,
-        span: MirSpan,
-    ) -> Result<'db, Option<BasicBlockId<'db>>> {
+    fn lower_call(&mut self, func: Operand<'db>, args: Box<[Operand<'db>]>, place: Place<'db>, current: BasicBlockId<'db>, is_uninhabited: bool, span: MirSpan) -> Result<'db, Option<BasicBlockId<'db>>> {
         let b = if is_uninhabited { None } else { Some(self.new_basic_block()) };
         self.set_terminator(
             current,
         self.result.basic_blocks[source].terminator.is_none()
     }
 
-    fn set_terminator(
-        &mut self,
-        source: BasicBlockId<'db>,
-        terminator: TerminatorKind<'db>,
-        span: MirSpan,
-    ) {
+    fn set_terminator(&mut self, source: BasicBlockId<'db>, terminator: TerminatorKind<'db>, span: MirSpan) {
         self.result.basic_blocks[source].terminator = Some(Terminator { span, kind: terminator });
     }
 
         self.push_statement(block, StatementKind::FakeRead(p).with_span(span));
     }
 
-    fn push_assignment(
-        &mut self,
-        block: BasicBlockId<'db>,
-        place: Place<'db>,
-        rvalue: Rvalue<'db>,
-        span: MirSpan,
-    ) {
+    fn push_assignment(&mut self, block: BasicBlockId<'db>, place: Place<'db>, rvalue: Rvalue<'db>, span: MirSpan) {
         self.push_statement(block, StatementKind::Assign(place, rvalue).with_span(span));
     }
 
         }
     }
 
-    fn lower_loop(
-        &mut self,
-        prev_block: BasicBlockId<'db>,
-        place: Place<'db>,
-        label: Option<LabelId>,
-        span: MirSpan,
-        f: impl FnOnce(&mut MirLowerCtx<'_, 'db>, BasicBlockId<'db>) -> Result<'db, ()>,
-    ) -> Result<'db, Option<BasicBlockId<'db>>> {
+    fn lower_loop(&mut self, prev_block: BasicBlockId<'db>, place: Place<'db>, label: Option<LabelId>, span: MirSpan, f: impl FnOnce(&mut MirLowerCtx<'_, 'db>, BasicBlockId<'db>) -> Result<'db, ()>) -> Result<'db, Option<BasicBlockId<'db>>> {
         let begin = self.new_basic_block();
         let prev = self.current_loop_blocks.replace(LoopBlocks {
             begin,
         !self.infer.expr_adjustments.get(&expr_id).map(|it| it.is_empty()).unwrap_or(true)
     }
 
-    fn merge_blocks(
-        &mut self,
-        b1: Option<BasicBlockId<'db>>,
-        b2: Option<BasicBlockId<'db>>,
-        span: MirSpan,
-    ) -> Option<BasicBlockId<'db>> {
+    fn merge_blocks(&mut self, b1: Option<BasicBlockId<'db>>, b2: Option<BasicBlockId<'db>>, span: MirSpan) -> Option<BasicBlockId<'db>> {
         match (b1, b2) {
             (None, None) => None,
             (None, Some(b)) | (Some(b), None) => Some(b),
         self.push_storage_live_for_local(l, current, MirSpan::BindingId(b))
     }
 
-    fn push_storage_live_for_local(
-        &mut self,
-        l: LocalId<'db>,
-        current: BasicBlockId<'db>,
-        span: MirSpan,
-    ) -> Result<'db, ()> {
+    fn push_storage_live_for_local(&mut self, l: LocalId<'db>, current: BasicBlockId<'db>, span: MirSpan) -> Result<'db, ()> {
         self.drop_scopes.last_mut().unwrap().locals.push(l);
         self.push_statement(current, StatementKind::StorageLive(l).with_span(span));
         Ok(())
         lang_item(self.db, crate_id, item).ok_or(MirLowerError::LangItemNotFound(item))
     }
 
-    fn lower_block_to_place(
-        &mut self,
-        statements: &[hir_def::hir::Statement],
-        mut current: BasicBlockId<'db>,
-        tail: Option<ExprId>,
-        place: Place<'db>,
-        span: MirSpan,
-    ) -> Result<'db, Option<Idx<BasicBlock<'db>>>> {
+    fn lower_block_to_place(&mut self, statements: &[hir_def::hir::Statement], mut current: BasicBlockId<'db>, tail: Option<ExprId>, place: Place<'db>, span: MirSpan) -> Result<'db, Option<Idx<BasicBlock<'db>>>> {
         let scope = self.push_drop_scope();
         for statement in statements.iter() {
             match statement {
         Ok(Some(current))
     }
 
-    fn lower_params_and_bindings(
-        &mut self,
-        params: impl Iterator<Item = (PatId, Ty<'db>)> + Clone,
-        self_binding: Option<(BindingId, Ty<'db>)>,
-        pick_binding: impl Fn(BindingId) -> bool,
-    ) -> Result<'db, BasicBlockId<'db>> {
+    fn lower_params_and_bindings(&mut self, params: impl Iterator<Item = (PatId, Ty<'db>)> + Clone, self_binding: Option<(BindingId, Ty<'db>)>, pick_binding: impl Fn(BindingId) -> bool) -> Result<'db, BasicBlockId<'db>> {
         let base_param_count = self.result.param_locals.len();
         let self_binding = match self_binding {
             Some((self_binding, ty)) => {
         DisplayTarget::from_crate(self.db, self.krate())
     }
 
-    fn drop_until_scope(
-        &mut self,
-        scope_index: usize,
-        mut current: BasicBlockId<'db>,
-        span: MirSpan,
-    ) -> BasicBlockId<'db> {
+    fn drop_until_scope(&mut self, scope_index: usize, mut current: BasicBlockId<'db>, span: MirSpan) -> BasicBlockId<'db> {
         for scope in self.drop_scopes[scope_index..].to_vec().iter().rev() {
             self.emit_drop_and_storage_dead_for_scope(scope, &mut current, span);
         }
     }
 
     /// Don't call directly
-    fn pop_drop_scope_internal(
-        &mut self,
-        mut current: BasicBlockId<'db>,
-        span: MirSpan,
-    ) -> BasicBlockId<'db> {
+    fn pop_drop_scope_internal(&mut self, mut current: BasicBlockId<'db>, span: MirSpan) -> BasicBlockId<'db> {
         let scope = self.drop_scopes.pop().unwrap();
         self.emit_drop_and_storage_dead_for_scope(&scope, &mut current, span);
         current
     }
 
-    fn pop_drop_scope_assert_finished(
-        &mut self,
-        mut current: BasicBlockId<'db>,
-        span: MirSpan,
-    ) -> Result<'db, BasicBlockId<'db>> {
+    fn pop_drop_scope_assert_finished(&mut self, mut current: BasicBlockId<'db>, span: MirSpan) -> Result<'db, BasicBlockId<'db>> {
         current = self.pop_drop_scope_internal(current, span);
         if !self.drop_scopes.is_empty() {
             implementation_error!("Mismatched count between drop scope push and pops");
         Ok(current)
     }
 
-    fn emit_drop_and_storage_dead_for_scope(
-        &mut self,
-        scope: &DropScope<'db>,
-        current: &mut Idx<BasicBlock<'db>>,
-        span: MirSpan,
-    ) {
+    fn emit_drop_and_storage_dead_for_scope(&mut self, scope: &DropScope<'db>, current: &mut Idx<BasicBlock<'db>>, span: MirSpan) {
         for &l in scope.locals.iter().rev() {
             if !self.infcx.type_is_copy_modulo_regions(self.env.env, self.result.locals[l].ty) {
                 let prev = std::mem::replace(current, self.new_basic_block());
     }
 }
 
-fn cast_kind<'db>(
-    db: &'db dyn HirDatabase,
-    source_ty: Ty<'db>,
-    target_ty: Ty<'db>,
-) -> Result<'db, CastKind> {
+fn cast_kind<'db>(db: &'db dyn HirDatabase, source_ty: Ty<'db>, target_ty: Ty<'db>) -> Result<'db, CastKind> {
     let from = CastTy::from_ty(db, source_ty);
     let cast = CastTy::from_ty(db, target_ty);
     Ok(match (from, cast) {
     })
 }
 
-pub fn mir_body_for_closure_query<'db>(
-    db: &'db dyn HirDatabase,
-    closure: InternedClosureId,
-) -> Result<'db, Arc<MirBody<'db>>> {
+pub fn mir_body_for_closure_query<'db>(db: &'db dyn HirDatabase, closure: InternedClosureId) -> Result<'db, Arc<MirBody<'db>>> {
     let InternedClosure(owner, expr) = db.lookup_intern_closure(closure);
     let body = db.body(owner);
     let infer = db.infer(owner);
     Ok(Arc::new(ctx.result))
 }
 
-pub fn mir_body_query<'db>(
-    db: &'db dyn HirDatabase,
-    def: DefWithBodyId,
-) -> Result<'db, Arc<MirBody<'db>>> {
+pub fn mir_body_query<'db>(db: &'db dyn HirDatabase, def: DefWithBodyId) -> Result<'db, Arc<MirBody<'db>>> {
     let krate = def.krate(db);
     let edition = krate.data(db).edition;
     let detail = match def {
     Ok(Arc::new(result))
 }
 
-pub(crate) fn mir_body_cycle_result<'db>(
-    _db: &'db dyn HirDatabase,
-    _def: DefWithBodyId,
-) -> Result<'db, Arc<MirBody<'db>>> {
+pub(crate) fn mir_body_cycle_result<'db>(_db: &'db dyn HirDatabase, _def: DefWithBodyId) -> Result<'db, Arc<MirBody<'db>>> {
     Err(MirLowerError::Loop)
 }
 
-pub fn lower_to_mir<'db>(
-    db: &'db dyn HirDatabase,
-    owner: DefWithBodyId,
-    body: &Body,
-    infer: &InferenceResult<'db>,
-    // FIXME: root_expr should always be the body.body_expr, but since `X` in `[(); X]` doesn't have its own specific body yet, we
-    // need to take this input explicitly.
-    root_expr: ExprId,
-) -> Result<'db, MirBody<'db>> {
+pub fn lower_to_mir<'db>(db: &'db dyn HirDatabase, owner: DefWithBodyId, body: &Body, infer: &InferenceResult<'db>, root_expr: ExprId) -> Result<'db, MirBody<'db>> {
     if infer.type_mismatches().next().is_some() || infer.is_erroneous() {
         return Err(MirLowerError::HasErrors);
     }