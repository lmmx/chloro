COMPARISON DIFF
============================================================

Original size: 5724 bytes
Chloro size:   5666 bytes
Rustfmt size:  5762 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Defining opaque types via inference.
 
-use rustc_type_ir::{fold_regions, TypeVisitableExt};
+use rustc_type_ir::{TypeVisitableExt, fold_regions};
 use tracing::{debug, instrument};
 
 use crate::{
     infer::InferenceContext,
     next_solver::{
-        infer::{opaque_types::OpaqueHiddenType, traits::ObligationCause},
         EarlyBinder, OpaqueTypeKey, SolverDefId, TypingMode,
+        infer::{opaque_types::OpaqueHiddenType, traits::ObligationCause},
     },
 };
 
         // We clone the opaques instead of stealing them here as they are still used for
         // normalization in the next generation trait solver.
         let opaque_types: Vec<_> = self.table.infer_ctxt.clone_opaque_types();
-
         self.compute_definition_site_hidden_types(opaque_types);
     }
 }
 }
 
 impl<'db> InferenceContext<'_, 'db> {
-    fn compute_definition_site_hidden_types(
-        &mut self,
-        mut opaque_types: Vec<(OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)>,
-    ) {
+    fn compute_definition_site_hidden_types(&mut self, mut opaque_types: Vec<(OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)>) {
         for entry in opaque_types.iter_mut() {
             *entry = self.table.infer_ctxt.resolve_vars_if_possible(*entry);
         }
         debug!(?opaque_types);
-
         let interner = self.interner();
-        let TypingMode::Analysis {
-            defining_opaque_types_and_generators,
-        } = self.table.infer_ctxt.typing_mode()
+        let TypingMode::Analysis { defining_opaque_types_and_generators } =
+            self.table.infer_ctxt.typing_mode()
         else {
             unreachable!();
         };
-
         for def_id in defining_opaque_types_and_generators {
             let def_id = match def_id {
                 SolverDefId::InternedOpaqueTyId(it) => it,
     }
 
     #[tracing::instrument(skip(self), ret)]
-    fn consider_opaque_type_use(
-        &self,
-        opaque_type_key: OpaqueTypeKey<'db>,
-        hidden_type: OpaqueHiddenType<'db>,
-    ) -> UsageKind<'db> {
+    fn consider_opaque_type_use(&self, opaque_type_key: OpaqueTypeKey<'db>, hidden_type: OpaqueHiddenType<'db>) -> UsageKind<'db> {
         // We ignore uses of the opaque if they have any inference variables
         // as this can frequently happen with recursive calls.
         //
         if hidden_type.ty.has_non_region_infer() {
             return UsageKind::UnconstrainedHiddenType(hidden_type);
         }
-
         let cause = ObligationCause::new();
         let at = self.table.infer_ctxt.at(&cause, self.table.trait_env.env);
         let hidden_type = match at.deeply_normalize(hidden_type) {
             Ok(hidden_type) => hidden_type,
-            Err(_errors) => OpaqueHiddenType {
-                ty: self.types.error,
-            },
+            Err(_errors) => OpaqueHiddenType { ty: self.types.error },
         };
         let hidden_type = fold_regions(self.interner(), hidden_type, |_, _| self.types.re_erased);
         UsageKind::HasDefiningUse(hidden_type)