COMPARISON DIFF
============================================================

Original size: 13249 bytes
Chloro size:   12306 bytes
Rustfmt size:  13343 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
-use hir::{sym, Name};
+use hir::{Name, sym};
 use ide_db::famous_defs::FamousDefs;
 use stdx::format_to;
 use syntax::{
-    ast::{self, edit_in_place::Indent, make, HasArgList, HasLoopBody},
     AstNode,
+    ast::{self, HasArgList, HasLoopBody, edit_in_place::Indent, make},
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: convert_iter_for_each_to_for
-//
-// Converts an Iterator::for_each function into a for loop.
-//
-// ```
-// # //- minicore: iterators
-// # use core::iter;
-// fn main() {
-//     let iter = iter::repeat((9, 2));
-//     iter.for_each$0(|(x, y)| {
-//         println!("x: {}, y: {}", x, y);
-//     });
-// }
-// ```
-// ->
-// ```
-// # use core::iter;
-// fn main() {
-//     let iter = iter::repeat((9, 2));
-//     for (x, y) in iter {
-//         println!("x: {}, y: {}", x, y);
-//     }
-// }
-// ```
-pub(crate) fn convert_iter_for_each_to_for(
-    acc: &mut Assists,
-    ctx: &AssistContext<'_>,
-) -> Option<()> {
+pub(crate) fn convert_iter_for_each_to_for(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let method = ctx.find_node_at_offset::<ast::MethodCallExpr>()?;
-
     let closure = match method.arg_list()?.args().next()? {
         ast::Expr::ClosureExpr(expr) => expr,
         _ => return None,
     };
-
     let (method, receiver) = validate_method_call_expr(ctx, method)?;
-
     let param_list = closure.param_list()?;
     let param = param_list.params().next()?.pat()?;
     let body = closure.body()?;
-
     let stmt = method.syntax().parent().and_then(ast::ExprStmt::cast);
-    let range = stmt
-        .as_ref()
-        .map_or(method.syntax(), AstNode::syntax)
-        .text_range();
-
+    let range = stmt.as_ref().map_or(method.syntax(), AstNode::syntax).text_range();
     acc.add(
         AssistId::refactor_rewrite("convert_iter_for_each_to_for"),
         "Replace this `Iterator::for_each` with a for loop",
         range,
         |builder| {
-            let indent = stmt
-                .as_ref()
-                .map_or_else(|| method.indent_level(), ast::ExprStmt::indent_level);
+            let indent =
+                stmt.as_ref().map_or_else(|| method.indent_level(), ast::ExprStmt::indent_level);
 
             let block = match body {
                 ast::Expr::BlockExpr(block) => block,
     )
 }
 
-// Assist: convert_for_loop_with_for_each
-//
-// Converts a for loop into a for_each loop on the Iterator.
-//
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     for$0 v in x {
-//         let y = v * 2;
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     x.into_iter().for_each(|v| {
-//         let y = v * 2;
-//     });
-// }
-// ```
-pub(crate) fn convert_for_loop_with_for_each(
-    acc: &mut Assists,
-    ctx: &AssistContext<'_>,
-) -> Option<()> {
+pub(crate) fn convert_for_loop_with_for_each(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let for_loop = ctx.find_node_at_offset::<ast::ForExpr>()?;
     let iterable = for_loop.iterable()?;
     let pat = for_loop.pat()?;
         cov_mark::hit!(not_available_in_body);
         return None;
     }
-
     acc.add(
         AssistId::refactor_rewrite("convert_for_loop_with_for_each"),
         "Replace this for loop with `Iterator::for_each`",
 /// If iterable is a reference where the expression behind the reference implements a method
 /// returning an Iterator called iter or iter_mut (depending on the type of reference) then return
 /// the expression behind the reference and the method name
-fn is_ref_and_impls_iter_method(
-    sema: &hir::Semantics<'_, ide_db::RootDatabase>,
-    iterable: &ast::Expr,
-) -> Option<(ast::Expr, hir::Name, hir::Crate)> {
+fn is_ref_and_impls_iter_method(sema: &hir::Semantics<'_, ide_db::RootDatabase>, iterable: &ast::Expr) -> Option<(ast::Expr, hir::Name, hir::Crate)> {
     let ref_expr = match iterable {
         ast::Expr::RefExpr(r) => r,
         _ => return None,
     let scope = sema.scope(iterable.syntax())?;
     let krate = scope.krate();
     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;
-
     let has_wanted_method = ty
         .iterate_method_candidates(sema.db, &scope, None, Some(&wanted_method), |func| {
             if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {
     if !has_wanted_method {
         return None;
     }
-
     Some((expr_behind_ref, wanted_method, krate))
 }
 
     .unwrap_or(false)
 }
 
-fn validate_method_call_expr(
-    ctx: &AssistContext<'_>,
-    expr: ast::MethodCallExpr,
-) -> Option<(ast::Expr, ast::Expr)> {
+fn validate_method_call_expr(ctx: &AssistContext<'_>, expr: ast::MethodCallExpr) -> Option<(ast::Expr, ast::Expr)> {
     let name_ref = expr.name_ref()?;
-    if !name_ref
-        .syntax()
-        .text_range()
-        .contains_range(ctx.selection_trimmed())
-    {
+    if !name_ref.syntax().text_range().contains_range(ctx.selection_trimmed()) {
         cov_mark::hit!(test_for_each_not_applicable_invalid_cursor_pos);
         return None;
     }
     if name_ref.text() != "for_each" {
         return None;
     }
-
     let sema = &ctx.sema;
-
     let receiver = expr.receiver()?;
     let expr = ast::Expr::MethodCallExpr(expr);
-
     let it_type = sema.type_of_expr(&receiver)?.adjusted();
     let module = sema.scope(receiver.syntax())?.module();
     let krate = module.krate();
-
     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;
-    it_type
-        .impls_trait(sema.db, iter_trait, &[])
-        .then_some((expr, receiver))
+    it_type.impls_trait(sema.db, iter_trait, &[]).then_some((expr, receiver))
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_for_each_in_method_stmt() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_for_each_in_method() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_for_each_without_braces_stmt() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_for_each_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_for_each_not_applicable_invalid_cursor_pos() {
         cov_mark::check!(test_for_each_not_applicable_invalid_cursor_pos);
 }"#,
         )
     }
-
     #[test]
     fn each_to_for_not_for() {
         check_assist_not_applicable(
         ",
         )
     }
-
     #[test]
     fn each_to_for_simple_for() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_in_range() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn each_to_for_not_available_in_body() {
         cov_mark::check!(not_available_in_body);
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_no_iter_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut_behind_var() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_already_impls_iterator() {
         cov_mark::check!(test_already_impls_iterator);