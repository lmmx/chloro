COMPARISON DIFF
============================================================

Original size: 14759 bytes
Chloro size:   13839 bytes
Rustfmt size:  14777 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use hir::ModuleDef;
 use ide_db::{assists::AssistId, famous_defs::FamousDefs};
 use syntax::{
-    ast::{self, HasGenericArgs, HasVisibility},
     AstNode, NodeOrToken, SyntaxKind, SyntaxNode, SyntaxToken, TextRange,
+    ast::{self, HasGenericArgs, HasVisibility},
 };
 
 use crate::{AssistContext, Assists};
 
-// Assist: sugar_impl_future_into_async
-//
-// Rewrites asynchronous function from `-> impl Future` into `async fn`.
-// This action does not touch the function body and therefore `async { 0 }`
-// block does not transform to just `0`.
-//
-// ```
-// # //- minicore: future
-// pub fn foo() -> impl core::future::F$0uture<Output = usize> {
-//     async { 0 }
-// }
-// ```
-// ->
-// ```
-// pub async fn foo() -> usize {
-//     async { 0 }
-// }
-// ```
-pub(crate) fn sugar_impl_future_into_async(
-    acc: &mut Assists,
-    ctx: &AssistContext<'_>,
-) -> Option<()> {
+pub(crate) fn sugar_impl_future_into_async(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let ret_type: ast::RetType = ctx.find_node_at_offset()?;
     let function = ret_type.syntax().parent().and_then(ast::Fn::cast)?;
-
     if function.async_token().is_some() || function.const_token().is_some() {
         return None;
     }
-
     let ast::Type::ImplTraitType(return_impl_trait) = ret_type.ty()? else {
         return None;
     };
-
     let main_trait_path = return_impl_trait
         .type_bound_list()?
         .bounds()
             _ => None,
         })
         .next()?;
-
     let trait_type = ctx.sema.resolve_trait(&main_trait_path)?;
     let scope = ctx.sema.scope(main_trait_path.syntax())?;
     if trait_type != FamousDefs(&ctx.sema, scope.krate()).core_future_Future()? {
         return None;
     }
     let future_output = unwrap_future_output(main_trait_path)?;
-
     acc.add(
         AssistId::refactor_rewrite("sugar_impl_future_into_async"),
         "Convert `impl Future` into async",
     )
 }
 
-// Assist: desugar_async_into_impl_future
-//
-// Rewrites asynchronous function from `async fn` into `-> impl Future`.
-// This action does not touch the function body and therefore `0`
-// block does not transform to `async { 0 }`.
-//
-// ```
-// # //- minicore: future
-// pub as$0ync fn foo() -> usize {
-//     0
-// }
-// ```
-// ->
-// ```
-// pub fn foo() -> impl core::future::Future<Output = usize> {
-//     0
-// }
-// ```
-pub(crate) fn desugar_async_into_impl_future(
-    acc: &mut Assists,
-    ctx: &AssistContext<'_>,
-) -> Option<()> {
+pub(crate) fn desugar_async_into_impl_future(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let async_token = ctx.find_token_syntax_at_offset(SyntaxKind::ASYNC_KW)?;
     let function = async_token.parent().and_then(ast::Fn::cast)?;
-
     let rparen = function.param_list()?.r_paren_token()?;
     let return_type = match function.ret_type() {
         // unable to get a `ty` makes the action inapplicable
         // No type means `-> ()`
         None => None,
     };
-
     let scope = ctx.sema.scope(function.syntax())?;
     let module = scope.module();
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(module.krate()));
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
     let future_trait = FamousDefs(&ctx.sema, scope.krate()).core_future_Future()?;
     let trait_path = module.find_path(ctx.db(), ModuleDef::Trait(future_trait), cfg)?;
     let edition = scope.krate().edition(ctx.db());
     let trait_path = trait_path.display(ctx.db(), edition);
-
     acc.add(
         AssistId::refactor_rewrite("desugar_async_into_impl_future"),
         "Convert async into `impl Future`",
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn sugar_with_use() {
         check_assist(
     }
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     "#,
         );
     }
-
     #[test]
     fn desugar_with_use() {
         check_assist(
     }
     "#,
         );
-
         check_assist(
             desugar_async_into_impl_future,
             r#"
     }
     "#,
         );
-
         check_assist(
             desugar_async_into_impl_future,
             r#"
     }
     "#,
         );
-
         check_assist(
             desugar_async_into_impl_future,
             r#"
     "#,
         );
     }
-
     #[test]
     fn sugar_without_use() {
         check_assist(
     }
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     "#,
         );
     }
-
     #[test]
     fn desugar_without_use() {
         check_assist(
     }
     "#,
         );
-
         check_assist(
             desugar_async_into_impl_future,
             r#"
     "#,
         );
     }
-
     #[test]
     fn not_applicable() {
         check_assist_not_applicable(
     }
     "#,
         );
-
         check_assist_not_applicable(
             sugar_impl_future_into_async,
             r#"
     }
     "#,
         );
-
         check_assist_not_applicable(
             sugar_impl_future_into_async,
             r#"
     }
     "#,
         );
-
         check_assist_not_applicable(
             desugar_async_into_impl_future,
             r#"
     "#,
         );
     }
-
     #[test]
     fn sugar_definition_with_use() {
         check_assist(
     async fn foo();
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     "#,
         );
     }
-
     #[test]
     fn sugar_definition_without_use() {
         check_assist(
     async fn foo();
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     "#,
         );
     }
-
     #[test]
     fn sugar_more_types() {
         check_assist(
     async fn foo();
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     async fn foo() -> usize;
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     async fn foo() -> (usize);
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     async fn foo() -> (usize, usize);
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     "#,
         );
     }
-
     #[test]
     fn sugar_with_modifiers() {
         check_assist_not_applicable(
     const fn foo() -> impl core::future::F$0uture<Output = ()>;
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
             pub(crate) async unsafe fn foo() -> usize;
         "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     async unsafe fn foo();
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     async unsafe extern "C" fn foo();
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"
     async fn foo<T>() -> T;
     "#,
         );
-
         check_assist(
             sugar_impl_future_into_async,
             r#"