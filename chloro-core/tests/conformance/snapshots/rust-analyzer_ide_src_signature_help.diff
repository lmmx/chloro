COMPARISON DIFF
============================================================

Original size: 62523 bytes
Chloro size:   62172 bytes
Rustfmt size:  62523 bytes

✗ Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 }
 
 /// Computes parameter information for the given position.
-pub(crate) fn signature_help(
-    db: &RootDatabase,
-    FilePosition { file_id, offset }: FilePosition,
-) -> Option<SignatureHelp> {
+pub(crate) fn signature_help(db: &RootDatabase, FilePosition { file_id, offset }: FilePosition) -> Option<SignatureHelp> {
     let sema = Semantics::new(db);
     let file = sema.parse_guess_edition(file_id);
     let file = file.syntax();
     let edition =
         sema.attach_first_edition(file_id).map(|it| it.edition(db)).unwrap_or(Edition::CURRENT);
     let display_target = sema.first_crate(file_id)?.to_display_target(db);
-
     for node in token.parent_ancestors() {
         match_ast! {
             match node {
             break;
         }
     }
-
     None
 }
 
-fn signature_help_for_call(
-    sema: &Semantics<'_, RootDatabase>,
-    arg_list: ast::ArgList,
-    token: SyntaxToken,
-    edition: Edition,
-    display_target: DisplayTarget,
-) -> Option<SignatureHelp> {
+fn signature_help_for_call(sema: &Semantics<'_, RootDatabase>, arg_list: ast::ArgList, token: SyntaxToken, edition: Edition, display_target: DisplayTarget) -> Option<SignatureHelp> {
     let (callable, active_parameter) =
         callable_for_arg_list(sema, arg_list, token.text_range().start())?;
-
     let mut res =
         SignatureHelp { doc: None, signature: String::new(), parameters: vec![], active_parameter };
-
     let db = sema.db;
     let mut fn_params = None;
     match callable.kind() {
             None => format_to!(res.signature, "impl {fn_trait}"),
         },
     }
-
     res.signature.push('(');
     {
         if let Some((self_param, _)) = callable.receiver_param(db) {
         }
     }
     res.signature.push(')');
-
     let mut render = |ret_type: hir::Type<'_>| {
         if !ret_type.is_unit() {
             format_to!(res.signature, " -> {}", ret_type.display(db, display_target));
     Some(res)
 }
 
-fn signature_help_for_generics(
-    sema: &Semantics<'_, RootDatabase>,
-    arg_list: ast::GenericArgList,
-    token: SyntaxToken,
-    edition: Edition,
-    display_target: DisplayTarget,
-) -> Option<SignatureHelp> {
+fn signature_help_for_generics(sema: &Semantics<'_, RootDatabase>, arg_list: ast::GenericArgList, token: SyntaxToken, edition: Edition, display_target: DisplayTarget) -> Option<SignatureHelp> {
     let (generics_def, mut active_parameter, first_arg_is_non_lifetime, variant) =
         generic_def_for_node(sema, &arg_list, &token)?;
     let mut res = SignatureHelp {
         parameters: vec![],
         active_parameter: None,
     };
-
     let db = sema.db;
     match generics_def {
         hir::GenericDef::Function(it) => {
             return None;
         }
     }
-
     let params = generics_def.params(sema.db);
     let num_lifetime_params =
         params.iter().take_while(|param| matches!(param, GenericParam::LifetimeParam(_))).count();
         active_parameter += num_lifetime_params;
     }
     res.active_parameter = Some(active_parameter);
-
     res.signature.push('<');
     let mut buf = String::new();
     for param in params {
         add_assoc_type_bindings(db, &mut res, tr, arg_list, edition);
     }
     res.signature.push('>');
-
     Some(res)
 }
 
-fn add_assoc_type_bindings(
-    db: &RootDatabase,
-    res: &mut SignatureHelp,
-    tr: Trait,
-    args: ast::GenericArgList,
-    edition: Edition,
-) {
+fn add_assoc_type_bindings(db: &RootDatabase, res: &mut SignatureHelp, tr: Trait, args: ast::GenericArgList, edition: Edition) {
     if args.syntax().ancestors().find_map(ast::TypeBound::cast).is_none() {
         // Assoc type bindings are only valid in type bound position.
         return;
     }
-
     let present_bindings = args
         .generic_args()
         .filter_map(|arg| match arg {
             _ => None,
         })
         .collect::<BTreeSet<_>>();
-
     let mut buf = String::new();
     for binding in &present_bindings {
         buf.clear();
         format_to!(buf, "{} = …", binding);
         res.push_generic_param(&buf);
     }
-
     for item in tr.items_with_supertraits(db) {
         if let AssocItem::TypeAlias(ty) = item {
             let name = ty.name(db).display_no_db(edition).to_smolstr();
     }
 }
 
-fn signature_help_for_record_lit(
-    sema: &Semantics<'_, RootDatabase>,
-    record: ast::RecordExpr,
-    token: SyntaxToken,
-    edition: Edition,
-    display_target: DisplayTarget,
-) -> Option<SignatureHelp> {
+fn signature_help_for_record_lit(sema: &Semantics<'_, RootDatabase>, record: ast::RecordExpr, token: SyntaxToken, edition: Edition, display_target: DisplayTarget) -> Option<SignatureHelp> {
     signature_help_for_record_(
         sema,
         record.record_expr_field_list()?.syntax().children_with_tokens(),
     )
 }
 
-fn signature_help_for_record_pat(
-    sema: &Semantics<'_, RootDatabase>,
-    record: ast::RecordPat,
-    token: SyntaxToken,
-    edition: Edition,
-    display_target: DisplayTarget,
-) -> Option<SignatureHelp> {
+fn signature_help_for_record_pat(sema: &Semantics<'_, RootDatabase>, record: ast::RecordPat, token: SyntaxToken, edition: Edition, display_target: DisplayTarget) -> Option<SignatureHelp> {
     signature_help_for_record_(
         sema,
         record.record_pat_field_list()?.syntax().children_with_tokens(),
     )
 }
 
-fn signature_help_for_tuple_struct_pat(
-    sema: &Semantics<'_, RootDatabase>,
-    pat: ast::TupleStructPat,
-    token: SyntaxToken,
-    edition: Edition,
-    display_target: DisplayTarget,
-) -> Option<SignatureHelp> {
+fn signature_help_for_tuple_struct_pat(sema: &Semantics<'_, RootDatabase>, pat: ast::TupleStructPat, token: SyntaxToken, edition: Edition, display_target: DisplayTarget) -> Option<SignatureHelp> {
     let path = pat.path()?;
     let path_res = sema.resolve_path(&path)?;
     let mut res = SignatureHelp {
         active_parameter: None,
     };
     let db = sema.db;
-
     let fields: Vec<_> = if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {
         let en = variant.parent_enum(db);
 
     ))
 }
 
-fn signature_help_for_tuple_pat(
-    sema: &Semantics<'_, RootDatabase>,
-    pat: ast::TuplePat,
-    token: SyntaxToken,
-    display_target: DisplayTarget,
-) -> Option<SignatureHelp> {
+fn signature_help_for_tuple_pat(sema: &Semantics<'_, RootDatabase>, pat: ast::TuplePat, token: SyntaxToken, display_target: DisplayTarget) -> Option<SignatureHelp> {
     let db = sema.db;
     let field_pats = pat.fields();
     let pat = pat.into();
     let ty = sema.type_of_pat(&pat)?;
     let fields = ty.original.tuple_fields(db);
-
     Some(signature_help_for_tuple_pat_ish(
         db,
         SignatureHelp {
     ))
 }
 
-fn signature_help_for_tuple_expr(
-    sema: &Semantics<'_, RootDatabase>,
-    expr: ast::TupleExpr,
-    token: SyntaxToken,
-    display_target: DisplayTarget,
-) -> Option<SignatureHelp> {
+fn signature_help_for_tuple_expr(sema: &Semantics<'_, RootDatabase>, expr: ast::TupleExpr, token: SyntaxToken, display_target: DisplayTarget) -> Option<SignatureHelp> {
     let active_parameter = Some(
         expr.syntax()
             .children_with_tokens()
             .take_while(|t| t.text_range().start() <= token.text_range().start())
             .count(),
     );
-
     let db = sema.db;
     let mut res = SignatureHelp {
         doc: None,
     Some(res)
 }
 
-fn signature_help_for_record_<'db>(
-    sema: &Semantics<'db, RootDatabase>,
-    field_list_children: SyntaxElementChildren,
-    path: &ast::Path,
-    fields2: impl Iterator<Item = (hir::Field, hir::Type<'db>)>,
-    token: SyntaxToken,
-    edition: Edition,
-    display_target: DisplayTarget,
-) -> Option<SignatureHelp> {
+fn signature_help_for_record_<'db>(sema: &Semantics<'db, RootDatabase>, field_list_children: SyntaxElementChildren, path: &ast::Path, fields2: impl Iterator<Item = (hir::Field, hir::Type<'db>)>, token: SyntaxToken, edition: Edition, display_target: DisplayTarget) -> Option<SignatureHelp> {
     let active_parameter = field_list_children
         .filter_map(NodeOrToken::into_token)
         .filter(|t| t.kind() == T![,])
         .take_while(|t| t.text_range().start() <= token.text_range().start())
         .count();
-
     let mut res = SignatureHelp {
         doc: None,
         signature: String::new(),
         parameters: vec![],
         active_parameter: Some(active_parameter),
     };
-
     let fields;
-
     let db = sema.db;
     let path_res = sema.resolve_path(path)?;
     if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {
             _ => return None,
         }
     }
-
     let mut fields =
         fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();
     let mut buf = String::new();
     Some(res)
 }
 
-fn signature_help_for_tuple_pat_ish<'db>(
-    db: &'db RootDatabase,
-    mut res: SignatureHelp,
-    pat: &SyntaxNode,
-    token: SyntaxToken,
-    mut field_pats: AstChildren<ast::Pat>,
-    fields: impl ExactSizeIterator<Item = hir::Type<'db>>,
-    display_target: DisplayTarget,
-) -> SignatureHelp {
+fn signature_help_for_tuple_pat_ish<'db>(db: &'db RootDatabase, mut res: SignatureHelp, pat: &SyntaxNode, token: SyntaxToken, mut field_pats: AstChildren<ast::Pat>, fields: impl ExactSizeIterator<Item = hir::Type<'db>>, display_target: DisplayTarget) -> SignatureHelp {
     let rest_pat = field_pats.find(|it| matches!(it, ast::Pat::RestPat(_)));
     let is_left_of_rest_pat =
         rest_pat.is_none_or(|it| token.text_range().start() < it.syntax().text_range().end());
-
     let commas = pat
         .children_with_tokens()
         .filter_map(NodeOrToken::into_token)
         .filter(|t| t.kind() == T![,]);
-
     res.active_parameter = {
         Some(if is_left_of_rest_pat {
             commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()
             fields.len().saturating_sub(1).saturating_sub(n_commas)
         })
     };
-
     let mut buf = String::new();
     for ty in fields {
         format_to!(buf, "{}", ty.display_truncated(db, Some(20), display_target));
     res.signature.push(')');
     res
 }
+
 #[cfg(test)]
 mod tests {
-
     use expect_test::{Expect, expect};
     use ide_db::FilePosition;
     use stdx::format_to;
     use test_fixture::ChangeFixture;
-
     use crate::RootDatabase;
-
     /// Creates analysis from a multi-file fixture, returns positions marked with $0.
-    pub(crate) fn position(
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-    ) -> (RootDatabase, FilePosition) {
+    pub(crate) fn position(#[rust_analyzer::rust_fixture] ra_fixture: &str) -> (RootDatabase, FilePosition) {
         let mut database = RootDatabase::default();
         let change_fixture = ChangeFixture::parse(&database, ra_fixture);
         database.apply_change(change_fixture.change);
         let position = FilePosition { file_id: file_id.file_id(&database), offset };
         (database, position)
     }
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (db, position) = position(ra_fixture);
         };
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn test_fn_signature_two_args() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_empty() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_first_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_no_params() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_generic_method() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg_as_assoc_fn() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_impl() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_from_actix() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_bad_offset() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn outside_of_arg_list() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_tuple_structs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat_rest() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn generic_struct() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_enum_variants() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn cant_call_struct_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn cant_call_enum_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn fn_signature_for_call_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_signature_for_method_call_defined_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_lambdas() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_fn_def_over_reference() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_ptr() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_impl() {
         check(
             expect![""],
         );
     }
-
     #[test]
     fn call_info_for_unclosed_call() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn test_multiline_argument() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_on_variant() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_lots_of_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_trait_ufcs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_param_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_kinds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait_assoc_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_supertrait_assoc() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn no_assoc_types_outside_type_bounds() {
         check(
         "#]],
         );
     }
-
     #[test]
     fn impl_trait() {
         // FIXME: Substitute type vars in impl trait (`U` -> `i8`)
             "#]],
         );
     }
-
     #[test]
     fn fully_qualified_syntax() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn help_for_generic_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn regression_13579() {
         // FIXME(next-solver): There should be signature help available here.
             expect![""],
         );
     }
-
     #[test]
     fn record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_nonexistent_field() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_variant_record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_in_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_variant_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_arg_with_default() {
         check(
                          ^^^^^^
             "#]],
         );
-
         check(
             r#"
 //- minicore: sized, fn
             "#]],
         );
     }
-
     #[test]
     fn test_async_function() {
         check(