COMPARISON DIFF
============================================================

Original size: 111676 bytes
Chloro size:   110412 bytes
Rustfmt size:  111676 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     },
     traits::FnTrait,
 };
-
 use super::{
     BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch,
     cast::CastCheck, find_breakable,
 }
 
 impl<'db> InferenceContext<'_, 'db> {
-    pub(crate) fn infer_expr(
-        &mut self,
-        tgt_expr: ExprId,
-        expected: &Expectation<'db>,
-        is_read: ExprIsRead,
-    ) -> Ty<'db> {
+    pub(crate) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation<'db>, is_read: ExprIsRead) -> Ty<'db> {
         let ty = self.infer_expr_inner(tgt_expr, expected, is_read);
         if let Some(expected_ty) = expected.only_has_type(&mut self.table) {
             let could_unify = self.unify(ty, expected_ty);
         ty
     }
 
-    pub(crate) fn infer_expr_no_expect(
-        &mut self,
-        tgt_expr: ExprId,
-        is_read: ExprIsRead,
-    ) -> Ty<'db> {
+    pub(crate) fn infer_expr_no_expect(&mut self, tgt_expr: ExprId, is_read: ExprIsRead) -> Ty<'db> {
         self.infer_expr_inner(tgt_expr, &Expectation::None, is_read)
     }
 
     /// Infer type of expression with possibly implicit coerce to the expected type.
     /// Return the type after possible coercion.
-    pub(super) fn infer_expr_coerce(
-        &mut self,
-        expr: ExprId,
-        expected: &Expectation<'db>,
-        is_read: ExprIsRead,
-    ) -> Ty<'db> {
+    pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation<'db>, is_read: ExprIsRead) -> Ty<'db> {
         let ty = self.infer_expr_inner(expr, expected, is_read);
         if let Some(target) = expected.only_has_type(&mut self.table) {
             let coerce_never = if self.expr_guaranteed_to_constitute_read_for_never(expr, is_read) {
     /// expression and the *parent* expression is the scrutinee of a match or
     /// the pointee of an `&` addr-of expression, since both of those parent
     /// expressions take a *place* and not a value.
-    pub(super) fn expr_guaranteed_to_constitute_read_for_never(
-        &mut self,
-        expr: ExprId,
-        is_read: ExprIsRead,
-    ) -> bool {
+    pub(super) fn expr_guaranteed_to_constitute_read_for_never(&mut self, expr: ExprId, is_read: ExprIsRead) -> bool {
         // rustc does the place expr check first, but since we are feeding
         // readness of the `expr` as a given value, we just can short-circuit
         // the place expr check if it's true(see codes and comments below)
         if is_read == ExprIsRead::Yes {
             return true;
         }
-
         // We only care about place exprs. Anything else returns an immediate
         // which would constitute a read. We don't care about distinguishing
         // "syntactic" place exprs since if the base of a field projection is
         if !self.is_syntactic_place_expr(expr) {
             return true;
         }
-
         // rustc queries parent hir node of `expr` here and determine whether
         // the current `expr` is read of value per its parent.
         // But since we don't have hir node, we cannot follow such "bottom-up"
         }
     }
 
-    fn infer_expr_coerce_never(
-        &mut self,
-        expr: ExprId,
-        expected: &Expectation<'db>,
-        is_read: ExprIsRead,
-    ) -> Ty<'db> {
+    fn infer_expr_coerce_never(&mut self, expr: ExprId, expected: &Expectation<'db>, is_read: ExprIsRead) -> Ty<'db> {
         let ty = self.infer_expr_inner(expr, expected, is_read);
         // While we don't allow *arbitrary* coercions here, we *do* allow
         // coercions from `!` to `expected`.
     }
 
     #[tracing::instrument(level = "debug", skip(self, is_read), ret)]
-    fn infer_expr_inner(
-        &mut self,
-        tgt_expr: ExprId,
-        expected: &Expectation<'db>,
-        is_read: ExprIsRead,
-    ) -> Ty<'db> {
+    fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation<'db>, is_read: ExprIsRead) -> Ty<'db> {
         self.db.unwind_if_revision_cancelled();
-
         let expr = &self.body[tgt_expr];
         tracing::trace!(?expr);
         let ty = match expr {
         ty
     }
 
-    fn infer_async_block(
-        &mut self,
-        tgt_expr: ExprId,
-        id: &Option<BlockId>,
-        statements: &[Statement],
-        tail: &Option<ExprId>,
-    ) -> Ty<'db> {
+    fn infer_async_block(&mut self, tgt_expr: ExprId, id: &Option<BlockId>, statements: &[Statement], tail: &Option<ExprId>) -> Ty<'db> {
         let ret_ty = self.table.next_ty_var();
         let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);
         let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty);
         let prev_ret_coercion = self.return_coercion.replace(CoerceMany::new(ret_ty));
-
         // FIXME: We should handle async blocks like we handle closures
         let expected = &Expectation::has_type(ret_ty);
         let (_, inner_ty) = self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {
                 ty
             }
         });
-
         self.diverges = prev_diverges;
         self.return_ty = prev_ret_ty;
         self.return_coercion = prev_ret_coercion;
-
         self.lower_async_block_type_impl_trait(inner_ty, tgt_expr)
     }
 
-    pub(crate) fn lower_async_block_type_impl_trait(
-        &mut self,
-        inner_ty: Ty<'db>,
-        tgt_expr: ExprId,
-    ) -> Ty<'db> {
+    pub(crate) fn lower_async_block_type_impl_trait(&mut self, inner_ty: Ty<'db>, tgt_expr: ExprId) -> Ty<'db> {
         let coroutine_id = InternedCoroutine(self.owner, tgt_expr);
         let coroutine_id = self.db.intern_coroutine(coroutine_id).into();
         let parent_args = GenericArgs::identity_for_item(self.interner(), self.generic_def.into());
         )
     }
 
-    pub(crate) fn write_fn_trait_method_resolution(
-        &mut self,
-        fn_x: FnTrait,
-        derefed_callee: Ty<'db>,
-        adjustments: &mut Vec<Adjustment<'db>>,
-        callee_ty: Ty<'db>,
-        params: &[Ty<'db>],
-        tgt_expr: ExprId,
-    ) {
+    pub(crate) fn write_fn_trait_method_resolution(&mut self, fn_x: FnTrait, derefed_callee: Ty<'db>, adjustments: &mut Vec<Adjustment<'db>>, callee_ty: Ty<'db>, params: &[Ty<'db>], tgt_expr: ExprId) {
         match fn_x {
             FnTrait::FnOnce | FnTrait::AsyncFnOnce => (),
             FnTrait::FnMut | FnTrait::AsyncFnMut => {
             Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st,
             _ => self.table.next_ty_var(),
         };
-
         let krate = self.resolver.krate();
-
         let expected = Expectation::has_type(elem_ty);
         let (elem_ty, len) = match array {
             Array::ElementList { elements, .. } if elements.is_empty() => {
                 self.infer_expr_no_expect(expr, ExprIsRead::Yes);
             }
         }
-
         self.types.never
     }
 
         }
     }
 
-    fn infer_overloadable_binop(
-        &mut self,
-        lhs: ExprId,
-        op: BinaryOp,
-        rhs: ExprId,
-        tgt_expr: ExprId,
-    ) -> Ty<'db> {
+    fn infer_overloadable_binop(&mut self, lhs: ExprId, op: BinaryOp, rhs: ExprId, tgt_expr: ExprId) -> Ty<'db> {
         let lhs_expectation = Expectation::none();
         let is_read = if matches!(op, BinaryOp::Assignment { .. }) {
             ExprIsRead::Yes
         };
         let lhs_ty = self.infer_expr(lhs, &lhs_expectation, is_read);
         let rhs_ty = self.table.next_ty_var();
-
         let trait_func = lang_items_for_bin_op(op).and_then(|(name, lang_item)| {
             let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;
             let func = trait_id.trait_items(self.db).method_by_name(&name)?;
                 return ret_ty;
             }
         };
-
         // HACK: We can use this substitution for the function because the function itself doesn't
         // have its own generic parameters.
         let args = GenericArgs::new_from_iter(self.interner(), [lhs_ty.into(), rhs_ty.into()]);
-
         self.write_method_resolution(tgt_expr, func, args);
-
         let method_ty = self.db.value_ty(func.into()).unwrap().instantiate(self.interner(), args);
         self.register_obligations_for_call(method_ty);
-
         self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty), ExprIsRead::Yes);
-
         let ret_ty = match method_ty.callable_sig(self.interner()) {
             Some(sig) => {
                 let sig = sig.skip_binder();
             }
             None => self.err_ty(),
         };
-
         let ret_ty = self.process_remote_user_written_ty(ret_ty);
-
         if self.is_builtin_binop(lhs_ty, rhs_ty, op) {
             // use knowledge of built-in binary ops, which can sometimes help inference
             let builtin_ret = self.enforce_builtin_binop_types(lhs_ty, rhs_ty, op);
         }
     }
 
-    fn infer_block(
-        &mut self,
-        expr: ExprId,
-        block_id: Option<BlockId>,
-        statements: &[Statement],
-        tail: Option<ExprId>,
-        label: Option<LabelId>,
-        expected: &Expectation<'db>,
-    ) -> Ty<'db> {
+    fn infer_block(&mut self, expr: ExprId, block_id: Option<BlockId>, statements: &[Statement], tail: Option<ExprId>, label: Option<LabelId>, expected: &Expectation<'db>) -> Ty<'db> {
         let coerce_ty = expected.coercion_target_type(&mut self.table);
         let g = self.resolver.update_to_inner_scope(self.db, self.owner, expr);
         let prev_state = block_id.map(|block_id| {
             let prev_block = self.table.infer_ctxt.interner.block.replace(block_id);
             (prev_env, prev_block)
         });
-
         let (break_ty, ty) =
             self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty), label, |this| {
                 for stmt in statements {
             self.table.trait_env = prev_env;
             self.table.infer_ctxt.interner.block = prev_block;
         }
-
         break_ty.unwrap_or(ty)
     }
 
-    fn lookup_field(
-        &mut self,
-        receiver_ty: Ty<'db>,
-        name: &Name,
-    ) -> Option<(Ty<'db>, Either<FieldId, TupleFieldId>, Vec<Adjustment<'db>>, bool)> {
+    fn lookup_field(&mut self, receiver_ty: Ty<'db>, name: &Name) -> Option<(Ty<'db>, Either<FieldId, TupleFieldId>, Vec<Adjustment<'db>>, bool)> {
         let interner = self.interner();
         let mut autoderef = self.table.autoderef(receiver_ty);
         let mut private_field = None;
                 .instantiate(interner, parameters);
             Some((Either::Left(field_id), ty))
         });
-
         Some(match res {
             Some((field_id, ty)) => {
                 let adjustments = autoderef.adjust_steps();
         })
     }
 
-    fn infer_field_access(
-        &mut self,
-        tgt_expr: ExprId,
-        receiver: ExprId,
-        name: &Name,
-        expected: &Expectation<'db>,
-    ) -> Ty<'db> {
+    fn infer_field_access(&mut self, tgt_expr: ExprId, receiver: ExprId, name: &Name, expected: &Expectation<'db>) -> Ty<'db> {
         // Field projections don't constitute reads.
         let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none(), ExprIsRead::No);
-
         if name.is_missing() {
             // Bail out early, don't even try to look up field. Also, we don't issue an unresolved
             // field diagnostic because this is a syntax error rather than a semantic error.
             return self.err_ty();
         }
-
         match self.lookup_field(receiver_ty, name) {
             Some((ty, field_id, adjustments, is_public)) => {
                 self.write_expr_adj(receiver, adjustments.into_boxed_slice());
         }
     }
 
-    fn infer_call(
-        &mut self,
-        tgt_expr: ExprId,
-        callee: ExprId,
-        args: &[ExprId],
-        expected: &Expectation<'db>,
-    ) -> Ty<'db> {
+    fn infer_call(&mut self, tgt_expr: ExprId, callee: ExprId, args: &[ExprId], expected: &Expectation<'db>) -> Ty<'db> {
         let callee_ty = self.infer_expr(callee, &Expectation::none(), ExprIsRead::Yes);
         let interner = self.interner();
         let mut derefs = self.table.autoderef(callee_ty);
         )
     }
 
-    fn check_call(
-        &mut self,
-        tgt_expr: ExprId,
-        args: &[ExprId],
-        callee_ty: Ty<'db>,
-        param_tys: &[Ty<'db>],
-        ret_ty: Ty<'db>,
-        indices_to_skip: &[u32],
-        is_varargs: bool,
-        expected: &Expectation<'db>,
-    ) -> Ty<'db> {
+    fn check_call(&mut self, tgt_expr: ExprId, args: &[ExprId], callee_ty: Ty<'db>, param_tys: &[Ty<'db>], ret_ty: Ty<'db>, indices_to_skip: &[u32], is_varargs: bool, expected: &Expectation<'db>) -> Ty<'db> {
         self.register_obligations_for_call(callee_ty);
-
         self.check_call_arguments(
             tgt_expr,
             param_tys,
         self.table.normalize_associated_types_in(ret_ty)
     }
 
-    fn infer_method_call(
-        &mut self,
-        tgt_expr: ExprId,
-        receiver: ExprId,
-        args: &[ExprId],
-        method_name: &Name,
-        generic_args: Option<&HirGenericArgs>,
-        expected: &Expectation<'db>,
-    ) -> Ty<'db> {
+    fn infer_method_call(&mut self, tgt_expr: ExprId, receiver: ExprId, args: &[ExprId], method_name: &Name, generic_args: Option<&HirGenericArgs>, expected: &Expectation<'db>) -> Ty<'db> {
         let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none(), ExprIsRead::Yes);
         let receiver_ty = self.table.try_structurally_resolve_type(receiver_ty);
-
         if matches!(receiver_ty.kind(), TyKind::Error(_) | TyKind::Infer(InferTy::TyVar(_))) {
             // Don't probe on error type, or on a fully unresolved infer var.
             // FIXME: Emit an error if we're probing on an infer var (type annotations needed).
             }
             return receiver_ty;
         }
-
         let canonicalized_receiver = self.canonicalize(receiver_ty);
-
         let resolved = method_resolution::lookup_method(
             &canonicalized_receiver,
             &mut self.table,
         }
     }
 
-    fn check_method_call(
-        &mut self,
-        tgt_expr: ExprId,
-        args: &[ExprId],
-        method_ty: Ty<'db>,
-        receiver_ty: Ty<'db>,
-        expected: &Expectation<'db>,
-    ) -> Ty<'db> {
+    fn check_method_call(&mut self, tgt_expr: ExprId, args: &[ExprId], method_ty: Ty<'db>, receiver_ty: Ty<'db>, expected: &Expectation<'db>) -> Ty<'db> {
         self.register_obligations_for_call(method_ty);
         let ((formal_receiver_ty, param_tys), ret_ty, is_varargs) =
             match method_ty.callable_sig(self.interner()) {
                 }
             };
         self.table.unify(formal_receiver_ty, receiver_ty);
-
         self.check_call_arguments(tgt_expr, &param_tys, ret_ty, expected, args, &[], is_varargs);
         self.table.normalize_associated_types_in(ret_ty)
     }
 
     /// Generic function that factors out common logic from function calls,
     /// method calls and overloaded operators.
-    pub(in super::super) fn check_call_arguments(
-        &mut self,
-        call_expr: ExprId,
-        // Types (as defined in the *signature* of the target function)
-        formal_input_tys: &[Ty<'db>],
-        formal_output: Ty<'db>,
-        // Expected output from the parent expression or statement
-        expectation: &Expectation<'db>,
-        // The expressions for each provided argument
-        provided_args: &[ExprId],
-        skip_indices: &[u32],
-        // Whether the function is variadic, for example when imported from C
-        c_variadic: bool,
-    ) {
+    pub(in super::super) fn check_call_arguments(&mut self, call_expr: ExprId, formal_input_tys: &[Ty<'db>], formal_output: Ty<'db>, expectation: &Expectation<'db>, provided_args: &[ExprId], skip_indices: &[u32], c_variadic: bool) {
         // First, let's unify the formal method signature with the expectation eagerly.
         // We use this to guide coercion inference; it's output is "fudged" which means
         // any remaining type variables are assigned to new, unrelated variables. This
                     .ok()
             })
             .unwrap_or_default();
-
         // If there are no external expectations at the call site, just use the types from the function defn
         let expected_input_tys = if let Some(expected_input_tys) = &expected_input_tys {
             assert_eq!(expected_input_tys.len(), formal_input_tys.len());
         } else {
             formal_input_tys
         };
-
         let minimum_input_count = expected_input_tys.len();
         let provided_arg_count = provided_args.len() - skip_indices.len();
-
         // Keep track of whether we *could possibly* be satisfied, i.e. whether we're on the happy path
         // if the wrong number of arguments were supplied, we CAN'T be satisfied,
         // and if we're c_variadic, the supplied arguments must be >= the minimum count from the function
         } else {
             provided_arg_count == minimum_input_count
         };
-
         if !args_count_matches {
             self.push_diagnostic(InferenceDiagnostic::MismatchedArgCount {
                 call_expr,
                 found: provided_args.len(),
             });
         }
-
         // We introduce a helper function to demand that a given argument satisfy a given input
         // This is more complicated than just checking type equality, as arguments could be coerced
         // This version writes those types back so further type checking uses the narrowed types
                 Err(err) => Err((Some(err), coerced_ty, checked_ty)),
             }
         };
-
         // Check the arguments.
         // We do this in a pretty awful way: first we type-check any arguments
         // that are not closures, then we type-check the closures. This is so
                 }
             }
         }
-
         if !args_count_matches {}
     }
 
-    fn substs_for_method_call(
-        &mut self,
-        expr: ExprId,
-        def: GenericDefId,
-        generic_args: Option<&HirGenericArgs>,
-    ) -> GenericArgs<'db> {
+    fn substs_for_method_call(&mut self, expr: ExprId, def: GenericDefId, generic_args: Option<&HirGenericArgs>) -> GenericArgs<'db> {
         struct LowererCtx<'a, 'b, 'db> {
             ctx: &'a mut InferenceContext<'b, 'db>,
             expr: ExprId,
         }
-
         impl<'db> GenericArgsLowerer<'db> for LowererCtx<'_, '_, 'db> {
             fn report_len_mismatch(
                 &mut self,
                 unreachable!("we set `LifetimeElisionKind::Infer`")
             }
         }
-
         substs_from_args_and_bindings(
             self.db,
             self.body,
             }
             _ => return Default::default(),
         };
-
         let data = self.db.function_signature(func);
         let Some(legacy_const_generics_indices) = &data.legacy_const_generics_indices else {
             return Default::default();
         };
-
         // only use legacy const generics if the param count matches with them
         if data.params.len() + legacy_const_generics_indices.len() != args.len() {
             if args.len() <= data.params.len() {
                 return indices;
             }
         }
-
         // check legacy const parameters
         for arg_idx in legacy_const_generics_indices.iter().copied() {
             if arg_idx >= args.len() as u32 {
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
-
         let (op, is_assign) = match op {
             BinaryOp::Assignment { op: Some(inner) } => (BinaryOp::ArithOp(inner), true),
             _ => (op, false),
         };
-
         let output_ty = match op {
             BinaryOp::LogicOp(_) => {
                 let bool_ = self.types.bool;
 
             BinaryOp::Assignment { .. } => unreachable!("handled above"),
         };
-
         if is_assign { self.types.unit } else { output_ty }
     }
 
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
-
         let op = match op {
             BinaryOp::Assignment { op: Some(inner) } => BinaryOp::ArithOp(inner),
             _ => op,
         };
-
         match op {
             BinaryOp::LogicOp(_) => true,
 
         }
     }
 
-    pub(super) fn with_breakable_ctx<T>(
-        &mut self,
-        kind: BreakableKind,
-        ty: Option<Ty<'db>>,
-        label: Option<LabelId>,
-        cb: impl FnOnce(&mut Self) -> T,
-    ) -> (Option<Ty<'db>>, T) {
+    pub(super) fn with_breakable_ctx<T>(&mut self, kind: BreakableKind, ty: Option<Ty<'db>>, label: Option<LabelId>, cb: impl FnOnce(&mut Self) -> T) -> (Option<Ty<'db>>, T) {
         self.breakables.push({
             BreakableContext { kind, may_break: false, coerce: ty.map(CoerceMany::new), label }
         });