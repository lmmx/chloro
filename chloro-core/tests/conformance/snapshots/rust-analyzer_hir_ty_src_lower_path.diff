COMPARISON DIFF
============================================================

Original size: 55742 bytes
Chloro size:   54375 bytes
Rustfmt size:  55742 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
         ProjectionPredicate, Region, TraitRef, Ty,
     },
 };
-
 use super::{
     ImplTraitLoweringMode, TyLoweringContext, associated_type_by_name_including_super_traits,
     const_param_ty_query, ty_query,
     crate::infer::diagnostics::PathDiagnosticCallbackData<'a, 'db>,
 >;
 
-// We cannot use `&mut dyn FnMut()` because of lifetime issues, and we don't want to use `Box<dyn FnMut()>`
-// because of the allocation, so we create a lifetime-less callback, tailored for our needs.
 pub(crate) struct PathDiagnosticCallback<'a, 'db> {
     pub(crate) data: CallbackData<'a, 'db>,
-    pub(crate) callback:
-        fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
+    pub(crate) callback: fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
 }
 
 pub(crate) struct PathLoweringContext<'a, 'b, 'db> {
 
 impl<'a, 'b, 'db> PathLoweringContext<'a, 'b, 'db> {
     #[inline]
-    pub(crate) fn new(
-        ctx: &'a mut TyLoweringContext<'db, 'b>,
-        on_diagnostic: PathDiagnosticCallback<'a, 'db>,
-        path: &'a Path,
-    ) -> Self {
+    pub(crate) fn new(ctx: &'a mut TyLoweringContext<'db, 'b>, on_diagnostic: PathDiagnosticCallback<'a, 'db>, path: &'a Path) -> Self {
         let segments = path.segments();
         let first_segment = segments.first().unwrap_or(PathSegment::MISSING);
         Self {
     }
 
     #[inline]
-    fn with_lifetime_elision<T>(
-        &mut self,
-        lifetime_elision: LifetimeElisionKind<'db>,
-        f: impl FnOnce(&mut PathLoweringContext<'_, '_, 'db>) -> T,
-    ) -> T {
+    fn with_lifetime_elision<T>(&mut self, lifetime_elision: LifetimeElisionKind<'db>, f: impl FnOnce(&mut PathLoweringContext<'_, '_, 'db>) -> T) -> T {
         let old_lifetime_elision =
             std::mem::replace(&mut self.ctx.lifetime_elision, lifetime_elision);
         let result = f(self);
         result
     }
 
-    pub(crate) fn lower_ty_relative_path(
-        &mut self,
-        ty: Ty<'db>,
-        // We need the original resolution to lower `Self::AssocTy` correctly
-        res: Option<TypeNs>,
-        infer_args: bool,
-    ) -> (Ty<'db>, Option<TypeNs>) {
+    pub(crate) fn lower_ty_relative_path(&mut self, ty: Ty<'db>, res: Option<TypeNs>, infer_args: bool) -> (Ty<'db>, Option<TypeNs>) {
         let remaining_segments = self.segments.len() - self.current_segment_idx;
         match remaining_segments {
             0 => (ty, res),
         }
     }
 
-    // When calling this, the current segment is the resolved segment (we don't advance it yet).
-    pub(crate) fn lower_partly_resolved_path(
-        &mut self,
-        resolution: TypeNs,
-        infer_args: bool,
-    ) -> (Ty<'db>, Option<TypeNs>) {
+    pub(crate) fn lower_partly_resolved_path(&mut self, resolution: TypeNs, infer_args: bool) -> (Ty<'db>, Option<TypeNs>) {
         let remaining_segments = self.segments.skip(self.current_segment_idx + 1);
         tracing::debug!(?remaining_segments);
         let rem_seg_len = remaining_segments.len();
         tracing::debug!(?rem_seg_len);
-
         let ty = match resolution {
             TypeNs::TraitId(trait_) => {
                 let ty = match remaining_segments.len() {
                 return (Ty::new_error(self.ctx.interner, ErrorGuaranteed), None);
             }
         };
-
         tracing::debug!(?ty);
-
         self.skip_resolved_segment();
         self.lower_ty_relative_path(ty, Some(resolution), infer_args)
     }
                 });
             }
         };
-
         match resolution {
             TypeNs::SelfType(_) => {
                 prohibit_generics_on_resolved(GenericArgsProhibitedReason::SelfTy)
             | TypeNs::TypeAliasId(_)
             | TypeNs::TraitId(_) => {}
         }
-
         true
     }
 
     pub(crate) fn resolve_path_in_type_ns(&mut self) -> Option<(TypeNs, Option<usize>)> {
         let (resolution, remaining_index, _, prefix_info) =
             self.ctx.resolver.resolve_path_in_type_ns_with_prefix_info(self.ctx.db, self.path)?;
-
         let segments = self.segments;
         if segments.is_empty() || matches!(self.path, Path::LangItem(..)) {
             // `segments.is_empty()` can occur with `self`.
             return Some((resolution, remaining_index));
         }
-
         let (module_segments, resolved_segment_idx, enum_segment) = match remaining_index {
             None if prefix_info.enum_variant => {
                 (segments.strip_last_two(), segments.len() - 1, Some(segments.len() - 2))
             None => (segments.strip_last(), segments.len() - 1, None),
             Some(i) => (segments.take(i - 1), i - 1, None),
         };
-
         self.current_segment_idx = resolved_segment_idx;
         self.current_or_prev_segment =
             segments.get(resolved_segment_idx).expect("should have resolved segment");
-
         for (i, mod_segment) in module_segments.iter().enumerate() {
             if mod_segment.args_and_bindings.is_some() {
                 self.on_diagnostic(PathLoweringDiagnostic::GenericArgsProhibited {
                 });
             }
         }
-
         if let Some(enum_segment) = enum_segment
             && segments.get(enum_segment).is_some_and(|it| it.args_and_bindings.is_some())
             && segments.get(enum_segment + 1).is_some_and(|it| it.args_and_bindings.is_some())
                 reason: GenericArgsProhibitedReason::EnumVariant,
             });
         }
-
         if !self.handle_type_ns_resolution(&resolution) {
             return None;
         }
-
         Some((resolution, remaining_index))
     }
 
-    pub(crate) fn resolve_path_in_value_ns(
-        &mut self,
-        hygiene_id: HygieneId,
-    ) -> Option<ResolveValueResult> {
+    pub(crate) fn resolve_path_in_value_ns(&mut self, hygiene_id: HygieneId) -> Option<ResolveValueResult> {
         let (res, prefix_info) = self.ctx.resolver.resolve_path_in_value_ns_with_prefix_info(
             self.ctx.db,
             self.path,
             hygiene_id,
         )?;
-
         let segments = self.segments;
         if segments.is_empty() || matches!(self.path, Path::LangItem(..)) {
             // `segments.is_empty()` can occur with `self`.
             return Some(res);
         }
-
         let (mod_segments, enum_segment, resolved_segment_idx) = match res {
             ResolveValueResult::Partial(_, unresolved_segment, _) => {
                 (segments.take(unresolved_segment - 1), None, unresolved_segment - 1)
             }
             ResolveValueResult::ValueNs(..) => (segments.strip_last(), None, segments.len() - 1),
         };
-
         self.current_segment_idx = resolved_segment_idx;
         self.current_or_prev_segment =
             segments.get(resolved_segment_idx).expect("should have resolved segment");
-
         for (i, mod_segment) in mod_segments.iter().enumerate() {
             if mod_segment.args_and_bindings.is_some() {
                 self.on_diagnostic(PathLoweringDiagnostic::GenericArgsProhibited {
                 });
             }
         }
-
         if let Some(enum_segment) = enum_segment
             && segments.get(enum_segment).is_some_and(|it| it.args_and_bindings.is_some())
             && segments.get(enum_segment + 1).is_some_and(|it| it.args_and_bindings.is_some())
                 reason: GenericArgsProhibitedReason::EnumVariant,
             });
         }
-
         match &res {
             ResolveValueResult::ValueNs(resolution, _) => {
                 let resolved_segment_idx = self.current_segment_u32();
 
     /// Collect generic arguments from a path into a `Substs`. See also
     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.
-    pub(crate) fn substs_from_path(
-        &mut self,
-        // Note that we don't call `db.value_type(resolved)` here,
-        // `ValueTyDefId` is just a convenient way to pass generics and
-        // special-case enum variants
-        resolved: ValueTyDefId,
-        infer_args: bool,
-        lowering_assoc_type_generics: bool,
-    ) -> GenericArgs<'db> {
+    pub(crate) fn substs_from_path(&mut self, resolved: ValueTyDefId, infer_args: bool, lowering_assoc_type_generics: bool) -> GenericArgs<'db> {
         let interner = self.ctx.interner;
         let prev_current_segment_idx = self.current_segment_idx;
         let prev_current_segment = self.current_or_prev_segment;
-
         let generic_def = match resolved {
             ValueTyDefId::FunctionId(it) => it.into(),
             ValueTyDefId::StructId(it) => it.into(),
         result
     }
 
-    pub(crate) fn substs_from_path_segment(
-        &mut self,
-        def: GenericDefId,
-        infer_args: bool,
-        explicit_self_ty: Option<Ty<'db>>,
-        lowering_assoc_type_generics: bool,
-    ) -> GenericArgs<'db> {
+    pub(crate) fn substs_from_path_segment(&mut self, def: GenericDefId, infer_args: bool, explicit_self_ty: Option<Ty<'db>>, lowering_assoc_type_generics: bool) -> GenericArgs<'db> {
         let old_lifetime_elision = self.ctx.lifetime_elision.clone();
-
         if let Some(args) = self.current_or_prev_segment.args_and_bindings
             && args.parenthesized != GenericArgsParentheses::No
         {
             self.ctx.lifetime_elision =
                 LifetimeElisionKind::AnonymousCreateParameter { report_in_path: false };
         }
-
         let result = self.substs_from_args_and_bindings(
             self.current_or_prev_segment.args_and_bindings,
             def,
         result
     }
 
-    pub(super) fn substs_from_args_and_bindings(
-        &mut self,
-        args_and_bindings: Option<&HirGenericArgs>,
-        def: GenericDefId,
-        infer_args: bool,
-        explicit_self_ty: Option<Ty<'db>>,
-        generics_source: PathGenericsSource,
-        lowering_assoc_type_generics: bool,
-        lifetime_elision: LifetimeElisionKind<'db>,
-    ) -> GenericArgs<'db> {
+    pub(super) fn substs_from_args_and_bindings(&mut self, args_and_bindings: Option<&HirGenericArgs>, def: GenericDefId, infer_args: bool, explicit_self_ty: Option<Ty<'db>>, generics_source: PathGenericsSource, lowering_assoc_type_generics: bool, lifetime_elision: LifetimeElisionKind<'db>) -> GenericArgs<'db> {
         struct LowererCtx<'a, 'b, 'c, 'db> {
             ctx: &'a mut PathLoweringContext<'b, 'c, 'db>,
             generics_source: PathGenericsSource,
         }
-
         impl<'db> GenericArgsLowerer<'db> for LowererCtx<'_, '_, '_, 'db> {
             fn report_len_mismatch(
                 &mut self,
                 });
             }
         }
-
         substs_from_args_and_bindings(
             self.ctx.db,
             self.ctx.store,
         )
     }
 
-    pub(crate) fn lower_trait_ref_from_resolved_path(
-        &mut self,
-        resolved: TraitId,
-        explicit_self_ty: Ty<'db>,
-        infer_args: bool,
-    ) -> TraitRef<'db> {
+    pub(crate) fn lower_trait_ref_from_resolved_path(&mut self, resolved: TraitId, explicit_self_ty: Ty<'db>, infer_args: bool) -> TraitRef<'db> {
         let args = self.trait_ref_substs_from_path(resolved, explicit_self_ty, infer_args);
         TraitRef::new_from_args(self.ctx.interner, resolved.into(), args)
     }
 
-    fn trait_ref_substs_from_path(
-        &mut self,
-        resolved: TraitId,
-        explicit_self_ty: Ty<'db>,
-        infer_args: bool,
-    ) -> GenericArgs<'db> {
+    fn trait_ref_substs_from_path(&mut self, resolved: TraitId, explicit_self_ty: Ty<'db>, infer_args: bool) -> GenericArgs<'db> {
         self.substs_from_path_segment(resolved.into(), infer_args, Some(explicit_self_ty), false)
     }
 
-    pub(super) fn assoc_type_bindings_from_type_bound<'c>(
-        mut self,
-        trait_ref: TraitRef<'db>,
-    ) -> Option<impl Iterator<Item = Clause<'db>> + use<'a, 'b, 'c, 'db>> {
+    pub(super) fn assoc_type_bindings_from_type_bound<'c>(mut self, trait_ref: TraitRef<'db>) -> Option<impl Iterator<Item = Clause<'db>> + use<'a, 'b, 'c, 'db>> {
         let interner = self.ctx.interner;
         self.current_or_prev_segment.args_and_bindings.map(|args_and_bindings| {
             args_and_bindings.bindings.iter().enumerate().flat_map(move |(binding_idx, binding)| {
     Path(&'a Path),
 }
 
-pub(crate) trait GenericArgsLowerer<'db> {
-    fn report_elided_lifetimes_in_path(
-        &mut self,
-        def: GenericDefId,
-        expected_count: u32,
-        hard_error: bool,
-    );
-
-    fn report_elision_failure(&mut self, def: GenericDefId, expected_count: u32);
-
-    fn report_missing_lifetime(&mut self, def: GenericDefId, expected_count: u32);
-
-    fn report_len_mismatch(
-        &mut self,
-        def: GenericDefId,
-        provided_count: u32,
-        expected_count: u32,
-        kind: IncorrectGenericsLenKind,
-    );
-
-    fn report_arg_mismatch(&mut self, param_id: GenericParamId, arg_idx: u32, has_self_arg: bool);
-
-    fn provided_kind(
-        &mut self,
-        param_id: GenericParamId,
-        param: GenericParamDataRef<'_>,
-        arg: &HirGenericArg,
-    ) -> GenericArg<'db>;
-
-    fn provided_type_like_const(&mut self, const_ty: Ty<'db>, arg: TypeLikeConst<'_>)
-    -> Const<'db>;
-
-    fn inferred_kind(
-        &mut self,
-        def: GenericDefId,
-        param_id: GenericParamId,
-        param: GenericParamDataRef<'_>,
-        infer_args: bool,
-        preceding_args: &[GenericArg<'db>],
-    ) -> GenericArg<'db>;
-
-    fn parent_arg(&mut self, param_id: GenericParamId) -> GenericArg<'db>;
-}
+fn report_elided_lifetimes_in_path(&mut self, def: GenericDefId, expected_count: u32, hard_error: bool);
+fn report_elision_failure(&mut self, def: GenericDefId, expected_count: u32);
+fn report_missing_lifetime(&mut self, def: GenericDefId, expected_count: u32);
+fn report_len_mismatch(&mut self, def: GenericDefId, provided_count: u32, expected_count: u32, kind: IncorrectGenericsLenKind);
+fn report_arg_mismatch(&mut self, param_id: GenericParamId, arg_idx: u32, has_self_arg: bool);
+fn provided_kind(&mut self, param_id: GenericParamId, param: GenericParamDataRef<'_>, arg: &HirGenericArg) -> GenericArg<'db>;
+fn provided_type_like_const(&mut self, const_ty: Ty<'db>, arg: TypeLikeConst<'_>) -> Const<'db>;
+fn inferred_kind(&mut self, def: GenericDefId, param_id: GenericParamId, param: GenericParamDataRef<'_>, infer_args: bool, preceding_args: &[GenericArg<'db>]) -> GenericArg<'db>;
+fn parent_arg(&mut self, param_id: GenericParamId) -> GenericArg<'db>;
 
 /// Returns true if there was an error.
-fn check_generic_args_len<'db>(
-    args_and_bindings: Option<&HirGenericArgs>,
-    def: GenericDefId,
-    def_generics: &Generics,
-    infer_args: bool,
-    lifetime_elision: &LifetimeElisionKind<'db>,
-    lowering_assoc_type_generics: bool,
-    ctx: &mut impl GenericArgsLowerer<'db>,
-) -> bool {
+fn check_generic_args_len<'db>(args_and_bindings: Option<&HirGenericArgs>, def: GenericDefId, def_generics: &Generics, infer_args: bool, lifetime_elision: &LifetimeElisionKind<'db>, lowering_assoc_type_generics: bool, ctx: &mut impl GenericArgsLowerer<'db>) -> bool {
     let mut had_error = false;
-
     let (mut provided_lifetimes_count, mut provided_types_and_consts_count) = (0usize, 0usize);
     if let Some(args_and_bindings) = args_and_bindings {
         let args_no_self = &args_and_bindings.args[usize::from(args_and_bindings.has_self_type)..];
             }
         }
     }
-
     let lifetime_args_len = def_generics.len_lifetimes_self();
     if provided_lifetimes_count == 0
         && lifetime_args_len > 0
         );
         had_error = true;
     }
-
     let defaults_count =
         def_generics.iter_self_type_or_consts().filter(|(_, param)| param.has_default()).count();
     let named_type_and_const_params_count = def_generics
         );
         had_error = true;
     }
-
     had_error
 }
 
-pub(crate) fn substs_from_args_and_bindings<'db>(
-    db: &'db dyn HirDatabase,
-    store: &ExpressionStore,
-    args_and_bindings: Option<&HirGenericArgs>,
-    def: GenericDefId,
-    mut infer_args: bool,
-    lifetime_elision: LifetimeElisionKind<'db>,
-    lowering_assoc_type_generics: bool,
-    explicit_self_ty: Option<Ty<'db>>,
-    ctx: &mut impl GenericArgsLowerer<'db>,
-) -> GenericArgs<'db> {
+pub(crate) fn substs_from_args_and_bindings<'db>(db: &'db dyn HirDatabase, store: &ExpressionStore, args_and_bindings: Option<&HirGenericArgs>, def: GenericDefId, mut infer_args: bool, lifetime_elision: LifetimeElisionKind<'db>, lowering_assoc_type_generics: bool, explicit_self_ty: Option<Ty<'db>>, ctx: &mut impl GenericArgsLowerer<'db>) -> GenericArgs<'db> {
     let interner = DbInterner::new_with(db, None, None);
-
     tracing::debug!(?args_and_bindings);
-
     // Order is
     // - Parent parameters
     // - Optional Self parameter
     // - Type or Const parameters
     let def_generics = generics(db, def);
     let args_slice = args_and_bindings.map(|it| &*it.args).unwrap_or_default();
-
     // We do not allow inference if there are specified args, i.e. we do not allow partial inference.
     let has_non_lifetime_args =
         args_slice.iter().any(|arg| !matches!(arg, HirGenericArg::Lifetime(_)));
     infer_args &= !has_non_lifetime_args;
-
     let had_count_error = check_generic_args_len(
         args_and_bindings,
         def,
         lowering_assoc_type_generics,
         ctx,
     );
-
     let mut substs = Vec::with_capacity(def_generics.len());
-
     substs.extend(def_generics.iter_parent_id().map(|id| ctx.parent_arg(id)));
-
     let mut args = args_slice.iter().enumerate().peekable();
     let mut params = def_generics.iter_self().peekable();
-
     // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.
     // If we later encounter a lifetime, we know that the arguments were provided in the
     // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be
     // inferred, so we can use it for diagnostics later.
     let mut force_infer_lt = None;
-
     let has_self_arg = args_and_bindings.is_some_and(|it| it.has_self_type);
     // First, handle `Self` parameter. Consume it from the args if provided, otherwise from `explicit_self_ty`,
     // and lastly infer it.
         params.next();
         substs.push(self_ty);
     }
-
     loop {
         // We're going to iterate through the generic arguments that the user
         // provided, matching them with the generic parameters we expect.
             (None, None) => break,
         }
     }
-
     GenericArgs::new_from_iter(interner, substs)
 }
 
-fn type_looks_like_const(
-    store: &ExpressionStore,
-    type_ref: TypeRefId,
-) -> Option<TypeLikeConst<'_>> {
+fn type_looks_like_const(store: &ExpressionStore, type_ref: TypeRefId) -> Option<TypeLikeConst<'_>> {
     // A path/`_` const will be parsed as a type, instead of a const, because when parsing/lowering
     // in hir-def we don't yet know the expected argument kind. rustc does this a bit differently,
     // when lowering to HIR it resolves the path, and if it doesn't resolve to the type namespace