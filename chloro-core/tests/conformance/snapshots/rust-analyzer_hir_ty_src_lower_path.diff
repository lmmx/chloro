COMPARISON DIFF
============================================================

Original size: 55742 bytes
Chloro size:   55178 bytes
Rustfmt size:  55742 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
         ProjectionPredicate, Region, TraitRef, Ty,
     },
 };
-
 use super::{
     ImplTraitLoweringMode, TyLoweringContext, associated_type_by_name_including_super_traits,
     const_param_ty_query, ty_query,
 };
 
-type CallbackData<'a, 'db> = Either<
+type CallbackData<'a, 'db> =
+    Either<
     PathDiagnosticCallbackData,
     crate::infer::diagnostics::PathDiagnosticCallbackData<'a, 'db>,
 >;
 
-// We cannot use `&mut dyn FnMut()` because of lifetime issues, and we don't want to use `Box<dyn FnMut()>`
-// because of the allocation, so we create a lifetime-less callback, tailored for our needs.
 pub(crate) struct PathDiagnosticCallback<'a, 'db> {
     pub(crate) data: CallbackData<'a, 'db>,
-    pub(crate) callback:
-        fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
+    pub(crate) callback: fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
 }
 
 pub(crate) struct PathLoweringContext<'a, 'b, 'db> {
 
     #[inline]
     #[cold]
-    fn on_diagnostic(&mut self, diag: PathLoweringDiagnostic) {
+    fn on_diagnostic(
+        &mut self,
+        diag: PathLoweringDiagnostic,
+    ) {
         (self.on_diagnostic.callback)(&self.on_diagnostic.data, self.ctx, diag);
     }
 
     }
 
     #[inline]
-    pub(crate) fn set_current_segment(&mut self, segment: usize) {
+    pub(crate) fn set_current_segment(
+        &mut self,
+        segment: usize,
+    ) {
         self.current_segment_idx = segment;
         self.current_or_prev_segment = self
             .segments
     pub(crate) fn lower_ty_relative_path(
         &mut self,
         ty: Ty<'db>,
-        // We need the original resolution to lower `Self::AssocTy` correctly
         res: Option<TypeNs>,
         infer_args: bool,
     ) -> (Ty<'db>, Option<TypeNs>) {
         }
     }
 
-    // When calling this, the current segment is the resolved segment (we don't advance it yet).
     pub(crate) fn lower_partly_resolved_path(
         &mut self,
         resolution: TypeNs,
         tracing::debug!(?remaining_segments);
         let rem_seg_len = remaining_segments.len();
         tracing::debug!(?rem_seg_len);
-
         let ty = match resolution {
             TypeNs::TraitId(trait_) => {
                 let ty = match remaining_segments.len() {
                 return (Ty::new_error(self.ctx.interner, ErrorGuaranteed), None);
             }
         };
-
         tracing::debug!(?ty);
-
         self.skip_resolved_segment();
         self.lower_ty_relative_path(ty, Some(resolution), infer_args)
     }
 
     /// This returns whether to keep the resolution (`true`) of throw it (`false`).
     #[must_use]
-    fn handle_type_ns_resolution(&mut self, resolution: &TypeNs) -> bool {
+    fn handle_type_ns_resolution(
+        &mut self,
+        resolution: &TypeNs,
+    ) -> bool {
         let mut prohibit_generics_on_resolved = |reason| {
             if self.current_or_prev_segment.args_and_bindings.is_some() {
                 let segment = self.current_segment_u32();
                 });
             }
         };
-
         match resolution {
             TypeNs::SelfType(_) => {
                 prohibit_generics_on_resolved(GenericArgsProhibitedReason::SelfTy)
             | TypeNs::TypeAliasId(_)
             | TypeNs::TraitId(_) => {}
         }
-
         true
     }
 
     pub(crate) fn resolve_path_in_type_ns(&mut self) -> Option<(TypeNs, Option<usize>)> {
         let (resolution, remaining_index, _, prefix_info) =
             self.ctx.resolver.resolve_path_in_type_ns_with_prefix_info(self.ctx.db, self.path)?;
-
         let segments = self.segments;
         if segments.is_empty() || matches!(self.path, Path::LangItem(..)) {
             // `segments.is_empty()` can occur with `self`.
             return Some((resolution, remaining_index));
         }
-
         let (module_segments, resolved_segment_idx, enum_segment) = match remaining_index {
             None if prefix_info.enum_variant => {
                 (segments.strip_last_two(), segments.len() - 1, Some(segments.len() - 2))
             None => (segments.strip_last(), segments.len() - 1, None),
             Some(i) => (segments.take(i - 1), i - 1, None),
         };
-
         self.current_segment_idx = resolved_segment_idx;
         self.current_or_prev_segment =
             segments.get(resolved_segment_idx).expect("should have resolved segment");
-
         for (i, mod_segment) in module_segments.iter().enumerate() {
             if mod_segment.args_and_bindings.is_some() {
                 self.on_diagnostic(PathLoweringDiagnostic::GenericArgsProhibited {
                 });
             }
         }
-
         if let Some(enum_segment) = enum_segment
             && segments.get(enum_segment).is_some_and(|it| it.args_and_bindings.is_some())
             && segments.get(enum_segment + 1).is_some_and(|it| it.args_and_bindings.is_some())
                 reason: GenericArgsProhibitedReason::EnumVariant,
             });
         }
-
         if !self.handle_type_ns_resolution(&resolution) {
             return None;
         }
-
         Some((resolution, remaining_index))
     }
 
             self.path,
             hygiene_id,
         )?;
-
         let segments = self.segments;
         if segments.is_empty() || matches!(self.path, Path::LangItem(..)) {
             // `segments.is_empty()` can occur with `self`.
             return Some(res);
         }
-
         let (mod_segments, enum_segment, resolved_segment_idx) = match res {
             ResolveValueResult::Partial(_, unresolved_segment, _) => {
                 (segments.take(unresolved_segment - 1), None, unresolved_segment - 1)
             }
             ResolveValueResult::ValueNs(..) => (segments.strip_last(), None, segments.len() - 1),
         };
-
         self.current_segment_idx = resolved_segment_idx;
         self.current_or_prev_segment =
             segments.get(resolved_segment_idx).expect("should have resolved segment");
-
         for (i, mod_segment) in mod_segments.iter().enumerate() {
             if mod_segment.args_and_bindings.is_some() {
                 self.on_diagnostic(PathLoweringDiagnostic::GenericArgsProhibited {
                 });
             }
         }
-
         if let Some(enum_segment) = enum_segment
             && segments.get(enum_segment).is_some_and(|it| it.args_and_bindings.is_some())
             && segments.get(enum_segment + 1).is_some_and(|it| it.args_and_bindings.is_some())
                 reason: GenericArgsProhibitedReason::EnumVariant,
             });
         }
-
         match &res {
             ResolveValueResult::ValueNs(resolution, _) => {
                 let resolved_segment_idx = self.current_segment_u32();
     }
 
     #[tracing::instrument(skip(self), ret)]
-    fn select_associated_type(&mut self, res: Option<TypeNs>, infer_args: bool) -> Ty<'db> {
+    fn select_associated_type(
+        &mut self,
+        res: Option<TypeNs>,
+        infer_args: bool,
+    ) -> Ty<'db> {
         let interner = self.ctx.interner;
         let Some(res) = res else {
             return Ty::new_error(self.ctx.interner, ErrorGuaranteed);
         .unwrap_or_else(|| Ty::new_error(interner, ErrorGuaranteed))
     }
 
-    fn lower_path_inner(&mut self, typeable: TyDefId, infer_args: bool) -> Ty<'db> {
+    fn lower_path_inner(
+        &mut self,
+        typeable: TyDefId,
+        infer_args: bool,
+    ) -> Ty<'db> {
         let generic_def = match typeable {
             TyDefId::BuiltinType(builtinty) => {
                 return Ty::from_builtin_type(self.ctx.interner, builtinty);
     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.
     pub(crate) fn substs_from_path(
         &mut self,
-        // Note that we don't call `db.value_type(resolved)` here,
-        // `ValueTyDefId` is just a convenient way to pass generics and
-        // special-case enum variants
         resolved: ValueTyDefId,
         infer_args: bool,
         lowering_assoc_type_generics: bool,
         let interner = self.ctx.interner;
         let prev_current_segment_idx = self.current_segment_idx;
         let prev_current_segment = self.current_or_prev_segment;
-
         let generic_def = match resolved {
             ValueTyDefId::FunctionId(it) => it.into(),
             ValueTyDefId::StructId(it) => it.into(),
         lowering_assoc_type_generics: bool,
     ) -> GenericArgs<'db> {
         let old_lifetime_elision = self.ctx.lifetime_elision.clone();
-
         if let Some(args) = self.current_or_prev_segment.args_and_bindings
             && args.parenthesized != GenericArgsParentheses::No
         {
             self.ctx.lifetime_elision =
                 LifetimeElisionKind::AnonymousCreateParameter { report_in_path: false };
         }
-
         let result = self.substs_from_args_and_bindings(
             self.current_or_prev_segment.args_and_bindings,
             def,
             ctx: &'a mut PathLoweringContext<'b, 'c, 'db>,
             generics_source: PathGenericsSource,
         }
-
         impl<'db> GenericArgsLowerer<'db> for LowererCtx<'_, '_, '_, 'db> {
             fn report_len_mismatch(
                 &mut self,
                 });
             }
         }
-
         substs_from_args_and_bindings(
             self.ctx.db,
             self.ctx.store,
     Path(&'a Path),
 }
 
-pub(crate) trait GenericArgsLowerer<'db> {
-    fn report_elided_lifetimes_in_path(
-        &mut self,
-        def: GenericDefId,
-        expected_count: u32,
-        hard_error: bool,
-    );
-
-    fn report_elision_failure(&mut self, def: GenericDefId, expected_count: u32);
-
-    fn report_missing_lifetime(&mut self, def: GenericDefId, expected_count: u32);
-
-    fn report_len_mismatch(
-        &mut self,
-        def: GenericDefId,
-        provided_count: u32,
-        expected_count: u32,
-        kind: IncorrectGenericsLenKind,
-    );
-
-    fn report_arg_mismatch(&mut self, param_id: GenericParamId, arg_idx: u32, has_self_arg: bool);
-
-    fn provided_kind(
-        &mut self,
-        param_id: GenericParamId,
-        param: GenericParamDataRef<'_>,
-        arg: &HirGenericArg,
-    ) -> GenericArg<'db>;
-
-    fn provided_type_like_const(&mut self, const_ty: Ty<'db>, arg: TypeLikeConst<'_>)
-    -> Const<'db>;
-
-    fn inferred_kind(
-        &mut self,
-        def: GenericDefId,
-        param_id: GenericParamId,
-        param: GenericParamDataRef<'_>,
-        infer_args: bool,
-        preceding_args: &[GenericArg<'db>],
-    ) -> GenericArg<'db>;
-
-    fn parent_arg(&mut self, param_id: GenericParamId) -> GenericArg<'db>;
-}
+fn report_elided_lifetimes_in_path(
+    &mut self,
+    def: GenericDefId,
+    expected_count: u32,
+    hard_error: bool,
+);
+fn report_elision_failure(
+    &mut self,
+    def: GenericDefId,
+    expected_count: u32,
+);
+fn report_missing_lifetime(
+    &mut self,
+    def: GenericDefId,
+    expected_count: u32,
+);
+fn report_len_mismatch(
+    &mut self,
+    def: GenericDefId,
+    provided_count: u32,
+    expected_count: u32,
+    kind: IncorrectGenericsLenKind,
+);
+fn report_arg_mismatch(
+    &mut self,
+    param_id: GenericParamId,
+    arg_idx: u32,
+    has_self_arg: bool,
+);
+fn provided_kind(
+    &mut self,
+    param_id: GenericParamId,
+    param: GenericParamDataRef<'_>,
+    arg: &HirGenericArg,
+) -> GenericArg<'db>;
+fn provided_type_like_const(
+    &mut self,
+    const_ty: Ty<'db>,
+    arg: TypeLikeConst<'_>,
+) -> Const<'db>;
+fn inferred_kind(
+    &mut self,
+    def: GenericDefId,
+    param_id: GenericParamId,
+    param: GenericParamDataRef<'_>,
+    infer_args: bool,
+    preceding_args: &[GenericArg<'db>],
+) -> GenericArg<'db>;
+fn parent_arg(
+    &mut self,
+    param_id: GenericParamId,
+) -> GenericArg<'db>;
 
 /// Returns true if there was an error.
 fn check_generic_args_len<'db>(
     ctx: &mut impl GenericArgsLowerer<'db>,
 ) -> bool {
     let mut had_error = false;
-
     let (mut provided_lifetimes_count, mut provided_types_and_consts_count) = (0usize, 0usize);
     if let Some(args_and_bindings) = args_and_bindings {
         let args_no_self = &args_and_bindings.args[usize::from(args_and_bindings.has_self_type)..];
             }
         }
     }
-
     let lifetime_args_len = def_generics.len_lifetimes_self();
     if provided_lifetimes_count == 0
         && lifetime_args_len > 0
         );
         had_error = true;
     }
-
     let defaults_count =
         def_generics.iter_self_type_or_consts().filter(|(_, param)| param.has_default()).count();
     let named_type_and_const_params_count = def_generics
         );
         had_error = true;
     }
-
     had_error
 }
 
     ctx: &mut impl GenericArgsLowerer<'db>,
 ) -> GenericArgs<'db> {
     let interner = DbInterner::new_with(db, None, None);
-
     tracing::debug!(?args_and_bindings);
-
     // Order is
     // - Parent parameters
     // - Optional Self parameter
     // - Type or Const parameters
     let def_generics = generics(db, def);
     let args_slice = args_and_bindings.map(|it| &*it.args).unwrap_or_default();
-
     // We do not allow inference if there are specified args, i.e. we do not allow partial inference.
     let has_non_lifetime_args =
         args_slice.iter().any(|arg| !matches!(arg, HirGenericArg::Lifetime(_)));
     infer_args &= !has_non_lifetime_args;
-
     let had_count_error = check_generic_args_len(
         args_and_bindings,
         def,
         lowering_assoc_type_generics,
         ctx,
     );
-
     let mut substs = Vec::with_capacity(def_generics.len());
-
     substs.extend(def_generics.iter_parent_id().map(|id| ctx.parent_arg(id)));
-
     let mut args = args_slice.iter().enumerate().peekable();
     let mut params = def_generics.iter_self().peekable();
-
     // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.
     // If we later encounter a lifetime, we know that the arguments were provided in the
     // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be
     // inferred, so we can use it for diagnostics later.
     let mut force_infer_lt = None;
-
     let has_self_arg = args_and_bindings.is_some_and(|it| it.has_self_type);
     // First, handle `Self` parameter. Consume it from the args if provided, otherwise from `explicit_self_ty`,
     // and lastly infer it.
         params.next();
         substs.push(self_ty);
     }
-
     loop {
         // We're going to iterate through the generic arguments that the user
         // provided, matching them with the generic parameters we expect.
             (None, None) => break,
         }
     }
-
     GenericArgs::new_from_iter(interner, substs)
 }
 
     }
 }
 
-fn unknown_subst<'db>(interner: DbInterner<'db>, def: impl Into<GenericDefId>) -> GenericArgs<'db> {
+fn unknown_subst<'db>(
+    interner: DbInterner<'db>,
+    def: impl Into<GenericDefId>,
+) -> GenericArgs<'db> {
     let params = generics(interner.db(), def.into());
     GenericArgs::new_from_iter(
         interner,