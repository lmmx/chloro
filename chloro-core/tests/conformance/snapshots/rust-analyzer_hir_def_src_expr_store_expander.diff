COMPARISON DIFF
============================================================

Original size: 8495 bytes
Chloro size:   8299 bytes
Rustfmt size:  8873 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use base_db::Crate;
 use cfg::CfgOptions;
 use drop_bomb::DropBomb;
-use hir_expand::span_map::SpanMapRef;
 use hir_expand::AstId;
+use hir_expand::span_map::SpanMapRef;
 use hir_expand::{
-    eager::EagerCallBackFn, mod_path::ModPath, span_map::SpanMap, ExpandError, ExpandErrorKind,
-    ExpandResult, HirFileId, InFile, Lookup, MacroCallId,
+    ExpandError, ExpandErrorKind, ExpandResult, HirFileId, InFile, Lookup, MacroCallId,
+    eager::EagerCallBackFn, mod_path::ModPath, span_map::SpanMap,
 };
 use span::{AstIdMap, Edition, SyntaxContext};
 use syntax::ast::HasAttrs;
-use syntax::{ast, AstNode, Parse};
+use syntax::{AstNode, Parse, ast};
 use triomphe::Arc;
 use tt::TextRange;
 
 use crate::expr_store::HygieneId;
 use crate::macro_call_as_call_id;
 use crate::nameres::DefMap;
-use crate::{db::DefDatabase, MacroId, UnresolvedMacro};
+use crate::{MacroId, UnresolvedMacro, db::DefDatabase};
 
 #[derive(Debug)]
 pub(super) struct Expander {
 }
 
 impl Expander {
-    pub(super) fn new(
-        db: &dyn DefDatabase,
-        current_file_id: HirFileId,
-        def_map: &DefMap,
-    ) -> Expander {
+    pub(super) fn new(db: &dyn DefDatabase, current_file_id: HirFileId, def_map: &DefMap) -> Expander {
         let recursion_limit = def_map.recursion_limit() as usize;
         let recursion_limit = if cfg!(test) {
             // Without this, `body::tests::your_stack_belongs_to_me` stack-overflows in debug
 
     pub(super) fn hygiene_for_range(&self, db: &dyn DefDatabase, range: TextRange) -> HygieneId {
         match self.span_map.as_ref() {
-            hir_expand::span_map::SpanMapRef::ExpansionSpanMap(span_map) => HygieneId::new(
-                span_map
-                    .span_at(range.start())
-                    .ctx
-                    .opaque_and_semitransparent(db),
-            ),
+            hir_expand::span_map::SpanMapRef::ExpansionSpanMap(span_map) => {
+                HygieneId::new(span_map.span_at(range.start()).ctx.opaque_and_semitransparent(db))
+            }
             hir_expand::span_map::SpanMapRef::RealSpanMap(_) => HygieneId::ROOT,
         }
     }
 
-    pub(super) fn is_cfg_enabled(
-        &self,
-        db: &dyn DefDatabase,
-        has_attrs: &dyn HasAttrs,
-        cfg_options: &CfgOptions,
-    ) -> Result<(), cfg::CfgExpr> {
+    pub(super) fn is_cfg_enabled(&self, db: &dyn DefDatabase, has_attrs: &dyn HasAttrs, cfg_options: &CfgOptions) -> Result<(), cfg::CfgExpr> {
         Attrs::is_cfg_enabled_for(db, has_attrs, self.span_map.as_ref(), cfg_options)
     }
 
         SyntaxContext::root(Edition::CURRENT_FIXME)
     }
 
-    pub(super) fn enter_expand<T: ast::AstNode>(
-        &mut self,
-        db: &dyn DefDatabase,
-        macro_call: ast::MacroCall,
-        krate: Crate,
-        resolver: impl Fn(&ModPath) -> Option<MacroId>,
-        eager_callback: EagerCallBackFn<'_>,
-    ) -> Result<ExpandResult<Option<(Mark, Option<Parse<T>>)>>, UnresolvedMacro> {
+    pub(super) fn enter_expand<T: ast::AstNode>(&mut self, db: &dyn DefDatabase, macro_call: ast::MacroCall, krate: Crate, resolver: impl Fn(&ModPath) -> Option<MacroId>, eager_callback: EagerCallBackFn<'_>) -> Result<ExpandResult<Option<(Mark, Option<Parse<T>>)>>, UnresolvedMacro> {
         // FIXME: within_limit should support this, instead of us having to extract the error
         let mut unresolved_macro_err = None;
-
         let result = self.within_limit(db, |this| {
             let macro_call = this.in_file(&macro_call);
 
             let expands_to = hir_expand::ExpandTo::from_call_site(macro_call.value);
-            let ast_id = AstId::new(
-                macro_call.file_id,
-                this.ast_id_map().ast_id(macro_call.value),
-            );
+            let ast_id = AstId::new(macro_call.file_id, this.ast_id_map().ast_id(macro_call.value));
             let path = macro_call.value.path().and_then(|path| {
                 let range = path.syntax().text_range();
                 let mod_path = ModPath::from_src(db, path, &mut |range| {
 
             let Some((call_site, path)) = path else {
                 return ExpandResult::only_err(ExpandError::other(
-                    this.span_map
-                        .span_for_range(macro_call.value.syntax().text_range()),
+                    this.span_map.span_for_range(macro_call.value.syntax().text_range()),
                     "malformed macro invocation",
                 ));
             };
                 Ok(call_id) => call_id,
                 Err(resolve_err) => {
                     unresolved_macro_err = Some(resolve_err);
-                    ExpandResult {
-                        value: None,
-                        err: None,
-                    }
+                    ExpandResult { value: None, err: None }
                 }
             }
         });
-
-        if let Some(err) = unresolved_macro_err {
-            Err(err)
-        } else {
-            Ok(result)
-        }
+        if let Some(err) = unresolved_macro_err { Err(err) } else { Ok(result) }
     }
 
-    pub(super) fn enter_expand_id<T: ast::AstNode>(
-        &mut self,
-        db: &dyn DefDatabase,
-        call_id: MacroCallId,
-    ) -> ExpandResult<Option<(Mark, Option<Parse<T>>)>> {
+    pub(super) fn enter_expand_id<T: ast::AstNode>(&mut self, db: &dyn DefDatabase, call_id: MacroCallId) -> ExpandResult<Option<(Mark, Option<Parse<T>>)>> {
         self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))
     }
 
-    pub(super) fn exit(
-        &mut self,
-        Mark {
-            file_id,
-            span_map,
-            ast_id_map,
-            mut bomb,
-        }: Mark,
-    ) {
+    pub(super) fn exit(&mut self, Mark { file_id, span_map, ast_id_map, mut bomb }: Mark) {
         self.span_map = span_map;
         self.current_file_id = file_id;
         self.ast_id_map = ast_id_map;
     }
 
     pub(super) fn in_file<T>(&self, value: T) -> InFile<T> {
-        InFile {
-            file_id: self.current_file_id,
-            value,
-        }
+        InFile { file_id: self.current_file_id, value }
     }
 
     pub(super) fn current_file_id(&self) -> HirFileId {
         self.current_file_id
     }
 
-    fn within_limit<F, T: ast::AstNode>(
-        &mut self,
-        db: &dyn DefDatabase,
-        op: F,
-    ) -> ExpandResult<Option<(Mark, Option<Parse<T>>)>>
+    fn within_limit<F, T: ast::AstNode>(&mut self, db: &dyn DefDatabase, op: F) -> ExpandResult<Option<(Mark, Option<Parse<T>>)>>
     where
-        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,
-    {
+        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>, {
         if self.recursion_depth == u32::MAX {
             // Recursion limit has been reached somewhere in the macro expansion tree. We should
             // stop expanding other macro calls in this tree, or else this may result in
             cov_mark::hit!(overflow_but_not_me);
             return ExpandResult::ok(None);
         }
-
         let ExpandResult { value, err } = op(self);
         let Some(call_id) = value else {
             return ExpandResult { value: None, err };
             self.recursion_depth = u32::MAX;
             cov_mark::hit!(your_stack_belongs_to_me);
             return ExpandResult::only_err(ExpandError::new(
-                db.macro_arg_considering_derives(call_id, &call_id.lookup(db).kind)
-                    .2,
+                db.macro_arg_considering_derives(call_id, &call_id.lookup(db).kind).2,
                 ExpandErrorKind::RecursionOverflow,
             ));
         }
-
         let res = db.parse_macro_expansion(call_id);
-
         let err = err.or(res.err);
         ExpandResult {
             value: {