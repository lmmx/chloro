COMPARISON DIFF
============================================================

Original size: 87058 bytes
Chloro size:   87116 bytes
Rustfmt size:  87058 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //!  - Building the type for an item: This happens through the `ty` query.
 //!
 //! This usually involves resolving names, collecting generic arguments etc.
-pub(crate) mod diagnostics;
-pub(crate) mod path;
 
 use std::{
     cell::OnceCell,
     },
 };
 
+pub(crate) mod diagnostics;
+pub(crate) mod path;
+
 pub(crate) struct PathDiagnosticCallbackData(pub(crate) TypeRefId);
 
 #[derive(PartialEq, Eq, Debug, Hash)]
     /// bounds at the same time to get the IDs correct (without becoming too
     /// complicated).
     mode: ImplTraitLoweringMode,
-    // This is structured as a struct with fields and not as an enum because it helps with the borrow checker.
     opaque_type_data: Arena<ImplTrait<'db>>,
 }
 
     /// struct Foo<'a> { x: &'a () }
     /// async fn foo(Foo { x: _ }: Foo<'_>) {}
     /// ```
-    AnonymousCreateParameter { report_in_path: bool },
-
+    AnonymousCreateParameter {
+        report_in_path: bool,
+    },
     /// Replace all anonymous lifetimes by provided lifetime.
     Elided(Region<'db>),
-
     /// Give a hard error when either `&` or `'_` is written. Used to
     /// rule out things like `where T: Foo<'_>`. Does not imply an
     /// error on default object bounds (e.g., `Box<dyn Foo>`).
     AnonymousReportError,
-
     /// Resolves elided lifetimes to `'static` if there are no other lifetimes in scope,
     /// otherwise give a warning that the previous behavior of introducing a new early-bound
     /// lifetime is a bug and will be removed (if `only_lint` is enabled).
-    StaticIfNoLifetimeInScope { only_lint: bool },
-
+    StaticIfNoLifetimeInScope {
+        only_lint: bool,
+    },
     /// Signal we cannot find which should be the anonymous lifetime.
     ElisionFailure,
-
     /// Infer all elided lifetimes.
     Infer,
 }
         }
     }
 
-    pub(crate) fn set_lifetime_elision(&mut self, lifetime_elision: LifetimeElisionKind<'db>) {
+    pub(crate) fn set_lifetime_elision(
+        &mut self,
+        lifetime_elision: LifetimeElisionKind<'db>,
+    ) {
         self.lifetime_elision = lifetime_elision;
     }
 
         self.with_debruijn(self.in_binders.shifted_in(debruijn.as_u32()), f)
     }
 
-    pub(crate) fn with_impl_trait_mode(self, impl_trait_mode: ImplTraitLoweringMode) -> Self {
+    pub(crate) fn with_impl_trait_mode(
+        self,
+        impl_trait_mode: ImplTraitLoweringMode,
+    ) -> Self {
         Self { impl_trait_mode: ImplTraitLoweringState::new(impl_trait_mode), ..self }
     }
 
-    pub(crate) fn impl_trait_mode(&mut self, impl_trait_mode: ImplTraitLoweringMode) -> &mut Self {
+    pub(crate) fn impl_trait_mode(
+        &mut self,
+        impl_trait_mode: ImplTraitLoweringMode,
+    ) -> &mut Self {
         self.impl_trait_mode = ImplTraitLoweringState::new(impl_trait_mode);
         self
     }
 
-    pub(crate) fn lowering_param_default(&mut self, index: u32) {
+    pub(crate) fn lowering_param_default(
+        &mut self,
+        index: u32,
+    ) {
         self.lowering_param_default = Some(index);
     }
 
-    pub(crate) fn push_diagnostic(&mut self, type_ref: TypeRefId, kind: TyLoweringDiagnosticKind) {
+    pub(crate) fn push_diagnostic(
+        &mut self,
+        type_ref: TypeRefId,
+        kind: TyLoweringDiagnosticKind,
+    ) {
         self.diagnostics.push(TyLoweringDiagnostic { source: type_ref, kind });
     }
 }
 }
 
 impl<'db, 'a> TyLoweringContext<'db, 'a> {
-    pub fn lower_ty(&mut self, type_ref: TypeRefId) -> Ty<'db> {
+    pub fn lower_ty(
+        &mut self,
+        type_ref: TypeRefId,
+    ) -> Ty<'db> {
         self.lower_ty_ext(type_ref).0
     }
 
-    pub(crate) fn lower_const(&mut self, const_ref: ConstRef, const_type: Ty<'db>) -> Const<'db> {
+    pub(crate) fn lower_const(
+        &mut self,
+        const_ref: ConstRef,
+        const_type: Ty<'db>,
+    ) -> Const<'db> {
         let const_ref = &self.store[const_ref.expr];
         match const_ref {
             hir_def::hir::Expr::Path(path) => {
         }
     }
 
-    pub(crate) fn path_to_const(&mut self, path: &Path) -> Option<Const<'db>> {
+    pub(crate) fn path_to_const(
+        &mut self,
+        path: &Path,
+    ) -> Option<Const<'db>> {
         match self.resolver.resolve_path_in_value_ns_fully(self.db, path, HygieneId::ROOT) {
             Some(ValueNs::GenericParam(p)) => {
                 let args = self.generics();
         }
     }
 
-    pub(crate) fn lower_path_as_const(&mut self, path: &Path, const_type: Ty<'db>) -> Const<'db> {
+    pub(crate) fn lower_path_as_const(
+        &mut self,
+        path: &Path,
+        const_type: Ty<'db>,
+    ) -> Const<'db> {
         self.path_to_const(path).unwrap_or_else(|| unknown_const(const_type))
     }
 
         self.generics.get_or_init(|| generics(self.db, self.def))
     }
 
-    fn param_index_is_disallowed(&self, index: u32) -> bool {
+    fn param_index_is_disallowed(
+        &self,
+        index: u32,
+    ) -> bool {
         self.lowering_param_default
             .is_some_and(|disallow_params_after| index >= disallow_params_after)
     }
 
-    fn type_param(&mut self, id: TypeParamId, index: u32) -> Ty<'db> {
+    fn type_param(
+        &mut self,
+        id: TypeParamId,
+        index: u32,
+    ) -> Ty<'db> {
         if self.param_index_is_disallowed(index) {
             // FIXME: Report an error.
             Ty::new_error(self.interner, ErrorGuaranteed)
         }
     }
 
-    fn const_param(&mut self, id: ConstParamId, index: u32) -> Const<'db> {
+    fn const_param(
+        &mut self,
+        id: ConstParamId,
+        index: u32,
+    ) -> Const<'db> {
         if self.param_index_is_disallowed(index) {
             // FIXME: Report an error.
             Const::error(self.interner)
         }
     }
 
-    fn region_param(&mut self, id: LifetimeParamId, index: u32) -> Region<'db> {
+    fn region_param(
+        &mut self,
+        id: LifetimeParamId,
+        index: u32,
+    ) -> Region<'db> {
         if self.param_index_is_disallowed(index) {
             // FIXME: Report an error.
             Region::error(self.interner)
     }
 
     #[tracing::instrument(skip(self), ret)]
-    pub fn lower_ty_ext(&mut self, type_ref_id: TypeRefId) -> (Ty<'db>, Option<TypeNs>) {
+    pub fn lower_ty_ext(
+        &mut self,
+        type_ref_id: TypeRefId,
+    ) -> (Ty<'db>, Option<TypeNs>) {
         let interner = self.interner;
         let mut res = None;
         let type_ref = &self.store[type_ref_id];
     /// This is only for `generic_predicates_for_param`, where we can't just
     /// lower the self types of the predicates since that could lead to cycles.
     /// So we just check here if the `type_ref` resolves to a generic param, and which.
-    fn lower_ty_only_param(&self, type_ref: TypeRefId) -> Option<TypeOrConstParamId> {
+    fn lower_ty_only_param(
+        &self,
+        type_ref: TypeRefId,
+    ) -> Option<TypeOrConstParamId> {
         let type_ref = &self.store[type_ref];
         let path = match type_ref {
             TypeRef::Path(path) => path,
     }
 
     #[inline]
-    fn at_path(&mut self, path_id: PathId) -> PathLoweringContext<'_, 'a, 'db> {
+    fn at_path(
+        &mut self,
+        path_id: PathId,
+    ) -> PathLoweringContext<'_, 'a, 'db> {
         PathLoweringContext::new(
             self,
             Self::on_path_diagnostic_callback(path_id.type_ref()),
         )
     }
 
-    pub(crate) fn lower_path(&mut self, path: &Path, path_id: PathId) -> (Ty<'db>, Option<TypeNs>) {
+    pub(crate) fn lower_path(
+        &mut self,
+        path: &Path,
+        path_id: PathId,
+    ) -> (Ty<'db>, Option<TypeNs>) {
         // Resolve the path (in type namespace)
         if let Some(type_ref) = path.type_anchor() {
             let (ty, res) = self.lower_ty_ext(type_ref);
             let mut ctx = self.at_path(path_id);
             return ctx.lower_ty_relative_path(ty, res, false);
         }
-
         let mut ctx = self.at_path(path_id);
         let (resolution, remaining_index) = match ctx.resolve_path_in_type_ns() {
             Some(it) => it,
             None => return (Ty::new_error(self.interner, ErrorGuaranteed), None),
         };
-
         if matches!(resolution, TypeNs::TraitId(_)) && remaining_index.is_none() {
             // trait object type without dyn
             let bound = TypeBound::Path(path_id, TraitBoundModifier::None);
             let ty = self.lower_dyn_trait(&[bound]);
             return (ty, None);
         }
-
         ctx.lower_partly_resolved_path(resolution, false)
     }
 
         clause.into_iter().chain(assoc_bounds.into_iter().flatten())
     }
 
-    fn lower_dyn_trait(&mut self, bounds: &[TypeBound]) -> Ty<'db> {
+    fn lower_dyn_trait(
+        &mut self,
+        bounds: &[TypeBound],
+    ) -> Ty<'db> {
         let interner = self.interner;
         // FIXME: we should never create non-existential predicates in the first place
         // For now, use an error type so we don't run into dummy binder issues
 
             Some(BoundExistentialPredicates::new_from_iter(interner, lowered_bounds))
         });
-
         if let Some(bounds) = bounds {
             let region = match lifetime {
                 Some(it) => match it.kind() {
         ImplTrait { predicates }
     }
 
-    pub(crate) fn lower_lifetime(&mut self, lifetime: LifetimeRefId) -> Region<'db> {
+    pub(crate) fn lower_lifetime(
+        &mut self,
+        lifetime: LifetimeRefId,
+    ) -> Region<'db> {
         match self.resolver.resolve_lifetime(&self.store[lifetime]) {
             Some(resolution) => match resolution {
                 LifetimeNs::Static => Region::new_static(self.interner),
     AdtId(AdtId),
     TypeAliasId(TypeAliasId),
 }
-impl_from!(BuiltinType, AdtId(StructId, EnumId, UnionId), TypeAliasId for TyDefId);
-
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, salsa_macros::Supertype)]
 pub enum ValueTyDefId {
     FunctionId(FunctionId),
     ConstId(ConstId),
     StaticId(StaticId),
 }
-impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for ValueTyDefId);
-
 impl ValueTyDefId {
-    pub(crate) fn to_generic_def_id(self, db: &dyn HirDatabase) -> GenericDefId {
+    pub(crate) fn to_generic_def_id(
+        self,
+        db: &dyn HirDatabase,
+    ) -> GenericDefId {
         match self {
             Self::FunctionId(id) => id.into(),
             Self::StructId(id) => id.into(),
 /// `struct Foo(usize)`, we have two types: The type of the struct itself, and
 /// the constructor function `(usize) -> Foo` which lives in the values
 /// namespace.
-pub(crate) fn ty_query<'db>(db: &'db dyn HirDatabase, def: TyDefId) -> EarlyBinder<'db, Ty<'db>> {
+pub(crate) fn ty_query<'db>(
+    db: &'db dyn HirDatabase,
+    def: TyDefId,
+) -> EarlyBinder<'db, Ty<'db>> {
     let interner = DbInterner::new_with(db, None, None);
     match def {
         TyDefId::BuiltinType(it) => EarlyBinder::bind(Ty::from_builtin_type(interner, it)),
 
 /// Build the declared type of a function. This should not need to look at the
 /// function body.
-fn type_for_fn<'db>(db: &'db dyn HirDatabase, def: FunctionId) -> EarlyBinder<'db, Ty<'db>> {
+fn type_for_fn<'db>(
+    db: &'db dyn HirDatabase,
+    def: FunctionId,
+) -> EarlyBinder<'db, Ty<'db>> {
     let interner = DbInterner::new_with(db, None, None);
     EarlyBinder::bind(Ty::new_fn_def(
         interner,
 }
 
 /// Build the declared type of a const.
-fn type_for_const<'db>(db: &'db dyn HirDatabase, def: ConstId) -> EarlyBinder<'db, Ty<'db>> {
+fn type_for_const<'db>(
+    db: &'db dyn HirDatabase,
+    def: ConstId,
+) -> EarlyBinder<'db, Ty<'db>> {
     let resolver = def.resolver(db);
     let data = db.const_signature(def);
     let parent = def.loc(db).container;
 }
 
 /// Build the declared type of a static.
-fn type_for_static<'db>(db: &'db dyn HirDatabase, def: StaticId) -> EarlyBinder<'db, Ty<'db>> {
+fn type_for_static<'db>(
+    db: &'db dyn HirDatabase,
+    def: StaticId,
+) -> EarlyBinder<'db, Ty<'db>> {
     let resolver = def.resolver(db);
     let data = db.static_signature(def);
     let mut ctx = TyLoweringContext::new(
     impl_id: ImplId,
 ) -> (EarlyBinder<'db, Ty<'db>>, Diagnostics) {
     let resolver = impl_id.resolver(db);
-
     let impl_data = db.impl_signature(impl_id);
     let mut ctx = TyLoweringContext::new(
         db,
     (EarlyBinder::bind(Ty::new_error(DbInterner::new_with(db, None, None), ErrorGuaranteed)), None)
 }
 
-pub(crate) fn const_param_ty_query<'db>(db: &'db dyn HirDatabase, def: ConstParamId) -> Ty<'db> {
+pub(crate) fn const_param_ty_query<'db>(
+    db: &'db dyn HirDatabase,
+    def: ConstParamId,
+) -> Ty<'db> {
     db.const_param_ty_with_diagnostics(def).0
 }
 
-// returns None if def is a type arg
 pub(crate) fn const_param_ty_with_diagnostics_query<'db>(
     db: &'db dyn HirDatabase,
     def: ConstParamId,
     if fields.is_empty() {
         return (Arc::new(ArenaMap::default()), None);
     }
-
     let (resolver, def): (_, GenericDefId) = match variant_id {
         VariantId::StructId(it) => (it.resolver(db), it.into()),
         VariantId::UnionId(it) => (it.resolver(db), it.into()),
         def,
         LifetimeElisionKind::AnonymousReportError,
     );
-
     // we have to filter out all other predicates *first*, before attempting to lower them
     let predicate = |pred: &_, ctx: &mut TyLoweringContext<'_, '_>| match pred {
         WherePredicate::ForLifetime { target, bound, .. }
             }
         }
     }
-
     let args = GenericArgs::identity_for_item(interner, def.into());
     if !args.is_empty() {
         let explicitly_unsized_tys = ctx.unsized_types;
     if generics.has_no_predicates() && generics.is_empty() {
         return TraitEnvironment::empty(def.krate(db));
     }
-
     let resolver = def.resolver(db);
     let mut ctx = TyLoweringContext::new(
         db,
             }
         }
     }
-
     if let Some(trait_id) = def.assoc_trait_container(db) {
         // add `Self: Trait<T1, T2, ...>` to the environment in trait
         // function default implementations (and speculative code
         ));
         clauses.push(clause);
     }
-
     let explicitly_unsized_tys = ctx.unsized_types;
-
     let sized_trait = LangItem::Sized.resolve_trait(db, resolver.krate());
     if let Some(sized_trait) = sized_trait {
         let (mut generics, mut def_id) =
             }
         }
     }
-
     let clauses = rustc_type_ir::elaborate::elaborate(ctx.interner, clauses);
     let clauses = Clauses::new_from_iter(ctx.interner, clauses);
     let env = ParamEnv { clauses };
-
     TraitEnvironment::new(resolver.krate(), None, traits_in_scope.into_boxed_slice(), env)
 }
 
     filter: F,
 ) -> (GenericPredicates<'db>, Diagnostics)
 where
-    F: Fn(GenericDefId) -> bool,
-{
+    F: Fn(GenericDefId) -> bool, {
     let generics = generics(db, def);
     let resolver = def.resolver(db);
     let interner = DbInterner::new_with(db, Some(resolver.krate()), None);
         def,
         LifetimeElisionKind::AnonymousReportError,
     );
-
     let mut predicates = Vec::new();
     for maybe_parent_generics in
         std::iter::successors(Some(&generics), |generics| generics.parent_generics())
             }
         }
     }
-
     let explicitly_unsized_tys = ctx.unsized_types;
-
     let sized_trait = LangItem::Sized.resolve_trait(db, resolver.krate());
     if let Some(sized_trait) = sized_trait {
         let mut add_sized_clause = |param_idx, param_id, param_data| {
             });
         }
     }
-
     // FIXME: rustc gathers more predicates by recursing through resulting trait predicates.
     // See https://github.com/rust-lang/rust/blob/76c5ed2847cdb26ef2822a3a165d710f6b772217/compiler/rustc_hir_analysis/src/collect/predicates_of.rs#L689-L715
-
     (
         GenericPredicates(predicates.is_empty().not().then(|| predicates.into())),
         create_diagnostics(ctx.diagnostics),
 ) -> Option<impl Iterator<Item = Clause<'db>> + Captures<'a> + Captures<'subst>> {
     let interner = DbInterner::new_with(db, Some(resolver.krate()), None);
     let sized_trait = LangItem::Sized.resolve_trait(db, resolver.krate())?;
-
     let trait_self_idx = trait_self_param_idx(db, def);
-
     Some(
         args.iter()
             .enumerate()
 
 impl<'db> GenericDefaults<'db> {
     #[inline]
-    pub fn get(&self, idx: usize) -> Option<EarlyBinder<'db, GenericArg<'db>>> {
+    pub fn get(
+        &self,
+        idx: usize,
+    ) -> Option<EarlyBinder<'db, GenericArg<'db>>> {
         self.0.as_ref()?[idx]
     }
 }
         return (GenericDefaults(None), None);
     }
     let resolver = def.resolver(db);
-
     let mut ctx = TyLoweringContext::new(
         db,
         &resolver,
             result
         })
         .collect::<Vec<_>>();
-    ctx.diagnostics.clear(); // Don't include diagnostics from the parent.
+    ctx.diagnostics.clear();
+    // Don't include diagnostics from the parent.
     defaults.extend(generic_params.iter_self().map(|(_id, p)| {
         let (result, has_default) = handle_generic_param(&mut ctx, idx, p);
         has_any_default |= has_default;
         GenericDefaults(None)
     };
     return (defaults, diagnostics);
-
     fn handle_generic_param<'db>(
         ctx: &mut TyLoweringContext<'db, '_>,
         idx: usize,
         LifetimeElisionKind::for_fn_params(&data),
     );
     let params = data.params.iter().map(|&tr| ctx_params.lower_ty(tr));
-
     let ret = match data.ret_type {
         Some(ret_type) => {
             let mut ctx_ret = TyLoweringContext::new(
         }
         None => Ty::new_tup(interner, &[]),
     };
-
     let inputs_and_output = Tys::new_from_iter(interner, params.chain(Some(ret)));
     // If/when we track late bound vars, we need to switch this to not be `dummy`
     EarlyBinder::bind(rustc_type_ir::Binder::dummy(FnSig {
     }))
 }
 
-fn type_for_adt<'db>(db: &'db dyn HirDatabase, adt: AdtId) -> EarlyBinder<'db, Ty<'db>> {
+fn type_for_adt<'db>(
+    db: &'db dyn HirDatabase,
+    adt: AdtId,
+) -> EarlyBinder<'db, Ty<'db>> {
     let interner = DbInterner::new_with(db, None, None);
     let args = GenericArgs::identity_for_item(interner, adt.into());
     let ty = Ty::new_adt(interner, adt, args);
     let field_tys = db.field_types(def.into());
     let params = field_tys.iter().map(|(_, ty)| ty.skip_binder());
     let ret = type_for_adt(db, def.into()).skip_binder();
-
     let inputs_and_output =
         Tys::new_from_iter(DbInterner::new_with(db, None, None), params.chain(Some(ret)));
     EarlyBinder::bind(Binder::dummy(FnSig {
     let params = field_tys.iter().map(|(_, ty)| ty.skip_binder());
     let parent = def.lookup(db).parent;
     let ret = type_for_adt(db, parent.into()).skip_binder();
-
     let inputs_and_output =
         Tys::new_from_iter(DbInterner::new_with(db, None, None), params.chain(Some(ret)));
     EarlyBinder::bind(Binder::dummy(FnSig {
     }))
 }
 
-// FIXME(next-solver): should merge this with `explicit_item_bounds` in some way
 pub(crate) fn associated_ty_item_bounds<'db>(
     db: &'db dyn HirDatabase,
     type_alias: TypeAliasId,
     // FIXME: we should never create non-existential predicates in the first place
     // For now, use an error type so we don't run into dummy binder issues
     let self_ty = Ty::new_error(interner, ErrorGuaranteed);
-
     let mut bounds = Vec::new();
     for bound in &type_alias_data.bounds {
         ctx.lower_type_bound(bound, self_ty, false).for_each(|pred| {
             }
         });
     }
-
     if !ctx.unsized_types.contains(&self_ty)
         && let Some(sized_trait) = LangItem::Sized.resolve_trait(db, resolver.krate())
     {
         )));
         bounds.push(sized_clause);
     }
-
     EarlyBinder::bind(BoundExistentialPredicates::new_from_iter(interner, bounds))
 }
 
 #[tracing::instrument(skip(interner, check_alias))]
 fn named_associated_type_shorthand_candidates<'db, R>(
     interner: DbInterner<'db>,
-    // If the type parameter is defined in an impl and we're in a method, there
-    // might be additional where clauses to consider
     def: GenericDefId,
     res: TypeNs,
     assoc_name: Option<Name>,
 
         None
     };
-
     match res {
         TypeNs::SelfType(impl_id) => {
             let trait_ref = db.impl_trait(impl_id)?;