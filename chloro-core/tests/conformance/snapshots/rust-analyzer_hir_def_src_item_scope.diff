COMPARISON DIFF
============================================================

Original size: 33374 bytes
Chloro size:   32528 bytes
Rustfmt size:  33374 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     per_ns::{Item, MacrosItem, PerNs, TypesItem, ValuesItem},
     visibility::Visibility,
 };
-
 #[derive(Debug, Default)]
 pub struct PerNsGlobImports {
     types: FxHashSet<(LocalModuleId, Name)>,
     pub(crate) fn contains_type(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.types.contains(&(module_id, name))
     }
+
     pub(crate) fn contains_value(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.values.contains(&(module_id, name))
     }
+
     pub(crate) fn contains_macro(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.macros.contains(&(module_id, name))
     }
     values: FxIndexMap<Name, ValuesItem>,
     macros: FxIndexMap<Name, MacrosItem>,
     unresolved: FxHashSet<Name>,
-
     /// The defs declared in this scope. Each def has a single scope where it is
     /// declared.
     declarations: ThinVec<ModuleDefId>,
-
     impls: ThinVec<ImplId>,
     extern_blocks: ThinVec<ExternBlockId>,
     unnamed_consts: ThinVec<ConstId>,
     /// Traits imported via `use Trait as _;`.
     unnamed_trait_imports: ThinVec<(TraitId, Item<()>)>,
-
-    // the resolutions of the imports of this scope
     use_imports_types: FxHashMap<ImportOrExternCrate, ImportOrDef>,
     use_imports_values: FxHashMap<ImportOrGlob, ImportOrDef>,
     use_imports_macros: FxHashMap<ImportOrExternCrate, ImportOrDef>,
-
     use_decls: ThinVec<UseId>,
     extern_crate_decls: ThinVec<ExternCrateId>,
     /// Macros visible in current module in legacy textual scope
     /// Note that this automatically inherit macros defined textually before the definition of module itself.
     ///
     /// Module scoped macros will be inserted into `items` instead of here.
-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will
-    // be all resolved to the last one defined if shadowing happens.
     legacy_macros: FxHashMap<Name, SmallVec<[MacroId; 2]>>,
     /// The attribute macro invocations in this scope.
     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,
     derive_call_ids: SmallVec<[Option<MacroCallId>; 4]>,
 }
 
-pub(crate) static BUILTIN_SCOPE: LazyLock<FxIndexMap<Name, PerNs>> = LazyLock::new(|| {
+{
     BuiltinType::all_builtin_types()
         .iter()
         .map(|(name, ty)| (name.clone(), PerNs::types((*ty).into(), Visibility::Public, None)))
-        .collect()
-});
-
+        .collect();
+}
 /// Shadow mode for builtin type which can be shadowed by module.
 #[derive(Debug, Copy, Clone, PartialEq, Eq)]
 pub(crate) enum BuiltinShadowMode {
         self.values.iter().map(|(n, &i)| (n, i))
     }
 
-    pub fn types(
-        &self,
-    ) -> impl Iterator<Item = (&Name, Item<ModuleDefId, ImportOrExternCrate>)> + '_ {
+    pub fn types(&self) -> impl Iterator<Item = (&Name, Item<ModuleDefId, ImportOrExternCrate>)> + '_ {
         self.types.iter().map(|(n, &i)| (n, i))
     }
 
 
     pub fn fully_resolve_import(&self, db: &dyn DefDatabase, mut import: ImportId) -> PerNs {
         let mut res = PerNs::none();
-
         let mut def_map;
         let mut scope = self;
         while let Some(&m) = scope.use_imports_macros.get(&ImportOrExternCrate::Import(import)) {
     }
 
     /// XXX: this is O(N) rather than O(1), try to not introduce new usages.
-    pub(crate) fn names_of<T>(
-        &self,
-        item: ItemInNs,
-        mut cb: impl FnMut(&Name, Visibility, /*declared*/ bool) -> Option<T>,
-    ) -> Option<T> {
+    pub(crate) fn names_of<T>(&self, item: ItemInNs, mut cb: impl FnMut(&Name, Visibility, /*declared*/ bool) -> Option<T>) -> Option<T> {
         match item {
             ItemInNs::Macros(def) => self
                 .macros
         self.attr_macros.iter().map(|(k, v)| (*k, *v))
     }
 
-    pub(crate) fn set_derive_macro_invoc(
-        &mut self,
-        adt: AstId<ast::Adt>,
-        call: MacroCallId,
-        id: AttrId,
-        idx: usize,
-    ) {
+    pub(crate) fn set_derive_macro_invoc(&mut self, adt: AstId<ast::Adt>, call: MacroCallId, id: AttrId, idx: usize) {
         if let Some(derives) = self.derive_macros.get_mut(&adt)
             && let Some(DeriveMacroInvocation { derive_call_ids, .. }) =
                 derives.iter_mut().find(|&&mut DeriveMacroInvocation { attr_id, .. }| id == attr_id)
     /// We are required to set this up front as derive invocation recording happens out of order
     /// due to the fixed pointer iteration loop being able to record some derives later than others
     /// independent of their indices.
-    pub(crate) fn init_derive_attribute(
-        &mut self,
-        adt: AstId<ast::Adt>,
-        attr_id: AttrId,
-        attr_call_id: MacroCallId,
-        len: usize,
-    ) {
+    pub(crate) fn init_derive_attribute(&mut self, adt: AstId<ast::Adt>, attr_id: AttrId, attr_call_id: MacroCallId, len: usize) {
         self.derive_macros.entry(adt).or_default().push(DeriveMacroInvocation {
             attr_id,
             attr_call_id,
         });
     }
 
-    pub fn derive_macro_invocs(
-        &self,
-    ) -> impl Iterator<
+    pub fn derive_macro_invocs(&self) -> impl Iterator<
         Item = (
             AstId<ast::Adt>,
             impl Iterator<Item = (AttrId, MacroCallId, &[Option<MacroCallId>])>,
         })
     }
 
-    pub fn derive_macro_invoc(
-        &self,
-        ast_id: AstId<ast::Adt>,
-        attr_id: AttrId,
-    ) -> Option<MacroCallId> {
+    pub fn derive_macro_invoc(&self, ast_id: AstId<ast::Adt>, attr_id: AttrId) -> Option<MacroCallId> {
         Some(self.derive_macros.get(&ast_id)?.iter().find(|it| it.attr_id == attr_id)?.attr_call_id)
     }
 
-    // FIXME: This is only used in collection, we should move the relevant parts of it out of ItemScope
     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {
         self.unnamed_trait_imports.iter().find(|&&(t, _)| t == tr).map(|(_, trait_)| trait_.vis)
     }
 
-    pub(crate) fn push_unnamed_trait(
-        &mut self,
-        tr: TraitId,
-        vis: Visibility,
-        import: Option<ImportId>,
-    ) {
+    pub(crate) fn push_unnamed_trait(&mut self, tr: TraitId, vis: Visibility, import: Option<ImportId>) {
         self.unnamed_trait_imports.push((tr, Item { def: (), vis, import }));
     }
 
-    pub(crate) fn push_res_with_import(
-        &mut self,
-        glob_imports: &mut PerNsGlobImports,
-        lookup: (LocalModuleId, Name),
-        def: PerNs,
-        import: Option<ImportOrExternCrate>,
-    ) -> bool {
+    pub(crate) fn push_res_with_import(&mut self, glob_imports: &mut PerNsGlobImports, lookup: (LocalModuleId, Name), def: PerNs, import: Option<ImportOrExternCrate>) -> bool {
         let mut changed = false;
-
         // FIXME: Document and simplify this
-
         if let Some(mut fld) = def.types {
             let existing = self.types.entry(lookup.1.clone());
             match existing {
                 }
             }
         }
-
         if let Some(mut fld) = def.values {
             let existing = self.values.entry(lookup.1.clone());
             match existing {
                 _ => {}
             }
         }
-
         if let Some(mut fld) = def.macros {
             let existing = self.macros.entry(lookup.1.clone());
             match existing {
                 _ => {}
             }
         }
-
         if def.is_none() && self.unresolved.insert(lookup.1) {
             changed = true;
         }
-
         changed
     }
 
             .chain(self.values.values_mut().map(|def| &mut def.vis))
             .chain(self.unnamed_trait_imports.iter_mut().map(|(_, def)| &mut def.vis))
             .for_each(|vis| *vis = Visibility::PubCrate(krate));
-
         for mac in self.macros.values_mut() {
             if matches!(mac.def, MacroId::ProcMacroId(_) if mac.import.is_none()) {
                 continue;
     pub(crate) fn dump(&self, db: &dyn ExpandDatabase, buf: &mut String) {
         let mut entries: Vec<_> = self.resolutions().collect();
         entries.sort_by_key(|(name, _)| name.clone());
-
         for (name, def) in entries {
             format_to!(
                 buf,
     }
 }
 
-// These methods are a temporary measure only meant to be used by `DefCollector::push_res_and_update_glob_vis()`.
 impl ItemScope {
     pub(crate) fn update_visibility_types(&mut self, name: &Name, vis: Visibility) {
         let res =
 }
 
 impl PerNs {
-    pub(crate) fn from_def(
-        def: ModuleDefId,
-        v: Visibility,
-        has_constructor: bool,
-        import: Option<ImportOrExternCrate>,
-    ) -> PerNs {
+    pub(crate) fn from_def(def: ModuleDefId, v: Visibility, has_constructor: bool, import: Option<ImportOrExternCrate>) -> PerNs {
         match def {
             ModuleDefId::ModuleId(_) => PerNs::types(def, v, import),
             ModuleDefId::FunctionId(_) => {