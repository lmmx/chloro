COMPARISON DIFF
============================================================

Original size: 17943 bytes
Chloro size:   16620 bytes
Rustfmt size:  17943 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use rustc_hash::FxHashSet;
 
 use crate::RootDatabase;
-
 #[derive(Debug, Clone)]
 pub struct Query {
     query: String,
     krate.modules(db).into_iter().map(|module| SymbolIndex::module_symbols(db, module)).collect()
 }
 
-// Feature: Workspace Symbol
-//
-// Uses fuzzy-search to find types, modules and functions by name across your
-// project and dependencies. This is **the** most useful feature, which improves code
-// navigation tremendously. It mostly works on top of the built-in LSP
-// functionality, however `#` and `*` symbols can be used to narrow down the
-// search. Specifically,
-//
-// - `Foo` searches for `Foo` type in the current workspace
-// - `foo#` searches for `foo` function in the current workspace
-// - `Foo*` searches for `Foo` type among dependencies, including `stdlib`
-// - `foo#*` searches for `foo` function among dependencies
-//
-// That is, `#` switches from "types" to all symbols, `*` switches from the current
-// workspace to dependencies.
-//
-// Note that filtering does not currently work in VSCode due to the editor never
-// sending the special symbols to the language server. Instead, you can configure
-// the filtering via the `rust-analyzer.workspace.symbol.search.scope` and
-// `rust-analyzer.workspace.symbol.search.kind` settings. Symbols prefixed
-// with `__` are hidden from the search results unless configured otherwise.
-//
-// | Editor  | Shortcut |
-// |---------|-----------|
-// | VS Code | <kbd>Ctrl+T</kbd>
 pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {
     let _p = tracing::info_span!("world_symbols", query = ?query.query).entered();
-
     let indices: Vec<_> = if query.libs {
         LibraryRoots::get(db)
             .roots(db)
             crates.into_iter().map(|krate| crate_symbols(db, krate.into())).collect();
         indices.iter().flat_map(|indices| indices.iter().cloned()).collect()
     };
-
     let mut res = vec![];
     query.search::<()>(&indices, |f| {
         res.push(f.clone());
         struct InternedModuleId {
             id: hir::ModuleId,
         }
-
         #[salsa::tracked(returns(ref))]
         fn module_symbols(db: &dyn HirDatabase, module: InternedModuleId<'_>) -> SymbolIndex {
             let _p = tracing::info_span!("module_symbols").entered();
                 ))
             })
         }
-
         module_symbols(db, InternedModuleId::new(db, hir::ModuleId::from(module)))
     }
 }
     }
 }
 
-impl Eq for SymbolIndex {}
+impl Eq for SymbolIndex {
+}
 
 impl Hash for SymbolIndex {
     fn hash<H: Hasher>(&self, hasher: &mut H) {
             let rhs_chars = rhs.name.as_str().chars().map(|c| c.to_ascii_lowercase());
             lhs_chars.cmp(rhs_chars)
         }
-
         symbols.par_sort_by(cmp);
-
         let mut builder = fst::MapBuilder::memory();
-
         let mut last_batch_start = 0;
-
         for idx in 0..symbols.len() {
             if let Some(next_symbol) = symbols.get(idx + 1)
                 && cmp(&symbols[last_batch_start], next_symbol) == Ordering::Equal
 
             builder.insert(key, value).unwrap();
         }
-
         let map = builder
             .into_inner()
             .and_then(|mut buf| {
     fn range_to_map_value(start: usize, end: usize) -> u64 {
         debug_assert![start <= (u32::MAX as usize)];
         debug_assert![end <= (u32::MAX as usize)];
-
         ((start as u64) << 32) | end as u64
     }
 
 }
 
 impl Query {
-    pub(crate) fn search<'sym, T>(
-        self,
-        indices: &'sym [&SymbolIndex],
-        cb: impl FnMut(&'sym FileSymbol) -> ControlFlow<T>,
-    ) -> Option<T> {
+    pub(crate) fn search<'sym, T>(self, indices: &'sym [&SymbolIndex], cb: impl FnMut(&'sym FileSymbol) -> ControlFlow<T>) -> Option<T> {
         let _p = tracing::info_span!("symbol_index::Query::search").entered();
         let mut op = fst::map::OpBuilder::new();
         match self.mode {
         }
     }
 
-    fn search_maps<'sym, T>(
-        &self,
-        indices: &'sym [&SymbolIndex],
-        mut stream: fst::map::Union<'_>,
-        mut cb: impl FnMut(&'sym FileSymbol) -> ControlFlow<T>,
-    ) -> Option<T> {
+    fn search_maps<'sym, T>(&self, indices: &'sym [&SymbolIndex], mut stream: fst::map::Union<'_>, mut cb: impl FnMut(&'sym FileSymbol) -> ControlFlow<T>) -> Option<T> {
         let ignore_underscore_prefixed = !self.query.starts_with("__");
         while let Some((_, indexed_values)) = stream.next() {
             for &IndexedValue { index, value } in indexed_values {
 
 #[cfg(test)]
 mod tests {
-
     use expect_test::expect_file;
     use salsa::Setter;
     use test_fixture::{WORKSPACE, WithFixture};
-
     use super::*;
-
     #[test]
     fn test_symbol_index_collection() {
         let (db, _) = RootDatabase::with_many_files(
 pub(self) use crate::Trait as IsThisJustATrait;
 "#,
         );
-
         let symbols: Vec<_> = Crate::from(db.test_crate())
             .modules(&db)
             .into_iter()
                 (module_id, symbols)
             })
             .collect();
-
         expect_file!["./test_data/test_symbol_index_collection.txt"].assert_debug_eq(&symbols);
     }
-
     #[test]
     fn test_doc_alias() {
         let (db, _) = RootDatabase::with_single_file(
 struct Duplicate;
         "#,
         );
-
         let symbols: Vec<_> = Crate::from(db.test_crate())
             .modules(&db)
             .into_iter()
                 (module_id, symbols)
             })
             .collect();
-
         expect_file!["./test_data/test_doc_alias.txt"].assert_debug_eq(&symbols);
     }
-
     #[test]
     fn test_exclude_imports() {
         let (mut db, _) = RootDatabase::with_many_files(
 pub struct Foo;
 "#,
         );
-
         let mut local_roots = FxHashSet::default();
         local_roots.insert(WORKSPACE);
         LocalRoots::get(&db).set_roots(&mut db).to(local_roots);
-
         let mut query = Query::new("Foo".to_owned());
         let mut symbols = world_symbols(&db, query.clone());
         symbols.sort_by_key(|x| x.is_import);
         expect_file!["./test_data/test_symbols_with_imports.txt"].assert_debug_eq(&symbols);
-
         query.exclude_imports();
         let symbols = world_symbols(&db, query);
         expect_file!["./test_data/test_symbols_exclude_imports.txt"].assert_debug_eq(&symbols);