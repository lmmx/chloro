COMPARISON DIFF
============================================================

Original size: 11088 bytes
Chloro size:   11655 bytes
Rustfmt size:  11331 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! things. (That system should probably be refactored.)
 
 use rustc_type_ir::{
+    FnSig, GenericArgKind, TypeFoldable, TypingMode, Variance,
     error::ExpectedFound,
     inherent::{IntoKind, Span as _},
-    relate::{solver_relating::RelateExt, Relate, TypeRelation},
-    FnSig, GenericArgKind, TypeFoldable, TypingMode, Variance,
+    relate::{Relate, TypeRelation, solver_relating::RelateExt},
 };
 
 use crate::next_solver::{
-    fulfill::NextSolverError,
-    infer::relate::lattice::{LatticeOp, LatticeOpKind},
     AliasTerm, AliasTy, Binder, Const, DbInterner, GenericArg, Goal, ParamEnv,
     PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, Predicate, Region, Span, Term,
     TraitRef, Ty,
+    fulfill::NextSolverError,
+    infer::relate::lattice::{LatticeOp, LatticeOpKind},
 };
-
 use super::{
-    traits::{Obligation, ObligationCause},
     InferCtxt, InferOk, InferResult, TypeTrace, ValuePairs,
+    traits::{Obligation, ObligationCause},
 };
 
 #[derive(Clone, Copy)]
 
 impl<'db> InferCtxt<'db> {
     #[inline]
-    pub fn at<'a>(&'a self, cause: &'a ObligationCause, param_env: ParamEnv<'db>) -> At<'a, 'db> {
-        At {
-            infcx: self,
-            cause,
-            param_env,
-        }
+    pub fn at<'a>(
+        &'a self,
+        cause: &'a ObligationCause,
+        param_env: ParamEnv<'db>,
+    ) -> At<'a, 'db> {
+        At { infcx: self, cause, param_env }
     }
 
     /// Forks the inference context, creating a new inference context with the same inference
     /// Forks the inference context, creating a new inference context with the same inference
     /// variables in the same state, except possibly changing the intercrate mode. This can be
     /// used to "branch off" many tests from the same common state. Used in negative coherence.
-    pub fn fork_with_typing_mode(&self, typing_mode: TypingMode<DbInterner<'db>>) -> Self {
+    pub fn fork_with_typing_mode(
+        &self,
+        typing_mode: TypingMode<DbInterner<'db>>,
+    ) -> Self {
         // Unlike `fork`, this invalidates all cache entries as they may depend on the
         // typing mode.
-
         Self {
             interner: self.interner,
             typing_mode,
     }
 }
 
-pub trait ToTrace<'db>: Relate<DbInterner<'db>> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db>;
-}
-
+fn to_trace(
+    cause: &ObligationCause,
+    a: Self,
+    b: Self,
+) -> TypeTrace<'db>;
 impl<'a, 'db> At<'a, 'db> {
     /// Makes `actual <: expected`. For example, if type-checking a
     /// call like `foo(x)`, where `foo: fn(i32)`, you might have
     /// `sup(i32, x)`, since the "expected" type is the type that
     /// appears in the signature.
-    pub fn sup<T>(self, expected: T, actual: T) -> InferResult<'db, ()>
+    pub fn sup<T>(
+        self,
+        expected: T,
+        actual: T,
+    ) -> InferResult<'db, ()>
     where
-        T: ToTrace<'db>,
-    {
+        T: ToTrace<'db>, {
         RelateExt::relate(
             self.infcx,
             self.param_env,
     }
 
     /// Makes `expected <: actual`.
-    pub fn sub<T>(self, expected: T, actual: T) -> InferResult<'db, ()>
+    pub fn sub<T>(
+        self,
+        expected: T,
+        actual: T,
+    ) -> InferResult<'db, ()>
     where
-        T: ToTrace<'db>,
-    {
+        T: ToTrace<'db>, {
         RelateExt::relate(
             self.infcx,
             self.param_env,
     }
 
     /// Makes `expected == actual`.
-    pub fn eq<T>(self, expected: T, actual: T) -> InferResult<'db, ()>
+    pub fn eq<T>(
+        self,
+        expected: T,
+        actual: T,
+    ) -> InferResult<'db, ()>
     where
-        T: Relate<DbInterner<'db>>,
-    {
+        T: Relate<DbInterner<'db>>, {
         RelateExt::relate(
             self.infcx,
             self.param_env,
         .map(|goals| self.goals_to_obligations(goals))
     }
 
-    pub fn relate<T>(self, expected: T, variance: Variance, actual: T) -> InferResult<'db, ()>
+    pub fn relate<T>(
+        self,
+        expected: T,
+        variance: Variance,
+        actual: T,
+    ) -> InferResult<'db, ()>
     where
-        T: ToTrace<'db>,
-    {
+        T: ToTrace<'db>, {
         match variance {
             Variance::Covariant => self.sub(expected, actual),
             Variance::Invariant => self.eq(expected, actual),
 
     /// Deeply normalizes `value`, replacing all aliases which can by normalized in
     /// the current environment. This errors in case normalization fails or is ambiguous.
-    pub fn deeply_normalize<T>(self, value: T) -> Result<T, Vec<NextSolverError<'db>>>
+    pub fn deeply_normalize<T>(
+        self,
+        value: T,
+    ) -> Result<T, Vec<NextSolverError<'db>>>
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         crate::next_solver::normalize::deeply_normalize(self, value)
     }
 
     /// this can result in an error (e.g., if asked to compute LUB of
     /// u32 and i32), it is meaningful to call one of them the
     /// "expected type".
-    pub fn lub<T>(self, expected: T, actual: T) -> InferResult<'db, T>
+    pub fn lub<T>(
+        self,
+        expected: T,
+        actual: T,
+    ) -> InferResult<'db, T>
     where
-        T: ToTrace<'db>,
-    {
+        T: ToTrace<'db>, {
         let mut op = LatticeOp::new(
             self.infcx,
             ToTrace::to_trace(self.cause, expected, actual),
             LatticeOpKind::Lub,
         );
         let value = op.relate(expected, actual)?;
-        Ok(InferOk {
-            value,
-            obligations: op.into_obligations(),
-        })
+        Ok(InferOk { value, obligations: op.into_obligations() })
     }
 
-    fn goals_to_obligations(&self, goals: Vec<Goal<'db, Predicate<'db>>>) -> InferOk<'db, ()> {
+    fn goals_to_obligations(
+        &self,
+        goals: Vec<Goal<'db, Predicate<'db>>>,
+    ) -> InferOk<'db, ()> {
         InferOk {
             value: (),
             obligations: goals
 }
 
 impl<'db> ToTrace<'db> for Ty<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: ValuePairs::Terms(ExpectedFound::new(a.into(), b.into())),
 }
 
 impl<'db> ToTrace<'db> for Region<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
-        TypeTrace {
-            cause: cause.clone(),
-            values: ValuePairs::Regions(ExpectedFound::new(a, b)),
-        }
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
+        TypeTrace { cause: cause.clone(), values: ValuePairs::Regions(ExpectedFound::new(a, b)) }
     }
 }
 
 impl<'db> ToTrace<'db> for Const<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: ValuePairs::Terms(ExpectedFound::new(a.into(), b.into())),
 }
 
 impl<'db> ToTrace<'db> for GenericArg<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: match (a.kind(), b.kind()) {
 }
 
 impl<'db> ToTrace<'db> for Term<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
-        TypeTrace {
-            cause: cause.clone(),
-            values: ValuePairs::Terms(ExpectedFound::new(a, b)),
-        }
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
+        TypeTrace { cause: cause.clone(), values: ValuePairs::Terms(ExpectedFound::new(a, b)) }
     }
 }
 
 impl<'db> ToTrace<'db> for TraitRef<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
-        TypeTrace {
-            cause: cause.clone(),
-            values: ValuePairs::TraitRefs(ExpectedFound::new(a, b)),
-        }
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
+        TypeTrace { cause: cause.clone(), values: ValuePairs::TraitRefs(ExpectedFound::new(a, b)) }
     }
 }
 
 impl<'db> ToTrace<'db> for AliasTy<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: ValuePairs::Aliases(ExpectedFound::new(a.into(), b.into())),
 }
 
 impl<'db> ToTrace<'db> for AliasTerm<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
-        TypeTrace {
-            cause: cause.clone(),
-            values: ValuePairs::Aliases(ExpectedFound::new(a, b)),
-        }
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
+        TypeTrace { cause: cause.clone(), values: ValuePairs::Aliases(ExpectedFound::new(a, b)) }
     }
 }
 
 impl<'db> ToTrace<'db> for FnSig<DbInterner<'db>> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: ValuePairs::PolySigs(ExpectedFound::new(Binder::dummy(a), Binder::dummy(b))),
 }
 
 impl<'db> ToTrace<'db> for PolyFnSig<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
-        TypeTrace {
-            cause: cause.clone(),
-            values: ValuePairs::PolySigs(ExpectedFound::new(a, b)),
-        }
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
+        TypeTrace { cause: cause.clone(), values: ValuePairs::PolySigs(ExpectedFound::new(a, b)) }
     }
 }
 
 impl<'db> ToTrace<'db> for PolyExistentialTraitRef<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: ValuePairs::ExistentialTraitRef(ExpectedFound::new(a, b)),
 }
 
 impl<'db> ToTrace<'db> for PolyExistentialProjection<'db> {
-    fn to_trace(cause: &ObligationCause, a: Self, b: Self) -> TypeTrace<'db> {
+    fn to_trace(
+        cause: &ObligationCause,
+        a: Self,
+        b: Self,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: ValuePairs::ExistentialProjection(ExpectedFound::new(a, b)),