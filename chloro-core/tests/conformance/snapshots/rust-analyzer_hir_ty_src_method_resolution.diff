COMPARISON DIFF
============================================================

Original size: 65944 bytes
Chloro size:   63841 bytes
Rustfmt size:  65944 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! This module is concerned with finding methods that a given type provides.
 //! For details about how this works in rustc, see the method lookup page in the
 //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)
 //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.
+
 use std::ops::ControlFlow;
 
 use base_db::Crate;
     traits::next_trait_solve_canonical_in_ctxt,
     utils::all_super_traits,
 };
-
 /// This is used as a key for indexing impls.
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
 pub enum TyFingerprint {
-    // These are lang item impls:
     Str,
     Slice,
     Array,
     Int(IntTy),
     Uint(UintTy),
     Float(FloatTy),
-    // These can have user-defined impls:
     Adt(hir_def::AdtId),
     Dyn(TraitId),
     ForeignType(TypeAliasId),
-    // These only exist for trait impls
     Unit,
     Unnameable,
     Function(u32),
     }
 }
 
-pub(crate) const ALL_INT_FPS: [TyFingerprint; 12] = [
-    TyFingerprint::Int(IntTy::I8),
-    TyFingerprint::Int(IntTy::I16),
-    TyFingerprint::Int(IntTy::I32),
-    TyFingerprint::Int(IntTy::I64),
-    TyFingerprint::Int(IntTy::I128),
-    TyFingerprint::Int(IntTy::Isize),
-    TyFingerprint::Uint(UintTy::U8),
-    TyFingerprint::Uint(UintTy::U16),
-    TyFingerprint::Uint(UintTy::U32),
-    TyFingerprint::Uint(UintTy::U64),
-    TyFingerprint::Uint(UintTy::U128),
-    TyFingerprint::Uint(UintTy::Usize),
-];
 
-pub(crate) const ALL_FLOAT_FPS: [TyFingerprint; 4] = [
-    TyFingerprint::Float(FloatTy::F16),
-    TyFingerprint::Float(FloatTy::F32),
-    TyFingerprint::Float(FloatTy::F64),
-    TyFingerprint::Float(FloatTy::F128),
-];
 
 type TraitFpMap = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Box<[ImplId]>>>;
+
 type TraitFpMapCollector = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>;
 
 /// Trait impls defined or available in some crate.
 #[derive(Debug, Eq, PartialEq)]
 pub struct TraitImpls {
-    // If the `Option<TyFingerprint>` is `None`, the impl may apply to any self type.
     map: TraitFpMap,
 }
 
     pub(crate) fn trait_impls_in_crate_query(db: &dyn HirDatabase, krate: Crate) -> Arc<Self> {
         let _p = tracing::info_span!("trait_impls_in_crate_query", ?krate).entered();
         let mut impls = FxHashMap::default();
-
         Self::collect_def_map(db, &mut impls, crate_def_map(db, krate));
-
         Arc::new(Self::finish(impls))
     }
 
-    pub(crate) fn trait_impls_in_block_query(
-        db: &dyn HirDatabase,
-        block: BlockId,
-    ) -> Option<Arc<Self>> {
+    pub(crate) fn trait_impls_in_block_query(db: &dyn HirDatabase, block: BlockId) -> Option<Arc<Self>> {
         let _p = tracing::info_span!("trait_impls_in_block_query").entered();
         let mut impls = FxHashMap::default();
-
         Self::collect_def_map(db, &mut impls, block_def_map(db, block));
-
         if impls.is_empty() { None } else { Some(Arc::new(Self::finish(impls))) }
     }
 
-    pub(crate) fn trait_impls_in_deps_query(
-        db: &dyn HirDatabase,
-        krate: Crate,
-    ) -> Arc<[Arc<Self>]> {
+    pub(crate) fn trait_impls_in_deps_query(db: &dyn HirDatabase, krate: Crate) -> Arc<[Arc<Self>]> {
         let _p = tracing::info_span!("trait_impls_in_deps_query", ?krate).entered();
         Arc::from_iter(
             db.transitive_deps(krate).into_iter().map(|krate| db.trait_impls_in_crate(krate)),
     }
 
     /// Queries all trait impls for the given type.
-    pub fn for_self_ty_without_blanket_impls(
-        &self,
-        fp: TyFingerprint,
-    ) -> impl Iterator<Item = ImplId> + '_ {
+    pub fn for_self_ty_without_blanket_impls(&self, fp: TyFingerprint) -> impl Iterator<Item = ImplId> + '_ {
         self.map
             .values()
             .flat_map(move |impls| impls.get(&Some(fp)).into_iter())
     }
 
     /// Queries all impls of `trait_` that may apply to `self_ty`.
-    pub fn for_trait_and_self_ty(
-        &self,
-        trait_: TraitId,
-        self_ty: TyFingerprint,
-    ) -> impl Iterator<Item = ImplId> + '_ {
+    pub fn for_trait_and_self_ty(&self, trait_: TraitId, self_ty: TyFingerprint) -> impl Iterator<Item = ImplId> + '_ {
         self.map
             .get(&trait_)
             .into_iter()
     pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: Crate) -> Arc<Self> {
         let _p = tracing::info_span!("inherent_impls_in_crate_query", ?krate).entered();
         let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };
-
         let crate_def_map = crate_def_map(db, krate);
         impls.collect_def_map(db, crate_def_map);
         impls.shrink_to_fit();
-
         Arc::new(impls)
     }
 
-    pub(crate) fn inherent_impls_in_block_query(
-        db: &dyn HirDatabase,
-        block: BlockId,
-    ) -> Option<Arc<Self>> {
+    pub(crate) fn inherent_impls_in_block_query(db: &dyn HirDatabase, block: BlockId) -> Option<Arc<Self>> {
         let _p = tracing::info_span!("inherent_impls_in_block_query").entered();
         let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };
-
         let block_def_map = block_def_map(db, block);
         impls.collect_def_map(db, block_def_map);
         impls.shrink_to_fit();
-
         if impls.map.is_empty() && impls.invalid_impls.is_empty() {
             None
         } else {
     }
 }
 
-pub(crate) fn incoherent_inherent_impl_crates(
-    db: &dyn HirDatabase,
-    krate: Crate,
-    fp: TyFingerprint,
-) -> SmallVec<[Crate; 2]> {
+pub(crate) fn incoherent_inherent_impl_crates(db: &dyn HirDatabase, krate: Crate, fp: TyFingerprint) -> SmallVec<[Crate; 2]> {
     let _p = tracing::info_span!("incoherent_inherent_impl_crates").entered();
     let mut res = SmallVec::new();
-
     // should pass crate for finger print and do reverse deps
-
     for krate in db.transitive_deps(krate) {
         let impls = db.inherent_impls_in_crate(krate);
         if impls.map.get(&fp).is_some_and(|v| !v.is_empty()) {
             res.push(krate);
         }
     }
-
     res
 }
 
-pub fn def_crates<'db>(
-    db: &'db dyn HirDatabase,
-    ty: Ty<'db>,
-    cur_crate: Crate,
-) -> Option<SmallVec<[Crate; 2]>> {
+pub fn def_crates<'db>(db: &'db dyn HirDatabase, ty: Ty<'db>, cur_crate: Crate) -> Option<SmallVec<[Crate; 2]>> {
     match ty.kind() {
         TyKind::Adt(adt_def, _) => {
             let def_id = adt_def.def_id().0;
 }
 
 /// Look up the method with the given name.
-pub(crate) fn lookup_method<'db>(
-    ty: &Canonical<'db, Ty<'db>>,
-    table: &mut InferenceTable<'db>,
-    traits_in_scope: &FxHashSet<TraitId>,
-    visible_from_module: VisibleFromModule,
-    name: &Name,
-) -> Option<(ReceiverAdjustments, FunctionId, bool)> {
+pub(crate) fn lookup_method<'db>(ty: &Canonical<'db, Ty<'db>>, table: &mut InferenceTable<'db>, traits_in_scope: &FxHashSet<TraitId>, visible_from_module: VisibleFromModule, name: &Name) -> Option<(ReceiverAdjustments, FunctionId, bool)> {
     let mut not_visible = None;
     let res = iterate_method_candidates(
         ty,
 }
 
 impl ReceiverAdjustments {
-    pub(crate) fn apply<'db>(
-        &self,
-        table: &mut InferenceTable<'db>,
-        mut ty: Ty<'db>,
-    ) -> (Ty<'db>, Vec<Adjustment<'db>>) {
+    pub(crate) fn apply<'db>(&self, table: &mut InferenceTable<'db>, mut ty: Ty<'db>) -> (Ty<'db>, Vec<Adjustment<'db>>) {
         let mut adjust = Vec::new();
         let mut autoderef = table.autoderef(ty);
         autoderef.next();
     }
 }
 
-// This would be nicer if it just returned an iterator, but that runs into
-// lifetime problems, because we need to borrow temp `CrateImplDefs`.
-// FIXME add a context type here?
-pub(crate) fn iterate_method_candidates<'db, T>(
-    ty: &Canonical<'db, Ty<'db>>,
-    table: &mut InferenceTable<'db>,
-    traits_in_scope: &FxHashSet<TraitId>,
-    visible_from_module: VisibleFromModule,
-    name: Option<&Name>,
-    mode: LookupMode,
-    mut callback: impl FnMut(ReceiverAdjustments, AssocItemId, bool) -> Option<T>,
-) -> Option<T> {
+pub(crate) fn iterate_method_candidates<'db, T>(ty: &Canonical<'db, Ty<'db>>, table: &mut InferenceTable<'db>, traits_in_scope: &FxHashSet<TraitId>, visible_from_module: VisibleFromModule, name: Option<&Name>, mode: LookupMode, mut callback: impl FnMut(ReceiverAdjustments, AssocItemId, bool) -> Option<T>) -> Option<T> {
     let mut slot = None;
     _ = iterate_method_candidates_dyn_impl(
         ty,
     slot
 }
 
-pub fn lookup_impl_const<'db>(
-    infcx: &InferCtxt<'db>,
-    env: Arc<TraitEnvironment<'db>>,
-    const_id: ConstId,
-    subs: GenericArgs<'db>,
-) -> (ConstId, GenericArgs<'db>) {
+pub fn lookup_impl_const<'db>(infcx: &InferCtxt<'db>, env: Arc<TraitEnvironment<'db>>, const_id: ConstId, subs: GenericArgs<'db>) -> (ConstId, GenericArgs<'db>) {
     let interner = infcx.interner;
     let db = interner.db;
-
     let trait_id = match const_id.lookup(db).container {
         ItemContainerId::TraitId(id) => id,
         _ => return (const_id, subs),
     };
     let trait_ref = TraitRef::new(interner, trait_id.into(), subs);
-
     let const_signature = db.const_signature(const_id);
     let name = match const_signature.name.as_ref() {
         Some(name) => name,
         None => return (const_id, subs),
     };
-
     lookup_impl_assoc_item_for_trait_ref(infcx, trait_ref, env, name)
         .and_then(
             |assoc| if let (AssocItemId::ConstId(id), s) = assoc { Some((id, s)) } else { None },
 
 /// Checks if the self parameter of `Trait` method is the `dyn Trait` and we should
 /// call the method using the vtable.
-pub fn is_dyn_method<'db>(
-    interner: DbInterner<'db>,
-    _env: Arc<TraitEnvironment<'db>>,
-    func: FunctionId,
-    fn_subst: GenericArgs<'db>,
-) -> Option<usize> {
+pub fn is_dyn_method<'db>(interner: DbInterner<'db>, _env: Arc<TraitEnvironment<'db>>, func: FunctionId, fn_subst: GenericArgs<'db>) -> Option<usize> {
     let db = interner.db;
-
     let ItemContainerId::TraitId(trait_id) = func.lookup(db).container else {
         return None;
     };
 /// Looks up the impl method that actually runs for the trait method `func`.
 ///
 /// Returns `func` if it's not a method defined in a trait or the lookup failed.
-pub(crate) fn lookup_impl_method_query<'db>(
-    db: &'db dyn HirDatabase,
-    env: Arc<TraitEnvironment<'db>>,
-    func: FunctionId,
-    fn_subst: GenericArgs<'db>,
-) -> (FunctionId, GenericArgs<'db>) {
+pub(crate) fn lookup_impl_method_query<'db>(db: &'db dyn HirDatabase, env: Arc<TraitEnvironment<'db>>, func: FunctionId, fn_subst: GenericArgs<'db>) -> (FunctionId, GenericArgs<'db>) {
     let interner = DbInterner::new_with(db, Some(env.krate), env.block);
     let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
-
     let ItemContainerId::TraitId(trait_id) = func.lookup(db).container else {
         return (func, fn_subst);
     };
         trait_id.into(),
         GenericArgs::new_from_iter(interner, fn_subst.iter().take(trait_params)),
     );
-
     let name = &db.function_signature(func).name;
     let Some((impl_fn, impl_subst)) =
         lookup_impl_assoc_item_for_trait_ref(&infcx, trait_ref, env, name).and_then(|assoc| {
     else {
         return (func, fn_subst);
     };
-
     (
         impl_fn,
         GenericArgs::new_from_iter(
     )
 }
 
-fn lookup_impl_assoc_item_for_trait_ref<'db>(
-    infcx: &InferCtxt<'db>,
-    trait_ref: TraitRef<'db>,
-    env: Arc<TraitEnvironment<'db>>,
-    name: &Name,
-) -> Option<(AssocItemId, GenericArgs<'db>)> {
+fn lookup_impl_assoc_item_for_trait_ref<'db>(infcx: &InferCtxt<'db>, trait_ref: TraitRef<'db>, env: Arc<TraitEnvironment<'db>>, name: &Name) -> Option<(AssocItemId, GenericArgs<'db>)> {
     let (impl_id, impl_subst) = find_matching_impl(infcx, &env, trait_ref)?;
     let item =
         impl_id.impl_items(infcx.interner.db).items.iter().find_map(|(n, it)| match *it {
     Some((item, impl_subst))
 }
 
-pub(crate) fn find_matching_impl<'db>(
-    infcx: &InferCtxt<'db>,
-    env: &TraitEnvironment<'db>,
-    trait_ref: TraitRef<'db>,
-) -> Option<(ImplId, GenericArgs<'db>)> {
+pub(crate) fn find_matching_impl<'db>(infcx: &InferCtxt<'db>, env: &TraitEnvironment<'db>, trait_ref: TraitRef<'db>) -> Option<(ImplId, GenericArgs<'db>)> {
     let trait_ref =
         infcx.at(&ObligationCause::dummy(), env.env).deeply_normalize(trait_ref).ok()?;
-
     let obligation = Obligation::new(infcx.interner, ObligationCause::dummy(), env.env, trait_ref);
-
     let selection = infcx.select(&obligation).ok()??;
-
     // Currently, we use a fulfillment context to completely resolve
     // all nested obligations. This is because they can inform the
     // inference of the impl's type parameters.
     let mut ocx = ObligationCtxt::new(infcx);
     let impl_source = selection.map(|obligation| ocx.register_obligation(obligation));
-
     let errors = ocx.evaluate_obligations_error_on_ambiguity();
     if !errors.is_empty() {
         return None;
     }
-
     let impl_source = infcx.resolve_vars_if_possible(impl_source);
     if impl_source.has_non_region_infer() {
         return None;
     }
-
     match impl_source {
         ImplSource::UserDefined(impl_source) => Some((impl_source.impl_def_id, impl_source.args)),
         ImplSource::Param(_) | ImplSource::Builtin(..) => None,
     }
 }
 
-fn is_inherent_impl_coherent<'db>(
-    db: &'db dyn HirDatabase,
-    def_map: &DefMap,
-    impl_id: ImplId,
-    self_ty: Ty<'db>,
-) -> bool {
+fn is_inherent_impl_coherent<'db>(db: &'db dyn HirDatabase, def_map: &DefMap, impl_id: ImplId, self_ty: Ty<'db>) -> bool {
     let self_ty = self_ty.kind();
     let impl_allowed = match self_ty {
         TyKind::Tuple(_)
         // not a trait impl
         return true;
     };
-
     let local_crate = impl_.lookup(db).container.krate();
     let is_local = |tgt_crate| tgt_crate == local_crate;
-
     let trait_ref = impl_trait.instantiate_identity();
     let trait_id = trait_ref.def_id.0;
     if is_local(trait_id.module(db).krate()) {
         // trait to be implemented is local
         return true;
     }
-
     let unwrap_fundamental = |mut ty: Ty<'db>| {
         // Unwrap all layers of fundamental types with a loop.
         loop {
         }
     };
     //   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
-
     // FIXME: param coverage
     //   - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti`` (excluding `Ti`)
     let is_not_orphan = trait_ref.args.types().any(|ty| match unwrap_fundamental(ty).kind() {
 }
 
 /// To be used from `hir` only.
-pub fn iterate_path_candidates<'db>(
-    ty: &Canonical<'db, Ty<'db>>,
-    db: &'db dyn HirDatabase,
-    env: Arc<TraitEnvironment<'db>>,
-    traits_in_scope: &FxHashSet<TraitId>,
-    visible_from_module: VisibleFromModule,
-    name: Option<&Name>,
-    callback: &mut dyn MethodCandidateCallback,
-) -> ControlFlow<()> {
+pub fn iterate_path_candidates<'db>(ty: &Canonical<'db, Ty<'db>>, db: &'db dyn HirDatabase, env: Arc<TraitEnvironment<'db>>, traits_in_scope: &FxHashSet<TraitId>, visible_from_module: VisibleFromModule, name: Option<&Name>, callback: &mut dyn MethodCandidateCallback) -> ControlFlow<()> {
     iterate_method_candidates_dyn(
         ty,
         db,
 }
 
 /// To be used from `hir` only.
-pub fn iterate_method_candidates_dyn<'db>(
-    ty: &Canonical<'db, Ty<'db>>,
-    db: &'db dyn HirDatabase,
-    env: Arc<TraitEnvironment<'db>>,
-    traits_in_scope: &FxHashSet<TraitId>,
-    visible_from_module: VisibleFromModule,
-    name: Option<&Name>,
-    mode: LookupMode,
-    callback: &mut dyn MethodCandidateCallback,
-) -> ControlFlow<()> {
+pub fn iterate_method_candidates_dyn<'db>(ty: &Canonical<'db, Ty<'db>>, db: &'db dyn HirDatabase, env: Arc<TraitEnvironment<'db>>, traits_in_scope: &FxHashSet<TraitId>, visible_from_module: VisibleFromModule, name: Option<&Name>, mode: LookupMode, callback: &mut dyn MethodCandidateCallback) -> ControlFlow<()> {
     iterate_method_candidates_dyn_impl(
         ty,
         &mut InferenceTable::new(db, env, None),
     )
 }
 
-fn iterate_method_candidates_dyn_impl<'db>(
-    ty: &Canonical<'db, Ty<'db>>,
-    table: &mut InferenceTable<'db>,
-    traits_in_scope: &FxHashSet<TraitId>,
-    visible_from_module: VisibleFromModule,
-    name: Option<&Name>,
-    mode: LookupMode,
-    callback: &mut dyn MethodCandidateCallback,
-) -> ControlFlow<()> {
+fn iterate_method_candidates_dyn_impl<'db>(ty: &Canonical<'db, Ty<'db>>, table: &mut InferenceTable<'db>, traits_in_scope: &FxHashSet<TraitId>, visible_from_module: VisibleFromModule, name: Option<&Name>, mode: LookupMode, callback: &mut dyn MethodCandidateCallback) -> ControlFlow<()> {
     let _p = tracing::info_span!(
         "iterate_method_candidates_dyn",
         ?mode,
         traits_in_scope_len = traits_in_scope.len()
     )
     .entered();
-
     match mode {
         LookupMode::MethodCall => {
             // For method calls, rust first does any number of autoderef, and
 }
 
 #[tracing::instrument(skip_all, fields(name = ?name))]
-fn iterate_method_candidates_with_autoref<'db>(
-    table: &mut InferenceTable<'db>,
-    receiver_ty: Canonical<'db, Ty<'db>>,
-    first_adjustment: ReceiverAdjustments,
-    traits_in_scope: &FxHashSet<TraitId>,
-    visible_from_module: VisibleFromModule,
-    name: Option<&Name>,
-    callback: &mut dyn MethodCandidateCallback,
-) -> ControlFlow<()> {
+fn iterate_method_candidates_with_autoref<'db>(table: &mut InferenceTable<'db>, receiver_ty: Canonical<'db, Ty<'db>>, first_adjustment: ReceiverAdjustments, traits_in_scope: &FxHashSet<TraitId>, visible_from_module: VisibleFromModule, name: Option<&Name>, callback: &mut dyn MethodCandidateCallback) -> ControlFlow<()> {
     let interner = table.interner();
-
     let mut iterate_method_candidates_by_receiver = move |receiver_ty, first_adjustment| {
         iterate_method_candidates_by_receiver(
             table,
             callback,
         )
     };
-
     let mut maybe_reborrowed = first_adjustment.clone();
     if let TyKind::Ref(_, _, m) = receiver_ty.value.kind() {
         // Prefer reborrow of references to move
         maybe_reborrowed.autoref = Some(AutorefOrPtrAdjustment::Autoref(m));
         maybe_reborrowed.autoderefs += 1;
     }
-
     iterate_method_candidates_by_receiver(receiver_ty, maybe_reborrowed)?;
-
     let refed = Canonical {
         max_universe: receiver_ty.max_universe,
         variables: receiver_ty.variables,
         value: Ty::new_ref(interner, Region::error(interner), receiver_ty.value, Mutability::Not),
     };
-
     iterate_method_candidates_by_receiver(
         refed,
         first_adjustment.with_autoref(AutorefOrPtrAdjustment::Autoref(Mutability::Not)),
     )?;
-
     let ref_muted = Canonical {
         max_universe: receiver_ty.max_universe,
         variables: receiver_ty.variables,
         value: Ty::new_ref(interner, Region::error(interner), receiver_ty.value, Mutability::Mut),
     };
-
     iterate_method_candidates_by_receiver(
         ref_muted,
         first_adjustment.with_autoref(AutorefOrPtrAdjustment::Autoref(Mutability::Mut)),
     )?;
-
     if let TyKind::RawPtr(ty, Mutability::Mut) = receiver_ty.value.kind() {
         let const_ptr_ty = rustc_type_ir::Canonical {
             max_universe: rustc_type_ir::UniverseIndex::ZERO,
             first_adjustment.with_autoref(AutorefOrPtrAdjustment::ToConstPtr),
         )?;
     }
-
     ControlFlow::Continue(())
 }
 
-pub trait MethodCandidateCallback {
-    fn on_inherent_method(
-        &mut self,
-        adjustments: ReceiverAdjustments,
-        item: AssocItemId,
-        is_visible: bool,
-    ) -> ControlFlow<()>;
-
-    fn on_trait_method(
-        &mut self,
-        adjustments: ReceiverAdjustments,
-        item: AssocItemId,
-        is_visible: bool,
-    ) -> ControlFlow<()>;
-}
+fn on_inherent_method(&mut self, adjustments: ReceiverAdjustments, item: AssocItemId, is_visible: bool) -> ControlFlow<()>;
+fn on_trait_method(&mut self, adjustments: ReceiverAdjustments, item: AssocItemId, is_visible: bool) -> ControlFlow<()>;
 
 impl<F> MethodCandidateCallback for F
 where
-    F: FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,
-{
-    fn on_inherent_method(
-        &mut self,
-        adjustments: ReceiverAdjustments,
-        item: AssocItemId,
-        is_visible: bool,
-    ) -> ControlFlow<()> {
+    F: FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>, {
+    fn on_inherent_method(&mut self, adjustments: ReceiverAdjustments, item: AssocItemId, is_visible: bool) -> ControlFlow<()> {
         self(adjustments, item, is_visible)
     }
 
-    fn on_trait_method(
-        &mut self,
-        adjustments: ReceiverAdjustments,
-        item: AssocItemId,
-        is_visible: bool,
-    ) -> ControlFlow<()> {
+    fn on_trait_method(&mut self, adjustments: ReceiverAdjustments, item: AssocItemId, is_visible: bool) -> ControlFlow<()> {
         self(adjustments, item, is_visible)
     }
 }
 
 #[tracing::instrument(skip_all, fields(name = ?name))]
-fn iterate_method_candidates_by_receiver<'db>(
-    table: &mut InferenceTable<'db>,
-    receiver_ty: Canonical<'db, Ty<'db>>,
-    receiver_adjustments: ReceiverAdjustments,
-    traits_in_scope: &FxHashSet<TraitId>,
-    visible_from_module: VisibleFromModule,
-    name: Option<&Name>,
-    callback: &mut dyn MethodCandidateCallback,
-) -> ControlFlow<()> {
+fn iterate_method_candidates_by_receiver<'db>(table: &mut InferenceTable<'db>, receiver_ty: Canonical<'db, Ty<'db>>, receiver_adjustments: ReceiverAdjustments, traits_in_scope: &FxHashSet<TraitId>, visible_from_module: VisibleFromModule, name: Option<&Name>, callback: &mut dyn MethodCandidateCallback) -> ControlFlow<()> {
     let receiver_ty = table.instantiate_canonical(receiver_ty);
     // We're looking for methods with *receiver* type receiver_ty. These could
     // be found in any of the derefs of receiver_ty, so we have to go through
 }
 
 #[tracing::instrument(skip_all, fields(name = ?name))]
-fn iterate_method_candidates_for_self_ty<'db>(
-    self_ty: &Canonical<'db, Ty<'db>>,
-    table: &mut InferenceTable<'db>,
-    traits_in_scope: &FxHashSet<TraitId>,
-    visible_from_module: VisibleFromModule,
-    name: Option<&Name>,
-    callback: &mut dyn MethodCandidateCallback,
-) -> ControlFlow<()> {
+fn iterate_method_candidates_for_self_ty<'db>(self_ty: &Canonical<'db, Ty<'db>>, table: &mut InferenceTable<'db>, traits_in_scope: &FxHashSet<TraitId>, visible_from_module: VisibleFromModule, name: Option<&Name>, callback: &mut dyn MethodCandidateCallback) -> ControlFlow<()> {
     table.run_in_snapshot(|table| {
         let self_ty = table.instantiate_canonical(*self_ty);
         iterate_inherent_methods(
 }
 
 #[tracing::instrument(skip_all, fields(name = ?name, visible_from_module, receiver_ty))]
-fn iterate_trait_method_candidates<'db>(
-    self_ty: Ty<'db>,
-    table: &mut InferenceTable<'db>,
-    traits_in_scope: &FxHashSet<TraitId>,
-    name: Option<&Name>,
-    receiver_ty: Option<Ty<'db>>,
-    receiver_adjustments: Option<ReceiverAdjustments>,
-    mode: LookupMode,
-    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,
-) -> ControlFlow<()> {
+fn iterate_trait_method_candidates<'db>(self_ty: Ty<'db>, table: &mut InferenceTable<'db>, traits_in_scope: &FxHashSet<TraitId>, name: Option<&Name>, receiver_ty: Option<Ty<'db>>, receiver_adjustments: Option<ReceiverAdjustments>, mode: LookupMode, callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>) -> ControlFlow<()> {
     let db = table.db;
-
     let canonical_self_ty = table.canonicalize(self_ty);
     let krate = table.trait_env.krate;
-
     'traits: for &t in traits_in_scope {
         let data = db.trait_signature(t);
 
 }
 
 #[tracing::instrument(skip_all, fields(name = ?name, visible_from_module, receiver_ty))]
-fn iterate_inherent_methods<'db>(
-    self_ty: Ty<'db>,
-    table: &mut InferenceTable<'db>,
-    name: Option<&Name>,
-    receiver_ty: Option<Ty<'db>>,
-    receiver_adjustments: Option<ReceiverAdjustments>,
-    visible_from_module: VisibleFromModule,
-    mode: LookupMode,
-    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,
-) -> ControlFlow<()> {
+fn iterate_inherent_methods<'db>(self_ty: Ty<'db>, table: &mut InferenceTable<'db>, name: Option<&Name>, receiver_ty: Option<Ty<'db>>, receiver_adjustments: Option<ReceiverAdjustments>, visible_from_module: VisibleFromModule, mode: LookupMode, callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>) -> ControlFlow<()> {
     let db = table.db;
     let env = table.trait_env.clone();
-
     // For trait object types and placeholder types with trait bounds, the methods of the trait and
     // its super traits are considered inherent methods. This matters because these methods have
     // higher priority than the other traits' methods, which would be considered in
         }
         _ => {}
     }
-
     let def_crates = match def_crates(db, self_ty, env.krate) {
         Some(k) => k,
         None => return ControlFlow::Continue(()),
     };
-
     let (module, mut block) = match visible_from_module {
         VisibleFromModule::Filter(module) => (Some(module), module.containing_block()),
         VisibleFromModule::IncludeBlock(block) => (None, Some(block)),
         VisibleFromModule::None => (None, None),
     };
-
     while let Some(block_id) = block {
         if let Some(impls) = db.inherent_impls_in_block(block_id) {
             impls_for_self_ty(
 
         block = block_def_map(db, block_id).parent().and_then(|module| module.containing_block());
     }
-
     for krate in def_crates {
         let impls = db.inherent_impls_in_crate(krate);
         impls_for_self_ty(
         )?;
     }
     return ControlFlow::Continue(());
-
     #[tracing::instrument(skip_all, fields(name = ?name, visible_from_module, receiver_ty))]
     fn iterate_inherent_trait_methods<'db>(
         self_ty: Ty<'db>,
         }
         ControlFlow::Continue(())
     }
-
     #[tracing::instrument(skip_all, fields(name = ?name, visible_from_module, receiver_ty))]
     fn impls_for_self_ty<'db>(
         impls: &InherentImpls,
 }
 
 /// Returns the receiver type for the index trait call.
-pub(crate) fn resolve_indexing_op<'db>(
-    table: &mut InferenceTable<'db>,
-    ty: Canonical<'db, Ty<'db>>,
-    index_trait: TraitId,
-) -> Option<ReceiverAdjustments> {
+pub(crate) fn resolve_indexing_op<'db>(table: &mut InferenceTable<'db>, ty: Canonical<'db, Ty<'db>>, index_trait: TraitId) -> Option<ReceiverAdjustments> {
     let ty = table.instantiate_canonical(ty);
     let deref_chain = autoderef_method_receiver(table, ty);
     for (ty, adj) in deref_chain {
 }
 
 #[tracing::instrument(skip_all, fields(name))]
-fn is_valid_impl_method_candidate<'db>(
-    table: &mut InferenceTable<'db>,
-    self_ty: Ty<'db>,
-    receiver_ty: Option<Ty<'db>>,
-    visible_from_module: Option<ModuleId>,
-    name: Option<&Name>,
-    impl_id: ImplId,
-    item: AssocItemId,
-    item_name: &Name,
-) -> IsValidCandidate {
+fn is_valid_impl_method_candidate<'db>(table: &mut InferenceTable<'db>, self_ty: Ty<'db>, receiver_ty: Option<Ty<'db>>, visible_from_module: Option<ModuleId>, name: Option<&Name>, impl_id: ImplId, item: AssocItemId, item_name: &Name) -> IsValidCandidate {
     match item {
         AssocItemId::FunctionId(f) => is_valid_impl_fn_candidate(
             table,
 
 /// Checks whether a given `AssocItemId` is applicable for `receiver_ty`.
 #[tracing::instrument(skip_all, fields(name))]
-fn is_valid_trait_method_candidate<'db>(
-    table: &mut InferenceTable<'db>,
-    trait_id: TraitId,
-    name: Option<&Name>,
-    receiver_ty: Option<Ty<'db>>,
-    item: AssocItemId,
-    self_ty: Ty<'db>,
-    mode: LookupMode,
-) -> IsValidCandidate {
+fn is_valid_trait_method_candidate<'db>(table: &mut InferenceTable<'db>, trait_id: TraitId, name: Option<&Name>, receiver_ty: Option<Ty<'db>>, item: AssocItemId, self_ty: Ty<'db>, mode: LookupMode) -> IsValidCandidate {
     let db = table.db;
     match item {
         AssocItemId::FunctionId(fn_id) => {
 }
 
 #[tracing::instrument(skip_all, fields(name))]
-fn is_valid_impl_fn_candidate<'db>(
-    table: &mut InferenceTable<'db>,
-    impl_id: ImplId,
-    fn_id: FunctionId,
-    name: Option<&Name>,
-    receiver_ty: Option<Ty<'db>>,
-    self_ty: Ty<'db>,
-    visible_from_module: Option<ModuleId>,
-    item_name: &Name,
-) -> IsValidCandidate {
+fn is_valid_impl_fn_candidate<'db>(table: &mut InferenceTable<'db>, impl_id: ImplId, fn_id: FunctionId, name: Option<&Name>, receiver_ty: Option<Ty<'db>>, self_ty: Ty<'db>, visible_from_module: Option<ModuleId>, item_name: &Name) -> IsValidCandidate {
     check_that!(name.is_none_or(|n| n == item_name));
-
     let db = table.db;
     let data = db.function_signature(fn_id);
-
     if let Some(from_module) = visible_from_module
         && !db.assoc_visibility(fn_id.into()).is_visible_from(db, from_module)
     {
 /// This creates Substs for a trait with the given Self type and type variables
 /// for all other parameters, to query the trait solver with it.
 #[tracing::instrument(skip_all)]
-fn generic_implements_goal_ns<'db>(
-    table: &mut InferenceTable<'db>,
-    trait_: TraitId,
-    self_ty: Canonical<'db, Ty<'db>>,
-) -> Canonical<'db, Goal<'db, Predicate<'db>>> {
+fn generic_implements_goal_ns<'db>(table: &mut InferenceTable<'db>, trait_: TraitId, self_ty: Canonical<'db, Ty<'db>>) -> Canonical<'db, Goal<'db, Predicate<'db>>> {
     let args = table.infer_ctxt.fresh_args_for_item(SolverDefId::TraitId(trait_));
     let self_ty = table.instantiate_canonical(self_ty);
     let trait_ref =
         rustc_type_ir::TraitRef::new_from_args(table.infer_ctxt.interner, trait_.into(), args)
             .with_replaced_self_ty(table.infer_ctxt.interner, self_ty);
     let goal = Goal::new(table.infer_ctxt.interner, table.trait_env.env, trait_ref);
-
     table.canonicalize(goal)
 }
 
-fn autoderef_method_receiver<'db>(
-    table: &mut InferenceTable<'db>,
-    ty: Ty<'db>,
-) -> Vec<(Canonical<'db, Ty<'db>>, ReceiverAdjustments)> {
+fn autoderef_method_receiver<'db>(table: &mut InferenceTable<'db>, ty: Ty<'db>) -> Vec<(Canonical<'db, Ty<'db>>, ReceiverAdjustments)> {
     let interner = table.interner();
     let mut deref_chain = Vec::new();
     let mut autoderef = autoderef::Autoderef::new_no_tracking(table, ty).use_receiver_trait();