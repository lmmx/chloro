COMPARISON DIFF
============================================================

Original size: 12822 bytes
Chloro size:   12783 bytes
Rustfmt size:  12822 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# Hello\n\n?\n\n## World\n\n??").unwrap();
     let path = file.path().to_path_buf();
-
     // Create sections matching the file
     let sections = vec![
         Section {
             rhs_content: None,
         },
     ];
-
     let mut app = AppState::new(vec![path.clone()], sections, 100);
-
     // Find first navigable node (should be first section)
     if let Some(first) = app.navigate_to_first() {
         app.current_node_index = first;
     }
-
     // Enter detail view for first section
     app.enter_detail_view();
-
     // Simulate editing: replace "?" with "Yeah"
     if let Some(ref mut editor_state) = app.editor_state {
         editor_state.lines = edtui::Lines::from("\nYeah\n");
     }
-
     // Save
     app.save_current().unwrap();
-
     // Verify file content
     let content = fs::read_to_string(&path).unwrap();
     let lines: Vec<&str> = content.lines().collect();
-
     println!("{lines:?}");
-
     assert_eq!(
         lines,
         vec!["# Hello", "", "", "Yeah", "", "## World", "", "??"]
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# Test\n\nOriginal").unwrap();
     let path = file.path().to_path_buf();
-
     let sections = vec![Section {
         title: "Test".to_string(),
         level: 1,
         lhs_content: None,
         rhs_content: None,
     }];
-
     let mut app = AppState::new(vec![path.clone()], sections, 100);
-
     if let Some(first) = app.navigate_to_first() {
         app.current_node_index = first;
     }
-
     app.enter_detail_view();
-
     // Make an edit
     if let Some(ref mut editor_state) = app.editor_state {
         editor_state.lines = edtui::Lines::from("\nModified\n");
     }
-
     app.save_current().unwrap();
     app.exit_detail_view(true);
-
     // Generate plan
     let plan = app.generate_edit_plan();
-
     assert!(
         !plan.edits.is_empty(),
         "Edit plan should contain the saved edit"
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# One\n\nA\n\n## Two\n\nB\n\n### Three\n\nC").unwrap();
     let path = file.path().to_path_buf();
-
     let sections = vec![
         Section {
             title: "One".to_string(),
             rhs_content: None,
         },
     ];
-
     let mut app = AppState::new(vec![path.clone()], sections, 100);
-
     // Find and edit first section
     if let Some(first) = app.navigate_to_first() {
         app.current_node_index = first;
     }
     app.save_current().unwrap();
     app.exit_detail_view(true);
-
     // Find and edit third section (index 2)
     // After rebuild, need to find the section again
     if let Some(node_idx) = app.tree_nodes.iter().position(|n| {
     }) {
         app.current_node_index = node_idx;
     }
-
     app.enter_detail_view();
     if let Some(ref mut editor_state) = app.editor_state {
         editor_state.lines = edtui::Lines::from("\nCCC\n");
     }
     app.save_current().unwrap();
-
     // Verify file content
     let content = fs::read_to_string(&path).unwrap();
     assert!(
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# One\n\nA\n\n## Two\n\nB").unwrap();
     let path = file.path().to_path_buf();
-
     let sections = vec![
         Section {
             title: "One".to_string(),
             rhs_content: None,
         },
     ];
-
     let app = AppState::new(vec![path], sections, 100);
-
     // Single file mode should only show sections, no file nodes
     assert_eq!(app.tree_nodes.len(), 2);
     assert!(app.tree_nodes[0].navigable);
 fn test_tree_structure_multi_file() {
     let mut file1 = NamedTempFile::new().unwrap();
     let mut file2 = NamedTempFile::new().unwrap();
-
     writeln!(file1, "# One\n\nA").unwrap();
     writeln!(file2, "# Two\n\nB").unwrap();
-
     let path1 = file1.path().to_path_buf();
     let path2 = file2.path().to_path_buf();
-
     let sections = vec![
         Section {
             title: "One".to_string(),
             rhs_content: None,
         },
     ];
-
     let app = AppState::new(vec![path1, path2], sections, 100);
-
     // Multi-file mode should show file nodes + sections
     // 2 files + 2 sections = 4 nodes
     assert_eq!(app.tree_nodes.len(), 4);
-
     // File nodes should not be navigable
     let mut file_nodes = 0;
     let mut section_nodes = 0;
             file_nodes += 1;
         }
     }
-
     assert_eq!(file_nodes, 2, "Should have 2 file nodes");
     assert_eq!(section_nodes, 2, "Should have 2 section nodes");
 }
     let mut file = NamedTempFile::new().unwrap();
     writeln!(file, "# One\n\nA\n\n## Two\n\nB").unwrap();
     let path = file.path().to_path_buf();
-
     // Create a fake multi-file scenario with one file
     let mut file2 = NamedTempFile::new().unwrap();
     writeln!(file2, "# Three\n\nC").unwrap();
     let path2 = file2.path().to_path_buf();
-
     let sections = vec![
         Section {
             title: "One".to_string(),
             rhs_content: None,
         },
     ];
-
     let mut app = AppState::new(vec![path, path2], sections, 100);
-
     // Start at first position (should be file node, non-navigable)
     app.current_node_index = 0;
     assert!(
         !app.tree_nodes[0].navigable,
         "First node should be file (non-navigable)"
     );
-
     // Navigate to next - should skip to first section
     if let Some(next) = app.find_next_node() {
         app.current_node_index = next;
     }
-
     assert!(
         app.tree_nodes[app.current_node_index].navigable,
         "Should skip to navigable node"