COMPARISON DIFF
============================================================

Original size: 49754 bytes
Chloro size:   48939 bytes
Rustfmt size:  49754 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     infer::{select::EvaluationResult, traits::PredicateObligation},
     obligation_ctxt::ObligationCtxt,
 };
-
 use super::{
     AliasTerm, Binder, CanonicalQueryInput, CanonicalVarValues, Const, ConstKind, DbInterner,
     ErrorGuaranteed, GenericArg, GenericArgs, OpaqueTypeKey, ParamEnv, PolyCoercePredicate,
 };
 
 pub mod at;
+
 pub mod canonical;
+
 mod context;
+
 pub mod opaque_types;
+
 pub mod region_constraints;
+
 pub mod relate;
+
 pub mod resolve;
+
 pub(crate) mod select;
+
 pub(crate) mod snapshot;
+
 pub(crate) mod traits;
+
 mod type_variable;
+
 mod unify_key;
 
 /// `InferOk<'db, ()>` is used a lot. It may seem like a useless wrapper
     pub value: T,
     pub obligations: PredicateObligations<'db>,
 }
+
 pub type InferResult<'db, T> = Result<InferOk<'db, T>, TypeError<DbInterner<'db>>>;
 
 pub(crate) type UnificationTable<'a, 'db, T> = ut::UnificationTable<
 #[derive(Clone)]
 pub struct InferCtxtInner<'db> {
     pub(crate) undo_log: InferCtxtUndoLogs<'db>,
-
     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types
     /// that might instantiate a general type variable have an order,
     /// represented by its upper and lower bounds.
     pub(crate) type_variable_storage: type_variable::TypeVariableStorage<'db>,
-
     /// Map from const parameter variable to the kind of const it represents.
     pub(crate) const_unification_storage: ut::UnificationTableStorage<ConstVidKey<'db>>,
-
     /// Map from integral variable to the kind of integer it represents.
     pub(crate) int_unification_storage: ut::UnificationTableStorage<IntVid>,
-
     /// Map from floating variable to the kind of float it represents.
     pub(crate) float_unification_storage: ut::UnificationTableStorage<FloatVid>,
-
     /// Tracks the set of region variables and the constraints between them.
     ///
     /// This is initially `Some(_)` but when
     /// -- further attempts to perform unification, etc., may fail if new
     /// region constraints would've been added.
     pub(crate) region_constraint_storage: Option<RegionConstraintStorage<'db>>,
-
     /// A set of constraints that regionck must validate.
     ///
     /// Each constraint has the form `T:'a`, meaning "some type `T` must
     /// obligations within. This is expected to be done 'late enough'
     /// that all type inference variables have been bound and so forth.
     pub(crate) region_obligations: Vec<RegionObligation<'db>>,
-
     /// Caches for opaque type inference.
     pub(crate) opaque_type_storage: OpaqueTypeStorage<'db>,
 }
     }
 
     #[inline]
-    fn try_type_variables_probe_ref(
-        &self,
-        vid: TyVid,
-    ) -> Option<&type_variable::TypeVariableValue<'db>> {
+    fn try_type_variables_probe_ref(&self, vid: TyVid) -> Option<&type_variable::TypeVariableValue<'db>> {
         // Uses a read-only view of the unification table, this way we don't
         // need an undo log.
         self.type_variable_storage.eq_relations_ref().try_probe_value(vid)
 #[derive(Clone)]
 pub struct InferCtxt<'db> {
     pub interner: DbInterner<'db>,
-
     /// The mode of this inference context, see the struct documentation
     /// for more details.
     typing_mode: TypingMode<'db>,
-
     pub inner: RefCell<InferCtxtInner<'db>>,
-
     /// When an error occurs, we want to avoid reporting "derived"
     /// errors that are due to this original failure. We have this
     /// flag that one can set whenever one creates a type-error that
     /// Don't read this flag directly, call `is_tainted_by_errors()`
     /// and `set_tainted_by_errors()`.
     tainted_by_errors: Cell<Option<ErrorGuaranteed>>,
-
     /// What is the innermost universe we have created? Starts out as
     /// `UniverseIndex::root()` but grows from there as we enter
     /// universal quantifiers.
 pub enum BoundRegionConversionTime {
     /// when a fn is called
     FnCall,
-
     /// when two higher-ranked types are compared
     HigherRankedType,
-
     /// when projecting an associated type
     AssocTypeProjection(SolverDefId),
 }
 impl fmt::Display for FixupError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         use TyOrConstInferVar::*;
-
         match self.unresolved {
             TyInt(_) => write!(
                 f,
     interner: DbInterner<'db>,
 }
 
-pub trait DbInternerInferExt<'db> {
-    fn infer_ctxt(self) -> InferCtxtBuilder<'db>;
-}
+fn infer_ctxt(self) -> InferCtxtBuilder<'db>;
 
 impl<'db> DbInternerInferExt<'db> for DbInterner<'db> {
     fn infer_ctxt(self) -> InferCtxtBuilder<'db> {
     /// `V` and a instantiation `S`. This instantiation `S` maps from
     /// the bound values in `C` to their instantiated values in `V`
     /// (in other words, `S(C) = V`).
-    pub fn build_with_canonical<T>(
-        mut self,
-        input: &CanonicalQueryInput<'db, T>,
-    ) -> (InferCtxt<'db>, T, CanonicalVarValues<'db>)
+    pub fn build_with_canonical<T>(mut self, input: &CanonicalQueryInput<'db, T>) -> (InferCtxt<'db>, T, CanonicalVarValues<'db>)
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         let infcx = self.build(input.typing_mode);
         let (value, args) = infcx.instantiate_canonical(&input.canonical);
         (infcx, value, args)
 
     /// See the comment on [OpaqueTypesJank](crate::solve::OpaqueTypesJank)
     /// for more details.
-    pub fn predicate_may_hold_opaque_types_jank(
-        &self,
-        obligation: &PredicateObligation<'db>,
-    ) -> bool {
+    pub fn predicate_may_hold_opaque_types_jank(&self, obligation: &PredicateObligation<'db>) -> bool {
         <&SolverContext<'db>>::from(self).root_goal_may_hold_opaque_types_jank(Goal::new(
             self.interner,
             obligation.param_env,
 
     pub(crate) fn insert_type_vars<T>(&self, ty: T) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         struct Folder<'a, 'db> {
             infcx: &'a InferCtxt<'db>,
         }
                 if r.is_error() { self.infcx.next_region_var() } else { r }
             }
         }
-
         ty.fold_with(&mut Folder { infcx: self })
     }
 
     /// }
     /// ```
     #[expect(dead_code, reason = "this is used in rustc")]
-    fn predicate_must_hold_considering_regions(
-        &self,
-        obligation: &PredicateObligation<'db>,
-    ) -> bool {
+    fn predicate_must_hold_considering_regions(&self, obligation: &PredicateObligation<'db>) -> bool {
         self.evaluate_obligation(obligation).must_apply_considering_regions()
     }
 
 
     pub fn type_is_copy_modulo_regions(&self, param_env: ParamEnv<'db>, ty: Ty<'db>) -> bool {
         let ty = self.resolve_vars_if_possible(ty);
-
         let Some(copy_def_id) =
             LangItem::Copy.resolve_trait(self.interner.db, self.interner.krate.unwrap())
         else {
             return false;
         };
-
         // This can get called from typeck (by euv), and `moves_by_default`
         // rightly refuses to work with inference variables, but
         // moves_by_default has a cache, which we want to use in other
     /// practical obstacles. Among other things, `FnCtxt::coerce` presently
     /// records adjustments that are required on the HIR in order to perform
     /// the coercion, and we don't currently have a way to manage that.)
-    pub fn coerce_predicate(
-        &self,
-        cause: &ObligationCause,
-        param_env: ParamEnv<'db>,
-        predicate: PolyCoercePredicate<'db>,
-    ) -> Result<InferResult<'db, ()>, (TyVid, TyVid)> {
+    pub fn coerce_predicate(&self, cause: &ObligationCause, param_env: ParamEnv<'db>, predicate: PolyCoercePredicate<'db>) -> Result<InferResult<'db, ()>, (TyVid, TyVid)> {
         let subtype_predicate = predicate.map_bound(|p| SubtypePredicate {
             a_is_expected: false, // when coercing from `a` to `b`, `b` is expected
             a: p.a,
         self.subtype_predicate(cause, param_env, subtype_predicate)
     }
 
-    pub fn subtype_predicate(
-        &self,
-        cause: &ObligationCause,
-        param_env: ParamEnv<'db>,
-        predicate: PolySubtypePredicate<'db>,
-    ) -> Result<InferResult<'db, ()>, (TyVid, TyVid)> {
+    pub fn subtype_predicate(&self, cause: &ObligationCause, param_env: ParamEnv<'db>, predicate: PolySubtypePredicate<'db>) -> Result<InferResult<'db, ()>, (TyVid, TyVid)> {
         // Check for two unresolved inference variables, in which case we can
         // make no progress. This is partly a micro-optimization, but it's
         // also an opportunity to "sub-unify" the variables. This isn't
             }
             _ => {}
         }
-
         self.enter_forall(predicate, |SubtypePredicate { a_is_expected, a, b }| {
             if a_is_expected {
                 Ok(self.at(cause, param_env).sub(a, b))
         })
     }
 
-    pub fn region_outlives_predicate(
-        &self,
-        _cause: &traits::ObligationCause,
-        predicate: PolyRegionOutlivesPredicate<'db>,
-    ) {
+    pub fn region_outlives_predicate(&self, _cause: &traits::ObligationCause, predicate: PolyRegionOutlivesPredicate<'db>) {
         self.enter_forall(predicate, |OutlivesPredicate(r_a, r_b)| {
             self.sub_regions(r_b, r_a); // `b : a` ==> `a <= b`
         })
     }
 
     /// Like `fresh_args_for_item()`, but first uses the args from `first`.
-    pub fn fill_rest_fresh_args(
-        &self,
-        def_id: SolverDefId,
-        first: impl IntoIterator<Item = GenericArg<'db>>,
-    ) -> GenericArgs<'db> {
+    pub fn fill_rest_fresh_args(&self, def_id: SolverDefId, first: impl IntoIterator<Item = GenericArg<'db>>) -> GenericArgs<'db> {
         GenericArgs::fill_rest(self.interner, def_id, first, |_index, kind, _| {
             self.var_for_def(kind)
         })
     /// universe index of `TyVar(vid)`.
     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'db>, UniverseIndex> {
         use self::type_variable::TypeVariableValue;
-
         match self.inner.borrow_mut().type_variables().probe(vid) {
             TypeVariableValue::Known { value } => Ok(value),
             TypeVariableValue::Unknown { universe } => Err(universe),
     /// at will.
     pub fn resolve_vars_if_possible<T>(&self, value: T) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         if let Err(guar) = value.error_reported() {
             self.set_tainted_by_errors(guar);
         }
         }
     }
 
-    // Instantiates the bound variables in a given binder with fresh inference
-    // variables in the current universe.
-    //
-    // Use this method if you'd like to find some generic parameters of the binder's
-    // variables (e.g. during a method call). If there isn't a [`BoundRegionConversionTime`]
-    // that corresponds to your use case, consider whether or not you should
-    // use [`InferCtxt::enter_forall`] instead.
-    pub fn instantiate_binder_with_fresh_vars<T>(
-        &self,
-        _lbrct: BoundRegionConversionTime,
-        value: Binder<'db, T>,
-    ) -> T
+    pub fn instantiate_binder_with_fresh_vars<T>(&self, _lbrct: BoundRegionConversionTime, value: Binder<'db, T>) -> T
     where
-        T: TypeFoldable<DbInterner<'db>> + Clone,
-    {
+        T: TypeFoldable<DbInterner<'db>> + Clone, {
         if let Some(inner) = value.clone().no_bound_vars() {
             return inner;
         }
-
         let bound_vars = value.clone().bound_vars();
         let mut args = Vec::with_capacity(bound_vars.len());
-
         for bound_var_kind in bound_vars {
             let arg: GenericArg<'db> = match bound_var_kind {
                 BoundVarKind::Ty(_) => self.next_ty_var().into(),
             };
             args.push(arg);
         }
-
         struct ToFreshVars<'db> {
             args: Vec<GenericArg<'db>>,
         }
-
         impl<'db> BoundVarReplacerDelegate<'db> for ToFreshVars<'db> {
             fn replace_region(&mut self, br: BoundRegion) -> Region<'db> {
                 self.args[br.var.index()].expect_region()
     /// The returned function is used in a fast path. If it returns `true` the variable is
     /// unchanged, `false` indicates that the status is unknown.
     #[inline]
-    pub fn is_ty_infer_var_definitely_unchanged<'a>(
-        &'a self,
-    ) -> impl Fn(TyOrConstInferVar) -> bool + Captures<'db> + 'a {
+    pub fn is_ty_infer_var_definitely_unchanged<'a>(&'a self) -> impl Fn(TyOrConstInferVar) -> bool + Captures<'db> + 'a {
         // This hoists the borrow/release out of the loop body.
         let inner = self.inner.try_borrow();
-
         move |infer_var: TyOrConstInferVar| match (infer_var, &inner) {
             (TyOrConstInferVar::Ty(ty_var), Ok(inner)) => {
                 use self::type_variable::TypeVariableValue;
     TyInt(IntVid),
     /// Equivalent to `Infer(FloatVar(_))`.
     TyFloat(FloatVid),
-
     /// Equivalent to `ConstKind::Infer(InferConst::Var(_))`.
     Const(ConstVid),
 }
         }
     }
 
-    pub fn trait_refs(
-        cause: &ObligationCause,
-        a: TraitRef<'db>,
-        b: TraitRef<'db>,
-    ) -> TypeTrace<'db> {
+    pub fn trait_refs(cause: &ObligationCause, a: TraitRef<'db>, b: TraitRef<'db>) -> TypeTrace<'db> {
         TypeTrace { cause: cause.clone(), values: ValuePairs::TraitRefs(ExpectedFound::new(a, b)) }
     }
 
     /// The `DefId` and args of the opaque type causing this constraint.
     /// Used for error reporting.
     pub key: OpaqueTypeKey<'db>,
-
     /// The hidden type in which `member_region` appears: used for error reporting.
     pub hidden_ty: Ty<'db>,
-
     /// The region `R0`.
     pub member_region: Region<'db>,
-
     /// The options `O1..On`.
     pub choice_regions: Arc<Vec<Region<'db>>>,
 }