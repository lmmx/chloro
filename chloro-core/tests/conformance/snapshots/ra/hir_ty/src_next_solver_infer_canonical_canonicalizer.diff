COMPARISON DIFF
============================================================

Original size: 29589 bytes
Chloro size:   28022 bytes
Rustfmt size:  29841 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use rustc_hash::FxHashMap;
 use rustc_index::Idx;
-use rustc_type_ir::inherent::{Const as _, IntoKind as _, Region as _, SliceLike, Ty as _};
 use rustc_type_ir::InferTy::{self, FloatVar, IntVar, TyVar};
+use rustc_type_ir::inherent::{Const as _, IntoKind as _, Region as _, SliceLike, Ty as _};
 use rustc_type_ir::{
     BoundVar, BoundVarIndexKind, CanonicalQueryInput, DebruijnIndex, Flags, InferConst, RegionKind,
     TyVid, TypeFlags, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
     /// we only ever put ROOT values into the query, so this map is very
     /// simple.
     pub universe_map: SmallVec<[UniverseIndex; 4]>,
-
     /// This is equivalent to `CanonicalVarValues`, but using a
     /// `SmallVec` yields a significant performance win.
     pub var_values: SmallVec<[GenericArg<'db>; 8]>,
         let mut universe_map = SmallVec::default();
         universe_map.push(UniverseIndex::ROOT);
 
-        Self {
-            universe_map,
-            var_values: SmallVec::default(),
-        }
+        Self { universe_map, var_values: SmallVec::default() }
     }
 }
 
             query_state,
         )
         .unchecked_map(|(param_env, value)| ParamEnvAnd { param_env, value });
-        CanonicalQueryInput {
-            canonical,
-            typing_mode: self.typing_mode(),
-        }
+        CanonicalQueryInput { canonical, typing_mode: self.typing_mode() }
     }
 
     /// Canonicalizes a query *response* `V`. When we canonicalize a
 
     fn any(&self) -> bool;
 
-    // Do we preserve universe of variables.
     fn preserve_universes(&self) -> bool;
 }
 
             | RegionKind::ReStatic
             | RegionKind::ReEarlyParam(..)
             | RegionKind::ReError(..) => r,
-
-            RegionKind::RePlaceholder(placeholder) => canonicalizer
-                .canonical_var_for_region(CanonicalVarKind::PlaceholderRegion(placeholder), r),
-
+            RegionKind::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(
+                CanonicalVarKind::PlaceholderRegion(placeholder),
+                r,
+            ),
             RegionKind::ReVar(vid) => {
                 let universe = infcx
                     .inner
                     .unwrap_err();
                 canonicalizer.canonical_var_for_region(CanonicalVarKind::Region(universe), r)
             }
-
             _ => {
-                // Other than `'static` or `'empty`, the query
-                // response should be executing in a fully
-                // canonicalized environment, so there shouldn't be
-                // any other region names it can come up.
-                //
-                // rust-lang/rust#57464: `impl Trait` can leak local
-                // scopes (in manner violating typeck). Therefore, use
-                // `delayed_bug` to allow type error over an ICE.
                 panic!("unexpected region in query response: `{r:?}`");
             }
         }
             | RegionKind::ReError(_) => r,
             RegionKind::ReVar(_) => canonicalizer.canonical_var_for_region_in_root_universe(r),
             RegionKind::RePlaceholder(..) | RegionKind::ReBound(..) => {
-                // We only expect region names that the user can type.
                 panic!("unexpected region in query response: `{r:?}`")
             }
         }
     sub_root_lookup_table: FxHashMap<TyVid, usize>,
     canonicalize_mode: &'cx dyn CanonicalizeMode,
     needs_canonical_flags: TypeFlags,
-
     binder_index: DebruijnIndex,
 }
 
             RegionKind::ReBound(BoundVarIndexKind::Canonical, ..) => {
                 panic!("canonicalized bound var found during canonicalization");
             }
-
             RegionKind::ReStatic
             | RegionKind::ReEarlyParam(..)
             | RegionKind::ReError(_)
     fn fold_ty(&mut self, mut t: Ty<'db>) -> Ty<'db> {
         match t.kind() {
             TyKind::Infer(TyVar(mut vid)) => {
-                // We need to canonicalize the *root* of our ty var.
-                // This is so that our canonical response correctly reflects
-                // any equated inference vars correctly!
                 let root_vid = self.infcx.root_var(vid);
                 if root_vid != vid {
                     t = Ty::new_var(self.tcx, root_vid);
                     vid = root_vid;
                 }
-
                 debug!("canonical: type var found with vid {:?}", vid);
                 match self.infcx.probe_ty_var(vid) {
-                    // `t` could be a float / int variable; canonicalize that instead.
                     Ok(t) => {
                         debug!("(resolved to {:?})", t);
                         self.fold_ty(t)
                     }
-
-                    // `TyVar(vid)` is unresolved, track its universe index in the canonicalized
-                    // result.
                     Err(mut ui) => {
                         if !self.canonicalize_mode.preserve_universes() {
                             // FIXME: perf problem described in #55921.
                             ui = UniverseIndex::ROOT;
                         }
-
                         let sub_root = self.get_or_insert_sub_root(vid);
                         self.canonicalize_ty_var(CanonicalVarKind::Ty { ui, sub_root }, t)
                     }
                 }
             }
-
             TyKind::Infer(IntVar(vid)) => {
                 let nt = self.infcx.opportunistic_resolve_int_var(vid);
                 if nt != t {
                     self.canonicalize_ty_var(CanonicalVarKind::Float, t)
                 }
             }
-
             TyKind::Infer(
                 InferTy::FreshTy(_) | InferTy::FreshIntTy(_) | InferTy::FreshFloatTy(_),
             ) => {
                 panic!("encountered a fresh type during canonicalization")
             }
-
             TyKind::Placeholder(mut placeholder) => {
                 if !self.canonicalize_mode.preserve_universes() {
                     placeholder.universe = UniverseIndex::ROOT;
                 }
                 self.canonicalize_ty_var(CanonicalVarKind::PlaceholderTy(placeholder), t)
             }
-
             TyKind::Bound(BoundVarIndexKind::Bound(..), _) => t,
             TyKind::Bound(BoundVarIndexKind::Canonical, ..) => {
                 panic!("canonicalized bound var found during canonicalization");
             }
-
             TyKind::Closure(..)
             | TyKind::CoroutineClosure(..)
             | TyKind::Coroutine(..)
             tcx,
             canonicalize_region_mode,
             query_state,
+        ).unchecked_map(
+            |((), val)| val,
         )
-        .unchecked_map(|((), val)| val)
     }
 
     fn canonicalize_with_base<U, V>(
         let out_value = value.fold_with(&mut canonicalizer);
 
         // Once we have canonicalized `out_value`, it should not
+
         // contain anything that ties it to this inference context
+
         // anymore.
         debug_assert!(!out_value.has_infer() && !out_value.has_placeholders());
 
             .max()
             .unwrap_or(UniverseIndex::ROOT);
 
-        Canonical {
-            max_universe,
-            variables: canonical_variables,
-            value: (base.value, out_value),
-        }
+        Canonical { max_universe, variables: canonical_variables, value: (base.value, out_value) }
     }
 
     /// Creates a canonical variable replacing `kind` from the input,
     /// seen. `kind` is expected to be an unbound variable (or
     /// potentially a free region).
     fn canonical_var(&mut self, info: CanonicalVarKind<'db>, kind: GenericArg<'db>) -> BoundVar {
-        let Canonicalizer {
-            variables,
-            query_state,
-            indices,
-            ..
-        } = self;
+        let Canonicalizer { variables, query_state, indices, .. } = self;
 
         let var_values = &mut query_state.var_values;
 
         }
 
         // This code is hot. `variables` and `var_values` are usually small
+
         // (fewer than 8 elements ~95% of the time). They are SmallVec's to
+
         // avoid allocations in those cases. We also don't use `indices` to
+
         // determine if a kind has been seen before until the limit of 8 has
+
         // been exceeded, to also avoid allocations for `indices`.
         if !var_values.spilled() {
-            // `var_values` is stack-allocated. `indices` isn't used yet. Do a
-            // direct linear search of `var_values`.
             if let Some(idx) = var_values.iter().position(|&k| k == kind) {
-                // `kind` is already present in `var_values`.
                 BoundVar::new(idx)
             } else {
-                // `kind` isn't present in `var_values`. Append it. Likewise
-                // for `info` and `variables`.
                 variables.push(info);
                 var_values.push(kind);
                 assert_eq!(variables.len(), var_values.len());
-
-                // If `var_values` has become big enough to be heap-allocated,
-                // fill up `indices` to facilitate subsequent lookups.
                 if var_values.spilled() {
                     assert!(indices.is_empty());
                     *indices = var_values
                         .map(|(i, &kind)| (kind, BoundVar::new(i)))
                         .collect();
                 }
-                // The cv is the index of the appended element.
                 BoundVar::new(var_values.len() - 1)
             }
         } else {
-            // `var_values` is large. Do a hashmap search via `indices`.
             *indices.entry(kind).or_insert_with(|| {
                 variables.push(info);
                 var_values.push(kind);
 
     fn get_or_insert_sub_root(&mut self, vid: TyVid) -> BoundVar {
         let root_vid = self.infcx.sub_unification_table_root_var(vid);
-        let idx = *self
-            .sub_root_lookup_table
-            .entry(root_vid)
-            .or_insert_with(|| self.variables.len());
+        let idx =
+            *self.sub_root_lookup_table.entry(root_vid).or_insert_with(|| self.variables.len());
         BoundVar::from(idx)
     }
 
             .map(|(idx, universe)| (*universe, UniverseIndex::from_usize(idx)))
             .collect();
 
-        self.variables
-            .iter()
-            .map(|v| match *v {
+        self.variables.iter().map(|v| match *v {
                 CanonicalVarKind::Int | CanonicalVarKind::Float => *v,
-                CanonicalVarKind::Ty { ui, sub_root } => CanonicalVarKind::Ty {
-                    ui: reverse_universe_map[&ui],
-                    sub_root,
-                },
+                CanonicalVarKind::Ty { ui, sub_root } => {
+                    CanonicalVarKind::Ty { ui: reverse_universe_map[&ui], sub_root }
+                }
                 CanonicalVarKind::Region(u) => CanonicalVarKind::Region(reverse_universe_map[&u]),
                 CanonicalVarKind::Const(u) => CanonicalVarKind::Const(reverse_universe_map[&u]),
                 CanonicalVarKind::PlaceholderTy(placeholder) => {
                         ..placeholder
                     })
                 }
-            })
-            .collect()
+            }).collect(
+        )
     }
 
     /// Shorthand helper that creates a canonical region variable for