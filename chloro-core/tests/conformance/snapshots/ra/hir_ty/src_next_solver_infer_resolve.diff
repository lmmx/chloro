COMPARISON DIFF
============================================================

Original size: 3153 bytes
Chloro size:   3216 bytes
Rustfmt size:  3226 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Things for resolving vars in the infer context of the next-trait-solver.
 
 use rustc_type_ir::{
+    TypeFolder, TypeSuperFoldable, TypeVisitableExt,
     data_structures::DelayedMap,
     inherent::{Const as _, Ty as _},
-    TypeFolder, TypeSuperFoldable, TypeVisitableExt,
 };
 
 use crate::next_solver::{Const, DbInterner, ErrorGuaranteed, Region, Ty};
 
 ///////////////////////////////////////////////////////////////////////////
 // OPPORTUNISTIC VAR RESOLVER
-
 /// The opportunistic resolver can be used at any time. It simply replaces
 /// type/const variables that have been unified with the things they have
 /// been unified with (similar to `shallow_resolve`, but deep). This is
 impl<'a, 'db> OpportunisticVarResolver<'a, 'db> {
     #[inline]
     pub fn new(infcx: &'a InferCtxt<'db>) -> Self {
-        OpportunisticVarResolver {
-            infcx,
-            cache: Default::default(),
-        }
+        OpportunisticVarResolver { infcx, cache: Default::default() }
     }
 }
 
     #[inline]
     fn fold_ty(&mut self, t: Ty<'db>) -> Ty<'db> {
         if !t.has_non_region_infer() {
-            t // micro-optimize -- if there is nothing in this type that this fold affects...
+            t
+            // micro-optimize -- if there is nothing in this type that this fold affects...
         } else if let Some(ty) = self.cache.get(&t) {
             *ty
         } else {
 
     fn fold_const(&mut self, ct: Const<'db>) -> Const<'db> {
         if !ct.has_non_region_infer() {
-            ct // micro-optimize -- if there is nothing in this const that this fold affects...
+            ct
+            // micro-optimize -- if there is nothing in this const that this fold affects...
         } else {
             let ct = self.infcx.shallow_resolve_const(ct);
             ct.super_fold_with(self)