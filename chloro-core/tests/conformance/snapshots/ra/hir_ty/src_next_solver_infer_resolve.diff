COMPARISON DIFF
============================================================

Original size: 3153 bytes
Chloro size:   3166 bytes
Rustfmt size:  3226 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Things for resolving vars in the infer context of the next-trait-solver.
 
 use rustc_type_ir::{
     data_structures::DelayedMap,
     inherent::{Const as _, Ty as _},
-    TypeFolder, TypeSuperFoldable, TypeVisitableExt,
+    TypeFolder,
+    TypeSuperFoldable,
+    TypeVisitableExt,
 };
 
 use crate::next_solver::{Const, DbInterner, ErrorGuaranteed, Region, Ty};
-
 use super::InferCtxt;
 
-///////////////////////////////////////////////////////////////////////////
-// OPPORTUNISTIC VAR RESOLVER
-
 /// The opportunistic resolver can be used at any time. It simply replaces
 /// type/const variables that have been unified with the things they have
 /// been unified with (similar to `shallow_resolve`, but deep). This is
 impl<'a, 'db> OpportunisticVarResolver<'a, 'db> {
     #[inline]
     pub fn new(infcx: &'a InferCtxt<'db>) -> Self {
-        OpportunisticVarResolver {
-            infcx,
-            cache: Default::default(),
-        }
+        OpportunisticVarResolver { infcx, cache: Default::default() }
     }
 }
 
     }
 
     #[inline]
-    fn fold_ty(&mut self, t: Ty<'db>) -> Ty<'db> {
+    fn fold_ty(
+        &mut self,
+        t: Ty<'db>,
+    ) -> Ty<'db> {
         if !t.has_non_region_infer() {
             t // micro-optimize -- if there is nothing in this type that this fold affects...
         } else if let Some(ty) = self.cache.get(&t) {
         }
     }
 
-    fn fold_const(&mut self, ct: Const<'db>) -> Const<'db> {
+    fn fold_const(
+        &mut self,
+        ct: Const<'db>,
+    ) -> Const<'db> {
         if !ct.has_non_region_infer() {
             ct // micro-optimize -- if there is nothing in this const that this fold affects...
         } else {
         self.interner
     }
 
-    fn fold_ty(&mut self, t: Ty<'db>) -> Ty<'db> {
+    fn fold_ty(
+        &mut self,
+        t: Ty<'db>,
+    ) -> Ty<'db> {
         if !t.has_infer() {
             return t;
         }
-
         if t.is_infer() {
             Ty::new_error(self.interner, ErrorGuaranteed)
         } else {
         }
     }
 
-    fn fold_const(&mut self, c: Const<'db>) -> Const<'db> {
+    fn fold_const(
+        &mut self,
+        c: Const<'db>,
+    ) -> Const<'db> {
         if !c.has_infer() {
             return c;
         }
-
         if c.is_ct_infer() {
             Const::new_error(self.interner, ErrorGuaranteed)
         } else {
         }
     }
 
-    fn fold_region(&mut self, r: Region<'db>) -> Region<'db> {
-        if r.is_var() {
-            Region::error(self.interner)
-        } else {
-            r
-        }
+    fn fold_region(
+        &mut self,
+        r: Region<'db>,
+    ) -> Region<'db> {
+        if r.is_var() { Region::error(self.interner) } else { r }
     }
 }