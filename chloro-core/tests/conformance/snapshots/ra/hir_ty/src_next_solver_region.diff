COMPARISON DIFF
============================================================

Original size: 11497 bytes
Chloro size:   11419 bytes
Rustfmt size:  11829 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 };
 
 use crate::next_solver::{GenericArg, OutlivesPredicate};
-
 use super::{
     interned_vec_db,
     interner::{BoundVarKind, DbInterner, Placeholder},
     pub fn inner(&self) -> &RegionKind<'db> {
         crate::with_attached_db(|db| {
             let inner = self.kind_(db);
-            // SAFETY: The caller already has access to a `Region<'db>`, so borrowchecking will
-            // make sure that our returned value is valid for the lifetime `'db`.
-            unsafe { std::mem::transmute::<&RegionKind<'_>, &RegionKind<'db>>(inner) }
+            unsafe {
+                std::mem::transmute::<&RegionKind<'_>, &RegionKind<'db>>(inner)
+            }
         })
     }
 
         index: DebruijnIndex,
         bound: BoundRegion,
     ) -> Region<'db> {
-        Region::new(
-            interner,
-            RegionKind::ReBound(BoundVarIndexKind::Bound(index), bound),
-        )
+        Region::new(interner, RegionKind::ReBound(BoundVarIndexKind::Bound(index), bound))
     }
 
     pub fn is_placeholder(&self) -> bool {
     pub index: u32,
 }
 
-#[derive(Copy, Clone, PartialEq, Eq, Hash)]
 /// The parameter representation of late-bound function parameters, "some region
 /// at least as big as the scope `fr.scope`".
 ///
 /// between others we use the `DefId` of the parameter. For this reason the `bound_region` field
 /// should basically always be `BoundRegionKind::Named` as otherwise there is no way of telling
 /// different parameters apart.
+#[derive(Copy, Clone, PartialEq, Eq, Hash)]
 pub struct LateParamRegion {
     pub scope: SolverDefId,
     pub bound_region: BoundRegionKind,
             BoundRegionKind::Anon => write!(f, "BrAnon"),
             BoundRegionKind::Named(did) => {
                 write!(f, "BrNamed({did:?})")
-            }
+            },
             BoundRegionKind::ClosureEnv => write!(f, "BrEnv"),
         }
     }
             BoundRegionKind::ClosureEnv => write!(f, "{:?}.Env", self.var),
             BoundRegionKind::Named(def) => {
                 write!(f, "{:?}.Named({:?})", self.var, def)
-            }
+            },
         }
     }
 }
     ) -> Result<Self, F::Error> {
         folder.try_fold_region(self)
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         folder.fold_region(self)
     }
         debruijn: rustc_type_ir::DebruijnIndex,
         var: BoundRegion,
     ) -> Self {
-        Region::new(
-            interner,
-            RegionKind::ReBound(BoundVarIndexKind::Bound(debruijn), var),
-        )
+        Region::new(interner, RegionKind::ReBound(BoundVarIndexKind::Bound(debruijn), var))
     }
 
     fn new_anon_bound(
             interner,
             RegionKind::ReBound(
                 BoundVarIndexKind::Bound(debruijn),
-                BoundRegion {
-                    var,
-                    kind: BoundRegionKind::Anon,
-                },
+                BoundRegion { var, kind: BoundRegionKind::Anon },
             ),
         )
     }
             interner,
             RegionKind::ReBound(
                 BoundVarIndexKind::Canonical,
-                BoundRegion {
-                    var,
-                    kind: BoundRegionKind::Anon,
-                },
+                BoundRegion { var, kind: BoundRegionKind::Anon },
             ),
         )
     }
     }
 
     fn new(ui: rustc_type_ir::UniverseIndex, bound: Self::Bound) -> Self {
-        Placeholder {
-            universe: ui,
-            bound,
-        }
+        Placeholder { universe: ui, bound }
     }
 
     fn new_anon(ui: rustc_type_ir::UniverseIndex, var: rustc_type_ir::BoundVar) -> Self {
         Placeholder {
             universe: ui,
-            bound: BoundRegion {
-                var,
-                kind: BoundRegionKind::Anon,
-            },
+            bound: BoundRegion { var, kind: BoundRegionKind::Anon },
         }
     }
 }