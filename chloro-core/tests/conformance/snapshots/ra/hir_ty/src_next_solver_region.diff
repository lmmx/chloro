COMPARISON DIFF
============================================================

Original size: 11497 bytes
Chloro size:   11727 bytes
Rustfmt size:  11829 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Things related to regions.
 
 use hir_def::LifetimeParamId;
 use intern::Symbol;
 use rustc_type_ir::{
-    inherent::{IntoKind, PlaceholderLike, SliceLike},
+    inherent::{IntoKind,
+
     relate::Relate,
-    BoundVar, BoundVarIndexKind, DebruijnIndex, Flags, RegionVid, TypeFlags, TypeFoldable,
-    TypeVisitable, INNERMOST,
+
+    BoundVar, BoundVarIndexKind, DebruijnIndex, Flags, PlaceholderLike, RegionVid, SliceLike},
+    TypeFlags, TypeFoldable, TypeVisitable, INNERMOST,
 };
 
 use crate::next_solver::{GenericArg, OutlivesPredicate};
-
 use super::{
     interned_vec_db,
-    interner::{BoundVarKind, DbInterner, Placeholder},
-    ErrorGuaranteed, SolverDefId,
+
+    interner::{BoundVarKind,
+
+    DbInterner, ErrorGuaranteed, Placeholder}, SolverDefId,
 };
 
 pub type RegionKind<'db> = rustc_type_ir::RegionKind<DbInterner<'db>>;
 }
 
 impl std::fmt::Debug for Region<'_> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         self.kind().fmt(f)
     }
 }
 
 impl<'db> Region<'db> {
-    pub fn new(interner: DbInterner<'db>, kind: RegionKind<'db>) -> Self {
+    pub fn new(
+        interner: DbInterner<'db>,
+        kind: RegionKind<'db>,
+    ) -> Self {
         Region::new_(interner.db(), kind)
     }
 
         Region::new(interner, RegionKind::ReEarlyParam(early_bound_region))
     }
 
-    pub fn new_placeholder(interner: DbInterner<'db>, placeholder: PlaceholderRegion) -> Self {
+    pub fn new_placeholder(
+        interner: DbInterner<'db>,
+        placeholder: PlaceholderRegion,
+    ) -> Self {
         Region::new(interner, RegionKind::RePlaceholder(placeholder))
     }
 
-    pub fn new_var(interner: DbInterner<'db>, v: RegionVid) -> Region<'db> {
+    pub fn new_var(
+        interner: DbInterner<'db>,
+        v: RegionVid,
+    ) -> Region<'db> {
         Region::new(interner, RegionKind::ReVar(v))
     }
 
         index: DebruijnIndex,
         bound: BoundRegion,
     ) -> Region<'db> {
-        Region::new(
-            interner,
-            RegionKind::ReBound(BoundVarIndexKind::Bound(index), bound),
-        )
+        Region::new(interner, RegionKind::ReBound(BoundVarIndexKind::Bound(index), bound))
     }
 
     pub fn is_placeholder(&self) -> bool {
 
     pub fn type_flags(&self) -> TypeFlags {
         let mut flags = TypeFlags::empty();
-
         match &self.inner() {
             RegionKind::ReVar(..) => {
                 flags |= TypeFlags::HAS_FREE_REGIONS;
                 flags |= TypeFlags::HAS_ERROR;
             }
         }
-
         flags
     }
 }
 
 #[derive(Copy, Clone, PartialEq, Eq, Hash)]
 pub struct EarlyParamRegion {
-    // FIXME: See `ParamTy`.
     pub id: LifetimeParamId,
     pub index: u32,
 }
 
-#[derive(Copy, Clone, PartialEq, Eq, Hash)]
 /// The parameter representation of late-bound function parameters, "some region
 /// at least as big as the scope `fr.scope`".
 ///
 /// between others we use the `DefId` of the parameter. For this reason the `bound_region` field
 /// should basically always be `BoundRegionKind::Named` as otherwise there is no way of telling
 /// different parameters apart.
+#[derive(Copy, Clone, PartialEq, Eq, Hash)]
 pub struct LateParamRegion {
     pub scope: SolverDefId,
     pub bound_region: BoundRegionKind,
 }
 
 impl std::fmt::Debug for LateParamRegion {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         write!(f, "ReLateParam({:?}, {:?})", self.scope, self.bound_region)
     }
 }
 pub enum BoundRegionKind {
     /// An anonymous region parameter for a given fn (&T)
     Anon,
-
     /// Named region parameters for functions (a in &'a T)
     ///
     /// The `DefId` is needed to distinguish free regions in
     /// the event of shadowing.
     Named(SolverDefId),
-
     /// Anonymous region for the implicit env pointer parameter
     /// to a closure
     ClosureEnv,
 }
 
 impl std::fmt::Debug for BoundRegionKind {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         match *self {
             BoundRegionKind::Anon => write!(f, "BrAnon"),
             BoundRegionKind::Named(did) => {
 }
 
 impl std::fmt::Debug for EarlyParamRegion {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         write!(f, "#{}", self.index)
         // write!(f, "{}/#{}", self.name, self.index)
     }
         self.var
     }
 
-    fn assert_eq(self, var: BoundVarKind) {
+    fn assert_eq(
+        self,
+        var: BoundVarKind,
+    ) {
         assert_eq!(self.kind, var.expect_region())
     }
 }
 
 impl core::fmt::Debug for BoundRegion {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         match &self.kind {
             BoundRegionKind::Anon => write!(f, "{:?}", self.var),
             BoundRegionKind::ClosureEnv => write!(f, "{:?}.Env", self.var),
     ) -> Result<Self, F::Error> {
         folder.try_fold_region(self)
     }
-    fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
+
+    fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
+        self,
+        folder: &mut F,
+    ) -> Self {
         folder.fold_region(self)
     }
 }
         debruijn: rustc_type_ir::DebruijnIndex,
         var: BoundRegion,
     ) -> Self {
-        Region::new(
-            interner,
-            RegionKind::ReBound(BoundVarIndexKind::Bound(debruijn), var),
-        )
+        Region::new(interner, RegionKind::ReBound(BoundVarIndexKind::Bound(debruijn), var))
     }
 
     fn new_anon_bound(
             interner,
             RegionKind::ReBound(
                 BoundVarIndexKind::Bound(debruijn),
-                BoundRegion {
-                    var,
-                    kind: BoundRegionKind::Anon,
-                },
+                BoundRegion { var, kind: BoundRegionKind::Anon },
             ),
         )
     }
 
-    fn new_canonical_bound(interner: DbInterner<'db>, var: rustc_type_ir::BoundVar) -> Self {
+    fn new_canonical_bound(
+        interner: DbInterner<'db>,
+        var: rustc_type_ir::BoundVar,
+    ) -> Self {
         Region::new(
             interner,
             RegionKind::ReBound(
                 BoundVarIndexKind::Canonical,
-                BoundRegion {
-                    var,
-                    kind: BoundRegionKind::Anon,
-                },
+                BoundRegion { var, kind: BoundRegionKind::Anon },
             ),
         )
     }
         self.bound.var
     }
 
-    fn with_updated_universe(self, ui: rustc_type_ir::UniverseIndex) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: self.bound,
-        }
+    fn with_updated_universe(
+        self,
+        ui: rustc_type_ir::UniverseIndex,
+    ) -> Self {
+        Placeholder { universe: ui, bound: self.bound }
     }
 
-    fn new(ui: rustc_type_ir::UniverseIndex, bound: Self::Bound) -> Self {
-        Placeholder {
-            universe: ui,
-            bound,
-        }
+    fn new(
+        ui: rustc_type_ir::UniverseIndex,
+        bound: Self::Bound,
+    ) -> Self {
+        Placeholder { universe: ui, bound }
     }
 
-    fn new_anon(ui: rustc_type_ir::UniverseIndex, var: rustc_type_ir::BoundVar) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: BoundRegion {
-                var,
-                kind: BoundRegionKind::Anon,
-            },
-        }
+    fn new_anon(
+        ui: rustc_type_ir::UniverseIndex,
+        var: rustc_type_ir::BoundVar,
+    ) -> Self {
+        Placeholder { universe: ui, bound: BoundRegion { var, kind: BoundRegionKind::Anon } }
     }
 }
 
 type GenericArgOutlivesPredicate<'db> = OutlivesPredicate<'db, GenericArg<'db>>;
-
-interned_vec_db!(RegionAssumptions, GenericArgOutlivesPredicate);