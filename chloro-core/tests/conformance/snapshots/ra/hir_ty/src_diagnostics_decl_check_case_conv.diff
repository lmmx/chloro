COMPARISON DIFF
============================================================

Original size: 5852 bytes
Chloro size:   5704 bytes
Rustfmt size:  6228 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Functions for string case manipulation, such as detecting the identifier case,
 //! and converting it into appropriate form.
-
 // Code that was taken from rustc was taken at commit 89fdb30,
 // from file /compiler/rustc_lint/src/nonstandard_style.rs
 
     if is_camel_case(ident) {
         return None;
     }
-
     Some(stdx::to_camel_case(ident))
 }
 
     } else if is_upper_snake_case(ident) {
         return Some(ident.to_lowercase());
     }
-
     Some(stdx::to_lower_snake_case(ident))
 }
 
     } else if is_lower_snake_case(ident) {
         return Some(ident.to_uppercase());
     }
-
     Some(stdx::to_upper_snake_case(ident))
 }
 
-// Taken from rustc.
-// Modified by replacing the use of unstable feature `array_windows`.
 fn is_camel_case(name: &str) -> bool {
     let name = name.trim_matches('_');
     if name.is_empty() {
         return true;
     }
-
     let mut fst = None;
     // start with a non-lowercase letter rather than non-uppercase
     // ones (some scripts don't have a concept of upper/lowercase)
     is_snake_case(ident, char::is_lowercase)
 }
 
-// Taken from rustc.
-// Modified to allow checking for both upper and lower snake case.
-fn is_snake_case<F: Fn(char) -> bool>(ident: &str, wrong_case: F) -> bool {
+fn is_snake_case<F: Fn(char) -> bool>(
+    ident: &str,
+    wrong_case: F,
+) -> bool {
     if ident.is_empty() {
         return true;
     }
     let ident = ident.trim_matches('_');
-
     let mut allow_underscore = true;
     ident.chars().all(|c| {
         allow_underscore = match c {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use expect_test::{expect, Expect};
-
-    fn check<F: Fn(&str) -> Option<String>>(fun: F, input: &str, expect: Expect) {
+    use expect_test::{Expect, expect};
+    fn check<F: Fn(&str) -> Option<String>>(
+        fun: F,
+        input: &str,
+        expect: Expect,
+    ) {
         // `None` is translated to empty string, meaning that there is nothing to fix.
         let output = fun(input).unwrap_or_default();
-
         expect.assert_eq(&output);
     }
-
     #[test]
     fn test_to_lower_snake_case() {
         check(to_lower_snake_case, "lower_snake_case", expect![[""]]);
-        check(
-            to_lower_snake_case,
-            "UPPER_SNAKE_CASE",
-            expect![["upper_snake_case"]],
-        );
+        check(to_lower_snake_case, "UPPER_SNAKE_CASE", expect![["upper_snake_case"]]);
         check(to_lower_snake_case, "Weird_Case", expect![["weird_case"]]);
-        check(
-            to_lower_snake_case,
-            "UpperCamelCase",
-            expect![["upper_camel_case"]],
-        );
-        check(
-            to_lower_snake_case,
-            "lowerCamelCase",
-            expect![["lower_camel_case"]],
-        );
+        check(to_lower_snake_case, "UpperCamelCase", expect![["upper_camel_case"]]);
+        check(to_lower_snake_case, "lowerCamelCase", expect![["lower_camel_case"]]);
         check(to_lower_snake_case, "a", expect![[""]]);
         check(to_lower_snake_case, "abc", expect![[""]]);
         check(to_lower_snake_case, "foo__bar", expect![["foo_bar"]]);
         check(to_lower_snake_case, "Δ", expect!["δ"]);
     }
-
     #[test]
     fn test_to_camel_case() {
         check(to_camel_case, "UpperCamelCase", expect![[""]]);
         check(to_camel_case, "UpperCamelCase_", expect![[""]]);
         check(to_camel_case, "_CamelCase", expect![[""]]);
         check(to_camel_case, "lowerCamelCase", expect![["LowerCamelCase"]]);
-        check(
-            to_camel_case,
-            "lower_snake_case",
-            expect![["LowerSnakeCase"]],
-        );
-        check(
-            to_camel_case,
-            "UPPER_SNAKE_CASE",
-            expect![["UpperSnakeCase"]],
-        );
+        check(to_camel_case, "lower_snake_case", expect![["LowerSnakeCase"]]);
+        check(to_camel_case, "UPPER_SNAKE_CASE", expect![["UpperSnakeCase"]]);
         check(to_camel_case, "Weird_Case", expect![["WeirdCase"]]);
         check(to_camel_case, "name", expect![["Name"]]);
         check(to_camel_case, "A", expect![[""]]);
         check(to_camel_case, "Abc_123", expect![["Abc123"]]);
         check(to_camel_case, "A1_b2_c3", expect![["A1B2C3"]]);
     }
-
     #[test]
     fn test_to_upper_snake_case() {
         check(to_upper_snake_case, "UPPER_SNAKE_CASE", expect![[""]]);
-        check(
-            to_upper_snake_case,
-            "lower_snake_case",
-            expect![["LOWER_SNAKE_CASE"]],
-        );
+        check(to_upper_snake_case, "lower_snake_case", expect![["LOWER_SNAKE_CASE"]]);
         check(to_upper_snake_case, "Weird_Case", expect![["WEIRD_CASE"]]);
-        check(
-            to_upper_snake_case,
-            "UpperCamelCase",
-            expect![["UPPER_CAMEL_CASE"]],
-        );
-        check(
-            to_upper_snake_case,
-            "lowerCamelCase",
-            expect![["LOWER_CAMEL_CASE"]],
-        );
+        check(to_upper_snake_case, "UpperCamelCase", expect![["UPPER_CAMEL_CASE"]]);
+        check(to_upper_snake_case, "lowerCamelCase", expect![["LOWER_CAMEL_CASE"]]);
         check(to_upper_snake_case, "A", expect![[""]]);
         check(to_upper_snake_case, "ABC", expect![[""]]);
         check(to_upper_snake_case, "X86_64", expect![[""]]);