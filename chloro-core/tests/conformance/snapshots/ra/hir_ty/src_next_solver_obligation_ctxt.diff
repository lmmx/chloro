COMPARISON DIFF
============================================================

Original size: 6182 bytes
Chloro size:   6224 bytes
Rustfmt size:  6332 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir_def::TraitId;
 use rustc_type_ir::{TypeFoldable, Upcast, Variance};
 
 use crate::next_solver::{
-    fulfill::{FulfillmentCtxt, NextSolverError},
+    at::ToTrace,
+
+    fulfill::{FulfillmentCtxt,
+
     infer::{
-        at::ToTrace,
-        traits::{Obligation, ObligationCause, PredicateObligation, PredicateObligations},
-        InferCtxt, InferOk,
-    },
-    Const, DbInterner, ParamEnv, Term, TraitRef, Ty, TypeError,
+        InferCtxt,
+
+    traits::{Obligation,
+
+    Const, DbInterner, InferOk, NextSolverError}, ObligationCause, ParamEnv, PredicateObligation,
+    PredicateObligations}, Term, TraitRef, Ty, TypeError, },
 };
 
 /// Used if you want to have pleasant experience when dealing
 
 impl<'a, 'db> ObligationCtxt<'a, 'db> {
     pub fn new(infcx: &'a InferCtxt<'db>) -> Self {
-        Self {
-            infcx,
-            engine: FulfillmentCtxt::new(infcx),
-        }
+        Self { infcx, engine: FulfillmentCtxt::new(infcx) }
     }
 }
 
 impl<'a, 'db> ObligationCtxt<'a, 'db> {
-    pub fn register_obligation(&mut self, obligation: PredicateObligation<'db>) {
-        self.engine
-            .register_predicate_obligation(self.infcx, obligation);
+    pub fn register_obligation(
+        &mut self,
+        obligation: PredicateObligation<'db>,
+    ) {
+        self.engine.register_predicate_obligation(self.infcx, obligation);
     }
 
     pub fn register_obligations(
         &mut self,
         obligations: impl IntoIterator<Item = PredicateObligation<'db>>,
     ) {
-        self.engine
-            .register_predicate_obligations(self.infcx, obligations);
+        self.engine.register_predicate_obligations(self.infcx, obligations);
     }
 
-    pub fn register_infer_ok_obligations<T>(&mut self, infer_ok: InferOk<'db, T>) -> T {
+    pub fn register_infer_ok_obligations<T>(
+        &mut self,
+        infer_ok: InferOk<'db, T>,
+    ) -> T {
         let InferOk { value, obligations } = infer_ok;
         self.register_obligations(obligations);
         value
 
     #[must_use]
     pub fn evaluate_obligations_error_on_ambiguity(&mut self) -> Vec<NextSolverError<'db>> {
-        self.engine
-            .evaluate_obligations_error_on_ambiguity(self.infcx)
+        self.engine.evaluate_obligations_error_on_ambiguity(self.infcx)
     }
 
     /// Returns the not-yet-processed and stalled obligations from the
         param_env: ParamEnv<'db>,
         value: Ty<'db>,
     ) -> Result<Ty<'db>, Vec<NextSolverError<'db>>> {
-        self.infcx
-            .at(cause, param_env)
-            .structurally_normalize_ty(value, &mut self.engine)
+        self.infcx.at(cause, param_env).structurally_normalize_ty(value, &mut self.engine)
     }
 
     pub fn structurally_normalize_const(
         param_env: ParamEnv<'db>,
         value: Const<'db>,
     ) -> Result<Const<'db>, Vec<NextSolverError<'db>>> {
-        self.infcx
-            .at(cause, param_env)
-            .structurally_normalize_const(value, &mut self.engine)
+        self.infcx.at(cause, param_env).structurally_normalize_const(value, &mut self.engine)
     }
 
     pub fn structurally_normalize_term(
         param_env: ParamEnv<'db>,
         value: Term<'db>,
     ) -> Result<Term<'db>, Vec<NextSolverError<'db>>> {
-        self.infcx
-            .at(cause, param_env)
-            .structurally_normalize_term(value, &mut self.engine)
+        self.infcx.at(cause, param_env).structurally_normalize_term(value, &mut self.engine)
     }
 }