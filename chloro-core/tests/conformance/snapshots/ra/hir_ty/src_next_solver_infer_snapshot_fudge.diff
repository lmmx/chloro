COMPARISON DIFF
============================================================

Original size: 10383 bytes
Chloro size:   10330 bytes
Rustfmt size:  10823 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::next_solver::{
     infer::{
-        iter_idx_range,
-        snapshot::VariableLengths,
-        type_variable::TypeVariableOrigin,
-        unify_key::{ConstVariableOrigin, ConstVariableValue, ConstVidKey},
-        InferCtxt, UnificationTable,
+        iter_idx_range, snapshot::VariableLengths, type_variable::TypeVariableOrigin,
+        unify_key::{ConstVariableOrigin, ConstVariableValue, ConstVidKey}, InferCtxt,
+        UnificationTable,
     },
     Const, ConstKind, DbInterner, Region, Ty, TyKind,
 };
         iter_idx_range(range)
             .map(|index| match table.probe_value(index) {
                 ConstVariableValue::Known { value: _ } => ConstVariableOrigin {},
-                ConstVariableValue::Unknown {
-                    origin,
-                    universe: _,
-                } => origin,
+                ConstVariableValue::Unknown { origin, universe: _ } => origin,
             })
             .collect(),
     )
         })?;
 
         // At this point, we need to replace any of the now-popped
+
         // type/region variables that appear in `value` with a fresh
+
         // variable of the appropriate kind. We can't do this during
+
         // the probe because they would just get popped then too. =)
         Ok(self.fudge_inference(snapshot_vars, value))
     }
         if snapshot_vars.is_empty() {
             value
         } else {
-            value.fold_with(&mut InferenceFudger {
-                infcx: self,
-                snapshot_vars,
-            })
+            value.fold_with(&mut InferenceFudger { infcx: self, snapshot_vars })
         }
     }
 }
         let region_vars = inner
             .unwrap_region_constraints()
             .vars_since_snapshot(vars_pre_snapshot.region_constraints_len);
-        let type_vars = inner
-            .type_variables()
-            .vars_since_snapshot(vars_pre_snapshot.type_var_len);
-        let int_vars = vars_since_snapshot(
-            &inner.int_unification_table(),
-            vars_pre_snapshot.int_var_len,
-        );
-        let float_vars = vars_since_snapshot(
-            &inner.float_unification_table(),
-            vars_pre_snapshot.float_var_len,
-        );
+        let type_vars = inner.type_variables().vars_since_snapshot(vars_pre_snapshot.type_var_len);
+        let int_vars =
+            vars_since_snapshot(&inner.int_unification_table(), vars_pre_snapshot.int_var_len);
+        let float_vars =
+            vars_since_snapshot(&inner.float_unification_table(), vars_pre_snapshot.float_var_len);
 
         let const_vars = const_vars_since_snapshot(
             &mut inner.const_unification_table(),
             vars_pre_snapshot.const_var_len,
         );
-        SnapshotVarData {
-            region_vars,
-            type_vars,
-            int_vars,
-            float_vars,
-            const_vars,
-        }
+        SnapshotVarData { region_vars, type_vars, int_vars, float_vars, const_vars }
     }
 
     fn is_empty(&self) -> bool {
-        let SnapshotVarData {
-            region_vars,
-            type_vars,
-            int_vars,
-            float_vars,
-            const_vars,
-        } = self;
-        region_vars.is_empty()
-            && type_vars.0.is_empty()
-            && int_vars.is_empty()
-            && float_vars.is_empty()
-            && const_vars.0.is_empty()
+        let SnapshotVarData { region_vars, type_vars, int_vars, float_vars, const_vars } = self;
+        region_vars.is_empty() && type_vars.0.is_empty() && int_vars.is_empty() && float_vars.is_empty() && const_vars.0.is_empty()
     }
 }
 
                         // variables to their binding anyhow, we know
                         // that it is unbound, so we can just return
                         // it.
-                        debug_assert!(self
-                            .infcx
-                            .inner
-                            .borrow_mut()
-                            .type_variables()
-                            .probe(vid)
-                            .is_unknown());
+                        debug_assert!(
+                            self.infcx.inner.borrow_mut().type_variables().probe(vid).is_unknown()
+                        );
                         ty
                     }
                 }