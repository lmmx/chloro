COMPARISON DIFF
============================================================

Original size: 99713 bytes
Chloro size:   99264 bytes
Rustfmt size:  101455 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use rustc_type_ir::{
     AliasTyKind, BoundVarIndexKind, CoroutineArgsParts, CoroutineClosureArgsParts, RegionKind,
     Upcast,
-    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
+    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Tys as _, Ty as _},
 };
 use smallvec::SmallVec;
 use span::Edition;
     mir::pad16,
     next_solver::{
         AliasTy, Clause, ClauseKind, Const, ConstKind, DbInterner, EarlyBinder,
-        ExistentialPredicate, FnSig, GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Term,
-        TraitRef, Ty, TyKind, TypingMode,
-        abi::Safety,
+        ExistentialPredicate, FnSig, GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId,
+        Term, TraitRef, Ty, TyKind, TypingMode, abi::Safety,
         infer::{DbInternerInferExt, traits::ObligationCause},
     },
     primitive,
     utils::{self, detect_variant_from_bytes},
 };
 
-pub trait HirWrite: fmt::Write {
+pub trait HirWrite {
     fn start_location_link(&mut self, _location: ModuleDefId) {}
+
     fn end_location_link(&mut self) {}
 }
 
-// String will ignore link metadata
 impl HirWrite for String {}
 
-// `core::Formatter` will ignore metadata
 impl HirWrite for fmt::Formatter<'_> {}
 
 pub struct HirFormatter<'a, 'db> {
     bounds_formatting_ctx: BoundsFormattingCtx<'db>,
 }
 
-// FIXME: To consider, ref and dyn trait lifetimes can be omitted if they are `'_`, path args should
-// not be when in signatures
-// So this enum does not encode this well enough
-// Also 'static can be omitted for ref and dyn trait lifetimes in static/const item types
-// FIXME: Also named lifetimes may be rendered in places where their name is not in scope?
 #[derive(Copy, Clone)]
 pub enum DisplayLifetime {
     Always,
 #[derive(Default)]
 enum BoundsFormattingCtx<'db> {
     Entered {
+        //. prevent recursing into their bounds to avoid infinite loops.
         /// We can have recursive bounds like the following case:
         /// ```ignore
         /// where
         ///     T::FooAssoc: Baz<<T::FooAssoc as Bar>::BarAssoc> + Bar
         /// ```
         /// So, record the projection types met while formatting bounds and
-        //. prevent recursing into their bounds to avoid infinite loops.
         projection_tys_met: FxHashSet<AliasTy<'db>>,
     },
     #[default]
         format_bounds: F,
     ) -> T {
         match self.bounds_formatting_ctx {
-            BoundsFormattingCtx::Entered {
-                ref mut projection_tys_met,
-            } => {
+            BoundsFormattingCtx::Entered { ref mut projection_tys_met } => {
                 projection_tys_met.insert(target);
                 format_bounds(self)
             }
                 matches!(lifetime.kind(), RegionKind::ReEarlyParam(_))
             }
             DisplayLifetime::OnlyNamedOrStatic => {
-                matches!(
-                    lifetime.kind(),
-                    RegionKind::ReStatic | RegionKind::ReEarlyParam(_)
-                )
+                matches!(lifetime.kind(), RegionKind::ReStatic | RegionKind::ReEarlyParam(_))
             }
             DisplayLifetime::Never => false,
         }
             omit_verbose_types: false,
             closure_style: ClosureStyle::ImplFn,
             display_target: DisplayTarget::from_crate(db, module_id.krate()),
-            display_kind: DisplayKind::SourceCode {
-                target_module_id: module_id,
-                allow_opaque,
-            },
+            display_kind: DisplayKind::SourceCode { target_module_id: module_id, allow_opaque },
             show_container_bounds: false,
             display_lifetimes: DisplayLifetime::OnlyNamedOrStatic,
             bounds_formatting_ctx: Default::default(),
     /// `FmtError` is required to be compatible with std::fmt::Display
     FmtError,
 }
+
 impl From<fmt::Error> for HirDisplayError {
     fn from(_: fmt::Error) -> Self {
         Self::FmtError
     pub fn write_to<F: HirWrite>(&self, f: &mut F) -> Result<(), HirDisplayError> {
         let krate = self.display_target.krate;
         let block = match self.display_kind {
-            DisplayKind::SourceCode {
-                target_module_id, ..
-            } => target_module_id.containing_block(),
+            DisplayKind::SourceCode { target_module_id, .. } => target_module_id.containing_block(),
             DisplayKind::Diagnostics | DisplayKind::Test => None,
         };
         let interner = DbInterner::new_with(self.db, Some(krate), block);
     write!(
         f,
         ">::{}",
-        f.db.type_alias_signature(alias.def_id.expect_type_alias())
-            .name
-            .display(f.db, f.edition())
+        f.db.type_alias_signature(alias.def_id.expect_type_alias()).name.display(f.db, f.edition())
     )?;
     let proj_params = &alias.args.as_slice()[trait_ref.args.len()..];
     hir_fmt_generics(f, proj_params, None, None)
             ConstKind::Param(param) => {
                 let generics = generics(f.db, param.id.parent());
                 let param_data = &generics[param.id.local_id()];
-                write!(
-                    f,
-                    "{}",
-                    param_data.name().unwrap().display(f.db, f.edition())
-                )?;
+                write!(f, "{}", param_data.name().unwrap().display(f.db, f.edition()))?;
                 Ok(())
             }
             ConstKind::Value(const_bytes) => render_const_scalar(
 ) -> Result<(), HirDisplayError> {
     let trait_env = TraitEnvironment::empty(f.krate());
     let infcx = f.interner.infer_ctxt().build(TypingMode::PostAnalysis);
-    let ty = infcx
-        .at(&ObligationCause::new(), trait_env.env)
-        .deeply_normalize(ty)
-        .unwrap_or(ty);
+    let ty = infcx.at(&ObligationCause::new(), trait_env.env).deeply_normalize(ty).unwrap_or(ty);
     render_const_scalar_inner(f, b, memory_map, ty, trait_env)
 }
 
                 // FIXME(#17451): Replace with builtins once they are stabilised.
                 let it = f16::from_bits(u16::from_le_bytes(b.try_into().unwrap()).into());
                 let s = it.to_string();
-                if s.strip_prefix('-')
-                    .unwrap_or(&s)
-                    .chars()
-                    .all(|c| c.is_ascii_digit())
-                {
+                if s.strip_prefix('-').unwrap_or(&s).chars().all(|c| c.is_ascii_digit()) {
                     // Match Rust debug formatting
                     write!(f, "{s}.0")
                 } else {
                 // FIXME(#17451): Replace with builtins once they are stabilised.
                 let it = f128::from_bits(u128::from_le_bytes(b.try_into().unwrap()));
                 let s = it.to_string();
-                if s.strip_prefix('-')
-                    .unwrap_or(&s)
-                    .chars()
-                    .all(|c| c.is_ascii_digit())
-                {
+                if s.strip_prefix('-').unwrap_or(&s).chars().all(|c| c.is_ascii_digit()) {
                     // Match Rust debug formatting
                     write!(f, "{s}.0")
                 } else {
                     )
                 }
                 hir_def::AdtId::UnionId(u) => {
-                    write!(
-                        f,
-                        "{}",
-                        f.db.union_signature(u).name.display(f.db, f.edition())
-                    )
+                    write!(f, "{}", f.db.union_signature(u).name.display(f.db, f.edition()))
                 }
                 hir_def::AdtId::EnumId(e) => {
                     let Ok(target_data_layout) = f.db.target_data_layout(trait_env.krate) else {
     match data.shape {
         FieldsShape::Record | FieldsShape::Tuple => {
             let render_field = |f: &mut HirFormatter<'_, 'db>, id: LocalFieldId| {
-                let offset = layout
-                    .fields
-                    .offset(u32::from(id.into_raw()) as usize)
-                    .bytes_usize();
+                let offset = layout.fields.offset(u32::from(id.into_raw()) as usize).bytes_usize();
                 let ty = field_types[id].instantiate(f.interner, args);
                 let Ok(layout) = f.db.layout_of_ty(ty, trait_env.clone()) else {
                     return f.write_str("<layout-error>");
 
                             // Don't count Sized but count when it absent
                             // (i.e. when explicit ?Sized bound is set).
-                            let default_sized = SizedByDefault::Sized {
-                                anchor: func.krate(db),
-                            };
+                            let default_sized = SizedByDefault::Sized { anchor: func.krate(db) };
                             let sized_bounds = bounds()
                                 .filter(|b| {
                                     matches!(
                 write!(f, "fn ")?;
                 f.start_location_link(def.into());
                 match def {
-                    CallableDefId::FunctionId(ff) => write!(
-                        f,
-                        "{}",
-                        db.function_signature(ff).name.display(f.db, f.edition())
-                    )?,
-                    CallableDefId::StructId(s) => write!(
-                        f,
-                        "{}",
-                        db.struct_signature(s).name.display(f.db, f.edition())
-                    )?,
+                    CallableDefId::FunctionId(ff) => {
+                        write!(f, "{}", db.function_signature(ff).name.display(f.db, f.edition()))?
+                    }
+                    CallableDefId::StructId(s) => {
+                        write!(f, "{}", db.struct_signature(s).name.display(f.db, f.edition()))?
+                    }
                     CallableDefId::EnumVariantId(e) => {
                         let loc = e.lookup(db);
                         write!(
                         };
                         write!(f, "{}", name.display(f.db, f.edition()))?;
                     }
-                    DisplayKind::SourceCode {
-                        target_module_id: module_id,
-                        allow_opaque: _,
-                    } => {
+                    DisplayKind::SourceCode { target_module_id: module_id, allow_opaque: _ } => {
                         if let Some(path) = find_path::find_path(
                             db,
                             ItemInNs::Types(def_id.into()),
                 let impl_trait_id = db.lookup_intern_impl_trait_id(opaque_ty_id);
                 match impl_trait_id {
                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {
-                        let datas = db
-                            .return_type_impl_traits(func)
-                            .expect("impl trait id without data");
-                        let data = (*datas)
-                            .as_ref()
-                            .map_bound(|rpit| &rpit.impl_traits[idx].predicates);
+                        let datas =
+                            db.return_type_impl_traits(func).expect("impl trait id without data");
+                        let data =
+                            (*datas).as_ref().map_bound(|rpit| &rpit.impl_traits[idx].predicates);
                         let bounds = data
                             .iter_instantiated_copied(interner, alias_ty.args.as_slice())
                             .collect::<Vec<_>>();
                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution
                     }
                     ImplTraitId::TypeAliasImplTrait(alias, idx) => {
-                        let datas = db
-                            .type_alias_impl_traits(alias)
-                            .expect("impl trait id without data");
-                        let data = (*datas)
-                            .as_ref()
-                            .map_bound(|rpit| &rpit.impl_traits[idx].predicates);
+                        let datas =
+                            db.type_alias_impl_traits(alias).expect("impl trait id without data");
+                        let data =
+                            (*datas).as_ref().map_bound(|rpit| &rpit.impl_traits[idx].predicates);
                         let bounds = data
                             .iter_instantiated_copied(interner, alias_ty.args.as_slice())
                             .collect::<Vec<_>>();
                         );
                     }
                     ClosureStyle::ClosureWithSubst => {
-                        write!(
-                            f,
-                            "{{closure#{:?}}}",
-                            salsa::plumbing::AsId::as_id(&id).index()
-                        )?;
+                        write!(f, "{{closure#{:?}}}", salsa::plumbing::AsId::as_id(&id).index())?;
                         return hir_fmt_generics(f, substs.as_slice(), None, None);
                     }
                     _ => (),
                     }
                     _ => (),
                 }
-                let CoroutineClosureArgsParts {
-                    closure_kind_ty,
-                    signature_parts_ty,
-                    ..
-                } = args.split_coroutine_closure_args();
+                let CoroutineClosureArgsParts { closure_kind_ty, signature_parts_ty, .. } =
+                    args.split_coroutine_closure_args();
                 let kind = closure_kind_ty.to_opt_closure_kind().unwrap();
                 let kind = match kind {
                     rustc_type_ir::ClosureKind::Fn => "AsyncFn",
             TyKind::Infer(..) => write!(f, "_")?,
             TyKind::Coroutine(coroutine_id, subst) => {
                 let InternedCoroutine(owner, expr_id) = coroutine_id.0.loc(db);
-                let CoroutineArgsParts {
-                    resume_ty,
-                    yield_ty,
-                    return_ty,
-                    ..
-                } = subst.split_coroutine_args();
+                let CoroutineArgsParts { resume_ty, yield_ty, return_ty, .. } =
+                    subst.split_coroutine_args();
                 let body = db.body(owner);
                 let expr = &body[expr_id];
                 match expr {
 
 impl<'db> HirDisplay<'db> for PolyFnSig<'db> {
     fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError> {
-        let FnSig {
-            inputs_and_output,
-            c_variadic,
-            safety,
-            abi: _,
-        } = self.skip_binder();
+        let FnSig { inputs_and_output, c_variadic, safety, abi: _ } = self.skip_binder();
         if let Safety::Unsafe = safety {
             write!(f, "unsafe ")?;
         }
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum SizedByDefault {
     NotSized,
-    Sized { anchor: Crate },
+    Sized {
+        anchor: Crate,
+    },
 }
 
 impl SizedByDefault {
     default_sized: SizedByDefault,
 ) -> Result<(), HirDisplayError> {
     write!(f, "{prefix}")?;
-    if !predicates.is_empty()
-        || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })
-    {
+    if !predicates.is_empty() || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. }) {
         write!(f, " ")?;
         write_bounds_like_dyn_trait(f, this, predicates, default_sized)
     } else {
                 // existential) here, which is the only thing that's
                 // possible in actual Rust, and hence don't print it
                 f.start_location_link(trait_.into());
-                write!(
-                    f,
-                    "{}",
-                    f.db.trait_signature(trait_).name.display(f.db, f.edition())
-                )?;
+                write!(f, "{}", f.db.trait_signature(trait_).name.display(f.db, f.edition()))?;
                 f.end_location_link();
                 if is_fn_trait {
                     if let [_self, params @ ..] = trait_ref.trait_ref.args.as_slice()
     fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError> {
         let trait_ = self.def_id.0;
         f.start_location_link(trait_.into());
-        write!(
-            f,
-            "{}",
-            f.db.trait_signature(trait_).name.display(f.db, f.edition())
-        )?;
+        write!(f, "{}", f.db.trait_signature(trait_).name.display(f.db, f.edition()))?;
         f.end_location_link();
         let substs = self.args.as_slice();
         hir_fmt_generic_args(f, &substs[1..], None, Some(self.self_ty()))
                 Ok(())
             } else if root_module_id == vis_id && !root_module_id.is_within_block() {
                 write!(f, "pub(crate) ")
-            } else if module_id.containing_module(f.db) == Some(vis_id) && !vis_id.is_block_module()
-            {
+            } else if module_id.containing_module(f.db) == Some(vis_id) && !vis_id.is_block_module() {
                 write!(f, "pub(super) ")
             } else {
                 write!(f, "pub(in ...) ")
     ) -> Result<(), HirDisplayError>;
 }
 
-impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db>
-    for &'_ T
-{
+impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db> for &'_ T {
     fn hir_fmt(
         &self,
         f: &mut HirFormatter<'_, 'db>,
         T::hir_fmt(&self.0, f, self.1)
     }
 }
+
 impl<'db> HirDisplayWithExpressionStore<'db> for LifetimeRefId {
     fn hir_fmt(
         &self,
                 write!(
                     f,
                     "{}",
-                    generic_params[lifetime_param_id.local_id]
-                        .name
-                        .display(f.db, f.edition())
+                    generic_params[lifetime_param_id.local_id].name.display(f.db, f.edition())
                 )
             }
         }
                                 .iter()
                                 .filter_map(|it| match it {
                                     WherePredicate::TypeBound { target, bound }
-                                    | WherePredicate::ForLifetime {
-                                        lifetimes: _,
-                                        target,
-                                        bound,
-                                    } if matches!(
-                                        store[*target],
-                                        TypeRef::TypeParam(t) if t == *param
-                                    ) =>
+                                    | WherePredicate::ForLifetime { lifetimes: _, target, bound }
+                                        if matches!(
+                                            store[*target],
+                                            TypeRef::TypeParam(t) if t == *param
+                                        ) =>
                                     {
                                         Some(bound)
                                     }
             }
             TypeRef::ImplTrait(bounds) => {
                 write!(f, "impl ")?;
-                f.write_joined(
-                    bounds.iter().map(ExpressionStoreAdapter::wrap(store)),
-                    " + ",
-                )?;
+                f.write_joined(bounds.iter().map(ExpressionStoreAdapter::wrap(store)), " + ")?;
             }
             TypeRef::DynTrait(bounds) => {
                 write!(f, "dyn ")?;
-                f.write_joined(
-                    bounds.iter().map(ExpressionStoreAdapter::wrap(store)),
-                    " + ",
-                )?;
+                f.write_joined(bounds.iter().map(ExpressionStoreAdapter::wrap(store)), " + ")?;
             }
             TypeRef::Error => write!(f, "{{error}}")?,
         }
                 write!(
                     f,
                     "for<{}> ",
-                    lifetimes
-                        .iter()
-                        .map(|it| it.display(f.db, edition))
-                        .format(", ")
+                    lifetimes.iter().map(|it| it.display(f.db, edition)).format(", ")
                 )?;
                 store[*path].hir_fmt(f, store)
             }