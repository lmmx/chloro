COMPARISON DIFF
============================================================

Original size: 99713 bytes
Chloro size:   99199 bytes
Rustfmt size:  99713 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    FindPathConfig, GeneralConstId, GenericDefId, HasModule, LocalFieldId, Lookup, ModuleDefId,
-    ModuleId, TraitId,
     db::DefDatabase,
     expr_store::{ExpressionStore, path::Path},
     find_path::{self, PrefixKind},
         UseArgRef,
     },
     visibility::Visibility,
+    FindPathConfig, GeneralConstId, GenericDefId, HasModule, LocalFieldId, Lookup, ModuleDefId,
+    ModuleId, TraitId,
 };
 use hir_expand::{mod_path::PathKind, name::Name};
 use intern::{Internable, Interned, sym};
 use rustc_ast_ir::FloatTy;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
+    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
     AliasTyKind, BoundVarIndexKind, CoroutineArgsParts, CoroutineClosureArgsParts, RegionKind,
     Upcast,
-    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
 };
 use smallvec::SmallVec;
 use span::Edition;
 use triomphe::Arc;
 
 use crate::{
-    CallableDefId, FnAbi, ImplTraitId, MemoryMap, TraitEnvironment, consteval,
+    consteval,
     db::{HirDatabase, InternedClosure, InternedCoroutine},
     generics::generics,
     layout::Layout,
     },
     primitive,
     utils::{self, detect_variant_from_bytes},
+    CallableDefId, FnAbi, ImplTraitId, MemoryMap, TraitEnvironment,
 };
 
-pub trait HirWrite: fmt::Write {
-    fn start_location_link(&mut self, _location: ModuleDefId) {}
-    fn end_location_link(&mut self) {}
+pub trait HirWrite {
+    fn start_location_link(&mut self, _location: ModuleDefId) {
+    }
+
+    fn end_location_link(&mut self) {
+    }
 }
 
-// String will ignore link metadata
-impl HirWrite for String {}
+impl HirWrite for String {
+}
 
-// `core::Formatter` will ignore metadata
-impl HirWrite for fmt::Formatter<'_> {}
+impl HirWrite for fmt::Formatter<'_> {
+}
 
 pub struct HirFormatter<'a, 'db> {
     /// The database handle
     bounds_formatting_ctx: BoundsFormattingCtx<'db>,
 }
 
-// FIXME: To consider, ref and dyn trait lifetimes can be omitted if they are `'_`, path args should
-// not be when in signatures
-// So this enum does not encode this well enough
-// Also 'static can be omitted for ref and dyn trait lifetimes in static/const item types
-// FIXME: Also named lifetimes may be rendered in places where their name is not in scope?
 #[derive(Copy, Clone)]
 pub enum DisplayLifetime {
     Always,
         ///     T::FooAssoc: Baz<<T::FooAssoc as Bar>::BarAssoc> + Bar
         /// ```
         /// So, record the projection types met while formatting bounds and
-        //. prevent recursing into their bounds to avoid infinite loops.
         projection_tys_met: FxHashSet<AliasTy<'db>>,
     },
     #[default]
         show_container_bounds: bool,
     ) -> HirDisplayWrapper<'a, 'db, Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         assert!(
             !matches!(display_kind, DisplayKind::SourceCode { .. }),
             "HirDisplayWrapper cannot fail with DisplaySourceCodeError, use HirDisplay::hir_fmt directly instead"
         display_target: DisplayTarget,
     ) -> HirDisplayWrapper<'a, 'db, Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         HirDisplayWrapper {
             db,
             t: self,
         display_target: DisplayTarget,
     ) -> HirDisplayWrapper<'a, 'db, Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         HirDisplayWrapper {
             db,
             t: self,
         display_target: DisplayTarget,
     ) -> HirDisplayWrapper<'a, 'db, Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         HirDisplayWrapper {
             db,
             t: self,
         display_target: DisplayTarget,
     ) -> HirDisplayWrapper<'a, 'db, Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         HirDisplayWrapper {
             db,
             t: self,
         display_target: DisplayTarget,
     ) -> HirDisplayWrapper<'a, 'db, Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         HirDisplayWrapper {
             db,
             t: self,
         self.buf.clear();
         fmt::write(&mut self.buf, args)?;
         self.curr_size += self.buf.len();
-
         // Then we write to the internal formatter from the buffer
         self.fmt.write_str(&self.buf).map_err(HirDisplayError::from)
     }
     Diagnostics,
     /// Display types for inserting them in source files.
     /// The generated code should compile, so paths need to be qualified.
-    SourceCode { target_module_id: ModuleId, allow_opaque: bool },
+    SourceCode {
+        target_module_id: ModuleId,
+        allow_opaque: bool,
+    },
     /// Only for test purpose to keep real types
     Test,
 }
     /// `FmtError` is required to be compatible with std::fmt::Display
     FmtError,
 }
+
 impl From<fmt::Error> for HirDisplayError {
     fn from(_: fmt::Error) -> Self {
         Self::FmtError
 
 impl<'db, T> fmt::Display for HirDisplayWrapper<'_, 'db, T>
 where
-    T: HirDisplay<'db>,
-{
+    T: HirDisplay<'db>, {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         match self.write_to(f) {
             Ok(()) => Ok(()),
     }
     let trait_ref = alias.trait_ref(f.interner);
     let self_ty = trait_ref.self_ty();
-
     // if we are projection on a type parameter, check if the projection target has bounds
     // itself, if so, we render them directly as `impl Bound` instead of the less useful
     // `<Param as Trait>::Assoc`
             });
         }
     }
-
     write!(f, "<")?;
     self_ty.hir_fmt(f)?;
     write!(f, " as ")?;
         if f.should_truncate() {
             return write!(f, "{TYPE_HINT_TRUNCATION}");
         }
-
         use TyKind;
         match self.kind() {
             TyKind::Never => write!(f, "!")?,
     if parameters.is_empty() {
         return Ok(());
     }
-
     let parameters_to_write = generic_args_sans_defaults(f, generic_def, parameters);
-
     if !parameters_to_write.is_empty() {
         write!(f, "<")?;
         hir_fmt_generic_arguments(f, parameters_to_write, self_)?;
         write!(f, ">")?;
     }
-
     Ok(())
 }
 
     if parameters.is_empty() {
         return Ok(());
     }
-
     let parameters_to_write = generic_args_sans_defaults(f, generic_def, parameters);
-
     if !parameters_to_write.is_empty() {
         write!(f, "<")?;
         hir_fmt_generic_arguments(f, parameters_to_write, self_)?;
         write!(f, ">")?;
     }
-
     Ok(())
 }
 
 ) -> Result<(), HirDisplayError> {
     let mut first = true;
     let lifetime_offset = parameters.iter().position(|arg| arg.region().is_some());
-
     let (ty_or_const, lifetimes) = match lifetime_offset {
         Some(offset) => parameters.split_at(offset),
         None => (parameters, &[][..]),
     self_: Option<Ty<'db>>,
 ) -> Result<(), HirDisplayError> {
     let mut first = true;
-
     for ty in tys {
         if !mem::take(&mut first) {
             write!(f, ", ")?;
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum SizedByDefault {
     NotSized,
-    Sized { anchor: Crate },
+    Sized {
+        anchor: Crate,
+    },
 }
 
 impl SizedByDefault {
     ) -> Result<(), HirDisplayError>;
 }
 
-impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db>
-    for &'_ T
-{
+impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db> for &'_ T {
     fn hir_fmt(
         &self,
         f: &mut HirFormatter<'_, 'db>,
         T::hir_fmt(&self.0, f, self.1)
     }
 }
+
 impl<'db> HirDisplayWithExpressionStore<'db> for LifetimeRefId {
     fn hir_fmt(
         &self,
     ) -> Result<(), HirDisplayError> {
         // FIXME
         write!(f, "{{const}}")?;
-
         Ok(())
     }
 }
                 write!(f, "{name}")?
             }
         }
-
         // Convert trait's `Self` bound back to the surface syntax. Note there is no associated
         // trait, so there can only be one path segment that `has_self_type`. The `Self` type
         // itself can contain further qualified path through, which will be handled by recursive
             write!(f, " as ")?;
             // Now format the path of the trait...
         }
-
         for (seg_idx, segment) in self.segments().iter().enumerate() {
             if !matches!(self.kind(), PathKind::Plain) || seg_idx > 0 {
                 write!(f, "::")?;
                 }
             }
         }
-
         Ok(())
     }
 }