COMPARISON DIFF
============================================================

Original size: 99713 bytes
Chloro size:   98454 bytes
Rustfmt size:  99713 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    FindPathConfig, GeneralConstId, GenericDefId, HasModule, LocalFieldId, Lookup, ModuleDefId,
-    ModuleId, TraitId,
     db::DefDatabase,
-    expr_store::{ExpressionStore, path::Path},
+    expr_store::{path::Path, ExpressionStore},
     find_path::{self, PrefixKind},
     hir::generics::{TypeOrConstParamData, TypeParamProvenance, WherePredicate},
     item_scope::ItemInNs,
         UseArgRef,
     },
     visibility::Visibility,
+    FindPathConfig, GeneralConstId, GenericDefId, HasModule, LocalFieldId, Lookup, ModuleDefId,
+    ModuleId, TraitId,
 };
 use hir_expand::{mod_path::PathKind, name::Name};
-use intern::{Internable, Interned, sym};
+use intern::{sym, Internable, Interned};
 use itertools::Itertools;
 use la_arena::ArenaMap;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use rustc_ast_ir::FloatTy;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
+    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
     AliasTyKind, BoundVarIndexKind, CoroutineArgsParts, CoroutineClosureArgsParts, RegionKind,
     Upcast,
-    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
 };
 use smallvec::SmallVec;
 use span::Edition;
 use triomphe::Arc;
 
 use crate::{
-    CallableDefId, FnAbi, ImplTraitId, MemoryMap, TraitEnvironment, consteval,
+    consteval,
     db::{HirDatabase, InternedClosure, InternedCoroutine},
     generics::generics,
     layout::Layout,
     mir::pad16,
     next_solver::{
-        AliasTy, Clause, ClauseKind, Const, ConstKind, DbInterner, EarlyBinder,
-        ExistentialPredicate, FnSig, GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Term,
-        TraitRef, Ty, TyKind, TypingMode,
-        abi::Safety,
-        infer::{DbInternerInferExt, traits::ObligationCause},
+        abi::Safety, infer::{DbInternerInferExt, traits::ObligationCause}, AliasTy, Clause,
+        ClauseKind, Const, ConstKind, DbInterner, EarlyBinder, ExistentialPredicate, FnSig,
+        GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Term, TraitRef, Ty, TyKind,
+        TypingMode,
     },
     primitive,
     utils::{self, detect_variant_from_bytes},
+    CallableDefId, FnAbi, ImplTraitId, MemoryMap, TraitEnvironment,
 };
 
-pub trait HirWrite: fmt::Write {
-    fn start_location_link(&mut self, _location: ModuleDefId) {}
-    fn end_location_link(&mut self) {}
+pub trait HirWrite {
+    fn start_location_link(&mut self, _location: ModuleDefId) {
+    }
+
+    fn end_location_link(&mut self) {
+    }
 }
 
-// String will ignore link metadata
-impl HirWrite for String {}
+impl HirWrite for String {
+}
 
-// `core::Formatter` will ignore metadata
-impl HirWrite for fmt::Formatter<'_> {}
+impl HirWrite for fmt::Formatter<'_> {
+}
 
 pub struct HirFormatter<'a, 'db> {
     /// The database handle
     bounds_formatting_ctx: BoundsFormattingCtx<'db>,
 }
 
-// FIXME: To consider, ref and dyn trait lifetimes can be omitted if they are `'_`, path args should
-// not be when in signatures
-// So this enum does not encode this well enough
-// Also 'static can be omitted for ref and dyn trait lifetimes in static/const item types
-// FIXME: Also named lifetimes may be rendered in places where their name is not in scope?
 #[derive(Copy, Clone)]
 pub enum DisplayLifetime {
     Always,
 #[derive(Default)]
 enum BoundsFormattingCtx<'db> {
     Entered {
+        //. prevent recursing into their bounds to avoid infinite loops.
         /// We can have recursive bounds like the following case:
         /// ```ignore
         /// where
         ///     T::FooAssoc: Baz<<T::FooAssoc as Bar>::BarAssoc> + Bar
         /// ```
         /// So, record the projection types met while formatting bounds and
-        //. prevent recursing into their bounds to avoid infinite loops.
         projection_tys_met: FxHashSet<AliasTy<'db>>,
     },
     #[default]
                 projection_tys_met.insert(target);
                 self.bounds_formatting_ctx = BoundsFormattingCtx::Entered { projection_tys_met };
                 let res = format_bounds(self);
-                // Since we want to prevent only the infinite recursions in bounds formatting
-                // and do not want to skip formatting of other separate bounds, clear context
-                // when exiting the formatting of outermost bounds
                 self.bounds_formatting_ctx = BoundsFormattingCtx::Exited;
                 res
             }
     Diagnostics,
     /// Display types for inserting them in source files.
     /// The generated code should compile, so paths need to be qualified.
-    SourceCode { target_module_id: ModuleId, allow_opaque: bool },
+    SourceCode {
+        target_module_id: ModuleId,
+        allow_opaque: bool,
+    },
     /// Only for test purpose to keep real types
     Test,
 }
     /// `FmtError` is required to be compatible with std::fmt::Display
     FmtError,
 }
+
 impl From<fmt::Error> for HirDisplayError {
     fn from(_: fmt::Error) -> Self {
         Self::FmtError
             Ok(()) => Ok(()),
             Err(HirDisplayError::FmtError) => Err(fmt::Error),
             Err(HirDisplayError::DisplaySourceCodeError(_)) => {
-                // This should never happen
                 panic!(
                     "HirDisplay::hir_fmt failed with DisplaySourceCodeError when calling Display::fmt!"
                 )
     let self_ty = trait_ref.self_ty();
 
     // if we are projection on a type parameter, check if the projection target has bounds
+
     // itself, if so, we render them directly as `impl Bound` instead of the less useful
+
     // `<Param as Trait>::Assoc`
     if !f.display_kind.is_source_code()
         && let TyKind::Param(param) = self_ty.kind()
         }
         TyKind::Float(fl) => match fl {
             FloatTy::F16 => {
-                // FIXME(#17451): Replace with builtins once they are stabilised.
                 let it = f16::from_bits(u16::from_le_bytes(b.try_into().unwrap()).into());
                 let s = it.to_string();
                 if s.strip_prefix('-').unwrap_or(&s).chars().all(|c| c.is_ascii_digit()) {
-                    // Match Rust debug formatting
                     write!(f, "{s}.0")
                 } else {
                     write!(f, "{s}")
                 write!(f, "{it:?}")
             }
             FloatTy::F128 => {
-                // FIXME(#17451): Replace with builtins once they are stabilised.
                 let it = f128::from_bits(u128::from_le_bytes(b.try_into().unwrap()));
                 let s = it.to_string();
                 if s.strip_prefix('-').unwrap_or(&s).chars().all(|c| c.is_ascii_digit()) {
-                    // Match Rust debug formatting
                     write!(f, "{s}.0")
                 } else {
                     write!(f, "{s}")
         TyKind::CoroutineWitness(_, _) => f.write_str("<coroutine-witness>"),
         TyKind::CoroutineClosure(_, _) => f.write_str("<coroutine-closure>"),
         TyKind::UnsafeBinder(_) => f.write_str("<unsafe-binder>"),
-        // The below arms are unreachable, since const eval will bail out before here.
         TyKind::Foreign(_) => f.write_str("<extern-type>"),
         TyKind::Pat(_, _) => f.write_str("<pat>"),
         TyKind::Error(..)
         | TyKind::Param(_)
         | TyKind::Bound(_, _)
         | TyKind::Infer(_) => f.write_str("<placeholder-or-unknown-type>"),
-        // The below arms are unreachable, since we handled them in ref case.
         TyKind::Slice(_) | TyKind::Str | TyKind::Dynamic(_, _) => f.write_str("<unsized-value>"),
     }
 }
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum SizedByDefault {
     NotSized,
-    Sized { anchor: Crate },
+    Sized {
+        anchor: Crate,
+    },
 }
 
 impl SizedByDefault {
     default_sized: SizedByDefault,
 ) -> Result<(), HirDisplayError> {
     write!(f, "{prefix}")?;
-    if !predicates.is_empty()
-        || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })
-    {
+    if !predicates.is_empty() || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. }) {
         write!(f, " ")?;
         write_bounds_like_dyn_trait(f, this, predicates, default_sized)
     } else {
             let def_map = module_id.def_map(f.db);
             let root_module_id = def_map.module_id(DefMap::ROOT);
             if vis_id == module_id {
-                // pub(self) or omitted
                 Ok(())
             } else if root_module_id == vis_id && !root_module_id.is_within_block() {
                 write!(f, "pub(crate) ")
-            } else if module_id.containing_module(f.db) == Some(vis_id) && !vis_id.is_block_module()
-            {
+            } else if module_id.containing_module(f.db) == Some(vis_id) && !vis_id.is_block_module() {
                 write!(f, "pub(super) ")
             } else {
                 write!(f, "pub(in ...) ")
     ) -> Result<(), HirDisplayError>;
 }
 
-impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db>
-    for &'_ T
-{
+impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db> for &'_ T {
     fn hir_fmt(
         &self,
         f: &mut HirFormatter<'_, 'db>,
         T::hir_fmt(&self.0, f, self.1)
     }
 }
+
 impl<'db> HirDisplayWithExpressionStore<'db> for LifetimeRefId {
     fn hir_fmt(
         &self,
         }
 
         // Convert trait's `Self` bound back to the surface syntax. Note there is no associated
+
         // trait, so there can only be one path segment that `has_self_type`. The `Self` type
+
         // itself can contain further qualified path through, which will be handled by recursive
+
         // `hir_fmt`s.
+
         //
+
         // `trait_mod::Trait<Self = type_mod::Type, Args>::Assoc`
+
         // =>
+
         // `<type_mod::Type as trait_mod::Trait<Args>>::Assoc`
         let trait_self_ty = self.segments().iter().find_map(|seg| {
             let generic_args = seg.args_and_bindings?;
         match self {
             hir_def::expr_store::path::GenericArg::Type(ty) => ty.hir_fmt(f, store),
             hir_def::expr_store::path::GenericArg::Const(_c) => {
-                // write!(f, "{}", c.display(f.db, f.edition()))
                 write!(f, "<expr>")
             }
             hir_def::expr_store::path::GenericArg::Lifetime(lifetime) => lifetime.hir_fmt(f, store),