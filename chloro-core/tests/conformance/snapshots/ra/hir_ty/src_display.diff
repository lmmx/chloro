COMPARISON DIFF
============================================================

Original size: 99713 bytes
Chloro size:   98496 bytes
Rustfmt size:  99713 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    FindPathConfig, GeneralConstId, GenericDefId, HasModule, LocalFieldId, Lookup, ModuleDefId,
-    ModuleId, TraitId,
     db::DefDatabase,
-    expr_store::{ExpressionStore, path::Path},
+    expr_store::{path::Path, ExpressionStore},
     find_path::{self, PrefixKind},
     hir::generics::{TypeOrConstParamData, TypeParamProvenance, WherePredicate},
     item_scope::ItemInNs,
         UseArgRef,
     },
     visibility::Visibility,
+    FindPathConfig, GeneralConstId, GenericDefId, HasModule, LocalFieldId, Lookup, ModuleDefId,
+    ModuleId, TraitId,
 };
 use hir_expand::{mod_path::PathKind, name::Name};
-use intern::{Internable, Interned, sym};
+use intern::{sym, Internable, Interned};
 use itertools::Itertools;
 use la_arena::ArenaMap;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use rustc_ast_ir::FloatTy;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
+    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
     AliasTyKind, BoundVarIndexKind, CoroutineArgsParts, CoroutineClosureArgsParts, RegionKind,
     Upcast,
-    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
 };
 use smallvec::SmallVec;
 use span::Edition;
 use triomphe::Arc;
 
 use crate::{
-    CallableDefId, FnAbi, ImplTraitId, MemoryMap, TraitEnvironment, consteval,
+    consteval,
     db::{HirDatabase, InternedClosure, InternedCoroutine},
     generics::generics,
     layout::Layout,
     mir::pad16,
     next_solver::{
-        AliasTy, Clause, ClauseKind, Const, ConstKind, DbInterner, EarlyBinder,
-        ExistentialPredicate, FnSig, GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Term,
-        TraitRef, Ty, TyKind, TypingMode,
-        abi::Safety,
-        infer::{DbInternerInferExt, traits::ObligationCause},
+        abi::Safety, infer::{DbInternerInferExt, traits::ObligationCause}, AliasTy, Clause,
+        ClauseKind, Const, ConstKind, DbInterner, EarlyBinder, ExistentialPredicate, FnSig,
+        GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Term, TraitRef, Ty, TyKind,
+        TypingMode,
     },
     primitive,
     utils::{self, detect_variant_from_bytes},
+    CallableDefId, FnAbi, ImplTraitId, MemoryMap, TraitEnvironment,
 };
 
-pub trait HirWrite: fmt::Write {
-    fn start_location_link(&mut self, _location: ModuleDefId) {}
-    fn end_location_link(&mut self) {}
+pub trait HirWrite {
+    fn start_location_link(&mut self, _location: ModuleDefId) {
+    }
+
+    fn end_location_link(&mut self) {
+    }
 }
 
-// String will ignore link metadata
-impl HirWrite for String {}
+impl HirWrite for String {
+}
 
-// `core::Formatter` will ignore metadata
-impl HirWrite for fmt::Formatter<'_> {}
+impl HirWrite for fmt::Formatter<'_> {
+}
 
 pub struct HirFormatter<'a, 'db> {
     /// The database handle
     bounds_formatting_ctx: BoundsFormattingCtx<'db>,
 }
 
-// FIXME: To consider, ref and dyn trait lifetimes can be omitted if they are `'_`, path args should
-// not be when in signatures
-// So this enum does not encode this well enough
-// Also 'static can be omitted for ref and dyn trait lifetimes in static/const item types
-// FIXME: Also named lifetimes may be rendered in places where their name is not in scope?
 #[derive(Copy, Clone)]
 pub enum DisplayLifetime {
     Always,
 #[derive(Default)]
 enum BoundsFormattingCtx<'db> {
     Entered {
+        //. prevent recursing into their bounds to avoid infinite loops.
         /// We can have recursive bounds like the following case:
         /// ```ignore
         /// where
         ///     T::FooAssoc: Baz<<T::FooAssoc as Bar>::BarAssoc> + Bar
         /// ```
         /// So, record the projection types met while formatting bounds and
-        //. prevent recursing into their bounds to avoid infinite loops.
         projection_tys_met: FxHashSet<AliasTy<'db>>,
     },
     #[default]
         match self {
             BoundsFormattingCtx::Entered { projection_tys_met } => {
                 projection_tys_met.contains(proj)
-            }
+            },
             BoundsFormattingCtx::Exited => false,
         }
     }
             BoundsFormattingCtx::Entered { ref mut projection_tys_met } => {
                 projection_tys_met.insert(target);
                 format_bounds(self)
-            }
+            },
             BoundsFormattingCtx::Exited => {
                 let mut projection_tys_met = FxHashSet::default();
                 projection_tys_met.insert(target);
                 self.bounds_formatting_ctx = BoundsFormattingCtx::Entered { projection_tys_met };
                 let res = format_bounds(self);
-                // Since we want to prevent only the infinite recursions in bounds formatting
-                // and do not want to skip formatting of other separate bounds, clear context
-                // when exiting the formatting of outermost bounds
                 self.bounds_formatting_ctx = BoundsFormattingCtx::Exited;
                 res
-            }
+            },
         }
     }
 
             DisplayLifetime::OnlyStatic => matches!(lifetime.kind(), RegionKind::ReStatic),
             DisplayLifetime::OnlyNamed => {
                 matches!(lifetime.kind(), RegionKind::ReEarlyParam(_))
-            }
+            },
             DisplayLifetime::OnlyNamedOrStatic => {
                 matches!(lifetime.kind(), RegionKind::ReStatic | RegionKind::ReEarlyParam(_))
-            }
+            },
             DisplayLifetime::Never => false,
         }
     }
     Diagnostics,
     /// Display types for inserting them in source files.
     /// The generated code should compile, so paths need to be qualified.
-    SourceCode { target_module_id: ModuleId, allow_opaque: bool },
+    SourceCode {
+        target_module_id: ModuleId,
+        allow_opaque: bool,
+    },
     /// Only for test purpose to keep real types
     Test,
 }
     /// `FmtError` is required to be compatible with std::fmt::Display
     FmtError,
 }
+
 impl From<fmt::Error> for HirDisplayError {
     fn from(_: fmt::Error) -> Self {
         Self::FmtError
             Ok(()) => Ok(()),
             Err(HirDisplayError::FmtError) => Err(fmt::Error),
             Err(HirDisplayError::DisplaySourceCodeError(_)) => {
-                // This should never happen
                 panic!(
                     "HirDisplay::hir_fmt failed with DisplaySourceCodeError when calling Display::fmt!"
                 )
-            }
+            },
         }
     }
 }
     let self_ty = trait_ref.self_ty();
 
     // if we are projection on a type parameter, check if the projection target has bounds
+
     // itself, if so, we render them directly as `impl Bound` instead of the less useful
+
     // `<Param as Trait>::Assoc`
     if !f.display_kind.is_source_code()
         && let TyKind::Param(param) = self_ty.kind()
             ConstKind::Placeholder(_) => write!(f, "<placeholder>"),
             ConstKind::Bound(BoundVarIndexKind::Bound(db), bound_const) => {
                 write!(f, "?{}.{}", db.as_u32(), bound_const.var.as_u32())
-            }
+            },
             ConstKind::Bound(BoundVarIndexKind::Canonical, bound_const) => {
                 write!(f, "?c.{}", bound_const.var.as_u32())
-            }
+            },
             ConstKind::Infer(..) => write!(f, "#c#"),
             ConstKind::Param(param) => {
                 let generics = generics(f.db, param.id.parent());
                 let param_data = &generics[param.id.local_id()];
                 write!(f, "{}", param_data.name().unwrap().display(f.db, f.edition()))?;
                 Ok(())
-            }
+            },
             ConstKind::Value(const_bytes) => render_const_scalar(
                 f,
                 &const_bytes.value.inner().memory,
                 write!(f, "{}", c.name(f.db))?;
                 hir_fmt_generics(f, unev.args.as_slice(), c.generic_def(f.db), None)?;
                 Ok(())
-            }
+            },
             ConstKind::Error(..) => f.write_char('_'),
             ConstKind::Expr(..) => write!(f, "<const-expr>"),
         }
                 return f.write_str("<unicode-error>");
             };
             write!(f, "{c:?}")
-        }
+        },
         TyKind::Int(_) => {
             let it = i128::from_le_bytes(pad16(b, true));
             write!(f, "{it}")
-        }
+        },
         TyKind::Uint(_) => {
             let it = u128::from_le_bytes(pad16(b, false));
             write!(f, "{it}")
-        }
+        },
         TyKind::Float(fl) => match fl {
             FloatTy::F16 => {
-                // FIXME(#17451): Replace with builtins once they are stabilised.
                 let it = f16::from_bits(u16::from_le_bytes(b.try_into().unwrap()).into());
                 let s = it.to_string();
                 if s.strip_prefix('-').unwrap_or(&s).chars().all(|c| c.is_ascii_digit()) {
-                    // Match Rust debug formatting
                     write!(f, "{s}.0")
                 } else {
                     write!(f, "{s}")
                 }
-            }
+            },
             FloatTy::F32 => {
                 let it = f32::from_le_bytes(b.try_into().unwrap());
                 write!(f, "{it:?}")
-            }
+            },
             FloatTy::F64 => {
                 let it = f64::from_le_bytes(b.try_into().unwrap());
                 write!(f, "{it:?}")
-            }
+            },
             FloatTy::F128 => {
-                // FIXME(#17451): Replace with builtins once they are stabilised.
                 let it = f128::from_bits(u128::from_le_bytes(b.try_into().unwrap()));
                 let s = it.to_string();
                 if s.strip_prefix('-').unwrap_or(&s).chars().all(|c| c.is_ascii_digit()) {
-                    // Match Rust debug formatting
                     write!(f, "{s}.0")
                 } else {
                     write!(f, "{s}")
                 }
-            }
+            },
         },
         TyKind::Ref(_, t, _) => match t.kind() {
             TyKind::Str => {
                 };
                 let s = std::str::from_utf8(bytes).unwrap_or("<utf8-error>");
                 write!(f, "{s:?}")
-            }
+            },
             TyKind::Slice(ty) => {
                 let addr = usize::from_le_bytes(b[0..b.len() / 2].try_into().unwrap());
                 let count = usize::from_le_bytes(b[b.len() / 2..].try_into().unwrap());
                     render_const_scalar(f, &bytes[offset..offset + size_one], memory_map, ty)?;
                 }
                 f.write_str("]")
-            }
+            },
             TyKind::Dynamic(_, _) => {
                 let addr = usize::from_le_bytes(b[0..b.len() / 2].try_into().unwrap());
                 let ty_id = usize::from_le_bytes(b[b.len() / 2..].try_into().unwrap());
                 };
                 f.write_str("&")?;
                 render_const_scalar(f, bytes, memory_map, t)
-            }
+            },
             TyKind::Adt(adt, _) if b.len() == 2 * size_of::<usize>() => match adt.def_id().0 {
                 hir_def::AdtId::StructId(s) => {
                     let data = f.db.struct_signature(s);
                     write!(f, "&{}", data.name.display(f.db, f.edition()))?;
                     Ok(())
-                }
+                },
                 _ => f.write_str("<unsized-enum-or-union>"),
             },
             _ => {
                 };
                 f.write_str("&")?;
                 render_const_scalar(f, bytes, memory_map, t)
-            }
+            },
         },
         TyKind::Tuple(tys) => {
             let Ok(layout) = f.db.layout_of_ty(ty, trait_env.clone()) else {
                 render_const_scalar(f, &b[offset..offset + size], memory_map, ty)?;
             }
             f.write_str(")")
-        }
+        },
         TyKind::Adt(def, args) => {
             let def = def.def_id().0;
             let Ok(layout) = f.db.layout_of_adt(def, args, trait_env.clone()) else {
                         b,
                         memory_map,
                     )
-                }
+                },
                 hir_def::AdtId::UnionId(u) => {
                     write!(f, "{}", f.db.union_signature(u).name.display(f.db, f.edition()))
-                }
+                },
                 hir_def::AdtId::EnumId(e) => {
                     let Ok(target_data_layout) = f.db.target_data_layout(trait_env.krate) else {
                         return f.write_str("<target-layout-not-available>");
                         b,
                         memory_map,
                     )
-                }
+                },
             }
-        }
+        },
         TyKind::FnDef(..) => ty.hir_fmt(f),
         TyKind::FnPtr(_, _) | TyKind::RawPtr(_, _) => {
             let it = u128::from_le_bytes(pad16(b, false));
             write!(f, "{it:#X} as ")?;
             ty.hir_fmt(f)
-        }
+        },
         TyKind::Array(ty, len) => {
             let Some(len) = consteval::try_const_usize(f.db, len) else {
                 return f.write_str("<unknown-array-len>");
                 render_const_scalar(f, &b[offset..offset + size_one], memory_map, ty)?;
             }
             f.write_str("]")
-        }
+        },
         TyKind::Never => f.write_str("!"),
         TyKind::Closure(_, _) => f.write_str("<closure>"),
         TyKind::Coroutine(_, _) => f.write_str("<coroutine>"),
         TyKind::CoroutineWitness(_, _) => f.write_str("<coroutine-witness>"),
         TyKind::CoroutineClosure(_, _) => f.write_str("<coroutine-closure>"),
         TyKind::UnsafeBinder(_) => f.write_str("<unsafe-binder>"),
-        // The below arms are unreachable, since const eval will bail out before here.
         TyKind::Foreign(_) => f.write_str("<extern-type>"),
         TyKind::Pat(_, _) => f.write_str("<pat>"),
         TyKind::Error(..)
         | TyKind::Param(_)
         | TyKind::Bound(_, _)
         | TyKind::Infer(_) => f.write_str("<placeholder-or-unknown-type>"),
-        // The below arms are unreachable, since we handled them in ref case.
         TyKind::Slice(_) | TyKind::Str | TyKind::Dynamic(_, _) => f.write_str("<unsized-value>"),
     }
 }
                 write!(f, ")")?;
             }
             Ok(())
-        }
+        },
         FieldsShape::Unit => Ok(()),
     }
 }
                     }
                 }
                 &parameters[0..default_from]
-            }
+            },
         }
     } else {
         parameters
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum SizedByDefault {
     NotSized,
-    Sized { anchor: Crate },
+    Sized {
+        anchor: Crate,
+    },
 }
 
 impl SizedByDefault {
             Self::Sized { anchor } => {
                 let sized_trait = LangItem::Sized.resolve_trait(db, anchor);
                 Some(trait_) == sized_trait
-            }
+            },
         }
     }
 }
     default_sized: SizedByDefault,
 ) -> Result<(), HirDisplayError> {
     write!(f, "{prefix}")?;
-    if !predicates.is_empty()
-        || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })
-    {
+    if !predicates.is_empty() || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. }) {
         write!(f, " ")?;
         write_bounds_like_dyn_trait(f, this, predicates, default_sized)
     } else {
                 let param_data = &generics[param.id.local_id];
                 write!(f, "{}", param_data.name.display(f.db, f.edition()))?;
                 Ok(())
-            }
+            },
             RegionKind::ReBound(BoundVarIndexKind::Bound(db), idx) => {
                 write!(f, "?{}.{}", db.as_u32(), idx.var.as_u32())
-            }
+            },
             RegionKind::ReBound(BoundVarIndexKind::Canonical, idx) => {
                 write!(f, "?c.{}", idx.var.as_u32())
-            }
+            },
             RegionKind::ReVar(_) => write!(f, "_"),
             RegionKind::ReStatic => write!(f, "'static"),
             RegionKind::ReError(..) => {
                 } else {
                     write!(f, "'_")
                 }
-            }
+            },
             RegionKind::ReErased => write!(f, "'<erased>"),
             RegionKind::RePlaceholder(_) => write!(f, "<placeholder>"),
             RegionKind::ReLateParam(_) => write!(f, "<late-param>"),
             let def_map = module_id.def_map(f.db);
             let root_module_id = def_map.module_id(DefMap::ROOT);
             if vis_id == module_id {
-                // pub(self) or omitted
                 Ok(())
             } else if root_module_id == vis_id && !root_module_id.is_within_block() {
                 write!(f, "pub(crate) ")
-            } else if module_id.containing_module(f.db) == Some(vis_id) && !vis_id.is_block_module()
-            {
+            } else if module_id.containing_module(f.db) == Some(vis_id) && !vis_id.is_block_module() {
                 write!(f, "pub(super) ")
             } else {
                 write!(f, "pub(in ...) ")
             }
-        }
+        },
     }
 }
 
     ) -> Result<(), HirDisplayError>;
 }
 
-impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db>
-    for &'_ T
-{
+impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db> for &'_ T {
     fn hir_fmt(
         &self,
         f: &mut HirFormatter<'_, 'db>,
         T::hir_fmt(&self.0, f, self.1)
     }
 }
+
 impl<'db> HirDisplayWithExpressionStore<'db> for LifetimeRefId {
     fn hir_fmt(
         &self,
                     "{}",
                     generic_params[lifetime_param_id.local_id].name.display(f.db, f.edition())
                 )
-            }
+            },
         }
     }
 }
                     TraitBoundModifier::Maybe => write!(f, "?")?,
                 }
                 store[path].hir_fmt(f, store)
-            }
+            },
             TypeBound::Lifetime(lifetime) => lifetime.hir_fmt(f, store),
             TypeBound::ForLifetime(lifetimes, path) => {
                 let edition = f.edition();
                     lifetimes.iter().map(|it| it.display(f.db, edition)).format(", ")
                 )?;
                 store[*path].hir_fmt(f, store)
-            }
+            },
             TypeBound::Use(args) => {
                 write!(f, "use<")?;
                 let edition = f.edition();
                     }
                 }
                 write!(f, "> ")
-            }
+            },
             TypeBound::Error => write!(f, "{{error}}"),
         }
     }
         }
 
         // Convert trait's `Self` bound back to the surface syntax. Note there is no associated
+
         // trait, so there can only be one path segment that `has_self_type`. The `Self` type
+
         // itself can contain further qualified path through, which will be handled by recursive
+
         // `hir_fmt`s.
+
         //
+
         // `trait_mod::Trait<Self = type_mod::Type, Args>::Assoc`
+
         // =>
+
         // `<type_mod::Type as trait_mod::Trait<Args>>::Assoc`
         let trait_self_ty = self.segments().iter().find_map(|seg| {
             let generic_args = seg.args_and_bindings?;
         match self {
             hir_def::expr_store::path::GenericArg::Type(ty) => ty.hir_fmt(f, store),
             hir_def::expr_store::path::GenericArg::Const(_c) => {
-                // write!(f, "{}", c.display(f.db, f.edition()))
                 write!(f, "<expr>")
-            }
+            },
             hir_def::expr_store::path::GenericArg::Lifetime(lifetime) => lifetime.hir_fmt(f, store),
         }
     }