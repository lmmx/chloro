COMPARISON DIFF
============================================================

Original size: 99713 bytes
Chloro size:   99240 bytes
Rustfmt size:  99713 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    FindPathConfig, GeneralConstId, GenericDefId, HasModule, LocalFieldId, Lookup, ModuleDefId,
-    ModuleId, TraitId,
     db::DefDatabase,
-    expr_store::{ExpressionStore, path::Path},
+    expr_store::{path::Path, ExpressionStore},
     find_path::{self, PrefixKind},
     hir::generics::{TypeOrConstParamData, TypeParamProvenance, WherePredicate},
     item_scope::ItemInNs,
         UseArgRef,
     },
     visibility::Visibility,
+    FindPathConfig, GeneralConstId, GenericDefId, HasModule, LocalFieldId, Lookup, ModuleDefId,
+    ModuleId, TraitId,
 };
 use hir_expand::{mod_path::PathKind, name::Name};
 use intern::{Internable, Interned, sym};
 use itertools::Itertools;
 use la_arena::ArenaMap;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use rustc_ast_ir::FloatTy;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
+    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
     AliasTyKind, BoundVarIndexKind, CoroutineArgsParts, CoroutineClosureArgsParts, RegionKind,
     Upcast,
-    inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _, Tys as _},
 };
 use smallvec::SmallVec;
 use span::Edition;
 use triomphe::Arc;
 
 use crate::{
-    CallableDefId, FnAbi, ImplTraitId, MemoryMap, TraitEnvironment, consteval,
+    consteval,
     db::{HirDatabase, InternedClosure, InternedCoroutine},
     generics::generics,
     layout::Layout,
     mir::pad16,
     next_solver::{
-        AliasTy, Clause, ClauseKind, Const, ConstKind, DbInterner, EarlyBinder,
-        ExistentialPredicate, FnSig, GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Term,
-        TraitRef, Ty, TyKind, TypingMode,
-        abi::Safety,
-        infer::{DbInternerInferExt, traits::ObligationCause},
+        abi::Safety, infer::{DbInternerInferExt, traits::ObligationCause}, AliasTy, Clause,
+        ClauseKind, Const, ConstKind, DbInterner, EarlyBinder, ExistentialPredicate, FnSig,
+        GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Term, TraitRef, Ty, TyKind,
+        TypingMode,
     },
     primitive,
-    utils::{self, detect_variant_from_bytes},
+    utils::{detect_variant_from_bytes, self},
+    CallableDefId, FnAbi, ImplTraitId, MemoryMap, TraitEnvironment,
 };
 
-pub trait HirWrite: fmt::Write {
-    fn start_location_link(&mut self, _location: ModuleDefId) {}
-    fn end_location_link(&mut self) {}
+pub trait HirWrite {
+    fn start_location_link(&mut self, _location: ModuleDefId) {
+    }
+
+    fn end_location_link(&mut self) {
+    }
 }
 
-// String will ignore link metadata
-impl HirWrite for String {}
+impl HirWrite for String {
+}
 
-// `core::Formatter` will ignore metadata
-impl HirWrite for fmt::Formatter<'_> {}
+impl HirWrite for fmt::Formatter<'_> {
+}
 
 pub struct HirFormatter<'a, 'db> {
     /// The database handle
     bounds_formatting_ctx: BoundsFormattingCtx<'db>,
 }
 
-// FIXME: To consider, ref and dyn trait lifetimes can be omitted if they are `'_`, path args should
-// not be when in signatures
-// So this enum does not encode this well enough
-// Also 'static can be omitted for ref and dyn trait lifetimes in static/const item types
-// FIXME: Also named lifetimes may be rendered in places where their name is not in scope?
 #[derive(Copy, Clone)]
 pub enum DisplayLifetime {
     Always,
         ///     T::FooAssoc: Baz<<T::FooAssoc as Bar>::BarAssoc> + Bar
         /// ```
         /// So, record the projection types met while formatting bounds and
-        //. prevent recursing into their bounds to avoid infinite loops.
         projection_tys_met: FxHashSet<AliasTy<'db>>,
     },
     #[default]
     Diagnostics,
     /// Display types for inserting them in source files.
     /// The generated code should compile, so paths need to be qualified.
-    SourceCode { target_module_id: ModuleId, allow_opaque: bool },
+    SourceCode {
+        target_module_id: ModuleId,
+        allow_opaque: bool,
+    },
     /// Only for test purpose to keep real types
     Test,
 }
     /// `FmtError` is required to be compatible with std::fmt::Display
     FmtError,
 }
+
 impl From<fmt::Error> for HirDisplayError {
     fn from(_: fmt::Error) -> Self {
         Self::FmtError
     let self_ty = trait_ref.self_ty();
 
     // if we are projection on a type parameter, check if the projection target has bounds
+
     // itself, if so, we render them directly as `impl Bound` instead of the less useful
+
     // `<Param as Trait>::Assoc`
     if !f.display_kind.is_source_code()
         && let TyKind::Param(param) = self_ty.kind()
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum SizedByDefault {
     NotSized,
-    Sized { anchor: Crate },
+    Sized {
+        anchor: Crate,
+    },
 }
 
 impl SizedByDefault {
     ) -> Result<(), HirDisplayError>;
 }
 
-impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db>
-    for &'_ T
-{
+impl<'db, T: ?Sized + HirDisplayWithExpressionStore<'db>> HirDisplayWithExpressionStore<'db> for &'_ T {
     fn hir_fmt(
         &self,
         f: &mut HirFormatter<'_, 'db>,
         T::hir_fmt(&self.0, f, self.1)
     }
 }
+
 impl<'db> HirDisplayWithExpressionStore<'db> for LifetimeRefId {
     fn hir_fmt(
         &self,
         }
 
         // Convert trait's `Self` bound back to the surface syntax. Note there is no associated
+
         // trait, so there can only be one path segment that `has_self_type`. The `Self` type
+
         // itself can contain further qualified path through, which will be handled by recursive
+
         // `hir_fmt`s.
+
         //
+
         // `trait_mod::Trait<Self = type_mod::Type, Args>::Assoc`
+
         // =>
+
         // `<type_mod::Type as trait_mod::Trait<Args>>::Assoc`
         let trait_self_ty = self.segments().iter().find_map(|seg| {
             let generic_args = seg.args_and_bindings?;