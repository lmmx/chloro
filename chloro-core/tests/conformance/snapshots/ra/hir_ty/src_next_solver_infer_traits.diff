COMPARISON DIFF
============================================================

Original size: 8087 bytes
Chloro size:   8174 bytes
Rustfmt size:  8281 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use hir_def::TraitId;
 use macros::{TypeFoldable, TypeVisitable};
-use rustc_type_ir::elaborate::Elaboratable;
 use rustc_type_ir::Upcast;
+use rustc_type_ir::elaborate::Elaboratable;
 use tracing::debug;
 
 use crate::next_solver::{
     Clause, DbInterner, Goal, ParamEnv, PolyTraitPredicate, Predicate, Span, TraitPredicate,
     TraitRef, Ty,
 };
-
 use super::InferCtxt;
 
 /// The reason why we incurred this obligation; used for error reporting.
 /// scope. The eventual result is usually a `Selection` (defined below).
 #[derive(Clone, Debug, TypeVisitable, TypeFoldable)]
 pub struct Obligation<'db, T> {
+    /// The reason we have to prove this thing.
     #[type_foldable(identity)]
     #[type_visitable(ignore)]
-    /// The reason we have to prove this thing.
     pub cause: ObligationCause,
-
     /// The environment in which we should prove this thing.
     pub param_env: ParamEnv<'db>,
-
     /// The thing we are trying to prove.
     pub predicate: T,
-
     /// If we started proving this as a result of trying to prove
     /// something else, track the total depth to ensure termination.
     /// If this goes over a certain threshold, we abort compilation --
     }
 }
 
-impl<'db, T: Eq> Eq for Obligation<'db, T> {}
+impl<'db, T: Eq> Eq for Obligation<'db, T> {
+}
 
 impl<'db, T: Hash> Hash for Obligation<'db, T> {
     fn hash<H: Hasher>(&self, state: &mut H) {
 }
 
 pub(crate) type PredicateObligation<'db> = Obligation<'db, Predicate<'db>>;
+
 pub(crate) type TraitObligation<'db> = Obligation<'db, TraitPredicate<'db>>;
 
 pub(crate) type PredicateObligations<'db> = Vec<PredicateObligation<'db>>;
     ///
     /// Given `T: Trait` predicate it returns `T: !Trait` and given `T: !Trait` returns `T: Trait`.
     pub fn flip_polarity(&self, _interner: DbInterner<'db>) -> Option<PredicateObligation<'db>> {
-        Some(PredicateObligation {
+        Some(
+            PredicateObligation {
             cause: self.cause.clone(),
             param_env: self.param_env,
             predicate: self.predicate.flip_polarity()?,
             recursion_depth: self.recursion_depth,
-        })
+        },
+        )
     }
 }
 
         predicate: impl Upcast<DbInterner<'db>, O>,
     ) -> Obligation<'db, O> {
         let predicate = predicate.upcast(tcx);
-        Obligation {
-            cause,
-            param_env,
-            recursion_depth,
-            predicate,
-        }
+        Obligation { cause, param_env, recursion_depth, predicate }
     }
 
     pub fn with<P>(
         tcx: DbInterner<'db>,
         value: impl Upcast<DbInterner<'db>, P>,
     ) -> Obligation<'db, P> {
-        Obligation::with_depth(
-            tcx,
-            self.cause.clone(),
-            self.recursion_depth,
-            self.param_env,
-            value,
-        )
+        Obligation::with_depth(tcx, self.cause.clone(), self.recursion_depth, self.param_env, value)
     }
 }
 