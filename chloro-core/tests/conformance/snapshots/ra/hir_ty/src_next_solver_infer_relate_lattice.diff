COMPARISON DIFF
============================================================

Original size: 9566 bytes
Chloro size:   9212 bytes
Rustfmt size:  10026 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! [lattices]: https://en.wikipedia.org/wiki/Lattice_(order)
 
 use rustc_type_ir::{
+    AliasRelationDirection, TypeVisitableExt, Upcast, Variance,
     inherent::{IntoKind, Span as _},
     relate::{
-        combine::{super_combine_consts, super_combine_tys, PredicateEmittingRelation},
         Relate, StructurallyRelateAliases, TypeRelation, VarianceDiagInfo,
+        combine::{PredicateEmittingRelation, super_combine_consts, super_combine_tys},
     },
-    AliasRelationDirection, TypeVisitableExt, Upcast, Variance,
 };
 
 use crate::next_solver::{
-    infer::{
-        relate::RelateResult,
-        traits::{Obligation, PredicateObligations},
-        InferCtxt, TypeTrace,
-    },
     AliasTy, Binder, Const, DbInterner, Goal, ParamEnv, Predicate, PredicateKind, Region, Span, Ty,
     TyKind,
+    infer::{InferCtxt, TypeTrace, relate::RelateResult, traits::{Obligation, PredicateObligations}},
 };
 
 #[derive(Clone, Copy)]
         param_env: ParamEnv<'db>,
         kind: LatticeOpKind,
     ) -> LatticeOp<'infcx, 'db> {
-        LatticeOp {
-            infcx,
-            trace,
-            param_env,
-            kind,
-            obligations: PredicateObligations::new(),
-        }
+        LatticeOp { infcx, trace, param_env, kind, obligations: PredicateObligations::new() }
     }
 
     pub(crate) fn into_obligations(self) -> PredicateObligations<'db> {
         match variance {
             Variance::Invariant => {
                 self.obligations.extend(
-                    self.infcx
-                        .at(&self.trace.cause, self.param_env)
-                        .eq(a, b)?
-                        .into_obligations(),
+                    self.infcx.at(&self.trace.cause, self.param_env).eq(a, b)?.into_obligations(),
                 );
                 Ok(a)
             }
             }
 
             (
-                TyKind::Alias(
-                    rustc_type_ir::Opaque,
-                    AliasTy {
-                        def_id: a_def_id, ..
-                    },
-                ),
-                TyKind::Alias(
-                    rustc_type_ir::Opaque,
-                    AliasTy {
-                        def_id: b_def_id, ..
-                    },
-                ),
+                TyKind::Alias(rustc_type_ir::Opaque, AliasTy { def_id: a_def_id, .. }),
+                TyKind::Alias(rustc_type_ir::Opaque, AliasTy { def_id: b_def_id, .. }),
             ) if a_def_id == b_def_id => super_combine_tys(infcx, self, a, b),
 
             _ => super_combine_tys(infcx, self, a, b),
             self.relate_with_variance(Variance::Invariant, VarianceDiagInfo::default(), a, b)?;
             Ok(a)
         } else {
-            Ok(Binder::dummy(
-                self.relate(a.skip_binder(), b.skip_binder())?,
-            ))
+            Ok(Binder::dummy(self.relate(a.skip_binder(), b.skip_binder())?))
         }
     }
 }
 
 impl<'infcx, 'db> LatticeOp<'infcx, 'db> {
-    // Relates the type `v` to `a` and `b` such that `v` represents
-    // the LUB/GLB of `a` and `b` as appropriate.
-    //
-    // Subtle hack: ordering *may* be significant here. This method
-    // relates `v` to `a` first, which may help us to avoid unnecessary
-    // type variable obligations. See caller for details.
     fn relate_bound(&mut self, v: Ty<'db>, a: Ty<'db>, b: Ty<'db>) -> RelateResult<'db, ()> {
         let at = self.infcx.at(&self.trace.cause, self.param_env);
         match self.kind {
         preds: impl IntoIterator<Item: Upcast<DbInterner<'db>, Predicate<'db>>>,
     ) {
         self.obligations.extend(preds.into_iter().map(|pred| {
-            Obligation::new(
-                self.infcx.interner,
-                self.trace.cause.clone(),
-                self.param_env,
-                pred,
-            )
+            Obligation::new(self.infcx.interner, self.trace.cause.clone(), self.param_env, pred)
         }))
     }
 