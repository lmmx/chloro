COMPARISON DIFF
============================================================

Original size: 9566 bytes
Chloro size:   7573 bytes
Rustfmt size:  10026 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use rustc_type_ir::{
     inherent::{IntoKind, Span as _},
     relate::{
-        combine::{super_combine_consts, super_combine_tys, PredicateEmittingRelation},
-        Relate, StructurallyRelateAliases, TypeRelation, VarianceDiagInfo,
+        combine::{PredicateEmittingRelation, super_combine_consts, super_combine_tys}, Relate,
+        StructurallyRelateAliases, TypeRelation, VarianceDiagInfo,
     },
     AliasRelationDirection, TypeVisitableExt, Upcast, Variance,
 };
 
 use crate::next_solver::{
-    infer::{
-        relate::RelateResult,
-        traits::{Obligation, PredicateObligations},
-        InferCtxt, TypeTrace,
-    },
+    infer::{relate::RelateResult, traits::{Obligation, PredicateObligations}, InferCtxt, TypeTrace},
     AliasTy, Binder, Const, DbInterner, Goal, ParamEnv, Predicate, PredicateKind, Region, Span, Ty,
     TyKind,
 };
         param_env: ParamEnv<'db>,
         kind: LatticeOpKind,
     ) -> LatticeOp<'infcx, 'db> {
-        LatticeOp {
-            infcx,
-            trace,
-            param_env,
-            kind,
-            obligations: PredicateObligations::new(),
-        }
+        LatticeOp { infcx, trace, param_env, kind, obligations: PredicateObligations::new() }
     }
 
     pub(crate) fn into_obligations(self) -> PredicateObligations<'db> {
         match variance {
             Variance::Invariant => {
                 self.obligations.extend(
-                    self.infcx
-                        .at(&self.trace.cause, self.param_env)
-                        .eq(a, b)?
-                        .into_obligations(),
+                    self.infcx.at(&self.trace.cause, self.param_env).eq(a, b)?.into_obligations(),
                 );
                 Ok(a)
-            }
+            },
             Variance::Covariant => self.relate(a, b),
-            // FIXME(#41044) -- not correct, need test
             Variance::Bivariant => Ok(a),
             Variance::Contravariant => {
                 self.kind = self.kind.invert();
                 let res = self.relate(a, b);
                 self.kind = self.kind.invert();
                 res
-            }
+            },
         }
     }
 
         let b = infcx.shallow_resolve(b);
 
         match (a.kind(), b.kind()) {
-            // If one side is known to be a variable and one is not,
-            // create a variable (`v`) to represent the LUB. Make sure to
-            // relate `v` to the non-type-variable first (by passing it
-            // first to `relate_bound`). Otherwise, we would produce a
-            // subtype obligation that must then be processed.
-            //
-            // Example: if the LHS is a type variable, and RHS is
-            // `Box<i32>`, then we current compare `v` to the RHS first,
-            // which will instantiate `v` with `Box<i32>`. Then when `v`
-            // is compared to the LHS, we instantiate LHS with `Box<i32>`.
-            // But if we did in reverse order, we would create a `v <:
-            // LHS` (or vice versa) constraint and then instantiate
-            // `v`. This would require further processing to achieve same
-            // end-result; in particular, this screws up some of the logic
-            // in coercion, which expects LUB to figure out that the LHS
-            // is (e.g.) `Box<i32>`. A more obvious solution might be to
-            // iterate on the subtype obligations that are returned, but I
-            // think this suffices. -nmatsakis
             (TyKind::Infer(rustc_type_ir::TyVar(..)), _) => {
                 let v = infcx.next_ty_var();
                 self.relate_bound(v, b, a)?;
                 Ok(v)
-            }
+            },
             (_, TyKind::Infer(rustc_type_ir::TyVar(..))) => {
                 let v = infcx.next_ty_var();
                 self.relate_bound(v, a, b)?;
                 Ok(v)
-            }
-
+            },
             (
-                TyKind::Alias(
-                    rustc_type_ir::Opaque,
-                    AliasTy {
-                        def_id: a_def_id, ..
-                    },
-                ),
-                TyKind::Alias(
-                    rustc_type_ir::Opaque,
-                    AliasTy {
-                        def_id: b_def_id, ..
-                    },
-                ),
+                TyKind::Alias(rustc_type_ir::Opaque, AliasTy { def_id: a_def_id, .. }),
+                TyKind::Alias(rustc_type_ir::Opaque, AliasTy { def_id: b_def_id, .. }),
             ) if a_def_id == b_def_id => super_combine_tys(infcx, self, a, b),
-
             _ => super_combine_tys(infcx, self, a, b),
         }
     }
         let mut inner = self.infcx.inner.borrow_mut();
         let mut constraints = inner.unwrap_region_constraints();
         Ok(match self.kind {
-            // GLB(&'static u8, &'a u8) == &RegionLUB('static, 'a) u8 == &'static u8
             LatticeOpKind::Glb => constraints.lub_regions(self.cx(), a, b),
-
-            // LUB(&'static u8, &'a u8) == &RegionGLB('static, 'a) u8 == &'a u8
             LatticeOpKind::Lub => constraints.glb_regions(self.cx(), a, b),
         })
     }
         }
 
         if a.skip_binder().has_escaping_bound_vars() || b.skip_binder().has_escaping_bound_vars() {
-            // When higher-ranked types are involved, computing the GLB/LUB is
-            // very challenging, switch to invariance. This is obviously
-            // overly conservative but works ok in practice.
             self.relate_with_variance(Variance::Invariant, VarianceDiagInfo::default(), a, b)?;
             Ok(a)
         } else {
-            Ok(Binder::dummy(
-                self.relate(a.skip_binder(), b.skip_binder())?,
-            ))
+            Ok(Binder::dummy(self.relate(a.skip_binder(), b.skip_binder())?))
         }
     }
 }
 
 impl<'infcx, 'db> LatticeOp<'infcx, 'db> {
-    // Relates the type `v` to `a` and `b` such that `v` represents
-    // the LUB/GLB of `a` and `b` as appropriate.
-    //
-    // Subtle hack: ordering *may* be significant here. This method
-    // relates `v` to `a` first, which may help us to avoid unnecessary
-    // type variable obligations. See caller for details.
     fn relate_bound(&mut self, v: Ty<'db>, a: Ty<'db>, b: Ty<'db>) -> RelateResult<'db, ()> {
         let at = self.infcx.at(&self.trace.cause, self.param_env);
         match self.kind {
         preds: impl IntoIterator<Item: Upcast<DbInterner<'db>, Predicate<'db>>>,
     ) {
         self.obligations.extend(preds.into_iter().map(|pred| {
-            Obligation::new(
-                self.infcx.interner,
-                self.trace.cause.clone(),
-                self.param_env,
-                pred,
-            )
+            Obligation::new(self.infcx.interner, self.trace.cause.clone(), self.param_env, pred)
         }))
     }
 