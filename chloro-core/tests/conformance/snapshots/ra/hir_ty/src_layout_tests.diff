COMPARISON DIFF
============================================================

Original size: 15972 bytes
Chloro size:   15997 bytes
Rustfmt size:  15995 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
+mod closure;
+
 use base_db::target::TargetData;
 use either::Either;
 use hir_def::db::DefDatabase;
     test_db::TestDB,
 };
 
-mod closure;
-
 fn current_machine_target_data() -> TargetData {
     project_model::toolchain_info::target_data::get(
         QueryConfig::Rustc(&Sysroot::empty(), &std::env::current_dir().unwrap()),
         None,
         &FxHashMap::default(),
+    ).unwrap(
     )
-    .unwrap()
 }
 
 fn eval_goal(
             Some(adt_or_type_alias_id)
         })
         .unwrap();
-    crate::attach_db(&db, || {
+    crate::attach_db(
+        &db,
+        || {
         let interner = DbInterner::new_with(&db, None, None);
         let goal_ty = match adt_or_type_alias_id {
             Either::Left(adt_id) => crate::next_solver::Ty::new_adt(
         db.layout_of_ty(
             goal_ty,
             db.trait_environment(match adt_or_type_alias_id {
-                Either::Left(adt) => hir_def::GenericDefId::AdtId(adt),
-                Either::Right(ty) => hir_def::GenericDefId::TypeAliasId(ty),
-            }),
+            Either::Left(adt) => hir_def::GenericDefId::AdtId(adt),
+            Either::Right(ty) => hir_def::GenericDefId::TypeAliasId(ty),
+        }),
         )
-    })
+    },
+    )
 }
 
 /// A version of `eval_goal` for types that can not be expressed in ADTs, like closures and `impl Trait`
     );
 
     let (db, file_id) = TestDB::with_single_file(&ra_fixture);
-    crate::attach_db(&db, || {
+    crate::attach_db(
+        &db,
+        || {
         let module_id = db.module_for_file(file_id.file_id(&db));
         let def_map = module_id.def_map(&db);
         let scope = &def_map[module_id.local_id].scope;
         let infer = db.infer(function_id.into());
         let goal_ty = infer.type_of_binding[b];
         db.layout_of_ty(goal_ty, db.trait_environment(function_id.into()))
-    })
+    },
+    )
 }
 
 #[track_caller]
         struct BoxLike<T: ?Sized>(*mut T);
         struct Goal(BoxLike<Goal>);
     }
-    check_fail(
-        r#"struct Goal(Goal);"#,
-        LayoutError::RecursiveTypeWithoutIndirection,
-    );
+    check_fail(r#"struct Goal(Goal);"#, LayoutError::RecursiveTypeWithoutIndirection);
     check_fail(
         r#"
         struct Foo<T>(Foo<T>);
 }
 
 #[test]
-// FIXME
 #[should_panic]
 fn const_eval_complex() {
     size_and_align! {