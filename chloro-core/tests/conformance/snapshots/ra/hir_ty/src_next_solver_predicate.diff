COMPARISON DIFF
============================================================

Original size: 32384 bytes
Chloro size:   32330 bytes
Rustfmt size:  32663 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Things related to predicates.
 
 use std::cmp::Ordering;
 
 use macros::{TypeFoldable, TypeVisitable};
 use rustc_type_ir::{
-    self as ty,
-    elaborate::Elaboratable,
-    error::{ExpectedFound, TypeError},
-    inherent::{IntoKind, SliceLike},
     CollectAndApply, DebruijnIndex, EarlyBinder, FlagComputation, Flags, PredicatePolarity,
     TypeFlags, TypeFoldable, TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, Upcast,
     UpcastFrom, WithCachedTypeInfo,
+    elaborate::Elaboratable,
+    error::{ExpectedFound, TypeError},
+    inherent::{IntoKind, SliceLike},
+    self as ty,
 };
 use smallvec::SmallVec;
 
 use crate::next_solver::{InternedWrapperNoDebug, TraitIdWrapper};
 
-use super::{interned_vec_db, Binder, BoundVarKinds, DbInterner, Region, Ty};
+use super::{Binder, BoundVarKinds, DbInterner, Region, Ty, interned_vec_db};
 
 pub type BoundExistentialPredicate<'db> = Binder<'db, ExistentialPredicate<'db>>;
 
 pub type TraitRef<'db> = ty::TraitRef<DbInterner<'db>>;
+
 pub type AliasTerm<'db> = ty::AliasTerm<DbInterner<'db>>;
+
 pub type ProjectionPredicate<'db> = ty::ProjectionPredicate<DbInterner<'db>>;
+
 pub type ExistentialPredicate<'db> = ty::ExistentialPredicate<DbInterner<'db>>;
+
 pub type ExistentialTraitRef<'db> = ty::ExistentialTraitRef<DbInterner<'db>>;
+
 pub type ExistentialProjection<'db> = ty::ExistentialProjection<DbInterner<'db>>;
+
 pub type TraitPredicate<'db> = ty::TraitPredicate<DbInterner<'db>>;
+
 pub type ClauseKind<'db> = ty::ClauseKind<DbInterner<'db>>;
+
 pub type PredicateKind<'db> = ty::PredicateKind<DbInterner<'db>>;
+
 pub type NormalizesTo<'db> = ty::NormalizesTo<DbInterner<'db>>;
+
 pub type CoercePredicate<'db> = ty::CoercePredicate<DbInterner<'db>>;
+
 pub type SubtypePredicate<'db> = ty::SubtypePredicate<DbInterner<'db>>;
+
 pub type OutlivesPredicate<'db, T> = ty::OutlivesPredicate<DbInterner<'db>, T>;
+
 pub type RegionOutlivesPredicate<'db> = OutlivesPredicate<'db, Region<'db>>;
+
 pub type TypeOutlivesPredicate<'db> = OutlivesPredicate<'db, Ty<'db>>;
+
 pub type PolyTraitPredicate<'db> = Binder<'db, TraitPredicate<'db>>;
+
 pub type PolyRegionOutlivesPredicate<'db> = Binder<'db, RegionOutlivesPredicate<'db>>;
+
 pub type PolyTypeOutlivesPredicate<'db> = Binder<'db, TypeOutlivesPredicate<'db>>;
+
 pub type PolySubtypePredicate<'db> = Binder<'db, SubtypePredicate<'db>>;
+
 pub type PolyCoercePredicate<'db> = Binder<'db, CoercePredicate<'db>>;
+
 pub type PolyProjectionPredicate<'db> = Binder<'db, ProjectionPredicate<'db>>;
+
 pub type PolyTraitRef<'db> = Binder<'db, TraitRef<'db>>;
+
 pub type PolyExistentialTraitRef<'db> = Binder<'db, ExistentialTraitRef<'db>>;
+
 pub type PolyExistentialProjection<'db> = Binder<'db, ExistentialProjection<'db>>;
 
 /// Compares via an ordering that will not change if modules are reordered or other changes are
         (ExistentialPredicate::AutoTrait(_), _) => Ordering::Greater,
     }
 }
+
 interned_vec_db!(BoundExistentialPredicates, BoundExistentialPredicate);
 
-impl<'db> rustc_type_ir::inherent::BoundExistentialPredicates<DbInterner<'db>>
-    for BoundExistentialPredicates<'db>
-{
+impl<'db> rustc_type_ir::inherent::BoundExistentialPredicates<DbInterner<'db>> for BoundExistentialPredicates<'db> {
     fn principal_def_id(self) -> Option<TraitIdWrapper> {
-        self.principal()
-            .map(|trait_ref| trait_ref.skip_binder().def_id)
+        self.principal().map(|trait_ref| trait_ref.skip_binder().def_id)
     }
 
     fn principal(
     }
 
     fn auto_traits(self) -> impl IntoIterator<Item = TraitIdWrapper> {
-        self.iter()
-            .filter_map(|predicate| match predicate.skip_binder() {
-                ExistentialPredicate::AutoTrait(did) => Some(did),
-                _ => None,
-            })
+        self.iter().filter_map(|predicate| match predicate.skip_binder() {
+            ExistentialPredicate::AutoTrait(did) => Some(did),
+            _ => None,
+        })
     }
 
     fn projection_bounds(
                 match (ep_a.skip_binder(), ep_b.skip_binder()) {
                     (ty::ExistentialPredicate::Trait(a), ty::ExistentialPredicate::Trait(b)) => {
                         Ok(ep_a.rebind(ty::ExistentialPredicate::Trait(
-                            relation
-                                .relate(ep_a.rebind(a), ep_b.rebind(b))?
-                                .skip_binder(),
+                            relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),
                         )))
                     }
                     (
                         ty::ExistentialPredicate::Projection(a),
                         ty::ExistentialPredicate::Projection(b),
                     ) => Ok(ep_a.rebind(ty::ExistentialPredicate::Projection(
-                        relation
-                            .relate(ep_a.rebind(a), ep_b.rebind(b))?
-                            .skip_binder(),
+                        relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),
                     ))),
                     (
                         ty::ExistentialPredicate::AutoTrait(a),
             },
         );
 
-        CollectAndApply::collect_and_apply(v, |g| {
+        CollectAndApply::collect_and_apply(
+            v,
+            |g| {
             BoundExistentialPredicates::new_from_iter(interner, g.iter().cloned())
-        })
+        },
+        )
     }
 }
 
     }
 }
 
-impl<'db> std::fmt::Debug
-    for InternedWrapperNoDebug<WithCachedTypeInfo<Binder<'db, PredicateKind<'db>>>>
-{
+impl<'db> std::fmt::Debug for InternedWrapperNoDebug<WithCachedTypeInfo<Binder<'db, PredicateKind<'db>>>> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         write!(f, "Binder<")?;
         match self.0.internee.skip_binder() {
 }
 
 // FIXME: should make a "header" in interned_vec
-
 #[derive(Debug, Clone)]
 pub struct InternedClausesWrapper<'db>(SmallVec<[Clause<'db>; 2]>, TypeFlags, DebruijnIndex);
 
     }
 }
 
-impl<'db> Eq for InternedClausesWrapper<'db> {}
+impl<'db> Eq for InternedClausesWrapper<'db> {
+}
 
 impl<'db> std::hash::Hash for InternedClausesWrapper<'db> {
     fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
     }
 }
 
-impl<'db> rustc_type_ir::inherent::Clauses<DbInterner<'db>> for Clauses<'db> {}
+impl<'db> rustc_type_ir::inherent::Clauses<DbInterner<'db>> for Clauses<'db> {
+}
 
 impl<'db> rustc_type_ir::inherent::SliceLike for Clauses<'db> {
     type Item = Clause<'db>;
 
 impl<'db> IntoIterator for Clauses<'db> {
     type Item = Clause<'db>;
+
     type IntoIter = <Self as rustc_type_ir::inherent::SliceLike>::IntoIter;
 
     fn into_iter(self) -> Self::IntoIter {
         folder: &mut F,
     ) -> Result<Self, F::Error> {
         use rustc_type_ir::inherent::SliceLike as _;
-        let inner: smallvec::SmallVec<[_; 2]> = self
-            .iter()
-            .map(|v| v.try_fold_with(folder))
-            .collect::<Result<_, _>>()?;
+        let inner: smallvec::SmallVec<[_; 2]> =
+            self.iter().map(|v| v.try_fold_with(folder)).collect::<Result<_, _>>()?;
         Ok(Clauses::new_from_iter(folder.cx(), inner))
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         use rustc_type_ir::inherent::SliceLike as _;
         let inner: smallvec::SmallVec<[_; 2]> = self.iter().map(|v| v.fold_with(folder)).collect();
     }
 }
 
-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)] // TODO implement Debug by hand
+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
 pub struct Clause<'db>(pub(crate) Predicate<'db>);
 
-// We could cram the reveal into the clauses like rustc does, probably
 #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, TypeVisitable, TypeFoldable)]
 pub struct ParamEnv<'db> {
     pub(crate) clauses: Clauses<'db>,
 
 impl<'db> ParamEnv<'db> {
     pub fn empty() -> Self {
-        ParamEnv {
-            clauses: Clauses::new_from_iter(DbInterner::conjure(), []),
-        }
+        ParamEnv { clauses: Clauses::new_from_iter(DbInterner::conjure(), []) }
     }
 }
 
     ) -> Result<Self, F::Error> {
         folder.try_fold_predicate(self)
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         folder.fold_predicate(self)
     }
         let new = self.kind().try_fold_with(folder)?;
         Ok(Predicate::new(folder.cx(), new))
     }
+
     fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
         self,
         folder: &mut F,
         Binder::dummy(from).upcast(interner)
     }
 }
-impl<'db>
-    UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::PredicateKind<DbInterner<'db>>>>
-    for Predicate<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::PredicateKind<DbInterner<'db>>>> for Predicate<'db> {
     fn upcast_from(
         from: ty::Binder<DbInterner<'db>, ty::PredicateKind<DbInterner<'db>>>,
         interner: DbInterner<'db>,
         Predicate::new(interner, from)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>> for Predicate<'db> {
     fn upcast_from(from: ty::ClauseKind<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Binder::dummy(PredicateKind::Clause(from)).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>>
-    for Predicate<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>> for Predicate<'db> {
     fn upcast_from(
         from: ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>,
         interner: DbInterner<'db>,
         from.map_bound(PredicateKind::Clause).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, Clause<'db>> for Predicate<'db> {
     fn upcast_from(from: Clause<'db>, _interner: DbInterner<'db>) -> Self {
         from.0
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::NormalizesTo<DbInterner<'db>>> for Predicate<'db> {
     fn upcast_from(from: ty::NormalizesTo<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         PredicateKind::NormalizesTo(from).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>> for Predicate<'db> {
     fn upcast_from(from: ty::TraitRef<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Binder::dummy(from).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>>
-    for Predicate<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>> for Predicate<'db> {
     fn upcast_from(
         from: ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>,
         interner: DbInterner<'db>,
         .upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, Binder<'db, ty::TraitPredicate<DbInterner<'db>>>>
-    for Predicate<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, Binder<'db, ty::TraitPredicate<DbInterner<'db>>>> for Predicate<'db> {
     fn upcast_from(
         from: Binder<'db, ty::TraitPredicate<DbInterner<'db>>>,
         interner: DbInterner<'db>,
     ) -> Self {
-        from.map_bound(|it| PredicateKind::Clause(ClauseKind::Trait(it)))
-            .upcast(interner)
+        from.map_bound(|it| PredicateKind::Clause(ClauseKind::Trait(it))).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, Binder<'db, ProjectionPredicate<'db>>> for Predicate<'db> {
-    fn upcast_from(from: Binder<'db, ProjectionPredicate<'db>>, interner: DbInterner<'db>) -> Self {
-        from.map_bound(|it| PredicateKind::Clause(ClauseKind::Projection(it)))
-            .upcast(interner)
+    fn upcast_from(
+        from: Binder<'db, ProjectionPredicate<'db>>,
+        interner: DbInterner<'db>,
+    ) -> Self {
+        from.map_bound(|it| PredicateKind::Clause(ClauseKind::Projection(it))).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ProjectionPredicate<'db>> for Predicate<'db> {
     fn upcast_from(from: ProjectionPredicate<'db>, interner: DbInterner<'db>) -> Self {
         PredicateKind::Clause(ClauseKind::Projection(from)).upcast(interner)
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>> for Predicate<'db> {
     fn upcast_from(from: ty::TraitPredicate<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         PredicateKind::Clause(ClauseKind::Trait(from)).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>>
-    for Predicate<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>> for Predicate<'db> {
     fn upcast_from(
         from: ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>,
         interner: DbInterner<'db>,
         PredicateKind::Clause(ClauseKind::TypeOutlives(from)).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>>
-    for Predicate<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>> for Predicate<'db> {
     fn upcast_from(
         from: ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>,
         interner: DbInterner<'db>,
         PredicateKind::Clause(ClauseKind::RegionOutlives(from)).upcast(interner)
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>>
-    for Clause<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>> for Clause<'db> {
     fn upcast_from(
         from: ty::OutlivesPredicate<DbInterner<'db>, Ty<'db>>,
         interner: DbInterner<'db>,
         Clause(from.upcast(interner))
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>>
-    for Clause<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>> for Clause<'db> {
     fn upcast_from(
         from: ty::OutlivesPredicate<DbInterner<'db>, Region<'db>>,
         interner: DbInterner<'db>,
 
 impl<'db> UpcastFrom<DbInterner<'db>, PolyRegionOutlivesPredicate<'db>> for Predicate<'db> {
     fn upcast_from(from: PolyRegionOutlivesPredicate<'db>, tcx: DbInterner<'db>) -> Self {
-        from.map_bound(|p| PredicateKind::Clause(ClauseKind::RegionOutlives(p)))
-            .upcast(tcx)
+        from.map_bound(|p| PredicateKind::Clause(ClauseKind::RegionOutlives(p))).upcast(tcx)
     }
 }
 
         self,
         folder: &mut F,
     ) -> Result<Self, F::Error> {
-        Ok(folder
-            .try_fold_predicate(self.as_predicate())?
-            .expect_clause())
+        Ok(folder.try_fold_predicate(self.as_predicate())?.expect_clause())
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         folder.fold_predicate(self.as_predicate()).expect_clause()
     }
     }
 }
 
-impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>>
-    for Clause<'db>
-{
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>> for Clause<'db> {
     fn upcast_from(
         from: ty::Binder<DbInterner<'db>, ty::ClauseKind<DbInterner<'db>>>,
         interner: DbInterner<'db>,
         Clause(from.map_bound(PredicateKind::Clause).upcast(interner))
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>> for Clause<'db> {
     fn upcast_from(from: ty::TraitRef<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
-impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>>
-    for Clause<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>> for Clause<'db> {
     fn upcast_from(
         from: ty::Binder<DbInterner<'db>, ty::TraitRef<DbInterner<'db>>>,
         interner: DbInterner<'db>,
         Clause(from.upcast(interner))
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>> for Clause<'db> {
     fn upcast_from(from: ty::TraitPredicate<DbInterner<'db>>, interner: DbInterner<'db>) -> Self {
         Clause(from.upcast(interner))
     }
 }
-impl<'db>
-    UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>>>
-    for Clause<'db>
-{
+
+impl<'db> UpcastFrom<DbInterner<'db>, ty::Binder<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>>> for Clause<'db> {
     fn upcast_from(
         from: ty::Binder<DbInterner<'db>, ty::TraitPredicate<DbInterner<'db>>>,
         interner: DbInterner<'db>,
         Clause(from.upcast(interner))
     }
 }
+
 impl<'db> UpcastFrom<DbInterner<'db>, ty::ProjectionPredicate<DbInterner<'db>>> for Clause<'db> {
     fn upcast_from(
         from: ty::ProjectionPredicate<DbInterner<'db>>,
         Clause(from.upcast(interner))
     }
 }
-impl<'db>
-    UpcastFrom<
+
+impl<'db> UpcastFrom<
         DbInterner<'db>,
         ty::Binder<DbInterner<'db>, ty::ProjectionPredicate<DbInterner<'db>>>,
-    > for Clause<'db>
-{
+    > for Clause<'db> {
     fn upcast_from(
         from: ty::Binder<DbInterner<'db>, ty::ProjectionPredicate<DbInterner<'db>>>,
         interner: DbInterner<'db>,