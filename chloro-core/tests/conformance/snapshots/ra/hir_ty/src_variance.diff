COMPARISON DIFF
============================================================

Original size: 30604 bytes
Chloro size:   29971 bytes
Rustfmt size:  30951 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     if count == 0 {
         return VariancesOf::new_from_iter(interner, []);
     }
-    let mut variances = Context {
-        generics,
-        variances: vec![Variance::Bivariant; count],
-        db,
-    }
-    .solve();
+    let mut variances =
+        Context { generics, variances: vec![Variance::Bivariant; count], db }.solve();
 
     // FIXME(next-solver): This is *not* the correct behavior. I don't know if it has an actual effect,
+
     // since bivariance is prohibited in Rust, but rustc definitely does not fallback bivariance.
+
     // So why do we do this? Because, with the new solver, the effects of bivariance are catastrophic:
+
     // it leads to not relating types properly, and to very, very hard to debug bugs (speaking from experience).
+
     // Furthermore, our variance infra is known to not handle cycles properly. Therefore, at least until we fix
+
     // cycles, and perhaps forever at least for out tests, not allowing bivariance makes sense.
+
     // Why specifically invariance? I don't have a strong reason, mainly that invariance is a stronger relationship
+
     // (therefore, less room for mistakes) and that IMO incorrect covariance can be more problematic that incorrect
+
     // bivariance, at least while we don't handle lifetimes anyway.
     for variance in &mut variances {
         if *variance == Variance::Bivariant {
 }
 
 // pub(crate) fn variances_of_cycle_fn(
-//     _db: &dyn HirDatabase,
-//     _result: &Option<Arc<[Variance]>>,
-//     _count: u32,
-//     _def: GenericDefId,
-// ) -> salsa::CycleRecoveryAction<Option<Arc<[Variance]>>> {
-//     salsa::CycleRecoveryAction::Iterate
-// }
 
+//     _db: &dyn HirDatabase,
+
+//     _result: &Option<Arc<[Variance]>>,
+
+//     _count: u32,
+
+//     _def: GenericDefId,
+
+// ) -> salsa::CycleRecoveryAction<Option<Arc<[Variance]>>> {
+
+//     salsa::CycleRecoveryAction::Iterate
+
+// }
 fn glb(v1: Variance, v2: Variance) -> Variance {
     // Greatest lower bound of the variance lattice as defined in The Paper:
     //
     //       o
     match (v1, v2) {
         (Variance::Invariant, _) | (_, Variance::Invariant) => Variance::Invariant,
-
         (Variance::Covariant, Variance::Contravariant) => Variance::Invariant,
         (Variance::Contravariant, Variance::Covariant) => Variance::Invariant,
-
         (Variance::Covariant, Variance::Covariant) => Variance::Covariant,
-
         (Variance::Contravariant, Variance::Contravariant) => Variance::Contravariant,
-
         (x, Variance::Bivariant) | (Variance::Bivariant, x) => x,
     }
 }
                     AdtId::StructId(s) => add_constraints_from_variant(VariantId::StructId(s)),
                     AdtId::UnionId(u) => add_constraints_from_variant(VariantId::UnionId(u)),
                     AdtId::EnumId(e) => {
-                        e.enum_variants(db)
-                            .variants
-                            .iter()
-                            .for_each(|&(variant, _, _)| {
-                                add_constraints_from_variant(VariantId::EnumVariantId(variant))
-                            });
+                        e.enum_variants(db).variants.iter().for_each(|&(variant, _, _)| {
+                            add_constraints_from_variant(VariantId::EnumVariantId(variant))
+                        });
                     }
                 }
             }
             GenericDefId::FunctionId(f) => {
-                let sig = self
-                    .db
-                    .callable_item_signature(f.into())
-                    .instantiate_identity()
-                    .skip_binder();
+                let sig =
+                    self.db.callable_item_signature(f.into()).instantiate_identity().skip_binder();
                 self.add_constraints_from_sig(sig.inputs_and_output.iter(), Variance::Covariant);
             }
             _ => {}
         let mut variances = self.variances;
 
         // Const parameters are always invariant.
+
         // Make all const parameters invariant.
         for (idx, param) in self.generics.iter_id().enumerate() {
             if let GenericParamId::ConstParamId(_) = param {
     /// in a context with the generics defined in `generics` and
     /// ambient variance `variance`
     fn add_constraints_from_ty(&mut self, ty: Ty<'db>, variance: Variance) {
-        tracing::debug!(
-            "add_constraints_from_ty(ty={:?}, variance={:?})",
-            ty,
-            variance
-        );
+        tracing::debug!("add_constraints_from_ty(ty={:?}, variance={:?})", ty, variance);
         match ty.kind() {
             TyKind::Int(_)
             | TyKind::Uint(_)
             | TyKind::Never
             | TyKind::Str
             | TyKind::Foreign(..) => {
-                // leaf type -- noop
             }
             TyKind::FnDef(..)
             | TyKind::Coroutine(..)
             | TyKind::CoroutineClosure(..)
             | TyKind::Closure(..) => {
-                never!(
-                    "Unexpected unnameable type in variance computation: {:?}",
-                    ty
-                );
+                never!("Unexpected unnameable type in variance computation: {:?}", ty);
             }
             TyKind::Ref(lifetime, ty, mutbl) => {
                 self.add_constraints_from_region(lifetime, variance);
                 self.add_constraints_from_args(def.def_id().0.into(), args, variance);
             }
             TyKind::Alias(_, alias) => {
-                // FIXME: Probably not correct wrt. opaques.
                 self.add_constraints_from_invariant_args(alias.args);
             }
             TyKind::Dynamic(bounds, region) => {
-                // The type `dyn Trait<T> +'a` is covariant w/r/t `'a`:
                 self.add_constraints_from_region(region, variance);
-
                 for bound in bounds {
                     match bound.skip_binder() {
                         ExistentialPredicate::Trait(trait_ref) => {
                                 Term::Const(konst) => self.add_constraints_from_const(konst),
                             }
                         }
-                        ExistentialPredicate::AutoTrait(_) => {}
+                        ExistentialPredicate::AutoTrait(_) => {
+                        }
                     }
                 }
             }
-
-            // Chalk has no params, so use placeholders for now?
             TyKind::Param(param) => self.constrain(param.index as usize, variance),
             TyKind::FnPtr(sig, _) => {
                 self.add_constraints_from_sig(sig.skip_binder().inputs_and_output.iter(), variance);
             }
             TyKind::Error(_) => {
-                // we encounter this when walking the trait references for object
-                // types, where we use Error as the Self type
             }
-            TyKind::Bound(..) => {}
+            TyKind::Bound(..) => {
+            }
             TyKind::CoroutineWitness(..)
             | TyKind::Placeholder(..)
             | TyKind::Infer(..)
             | TyKind::UnsafeBinder(..)
             | TyKind::Pat(..) => {
-                never!(
-                    "unexpected type encountered in variance inference: {:?}",
-                    ty
-                )
+                never!("unexpected type encountered in variance inference: {:?}", ty)
             }
         }
     }
     fn add_constraints_from_const(&mut self, c: Const<'db>) {
         match c.kind() {
             ConstKind::Unevaluated(c) => self.add_constraints_from_invariant_args(c.args),
-            _ => {}
+            _ => {
+            }
         }
     }
 
         );
         match region.kind() {
             RegionKind::ReEarlyParam(param) => self.constrain(param.index as usize, variance),
-            RegionKind::ReStatic => {}
-            RegionKind::ReBound(..) => {
-                // Either a higher-ranked region inside of a type or a
-                // late-bound function parameter.
-                //
-                // We do not compute constraints for either of these.
+            RegionKind::ReStatic => {
+            }
+            RegionKind::ReBound(..) => {
+            }
+            RegionKind::ReError(_) => {
             }
-            RegionKind::ReError(_) => {}
             RegionKind::ReLateParam(..)
             | RegionKind::RePlaceholder(..)
             | RegionKind::ReVar(..)
             | RegionKind::ReErased => {
-                // We don't expect to see anything but 'static or bound
-                // regions when visiting member types or method types.
                 never!(
                     "unexpected region encountered in variance \
                       inference: {:?}",
     use stdx::format_to;
     use syntax::{ast::HasName, AstNode};
     use test_fixture::WithFixture;
-
     use hir_def::Lookup;
-
     use crate::{db::HirDatabase, test_db::TestDB, variance::generics};
-
     #[test]
     fn phantom_data() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn type_resolve_error_two_structs_deep() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_associated_consts() {
         // FIXME: Should be invariant
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_associated_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_associated_types2() {
         // FIXME: RPITs have variance, but we can't treat them as their own thing right now
             expect![""],
         );
     }
-
     #[test]
     fn rustc_test_variance_trait_bounds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_trait_matching() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_trait_object_bound() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_types_bounds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_unused_region_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_unused_type_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_contravariant_struct1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_contravariant_struct2() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_covariant_struct1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_covariant_struct2() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_invariant_struct1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn invalid_arg_counts() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn prove_fixedpoint() {
         check(
             "#]],
         );
     }
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expected: Expect) {
         // use tracing_subscriber::{layer::SubscriberExt, Layer};
         // ));
         let (db, file_id) = TestDB::with_single_file(ra_fixture);
 
-        crate::attach_db(&db, || {
+        crate::attach_db(
+            &db,
+            || {
             let mut defs: Vec<GenericDefId> = Vec::new();
             let module = db.module_for_file_opt(file_id.file_id(&db)).unwrap();
             let def_map = module.def_map(&db);
             }
 
             expected.assert_eq(&res);
-        })
+        },
+        )
     }
 }