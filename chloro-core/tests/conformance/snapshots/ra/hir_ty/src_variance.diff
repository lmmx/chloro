COMPARISON DIFF
============================================================

Original size: 30604 bytes
Chloro size:   30548 bytes
Rustfmt size:  30951 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! by the next salsa version. If not, we will likely have to adapt and go with the rustc approach
 //! while installing firewall per item queries to prevent invalidation issues.
 
-use hir_def::{signatures::StructFlags, AdtId, GenericDefId, GenericParamId, VariantId};
+use hir_def::{AdtId, GenericDefId, GenericParamId, VariantId, signatures::StructFlags};
 use rustc_ast_ir::Mutability;
 use rustc_type_ir::{
-    inherent::{AdtDef, IntoKind, SliceLike},
     Variance,
+    inherent::{AdtDef, IntoKind, SliceLike},
 };
 use stdx::never;
 
 use crate::{
     db::HirDatabase,
-    generics::{generics, Generics},
+
+    generics::{Generics,
+
+    generics},
+
     next_solver::{
-        Const, ConstKind, DbInterner, ExistentialPredicate, GenericArg, GenericArgs, Region,
-        RegionKind, Term, Ty, TyKind, VariancesOf,
-    },
+        Const,
+
+    ConstKind, DbInterner, ExistentialPredicate, GenericArg, GenericArgs, Region, RegionKind, Term,
+    Ty, TyKind, VariancesOf, },
 };
 
-pub(crate) fn variances_of(db: &dyn HirDatabase, def: GenericDefId) -> VariancesOf<'_> {
+pub(crate) fn variances_of(
+    db: &dyn HirDatabase,
+    def: GenericDefId,
+) -> VariancesOf<'_> {
     tracing::debug!("variances_of(def={:?})", def);
     let interner = DbInterner::new_with(db, None, None);
     match def {
         }
         _ => return VariancesOf::new_from_iter(interner, []),
     }
-
     let generics = generics(db, def);
     let count = generics.len();
     if count == 0 {
         return VariancesOf::new_from_iter(interner, []);
     }
-    let mut variances = Context {
-        generics,
-        variances: vec![Variance::Bivariant; count],
-        db,
-    }
-    .solve();
-
+    let mut variances =
+        Context { generics, variances: vec![Variance::Bivariant; count], db }.solve();
     // FIXME(next-solver): This is *not* the correct behavior. I don't know if it has an actual effect,
     // since bivariance is prohibited in Rust, but rustc definitely does not fallback bivariance.
     // So why do we do this? Because, with the new solver, the effects of bivariance are catastrophic:
             *variance = Variance::Invariant;
         }
     }
-
     VariancesOf::new_from_iter(interner, variances)
 }
 
-// pub(crate) fn variances_of_cycle_fn(
-//     _db: &dyn HirDatabase,
-//     _result: &Option<Arc<[Variance]>>,
-//     _count: u32,
-//     _def: GenericDefId,
-// ) -> salsa::CycleRecoveryAction<Option<Arc<[Variance]>>> {
-//     salsa::CycleRecoveryAction::Iterate
-// }
-
-fn glb(v1: Variance, v2: Variance) -> Variance {
+fn glb(
+    v1: Variance,
+    v2: Variance,
+) -> Variance {
     // Greatest lower bound of the variance lattice as defined in The Paper:
     //
     //       *
     let interner = DbInterner::new_with(db, None, None);
     let generics = generics(db, def);
     let count = generics.len();
-
     // FIXME(next-solver): Returns `Invariance` and not `Bivariance` here, see the comment in the main query.
     VariancesOf::new_from_iter(interner, std::iter::repeat_n(Variance::Invariant, count))
 }
                     AdtId::StructId(s) => add_constraints_from_variant(VariantId::StructId(s)),
                     AdtId::UnionId(u) => add_constraints_from_variant(VariantId::UnionId(u)),
                     AdtId::EnumId(e) => {
-                        e.enum_variants(db)
-                            .variants
-                            .iter()
-                            .for_each(|&(variant, _, _)| {
-                                add_constraints_from_variant(VariantId::EnumVariantId(variant))
-                            });
+                        e.enum_variants(db).variants.iter().for_each(|&(variant, _, _)| {
+                            add_constraints_from_variant(VariantId::EnumVariantId(variant))
+                        });
                     }
                 }
             }
             GenericDefId::FunctionId(f) => {
-                let sig = self
-                    .db
-                    .callable_item_signature(f.into())
-                    .instantiate_identity()
-                    .skip_binder();
+                let sig =
+                    self.db.callable_item_signature(f.into()).instantiate_identity().skip_binder();
                 self.add_constraints_from_sig(sig.inputs_and_output.iter(), Variance::Covariant);
             }
             _ => {}
         }
         let mut variances = self.variances;
-
         // Const parameters are always invariant.
         // Make all const parameters invariant.
         for (idx, param) in self.generics.iter_id().enumerate() {
                 variances[idx] = Variance::Invariant;
             }
         }
-
         // Functions are permitted to have unused generic parameters: make those invariant.
         if let GenericDefId::FunctionId(_) = self.generics.def() {
             variances
                 .filter(|&&mut v| v == Variance::Bivariant)
                 .for_each(|v| *v = Variance::Invariant);
         }
-
         variances
     }
 
     /// Adds constraints appropriate for an instance of `ty` appearing
     /// in a context with the generics defined in `generics` and
     /// ambient variance `variance`
-    fn add_constraints_from_ty(&mut self, ty: Ty<'db>, variance: Variance) {
-        tracing::debug!(
-            "add_constraints_from_ty(ty={:?}, variance={:?})",
-            ty,
-            variance
-        );
+    fn add_constraints_from_ty(
+        &mut self,
+        ty: Ty<'db>,
+        variance: Variance,
+    ) {
+        tracing::debug!("add_constraints_from_ty(ty={:?}, variance={:?})", ty, variance);
         match ty.kind() {
             TyKind::Int(_)
             | TyKind::Uint(_)
             | TyKind::Coroutine(..)
             | TyKind::CoroutineClosure(..)
             | TyKind::Closure(..) => {
-                never!(
-                    "Unexpected unnameable type in variance computation: {:?}",
-                    ty
-                );
+                never!("Unexpected unnameable type in variance computation: {:?}", ty);
             }
             TyKind::Ref(lifetime, ty, mutbl) => {
                 self.add_constraints_from_region(lifetime, variance);
             | TyKind::Infer(..)
             | TyKind::UnsafeBinder(..)
             | TyKind::Pat(..) => {
-                never!(
-                    "unexpected type encountered in variance inference: {:?}",
-                    ty
-                )
+                never!("unexpected type encountered in variance inference: {:?}", ty)
             }
         }
     }
 
-    fn add_constraints_from_invariant_args(&mut self, args: GenericArgs<'db>) {
+    fn add_constraints_from_invariant_args(
+        &mut self,
+        args: GenericArgs<'db>,
+    ) {
         for k in args.iter() {
             match k {
                 GenericArg::Lifetime(lt) => {
             return;
         }
         let variances = self.db.variances_of(def_id);
-
         for (k, v) in args.iter().zip(variances) {
             match k {
                 GenericArg::Lifetime(lt) => self.add_constraints_from_region(lt, variance.xform(v)),
 
     /// Adds constraints appropriate for a const expression `val`
     /// in a context with ambient variance `variance`
-    fn add_constraints_from_const(&mut self, c: Const<'db>) {
+    fn add_constraints_from_const(
+        &mut self,
+        c: Const<'db>,
+    ) {
         match c.kind() {
             ConstKind::Unevaluated(c) => self.add_constraints_from_invariant_args(c.args),
             _ => {}
 
     /// Adds constraints appropriate for a region appearing in a
     /// context with ambient variance `variance`
-    fn add_constraints_from_region(&mut self, region: Region<'db>, variance: Variance) {
+    fn add_constraints_from_region(
+        &mut self,
+        region: Region<'db>,
+        variance: Variance,
+    ) {
         tracing::debug!(
             "add_constraints_from_region(region={:?}, variance={:?})",
             region,
 
     /// Adds constraints appropriate for a mutability-type pair
     /// appearing in a context with ambient variance `variance`
-    fn add_constraints_from_mt(&mut self, ty: Ty<'db>, mt: Mutability, variance: Variance) {
+    fn add_constraints_from_mt(
+        &mut self,
+        ty: Ty<'db>,
+        mt: Mutability,
+        variance: Variance,
+    ) {
         self.add_constraints_from_ty(
             ty,
             match mt {
         );
     }
 
-    fn constrain(&mut self, index: usize, variance: Variance) {
+    fn constrain(
+        &mut self,
+        index: usize,
+        variance: Variance,
+    ) {
         tracing::debug!(
             "constrain(index={:?}, variance={:?}, to={:?})",
             index,
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{expect, Expect};
+    use expect_test::{Expect, expect};
     use hir_def::{
-        hir::generics::GenericParamDataRef, src::HasSource, AdtId, GenericDefId, ModuleDefId,
+        hir::generics::GenericParamDataRef,
+
+        src::HasSource,
+
+        AdtId, GenericDefId, ModuleDefId,
     };
     use itertools::Itertools;
-    use rustc_type_ir::{inherent::SliceLike, Variance};
+    use rustc_type_ir::{Variance, inherent::SliceLike};
     use stdx::format_to;
-    use syntax::{ast::HasName, AstNode};
+    use syntax::{AstNode, ast::HasName};
     use test_fixture::WithFixture;
-
     use hir_def::Lookup;
-
     use crate::{db::HirDatabase, test_db::TestDB, variance::generics};
-
     #[test]
     fn phantom_data() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn type_resolve_error_two_structs_deep() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_associated_consts() {
         // FIXME: Should be invariant
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_associated_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_associated_types2() {
         // FIXME: RPITs have variance, but we can't treat them as their own thing right now
             expect![""],
         );
     }
-
     #[test]
     fn rustc_test_variance_trait_bounds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_trait_matching() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_trait_object_bound() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_types_bounds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_unused_region_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_unused_type_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_contravariant_struct1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_contravariant_struct2() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_covariant_struct1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_covariant_struct2() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn rustc_test_variance_use_invariant_struct1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn invalid_arg_counts() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn prove_fixedpoint() {
         check(
             "#]],
         );
     }
-
     #[track_caller]
-    fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expected: Expect) {
+    fn check(
+        #[rust_analyzer::rust_fixture] ra_fixture: &str,
+        expected: Expect,
+    ) {
         // use tracing_subscriber::{layer::SubscriberExt, Layer};
         // let my_layer = tracing_subscriber::fmt::layer();
         // let _g = tracing::subscriber::set_default(tracing_subscriber::registry().with(
         //     })),
         // ));
         let (db, file_id) = TestDB::with_single_file(ra_fixture);
-
         crate::attach_db(&db, || {
             let mut defs: Vec<GenericDefId> = Vec::new();
             let module = db.module_for_file_opt(file_id.file_id(&db)).unwrap();