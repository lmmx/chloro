COMPARISON DIFF
============================================================

Original size: 25852 bytes
Chloro size:   25866 bytes
Rustfmt size:  26842 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     db::{HirDatabase, InternedClosure, InternedClosureId},
     display::DisplayTarget,
     mir::OperandKind,
-    next_solver::{
-        DbInterner, GenericArgs, Ty, TypingMode,
-        infer::{DbInternerInferExt, InferCtxt},
-    },
+    next_solver::{DbInterner, GenericArgs, Ty, TypingMode, infer::{DbInternerInferExt, InferCtxt}},
 };
 
 use super::{
     Place, ProjectionElem, Rvalue, StatementKind, TerminatorKind,
 };
 
-#[derive(Debug, Clone, PartialEq, Eq)]
 /// Stores spans which implies that the local should be mutable.
+#[derive(Debug, Clone, PartialEq, Eq)]
 pub enum MutabilityReason {
-    Mut { spans: Vec<MirSpan> },
+    Mut {
+        spans: Vec<MirSpan>,
+    },
     Not,
     Unused,
 }
         match db.mir_body_for_closure(c) {
             Ok(body) => {
                 cb(body.clone());
-                body.closures
-                    .iter()
-                    .try_for_each(|&it| for_closure(db, it, cb))
+                body.closures.iter().try_for_each(|&it| for_closure(db, it, cb))
             }
             Err(e) => Err(e),
         }
     match db.mir_body(def) {
         Ok(body) => {
             cb(body.clone());
-            body.closures
-                .iter()
-                .try_for_each(|&it| for_closure(db, it, &mut cb))
+            body.closures.iter().try_for_each(|&it| for_closure(db, it, &mut cb))
         }
         Err(e) => Err(e),
     }
         let (captures, _) = infer.closure_info(c);
         let parent_subst = subst.split_closure_args_untupled().parent_args;
         let interner = DbInterner::new_with(db, None, None);
-        captures
-            .get(f)
-            .expect("broken closure field")
-            .ty
-            .instantiate(interner, parent_subst)
+        captures.get(f).expect("broken closure field").ty.instantiate(interner, parent_subst)
     }
 }
 
                 && !infcx.type_is_copy_modulo_regions(env.env, ty)
                 && !ty.references_non_lt_error()
             {
-                result.push(MovedOutOfRef {
-                    span: op.span.unwrap_or(span),
-                    ty,
-                });
+                result.push(MovedOutOfRef { span: op.span.unwrap_or(span), ty });
             }
         }
         OperandKind::Constant { .. } | OperandKind::Static(_) => (),
                 );
             }
             if !infcx.type_is_copy_modulo_regions(env.env, ty) && !ty.references_non_lt_error() {
-                result.push(PartiallyMoved {
-                    span,
-                    ty,
-                    local: p.local,
-                });
+                result.push(PartiallyMoved { span, ty, local: p.local });
             }
         }
         OperandKind::Constant { .. } | OperandKind::Static(_) => (),
     db: &'db dyn HirDatabase,
     body: &MirBody<'db>,
 ) -> ArenaMap<BasicBlockId<'db>, ArenaMap<LocalId<'db>, bool>> {
-    let mut result: ArenaMap<BasicBlockId<'db>, ArenaMap<LocalId<'db>, bool>> = body
-        .basic_blocks
-        .iter()
-        .map(|it| (it.0, ArenaMap::default()))
-        .collect();
+    let mut result: ArenaMap<BasicBlockId<'db>, ArenaMap<LocalId<'db>, bool>> =
+        body.basic_blocks.iter().map(|it| (it.0, ArenaMap::default())).collect();
     fn dfs<'db>(
         db: &'db dyn HirDatabase,
         body: &MirBody<'db>,
             match &terminator.kind {
                 TerminatorKind::Goto { target } => process(*target, is_ever_initialized),
                 TerminatorKind::SwitchInt { targets, .. } => {
-                    targets
-                        .all_targets()
-                        .iter()
-                        .for_each(|&it| process(it, is_ever_initialized));
+                    targets.all_targets().iter().for_each(|&it| process(it, is_ever_initialized));
                 }
                 TerminatorKind::UnwindResume
                 | TerminatorKind::Abort
                 | TerminatorKind::Return
                 | TerminatorKind::Unreachable => (),
-                TerminatorKind::Call {
-                    target,
-                    cleanup,
-                    destination,
-                    ..
-                } => {
-                    if destination
-                        .projection
-                        .lookup(&body.projection_store)
-                        .is_empty()
+                TerminatorKind::Call { target, cleanup, destination, .. } => {
+                    if destination.projection.lookup(&body.projection_store).is_empty()
                         && destination.local == l
                     {
                         is_ever_initialized = true;
                     }
-                    target
-                        .iter()
-                        .chain(cleanup)
-                        .for_each(|&it| process(it, is_ever_initialized));
+                    target.iter().chain(cleanup).for_each(|&it| process(it, is_ever_initialized));
                 }
-                TerminatorKind::Drop {
-                    target,
-                    unwind,
-                    place: _,
-                } => {
+                TerminatorKind::Drop { target, unwind, place: _ } => {
                     iter::once(target)
                         .chain(unwind)
                         .for_each(|&it| process(it, is_ever_initialized));
     body: &MirBody<'db>,
 ) -> ArenaMap<LocalId<'db>, MutabilityReason> {
     let db = infcx.interner.db;
-    let mut result: ArenaMap<LocalId<'db>, MutabilityReason> = body
-        .locals
-        .iter()
-        .map(|it| (it.0, MutabilityReason::Unused))
-        .collect();
+    let mut result: ArenaMap<LocalId<'db>, MutabilityReason> =
+        body.locals.iter().map(|it| (it.0, MutabilityReason::Unused)).collect();
 
     let ever_init_maps = ever_initialized_map(db, body);
     for (block_id, mut ever_init_map) in ever_init_maps.into_iter() {
             TerminatorKind::SwitchInt { discr, targets: _ } => {
                 record_usage_for_operand(discr, &mut result);
             }
-            TerminatorKind::Call {
-                destination,
-                args,
-                func,
-                ..
-            } => {
+            TerminatorKind::Call { destination, args, func, .. } => {
                 record_usage_for_operand(func, &mut result);
                 for arg in args.iter() {
                     record_usage_for_operand(arg, &mut result);
                 }
-                if destination
-                    .projection
-                    .lookup(&body.projection_store)
-                    .is_empty()
-                {
-                    if ever_init_map
-                        .get(destination.local)
-                        .copied()
-                        .unwrap_or_default()
-                    {
+                if destination.projection.lookup(&body.projection_store).is_empty() {
+                    if ever_init_map.get(destination.local).copied().unwrap_or_default() {
                         push_mut_span(destination.local, terminator.span, &mut result);
                     } else {
                         ever_init_map.insert(destination.local, true);