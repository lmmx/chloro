COMPARISON DIFF
============================================================

Original size: 25852 bytes
Chloro size:   25876 bytes
Rustfmt size:  25852 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! MIR borrow checker, which is used in diagnostics like `unused_mut`
 
 // Currently it is an ad-hoc implementation, only useful for mutability analysis. Feel free to remove all of these
 // if needed for implementing a proper borrow checker.
-
 use std::iter;
 
 use hir_def::{DefWithBodyId, HasModule};
 use triomphe::Arc;
 
 use crate::{
-    TraitEnvironment,
     db::{HirDatabase, InternedClosure, InternedClosureId},
     display::DisplayTarget,
     mir::OperandKind,
         DbInterner, GenericArgs, Ty, TypingMode,
         infer::{DbInternerInferExt, InferCtxt},
     },
+    TraitEnvironment,
 };
-
 use super::{
     BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, MutBorrowKind, Operand,
     Place, ProjectionElem, Rvalue, StatementKind, TerminatorKind,
 };
 
-#[derive(Debug, Clone, PartialEq, Eq)]
 /// Stores spans which implies that the local should be mutable.
+#[derive(Debug, Clone, PartialEq, Eq)]
 pub enum MutabilityReason {
-    Mut { spans: Vec<MirSpan> },
+    Mut {
+        spans: Vec<MirSpan>,
+    },
     Not,
     Unused,
 }
     Ok(res.into())
 }
 
-fn make_fetch_closure_field<'db>(
-    db: &'db dyn HirDatabase,
-) -> impl FnOnce(InternedClosureId, GenericArgs<'db>, usize) -> Ty<'db> + use<'db> {
+fn make_fetch_closure_field<'db>(db: &'db dyn HirDatabase) -> impl FnOnce(InternedClosureId, GenericArgs<'db>, usize) -> Ty<'db> + use<'db> {
     |c: InternedClosureId, subst: GenericArgs<'db>, f: usize| {
         let InternedClosure(def, _) = db.lookup_intern_closure(c);
         let infer = db.infer(def);
     result
 }
 
-fn borrow_regions<'db>(db: &'db dyn HirDatabase, body: &MirBody<'db>) -> Vec<BorrowRegion<'db>> {
+fn borrow_regions<'db>(
+    db: &'db dyn HirDatabase,
+    body: &MirBody<'db>,
+) -> Vec<BorrowRegion<'db>> {
     let mut borrows = FxHashMap::default();
     for (_, block) in body.basic_blocks.iter() {
         db.unwind_if_revision_cancelled();
             None => (),
         }
     }
-
     borrows.into_values().collect()
 }
 
     };
 }
 
-fn record_usage<'db>(local: LocalId<'db>, result: &mut ArenaMap<LocalId<'db>, MutabilityReason>) {
+fn record_usage<'db>(
+    local: LocalId<'db>,
+    result: &mut ArenaMap<LocalId<'db>, MutabilityReason>,
+) {
     if let it @ MutabilityReason::Unused = &mut result[local] {
         *it = MutabilityReason::Not;
     };
     let db = infcx.interner.db;
     let mut result: ArenaMap<LocalId<'db>, MutabilityReason> =
         body.locals.iter().map(|it| (it.0, MutabilityReason::Unused)).collect();
-
     let ever_init_maps = ever_initialized_map(db, body);
     for (block_id, mut ever_init_map) in ever_init_maps.into_iter() {
         let block = &body.basic_blocks[block_id];