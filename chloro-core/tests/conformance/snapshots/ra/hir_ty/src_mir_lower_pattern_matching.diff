COMPARISON DIFF
============================================================

Original size: 29552 bytes
Chloro size:   29549 bytes
Rustfmt size:  29552 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! MIR lowering for patterns
 
-use hir_def::{AssocItemId, hir::ExprId, signatures::VariantFields};
+use hir_def::{hir::ExprId, signatures::VariantFields, AssocItemId};
 use rustc_type_ir::inherent::{IntoKind, SliceLike, Ty as _};
 
 use crate::next_solver::GenericArgs;
 use crate::{
-    BindingMode,
     mir::{
-        LocalId, MutBorrowKind, Operand, OperandKind,
         lower::{
             BasicBlockId, BinOp, BindingId, BorrowKind, Either, Expr, FieldId, Idx, MemoryMap,
             MirLowerCtx, MirLowerError, MirSpan, Pat, PatId, Place, PlaceElem, ProjectionElem,
             RecordFieldPat, ResolveValueResult, Result, Rvalue, SwitchTargets, TerminatorKind,
             TupleFieldId, TupleId, Ty, TyKind, ValueNs, VariantId,
         },
+        LocalId, MutBorrowKind, Operand, OperandKind,
     },
+    BindingMode,
 };
 
 macro_rules! not_supported {
 }
 
 pub(super) enum AdtPatternShape<'a> {
-    Tuple { args: &'a [PatId], ellipsis: Option<u32> },
-    Record { args: &'a [RecordFieldPat] },
+    Tuple {
+        args: &'a [PatId],
+        ellipsis: Option<u32>,
+    },
+    Record {
+        args: &'a [RecordFieldPat],
+    },
     Unit,
 }
 
         value: Place<'db>,
         pattern: PatId,
     ) -> Result<'db, BasicBlockId<'db>> {
-        let (current, _) =
-            self.pattern_match_inner(current, None, value, pattern, MatchingMode::Assign)?;
+        let (current, _) = self.pattern_match_inner(current, None, value, pattern, MatchingMode::Assign)?;
         Ok(current)
     }
 
         cond_place: Place<'db>,
         span: MirSpan,
     ) {
-        self.push_assignment(
+        self
+            .push_assignment(
             current,
             target_place.into(),
             match mode {
     ) -> Result<'db, (BasicBlockId<'db>, Option<BasicBlockId<'db>>)> {
         let then_target = self.new_basic_block();
         let else_target = current_else.unwrap_or_else(|| self.new_basic_block());
-        let discr: Place<'db> =
-            self.temp(Ty::new_bool(self.interner()), current, pattern.into())?.into();
-        self.push_assignment(
+        let discr: Place<'db> = self.temp(Ty::new_bool(self.interner()), current, pattern.into())?.into();
+        self
+            .push_assignment(
             current,
             discr,
             Rvalue::CheckedBinaryOp(
             pattern.into(),
         );
         let discr = Operand { kind: OperandKind::Copy(discr), span: None };
-        self.set_terminator(
+        self
+            .set_terminator(
             current,
             TerminatorKind::SwitchInt {
                 discr,
         mode: MatchingMode,
     ) -> Result<'db, (BasicBlockId<'db>, Option<BasicBlockId<'db>>)> {
         let (al, ar) = args.split_at(ellipsis.map_or(args.len(), |it| it as usize));
-        let it = al
-            .iter()
-            .zip(fields.clone())
-            .chain(ar.iter().rev().zip(fields.rev()))
-            .map(|(x, y)| (y, *x));
+        let it = al.iter().zip(fields.clone()).chain(ar.iter().rev().zip(fields.rev())).map(|(x, y)| (y, *x));
         self.pattern_match_adt(current, current_else, it, cond_place, mode)
     }
 }