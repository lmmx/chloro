COMPARISON DIFF
============================================================

Original size: 29552 bytes
Chloro size:   29476 bytes
Rustfmt size:  29552 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! MIR lowering for patterns
 
-use hir_def::{AssocItemId, hir::ExprId, signatures::VariantFields};
+use hir_def::{hir::ExprId, signatures::VariantFields, AssocItemId};
 use rustc_type_ir::inherent::{IntoKind, SliceLike, Ty as _};
 
 use crate::next_solver::GenericArgs;
 use crate::{
-    BindingMode,
     mir::{
-        LocalId, MutBorrowKind, Operand, OperandKind,
         lower::{
             BasicBlockId, BinOp, BindingId, BorrowKind, Either, Expr, FieldId, Idx, MemoryMap,
             MirLowerCtx, MirLowerError, MirSpan, Pat, PatId, Place, PlaceElem, ProjectionElem,
             RecordFieldPat, ResolveValueResult, Result, Rvalue, SwitchTargets, TerminatorKind,
             TupleFieldId, TupleId, Ty, TyKind, ValueNs, VariantId,
         },
+        LocalId, MutBorrowKind, Operand, OperandKind,
     },
+    BindingMode,
 };
 
 macro_rules! not_supported {
 }
 
 pub(super) enum AdtPatternShape<'a> {
-    Tuple { args: &'a [PatId], ellipsis: Option<u32> },
-    Record { args: &'a [RecordFieldPat] },
+    Tuple {
+        args: &'a [PatId],
+        ellipsis: Option<u32>,
+    },
+    Record {
+        args: &'a [RecordFieldPat],
+    },
     Unit,
 }
 
                     args,
                     *ellipsis,
                     (0..subst.len()).map(|i| {
-                        PlaceElem::Field(Either::Right(TupleFieldId {
-                            tuple: TupleId(!0), // Dummy as it is unused
-                            index: i as u32,
-                        }))
-                    }),
+                    PlaceElem::Field(Either::Right(TupleFieldId {
+                        tuple: TupleId(!0),
+                        index: i as u32,
+                    }))
+                }),
                     &cond_place,
                     mode,
                 )?
-            }
+            },
             Pat::Or(pats) => {
                 let then_target = self.new_basic_block();
                 let mut finished = false;
                     }
                 }
                 (then_target, current_else)
-            }
+            },
             Pat::Record { args, .. } => {
                 let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {
                     not_supported!("unresolved variant for record");
                     AdtPatternShape::Record { args },
                     mode,
                 )?
-            }
+            },
             Pat::Range { start, end } => {
                 let mut add_check = |l: &ExprId, binop| -> Result<'db, ()> {
                     let lv = self.lower_literal_or_const_to_operand(self.infer[pattern], l)?;
                     }
                 }
                 (current, current_else)
-            }
+            },
             Pat::Slice { prefix, slice, suffix } => {
                 if mode == MatchingMode::Check {
                     // emit runtime length check for slice
                         self.pattern_match_inner(current, current_else, next_place, pat, mode)?;
                 }
                 (current, current_else)
-            }
+            },
             Pat::Path(p) => match self.infer.variant_resolution_for_pat(pattern) {
                 Some(variant) => self.pattern_matching_variant(
                     cond_place,
                         .resolver
                         .resolve_path_in_value_ns(self.db, p, hygiene)
                         .ok_or_else(unresolved_name)?;
-
                     if let (
                         MatchingMode::Assign,
                         ResolveValueResult::ValueNs(ValueNs::LocalBinding(binding), _),
                         );
                         return Ok((current, current_else));
                     }
-
-                    // The path is not a variant or a local, so it is a const
                     if mode != MatchingMode::Check {
                         // A const don't bind anything. Only needs check.
                         return Ok((current, current_else));
                         span,
                     );
                     (next, Some(else_target))
-                }
+                },
             },
             Pat::Lit(l) => match &self.body[*l] {
                 Expr::Literal(l) => {
                     } else {
                         (current, current_else)
                     }
-                }
+                },
                 _ => not_supported!("expression path literal"),
             },
             Pat::Bind { id, subpat } => {
                 } else {
                     (current, current_else)
                 }
-            }
+            },
             Pat::TupleStruct { path: _, args, ellipsis } => {
                 let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {
                     not_supported!("unresolved variant");
                     AdtPatternShape::Tuple { args, ellipsis: *ellipsis },
                     mode,
                 )?
-            }
+            },
             Pat::Ref { pat, mutability: _ } => {
                 let cond_place =
                     cond_place.project(ProjectionElem::Deref, &mut self.result.projection_store);
                 self.pattern_match_inner(current, current_else, cond_place, *pat, mode)?
-            }
+            },
             &Pat::Expr(expr) => {
                 stdx::always!(
                     mode == MatchingMode::Assign,
                     expr.into(),
                 );
                 (current, current_else)
-            }
+            },
             Pat::Box { .. } => not_supported!("box pattern"),
             Pat::ConstBlock(_) => not_supported!("const block pattern"),
         })
                     &cond_place,
                     mode,
                 )?
-            }
+            },
             VariantId::StructId(s) => self.pattern_matching_variant_fields(
                 shape,
                 s.fields(self.db),
             )?,
             VariantId::UnionId(_) => {
                 return Err(MirLowerError::TypeError("pattern matching on union"));
-            }
+            },
         })
     }
 
                     })
                     .collect::<Result<'db, Vec<_>>>()?;
                 self.pattern_match_adt(current, current_else, it.into_iter(), cond_place, mode)?
-            }
+            },
             AdtPatternShape::Tuple { args, ellipsis } => {
                 let fields = variant_data.fields().iter().map(|(x, _)| {
                     PlaceElem::Field(Either::Left(FieldId { parent: v, local_id: x }))
                     cond_place,
                     mode,
                 )?
-            }
+            },
             AdtPatternShape::Unit => (current, current_else),
         })
     }