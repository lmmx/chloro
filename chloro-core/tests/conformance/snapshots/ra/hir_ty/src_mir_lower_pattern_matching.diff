COMPARISON DIFF
============================================================

Original size: 29552 bytes
Chloro size:   29655 bytes
Rustfmt size:  29552 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! MIR lowering for patterns
 
-use hir_def::{AssocItemId, hir::ExprId, signatures::VariantFields};
+use hir_def::{hir::ExprId, signatures::VariantFields, AssocItemId};
 use rustc_type_ir::inherent::{IntoKind, SliceLike, Ty as _};
 
 use crate::next_solver::GenericArgs;
 use crate::{
-    BindingMode,
     mir::{
-        LocalId, MutBorrowKind, Operand, OperandKind,
         lower::{
             BasicBlockId, BinOp, BindingId, BorrowKind, Either, Expr, FieldId, Idx, MemoryMap,
             MirLowerCtx, MirLowerError, MirSpan, Pat, PatId, Place, PlaceElem, ProjectionElem,
             RecordFieldPat, ResolveValueResult, Result, Rvalue, SwitchTargets, TerminatorKind,
             TupleFieldId, TupleId, Ty, TyKind, ValueNs, VariantId,
         },
+        LocalId, MutBorrowKind, Operand, OperandKind,
     },
+    BindingMode,
 };
 
 macro_rules! not_supported {
 }
 
 pub(super) enum AdtPatternShape<'a> {
-    Tuple { args: &'a [PatId], ellipsis: Option<u32> },
-    Record { args: &'a [RecordFieldPat] },
+    Tuple {
+        args: &'a [PatId],
+        ellipsis: Option<u32>,
+    },
+    Record {
+        args: &'a [RecordFieldPat],
+    },
     Unit,
 }
 
                 .collect::<Vec<_>>()
                 .into(),
         );
-        Ok(match &self.body[pattern] {
+        Ok(
+            match &self.body[pattern] {
             Pat::Missing => return Err(MirLowerError::IncompletePattern),
             Pat::Wild => (current, current_else),
             Pat::Tuple { args, ellipsis } => {
             }
             Pat::Box { .. } => not_supported!("box pattern"),
             Pat::ConstBlock(_) => not_supported!("const block pattern"),
-        })
+        },
+        )
     }
 
     fn pattern_match_binding(
         shape: AdtPatternShape<'_>,
         mode: MatchingMode,
     ) -> Result<'db, (BasicBlockId<'db>, Option<BasicBlockId<'db>>)> {
-        Ok(match variant {
+        Ok(
+            match variant {
             VariantId::EnumVariantId(v) => {
                 if mode == MatchingMode::Check {
                     let e = self.const_eval_discriminant(v)? as u128;
             VariantId::UnionId(_) => {
                 return Err(MirLowerError::TypeError("pattern matching on union"));
             }
-        })
+        },
+        )
     }
 
     fn pattern_matching_variant_fields(
         cond_place: &Place<'db>,
         mode: MatchingMode,
     ) -> Result<'db, (BasicBlockId<'db>, Option<BasicBlockId<'db>>)> {
-        Ok(match shape {
+        Ok(
+            match shape {
             AdtPatternShape::Record { args } => {
                 let it = args
                     .iter()
                 )?
             }
             AdtPatternShape::Unit => (current, current_else),
-        })
+        },
+        )
     }
 
     fn pattern_match_adt(