COMPARISON DIFF
============================================================

Original size: 28638 bytes
Chloro size:   28566 bytes
Rustfmt size:  28638 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use la_arena::Idx;
 use rustc_abi::{Float, HasDataLayout, Integer, IntegerType, Primitive, ReprOptions};
 use rustc_type_ir::{
-    ConstKind, CoroutineArgs, DebruijnIndex, FloatTy, INNERMOST, IntTy, Interner,
-    PredicatePolarity, RegionKind, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeSuperVisitable,
-    TypeVisitableExt, TypeVisitor, UintTy, UniverseIndex,
+    ConstKind, CoroutineArgs, DebruijnIndex, FloatTy, IntTy, Interner, PredicatePolarity,
+    RegionKind, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeSuperVisitable, TypeVisitableExt,
+    TypeVisitor, UintTy, UniverseIndex,
     inherent::{
         AdtDef, GenericArg as _, GenericArgs as _, IntoKind, ParamEnv as _, SliceLike, Ty as _,
     },
     lang_items::SolverTraitLangItem,
     solve::SizedTraitKind,
+    INNERMOST,
 };
 
 use crate::{
     pub fn wrap_incr(self, interner: DbInterner<'db>) -> Self {
         self.checked_add(interner, 1).0
     }
+
     pub fn checked_add(self, interner: DbInterner<'db>, n: u128) -> (Self, bool) {
         let (size, signed) = self.ty.int_size_and_signed(interner);
         let (val, oflo) = if signed {
 
 pub trait IntegerTypeExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn initial_discriminant<'db>(&self, interner: DbInterner<'db>) -> Discr<'db>;
+
     fn disr_incr<'db>(
         &self,
         interner: DbInterner<'db>,
     }
 
     fn initial_discriminant<'db>(&self, interner: DbInterner<'db>) -> Discr<'db> {
-        Discr { val: 0, ty: self.to_ty(interner) }
+        Discr {
+            val: 0,
+            ty: self.to_ty(interner),
+        }
     }
 
     fn disr_incr<'db>(
         if let Some(val) = val {
             assert_eq!(self.to_ty(interner), val.ty);
             let (new, oflo) = val.checked_add(interner, 1);
-            if oflo { None } else { Some(new) }
+            if oflo {
+                None
+            } else {
+                Some(new)
+            }
         } else {
             Some(self.initial_discriminant(interner))
         }
 
 pub trait IntegerExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>, signed: bool) -> Ty<'db>;
+
     fn from_int_ty<C: HasDataLayout>(cx: &C, ity: IntTy) -> Integer;
+
     fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: UintTy) -> Integer;
+
     fn repr_discr<'db>(
         interner: DbInterner<'db>,
         ty: Ty<'db>,
             IntTy::Isize => cx.data_layout().ptr_sized_integer(),
         }
     }
+
     fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: UintTy) -> Integer {
         use Integer::*;
         match ity {
 
 pub trait FloatExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn from_float_ty(fty: FloatTy) -> Self;
 }
 
 
 pub trait PrimitiveExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn to_int_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
 }
 
             Primitive::Pointer(_) => Ty::new(
                 interner,
                 TyKind::RawPtr(
-                    Ty::new(interner, TyKind::Tuple(Default::default())),
-                    rustc_ast_ir::Mutability::Mut,
-                ),
+                Ty::new(interner, TyKind::Tuple(Default::default())),
+                rustc_ast_ir::Mutability::Mut,
+            ),
             ),
         }
     }
     }
 }
 
-pub struct BottomUpFolder<'db, F, G, H>
-where
-    F: FnMut(Ty<'db>) -> Ty<'db>,
-    G: FnMut(Region<'db>) -> Region<'db>,
-    H: FnMut(Const<'db>) -> Const<'db>,
-{
+pub struct BottomUpFolder<'db, F, G, H> {
     pub interner: DbInterner<'db>,
     pub ty_op: F,
     pub lt_op: G,
     ControlFlow::Continue(())
 }
 
-// FIXME(next-trait-solver): uplift
 pub fn sizedness_constraint_for_ty<'db>(
     interner: DbInterner<'db>,
     sizedness: SizedTraitKind,
                 type_alias.into(),
                 LifetimeElisionKind::AnonymousReportError,
             );
-
             let item_args = GenericArgs::identity_for_item(interner, def_id);
             let interner_ty = Ty::new_projection_from_args(interner, def_id, item_args);
-
             let mut bounds = Vec::new();
             for bound in &type_alias_data.bounds {
                 ctx.lower_type_bound(bound, interner_ty, false).for_each(|pred| {
                     bounds.push(pred);
                 });
             }
-
             if !ctx.unsized_types.contains(&interner_ty) {
                 let sized_trait = LangItem::Sized
                     .resolve_trait(ctx.db, interner.krate.expect("Must have interner.krate"));
                 bounds.extend(sized_bound);
                 bounds.shrink_to_fit();
             }
-
             rustc_type_ir::EarlyBinder::bind(Clauses::new_from_iter(interner, bounds))
         }
         SolverDefId::InternedOpaqueTyId(id) => {