COMPARISON DIFF
============================================================

Original size: 28638 bytes
Chloro size:   29306 bytes
Rustfmt size:  28638 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use la_arena::Idx;
 use rustc_abi::{Float, HasDataLayout, Integer, IntegerType, Primitive, ReprOptions};
 use rustc_type_ir::{
-    ConstKind, CoroutineArgs, DebruijnIndex, FloatTy, INNERMOST, IntTy, Interner,
-    PredicatePolarity, RegionKind, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeSuperVisitable,
-    TypeVisitableExt, TypeVisitor, UintTy, UniverseIndex,
     inherent::{
         AdtDef, GenericArg as _, GenericArgs as _, IntoKind, ParamEnv as _, SliceLike, Ty as _,
     },
     lang_items::SolverTraitLangItem,
     solve::SizedTraitKind,
+    ConstKind,
+    CoroutineArgs,
+    DebruijnIndex,
+    FloatTy,
+    IntTy,
+    Interner,
+    PredicatePolarity,
+    RegionKind,
+    TypeFoldable,
+    TypeFolder,
+    TypeSuperFoldable,
+    TypeSuperVisitable,
+    TypeVisitableExt,
+    TypeVisitor,
+    UintTy,
+    UniverseIndex,
+    INNERMOST,
 };
 
 use crate::{
         infer::InferCtxt,
     },
 };
-
 use super::{
-    Binder, BoundRegion, BoundTy, Clause, ClauseKind, Clauses, Const, DbInterner, EarlyBinder,
-    GenericArgs, Predicate, PredicateKind, Region, SolverDefId, TraitPredicate, TraitRef, Ty,
-    TyKind,
     fold::{BoundVarReplacer, FnMutDelegate},
+    Binder,
+    BoundRegion,
+    BoundTy,
+    Clause,
+    ClauseKind,
+    Clauses,
+    Const,
+    DbInterner,
+    EarlyBinder,
+    GenericArgs,
+    Predicate,
+    PredicateKind,
+    Region,
+    SolverDefId,
+    TraitPredicate,
+    TraitRef,
+    Ty,
+    TyKind,
 };
 
 #[derive(Clone, Debug)]
 
 impl<'db> Discr<'db> {
     /// Adds `1` to the value and wraps around if the maximum for the type is reached.
-    pub fn wrap_incr(self, interner: DbInterner<'db>) -> Self {
+    pub fn wrap_incr(
+        self,
+        interner: DbInterner<'db>,
+    ) -> Self {
         self.checked_add(interner, 1).0
     }
-    pub fn checked_add(self, interner: DbInterner<'db>, n: u128) -> (Self, bool) {
+
+    pub fn checked_add(
+        self,
+        interner: DbInterner<'db>,
+        n: u128,
+    ) -> (Self, bool) {
         let (size, signed) = self.ty.int_size_and_signed(interner);
         let (val, oflo) = if signed {
             let min = size.signed_int_min();
 }
 
 pub trait IntegerTypeExt {
-    fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
-    fn initial_discriminant<'db>(&self, interner: DbInterner<'db>) -> Discr<'db>;
+    fn to_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db>;
+
+    fn initial_discriminant<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Discr<'db>;
+
     fn disr_incr<'db>(
         &self,
         interner: DbInterner<'db>,
 }
 
 impl IntegerTypeExt for IntegerType {
-    fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db> {
+    fn to_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db> {
         match self {
             IntegerType::Pointer(true) => Ty::new(interner, TyKind::Int(IntTy::Isize)),
             IntegerType::Pointer(false) => Ty::new(interner, TyKind::Uint(UintTy::Usize)),
         }
     }
 
-    fn initial_discriminant<'db>(&self, interner: DbInterner<'db>) -> Discr<'db> {
+    fn initial_discriminant<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Discr<'db> {
         Discr { val: 0, ty: self.to_ty(interner) }
     }
 
 }
 
 pub trait IntegerExt {
-    fn to_ty<'db>(&self, interner: DbInterner<'db>, signed: bool) -> Ty<'db>;
-    fn from_int_ty<C: HasDataLayout>(cx: &C, ity: IntTy) -> Integer;
-    fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: UintTy) -> Integer;
+    fn to_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+        signed: bool,
+    ) -> Ty<'db>;
+
+    fn from_int_ty<C: HasDataLayout>(
+        cx: &C,
+        ity: IntTy,
+    ) -> Integer;
+
+    fn from_uint_ty<C: HasDataLayout>(
+        cx: &C,
+        ity: UintTy,
+    ) -> Integer;
+
     fn repr_discr<'db>(
         interner: DbInterner<'db>,
         ty: Ty<'db>,
 
 impl IntegerExt for Integer {
     #[inline]
-    fn to_ty<'db>(&self, interner: DbInterner<'db>, signed: bool) -> Ty<'db> {
+    fn to_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+        signed: bool,
+    ) -> Ty<'db> {
         use Integer::*;
         match (*self, signed) {
             (I8, false) => Ty::new(interner, TyKind::Uint(UintTy::U8)),
         }
     }
 
-    fn from_int_ty<C: HasDataLayout>(cx: &C, ity: IntTy) -> Integer {
+    fn from_int_ty<C: HasDataLayout>(
+        cx: &C,
+        ity: IntTy,
+    ) -> Integer {
         use Integer::*;
         match ity {
             IntTy::I8 => I8,
             IntTy::Isize => cx.data_layout().ptr_sized_integer(),
         }
     }
-    fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: UintTy) -> Integer {
+
+    fn from_uint_ty<C: HasDataLayout>(
+        cx: &C,
+        ity: UintTy,
+    ) -> Integer {
         use Integer::*;
         match ity {
             UintTy::U8 => I8,
         // which can fit all i128 values, so the result remains unaffected.
         let unsigned_fit = Integer::fit_unsigned(std::cmp::max(min as u128, max as u128));
         let signed_fit = std::cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));
-
         if let Some(ity) = repr.int {
             let discr = Integer::from_attr(&interner, ity);
             let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };
             }
             return (discr, ity.is_signed());
         }
-
         let at_least = if repr.c() {
             // This is usually I32, however it can be different on some platforms,
             // notably hexagon and arm-none/thumb-none
             // repr(Rust) enums try to be as small as possible
             Integer::I8
         };
-
         // If there are no negative values, we can use the unsigned fit.
         if min >= 0 {
             (std::cmp::max(unsigned_fit, at_least), false)
 }
 
 pub trait FloatExt {
-    fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+    fn to_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db>;
+
     fn from_float_ty(fty: FloatTy) -> Self;
 }
 
 impl FloatExt for Float {
     #[inline]
-    fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db> {
+    fn to_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db> {
         use Float::*;
         match *self {
             F16 => Ty::new(interner, TyKind::Float(FloatTy::F16)),
 }
 
 pub trait PrimitiveExt {
-    fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
-    fn to_int_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+    fn to_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db>;
+
+    fn to_int_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db>;
 }
 
 impl PrimitiveExt for Primitive {
     #[inline]
-    fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db> {
+    fn to_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db> {
         match *self {
             Primitive::Int(i, signed) => i.to_ty(interner, signed),
             Primitive::Float(f) => f.to_ty(interner),
     /// Return an *integer* type matching this primitive.
     /// Useful in particular when dealing with enum discriminants.
     #[inline]
-    fn to_int_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db> {
+    fn to_int_ty<'db>(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db> {
         match *self {
             Primitive::Int(i, signed) => i.to_ty(interner, signed),
             Primitive::Pointer(_) => {
 }
 
 pub trait CoroutineArgsExt<'db> {
-    fn discr_ty(&self, interner: DbInterner<'db>) -> Ty<'db>;
+    fn discr_ty(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db>;
 }
 
 impl<'db> CoroutineArgsExt<'db> for CoroutineArgs<DbInterner<'db>> {
     /// The type of the state discriminant used in the coroutine type.
     #[inline]
-    fn discr_ty(&self, interner: DbInterner<'db>) -> Ty<'db> {
+    fn discr_ty(
+        &self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db> {
         Ty::new(interner, TyKind::Uint(UintTy::U32))
     }
 }
 impl<'db> TypeVisitor<DbInterner<'db>> for MaxUniverse {
     type Result = ();
 
-    fn visit_ty(&mut self, t: Ty<'db>) {
+    fn visit_ty(
+        &mut self,
+        t: Ty<'db>,
+    ) {
         if let TyKind::Placeholder(placeholder) = t.kind() {
             self.max_universe = UniverseIndex::from_u32(
                 self.max_universe.as_u32().max(placeholder.universe.as_u32()),
             );
         }
-
         t.super_visit_with(self)
     }
 
-    fn visit_const(&mut self, c: Const<'db>) {
+    fn visit_const(
+        &mut self,
+        c: Const<'db>,
+    ) {
         if let ConstKind::Placeholder(placeholder) = c.kind() {
             self.max_universe = UniverseIndex::from_u32(
                 self.max_universe.as_u32().max(placeholder.universe.as_u32()),
             );
         }
-
         c.super_visit_with(self)
     }
 
-    fn visit_region(&mut self, r: Region<'db>) {
+    fn visit_region(
+        &mut self,
+        r: Region<'db>,
+    ) {
         if let RegionKind::RePlaceholder(placeholder) = r.kind() {
             self.max_universe = UniverseIndex::from_u32(
                 self.max_universe.as_u32().max(placeholder.universe.as_u32()),
     }
 }
 
-pub struct BottomUpFolder<'db, F, G, H>
-where
-    F: FnMut(Ty<'db>) -> Ty<'db>,
-    G: FnMut(Region<'db>) -> Region<'db>,
-    H: FnMut(Const<'db>) -> Const<'db>,
-{
+pub struct BottomUpFolder<'db, F, G, H> {
     pub interner: DbInterner<'db>,
     pub ty_op: F,
     pub lt_op: G,
 where
     F: FnMut(Ty<'db>) -> Ty<'db>,
     G: FnMut(Region<'db>) -> Region<'db>,
-    H: FnMut(Const<'db>) -> Const<'db>,
-{
+    H: FnMut(Const<'db>) -> Const<'db>, {
     fn cx(&self) -> DbInterner<'db> {
         self.interner
     }
 
-    fn fold_ty(&mut self, ty: Ty<'db>) -> Ty<'db> {
+    fn fold_ty(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         let t = ty.super_fold_with(self);
         (self.ty_op)(t)
     }
 
-    fn fold_region(&mut self, r: Region<'db>) -> Region<'db> {
+    fn fold_region(
+        &mut self,
+        r: Region<'db>,
+    ) -> Region<'db> {
         // This one is a little different, because `super_fold_with` is not
         // implemented on non-recursive `Region`.
         (self.lt_op)(r)
     }
 
-    fn fold_const(&mut self, ct: Const<'db>) -> Const<'db> {
+    fn fold_const(
+        &mut self,
+        ct: Const<'db>,
+    ) -> Const<'db> {
         let ct = ct.super_fold_with(self);
         (self.ct_op)(ct)
     }
         Some(TyFingerprint::Dyn(trait_id)) => Some(trait_id.module(db)),
         _ => None,
     };
-
     let mut def_blocks =
         [trait_module.containing_block(), type_module.and_then(|it| it.containing_block())];
-
     let block_impls = iter::successors(block, |&block_id| {
         cov_mark::hit!(block_local_impls);
         block_id.loc(db).module.containing_block()
     ControlFlow::Continue(())
 }
 
-// FIXME(next-trait-solver): uplift
 pub fn sizedness_constraint_for_ty<'db>(
     interner: DbInterner<'db>,
     sizedness: SizedTraitKind,
     ty: Ty<'db>,
 ) -> Option<Ty<'db>> {
     use rustc_type_ir::TyKind::*;
-
     match ty.kind() {
         // these are always sized
         Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)
 impl<'db> TypeVisitor<DbInterner<'db>> for ContainsTypeErrors {
     type Result = ControlFlow<()>;
 
-    fn visit_ty(&mut self, t: Ty<'db>) -> Self::Result {
+    fn visit_ty(
+        &mut self,
+        t: Ty<'db>,
+    ) -> Self::Result {
         match t.kind() {
             rustc_type_ir::TyKind::Error(_) => ControlFlow::Break(()),
             _ => t.super_visit_with(self),
         t
     }
 
-    fn fold_region(&mut self, r0: Region<'db>) -> Region<'db> {
+    fn fold_region(
+        &mut self,
+        r0: Region<'db>,
+    ) -> Region<'db> {
         let r1 = match r0.kind() {
             RegionKind::ReVar(vid) => self
                 .infcx
                 .opportunistic_resolve_var(self.infcx.interner, vid),
             _ => r0,
         };
-
         let r2 = match r1.kind() {
             RegionKind::RePlaceholder(p) => {
                 let replace_var = self.mapped_regions.get(&p);
             }
             _ => r1,
         };
-
         tracing::debug!(?r0, ?r1, ?r2, "fold_region");
-
         r2
     }
 
-    fn fold_ty(&mut self, ty: Ty<'db>) -> Ty<'db> {
+    fn fold_ty(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         let ty = self.infcx.shallow_resolve(ty);
         match ty.kind() {
             TyKind::Placeholder(p) => {
         }
     }
 
-    fn fold_const(&mut self, ct: Const<'db>) -> Const<'db> {
+    fn fold_const(
+        &mut self,
+        ct: Const<'db>,
+    ) -> Const<'db> {
         let ct = self.infcx.shallow_resolve_const(ct);
         if let ConstKind::Placeholder(p) = ct.kind() {
             let replace_var = self.mapped_consts.get(&p);
             }
         }
     }
-
     false
 }