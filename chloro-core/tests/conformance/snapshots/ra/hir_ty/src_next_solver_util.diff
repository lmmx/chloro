COMPARISON DIFF
============================================================

Original size: 28638 bytes
Chloro size:   28509 bytes
Rustfmt size:  28638 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use la_arena::Idx;
 use rustc_abi::{Float, HasDataLayout, Integer, IntegerType, Primitive, ReprOptions};
 use rustc_type_ir::{
-    ConstKind, CoroutineArgs, DebruijnIndex, FloatTy, INNERMOST, IntTy, Interner,
-    PredicatePolarity, RegionKind, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeSuperVisitable,
-    TypeVisitableExt, TypeVisitor, UintTy, UniverseIndex,
     inherent::{
         AdtDef, GenericArg as _, GenericArgs as _, IntoKind, ParamEnv as _, SliceLike, Ty as _,
     },
     lang_items::SolverTraitLangItem,
     solve::SizedTraitKind,
+    ConstKind, CoroutineArgs, DebruijnIndex, FloatTy, IntTy, Interner, PredicatePolarity,
+    RegionKind, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeSuperVisitable, TypeVisitableExt,
+    TypeVisitor, UintTy, UniverseIndex, INNERMOST,
 };
 
 use crate::{
     lower::{LifetimeElisionKind, TyLoweringContext},
     method_resolution::{TraitImpls, TyFingerprint},
     next_solver::{
-        BoundConst, FxIndexMap, ParamEnv, Placeholder, PlaceholderConst, PlaceholderRegion,
-        infer::InferCtxt,
+        infer::InferCtxt, BoundConst, FxIndexMap, ParamEnv, Placeholder, PlaceholderConst,
+        PlaceholderRegion,
     },
 };
-
 use super::{
+    fold::{BoundVarReplacer, FnMutDelegate},
     Binder, BoundRegion, BoundTy, Clause, ClauseKind, Clauses, Const, DbInterner, EarlyBinder,
     GenericArgs, Predicate, PredicateKind, Region, SolverDefId, TraitPredicate, TraitRef, Ty,
     TyKind,
-    fold::{BoundVarReplacer, FnMutDelegate},
 };
 
 #[derive(Clone, Debug)]
     pub fn wrap_incr(self, interner: DbInterner<'db>) -> Self {
         self.checked_add(interner, 1).0
     }
+
     pub fn checked_add(self, interner: DbInterner<'db>, n: u128) -> (Self, bool) {
         let (size, signed) = self.ty.int_size_and_signed(interner);
         let (val, oflo) = if signed {
 
 pub trait IntegerTypeExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn initial_discriminant<'db>(&self, interner: DbInterner<'db>) -> Discr<'db>;
+
     fn disr_incr<'db>(
         &self,
         interner: DbInterner<'db>,
     }
 
     fn initial_discriminant<'db>(&self, interner: DbInterner<'db>) -> Discr<'db> {
-        Discr { val: 0, ty: self.to_ty(interner) }
+        Discr {
+            val: 0,
+            ty: self.to_ty(interner),
+        }
     }
 
     fn disr_incr<'db>(
 
 pub trait IntegerExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>, signed: bool) -> Ty<'db>;
+
     fn from_int_ty<C: HasDataLayout>(cx: &C, ity: IntTy) -> Integer;
+
     fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: UintTy) -> Integer;
+
     fn repr_discr<'db>(
         interner: DbInterner<'db>,
         ty: Ty<'db>,
             IntTy::Isize => cx.data_layout().ptr_sized_integer(),
         }
     }
+
     fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: UintTy) -> Integer {
         use Integer::*;
         match ity {
         // which can fit all i128 values, so the result remains unaffected.
         let unsigned_fit = Integer::fit_unsigned(std::cmp::max(min as u128, max as u128));
         let signed_fit = std::cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));
-
         if let Some(ity) = repr.int {
             let discr = Integer::from_attr(&interner, ity);
             let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };
             }
             return (discr, ity.is_signed());
         }
-
         let at_least = if repr.c() {
             // This is usually I32, however it can be different on some platforms,
             // notably hexagon and arm-none/thumb-none
             // repr(Rust) enums try to be as small as possible
             Integer::I8
         };
-
         // If there are no negative values, we can use the unsigned fit.
         if min >= 0 {
             (std::cmp::max(unsigned_fit, at_least), false)
 
 pub trait FloatExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn from_float_ty(fty: FloatTy) -> Self;
 }
 
 
 pub trait PrimitiveExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn to_int_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
 }
 
                 self.max_universe.as_u32().max(placeholder.universe.as_u32()),
             );
         }
-
         t.super_visit_with(self)
     }
 
                 self.max_universe.as_u32().max(placeholder.universe.as_u32()),
             );
         }
-
         c.super_visit_with(self)
     }
 
     }
 }
 
-pub struct BottomUpFolder<'db, F, G, H>
-where
-    F: FnMut(Ty<'db>) -> Ty<'db>,
-    G: FnMut(Region<'db>) -> Region<'db>,
-    H: FnMut(Const<'db>) -> Const<'db>,
-{
+pub struct BottomUpFolder<'db, F, G, H> {
     pub interner: DbInterner<'db>,
     pub ty_op: F,
     pub lt_op: G,
         Some(TyFingerprint::Dyn(trait_id)) => Some(trait_id.module(db)),
         _ => None,
     };
-
     let mut def_blocks =
         [trait_module.containing_block(), type_module.and_then(|it| it.containing_block())];
-
     let block_impls = iter::successors(block, |&block_id| {
         cov_mark::hit!(block_local_impls);
         block_id.loc(db).module.containing_block()
     ControlFlow::Continue(())
 }
 
-// FIXME(next-trait-solver): uplift
 pub fn sizedness_constraint_for_ty<'db>(
     interner: DbInterner<'db>,
     sizedness: SizedTraitKind,
     ty: Ty<'db>,
 ) -> Option<Ty<'db>> {
     use rustc_type_ir::TyKind::*;
-
     match ty.kind() {
         // these are always sized
         Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)
                 .opportunistic_resolve_var(self.infcx.interner, vid),
             _ => r0,
         };
-
         let r2 = match r1.kind() {
             RegionKind::RePlaceholder(p) => {
                 let replace_var = self.mapped_regions.get(&p);
             }
             _ => r1,
         };
-
         tracing::debug!(?r0, ?r1, ?r2, "fold_region");
-
         r2
     }
 
             }
         }
     }
-
     false
 }