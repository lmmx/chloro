COMPARISON DIFF
============================================================

Original size: 28638 bytes
Chloro size:   28602 bytes
Rustfmt size:  29240 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     PredicatePolarity, RegionKind, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeSuperVisitable,
     TypeVisitableExt, TypeVisitor, UintTy, UniverseIndex,
     inherent::{
-        AdtDef, GenericArg as _, GenericArgs as _, IntoKind, ParamEnv as _, SliceLike, Ty as _,
+        AdtDef, GenericArgs as _, GenericArg as _, IntoKind, ParamEnv as _, SliceLike, Ty as _,
     },
     lang_items::SolverTraitLangItem,
     solve::SizedTraitKind,
     pub fn wrap_incr(self, interner: DbInterner<'db>) -> Self {
         self.checked_add(interner, 1).0
     }
+
     pub fn checked_add(self, interner: DbInterner<'db>, n: u128) -> (Self, bool) {
         let (size, signed) = self.ty.int_size_and_signed(interner);
         let (val, oflo) = if signed {
             assert!(n < (i128::MAX as u128));
             let n = n as i128;
             let oflo = val > max - n;
-            let val = if oflo {
-                min + (n - (max - val) - 1)
-            } else {
-                val + n
-            };
+            let val = if oflo { min + (n - (max - val) - 1) } else { val + n };
             // zero the upper bits
             let val = val as u128;
             let val = size.truncate(val);
 
 pub trait IntegerTypeExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn initial_discriminant<'db>(&self, interner: DbInterner<'db>) -> Discr<'db>;
+
     fn disr_incr<'db>(
         &self,
         interner: DbInterner<'db>,
         if let Some(val) = val {
             assert_eq!(self.to_ty(interner), val.ty);
             let (new, oflo) = val.checked_add(interner, 1);
-            if oflo { None } else { Some(new) }
+            if oflo {
+                None
+            } else {
+                Some(new)
+            }
         } else {
             Some(self.initial_discriminant(interner))
         }
 
 pub trait IntegerExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>, signed: bool) -> Ty<'db>;
+
     fn from_int_ty<C: HasDataLayout>(cx: &C, ity: IntTy) -> Integer;
+
     fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: UintTy) -> Integer;
+
     fn repr_discr<'db>(
         interner: DbInterner<'db>,
         ty: Ty<'db>,
             IntTy::Isize => cx.data_layout().ptr_sized_integer(),
         }
     }
+
     fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: UintTy) -> Integer {
         use Integer::*;
         match ity {
 
         if let Some(ity) = repr.int {
             let discr = Integer::from_attr(&interner, ity);
-            let fit = if ity.is_signed() {
-                signed_fit
-            } else {
-                unsigned_fit
-            };
+            let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };
             if discr < fit {
                 panic!(
                     "Integer::repr_discr: `#[repr]` hint too small for \
 
 pub trait FloatExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn from_float_ty(fty: FloatTy) -> Self;
 }
 
 
 pub trait PrimitiveExt {
     fn to_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
+
     fn to_int_ty<'db>(&self, interner: DbInterner<'db>) -> Ty<'db>;
 }
 
             Primitive::Pointer(_) => Ty::new(
                 interner,
                 TyKind::RawPtr(
-                    Ty::new(interner, TyKind::Tuple(Default::default())),
-                    rustc_ast_ir::Mutability::Mut,
-                ),
+                Ty::new(interner, TyKind::Tuple(Default::default())),
+                rustc_ast_ir::Mutability::Mut,
+            ),
             ),
         }
     }
             Primitive::Int(i, signed) => i.to_ty(interner, signed),
             Primitive::Pointer(_) => {
                 let signed = false;
-                interner
-                    .data_layout()
-                    .ptr_sized_integer()
-                    .to_ty(interner, signed)
+                interner.data_layout().ptr_sized_integer().to_ty(interner, signed)
             }
             Primitive::Float(_) => panic!("floats do not have an int type"),
         }
 
 impl MaxUniverse {
     pub fn new() -> Self {
-        MaxUniverse {
-            max_universe: UniverseIndex::ROOT,
-        }
+        MaxUniverse { max_universe: UniverseIndex::ROOT }
     }
 
     pub fn max_universe(self) -> UniverseIndex {
     fn visit_ty(&mut self, t: Ty<'db>) {
         if let TyKind::Placeholder(placeholder) = t.kind() {
             self.max_universe = UniverseIndex::from_u32(
-                self.max_universe
-                    .as_u32()
-                    .max(placeholder.universe.as_u32()),
+                self.max_universe.as_u32().max(placeholder.universe.as_u32()),
             );
         }
 
     fn visit_const(&mut self, c: Const<'db>) {
         if let ConstKind::Placeholder(placeholder) = c.kind() {
             self.max_universe = UniverseIndex::from_u32(
-                self.max_universe
-                    .as_u32()
-                    .max(placeholder.universe.as_u32()),
+                self.max_universe.as_u32().max(placeholder.universe.as_u32()),
             );
         }
 
     fn visit_region(&mut self, r: Region<'db>) {
         if let RegionKind::RePlaceholder(placeholder) = r.kind() {
             self.max_universe = UniverseIndex::from_u32(
-                self.max_universe
-                    .as_u32()
-                    .max(placeholder.universe.as_u32()),
+                self.max_universe.as_u32().max(placeholder.universe.as_u32()),
             );
         }
     }
 }
 
-pub struct BottomUpFolder<'db, F, G, H>
-where
-    F: FnMut(Ty<'db>) -> Ty<'db>,
-    G: FnMut(Region<'db>) -> Region<'db>,
-    H: FnMut(Const<'db>) -> Const<'db>,
-{
+pub struct BottomUpFolder<'db, F, G, H> {
     pub interner: DbInterner<'db>,
     pub ty_op: F,
     pub lt_op: G,
         _ => None,
     };
 
-    let mut def_blocks = [
-        trait_module.containing_block(),
-        type_module.and_then(|it| it.containing_block()),
-    ];
+    let mut def_blocks =
+        [trait_module.containing_block(), type_module.and_then(|it| it.containing_block())];
 
     let block_impls = iter::successors(block, |&block_id| {
         cov_mark::hit!(block_local_impls);
     for it in block_impls {
         f(&it)?;
     }
-    for it in def_blocks
-        .into_iter()
-        .flatten()
-        .filter_map(|it| db.trait_impls_in_block(it))
-    {
+    for it in def_blocks.into_iter().flatten().filter_map(|it| db.trait_impls_in_block(it)) {
         f(&it)?;
     }
     ControlFlow::Continue(())
             .and_then(|ty| sizedness_constraint_for_ty(interner, sizedness, ty)),
 
         Adt(adt, args) => {
-            let tail_ty = EarlyBinder::bind(
-                adt.all_field_tys(interner)
-                    .skip_binder()
-                    .into_iter()
-                    .last()?,
-            )
-            .instantiate(interner, args);
+            let tail_ty =
+                EarlyBinder::bind(adt.all_field_tys(interner).skip_binder().into_iter().last()?)
+                    .instantiate(interner, args);
             sizedness_constraint_for_ty(interner, sizedness, tail_ty)
         }
 
     let types = &mut |ty: BoundTy| args.as_slice()[ty.var.index()].expect_ty();
     let regions = &mut |region: BoundRegion| args.as_slice()[region.var.index()].expect_region();
     let consts = &mut |const_: BoundConst| args.as_slice()[const_.var.index()].expect_const();
-    let mut instantiate = BoundVarReplacer::new(
-        interner,
-        FnMutDelegate {
-            types,
-            regions,
-            consts,
-        },
-    );
+    let mut instantiate = BoundVarReplacer::new(interner, FnMutDelegate { types, regions, consts });
     b.skip_binder().fold_with(&mut instantiate)
 }
 
 
             let mut bounds = Vec::new();
             for bound in &type_alias_data.bounds {
-                ctx.lower_type_bound(bound, interner_ty, false)
-                    .for_each(|pred| {
-                        bounds.push(pred);
-                    });
+                ctx.lower_type_bound(bound, interner_ty, false).for_each(|pred| {
+                    bounds.push(pred);
+                });
             }
 
             if !ctx.unsized_types.contains(&interner_ty) {
             return true;
         }
 
-        if matches!(
-            trait_pred.self_ty().kind(),
-            TyKind::Param(_) | TyKind::Placeholder(_)
-        ) {
+        if matches!(trait_pred.self_ty().kind(), TyKind::Param(_) | TyKind::Placeholder(_)) {
             for clause in param_env.caller_bounds().iter() {
                 if let ClauseKind::Trait(clause_pred) = clause.kind().skip_binder()
                     && clause_pred.polarity == PredicatePolarity::Positive