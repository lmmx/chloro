COMPARISON DIFF
============================================================

Original size: 12418 bytes
Chloro size:   12382 bytes
Rustfmt size:  12886 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::next_solver::{
     DbInterner, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode,
-    infer::{
-        InferCtxt,
-        traits::{PredicateObligation, PredicateObligations},
-    },
+    infer::{InferCtxt, traits::{PredicateObligation, PredicateObligations}},
     inspect::ProofTreeVisitor,
 };
 
-type PendingObligations<'db> = Vec<(
-    PredicateObligation<'db>,
-    Option<GoalStalledOn<DbInterner<'db>>>,
-)>;
+type PendingObligations<'db> = Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
 
 /// A trait engine using the new trait solver.
 ///
 #[derive(Debug, Clone)]
 pub struct FulfillmentCtxt<'db> {
     obligations: ObligationStorage<'db>,
-
     /// The snapshot in which this context was created. Using the context
     /// outside of this snapshot leads to subtle bugs if the snapshot
     /// gets rolled back. Because of this we explicitly check that we only
         &mut self,
         cond: impl Fn(&PredicateObligation<'db>) -> bool,
     ) -> PendingObligations<'db> {
-        let (not_stalled, pending) = mem::take(&mut self.pending)
-            .into_iter()
-            .partition(|(o, _)| cond(o));
+        let (not_stalled, pending) =
+            mem::take(&mut self.pending).into_iter().partition(|(o, _)| cond(o));
         self.pending = pending;
         not_stalled
     }
                             Span::dummy(),
                             stalled_on.take(),
                         );
-                        matches!(
-                            result,
-                            Ok(GoalEvaluation {
-                                has_changed: HasChanged::Yes,
-                                ..
-                            })
-                        )
+                        matches!(result, Ok(GoalEvaluation { has_changed: HasChanged::Yes, .. }))
                     })
                     .map(|(o, _)| o),
             );
     ) {
         // FIXME: See the comment in `try_evaluate_obligations()`.
         // assert_eq!(self.usable_in_snapshot, infcx.num_open_snapshots());
-        obligations
-            .into_iter()
-            .for_each(|obligation| self.obligations.register(obligation, None));
+        obligations.into_iter().for_each(|obligation| self.obligations.register(obligation, None));
     }
 
     pub(crate) fn collect_remaining_errors(
             .pending
             .drain(..)
             .map(|(obligation, _)| NextSolverError::Ambiguity(obligation))
-            .chain(
-                self.obligations
-                    .overflowed
-                    .drain(..)
-                    .map(NextSolverError::Overflow),
-            )
+            .chain(self.obligations.overflowed.drain(..).map(NextSolverError::Overflow))
             .collect()
     }
 
                 }
 
                 let result = delegate.evaluate_root_goal(goal, Span::dummy(), stalled_on);
-                let GoalEvaluation {
-                    goal: _,
-                    certainty,
-                    has_changed,
-                    stalled_on,
-                } = match result {
+                let GoalEvaluation { goal: _, certainty, has_changed, stalled_on } = match result {
                     Ok(result) => result,
                     Err(NoSolution) => {
                         errors.push(NextSolverError::TrueError(obligation));
         infcx: &InferCtxt<'db>,
     ) -> PredicateObligations<'db> {
         let stalled_coroutines = match infcx.typing_mode() {
-            TypingMode::Analysis {
-                defining_opaque_types_and_generators,
-            } => defining_opaque_types_and_generators,
+            TypingMode::Analysis { defining_opaque_types_and_generators } => {
+                defining_opaque_types_and_generators
+            }
             TypingMode::Coherence
-            | TypingMode::Borrowck {
-                defining_opaque_types: _,
-            }
-            | TypingMode::PostBorrowckAnalysis {
-                defined_opaque_types: _,
-            }
+            | TypingMode::Borrowck { defining_opaque_types: _ }
+            | TypingMode::PostBorrowckAnalysis { defined_opaque_types: _ }
             | TypingMode::PostAnalysis => return Default::default(),
         };
         let stalled_coroutines = stalled_coroutines.inner();
         }
 
         if let TyKind::Coroutine(def_id, _) = ty.kind()
-            && self.stalled_coroutines.contains(&def_id.into())
-        {
+            && self.stalled_coroutines.contains(&def_id.into()) {
             ControlFlow::Break(())
         } else if ty.has_coroutines() {
             ty.super_visit_with(self)