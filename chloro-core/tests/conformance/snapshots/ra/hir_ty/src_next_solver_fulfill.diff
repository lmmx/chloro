COMPARISON DIFF
============================================================

Original size: 12418 bytes
Chloro size:   11853 bytes
Rustfmt size:  12418 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     solve::{GoalEvaluation, GoalStalledOn, HasChanged, SolverDelegateEvalExt},
 };
 use rustc_type_ir::{
-    Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
     inherent::{IntoKind, Span as _},
     solve::{Certainty, NoSolution},
+    Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
 };
 
 use crate::next_solver::{
-    DbInterner, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode,
-    infer::{
-        InferCtxt,
-        traits::{PredicateObligation, PredicateObligations},
-    },
+    infer::{traits::{PredicateObligation, PredicateObligations}, InferCtxt},
     inspect::ProofTreeVisitor,
+    DbInterner, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode,
 };
 
-type PendingObligations<'db> =
-    Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
+type PendingObligations<'db> = Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
 
 /// A trait engine using the new trait solver.
 ///
 #[derive(Debug, Clone)]
 pub struct FulfillmentCtxt<'db> {
     obligations: ObligationStorage<'db>,
-
     /// The snapshot in which this context was created. Using the context
     /// outside of this snapshot leads to subtle bugs if the snapshot
     /// gets rolled back. Because of this we explicitly check that we only
 
     fn on_fulfillment_overflow(&mut self, infcx: &InferCtxt<'db>) {
         infcx.probe(|_| {
-            // IMPORTANT: we must not use solve any inference variables in the obligations
-            // as this is all happening inside of a probe. We use a probe to make sure
-            // we get all obligations involved in the overflow. We pretty much check: if
-            // we were to do another step of `try_evaluate_obligations`, which goals would
-            // change.
-            // FIXME: <https://github.com/Gankra/thin-vec/pull/66> is merged, this can be removed.
             self.overflowed.extend(
                 self.pending
                     .extract_if(.., |(o, stalled_on)| {
         &mut self,
         _infcx: &InferCtxt<'db>,
     ) -> Vec<NextSolverError<'db>> {
-        self.obligations
-            .pending
-            .drain(..)
-            .map(|(obligation, _)| NextSolverError::Ambiguity(obligation))
-            .chain(self.obligations.overflowed.drain(..).map(NextSolverError::Overflow))
-            .collect()
+        self.obligations.pending.drain(..).map(
+            |(obligation, _)| NextSolverError::Ambiguity(obligation),
+        ).chain(
+            self.obligations.overflowed.drain(..).map(NextSolverError::Overflow),
+        ).collect(
+        )
     }
 
     pub(crate) fn try_evaluate_obligations(
             return Default::default();
         }
 
-        self.obligations
-            .drain_pending(|obl| {
-                infcx.probe(|_| {
-                    infcx
+        self.obligations.drain_pending(|obl| {
+            infcx.probe(|_| {
+                infcx
                         .visit_proof_tree(
                             obl.as_goal(),
                             &mut StalledOnCoroutines {
                             },
                         )
                         .is_break()
-                })
             })
-            .into_iter()
-            .map(|(o, _)| o)
-            .collect()
+        }).into_iter(
+        ).map(
+            |(o, _)| o,
+        ).collect(
+        )
     }
 }
 
             return ControlFlow::Continue(());
         }
 
-        if let TyKind::Coroutine(def_id, _) = ty.kind()
-            && self.stalled_coroutines.contains(&def_id.into())
-        {
+        if let TyKind::Coroutine(def_id, _) = ty.kind() && self.stalled_coroutines.contains(&def_id.into()) {
             ControlFlow::Break(())
         } else if ty.has_coroutines() {
             ty.super_visit_with(self)