COMPARISON DIFF
============================================================

Original size: 12418 bytes
Chloro size:   12349 bytes
Rustfmt size:  12418 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     solve::{GoalEvaluation, GoalStalledOn, HasChanged, SolverDelegateEvalExt},
 };
 use rustc_type_ir::{
-    Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
     inherent::{IntoKind, Span as _},
     solve::{Certainty, NoSolution},
+    Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
 };
 
 use crate::next_solver::{
-    DbInterner, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode,
-    infer::{
-        InferCtxt,
-        traits::{PredicateObligation, PredicateObligations},
-    },
+    infer::{traits::{PredicateObligation, PredicateObligations}, InferCtxt},
     inspect::ProofTreeVisitor,
+    DbInterner, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode,
 };
 
-type PendingObligations<'db> =
-    Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
+type PendingObligations<'db> = Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
 
 /// A trait engine using the new trait solver.
 ///
 #[derive(Debug, Clone)]
 pub struct FulfillmentCtxt<'db> {
     obligations: ObligationStorage<'db>,
-
     /// The snapshot in which this context was created. Using the context
     /// outside of this snapshot leads to subtle bugs if the snapshot
     /// gets rolled back. Because of this we explicitly check that we only
         &mut self,
         _infcx: &InferCtxt<'db>,
     ) -> Vec<NextSolverError<'db>> {
-        self.obligations
-            .pending
-            .drain(..)
-            .map(|(obligation, _)| NextSolverError::Ambiguity(obligation))
-            .chain(self.obligations.overflowed.drain(..).map(NextSolverError::Overflow))
-            .collect()
+        self.obligations.pending.drain(..).map(
+            |(obligation, _)| NextSolverError::Ambiguity(obligation),
+        ).chain(
+            self.obligations.overflowed.drain(..).map(NextSolverError::Overflow),
+        ).collect(
+        )
     }
 
     pub(crate) fn try_evaluate_obligations(
             return Default::default();
         }
 
-        self.obligations
-            .drain_pending(|obl| {
+        self.obligations.drain_pending(|obl| {
                 infcx.probe(|_| {
                     infcx
                         .visit_proof_tree(
                         )
                         .is_break()
                 })
-            })
-            .into_iter()
-            .map(|(o, _)| o)
-            .collect()
+            }).into_iter(
+        ).map(
+            |(o, _)| o,
+        ).collect(
+        )
     }
 }
 
             return ControlFlow::Continue(());
         }
 
-        if let TyKind::Coroutine(def_id, _) = ty.kind()
-            && self.stalled_coroutines.contains(&def_id.into())
-        {
+        if let TyKind::Coroutine(def_id, _) = ty.kind() && self.stalled_coroutines.contains(&def_id.into()) {
             ControlFlow::Break(())
         } else if ty.has_coroutines() {
             ty.super_visit_with(self)