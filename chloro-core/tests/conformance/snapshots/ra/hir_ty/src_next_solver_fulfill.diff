COMPARISON DIFF
============================================================

Original size: 12418 bytes
Chloro size:   12483 bytes
Rustfmt size:  12418 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use rustc_hash::FxHashSet;
 use rustc_next_trait_solver::{
     delegate::SolverDelegate,
-    solve::{GoalEvaluation, GoalStalledOn, HasChanged, SolverDelegateEvalExt},
+
+    solve::{GoalEvaluation,
+
+    GoalStalledOn, HasChanged, SolverDelegateEvalExt},
 };
 use rustc_type_ir::{
-    Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
-    inherent::{IntoKind, Span as _},
-    solve::{Certainty, NoSolution},
+    inherent::{IntoKind,
+
+    solve::{Certainty,
+
+    Interner, NoSolution}, Span as _}, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,
+    TypeVisitor,
 };
 
 use crate::next_solver::{
-    DbInterner, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode,
     infer::{
         InferCtxt,
-        traits::{PredicateObligation, PredicateObligations},
-    },
+
     inspect::ProofTreeVisitor,
+
+    traits::{PredicateObligation,
+
+    DbInterner, PredicateObligations}, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode, },
 };
 
-type PendingObligations<'db> =
-    Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
+type PendingObligations<'db> = Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
 
 /// A trait engine using the new trait solver.
 ///
 #[derive(Debug, Clone)]
 pub struct FulfillmentCtxt<'db> {
     obligations: ObligationStorage<'db>,
-
     /// The snapshot in which this context was created. Using the context
     /// outside of this snapshot leads to subtle bugs if the snapshot
     /// gets rolled back. Because of this we explicitly check that we only
         not_stalled
     }
 
-    fn on_fulfillment_overflow(&mut self, infcx: &InferCtxt<'db>) {
+    fn on_fulfillment_overflow(
+        &mut self,
+        infcx: &InferCtxt<'db>,
+    ) {
         infcx.probe(|_| {
             // IMPORTANT: we must not use solve any inference variables in the obligations
             // as this is all happening inside of a probe. We use a probe to make sure
                 break;
             }
         }
-
         errors
     }
 
         if !errors.is_empty() {
             return errors;
         }
-
         self.collect_remaining_errors(infcx)
     }
 
             | TypingMode::PostAnalysis => return Default::default(),
         };
         let stalled_coroutines = stalled_coroutines.inner();
-
         if stalled_coroutines.is_empty() {
             return Default::default();
         }
-
         self.obligations
             .drain_pending(|obl| {
                 infcx.probe(|_| {
 impl<'db> ProofTreeVisitor<'db> for StalledOnCoroutines<'_, 'db> {
     type Result = ControlFlow<()>;
 
-    fn visit_goal(&mut self, inspect_goal: &super::inspect::InspectGoal<'_, 'db>) -> Self::Result {
+    fn visit_goal(
+        &mut self,
+        inspect_goal: &super::inspect::InspectGoal<'_, 'db>,
+    ) -> Self::Result {
         inspect_goal.goal().predicate.visit_with(self)?;
-
         if let Some(candidate) = inspect_goal.unique_applicable_candidate() {
             candidate.visit_nested_no_probe(self)
         } else {
 impl<'db> TypeVisitor<DbInterner<'db>> for StalledOnCoroutines<'_, 'db> {
     type Result = ControlFlow<()>;
 
-    fn visit_ty(&mut self, ty: Ty<'db>) -> Self::Result {
+    fn visit_ty(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Self::Result {
         if !self.cache.insert(ty) {
             return ControlFlow::Continue(());
         }
-
         if let TyKind::Coroutine(def_id, _) = ty.kind()
             && self.stalled_coroutines.contains(&def_id.into())
         {