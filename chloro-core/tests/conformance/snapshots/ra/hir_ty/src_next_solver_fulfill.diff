COMPARISON DIFF
============================================================

Original size: 12418 bytes
Chloro size:   12384 bytes
Rustfmt size:  12418 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     solve::{GoalEvaluation, GoalStalledOn, HasChanged, SolverDelegateEvalExt},
 };
 use rustc_type_ir::{
-    Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
     inherent::{IntoKind, Span as _},
     solve::{Certainty, NoSolution},
+    Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
 };
 
 use crate::next_solver::{
-    DbInterner, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode,
-    infer::{
-        InferCtxt,
-        traits::{PredicateObligation, PredicateObligations},
-    },
+    infer::{traits::{PredicateObligation, PredicateObligations}, InferCtxt},
     inspect::ProofTreeVisitor,
+    DbInterner, SolverContext, SolverDefId, Span, Ty, TyKind, TypingMode,
 };
 
-type PendingObligations<'db> =
-    Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
+type PendingObligations<'db> = Vec<(PredicateObligation<'db>, Option<GoalStalledOn<DbInterner<'db>>>)>;
 
 /// A trait engine using the new trait solver.
 ///
 #[derive(Debug, Clone)]
 pub struct FulfillmentCtxt<'db> {
     obligations: ObligationStorage<'db>,
-
     /// The snapshot in which this context was created. Using the context
     /// outside of this snapshot leads to subtle bugs if the snapshot
     /// gets rolled back. Because of this we explicitly check that we only
                 break;
             }
         }
-
         errors
     }
 
         if !errors.is_empty() {
             return errors;
         }
-
         self.collect_remaining_errors(infcx)
     }
 
             | TypingMode::PostAnalysis => return Default::default(),
         };
         let stalled_coroutines = stalled_coroutines.inner();
-
         if stalled_coroutines.is_empty() {
             return Default::default();
         }
-
         self.obligations
             .drain_pending(|obl| {
                 infcx.probe(|_| {
 
     fn visit_goal(&mut self, inspect_goal: &super::inspect::InspectGoal<'_, 'db>) -> Self::Result {
         inspect_goal.goal().predicate.visit_with(self)?;
-
         if let Some(candidate) = inspect_goal.unique_applicable_candidate() {
             candidate.visit_nested_no_probe(self)
         } else {
         if !self.cache.insert(ty) {
             return ControlFlow::Continue(());
         }
-
         if let TyKind::Coroutine(def_id, _) = ty.kind()
             && self.stalled_coroutines.contains(&def_id.into())
         {