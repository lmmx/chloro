COMPARISON DIFF
============================================================

Original size: 24418 bytes
Chloro size:   24461 bytes
Rustfmt size:  24577 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use self::CombineMapType::*;
 use self::UndoLog::*;
-use super::unify_key::RegionVidKey;
 use super::MemberConstraint;
+use super::unify_key::RegionVidKey;
 use crate::next_solver::infer::snapshot::undo_log::{InferCtxtUndoLogs, Snapshot};
 use crate::next_solver::infer::unify_key::RegionVariableValue;
 use crate::next_solver::{AliasTy, Binder, DbInterner, ParamTy, PlaceholderTy, Region, Ty};
 pub struct RegionConstraintStorage<'db> {
     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.
     pub(super) var_infos: IndexVec<RegionVid, RegionVariableInfo>,
-
     pub(super) data: RegionConstraintData<'db>,
-
     /// For a given pair of regions (R1, R2), maps to a region R3 that
     /// is designated as their LUB (edges R1 <= R3 and R2 <= R3
     /// exist). This prevents us from making many such regions.
     lubs: CombineMap<'db>,
-
     /// For a given pair of regions (R1, R2), maps to a region R3 that
     /// is designated as their GLB (edges R3 <= R1 and R3 <= R2
     /// exist). This prevents us from making many such regions.
     glbs: CombineMap<'db>,
-
     /// When we add a R1 == R2 constraint, we currently add (a) edges
     /// R1 <= R2 and R2 <= R1 and (b) we unify the two regions in this
     /// table. You can then call `opportunistic_resolve_var` early
     /// would wind up with a fresh stream of region variables that have been
     /// equated but appear distinct.
     pub(super) unification_table: ut::UnificationTableStorage<RegionVidKey<'db>>,
-
     /// a flag set to true when we perform any unifications; this is used
     /// to micro-optimize `take_and_reset_data`
     any_unifications: bool,
     /// Constraints of the form `A <= B`, where either `A` or `B` can
     /// be a region variable (or neither, as it happens).
     pub constraints: Vec<Constraint<'db>>,
-
     /// Constraints of the form `R0 member of [R1, ..., Rn]`, meaning that
     /// `R0` must be equal to one of the regions `R1..Rn`. These occur
     /// with `impl Trait` quite frequently.
     pub member_constraints: Vec<MemberConstraint<'db>>,
-
     /// A "verify" is something that we need to verify after inference
     /// is done, but which does not directly affect inference in any
     /// way.
 pub struct VerifyIfEq<'db> {
     /// Type which must match the generic `G`
     pub ty: Ty<'db>,
-
     /// Bound that applies if `ty` is equal.
     pub bound: Region<'db>,
 }
         &'a mut self,
         undo_log: &'a mut InferCtxtUndoLogs<'db>,
     ) -> RegionConstraintCollector<'db, 'a> {
-        RegionConstraintCollector {
-            storage: self,
-            undo_log,
-        }
+        RegionConstraintCollector { storage: self, undo_log }
     }
 }
 
         assert!(!UndoLogs::<UndoLog<'db>>::in_snapshot(&self.undo_log));
 
         // If you add a new field to `RegionConstraintCollector`, you
+
         // should think carefully about whether it needs to be cleared
+
         // or updated in some way.
         let RegionConstraintStorage {
             var_infos: _,
         } = self.storage;
 
         // Clear the tables of (lubs, glbs), so that we will create
+
         // fresh regions if we do a LUB operation. As it happens,
+
         // LUB/GLB are not performed by the MIR type-checker, which is
+
         // the one that uses this method, but it's good to be correct.
         lubs.clear();
         glbs.clear();
         let data = mem::take(data);
 
         // Clear all unifications and recreate the variables a "now
+
         // un-unified" state. Note that when we unify `a` and `b`, we
+
         // also insert `a <= b` and a `b <= a` edges, so the
+
         // `RegionConstraintData` contains the relationship here.
         if *any_unifications {
             *any_unifications = false;
 
     pub(super) fn start_snapshot(&self) -> RegionSnapshot {
         debug!("RegionConstraintCollector: start_snapshot");
-        RegionSnapshot {
-            any_unifications: self.storage.any_unifications,
-        }
+        RegionSnapshot { any_unifications: self.storage.any_unifications }
     }
 
     pub(super) fn rollback_to(&mut self, snapshot: RegionSnapshot) {
     pub(super) fn new_region_var(&mut self, universe: UniverseIndex) -> RegionVid {
         let vid = self.storage.var_infos.push(RegionVariableInfo { universe });
 
-        let u_vid = self
-            .unification_table_mut()
-            .new_key(RegionVariableValue::Unknown { universe });
+        let u_vid = self.unification_table_mut().new_key(RegionVariableValue::Unknown { universe });
         assert_eq!(vid, u_vid.vid);
         self.undo_log.push(AddVar(vid));
         debug!("created new region variable {:?} in {:?}", vid, universe);
 
     fn add_constraint(&mut self, constraint: Constraint<'db>) {
         // cannot add constraints once regions are resolved
-        debug!(
-            "RegionConstraintCollector: add_constraint({:?})",
-            constraint
-        );
+        debug!("RegionConstraintCollector: add_constraint({:?})", constraint);
 
         let index = self.storage.data.constraints.len();
         self.storage.data.constraints.push(constraint);
             // equating regions.
             self.make_subregion(a, b);
             self.make_subregion(b, a);
-
             match (a.kind(), b.kind()) {
                 (RegionKind::ReVar(a), RegionKind::ReVar(b)) => {
                     debug!("make_eqregion: unifying {:?} with {:?}", a, b);
                         self.storage.any_unifications = true;
                     };
                 }
-                (_, _) => {}
+                (_, _) => {},
             }
         }
     }
     #[instrument(skip(self), level = "debug")]
     pub(super) fn make_subregion(&mut self, sub: Region<'db>, sup: Region<'db>) {
         // cannot add constraints once regions are resolved
-
         match (sub.kind(), sup.kind()) {
             (RegionKind::ReBound(..), _) | (_, RegionKind::ReBound(..)) => {
                 panic!("cannot relate bound region: {sub:?} <= {sup:?}");
     ) -> Region<'db> {
         // cannot add constraints once regions are resolved
         debug!("RegionConstraintCollector: lub_regions({:?}, {:?})", a, b);
-        #[expect(clippy::if_same_then_else)]
-        if a.is_static() || b.is_static() {
-            a // nothing lives longer than static
+        #[expect(clippy::if_same_then_else)] if a.is_static() || b.is_static() {
+            // nothing lives longer than static
+            a
         } else if a == b {
-            a // LUB(a,a) = a
+            // LUB(a,a) = a
+            a
         } else {
             self.combine_vars(db, Lub, a, b)
         }
     ) -> Region<'db> {
         // cannot add constraints once regions are resolved
         debug!("RegionConstraintCollector: glb_regions({:?}, {:?})", a, b);
-        #[expect(clippy::if_same_then_else)]
-        if a.is_static() {
-            b // static lives longer than everything else
+        #[expect(clippy::if_same_then_else)] if a.is_static() {
+            // static lives longer than everything else
+            b
         } else if b.is_static() {
-            a // static lives longer than everything else
+            // static lives longer than everything else
+            a
         } else if a == b {
-            a // GLB(a,a) = a
+            // GLB(a,a) = a
+            a
         } else {
             self.combine_vars(db, Glb, a, b)
         }
     /// Returns `true` if this region constraint data contains no constraints, and `false`
     /// otherwise.
     pub fn is_empty(&self) -> bool {
-        let RegionConstraintData {
-            constraints,
-            member_constraints,
-            verifys,
-        } = self;
+        let RegionConstraintData { constraints, member_constraints, verifys } = self;
         constraints.is_empty() && member_constraints.is_empty() && verifys.is_empty()
     }
 }