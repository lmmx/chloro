COMPARISON DIFF
============================================================

Original size: 19964 bytes
Chloro size:   19964 bytes
Rustfmt size:  20619 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Fallback of infer vars to `!` and `i32`/`f64`.
 
 use intern::sym;
 use petgraph::{
-    visit::{Dfs, Walker},
     Graph,
+    visit::{Dfs, Walker},
 };
 use rustc_hash::{FxBuildHasher, FxHashMap, FxHashSet};
 use rustc_type_ir::{
-    inherent::{IntoKind, Ty as _},
     TyVid,
+    inherent::{IntoKind, Ty as _},
 };
 use tracing::debug;
 
             return DivergingFallbackBehavior::ToNever;
         }
 
-        if self
-            .resolver
-            .def_map()
-            .is_unstable_feature_enabled(&sym::never_type_fallback)
-        {
+        if self.resolver.def_map().is_unstable_feature_enabled(&sym::never_type_fallback) {
             return DivergingFallbackBehavior::ContextDependent;
         }
 
                 None => return false,
             },
         };
-        debug!(
-            "fallback_if_possible(ty={:?}): defaulting to `{:?}`",
-            ty, fallback
-        );
+        debug!("fallback_if_possible(ty={:?}): defaulting to `{:?}`", ty, fallback);
 
         self.demand_eqtype(ty, fallback);
         true
             "calculate_diverging_fallback: diverging_type_vars={:?}",
             self.table.diverging_type_vars
         );
-        debug!(
-            "calculate_diverging_fallback: diverging_roots={:?}",
-            diverging_roots
-        );
+        debug!("calculate_diverging_fallback: diverging_roots={:?}", diverging_roots);
 
         // Find all type variables that are reachable from a diverging
         // type variable. These will typically default to `!`, unless
                 roots_reachable_from_diverging.move_to(root_vid.as_u32().into());
 
                 // drain the iterator to visit all nodes reachable from this node
-                while roots_reachable_from_diverging
-                    .next(&coercion_graph)
-                    .is_some()
-                {}
+                while roots_reachable_from_diverging.next(&coercion_graph).is_some() {}
             } else {
                 non_diverging_vids.push(unsolved_vid);
             }
         let mut roots_reachable_from_non_diverging = Dfs::empty(&coercion_graph);
         for &non_diverging_vid in &non_diverging_vids {
             let root_vid = self.table.infer_ctxt.root_var(non_diverging_vid);
-            if roots_reachable_from_diverging
-                .discovered
-                .contains(root_vid.as_usize())
-            {
+            if roots_reachable_from_diverging.discovered.contains(root_vid.as_usize()) {
                 continue;
             }
             roots_reachable_from_non_diverging.move_to(root_vid.as_u32().into());
-            while roots_reachable_from_non_diverging
-                .next(&coercion_graph)
-                .is_some()
-            {}
+            while roots_reachable_from_non_diverging.next(&coercion_graph).is_some() {}
         }
         debug!(
             "calculate_diverging_fallback: roots_reachable_from_non_diverging={:?}",
             roots_reachable_from_non_diverging,
         );
 
-        debug!(
-            "obligations: {:#?}",
-            self.table.fulfillment_cx.pending_obligations()
-        );
+        debug!("obligations: {:#?}", self.table.fulfillment_cx.pending_obligations());
 
         // For each diverging variable, figure out whether it can
         // reach a member of N. If so, it falls back to `()`. Else
             let root_vid = self.table.infer_ctxt.root_var(diverging_vid);
             let can_reach_non_diverging = Dfs::new(&coercion_graph, root_vid.as_u32().into())
                 .iter(&coercion_graph)
-                .any(|n| {
-                    roots_reachable_from_non_diverging
-                        .discovered
-                        .contains(n.index())
-                });
+                .any(|n| roots_reachable_from_non_diverging.discovered.contains(n.index()));
 
             let mut fallback_to = |ty| {
                 diverging_fallback.insert(diverging_ty, ty);
                     //     fallback_to(self.types.unit);
                     // }
                     if can_reach_non_diverging {
-                        debug!(
-                            "fallback to () - reached non-diverging: {:?}",
-                            diverging_vid
-                        );
+                        debug!("fallback to () - reached non-diverging: {:?}", diverging_vid);
                         fallback_to(self.types.unit);
                     } else {
                         debug!("fallback to ! - all diverging: {:?}", diverging_vid);
     fn create_coercion_graph(&self) -> Graph<(), ()> {
         let pending_obligations = self.table.fulfillment_cx.pending_obligations();
         let pending_obligations_len = pending_obligations.len();
-        debug!(
-            "create_coercion_graph: pending_obligations={:?}",
-            pending_obligations
-        );
+        debug!("create_coercion_graph: pending_obligations={:?}", pending_obligations);
         let coercion_edges = pending_obligations
             .into_iter()
             .filter_map(|obligation| {
                 // coercion and subtyping.
                 let (a, b) = match atom {
                     PredicateKind::Coerce(CoercePredicate { a, b }) => (a, b),
-                    PredicateKind::Subtype(SubtypePredicate {
-                        a_is_expected: _,
-                        a,
-                        b,
-                    }) => (a, b),
+                    PredicateKind::Subtype(SubtypePredicate { a_is_expected: _, a, b }) => (a, b),
                     _ => return None,
                 };
 
 
     /// If `ty` is an unresolved type variable, returns its root vid.
     fn root_vid(&self, ty: Ty<'db>) -> Option<TyVid> {
-        Some(
-            self.table
-                .infer_ctxt
-                .root_var(self.shallow_resolve(ty).ty_vid()?),
-        )
+        Some(self.table.infer_ctxt.root_var(self.shallow_resolve(ty).ty_vid()?))
     }
 }