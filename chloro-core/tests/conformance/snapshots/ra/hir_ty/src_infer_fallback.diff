COMPARISON DIFF
============================================================

Original size: 19964 bytes
Chloro size:   20003 bytes
Rustfmt size:  20619 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Fallback of infer vars to `!` and `i32`/`f64`.
 
 use intern::sym;
 use petgraph::{
-    visit::{Dfs, Walker},
     Graph,
+    visit::{Dfs, Walker},
 };
 use rustc_hash::{FxBuildHasher, FxHashMap, FxHashSet};
 use rustc_type_ir::{
-    inherent::{IntoKind, Ty as _},
     TyVid,
+    inherent::{IntoKind, Ty as _},
 };
 use tracing::debug;
 
         }
 
         // We now see if we can make progress. This might cause us to
+
         // unify inference variables for opaque types, since we may
+
         // have unified some other type variables during the first
+
         // phase of fallback. This means that we only replace
+
         // inference variables with their underlying opaque types as a
+
         // last resort.
+
         //
+
         // In code like this:
+
         //
+
         // ```rust
+
         // type MyType = impl Copy;
+
         // fn produce() -> MyType { true }
+
         // fn bad_produce() -> MyType { panic!() }
+
         // ```
+
         //
+
         // we want to unify the opaque inference variable in `bad_produce`
+
         // with the diverging fallback for `panic!` (e.g. `()` or `!`).
+
         // This will produce a nice error message about conflicting concrete
+
         // types for `MyType`.
+
         //
+
         // If we had tried to fallback the opaque inference variable to `MyType`,
+
         // we will generate a confusing type-check error that does not explicitly
+
         // refer to opaque types.
         self.table.select_obligations_where_possible();
     }
             return DivergingFallbackBehavior::ToNever;
         }
 
-        if self
-            .resolver
-            .def_map()
-            .is_unstable_feature_enabled(&sym::never_type_fallback)
-        {
+        if self.resolver.def_map().is_unstable_feature_enabled(&sym::never_type_fallback) {
             return DivergingFallbackBehavior::ContextDependent;
         }
 
             self.calculate_diverging_fallback(&unresolved_variables, diverging_fallback_behavior);
 
         // We do fallback in two passes, to try to generate
+
         // better error messages.
+
         // The first time, we do *not* replace opaque types.
         let mut fallback_occurred = false;
         for ty in unresolved_variables {
                 None => return false,
             },
         };
-        debug!(
-            "fallback_if_possible(ty={:?}): defaulting to `{:?}`",
-            ty, fallback
-        );
+        debug!("fallback_if_possible(ty={:?}): defaulting to `{:?}`", ty, fallback);
 
         self.demand_eqtype(ty, fallback);
         true
         debug!("calculate_diverging_fallback({:?})", unresolved_variables);
 
         // Construct a coercion graph where an edge `A -> B` indicates
+
         // a type variable is that is coerced
         let coercion_graph = self.create_coercion_graph();
 
         // Extract the unsolved type inference variable vids; note that some
+
         // unsolved variables are integer/float variables and are excluded.
         let unsolved_vids = unresolved_variables.iter().filter_map(|ty| ty.ty_vid());
 
         // Compute the diverging root vids D -- that is, the root vid of
+
         // those type variables that (a) are the target of a coercion from
+
         // a `!` type and (b) have not yet been solved.
+
         //
+
         // These variables are the ones that are targets for fallback to
+
         // either `!` or `()`.
         let diverging_roots: FxHashSet<TyVid> = self
             .table
             "calculate_diverging_fallback: diverging_type_vars={:?}",
             self.table.diverging_type_vars
         );
-        debug!(
-            "calculate_diverging_fallback: diverging_roots={:?}",
-            diverging_roots
-        );
+        debug!("calculate_diverging_fallback: diverging_roots={:?}", diverging_roots);
 
         // Find all type variables that are reachable from a diverging
+
         // type variable. These will typically default to `!`, unless
+
         // we find later that they are *also* reachable from some
+
         // other type variable outside this set.
         let mut roots_reachable_from_diverging = Dfs::empty(&coercion_graph);
         let mut diverging_vids = vec![];
                 roots_reachable_from_diverging.move_to(root_vid.as_u32().into());
 
                 // drain the iterator to visit all nodes reachable from this node
-                while roots_reachable_from_diverging
-                    .next(&coercion_graph)
-                    .is_some()
-                {}
+                while roots_reachable_from_diverging.next(&coercion_graph).is_some() {}
             } else {
                 non_diverging_vids.push(unsolved_vid);
             }
         );
 
         // Find all type variables N0 that are not reachable from a
+
         // diverging variable, and then compute the set reachable from
+
         // N0, which we call N. These are the *non-diverging* type
+
         // variables. (Note that this set consists of "root variables".)
         let mut roots_reachable_from_non_diverging = Dfs::empty(&coercion_graph);
         for &non_diverging_vid in &non_diverging_vids {
             let root_vid = self.table.infer_ctxt.root_var(non_diverging_vid);
-            if roots_reachable_from_diverging
-                .discovered
-                .contains(root_vid.as_usize())
-            {
+            if roots_reachable_from_diverging.discovered.contains(root_vid.as_usize()) {
                 continue;
             }
             roots_reachable_from_non_diverging.move_to(root_vid.as_u32().into());
-            while roots_reachable_from_non_diverging
-                .next(&coercion_graph)
-                .is_some()
-            {}
+            while roots_reachable_from_non_diverging.next(&coercion_graph).is_some() {}
         }
         debug!(
             "calculate_diverging_fallback: roots_reachable_from_non_diverging={:?}",
             roots_reachable_from_non_diverging,
         );
 
-        debug!(
-            "obligations: {:#?}",
-            self.table.fulfillment_cx.pending_obligations()
-        );
+        debug!("obligations: {:#?}", self.table.fulfillment_cx.pending_obligations());
 
         // For each diverging variable, figure out whether it can
+
         // reach a member of N. If so, it falls back to `()`. Else
+
         // `!`.
         let mut diverging_fallback =
             FxHashMap::with_capacity_and_hasher(diverging_vids.len(), FxBuildHasher);
             let root_vid = self.table.infer_ctxt.root_var(diverging_vid);
             let can_reach_non_diverging = Dfs::new(&coercion_graph, root_vid.as_u32().into())
                 .iter(&coercion_graph)
-                .any(|n| {
-                    roots_reachable_from_non_diverging
-                        .discovered
-                        .contains(n.index())
-                });
+                .any(|n| roots_reachable_from_non_diverging.discovered.contains(n.index()));
 
             let mut fallback_to = |ty| {
                 diverging_fallback.insert(diverging_ty, ty);
                     //     fallback_to(self.types.unit);
                     // }
                     if can_reach_non_diverging {
-                        debug!(
-                            "fallback to () - reached non-diverging: {:?}",
-                            diverging_vid
-                        );
+                        debug!("fallback to () - reached non-diverging: {:?}", diverging_vid);
                         fallback_to(self.types.unit);
                     } else {
                         debug!("fallback to ! - all diverging: {:?}", diverging_vid);
     fn create_coercion_graph(&self) -> Graph<(), ()> {
         let pending_obligations = self.table.fulfillment_cx.pending_obligations();
         let pending_obligations_len = pending_obligations.len();
-        debug!(
-            "create_coercion_graph: pending_obligations={:?}",
-            pending_obligations
-        );
+        debug!("create_coercion_graph: pending_obligations={:?}", pending_obligations);
         let coercion_edges = pending_obligations
             .into_iter()
             .filter_map(|obligation| {
                 // coercion and subtyping.
                 let (a, b) = match atom {
                     PredicateKind::Coerce(CoercePredicate { a, b }) => (a, b),
-                    PredicateKind::Subtype(SubtypePredicate {
-                        a_is_expected: _,
-                        a,
-                        b,
-                    }) => (a, b),
+                    PredicateKind::Subtype(SubtypePredicate { a_is_expected: _, a, b }) => (a, b),
                     _ => return None,
                 };
 
 
     /// If `ty` is an unresolved type variable, returns its root vid.
     fn root_vid(&self, ty: Ty<'db>) -> Option<TyVid> {
-        Some(
-            self.table
-                .infer_ctxt
-                .root_var(self.shallow_resolve(ty).ty_vid()?),
-        )
+        Some(self.table.infer_ctxt.root_var(self.shallow_resolve(ty).ty_vid()?))
     }
 }