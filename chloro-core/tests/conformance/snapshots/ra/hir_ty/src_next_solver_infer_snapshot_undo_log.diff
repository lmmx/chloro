COMPARISON DIFF
============================================================

Original size: 6956 bytes
Chloro size:   6881 bytes
Rustfmt size:  7094 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use rustc_type_ir::IntVid;
 use tracing::debug;
 
+use crate::next_solver::OpaqueTypeKey;
 use crate::next_solver::infer::opaque_types::OpaqueHiddenType;
 use crate::next_solver::infer::unify_key::ConstVidKey;
 use crate::next_solver::infer::unify_key::RegionVidKey;
-use crate::next_solver::infer::{region_constraints, type_variable, InferCtxtInner};
-use crate::next_solver::OpaqueTypeKey;
+use crate::next_solver::infer::{InferCtxtInner, region_constraints, type_variable};
 
-pub struct Snapshot {
-    pub(crate) undo_len: usize,
-}
+pub struct Snapshot { pub(crate) undo_len: usize }
 
 /// Records the "undo" data for a single operation that affects some form of inference variable.
 #[derive(Clone)]
     }
 }
 
-// Upcast from a single kind of "undoable action" to the general enum
 impl_from! {
     RegionConstraintCollector(region_constraints::UndoLog<'db>),
 
             UndoLog::ConstUnificationTable(undo) => self.const_unification_storage.reverse(undo),
             UndoLog::IntUnificationTable(undo) => self.int_unification_storage.reverse(undo),
             UndoLog::FloatUnificationTable(undo) => self.float_unification_storage.reverse(undo),
-            UndoLog::RegionConstraintCollector(undo) => self
-                .region_constraint_storage
-                .as_mut()
-                .unwrap()
-                .reverse(undo),
-            UndoLog::RegionUnificationTable(undo) => self
-                .region_constraint_storage
-                .as_mut()
-                .unwrap()
-                .unification_table
-                .reverse(undo),
+            UndoLog::RegionConstraintCollector(undo) => {
+                self.region_constraint_storage.as_mut().unwrap().reverse(undo)
+            }
+            UndoLog::RegionUnificationTable(undo) => {
+                self.region_constraint_storage.as_mut().unwrap().unification_table.reverse(undo)
+            }
             UndoLog::PushRegionObligation => {
                 self.region_obligations.pop();
             }
 impl<'db> InferCtxtUndoLogs<'db> {
     pub(crate) fn start_snapshot(&mut self) -> Snapshot {
         self.num_open_snapshots += 1;
-        Snapshot {
-            undo_len: self.logs.len(),
-        }
+        Snapshot { undo_len: self.logs.len() }
     }
 
     pub(crate) fn region_constraints_in_snapshot(
     }
 
     pub(crate) fn opaque_types_in_snapshot(&self, s: &Snapshot) -> bool {
-        self.logs[s.undo_len..]
-            .iter()
-            .any(|log| matches!(log, UndoLog::OpaqueTypes(..)))
+        self.logs[s.undo_len..].iter().any(|log| matches!(log, UndoLog::OpaqueTypes(..)))
     }
 
     fn assert_open_snapshot(&self, snapshot: &Snapshot) {