COMPARISON DIFF
============================================================

Original size: 11079 bytes
Chloro size:   10891 bytes
Rustfmt size:  11433 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     Binder, Const, ConstKind, DbInterner, ErrorGuaranteed, GenericArgs, OpaqueTypeKey, Region,
     SolverDefId, Span, Ty, TyKind,
 };
-
 use super::{relate::RelateResult, BoundRegionConversionTime, InferCtxt};
 
 impl<'db> rustc_type_ir::InferCtxtLike for InferCtxt<'db> {
     }
 
     fn universe_of_lt(&self, lt: RegionVid) -> Option<UniverseIndex> {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .probe_value(lt)
-            .err()
+        self.inner.borrow_mut().unwrap_region_constraints().probe_value(lt).err()
     }
 
     fn universe_of_ct(&self, ct: ConstVid) -> Option<UniverseIndex> {
     }
 
     fn opportunistic_resolve_lt_var(&self, vid: RegionVid) -> Region<'db> {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .opportunistic_resolve_var(self.interner, vid)
+        self.inner.borrow_mut().unwrap_region_constraints().opportunistic_resolve_var(
+            self.interner,
+            vid,
+        )
     }
 
-    fn is_changed_arg(&self, arg: <Self::Interner as rustc_type_ir::Interner>::GenericArg) -> bool {
+    fn is_changed_arg(
+        &self,
+        arg: <Self::Interner as rustc_type_ir::Interner>::GenericArg,
+    ) -> bool {
         match arg.kind() {
             GenericArgKind::Lifetime(_) => {
-                // Lifetimes should not change affect trait selection.
                 false
-            }
+            },
             GenericArgKind::Type(ty) => {
                 if let TyKind::Infer(infer_ty) = ty.kind() {
                     match infer_ty {
-                        InferTy::TyVar(vid) => !self
-                            .probe_ty_var(vid)
-                            .is_err_and(|_| self.root_var(vid) == vid),
+                        InferTy::TyVar(vid) => {
+                            !self.probe_ty_var(vid).is_err_and(|_| self.root_var(vid) == vid)
+                        },
                         InferTy::IntVar(vid) => {
                             let mut inner = self.inner.borrow_mut();
                             !matches!(
                                 IntVarValue::Unknown
                                     if inner.int_unification_table().find(vid) == vid
                             )
-                        }
+                        },
                         InferTy::FloatVar(vid) => {
                             let mut inner = self.inner.borrow_mut();
                             !matches!(
                                 FloatVarValue::Unknown
                                     if inner.float_unification_table().find(vid) == vid
                             )
-                        }
+                        },
                         InferTy::FreshTy(_) | InferTy::FreshIntTy(_) | InferTy::FreshFloatTy(_) => {
                             true
-                        }
+                        },
                     }
                 } else {
                     true
                 }
-            }
+            },
             GenericArgKind::Const(ct) => {
                 if let ConstKind::Infer(infer_ct) = ct.kind() {
                     match infer_ct {
-                        InferConst::Var(vid) => !self
-                            .probe_const_var(vid)
-                            .is_err_and(|_| self.root_const_var(vid) == vid),
+                        InferConst::Var(vid) => !self.probe_const_var(vid).is_err_and(|_| self.root_const_var(vid) == vid),
                         InferConst::Fresh(_) => true,
                     }
                 } else {
                     true
                 }
-            }
+            },
         }
     }
 
     }
 
     fn equate_float_vids_raw(&self, a: rustc_type_ir::FloatVid, b: rustc_type_ir::FloatVid) {
-        self.inner
-            .borrow_mut()
-            .float_unification_table()
-            .union(a, b);
+        self.inner.borrow_mut().float_unification_table().union(a, b);
     }
 
     fn equate_const_vids_raw(&self, a: rustc_type_ir::ConstVid, b: rustc_type_ir::ConstVid) {
-        self.inner
-            .borrow_mut()
-            .const_unification_table()
-            .union(a, b);
+        self.inner.borrow_mut().const_unification_table().union(a, b);
     }
 
     fn instantiate_ty_var_raw<R: PredicateEmittingRelation<Self>>(
         vid: rustc_type_ir::IntVid,
         value: rustc_type_ir::IntVarValue,
     ) {
-        self.inner
-            .borrow_mut()
-            .int_unification_table()
-            .union_value(vid, value);
+        self.inner.borrow_mut().int_unification_table().union_value(vid, value);
     }
 
     fn instantiate_float_var_raw(
         vid: rustc_type_ir::FloatVid,
         value: rustc_type_ir::FloatVarValue,
     ) {
-        self.inner
-            .borrow_mut()
-            .float_unification_table()
-            .union_value(vid, value);
+        self.inner.borrow_mut().float_unification_table().union_value(vid, value);
     }
 
     fn instantiate_const_var_raw<R: PredicateEmittingRelation<Self>>(
     fn shallow_resolve(&self, ty: Ty<'db>) -> Ty<'db> {
         self.shallow_resolve(ty)
     }
+
     fn shallow_resolve_const(&self, ct: Const<'db>) -> Const<'db> {
         self.shallow_resolve_const(ct)
     }
     }
 
     fn sub_regions(&self, sub: Region<'db>, sup: Region<'db>, _span: Span) {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .make_subregion(sub, sup);
+        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(sub, sup);
     }
 
     fn equate_regions(&self, a: Region<'db>, b: Region<'db>, _span: Span) {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .make_eqregion(a, b);
+        self.inner.borrow_mut().unwrap_region_constraints().make_eqregion(a, b);
     }
 
     fn register_ty_outlives(&self, _ty: Ty<'db>, _r: Region<'db>, _span: Span) {
     fn opaque_types_storage_num_entries(&self) -> OpaqueTypeStorageEntries {
         self.inner.borrow_mut().opaque_types().num_entries()
     }
+
     fn clone_opaque_types_lookup_table(&self) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
-        self.inner
-            .borrow_mut()
-            .opaque_types()
-            .iter_lookup_table()
-            .map(|(k, h)| (k, h.ty))
-            .collect()
+        self.inner.borrow_mut().opaque_types().iter_lookup_table().map(|(k, h)| (k, h.ty)).collect()
     }
+
     fn clone_duplicate_opaque_types(&self) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
-        self.inner
-            .borrow_mut()
-            .opaque_types()
-            .iter_duplicate_entries()
-            .map(|(k, h)| (k, h.ty))
-            .collect()
+        self.inner.borrow_mut().opaque_types().iter_duplicate_entries().map(|(k, h)| (k, h.ty)).collect(
+        )
     }
+
     fn clone_opaque_types_added_since(
         &self,
         prev_entries: OpaqueTypeStorageEntries,
     ) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
-        self.inner
-            .borrow_mut()
-            .opaque_types()
-            .opaque_types_added_since(prev_entries)
-            .map(|(k, h)| (k, h.ty))
-            .collect()
+        self.inner.borrow_mut().opaque_types().opaque_types_added_since(prev_entries).map(
+            |(k, h)| (k, h.ty),
+        ).collect(
+        )
     }
 
     fn register_hidden_type_in_storage(
     ) -> Option<Ty<'db>> {
         self.register_hidden_type_in_storage(opaque_type_key, OpaqueHiddenType { ty: hidden_ty })
     }
+
     fn add_duplicate_opaque_type(
         &self,
         opaque_type_key: OpaqueTypeKey<'db>,