COMPARISON DIFF
============================================================

Original size: 11079 bytes
Chloro size:   11761 bytes
Rustfmt size:  11433 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Definition of `InferCtxtLike` from the librarified type layer.
 
 use rustc_type_ir::{
-    inherent::{Const as _, IntoKind, Ty as _},
-    relate::combine::PredicateEmittingRelation,
-    ConstVid, FloatVarValue, FloatVid, GenericArgKind, InferConst, InferTy, IntVarValue, IntVid,
-    RegionVid, TyVid, TypeFoldable, TypingMode, UniverseIndex,
+    inherent::{Const as _, IntoKind, Ty as _}, relate::combine::PredicateEmittingRelation, ConstVid,
+    FloatVarValue, FloatVid, GenericArgKind, InferConst, InferTy, IntVarValue, IntVid, RegionVid,
+    TyVid, TypeFoldable, TypingMode, UniverseIndex,
 };
 
 use crate::next_solver::{
-    infer::opaque_types::{table::OpaqueTypeStorageEntries, OpaqueHiddenType},
-    Binder, Const, ConstKind, DbInterner, ErrorGuaranteed, GenericArgs, OpaqueTypeKey, Region,
-    SolverDefId, Span, Ty, TyKind,
+    infer::opaque_types::{OpaqueHiddenType, table::OpaqueTypeStorageEntries}, Binder, Const,
+    ConstKind, DbInterner, ErrorGuaranteed, GenericArgs, OpaqueTypeKey, Region, SolverDefId, Span,
+    Ty, TyKind,
 };
-
-use super::{relate::RelateResult, BoundRegionConversionTime, InferCtxt};
+use super::{BoundRegionConversionTime, InferCtxt, relate::RelateResult};
 
 impl<'db> rustc_type_ir::InferCtxtLike for InferCtxt<'db> {
     type Interner = DbInterner<'db>;
         self.create_next_universe()
     }
 
-    fn universe_of_ty(&self, vid: TyVid) -> Option<UniverseIndex> {
+    fn universe_of_ty(
+        &self,
+        vid: TyVid,
+    ) -> Option<UniverseIndex> {
         self.probe_ty_var(vid).err()
     }
 
-    fn universe_of_lt(&self, lt: RegionVid) -> Option<UniverseIndex> {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .probe_value(lt)
-            .err()
+    fn universe_of_lt(
+        &self,
+        lt: RegionVid,
+    ) -> Option<UniverseIndex> {
+        self.inner.borrow_mut().unwrap_region_constraints().probe_value(lt).err()
     }
 
-    fn universe_of_ct(&self, ct: ConstVid) -> Option<UniverseIndex> {
+    fn universe_of_ct(
+        &self,
+        ct: ConstVid,
+    ) -> Option<UniverseIndex> {
         self.probe_const_var(ct).err()
     }
 
-    fn root_ty_var(&self, var: TyVid) -> TyVid {
+    fn root_ty_var(
+        &self,
+        var: TyVid,
+    ) -> TyVid {
         self.root_var(var)
     }
 
-    fn root_const_var(&self, var: ConstVid) -> ConstVid {
+    fn root_const_var(
+        &self,
+        var: ConstVid,
+    ) -> ConstVid {
         self.root_const_var(var)
     }
 
-    fn opportunistic_resolve_ty_var(&self, vid: TyVid) -> Ty<'db> {
+    fn opportunistic_resolve_ty_var(
+        &self,
+        vid: TyVid,
+    ) -> Ty<'db> {
         match self.probe_ty_var(vid) {
             Ok(ty) => ty,
             Err(_) => Ty::new_var(self.interner, self.root_var(vid)),
         }
     }
 
-    fn opportunistic_resolve_int_var(&self, vid: IntVid) -> Ty<'db> {
+    fn opportunistic_resolve_int_var(
+        &self,
+        vid: IntVid,
+    ) -> Ty<'db> {
         self.opportunistic_resolve_int_var(vid)
     }
 
-    fn opportunistic_resolve_float_var(&self, vid: FloatVid) -> Ty<'db> {
+    fn opportunistic_resolve_float_var(
+        &self,
+        vid: FloatVid,
+    ) -> Ty<'db> {
         self.opportunistic_resolve_float_var(vid)
     }
 
-    fn opportunistic_resolve_ct_var(&self, vid: ConstVid) -> Const<'db> {
+    fn opportunistic_resolve_ct_var(
+        &self,
+        vid: ConstVid,
+    ) -> Const<'db> {
         match self.probe_const_var(vid) {
             Ok(ct) => ct,
             Err(_) => Const::new_var(self.interner, self.root_const_var(vid)),
         }
     }
 
-    fn opportunistic_resolve_lt_var(&self, vid: RegionVid) -> Region<'db> {
+    fn opportunistic_resolve_lt_var(
+        &self,
+        vid: RegionVid,
+    ) -> Region<'db> {
         self.inner
             .borrow_mut()
             .unwrap_region_constraints()
             .opportunistic_resolve_var(self.interner, vid)
     }
 
-    fn is_changed_arg(&self, arg: <Self::Interner as rustc_type_ir::Interner>::GenericArg) -> bool {
+    fn is_changed_arg(
+        &self,
+        arg: <Self::Interner as rustc_type_ir::Interner>::GenericArg,
+    ) -> bool {
         match arg.kind() {
             GenericArgKind::Lifetime(_) => {
                 // Lifetimes should not change affect trait selection.
             GenericArgKind::Type(ty) => {
                 if let TyKind::Infer(infer_ty) = ty.kind() {
                     match infer_ty {
-                        InferTy::TyVar(vid) => !self
-                            .probe_ty_var(vid)
-                            .is_err_and(|_| self.root_var(vid) == vid),
+                        InferTy::TyVar(vid) => {
+                            !self.probe_ty_var(vid).is_err_and(|_| self.root_var(vid) == vid)
+                        }
                         InferTy::IntVar(vid) => {
                             let mut inner = self.inner.borrow_mut();
                             !matches!(
         self.next_const_var()
     }
 
-    fn fresh_args_for_item(&self, def_id: SolverDefId) -> GenericArgs<'db> {
+    fn fresh_args_for_item(
+        &self,
+        def_id: SolverDefId,
+    ) -> GenericArgs<'db> {
         self.fresh_args_for_item(def_id)
     }
 
         self.enter_forall(value, f)
     }
 
-    fn equate_ty_vids_raw(&self, a: rustc_type_ir::TyVid, b: rustc_type_ir::TyVid) {
+    fn equate_ty_vids_raw(
+        &self,
+        a: rustc_type_ir::TyVid,
+        b: rustc_type_ir::TyVid,
+    ) {
         self.inner.borrow_mut().type_variables().equate(a, b);
     }
 
-    fn equate_int_vids_raw(&self, a: rustc_type_ir::IntVid, b: rustc_type_ir::IntVid) {
+    fn equate_int_vids_raw(
+        &self,
+        a: rustc_type_ir::IntVid,
+        b: rustc_type_ir::IntVid,
+    ) {
         self.inner.borrow_mut().int_unification_table().union(a, b);
     }
 
-    fn equate_float_vids_raw(&self, a: rustc_type_ir::FloatVid, b: rustc_type_ir::FloatVid) {
-        self.inner
-            .borrow_mut()
-            .float_unification_table()
-            .union(a, b);
+    fn equate_float_vids_raw(
+        &self,
+        a: rustc_type_ir::FloatVid,
+        b: rustc_type_ir::FloatVid,
+    ) {
+        self.inner.borrow_mut().float_unification_table().union(a, b);
     }
 
-    fn equate_const_vids_raw(&self, a: rustc_type_ir::ConstVid, b: rustc_type_ir::ConstVid) {
-        self.inner
-            .borrow_mut()
-            .const_unification_table()
-            .union(a, b);
+    fn equate_const_vids_raw(
+        &self,
+        a: rustc_type_ir::ConstVid,
+        b: rustc_type_ir::ConstVid,
+    ) {
+        self.inner.borrow_mut().const_unification_table().union(a, b);
     }
 
     fn instantiate_ty_var_raw<R: PredicateEmittingRelation<Self>>(
         vid: rustc_type_ir::IntVid,
         value: rustc_type_ir::IntVarValue,
     ) {
-        self.inner
-            .borrow_mut()
-            .int_unification_table()
-            .union_value(vid, value);
+        self.inner.borrow_mut().int_unification_table().union_value(vid, value);
     }
 
     fn instantiate_float_var_raw(
         vid: rustc_type_ir::FloatVid,
         value: rustc_type_ir::FloatVarValue,
     ) {
-        self.inner
-            .borrow_mut()
-            .float_unification_table()
-            .union_value(vid, value);
+        self.inner.borrow_mut().float_unification_table().union_value(vid, value);
     }
 
     fn instantiate_const_var_raw<R: PredicateEmittingRelation<Self>>(
         self.instantiate_const_var(relation, target_is_expected, target_vid, source_ct)
     }
 
-    fn set_tainted_by_errors(&self, e: ErrorGuaranteed) {
+    fn set_tainted_by_errors(
+        &self,
+        e: ErrorGuaranteed,
+    ) {
         self.set_tainted_by_errors(e)
     }
 
-    fn shallow_resolve(&self, ty: Ty<'db>) -> Ty<'db> {
+    fn shallow_resolve(
+        &self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         self.shallow_resolve(ty)
     }
-    fn shallow_resolve_const(&self, ct: Const<'db>) -> Const<'db> {
+
+    fn shallow_resolve_const(
+        &self,
+        ct: Const<'db>,
+    ) -> Const<'db> {
         self.shallow_resolve_const(ct)
     }
 
-    fn resolve_vars_if_possible<T>(&self, value: T) -> T
+    fn resolve_vars_if_possible<T>(
+        &self,
+        value: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         self.resolve_vars_if_possible(value)
     }
 
-    fn probe<T>(&self, probe: impl FnOnce() -> T) -> T {
+    fn probe<T>(
+        &self,
+        probe: impl FnOnce() -> T,
+    ) -> T {
         self.probe(|_| probe())
     }
 
-    fn sub_regions(&self, sub: Region<'db>, sup: Region<'db>, _span: Span) {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .make_subregion(sub, sup);
+    fn sub_regions(
+        &self,
+        sub: Region<'db>,
+        sup: Region<'db>,
+        _span: Span,
+    ) {
+        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(sub, sup);
     }
 
-    fn equate_regions(&self, a: Region<'db>, b: Region<'db>, _span: Span) {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .make_eqregion(a, b);
+    fn equate_regions(
+        &self,
+        a: Region<'db>,
+        b: Region<'db>,
+        _span: Span,
+    ) {
+        self.inner.borrow_mut().unwrap_region_constraints().make_eqregion(a, b);
     }
 
-    fn register_ty_outlives(&self, _ty: Ty<'db>, _r: Region<'db>, _span: Span) {
+    fn register_ty_outlives(
+        &self,
+        _ty: Ty<'db>,
+        _r: Region<'db>,
+        _span: Span,
+    ) {
         // self.register_type_outlives_constraint(ty, r, &ObligationCause::dummy());
     }
 
     fn opaque_types_storage_num_entries(&self) -> OpaqueTypeStorageEntries {
         self.inner.borrow_mut().opaque_types().num_entries()
     }
+
     fn clone_opaque_types_lookup_table(&self) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
-        self.inner
-            .borrow_mut()
-            .opaque_types()
-            .iter_lookup_table()
-            .map(|(k, h)| (k, h.ty))
-            .collect()
+        self.inner.borrow_mut().opaque_types().iter_lookup_table().map(|(k, h)| (k, h.ty)).collect()
     }
+
     fn clone_duplicate_opaque_types(&self) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
         self.inner
             .borrow_mut()
             .map(|(k, h)| (k, h.ty))
             .collect()
     }
+
     fn clone_opaque_types_added_since(
         &self,
         prev_entries: OpaqueTypeStorageEntries,
     ) -> Option<Ty<'db>> {
         self.register_hidden_type_in_storage(opaque_type_key, OpaqueHiddenType { ty: hidden_ty })
     }
+
     fn add_duplicate_opaque_type(
         &self,
         opaque_type_key: OpaqueTypeKey<'db>,
         let _ = self.take_opaque_types();
     }
 
-    fn sub_unification_table_root_var(&self, var: rustc_type_ir::TyVid) -> rustc_type_ir::TyVid {
+    fn sub_unification_table_root_var(
+        &self,
+        var: rustc_type_ir::TyVid,
+    ) -> rustc_type_ir::TyVid {
         self.sub_unification_table_root_var(var)
     }
 
-    fn sub_unify_ty_vids_raw(&self, a: rustc_type_ir::TyVid, b: rustc_type_ir::TyVid) {
+    fn sub_unify_ty_vids_raw(
+        &self,
+        a: rustc_type_ir::TyVid,
+        b: rustc_type_ir::TyVid,
+    ) {
         self.sub_unify_ty_vids_raw(a, b);
     }
 