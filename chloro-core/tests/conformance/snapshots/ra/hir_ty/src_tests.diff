COMPARISON DIFF
============================================================

Original size: 22347 bytes
Chloro size:   22425 bytes
Rustfmt size:  23079 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     InferenceResult,
 };
 
-// These tests compare the inference results for all expressions in a file
-// against snapshots of the expected results using expect. Use
-// `env UPDATE_EXPECT=1 cargo test -p hir_ty` to update the snapshots.
 
+// These tests compare the inference results for all expressions in a file
+
+// against snapshots of the expected results using expect. Use
+
+// `env UPDATE_EXPECT=1 cargo test -p hir_ty` to update the snapshots.
 #[track_caller]
 fn check_types(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
     check_impl(ra_fixture, false, true, false)
                 } else if expected.starts_with("adjustments:") {
                     adjustments.insert(
                         file_range,
-                        expected
-                            .trim_start_matches("adjustments:")
-                            .trim()
-                            .to_owned(),
+                        expected.trim_start_matches("adjustments:").trim().to_owned(),
                     );
                 } else {
                     panic!("unexpected annotation: {expected} @ {range:?}");
                     } else {
                         ty.display_test(&db, display_target).to_string()
                     };
-                    assert_eq!(
-                        actual, expected,
-                        "type annotation differs at {:#?}",
-                        range.range
-                    );
+                    assert_eq!(actual, expected, "type annotation differs at {:#?}", range.range);
                 }
             }
 
                     } else {
                         ty.display_test(&db, display_target).to_string()
                     };
-                    assert_eq!(
-                        actual, expected,
-                        "type annotation differs at {:#?}",
-                        range.range
-                    );
+                    assert_eq!(actual, expected, "type annotation differs at {:#?}", range.range);
                 }
                 if let Some(expected) = adjustments.remove(&range) {
                     let adjustments = inference_result
                 match mismatches.remove(&range) {
                     Some(annotation) => assert_eq!(actual, annotation),
                     None => {
-                        format_to!(
-                            unexpected_type_mismatches,
-                            "{:?}: {}\n",
-                            range.range,
-                            actual
-                        )
+                        format_to!(unexpected_type_mismatches, "{:?}: {}\n", range.range, actual)
                     }
                 }
             }
 
         let mut buf = String::new();
         if !unexpected_type_mismatches.is_empty() {
-            format_to!(
-                buf,
-                "Unexpected type mismatches:\n{}",
-                unexpected_type_mismatches
-            );
+            format_to!(buf, "Unexpected type mismatches:\n{}", unexpected_type_mismatches);
         }
         if !mismatches.is_empty() {
             format_to!(buf, "Unchecked mismatch annotations:\n");
     expr: ExprId,
     db: &TestDB,
 ) -> Option<InFile<SyntaxNode>> {
-    Some(match body_source_map.expr_syntax(expr) {
+    Some(
+        match body_source_map.expr_syntax(expr) {
         Ok(sp) => {
             let root = db.parse_or_expand(sp.file_id);
             sp.map(|ptr| ptr.to_node(&root).syntax().clone())
         }
         Err(SyntheticSyntax) => return None,
-    })
+    },
+    )
 }
 
 fn pat_node(
     pat: PatId,
     db: &TestDB,
 ) -> Option<InFile<SyntaxNode>> {
-    Some(match body_source_map.pat_syntax(pat) {
+    Some(
+        match body_source_map.pat_syntax(pat) {
         Ok(sp) => {
             let root = db.parse_or_expand(sp.file_id);
             sp.map(|ptr| ptr.to_node(&root).syntax().clone())
         }
         Err(SyntheticSyntax) => return None,
-    })
+    },
+    )
 }
 
 fn infer(#[rust_analyzer::rust_fixture] ra_fixture: &str) -> String {
     let _tracing = setup_tracing();
     let (db, file_id) = TestDB::with_single_file(content);
 
-    crate::attach_db(&db, || {
+    crate::attach_db(
+        &db,
+        || {
         let mut buf = String::new();
 
         let mut infer_def = |inference_result: Arc<InferenceResult<'_>>,
             for (node, ty) in &types {
                 let (range, text) =
                     if let Some(self_param) = ast::SelfParam::cast(node.value.clone()) {
-                        (
-                            self_param.name().unwrap().syntax().text_range(),
-                            "self".to_owned(),
-                        )
+                        (self_param.name().unwrap().syntax().text_range(), "self".to_owned())
                     } else {
-                        (
-                            node.value.text_range(),
-                            node.value.text().to_string().replace('\n', " "),
-                        )
+                        (node.value.text_range(), node.value.text().to_string().replace('\n', " "))
                     };
                 let macro_prefix = if node.file_id != file_id { "!" } else { "" };
                 format_to!(
 
         buf.truncate(buf.trim_end().len());
         buf
-    })
+    },
+    )
 }
 
 pub(crate) fn visit_module(
                     visit_body(db, &body, cb);
                 }
                 ModuleDefId::AdtId(hir_def::AdtId::EnumId(it)) => {
-                    it.enum_variants(db)
-                        .variants
-                        .iter()
-                        .for_each(|&(it, _, _)| {
-                            let body = db.body(it.into());
-                            cb(it.into());
-                            visit_body(db, &body, cb);
-                        });
+                    it.enum_variants(db).variants.iter().for_each(|&(it, _, _)| {
+                        let body = db.body(it.into());
+                        cb(it.into());
+                        visit_body(db, &body, cb);
+                    });
                 }
                 ModuleDefId::TraitId(it) => {
                     let trait_data = it.trait_items(db);
 
     db.set_file_text(pos.file_id.file_id(&db), new_text);
 
-    crate::attach_db(&db, || {
+    crate::attach_db(
+        &db,
+        || {
         let module = db.module_for_file(pos.file_id.file_id(&db));
         let crate_def_map = module.def_map(&db);
         visit_module(&db, crate_def_map, module.local_id, &mut |def| {
                 _ => return,
             });
         });
-    })
+    },
+    )
 }