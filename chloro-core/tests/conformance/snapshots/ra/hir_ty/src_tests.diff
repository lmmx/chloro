COMPARISON DIFF
============================================================

Original size: 22347 bytes
Chloro size:   22137 bytes
Rustfmt size:  23079 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     src::HasSource,
     AssocItemId, DefWithBodyId, HasModule, LocalModuleId, Lookup, ModuleDefId, SyntheticSyntax,
 };
-use hir_expand::{db::ExpandDatabase, FileRange, InFile};
+use hir_expand::{FileRange, InFile, db::ExpandDatabase};
 use itertools::Itertools;
 use rustc_hash::FxHashMap;
 use stdx::format_to;
     InferenceResult,
 };
 
-// These tests compare the inference results for all expressions in a file
-// against snapshots of the expected results using expect. Use
-// `env UPDATE_EXPECT=1 cargo test -p hir_ty` to update the snapshots.
-
 #[track_caller]
 fn check_types(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
     check_impl(ra_fixture, false, true, false)
                 } else if expected.starts_with("adjustments:") {
                     adjustments.insert(
                         file_range,
-                        expected
-                            .trim_start_matches("adjustments:")
-                            .trim()
-                            .to_owned(),
+                        expected.trim_start_matches("adjustments:").trim().to_owned(),
                     );
                 } else {
                     panic!("unexpected annotation: {expected} @ {range:?}");
                     } else {
                         ty.display_test(&db, display_target).to_string()
                     };
-                    assert_eq!(
-                        actual, expected,
-                        "type annotation differs at {:#?}",
-                        range.range
-                    );
+                    assert_eq!(actual, expected, "type annotation differs at {:#?}", range.range);
                 }
             }
 
                     } else {
                         ty.display_test(&db, display_target).to_string()
                     };
-                    assert_eq!(
-                        actual, expected,
-                        "type annotation differs at {:#?}",
-                        range.range
-                    );
+                    assert_eq!(actual, expected, "type annotation differs at {:#?}", range.range);
                 }
                 if let Some(expected) = adjustments.remove(&range) {
                     let adjustments = inference_result
                 match mismatches.remove(&range) {
                     Some(annotation) => assert_eq!(actual, annotation),
                     None => {
-                        format_to!(
-                            unexpected_type_mismatches,
-                            "{:?}: {}\n",
-                            range.range,
-                            actual
-                        )
+                        format_to!(unexpected_type_mismatches, "{:?}: {}\n", range.range, actual)
                     }
                 }
             }
 
         let mut buf = String::new();
         if !unexpected_type_mismatches.is_empty() {
-            format_to!(
-                buf,
-                "Unexpected type mismatches:\n{}",
-                unexpected_type_mismatches
-            );
+            format_to!(buf, "Unexpected type mismatches:\n{}", unexpected_type_mismatches);
         }
         if !mismatches.is_empty() {
             format_to!(buf, "Unchecked mismatch annotations:\n");
             for (node, ty) in &types {
                 let (range, text) =
                     if let Some(self_param) = ast::SelfParam::cast(node.value.clone()) {
-                        (
-                            self_param.name().unwrap().syntax().text_range(),
-                            "self".to_owned(),
-                        )
+                        (self_param.name().unwrap().syntax().text_range(), "self".to_owned())
                     } else {
-                        (
-                            node.value.text_range(),
-                            node.value.text().to_string().replace('\n', " "),
-                        )
+                        (node.value.text_range(), node.value.text().to_string().replace('\n', " "))
                     };
                 let macro_prefix = if node.file_id != file_id { "!" } else { "" };
                 format_to!(
                     visit_body(db, &body, cb);
                 }
                 ModuleDefId::AdtId(hir_def::AdtId::EnumId(it)) => {
-                    it.enum_variants(db)
-                        .variants
-                        .iter()
-                        .for_each(|&(it, _, _)| {
-                            let body = db.body(it.into());
-                            cb(it.into());
-                            visit_body(db, &body, cb);
-                        });
+                    it.enum_variants(db).variants.iter().for_each(|&(it, _, _)| {
+                        let body = db.body(it.into());
+                        cb(it.into());
+                        visit_body(db, &body, cb);
+                    });
                 }
                 ModuleDefId::TraitId(it) => {
                     let trait_data = it.trait_items(db);