COMPARISON DIFF
============================================================

Original size: 12941 bytes
Chloro size:   13029 bytes
Rustfmt size:  13256 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use std::fmt;
 
-use hir_def::{lang_item::LangItem, TraitId, TypeAliasId};
+use hir_def::{TraitId, TypeAliasId, lang_item::LangItem};
 use rustc_type_ir::inherent::{IntoKind, Ty as _};
 use tracing::debug;
 use triomphe::Arc;
     db::HirDatabase,
     infer::unify::InferenceTable,
     next_solver::{
+        Canonical, TraitRef, Ty, TyKind,
         infer::{
-            traits::{Obligation, ObligationCause, PredicateObligations},
             InferOk,
+            traits::{Obligation, ObligationCause, PredicateObligations},
         },
         obligation_ctxt::ObligationCtxt,
-        Canonical, TraitRef, Ty, TyKind,
     },
     TraitEnvironment,
 };
     v.into_iter()
 }
 
-pub(crate) trait TrackAutoderefSteps<'db>: Default + fmt::Debug {
+pub(crate) trait TrackAutoderefSteps<'db> {
     fn len(&self) -> usize;
-    fn push(&mut self, ty: Ty<'db>, kind: AutoderefKind);
+
+    fn push(
+        &mut self,
+        ty: Ty<'db>,
+        kind: AutoderefKind,
+    );
 }
 
 impl<'db> TrackAutoderefSteps<'db> for usize {
     fn len(&self) -> usize {
         *self
     }
-    fn push(&mut self, _: Ty<'db>, _: AutoderefKind) {
+
+    fn push(
+        &mut self,
+        _: Ty<'db>,
+        _: AutoderefKind,
+    ) {
         *self += 1;
     }
 }
+
 impl<'db> TrackAutoderefSteps<'db> for Vec<(Ty<'db>, AutoderefKind)> {
     fn len(&self) -> usize {
         self.len()
     }
-    fn push(&mut self, ty: Ty<'db>, kind: AutoderefKind) {
+
+    fn push(
+        &mut self,
+        ty: Ty<'db>,
+        kind: AutoderefKind,
+    ) {
         self.push((ty, kind));
     }
 }
 /// Although called `Autoderef` it can be configured to use the
 /// `Receiver` trait instead of the `Deref` trait.
 pub(crate) struct Autoderef<'a, 'db, Steps = Vec<(Ty<'db>, AutoderefKind)>> {
-    // Meta infos:
     pub(crate) table: &'a mut InferenceTable<'db>,
     traits: Option<AutoderefTraits>,
-
-    // Current state:
     state: AutoderefSnapshot<'db, Steps>,
-
-    // Configurations:
     include_raw_pointers: bool,
     use_receiver_trait: bool,
 }
     type Item = (Ty<'db>, usize);
 
     fn next(&mut self) -> Option<Self::Item> {
-        debug!(
-            "autoderef: steps={:?}, cur_ty={:?}",
-            self.state.steps, self.state.cur_ty
-        );
+        debug!("autoderef: steps={:?}, cur_ty={:?}", self.state.steps, self.state.cur_ty);
         if self.state.at_start {
             self.state.at_start = false;
             debug!("autoderef stage #0 is {:?}", self.state.cur_ty);
             return Some((self.state.cur_ty, 0));
         }
-
         // If we have reached the recursion limit, error gracefully.
         if self.state.steps.len() >= AUTODEREF_RECURSION_LIMIT {
             self.state.reached_recursion_limit = true;
             return None;
         }
-
         if self.state.cur_ty.is_ty_var() {
             return None;
         }
-
         // Otherwise, deref if type is derefable:
         // NOTE: in the case of self.use_receiver_trait = true, you might think it would
         // be better to skip this clause and use the Overloaded case only, since &T
         // and &mut T implement Receiver. But built-in derefs apply equally to Receiver
         // and Deref, and this has benefits for const and the emitted MIR.
-        let (kind, new_ty) = if let Some(ty) = self
-            .state
-            .cur_ty
-            .builtin_deref(self.table.db, self.include_raw_pointers)
+        let (kind, new_ty) = if let Some(ty) =
+            self.state.cur_ty.builtin_deref(self.table.db, self.include_raw_pointers)
         {
             debug_assert_eq!(ty, self.table.infer_ctxt.resolve_vars_if_possible(ty));
             // NOTE: we may still need to normalize the built-in deref in case
         } else {
             return None;
         };
-
         self.state.steps.push(self.state.cur_ty, kind);
         debug!(
             "autoderef stage #{:?} is {:?} from {:?}",
             (self.state.cur_ty, kind)
         );
         self.state.cur_ty = new_ty;
-
         Some((self.state.cur_ty, self.step_count()))
     }
 }
 
 impl<'a, 'db> Autoderef<'a, 'db> {
-    pub(crate) fn new(table: &'a mut InferenceTable<'db>, base_ty: Ty<'db>) -> Self {
+    pub(crate) fn new(
+        table: &'a mut InferenceTable<'db>,
+        base_ty: Ty<'db>,
+    ) -> Self {
         Self::new_impl(table, base_ty)
     }
 }
 
 impl<'a, 'db> Autoderef<'a, 'db, usize> {
-    pub(crate) fn new_no_tracking(table: &'a mut InferenceTable<'db>, base_ty: Ty<'db>) -> Self {
+    pub(crate) fn new_no_tracking(
+        table: &'a mut InferenceTable<'db>,
+        base_ty: Ty<'db>,
+    ) -> Self {
         Self::new_impl(table, base_ty)
     }
 }
 
 impl<'a, 'db, Steps: TrackAutoderefSteps<'db>> Autoderef<'a, 'db, Steps> {
-    fn new_impl(table: &'a mut InferenceTable<'db>, base_ty: Ty<'db>) -> Self {
+    fn new_impl(
+        table: &'a mut InferenceTable<'db>,
+        base_ty: Ty<'db>,
+    ) -> Self {
         Autoderef {
             state: AutoderefSnapshot {
                 steps: Steps::default(),
         }
     }
 
-    fn overloaded_deref_ty(&mut self, ty: Ty<'db>) -> Option<Ty<'db>> {
+    fn overloaded_deref_ty(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Option<Ty<'db>> {
         debug!("overloaded_deref_ty({:?})", ty);
         let interner = self.table.interner();
-
         // <ty as Deref>, or whatever the equivalent trait is that we've been asked to walk.
-        let AutoderefTraits {
-            trait_,
-            trait_target,
-        } = self.autoderef_traits()?;
-
+        let AutoderefTraits { trait_, trait_target } = self.autoderef_traits()?;
         let trait_ref = TraitRef::new(interner, trait_.into(), [ty]);
-        let obligation = Obligation::new(
-            interner,
-            ObligationCause::new(),
-            self.table.trait_env.env,
-            trait_ref,
-        );
+        let obligation =
+            Obligation::new(interner, ObligationCause::new(), self.table.trait_env.env, trait_ref);
         // We detect whether the self type implements `Deref` before trying to
         // structurally normalize. We use `predicate_may_hold_opaque_types_jank`
         // to support not-yet-defined opaque types. It will succeed for `impl Deref`
         // but fail for `impl OtherTrait`.
-        if !self
-            .table
-            .infer_ctxt
-            .predicate_may_hold_opaque_types_jank(&obligation)
-        {
+        if !self.table.infer_ctxt.predicate_may_hold_opaque_types_jank(&obligation) {
             debug!("overloaded_deref_ty: cannot match obligation");
             return None;
         }
-
         let (normalized_ty, obligations) = structurally_normalize_ty(
             self.table,
             Ty::new_projection(interner, trait_target.into(), [ty]),
         )?;
-        debug!(
-            "overloaded_deref_ty({:?}) = ({:?}, {:?})",
-            ty, normalized_ty, obligations
-        );
+        debug!("overloaded_deref_ty({:?}) = ({:?}, {:?})", ty, normalized_ty, obligations);
         self.state.obligations.extend(obligations);
-
-        Some(
-            self.table
-                .infer_ctxt
-                .resolve_vars_if_possible(normalized_ty),
-        )
+        Some(self.table.infer_ctxt.resolve_vars_if_possible(normalized_ty))
     }
 
     /// Returns the final type we ended up with, which may be an unresolved
     if !errors.is_empty() {
         unreachable!();
     }
-
     Some((normalized_ty, ocx.into_pending_obligations()))
 }
 
     ty: Ty<'db>,
 ) -> Option<InferOk<'db, Ty<'db>>> {
     let interner = table.interner();
-
     let trait_target = LangItem::DerefTarget.resolve_type_alias(table.db, table.trait_env.krate)?;
-
-    let (normalized_ty, obligations) = structurally_normalize_ty(
-        table,
-        Ty::new_projection(interner, trait_target.into(), [ty]),
-    )?;
-
-    Some(InferOk {
-        value: normalized_ty,
-        obligations,
-    })
+    let (normalized_ty, obligations) =
+        structurally_normalize_ty(table, Ty::new_projection(interner, trait_target.into(), [ty]))?;
+    Some(InferOk { value: normalized_ty, obligations })
 }