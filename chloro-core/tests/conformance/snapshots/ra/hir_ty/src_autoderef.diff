COMPARISON DIFF
============================================================

Original size: 12941 bytes
Chloro size:   12925 bytes
Rustfmt size:  13256 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use std::fmt;
 
-use hir_def::{lang_item::LangItem, TraitId, TypeAliasId};
+use hir_def::{TraitId, TypeAliasId, lang_item::LangItem};
 use rustc_type_ir::inherent::{IntoKind, Ty as _};
 use tracing::debug;
 use triomphe::Arc;
 
 use crate::{
+    TraitEnvironment,
     db::HirDatabase,
     infer::unify::InferenceTable,
     next_solver::{
+        Canonical, TraitRef, Ty, TyKind,
         infer::{
-            traits::{Obligation, ObligationCause, PredicateObligations},
             InferOk,
+            traits::{Obligation, ObligationCause, PredicateObligations},
         },
         obligation_ctxt::ObligationCtxt,
-        Canonical, TraitRef, Ty, TyKind,
     },
-    TraitEnvironment,
 };
 
 const AUTODEREF_RECURSION_LIMIT: usize = 20;
     v.into_iter()
 }
 
-pub(crate) trait TrackAutoderefSteps<'db>: Default + fmt::Debug {
+pub(crate) trait TrackAutoderefSteps<'db> {
     fn len(&self) -> usize;
+
     fn push(&mut self, ty: Ty<'db>, kind: AutoderefKind);
 }
 
     fn len(&self) -> usize {
         *self
     }
+
     fn push(&mut self, _: Ty<'db>, _: AutoderefKind) {
         *self += 1;
     }
 }
+
 impl<'db> TrackAutoderefSteps<'db> for Vec<(Ty<'db>, AutoderefKind)> {
     fn len(&self) -> usize {
         self.len()
     }
+
     fn push(&mut self, ty: Ty<'db>, kind: AutoderefKind) {
         self.push((ty, kind));
     }
     // Meta infos:
     pub(crate) table: &'a mut InferenceTable<'db>,
     traits: Option<AutoderefTraits>,
-
     // Current state:
     state: AutoderefSnapshot<'db, Steps>,
-
     // Configurations:
     include_raw_pointers: bool,
     use_receiver_trait: bool,
     type Item = (Ty<'db>, usize);
 
     fn next(&mut self) -> Option<Self::Item> {
-        debug!(
-            "autoderef: steps={:?}, cur_ty={:?}",
-            self.state.steps, self.state.cur_ty
-        );
+        debug!("autoderef: steps={:?}, cur_ty={:?}", self.state.steps, self.state.cur_ty);
         if self.state.at_start {
             self.state.at_start = false;
             debug!("autoderef stage #0 is {:?}", self.state.cur_ty);
         }
 
         // Otherwise, deref if type is derefable:
+
         // NOTE: in the case of self.use_receiver_trait = true, you might think it would
+
         // be better to skip this clause and use the Overloaded case only, since &T
+
         // and &mut T implement Receiver. But built-in derefs apply equally to Receiver
+
         // and Deref, and this has benefits for const and the emitted MIR.
-        let (kind, new_ty) = if let Some(ty) = self
-            .state
-            .cur_ty
-            .builtin_deref(self.table.db, self.include_raw_pointers)
+        let (kind, new_ty) = if let Some(ty) =
+            self.state.cur_ty.builtin_deref(self.table.db, self.include_raw_pointers)
         {
             debug_assert_eq!(ty, self.table.infer_ctxt.resolve_vars_if_possible(ty));
             // NOTE: we may still need to normalize the built-in deref in case
         let interner = self.table.interner();
 
         // <ty as Deref>, or whatever the equivalent trait is that we've been asked to walk.
-        let AutoderefTraits {
-            trait_,
-            trait_target,
-        } = self.autoderef_traits()?;
+        let AutoderefTraits { trait_, trait_target } = self.autoderef_traits()?;
 
         let trait_ref = TraitRef::new(interner, trait_.into(), [ty]);
-        let obligation = Obligation::new(
-            interner,
-            ObligationCause::new(),
-            self.table.trait_env.env,
-            trait_ref,
-        );
+        let obligation =
+            Obligation::new(interner, ObligationCause::new(), self.table.trait_env.env, trait_ref);
         // We detect whether the self type implements `Deref` before trying to
         // structurally normalize. We use `predicate_may_hold_opaque_types_jank`
         // to support not-yet-defined opaque types. It will succeed for `impl Deref`
         // but fail for `impl OtherTrait`.
-        if !self
-            .table
-            .infer_ctxt
-            .predicate_may_hold_opaque_types_jank(&obligation)
-        {
+        if !self.table.infer_ctxt.predicate_may_hold_opaque_types_jank(&obligation) {
             debug!("overloaded_deref_ty: cannot match obligation");
             return None;
         }
             self.table,
             Ty::new_projection(interner, trait_target.into(), [ty]),
         )?;
-        debug!(
-            "overloaded_deref_ty({:?}) = ({:?}, {:?})",
-            ty, normalized_ty, obligations
-        );
+        debug!("overloaded_deref_ty({:?}) = ({:?}, {:?})", ty, normalized_ty, obligations);
         self.state.obligations.extend(obligations);
 
-        Some(
-            self.table
-                .infer_ctxt
-                .resolve_vars_if_possible(normalized_ty),
-        )
+        Some(self.table.infer_ctxt.resolve_vars_if_possible(normalized_ty))
     }
 
     /// Returns the final type we ended up with, which may be an unresolved
 
     let trait_target = LangItem::DerefTarget.resolve_type_alias(table.db, table.trait_env.krate)?;
 
-    let (normalized_ty, obligations) = structurally_normalize_ty(
-        table,
-        Ty::new_projection(interner, trait_target.into(), [ty]),
-    )?;
+    let (normalized_ty, obligations) =
+        structurally_normalize_ty(table, Ty::new_projection(interner, trait_target.into(), [ty]))?;
 
-    Some(InferOk {
-        value: normalized_ty,
-        obligations,
-    })
+    Some(InferOk { value: normalized_ty, obligations })
 }