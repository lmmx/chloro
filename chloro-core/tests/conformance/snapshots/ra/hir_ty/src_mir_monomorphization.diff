COMPARISON DIFF
============================================================

Original size: 9213 bytes
Chloro size:   9298 bytes
Rustfmt size:  9281 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::next_solver::{Const, ConstKind, Region, RegionKind};
 use crate::{
-    db::{HirDatabase, InternedClosureId},
-    next_solver::{
-        infer::{traits::ObligationCause, DbInternerInferExt, InferCtxt},
-        obligation_ctxt::ObligationCtxt,
-        references_non_lt_error, DbInterner, GenericArgs, Ty, TyKind, TypingMode,
-    },
-    TraitEnvironment,
+    db::{HirDatabase, infer::{DbInternerInferExt, next_solver::{
+        DbInterner,
+    obligation_ctxt::ObligationCtxt, references_non_lt_error, traits::ObligationCause},
+    GenericArgs, InferCtxt, InternedClosureId}, TraitEnvironment, Ty, TyKind, TypingMode, },
 };
-
 use super::{MirBody, MirLowerError, Operand, OperandKind, Rvalue, StatementKind, TerminatorKind};
 
 struct Filler<'db> {
         self.infcx.interner
     }
 
-    fn try_fold_ty(&mut self, ty: Ty<'db>) -> Result<Ty<'db>, Self::Error> {
+    fn try_fold_ty(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Result<Ty<'db>, Self::Error> {
         if !ty.has_type_flags(TypeFlags::HAS_ALIAS | TypeFlags::HAS_PARAM) {
             return Ok(ty);
         }
-
         match ty.kind() {
             TyKind::Alias(..) => {
                 // First instantiate params.
         }
     }
 
-    fn try_fold_const(&mut self, ct: Const<'db>) -> Result<Const<'db>, Self::Error> {
+    fn try_fold_const(
+        &mut self,
+        ct: Const<'db>,
+    ) -> Result<Const<'db>, Self::Error> {
         let ConstKind::Param(param) = ct.kind() else {
             return ct.try_super_fold_with(self);
         };
             .ok_or_else(|| MirLowerError::GenericArgNotProvided(param.id.into(), self.subst))
     }
 
-    fn try_fold_region(&mut self, region: Region<'db>) -> Result<Region<'db>, Self::Error> {
+    fn try_fold_region(
+        &mut self,
+        region: Region<'db>,
+    ) -> Result<Region<'db>, Self::Error> {
         let RegionKind::ReEarlyParam(param) = region.kind() else {
             return Ok(region);
         };
     ) -> Self {
         let interner = DbInterner::new_with(db, Some(env.krate), env.block);
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
-        Self {
-            infcx,
-            trait_env: env,
-            subst,
-        }
+        Self { infcx, trait_env: env, subst }
     }
 
     fn fill<T: TypeFoldable<DbInterner<'db>> + Copy>(
         // Can't deep normalized as that'll try to normalize consts and fail.
         *t = t.try_fold_with(self)?;
         if references_non_lt_error(t) {
-            Err(MirLowerError::NotSupported(
-                "monomorphization resulted in errors".to_owned(),
-            ))
+            Err(MirLowerError::NotSupported("monomorphization resulted in errors".to_owned()))
         } else {
             Ok(())
         }
     }
 
-    fn fill_operand(&mut self, op: &mut Operand<'db>) -> Result<(), MirLowerError<'db>> {
+    fn fill_operand(
+        &mut self,
+        op: &mut Operand<'db>,
+    ) -> Result<(), MirLowerError<'db>> {
         match &mut op.kind {
             OperandKind::Constant { konst, ty } => {
                 self.fill(konst)?;
         Ok(())
     }
 
-    fn fill_body(&mut self, body: &mut MirBody<'db>) -> Result<(), MirLowerError<'db>> {
+    fn fill_body(
+        &mut self,
+        body: &mut MirBody<'db>,
+    ) -> Result<(), MirLowerError<'db>> {
         for (_, l) in body.locals.iter_mut() {
             self.fill(&mut l.ty)?;
         }