COMPARISON DIFF
============================================================

Original size: 14262 bytes
Chloro size:   14696 bytes
Rustfmt size:  14546 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use macros::{TypeFoldable, TypeVisitable};
 use rustc_ast_ir::visit::VisitorResult;
 use rustc_type_ir::{
-    inherent::{IntoKind, ParamEnv as _, PlaceholderLike, SliceLike},
-    relate::Relate,
     BoundVar, BoundVarIndexKind, ConstVid, DebruijnIndex, FlagComputation, Flags, InferConst,
     TypeFoldable, TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,
     WithCachedTypeInfo,
+    inherent::{IntoKind, ParamEnv as _, PlaceholderLike, SliceLike},
+    relate::Relate,
 };
 
 use crate::{
-    next_solver::{interner::InternedWrapperNoDebug, ClauseKind, ParamEnv},
     MemoryMap,
+    next_solver::{ClauseKind, ParamEnv, interner::InternedWrapperNoDebug},
 };
-
 use super::{BoundVarKind, DbInterner, ErrorGuaranteed, GenericArgs, Placeholder, Ty};
 
 pub type ConstKind<'db> = rustc_type_ir::ConstKind<DbInterner<'db>>;
+
 pub type UnevaluatedConst<'db> = rustc_type_ir::UnevaluatedConst<DbInterner<'db>>;
 
 #[salsa::interned(constructor = new_)]
 }
 
 impl<'db> Const<'db> {
-    pub fn new(interner: DbInterner<'db>, kind: ConstKind<'db>) -> Self {
+    pub fn new(
+        interner: DbInterner<'db>,
+        kind: ConstKind<'db>,
+    ) -> Self {
         let flags = FlagComputation::for_const_kind(&kind);
         let cached = WithCachedTypeInfo {
             internee: kind,
         Const::new(interner, ConstKind::Error(ErrorGuaranteed))
     }
 
-    pub fn new_param(interner: DbInterner<'db>, param: ParamConst) -> Self {
+    pub fn new_param(
+        interner: DbInterner<'db>,
+        param: ParamConst,
+    ) -> Self {
         Const::new(interner, ConstKind::Param(param))
     }
 
-    pub fn new_placeholder(interner: DbInterner<'db>, placeholder: PlaceholderConst) -> Self {
+    pub fn new_placeholder(
+        interner: DbInterner<'db>,
+        placeholder: PlaceholderConst,
+    ) -> Self {
         Const::new(interner, ConstKind::Placeholder(placeholder))
     }
 
-    pub fn new_bound(interner: DbInterner<'db>, index: DebruijnIndex, bound: BoundConst) -> Self {
-        Const::new(
-            interner,
-            ConstKind::Bound(BoundVarIndexKind::Bound(index), bound),
-        )
+    pub fn new_bound(
+        interner: DbInterner<'db>,
+        index: DebruijnIndex,
+        bound: BoundConst,
+    ) -> Self {
+        Const::new(interner, ConstKind::Bound(BoundVarIndexKind::Bound(index), bound))
     }
 
     pub fn new_valtree(
 }
 
 impl<'db> std::fmt::Debug for Const<'db> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         self.inner().internee.fmt(f)
     }
 }
 
 impl<'db> std::fmt::Debug for InternedWrapperNoDebug<WithCachedTypeInfo<ConstKind<'db>>> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         self.0.internee.fmt(f)
     }
 }
 
 #[derive(Copy, Clone, Hash, Eq, PartialEq)]
 pub struct ParamConst {
-    // FIXME: See `ParamTy`.
     pub id: ConstParamId,
     pub index: u32,
 }
 
 impl std::fmt::Debug for ParamConst {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         write!(f, "#{}", self.index)
     }
 }
 
 impl ParamConst {
-    pub fn find_const_ty_from_env<'db>(self, env: ParamEnv<'db>) -> Ty<'db> {
+    pub fn find_const_ty_from_env<'db>(
+        self,
+        env: ParamEnv<'db>,
+    ) -> Ty<'db> {
         let mut candidates = env.caller_bounds().iter().filter_map(|clause| {
             // `ConstArgHasType` are never desugared to be higher ranked.
             match clause.kind().skip_binder() {
                 _ => None,
             }
         });
-
         // N.B. it may be tempting to fix ICEs by making this function return
         // `Option<Ty<'db>>` instead of `Ty<'db>`; however, this is generally
         // considered to be a bandaid solution, since it hides more important
 #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash, TypeFoldable, TypeVisitable)]
 pub struct ValueConst<'db> {
     pub ty: Ty<'db>,
-    // FIXME: Should we ignore this for TypeVisitable, TypeFoldable?
     #[type_visitable(ignore)]
     #[type_foldable(identity)]
     pub value: Valtree<'db>,
 }
 
 impl<'db> ValueConst<'db> {
-    pub fn new(ty: Ty<'db>, bytes: ConstBytes<'db>) -> Self {
+    pub fn new(
+        ty: Ty<'db>,
+        bytes: ConstBytes<'db>,
+    ) -> Self {
         let value = Valtree::new(bytes);
         ValueConst { ty, value }
     }
 }
 
 impl Hash for ConstBytes<'_> {
-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+    fn hash<H: std::hash::Hasher>(
+        &self,
+        state: &mut H,
+    ) {
         self.memory.hash(state)
     }
 }
     ) -> Result<Self, F::Error> {
         folder.try_fold_const(self)
     }
-    fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
+
+    fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
+        self,
+        folder: &mut F,
+    ) -> Self {
         folder.fold_const(self)
     }
 }
             | ConstKind::Placeholder(_)
             | ConstKind::Error(_) => return Ok(self),
         };
-        if kind != self.kind() {
-            Ok(Const::new(folder.cx(), kind))
-        } else {
-            Ok(self)
-        }
+        if kind != self.kind() { Ok(Const::new(folder.cx(), kind)) } else { Ok(self) }
     }
+
     fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
         self,
         folder: &mut F,
             | ConstKind::Placeholder(_)
             | ConstKind::Error(_) => return self,
         };
-        if kind != self.kind() {
-            Const::new(folder.cx(), kind)
-        } else {
-            self
-        }
+        if kind != self.kind() { Const::new(folder.cx(), kind) } else { self }
     }
 }
 
 }
 
 impl<'db> rustc_type_ir::inherent::Const<DbInterner<'db>> for Const<'db> {
-    fn new_infer(interner: DbInterner<'db>, var: InferConst) -> Self {
+    fn new_infer(
+        interner: DbInterner<'db>,
+        var: InferConst,
+    ) -> Self {
         Const::new(interner, ConstKind::Infer(var))
     }
 
-    fn new_var(interner: DbInterner<'db>, var: ConstVid) -> Self {
+    fn new_var(
+        interner: DbInterner<'db>,
+        var: ConstVid,
+    ) -> Self {
         Const::new(interner, ConstKind::Infer(InferConst::Var(var)))
     }
 
-    fn new_bound(interner: DbInterner<'db>, debruijn: DebruijnIndex, var: BoundConst) -> Self {
-        Const::new(
-            interner,
-            ConstKind::Bound(BoundVarIndexKind::Bound(debruijn), var),
-        )
+    fn new_bound(
+        interner: DbInterner<'db>,
+        debruijn: DebruijnIndex,
+        var: BoundConst,
+    ) -> Self {
+        Const::new(interner, ConstKind::Bound(BoundVarIndexKind::Bound(debruijn), var))
     }
 
-    fn new_anon_bound(interner: DbInterner<'db>, debruijn: DebruijnIndex, var: BoundVar) -> Self {
+    fn new_anon_bound(
+        interner: DbInterner<'db>,
+        debruijn: DebruijnIndex,
+        var: BoundVar,
+    ) -> Self {
         Const::new(
             interner,
             ConstKind::Bound(BoundVarIndexKind::Bound(debruijn), BoundConst { var }),
         )
     }
 
-    fn new_canonical_bound(interner: DbInterner<'db>, var: BoundVar) -> Self {
-        Const::new(
-            interner,
-            ConstKind::Bound(BoundVarIndexKind::Canonical, BoundConst { var }),
-        )
+    fn new_canonical_bound(
+        interner: DbInterner<'db>,
+        var: BoundVar,
+    ) -> Self {
+        Const::new(interner, ConstKind::Bound(BoundVarIndexKind::Canonical, BoundConst { var }))
     }
 
     fn new_placeholder(
         Const::new(interner, ConstKind::Unevaluated(uv))
     }
 
-    fn new_expr(interner: DbInterner<'db>, expr: ExprConst) -> Self {
+    fn new_expr(
+        interner: DbInterner<'db>,
+        expr: ExprConst,
+    ) -> Self {
         Const::new(interner, ConstKind::Expr(expr))
     }
 
-    fn new_error(interner: DbInterner<'db>, guar: ErrorGuaranteed) -> Self {
+    fn new_error(
+        interner: DbInterner<'db>,
+        guar: ErrorGuaranteed,
+    ) -> Self {
         Const::new(interner, ConstKind::Error(guar))
     }
 }
         self.var
     }
 
-    fn assert_eq(self, var: BoundVarKind) {
+    fn assert_eq(
+        self,
+        var: BoundVarKind,
+    ) {
         var.expect_const()
     }
 }
         self.bound.var
     }
 
-    fn with_updated_universe(self, ui: rustc_type_ir::UniverseIndex) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: self.bound,
-        }
+    fn with_updated_universe(
+        self,
+        ui: rustc_type_ir::UniverseIndex,
+    ) -> Self {
+        Placeholder { universe: ui, bound: self.bound }
     }
 
-    fn new(ui: rustc_type_ir::UniverseIndex, var: BoundConst) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: var,
-        }
+    fn new(
+        ui: rustc_type_ir::UniverseIndex,
+        var: BoundConst,
+    ) -> Self {
+        Placeholder { universe: ui, bound: var }
     }
-    fn new_anon(ui: rustc_type_ir::UniverseIndex, var: rustc_type_ir::BoundVar) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: BoundConst { var },
-        }
+
+    fn new_anon(
+        ui: rustc_type_ir::UniverseIndex,
+        var: rustc_type_ir::BoundVar,
+    ) -> Self {
+        Placeholder { universe: ui, bound: BoundConst { var } }
     }
 }
 