COMPARISON DIFF
============================================================

Original size: 14262 bytes
Chloro size:   14469 bytes
Rustfmt size:  14546 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     next_solver::{interner::InternedWrapperNoDebug, ClauseKind, ParamEnv},
     MemoryMap,
 };
-
 use super::{BoundVarKind, DbInterner, ErrorGuaranteed, GenericArgs, Placeholder, Ty};
 
 pub type ConstKind<'db> = rustc_type_ir::ConstKind<DbInterner<'db>>;
+
 pub type UnevaluatedConst<'db> = rustc_type_ir::UnevaluatedConst<DbInterner<'db>>;
 
 #[salsa::interned(constructor = new_)]
     }
 
     pub fn inner(&self) -> &WithCachedTypeInfo<ConstKind<'db>> {
-        crate::with_attached_db(|db| {
+        crate::with_attached_db(
+            |db| {
             let inner = &self.kind_(db).0;
             // SAFETY: The caller already has access to a `Const<'db>`, so borrowchecking will
             // make sure that our returned value is valid for the lifetime `'db`.
             unsafe { std::mem::transmute(inner) }
-        })
+        },
+        )
     }
 
     pub fn error(interner: DbInterner<'db>) -> Self {
     }
 
     pub fn new_bound(interner: DbInterner<'db>, index: DebruijnIndex, bound: BoundConst) -> Self {
-        Const::new(
-            interner,
-            ConstKind::Bound(BoundVarIndexKind::Bound(index), bound),
-        )
+        Const::new(interner, ConstKind::Bound(BoundVarIndexKind::Bound(index), bound))
     }
 
     pub fn new_valtree(
     ) -> Self {
         Const::new(
             interner,
-            ConstKind::Value(ValueConst {
+            ConstKind::Value(
+                ValueConst {
                 ty,
                 value: Valtree::new(ConstBytes { memory, memory_map }),
-            }),
+            },
+            ),
         )
     }
 
         });
 
         // N.B. it may be tempting to fix ICEs by making this function return
+
         // `Option<Ty<'db>>` instead of `Ty<'db>`; however, this is generally
+
         // considered to be a bandaid solution, since it hides more important
+
         // underlying issues with how we construct generics and predicates of
+
         // items. It's advised to fix the underlying issue rather than trying
+
         // to modify this function.
         let ty = candidates.next().unwrap_or_else(|| {
             panic!("cannot find `{self:?}` in param-env: {env:#?}");
 
 impl<'db> Valtree<'db> {
     pub fn new(bytes: ConstBytes<'db>) -> Self {
-        crate::with_attached_db(|db| unsafe {
+        crate::with_attached_db(
+            |db| unsafe {
             // SAFETY: ¯\_(ツ)_/¯
             std::mem::transmute(Valtree::new_(db, bytes))
-        })
+        },
+        )
     }
 
     pub fn inner(&self) -> &ConstBytes<'db> {
-        crate::with_attached_db(|db| {
+        crate::with_attached_db(
+            |db| {
             let inner = self.bytes_(db);
             // SAFETY: The caller already has access to a `Valtree<'db>`, so borrowchecking will
             // make sure that our returned value is valid for the lifetime `'db`.
             unsafe { std::mem::transmute(inner) }
-        })
+        },
+        )
     }
 }
 
     ) -> Result<Self, F::Error> {
         folder.try_fold_const(self)
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         folder.fold_const(self)
     }
             | ConstKind::Placeholder(_)
             | ConstKind::Error(_) => return Ok(self),
         };
-        if kind != self.kind() {
-            Ok(Const::new(folder.cx(), kind))
-        } else {
-            Ok(self)
-        }
+        if kind != self.kind() { Ok(Const::new(folder.cx(), kind)) } else { Ok(self) }
     }
+
     fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
         self,
         folder: &mut F,
             | ConstKind::Placeholder(_)
             | ConstKind::Error(_) => return self,
         };
-        if kind != self.kind() {
-            Const::new(folder.cx(), kind)
-        } else {
-            self
-        }
+        if kind != self.kind() { Const::new(folder.cx(), kind) } else { self }
     }
 }
 
     }
 
     fn new_bound(interner: DbInterner<'db>, debruijn: DebruijnIndex, var: BoundConst) -> Self {
-        Const::new(
-            interner,
-            ConstKind::Bound(BoundVarIndexKind::Bound(debruijn), var),
-        )
+        Const::new(interner, ConstKind::Bound(BoundVarIndexKind::Bound(debruijn), var))
     }
 
     fn new_anon_bound(interner: DbInterner<'db>, debruijn: DebruijnIndex, var: BoundVar) -> Self {
     }
 
     fn new_canonical_bound(interner: DbInterner<'db>, var: BoundVar) -> Self {
-        Const::new(
-            interner,
-            ConstKind::Bound(BoundVarIndexKind::Canonical, BoundConst { var }),
-        )
+        Const::new(interner, ConstKind::Bound(BoundVarIndexKind::Canonical, BoundConst { var }))
     }
 
     fn new_placeholder(
             bound: var,
         }
     }
+
     fn new_anon(ui: rustc_type_ir::UniverseIndex, var: rustc_type_ir::BoundVar) -> Self {
         Placeholder {
             universe: ui,