COMPARISON DIFF
============================================================

Original size: 20827 bytes
Chloro size:   21094 bytes
Rustfmt size:  21200 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
                 Ok(relation.relate(a_ct, b_ct)?.into())
             }
             (GenericArgKind::Lifetime(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
             (GenericArgKind::Type(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
             (GenericArgKind::Const(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
         }
     }
 
 interned_vec_db!(GenericArgs, GenericArg);
 
-impl<'db> rustc_type_ir::inherent::GenericArg<DbInterner<'db>> for GenericArg<'db> {}
+impl<'db> rustc_type_ir::inherent::GenericArg<DbInterner<'db>> for GenericArg<'db> {
+}
 
 impl<'db> GenericArgs<'db> {
     /// Creates an `GenericArgs` for generic parameter definitions,
 
     /// Creates an all-error `GenericArgs`.
     pub fn error_for_item(interner: DbInterner<'db>, def_id: SolverDefId) -> GenericArgs<'db> {
-        GenericArgs::for_item(interner, def_id, |_, id, _| {
-            GenericArg::error_from_id(interner, id)
-        })
+        GenericArgs::for_item(interner, def_id, |_, id, _| GenericArg::error_from_id(interner, id))
     }
 
     /// Like `for_item`, but prefers the default of a parameter if it has any.
         F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
     {
         let defaults = interner.db.generic_defaults(def_id);
-        Self::for_item(interner, def_id.into(), |idx, id, prev| {
-            match defaults.get(idx as usize) {
-                Some(default) => default.instantiate(interner, prev),
-                None => fallback(idx, id, prev),
-            }
-        })
+        Self::for_item(
+            interner,
+            def_id.into(),
+            |idx, id, prev| match defaults.get(idx as usize) {
+            Some(default) => default.instantiate(interner, prev),
+            None => fallback(idx, id, prev),
+        },
+        )
     }
 
     /// Like `for_item()`, but calls first uses the args from `first`.
         F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
     {
         let mut iter = first.into_iter();
-        Self::for_item(interner, def_id, |idx, id, prev| {
+        Self::for_item(
+            interner,
+            def_id,
+            |idx, id, prev| {
             iter.next().unwrap_or_else(|| fallback(idx, id, prev))
-        })
+        },
+        )
     }
 
     /// Appends default param values to `first` if needed. Params without default will call `fallback()`.
         F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
     {
         let defaults = interner.db.generic_defaults(def_id);
-        Self::fill_rest(interner, def_id.into(), first, |idx, id, prev| {
+        Self::fill_rest(
+            interner,
+            def_id.into(),
+            first,
+            |idx, id, prev| {
             defaults
                 .get(idx as usize)
                 .map(|default| default.instantiate(interner, prev))
                 .unwrap_or_else(|| fallback(idx, id, prev))
-        })
+        },
+        )
     }
 
     fn fill_item<F>(
         interner: DbInterner<'_>,
         defs: Generics,
         mk_kind: &mut F,
-    ) where
+    )
+    where
         F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
     {
         if let Some(def_id) = defs.parent {
         Self::fill_single(args, &defs, mk_kind);
     }
 
-    fn fill_single<F>(args: &mut SmallVec<[GenericArg<'db>; 8]>, defs: &Generics, mk_kind: &mut F)
+    fn fill_single<F>(
+        args: &mut SmallVec<[GenericArg<'db>; 8]>,
+        defs: &Generics,
+        mk_kind: &mut F,
+    )
     where
         F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
     {
     }
 
     pub fn closure_sig_untupled(self) -> PolyFnSig<'db> {
-        let TyKind::FnPtr(inputs_and_output, hdr) = self
-            .split_closure_args_untupled()
-            .closure_sig_as_fn_ptr_ty
-            .kind()
+        let TyKind::FnPtr(inputs_and_output, hdr) =
+            self.split_closure_args_untupled().closure_sig_as_fn_ptr_ty.kind()
         else {
             unreachable!("not a function pointer")
         };
     fn as_closure(self) -> ClosureArgs<DbInterner<'db>> {
         ClosureArgs { args: self }
     }
+
     fn as_coroutine(self) -> CoroutineArgs<DbInterner<'db>> {
         CoroutineArgs { args: self }
     }
+
     fn as_coroutine_closure(self) -> CoroutineClosureArgs<DbInterner<'db>> {
         CoroutineClosureArgs { args: self }
     }
+
     fn rebase_onto(
         self,
         interner: DbInterner<'db>,
         interner: DbInterner<'db>,
         def_id: <DbInterner<'db> as rustc_type_ir::Interner>::DefId,
     ) -> <DbInterner<'db> as rustc_type_ir::Interner>::GenericArgs {
-        Self::for_item(interner, def_id, |index, kind, _| {
-            mk_param(interner, index, kind)
-        })
+        Self::for_item(interner, def_id, |index, kind, _| mk_param(interner, index, kind))
     }
 
     fn extend_with_error(
         def_id: <DbInterner<'db> as rustc_type_ir::Interner>::DefId,
         original_args: &[<DbInterner<'db> as rustc_type_ir::Interner>::GenericArg],
     ) -> <DbInterner<'db> as rustc_type_ir::Interner>::GenericArgs {
-        Self::for_item(interner, def_id, |index, kind, _| {
+        Self::for_item(
+            interner,
+            def_id,
+            |index, kind, _| {
             if let Some(arg) = original_args.get(index as usize) {
                 *arg
             } else {
                 error_for_param_kind(kind, interner)
             }
-        })
+        },
+        )
     }
+
     fn type_at(self, i: usize) -> <DbInterner<'db> as rustc_type_ir::Interner>::Ty {
         self.inner()
             .get(i)
         // FIXME: should use `ClosureSubst` when possible
         match self.inner().as_slice() {
             [parent_args @ .., closure_kind_ty, sig_ty, tupled_upvars_ty] => {
-                let interner = DbInterner::conjure();
                 // This is stupid, but the next solver expects the first input to actually be a tuple
+                let interner = DbInterner::conjure();
                 let sig_ty = match sig_ty.expect_ty().kind() {
                     TyKind::FnPtr(sig_tys, header) => Ty::new(
                         interner,
         self,
     ) -> rustc_type_ir::CoroutineClosureArgsParts<DbInterner<'db>> {
         match self.inner().as_slice() {
-            [parent_args @ .., closure_kind_ty, signature_parts_ty, tupled_upvars_ty, coroutine_captures_by_ref_ty] => {
-                rustc_type_ir::CoroutineClosureArgsParts {
-                    parent_args: GenericArgs::new_from_iter(
-                        DbInterner::conjure(),
-                        parent_args.iter().cloned(),
-                    ),
-                    closure_kind_ty: closure_kind_ty.expect_ty(),
-                    signature_parts_ty: signature_parts_ty.expect_ty(),
-                    tupled_upvars_ty: tupled_upvars_ty.expect_ty(),
-                    coroutine_captures_by_ref_ty: coroutine_captures_by_ref_ty.expect_ty(),
-                }
-            }
+            [
+                parent_args @ ..,
+                closure_kind_ty,
+                signature_parts_ty,
+                tupled_upvars_ty,
+                coroutine_captures_by_ref_ty,
+            ] => rustc_type_ir::CoroutineClosureArgsParts {
+                parent_args: GenericArgs::new_from_iter(
+                    DbInterner::conjure(),
+                    parent_args.iter().cloned(),
+                ),
+                closure_kind_ty: closure_kind_ty.expect_ty(),
+                signature_parts_ty: signature_parts_ty.expect_ty(),
+                tupled_upvars_ty: tupled_upvars_ty.expect_ty(),
+                coroutine_captures_by_ref_ty: coroutine_captures_by_ref_ty.expect_ty(),
+            },
             _ => panic!("GenericArgs were likely not for a CoroutineClosure."),
         }
     }
     }
 }
 
-pub fn mk_param<'db>(interner: DbInterner<'db>, index: u32, id: GenericParamId) -> GenericArg<'db> {
+pub fn mk_param<'db>(
+    interner: DbInterner<'db>,
+    index: u32,
+    id: GenericParamId,
+) -> GenericArg<'db> {
     match id {
         GenericParamId::LifetimeParamId(id) => {
             Region::new_early_param(interner, EarlyParamRegion { index, id }).into()
     }
 }
 
-pub fn error_for_param_kind<'db>(id: GenericParamId, interner: DbInterner<'db>) -> GenericArg<'db> {
+pub fn error_for_param_kind<'db>(
+    id: GenericParamId,
+    interner: DbInterner<'db>,
+) -> GenericArg<'db> {
     match id {
         GenericParamId::LifetimeParamId(_) => Region::error(interner).into(),
         GenericParamId::TypeParamId(_) => Ty::new_error(interner, ErrorGuaranteed).into(),
                 Ok(relation.relate(a_ct, b_ct)?.into())
             }
             (TermKind::Ty(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
             (TermKind::Const(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
         }
     }
 }
 
-impl<'db> rustc_type_ir::inherent::Term<DbInterner<'db>> for Term<'db> {}
+impl<'db> rustc_type_ir::inherent::Term<DbInterner<'db>> for Term<'db> {
+}
 
 #[derive(Clone, Eq, PartialEq, Debug)]
 pub enum TermVid {