COMPARISON DIFF
============================================================

Original size: 20827 bytes
Chloro size:   21035 bytes
Rustfmt size:  21200 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Things related to generic args in the next-trait-solver.
 
 use hir_def::{GenericDefId, GenericParamId};
 use macros::{TypeFoldable, TypeVisitable};
 use rustc_type_ir::{
-    inherent::{GenericArg as _, GenericsOf, IntoKind, SliceLike, Term as _, Ty as _},
-    relate::{Relate, VarianceDiagInfo},
     ClosureArgs, CollectAndApply, ConstVid, CoroutineArgs, CoroutineClosureArgs, FnSigTys,
     GenericArgKind, Interner, TermKind, TyKind, TyVid, Variance,
+    inherent::{GenericArg as _, GenericsOf, IntoKind, SliceLike, Term as _, Ty as _},
+    relate::{Relate, VarianceDiagInfo},
 };
 use smallvec::SmallVec;
 
-use crate::next_solver::{interned_vec_db, PolyFnSig};
-
+use crate::next_solver::{PolyFnSig, interned_vec_db};
 use super::{
-    generics::Generics, Const, DbInterner, EarlyParamRegion, ErrorGuaranteed, ParamConst, Region,
-    SolverDefId, Ty, Tys,
+    Const, DbInterner, EarlyParamRegion, ErrorGuaranteed, ParamConst, Region, SolverDefId, Ty, Tys,
+    generics::Generics,
 };
 
 #[derive(Copy, Clone, PartialEq, Eq, Hash, TypeVisitable, TypeFoldable)]
 }
 
 impl<'db> std::fmt::Debug for GenericArg<'db> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         match self {
             Self::Ty(t) => std::fmt::Debug::fmt(t, f),
             Self::Lifetime(r) => std::fmt::Debug::fmt(r, f),
         }
     }
 
-    pub fn error_from_id(interner: DbInterner<'db>, id: GenericParamId) -> GenericArg<'db> {
+    pub fn error_from_id(
+        interner: DbInterner<'db>,
+        id: GenericParamId,
+    ) -> GenericArg<'db> {
         match id {
             GenericParamId::TypeParamId(_) => Ty::new_error(interner, ErrorGuaranteed).into(),
             GenericParamId::ConstParamId(_) => Const::error(interner).into(),
 }
 
 impl<'db> std::fmt::Debug for Term<'db> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         match self {
             Self::Ty(t) => std::fmt::Debug::fmt(t, f),
             Self::Const(c) => std::fmt::Debug::fmt(c, f),
         self.as_type().expect("expected a type, but found a const")
     }
 
-    pub fn is_trivially_wf(&self, tcx: DbInterner<'db>) -> bool {
+    pub fn is_trivially_wf(
+        &self,
+        tcx: DbInterner<'db>,
+    ) -> bool {
         match self.kind() {
             TermKind::Ty(ty) => ty.is_trivially_wf(tcx),
             TermKind::Const(ct) => ct.is_trivially_wf(),
                 Ok(relation.relate(a_ct, b_ct)?.into())
             }
             (GenericArgKind::Lifetime(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
             (GenericArgKind::Type(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
             (GenericArgKind::Const(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
         }
     }
 }
-
-interned_vec_db!(GenericArgs, GenericArg);
-
-impl<'db> rustc_type_ir::inherent::GenericArg<DbInterner<'db>> for GenericArg<'db> {}
+impl<'db> rustc_type_ir::inherent::GenericArg<DbInterner<'db>> for GenericArg<'db> {
+}
 
 impl<'db> GenericArgs<'db> {
     /// Creates an `GenericArgs` for generic parameter definitions,
         mut mk_kind: F,
     ) -> GenericArgs<'db>
     where
-        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
-    {
+        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>, {
         let defs = interner.generics_of(def_id);
         let count = defs.count();
         let mut args = SmallVec::with_capacity(count);
     }
 
     /// Creates an all-error `GenericArgs`.
-    pub fn error_for_item(interner: DbInterner<'db>, def_id: SolverDefId) -> GenericArgs<'db> {
-        GenericArgs::for_item(interner, def_id, |_, id, _| {
-            GenericArg::error_from_id(interner, id)
-        })
+    pub fn error_for_item(
+        interner: DbInterner<'db>,
+        def_id: SolverDefId,
+    ) -> GenericArgs<'db> {
+        GenericArgs::for_item(interner, def_id, |_, id, _| GenericArg::error_from_id(interner, id))
     }
 
     /// Like `for_item`, but prefers the default of a parameter if it has any.
         mut fallback: F,
     ) -> GenericArgs<'db>
     where
-        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
-    {
+        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>, {
         let defaults = interner.db.generic_defaults(def_id);
-        Self::for_item(interner, def_id.into(), |idx, id, prev| {
-            match defaults.get(idx as usize) {
-                Some(default) => default.instantiate(interner, prev),
-                None => fallback(idx, id, prev),
-            }
+        Self::for_item(interner, def_id.into(), |idx, id, prev| match defaults.get(idx as usize) {
+            Some(default) => default.instantiate(interner, prev),
+            None => fallback(idx, id, prev),
         })
     }
 
         mut fallback: F,
     ) -> GenericArgs<'db>
     where
-        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
-    {
+        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>, {
         let mut iter = first.into_iter();
         Self::for_item(interner, def_id, |idx, id, prev| {
             iter.next().unwrap_or_else(|| fallback(idx, id, prev))
         mut fallback: F,
     ) -> GenericArgs<'db>
     where
-        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
-    {
+        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>, {
         let defaults = interner.db.generic_defaults(def_id);
         Self::fill_rest(interner, def_id.into(), first, |idx, id, prev| {
             defaults
         interner: DbInterner<'_>,
         defs: Generics,
         mk_kind: &mut F,
-    ) where
-        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
-    {
+    )
+    where
+        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>, {
         if let Some(def_id) = defs.parent {
             let parent_defs = interner.generics_of(def_id.into());
             Self::fill_item(args, interner, parent_defs, mk_kind);
         Self::fill_single(args, &defs, mk_kind);
     }
 
-    fn fill_single<F>(args: &mut SmallVec<[GenericArg<'db>; 8]>, defs: &Generics, mk_kind: &mut F)
+    fn fill_single<F>(
+        args: &mut SmallVec<[GenericArg<'db>; 8]>,
+        defs: &Generics,
+        mk_kind: &mut F,
+    )
     where
-        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>,
-    {
+        F: FnMut(u32, GenericParamId, &[GenericArg<'db>]) -> GenericArg<'db>, {
         args.reserve(defs.own_params.len());
         for param in &defs.own_params {
             let kind = mk_kind(args.len() as u32, param.id, args);
     }
 
     pub fn closure_sig_untupled(self) -> PolyFnSig<'db> {
-        let TyKind::FnPtr(inputs_and_output, hdr) = self
-            .split_closure_args_untupled()
-            .closure_sig_as_fn_ptr_ty
-            .kind()
+        let TyKind::FnPtr(inputs_and_output, hdr) =
+            self.split_closure_args_untupled().closure_sig_as_fn_ptr_ty.kind()
         else {
             unreachable!("not a function pointer")
         };
     fn as_closure(self) -> ClosureArgs<DbInterner<'db>> {
         ClosureArgs { args: self }
     }
+
     fn as_coroutine(self) -> CoroutineArgs<DbInterner<'db>> {
         CoroutineArgs { args: self }
     }
+
     fn as_coroutine_closure(self) -> CoroutineClosureArgs<DbInterner<'db>> {
         CoroutineClosureArgs { args: self }
     }
+
     fn rebase_onto(
         self,
         interner: DbInterner<'db>,
         interner: DbInterner<'db>,
         def_id: <DbInterner<'db> as rustc_type_ir::Interner>::DefId,
     ) -> <DbInterner<'db> as rustc_type_ir::Interner>::GenericArgs {
-        Self::for_item(interner, def_id, |index, kind, _| {
-            mk_param(interner, index, kind)
-        })
+        Self::for_item(interner, def_id, |index, kind, _| mk_param(interner, index, kind))
     }
 
     fn extend_with_error(
             }
         })
     }
-    fn type_at(self, i: usize) -> <DbInterner<'db> as rustc_type_ir::Interner>::Ty {
+
+    fn type_at(
+        self,
+        i: usize,
+    ) -> <DbInterner<'db> as rustc_type_ir::Interner>::Ty {
         self.inner()
             .get(i)
             .and_then(|g| g.as_type())
             .unwrap_or_else(|| Ty::new_error(DbInterner::conjure(), ErrorGuaranteed))
     }
 
-    fn region_at(self, i: usize) -> <DbInterner<'db> as rustc_type_ir::Interner>::Region {
+    fn region_at(
+        self,
+        i: usize,
+    ) -> <DbInterner<'db> as rustc_type_ir::Interner>::Region {
         self.inner()
             .get(i)
             .and_then(|g| g.as_region())
             .unwrap_or_else(|| Region::error(DbInterner::conjure()))
     }
 
-    fn const_at(self, i: usize) -> <DbInterner<'db> as rustc_type_ir::Interner>::Const {
+    fn const_at(
+        self,
+        i: usize,
+    ) -> <DbInterner<'db> as rustc_type_ir::Interner>::Const {
         self.inner()
             .get(i)
             .and_then(|g| g.as_const())
         }
     }
 
-    fn split_coroutine_closure_args(
-        self,
-    ) -> rustc_type_ir::CoroutineClosureArgsParts<DbInterner<'db>> {
+    fn split_coroutine_closure_args(self) -> rustc_type_ir::CoroutineClosureArgsParts<DbInterner<'db>> {
         match self.inner().as_slice() {
-            [parent_args @ .., closure_kind_ty, signature_parts_ty, tupled_upvars_ty, coroutine_captures_by_ref_ty] => {
-                rustc_type_ir::CoroutineClosureArgsParts {
-                    parent_args: GenericArgs::new_from_iter(
-                        DbInterner::conjure(),
-                        parent_args.iter().cloned(),
-                    ),
-                    closure_kind_ty: closure_kind_ty.expect_ty(),
-                    signature_parts_ty: signature_parts_ty.expect_ty(),
-                    tupled_upvars_ty: tupled_upvars_ty.expect_ty(),
-                    coroutine_captures_by_ref_ty: coroutine_captures_by_ref_ty.expect_ty(),
-                }
-            }
+            [
+                parent_args @ ..,
+                closure_kind_ty,
+                signature_parts_ty,
+                tupled_upvars_ty,
+                coroutine_captures_by_ref_ty,
+            ] => rustc_type_ir::CoroutineClosureArgsParts {
+                parent_args: GenericArgs::new_from_iter(
+                    DbInterner::conjure(),
+                    parent_args.iter().cloned(),
+                ),
+                closure_kind_ty: closure_kind_ty.expect_ty(),
+                signature_parts_ty: signature_parts_ty.expect_ty(),
+                tupled_upvars_ty: tupled_upvars_ty.expect_ty(),
+                coroutine_captures_by_ref_ty: coroutine_captures_by_ref_ty.expect_ty(),
+            },
             _ => panic!("GenericArgs were likely not for a CoroutineClosure."),
         }
     }
     }
 }
 
-pub fn mk_param<'db>(interner: DbInterner<'db>, index: u32, id: GenericParamId) -> GenericArg<'db> {
+pub fn mk_param<'db>(
+    interner: DbInterner<'db>,
+    index: u32,
+    id: GenericParamId,
+) -> GenericArg<'db> {
     match id {
         GenericParamId::LifetimeParamId(id) => {
             Region::new_early_param(interner, EarlyParamRegion { index, id }).into()
     }
 }
 
-pub fn error_for_param_kind<'db>(id: GenericParamId, interner: DbInterner<'db>) -> GenericArg<'db> {
+pub fn error_for_param_kind<'db>(
+    id: GenericParamId,
+    interner: DbInterner<'db>,
+) -> GenericArg<'db> {
     match id {
         GenericParamId::LifetimeParamId(_) => Region::error(interner).into(),
         GenericParamId::TypeParamId(_) => Ty::new_error(interner, ErrorGuaranteed).into(),
                 Ok(relation.relate(a_ct, b_ct)?.into())
             }
             (TermKind::Ty(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
             (TermKind::Const(unpacked), x) => {
-                unreachable!(
-                    "impossible case reached: can't relate: {:?} with {:?}",
-                    unpacked, x
-                )
+                unreachable!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
             }
         }
     }
 }
 
-impl<'db> rustc_type_ir::inherent::Term<DbInterner<'db>> for Term<'db> {}
+impl<'db> rustc_type_ir::inherent::Term<DbInterner<'db>> for Term<'db> {
+}
 
 #[derive(Clone, Eq, PartialEq, Debug)]
 pub enum TermVid {
 }
 
 impl<'db> DbInterner<'db> {
-    pub(super) fn mk_args(self, args: &[GenericArg<'db>]) -> GenericArgs<'db> {
+    pub(super) fn mk_args(
+        self,
+        args: &[GenericArg<'db>],
+    ) -> GenericArgs<'db> {
         GenericArgs::new_from_iter(self, args.iter().cloned())
     }
 
-    pub(super) fn mk_args_from_iter<I, T>(self, iter: I) -> T::Output
+    pub(super) fn mk_args_from_iter<I, T>(
+        self,
+        iter: I,
+    ) -> T::Output
     where
         I: Iterator<Item = T>,
-        T: rustc_type_ir::CollectAndApply<GenericArg<'db>, GenericArgs<'db>>,
-    {
+        T: rustc_type_ir::CollectAndApply<GenericArg<'db>, GenericArgs<'db>>, {
         T::collect_and_apply(iter, |xs| self.mk_args(xs))
     }
 }