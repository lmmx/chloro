COMPARISON DIFF
============================================================

Original size: 6415 bytes
Chloro size:   6220 bytes
Rustfmt size:  6524 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Type inhabitedness logic.
+
 use std::ops::ControlFlow::{self, Break, Continue};
 
-use hir_def::{visibility::Visibility, AdtId, EnumVariantId, ModuleId, VariantId};
+use hir_def::{AdtId, EnumVariantId, ModuleId, VariantId, visibility::Visibility};
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
     inherent::{AdtDef, IntoKind},
     consteval::try_const_usize,
     db::HirDatabase,
     next_solver::{
-        infer::{traits::ObligationCause, InferCtxt},
-        obligation_ctxt::ObligationCtxt,
-        DbInterner, EarlyBinder, GenericArgs, Ty, TyKind,
+        infer::{InferCtxt, traits::ObligationCause}, obligation_ctxt::ObligationCtxt, DbInterner,
+        EarlyBinder, GenericArgs, Ty, TyKind,
     },
     TraitEnvironment,
 };
 
-// FIXME: Turn this into a query, it can be quite slow
 /// Checks whether a type is visibly uninhabited from a particular module.
 pub(crate) fn is_ty_uninhabited_from<'db>(
     infcx: &InferCtxt<'db>,
     inhabitedness == BREAK_VISIBLY_UNINHABITED
 }
 
-// FIXME: Turn this into a query, it can be quite slow
 /// Checks whether a variant is visibly uninhabited from a particular module.
 pub(crate) fn is_enum_variant_uninhabited_from<'db>(
     infcx: &InferCtxt<'db>,
 struct UninhabitedFrom<'a, 'db> {
     target_mod: ModuleId,
     recursive_ty: FxHashSet<Ty<'db>>,
-    // guard for preventing stack overflow in non trivial non terminating types
     max_depth: usize,
     infcx: &'a InferCtxt<'db>,
     env: Arc<TraitEnvironment<'db>>,
 }
 
 const CONTINUE_OPAQUELY_INHABITED: ControlFlow<VisiblyUninhabited> = Continue(());
+
 const BREAK_VISIBLY_UNINHABITED: ControlFlow<VisiblyUninhabited> = Break(VisiblyUninhabited);
+
 #[derive(PartialEq, Eq)]
 struct VisiblyUninhabited;
 
         target_mod: ModuleId,
         env: Arc<TraitEnvironment<'db>>,
     ) -> Self {
-        Self {
-            target_mod,
-            recursive_ty: FxHashSet::default(),
-            max_depth: 500,
-            infcx,
-            env,
-        }
+        Self { target_mod, recursive_ty: FxHashSet::default(), max_depth: 500, infcx, env }
     }
 
     #[inline]
 
         let is_enum = matches!(variant, VariantId::EnumVariantId(..));
         let field_tys = self.db().field_types(variant);
-        let field_vis = if is_enum {
-            None
-        } else {
-            Some(self.db().field_visibilities(variant))
-        };
+        let field_vis = if is_enum { None } else { Some(self.db().field_visibilities(variant)) };
 
         for (fid, _) in fields.iter() {
             self.visit_field(field_vis.as_ref().map(|it| it[fid]), &field_tys[fid], subst)?;