COMPARISON DIFF
============================================================

Original size: 6415 bytes
Chloro size:   6225 bytes
Rustfmt size:  6524 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Type inhabitedness logic.
+
 use std::ops::ControlFlow::{self, Break, Continue};
 
 use hir_def::{visibility::Visibility, AdtId, EnumVariantId, ModuleId, VariantId};
     consteval::try_const_usize,
     db::HirDatabase,
     next_solver::{
-        infer::{traits::ObligationCause, InferCtxt},
-        obligation_ctxt::ObligationCtxt,
-        DbInterner, EarlyBinder, GenericArgs, Ty, TyKind,
+        infer::{InferCtxt, traits::ObligationCause}, obligation_ctxt::ObligationCtxt, DbInterner,
+        EarlyBinder, GenericArgs, Ty, TyKind,
     },
     TraitEnvironment,
 };
 
-// FIXME: Turn this into a query, it can be quite slow
 /// Checks whether a type is visibly uninhabited from a particular module.
 pub(crate) fn is_ty_uninhabited_from<'db>(
     infcx: &InferCtxt<'db>,
     inhabitedness == BREAK_VISIBLY_UNINHABITED
 }
 
-// FIXME: Turn this into a query, it can be quite slow
 /// Checks whether a variant is visibly uninhabited from a particular module.
 pub(crate) fn is_enum_variant_uninhabited_from<'db>(
     infcx: &InferCtxt<'db>,
 }
 
 const CONTINUE_OPAQUELY_INHABITED: ControlFlow<VisiblyUninhabited> = Continue(());
+
 const BREAK_VISIBLY_UNINHABITED: ControlFlow<VisiblyUninhabited> = Break(VisiblyUninhabited);
+
 #[derive(PartialEq, Eq)]
 struct VisiblyUninhabited;
 
         target_mod: ModuleId,
         env: Arc<TraitEnvironment<'db>>,
     ) -> Self {
-        Self {
-            target_mod,
-            recursive_ty: FxHashSet::default(),
-            max_depth: 500,
-            infcx,
-            env,
-        }
+        Self { target_mod, recursive_ty: FxHashSet::default(), max_depth: 500, infcx, env }
     }
 
     #[inline]
     ) -> ControlFlow<VisiblyUninhabited> {
         // An ADT is uninhabited iff all its variants uninhabited.
         match adt {
-            // rustc: For now, `union`s are never considered uninhabited.
             AdtId::UnionId(_) => CONTINUE_OPAQUELY_INHABITED,
             AdtId::StructId(s) => self.visit_variant(s.into(), subst),
             AdtId::EnumId(e) => {
                 let enum_data = e.enum_variants(self.db());
-
                 for &(variant, _, _) in enum_data.variants.iter() {
                     let variant_inhabitedness = self.visit_variant(variant.into(), subst);
                     match variant_inhabitedness {
 
         let is_enum = matches!(variant, VariantId::EnumVariantId(..));
         let field_tys = self.db().field_types(variant);
-        let field_vis = if is_enum {
-            None
-        } else {
-            Some(self.db().field_visibilities(variant))
-        };
+        let field_vis = if is_enum { None } else { Some(self.db().field_visibilities(variant)) };
 
         for (fid, _) in fields.iter() {
             self.visit_field(field_vis.as_ref().map(|it| it[fid]), &field_tys[fid], subst)?;