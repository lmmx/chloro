COMPARISON DIFF
============================================================

Original size: 10884 bytes
Chloro size:   10930 bytes
Rustfmt size:  11524 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! - Type or Const parameters
 //!
 //! where parent follows the same scheme.
+
 use std::ops;
 
 use hir_def::{
     db::DefDatabase,
+
     expr_store::ExpressionStore,
+
     hir::generics::{
-        GenericParamDataRef, GenericParams, LifetimeParamData, LocalLifetimeParamId,
-        LocalTypeOrConstParamId, TypeOrConstParamData, TypeParamProvenance, WherePredicate,
-    },
-    ConstParamId, GenericDefId, GenericParamId, ItemContainerId, LifetimeParamId, Lookup,
-    TypeOrConstParamId, TypeParamId,
+        GenericParamDataRef,
+
+    ConstParamId, GenericDefId, GenericParamId, GenericParams, ItemContainerId, LifetimeParamData,
+    LifetimeParamId, LocalLifetimeParamId, LocalTypeOrConstParamId, Lookup, TypeOrConstParamData,
+    TypeOrConstParamId, TypeParamId, TypeParamProvenance, WherePredicate, },
 };
 use itertools::chain;
 use triomphe::Arc;
 
-pub fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {
+pub fn generics(
+    db: &dyn DefDatabase,
+    def: GenericDefId,
+) -> Generics {
     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));
     let (params, store) = db.generic_params_and_store(def);
     let has_trait_self_param = params.trait_self_param().is_some();
-    Generics {
-        def,
-        params,
-        parent_generics,
-        has_trait_self_param,
-        store,
-    }
+    Generics { def, params, parent_generics, has_trait_self_param, store }
 }
+
 #[derive(Clone, Debug)]
 pub struct Generics {
     def: GenericDefId,
 
 impl<T> ops::Index<T> for Generics
 where
-    GenericParams: ops::Index<T>,
-{
+    GenericParams: ops::Index<T>, {
     type Output = <GenericParams as ops::Index<T>>::Output;
-    fn index(&self, index: T) -> &Self::Output {
+
+    fn index(
+        &self,
+        index: T,
+    ) -> &Self::Output {
         &self.params[index]
     }
 }
 
     pub(crate) fn has_no_predicates(&self) -> bool {
         self.params.has_no_predicates()
-            && self
-                .parent_generics
-                .as_ref()
-                .is_none_or(|g| g.params.has_no_predicates())
+            && self.parent_generics.as_ref().is_none_or(|g| g.params.has_no_predicates())
     }
 
     pub(crate) fn is_empty(&self) -> bool {
-        self.params.is_empty()
-            && self
-                .parent_generics
-                .as_ref()
-                .is_none_or(|g| g.params.is_empty())
+        self.params.is_empty() && self.parent_generics.as_ref().is_none_or(|g| g.params.is_empty())
     }
 
     pub(crate) fn iter_id(&self) -> impl Iterator<Item = GenericParamId> + '_ {
         self.iter_parent().map(|(id, _)| id)
     }
 
-    pub(crate) fn iter_self_type_or_consts(
-        &self,
-    ) -> impl DoubleEndedIterator<Item = (LocalTypeOrConstParamId, &TypeOrConstParamData)> + '_
-    {
+    pub(crate) fn iter_self_type_or_consts(&self) -> impl DoubleEndedIterator<Item = (LocalTypeOrConstParamId, &TypeOrConstParamData)> + '_ {
         let mut toc = self.params.iter_type_or_consts();
         let trait_self_param = self.has_trait_self_param.then(|| toc.next()).flatten();
         chain!(trait_self_param, toc)
     }
 
     /// Iterate over the parent params followed by self params.
-    pub(crate) fn iter(
-        &self,
-    ) -> impl DoubleEndedIterator<Item = (GenericParamId, GenericParamDataRef<'_>)> + '_ {
+    pub(crate) fn iter(&self) -> impl DoubleEndedIterator<Item = (GenericParamId, GenericParamDataRef<'_>)> + '_ {
         self.iter_parent().chain(self.iter_self())
     }
 
-    pub(crate) fn iter_parents_with_store(
-        &self,
-    ) -> impl Iterator<Item = ((GenericParamId, GenericParamDataRef<'_>), &ExpressionStore)> + '_
-    {
-        self.iter_parent().zip(
-            self.parent_generics()
-                .into_iter()
-                .flat_map(|it| std::iter::repeat(&*it.store)),
-        )
+    pub(crate) fn iter_parents_with_store(&self) -> impl Iterator<Item = ((GenericParamId, GenericParamDataRef<'_>), &ExpressionStore)> + '_ {
+        self.iter_parent()
+            .zip(self.parent_generics().into_iter().flat_map(|it| std::iter::repeat(&*it.store)))
     }
 
     /// Iterate over the params without parent params.
-    pub(crate) fn iter_self(
-        &self,
-    ) -> impl DoubleEndedIterator<Item = (GenericParamId, GenericParamDataRef<'_>)> + '_ {
+    pub(crate) fn iter_self(&self) -> impl DoubleEndedIterator<Item = (GenericParamId, GenericParamDataRef<'_>)> + '_ {
         let mut toc = self.params.iter_type_or_consts().map(from_toc_id(self));
         let trait_self_param = self.has_trait_self_param.then(|| toc.next()).flatten();
-        chain!(
-            trait_self_param,
-            self.params.iter_lt().map(from_lt_id(self)),
-            toc
-        )
+        chain!(trait_self_param, self.params.iter_lt().map(from_lt_id(self)), toc)
     }
 
     /// Iterator over types and const params of parent.
-    pub(crate) fn iter_parent(
-        &self,
-    ) -> impl DoubleEndedIterator<Item = (GenericParamId, GenericParamDataRef<'_>)> + '_ {
+    pub(crate) fn iter_parent(&self) -> impl DoubleEndedIterator<Item = (GenericParamId, GenericParamDataRef<'_>)> + '_ {
         self.parent_generics().into_iter().flat_map(|it| {
             let mut toc = it.params.iter_type_or_consts().map(from_toc_id(it));
             let trait_self_param = it.has_trait_self_param.then(|| toc.next()).flatten();
-            chain!(
-                trait_self_param,
-                it.params.iter_lt().map(from_lt_id(it)),
-                toc
-            )
+            chain!(trait_self_param, it.params.iter_lt().map(from_lt_id(it)), toc)
         })
     }
 
         let mut type_params = 0;
         let mut impl_trait_params = 0;
         let mut const_params = 0;
-        self.params
-            .iter_type_or_consts()
-            .for_each(|(_, data)| match data {
-                TypeOrConstParamData::TypeParamData(p) => match p.provenance {
-                    TypeParamProvenance::TypeParamList => type_params += 1,
-                    TypeParamProvenance::TraitSelf => self_param |= true,
-                    TypeParamProvenance::ArgumentImplTrait => impl_trait_params += 1,
-                },
-                TypeOrConstParamData::ConstParamData(_) => const_params += 1,
-            });
-
+        self.params.iter_type_or_consts().for_each(|(_, data)| match data {
+            TypeOrConstParamData::TypeParamData(p) => match p.provenance {
+                TypeParamProvenance::TypeParamList => type_params += 1,
+                TypeParamProvenance::TraitSelf => self_param |= true,
+                TypeParamProvenance::ArgumentImplTrait => impl_trait_params += 1,
+            },
+            TypeOrConstParamData::ConstParamData(_) => const_params += 1,
+        });
         let lifetime_params = self.params.len_lifetimes();
-
         let parent_len = self.parent_generics().map_or(0, Generics::len);
-        (
-            parent_len,
-            self_param,
-            type_params,
-            const_params,
-            impl_trait_params,
-            lifetime_params,
-        )
+        (parent_len, self_param, type_params, const_params, impl_trait_params, lifetime_params)
     }
 
     pub(crate) fn type_or_const_param(
         })
     }
 
-    pub fn type_or_const_param_idx(&self, param: TypeOrConstParamId) -> Option<usize> {
+    pub fn type_or_const_param_idx(
+        &self,
+        param: TypeOrConstParamId,
+    ) -> Option<usize> {
         self.find_type_or_const_param(param)
     }
 
-    fn find_type_or_const_param(&self, param: TypeOrConstParamId) -> Option<usize> {
+    fn find_type_or_const_param(
+        &self,
+        param: TypeOrConstParamId,
+    ) -> Option<usize> {
         if param.parent == self.def {
             let idx = param.local_id.into_raw().into_u32() as usize;
             debug_assert!(
             Some(self.parent_generics().map_or(0, |g| g.len()) + self.params.len_lifetimes() + idx)
         } else {
             debug_assert_eq!(self.parent_generics().map(|it| it.def), Some(param.parent));
-            self.parent_generics()
-                .and_then(|g| g.find_type_or_const_param(param))
+            self.parent_generics().and_then(|g| g.find_type_or_const_param(param))
         }
     }
 
-    pub fn lifetime_idx(&self, lifetime: LifetimeParamId) -> Option<usize> {
+    pub fn lifetime_idx(
+        &self,
+        lifetime: LifetimeParamId,
+    ) -> Option<usize> {
         self.find_lifetime(lifetime)
     }
 
-    fn find_lifetime(&self, lifetime: LifetimeParamId) -> Option<usize> {
+    fn find_lifetime(
+        &self,
+        lifetime: LifetimeParamId,
+    ) -> Option<usize> {
         if lifetime.parent == self.def {
             let idx = lifetime.local_id.into_raw().into_u32() as usize;
             debug_assert!(idx <= self.params.len_lifetimes());
                     + idx,
             )
         } else {
-            debug_assert_eq!(
-                self.parent_generics().map(|it| it.def),
-                Some(lifetime.parent)
-            );
-            self.parent_generics()
-                .and_then(|g| g.find_lifetime(lifetime))
+            debug_assert_eq!(self.parent_generics().map(|it| it.def), Some(lifetime.parent));
+            self.parent_generics().and_then(|g| g.find_lifetime(lifetime))
         }
     }
 
     }
 }
 
-pub(crate) fn trait_self_param_idx(db: &dyn DefDatabase, def: GenericDefId) -> Option<usize> {
+pub(crate) fn trait_self_param_idx(
+    db: &dyn DefDatabase,
+    def: GenericDefId,
+) -> Option<usize> {
     match def {
         GenericDefId::TraitId(_) => {
             let params = db.generic_params(def);
-            params
-                .trait_self_param()
-                .map(|idx| idx.into_raw().into_u32() as usize)
+            params.trait_self_param().map(|idx| idx.into_raw().into_u32() as usize)
         }
         GenericDefId::ImplId(_) => None,
         _ => {
     }
 }
 
-pub(crate) fn parent_generic_def(db: &dyn DefDatabase, def: GenericDefId) -> Option<GenericDefId> {
+pub(crate) fn parent_generic_def(
+    db: &dyn DefDatabase,
+    def: GenericDefId,
+) -> Option<GenericDefId> {
     let container = match def {
         GenericDefId::FunctionId(it) => it.lookup(db).container,
         GenericDefId::TypeAliasId(it) => it.lookup(db).container,
         | GenericDefId::TraitId(_)
         | GenericDefId::ImplId(_) => return None,
     };
-
     match container {
         ItemContainerId::ImplId(it) => Some(it.into()),
         ItemContainerId::TraitId(it) => Some(it.into()),
     }
 }
 
-fn from_toc_id<'a>(
-    it: &'a Generics,
-) -> impl Fn(
+fn from_toc_id<'a>(it: &'a Generics) -> impl Fn(
     (LocalTypeOrConstParamId, &'a TypeOrConstParamData),
 ) -> (GenericParamId, GenericParamDataRef<'a>) {
     move |(local_id, p): (_, _)| {
-        let id = TypeOrConstParamId {
-            parent: it.def,
-            local_id,
-        };
+        let id = TypeOrConstParamId { parent: it.def, local_id };
         match p {
             TypeOrConstParamData::TypeParamData(p) => (
                 GenericParamId::TypeParamId(TypeParamId::from_unchecked(id)),
     }
 }
 
-fn from_lt_id<'a>(
-    it: &'a Generics,
-) -> impl Fn((LocalLifetimeParamId, &'a LifetimeParamData)) -> (GenericParamId, GenericParamDataRef<'a>)
-{
+fn from_lt_id<'a>(it: &'a Generics) -> impl Fn((LocalLifetimeParamId, &'a LifetimeParamData)) -> (GenericParamId, GenericParamDataRef<'a>) {
     move |(local_id, p): (_, _)| {
         (
-            GenericParamId::LifetimeParamId(LifetimeParamId {
-                parent: it.def,
-                local_id,
-            }),
+            GenericParamId::LifetimeParamId(LifetimeParamId { parent: it.def, local_id }),
             GenericParamDataRef::LifetimeParamData(p),
         )
     }