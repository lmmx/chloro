COMPARISON DIFF
============================================================

Original size: 25126 bytes
Chloro size:   24629 bytes
Rustfmt size:  25126 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, DefWithBodyId, HasModule, ItemContainerId, Lookup,
     lang_item::LangItem,
     resolver::{HasResolver, ValueNs},
+    AdtId, AssocItemId, DefWithBodyId, HasModule, ItemContainerId, Lookup,
+};
+pub(crate) use hir_def::{
+    expr_store::Body,
+    hir::{Expr, ExprId, MatchArm, Pat, PatId, Statement},
+    LocalFieldId, VariantId,
 };
 use intern::sym;
 use itertools::Itertools;
 use typed_arena::Arena;
 
 use crate::{
-    Adjust, InferenceResult, TraitEnvironment,
     db::HirDatabase,
     diagnostics::match_check::{
-        self,
-        pat_analysis::{self, DeconstructedPat, MatchCheckCtx, WitnessPat},
+        pat_analysis::{self, DeconstructedPat, MatchCheckCtx, WitnessPat}, self,
     },
     display::{DisplayTarget, HirDisplay},
-    next_solver::{
-        DbInterner, Ty, TyKind, TypingMode,
-        infer::{DbInternerInferExt, InferCtxt},
-    },
-};
-
-pub(crate) use hir_def::{
-    LocalFieldId, VariantId,
-    expr_store::Body,
-    hir::{Expr, ExprId, MatchArm, Pat, PatId, Statement},
+    next_solver::{infer::{DbInternerInferExt, InferCtxt}, DbInterner, Ty, TyKind, TypingMode},
+    Adjust, InferenceResult, TraitEnvironment,
 };
 
 pub enum BodyValidationDiagnostic {
         let mut filter_map_next_checker = None;
         // we'll pass &mut self while iterating over body.exprs, so they need to be disjoint
         let body = Arc::clone(&self.body);
-
         if matches!(self.owner, DefWithBodyId::FunctionId(_)) {
             self.check_for_trailing_return(body.body_expr, &body);
         }
-
         for (id, expr) in body.exprs() {
             if let Some((variant, missed_fields, true)) =
                 record_literal_missing_fields(db, &self.infer, id, expr)
                 _ => {}
             }
         }
-
         for (id, pat) in body.pats() {
             if let Some((variant, missed_fields, true)) =
                 record_pattern_missing_fields(db, &self.infer, id, pat)
             return;
         }
         // Check that the number of arguments matches the number of parameters.
-
         if self.infer.expr_type_mismatches().next().is_some() {
             // FIXME: Due to shortcomings in the current type system implementation, only emit
             // this diagnostic if there are no type mismatches in the containing function.
         if scrut_ty.references_non_lt_error() {
             return;
         }
-
         let cx = MatchCheckCtx::new(self.owner.module(self.db()), &self.infcx, self.env.clone());
-
         let pattern_arena = Arena::new();
         let mut m_arms = Vec::with_capacity(arms.len());
         let mut has_lowering_errors = false;
             cov_mark::hit!(validate_match_bailed_out);
             return;
         }
-
         let known_valid_scrutinee = Some(self.is_known_valid_scrutinee(scrutinee_expr));
         let report =
             match cx.compute_match_usefulness(m_arms.as_slice(), scrut_ty, known_valid_scrutinee) {
                 Ok(report) => report,
                 Err(()) => return,
             };
-
         // FIXME Report unreachable arms
         // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200
-
         let witnesses = report.non_exhaustiveness_witnesses;
         if !witnesses.is_empty() {
             self.diagnostics.push(BodyValidationDiagnostic::MissingMatchArms {
         }
     }
 
-    // [rustc's `is_known_valid_scrutinee`](https://github.com/rust-lang/rust/blob/c9bd03cb724e13cca96ad320733046cbdb16fbbe/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L288)
-    //
-    // While the above function in rustc uses thir exprs, r-a doesn't have them.
-    // So, the logic here is getting same result as "hir lowering + match with lowered thir"
-    // with "hir only"
     fn is_known_valid_scrutinee(&self, scrutinee_expr: ExprId) -> bool {
         let db = self.db();
-
         if self
             .infer
             .expr_adjustments
         {
             return false;
         }
-
         match &self.body[scrutinee_expr] {
             Expr::UnaryOp { op: UnaryOp::Deref, .. } => false,
             Expr::Path(path) => {
         }
     }
 
-    // check for instances of .filter_map(..).next()
     fn check(
         &mut self,
         current_expr_id: ExprId,
             self.prev_filter_map_expr_id = Some(current_expr_id);
             return None;
         }
-
         if *function_id == self.next_function_id?
             && let Some(prev_filter_map_expr_id) = self.prev_filter_map_expr_id
         {
                 return Some(());
             }
         }
-
         self.prev_filter_map_expr_id = None;
         None
     }
         Expr::RecordLit { fields, spread, .. } => (fields, spread.is_none()),
         _ => return None,
     };
-
     let variant_def = infer.variant_resolution_for_expr(id)?;
     if let VariantId::UnionId(_) = variant_def {
         return None;
     }
-
     let variant_data = variant_def.fields(db);
-
     let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();
     let missed_fields: Vec<LocalFieldId> = variant_data
         .fields()
         Pat::Record { path: _, args, ellipsis } => (args, !ellipsis),
         _ => return None,
     };
-
     let variant_def = infer.variant_resolution_for_pat(id)?;
     if let VariantId::UnionId(_) = variant_def {
         return None;
     }
-
     let variant_data = variant_def.fields(db);
-
     let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();
     let missed_fields: Vec<LocalFieldId> = variant_data
         .fields()
             }
         }
     }
-
     let mut has_type_mismatches = false;
     walk(pat, body, infer, &mut has_type_mismatches);
     !has_type_mismatches
             write!(f, "{}", pat.display(cx.db, display_target))
         }
     }
-
     let non_empty_enum = match scrut_ty.as_adt() {
         Some((AdtId::EnumId(e), _)) => !e.enum_variants(cx.db).variants.is_empty(),
         _ => false,