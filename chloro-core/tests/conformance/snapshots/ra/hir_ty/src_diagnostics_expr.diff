COMPARISON DIFF
============================================================

Original size: 25126 bytes
Chloro size:   24845 bytes
Rustfmt size:  25126 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, DefWithBodyId, HasModule, ItemContainerId, Lookup,
     lang_item::LangItem,
     resolver::{HasResolver, ValueNs},
+    AdtId, AssocItemId, DefWithBodyId, HasModule, ItemContainerId, Lookup,
+};
+pub(crate) use hir_def::{
+    expr_store::Body,
+    hir::{Expr, ExprId, MatchArm, Pat, PatId, Statement},
+    LocalFieldId, VariantId,
 };
 use intern::sym;
 use itertools::Itertools;
 use typed_arena::Arena;
 
 use crate::{
-    Adjust, InferenceResult, TraitEnvironment,
     db::HirDatabase,
     diagnostics::match_check::{
         self,
         DbInterner, Ty, TyKind, TypingMode,
         infer::{DbInternerInferExt, InferCtxt},
     },
-};
-
-pub(crate) use hir_def::{
-    LocalFieldId, VariantId,
-    expr_store::Body,
-    hir::{Expr, ExprId, MatchArm, Pat, PatId, Statement},
+    Adjust, InferenceResult, TraitEnvironment,
 };
 
 pub enum BodyValidationDiagnostic {
         let mut filter_map_next_checker = None;
         // we'll pass &mut self while iterating over body.exprs, so they need to be disjoint
         let body = Arc::clone(&self.body);
-
         if matches!(self.owner, DefWithBodyId::FunctionId(_)) {
             self.check_for_trailing_return(body.body_expr, &body);
         }
-
         for (id, expr) in body.exprs() {
             if let Some((variant, missed_fields, true)) =
                 record_literal_missing_fields(db, &self.infer, id, expr)
                 _ => {}
             }
         }
-
         for (id, pat) in body.pats() {
             if let Some((variant, missed_fields, true)) =
                 record_pattern_missing_fields(db, &self.infer, id, pat)
             return;
         }
         // Check that the number of arguments matches the number of parameters.
-
         if self.infer.expr_type_mismatches().next().is_some() {
             // FIXME: Due to shortcomings in the current type system implementation, only emit
             // this diagnostic if there are no type mismatches in the containing function.
         }
     }
 
-    fn validate_match(&mut self, match_expr: ExprId, scrutinee_expr: ExprId, arms: &[MatchArm]) {
+    fn validate_match(
+        &mut self,
+        match_expr: ExprId,
+        scrutinee_expr: ExprId,
+        arms: &[MatchArm],
+    ) {
         let Some(scrut_ty) = self.infer.type_of_expr_with_adjust(scrutinee_expr) else {
             return;
         };
         if scrut_ty.references_non_lt_error() {
             return;
         }
-
         let cx = MatchCheckCtx::new(self.owner.module(self.db()), &self.infcx, self.env.clone());
-
         let pattern_arena = Arena::new();
         let mut m_arms = Vec::with_capacity(arms.len());
         let mut has_lowering_errors = false;
             cov_mark::hit!(validate_match_bailed_out);
             return;
         }
-
         let known_valid_scrutinee = Some(self.is_known_valid_scrutinee(scrutinee_expr));
         let report =
             match cx.compute_match_usefulness(m_arms.as_slice(), scrut_ty, known_valid_scrutinee) {
                 Ok(report) => report,
                 Err(()) => return,
             };
-
         // FIXME Report unreachable arms
         // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200
-
         let witnesses = report.non_exhaustiveness_witnesses;
         if !witnesses.is_empty() {
             self.diagnostics.push(BodyValidationDiagnostic::MissingMatchArms {
         }
     }
 
-    // [rustc's `is_known_valid_scrutinee`](https://github.com/rust-lang/rust/blob/c9bd03cb724e13cca96ad320733046cbdb16fbbe/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L288)
-    //
-    // While the above function in rustc uses thir exprs, r-a doesn't have them.
-    // So, the logic here is getting same result as "hir lowering + match with lowered thir"
-    // with "hir only"
-    fn is_known_valid_scrutinee(&self, scrutinee_expr: ExprId) -> bool {
+    fn is_known_valid_scrutinee(
+        &self,
+        scrutinee_expr: ExprId,
+    ) -> bool {
         let db = self.db();
-
         if self
             .infer
             .expr_adjustments
         {
             return false;
         }
-
         match &self.body[scrutinee_expr] {
             Expr::UnaryOp { op: UnaryOp::Deref, .. } => false,
             Expr::Path(path) => {
         }
     }
 
-    fn validate_block(&mut self, expr: &Expr) {
+    fn validate_block(
+        &mut self,
+        expr: &Expr,
+    ) {
         let (Expr::Block { statements, .. }
         | Expr::Async { statements, .. }
         | Expr::Unsafe { statements, .. }) = expr
         pattern
     }
 
-    fn check_for_trailing_return(&mut self, body_expr: ExprId, body: &Body) {
+    fn check_for_trailing_return(
+        &mut self,
+        body_expr: ExprId,
+        body: &Body,
+    ) {
         if !self.validate_lints {
             return;
         }
         }
     }
 
-    fn check_for_unnecessary_else(&mut self, id: ExprId, expr: &Expr) {
+    fn check_for_unnecessary_else(
+        &mut self,
+        id: ExprId,
+        expr: &Expr,
+    ) {
         if !self.validate_lints {
             return;
         }
 }
 
 impl<'db> FilterMapNextChecker<'db> {
-    fn new(resolver: &hir_def::resolver::Resolver<'db>, db: &'db dyn HirDatabase) -> Self {
+    fn new(
+        resolver: &hir_def::resolver::Resolver<'db>,
+        db: &'db dyn HirDatabase,
+    ) -> Self {
         // Find and store the FunctionIds for Iterator::filter_map and Iterator::next
         let (next_function_id, filter_map_function_id) = match LangItem::IteratorNext
             .resolve_function(db, resolver.krate())
         }
     }
 
-    // check for instances of .filter_map(..).next()
     fn check(
         &mut self,
         current_expr_id: ExprId,
             self.prev_filter_map_expr_id = Some(current_expr_id);
             return None;
         }
-
         if *function_id == self.next_function_id?
             && let Some(prev_filter_map_expr_id) = self.prev_filter_map_expr_id
         {
                 return Some(());
             }
         }
-
         self.prev_filter_map_expr_id = None;
         None
     }
         Expr::RecordLit { fields, spread, .. } => (fields, spread.is_none()),
         _ => return None,
     };
-
     let variant_def = infer.variant_resolution_for_expr(id)?;
     if let VariantId::UnionId(_) = variant_def {
         return None;
     }
-
     let variant_data = variant_def.fields(db);
-
     let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();
     let missed_fields: Vec<LocalFieldId> = variant_data
         .fields()
         Pat::Record { path: _, args, ellipsis } => (args, !ellipsis),
         _ => return None,
     };
-
     let variant_def = infer.variant_resolution_for_pat(id)?;
     if let VariantId::UnionId(_) = variant_def {
         return None;
     }
-
     let variant_data = variant_def.fields(db);
-
     let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();
     let missed_fields: Vec<LocalFieldId> = variant_data
         .fields()
     Some((variant_def, missed_fields, exhaustive))
 }
 
-fn types_of_subpatterns_do_match(pat: PatId, body: &Body, infer: &InferenceResult<'_>) -> bool {
+fn types_of_subpatterns_do_match(
+    pat: PatId,
+    body: &Body,
+    infer: &InferenceResult<'_>,
+) -> bool {
     fn walk(pat: PatId, body: &Body, infer: &InferenceResult<'_>, has_type_mismatches: &mut bool) {
         match infer.type_mismatch_for_pat(pat) {
             Some(_) => *has_type_mismatches = true,
             }
         }
     }
-
     let mut has_type_mismatches = false;
     walk(pat, body, infer, &mut has_type_mismatches);
     !has_type_mismatches
             write!(f, "{}", pat.display(cx.db, display_target))
         }
     }
-
     let non_empty_enum = match scrut_ty.as_adt() {
         Some((AdtId::EnumId(e), _)) => !e.enum_variants(cx.db).variants.is_empty(),
         _ => false,