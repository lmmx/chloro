COMPARISON DIFF
============================================================

Original size: 25126 bytes
Chloro size:   24195 bytes
Rustfmt size:  25126 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, DefWithBodyId, HasModule, ItemContainerId, Lookup,
     lang_item::LangItem,
     resolver::{HasResolver, ValueNs},
+    AdtId, AssocItemId, DefWithBodyId, HasModule, ItemContainerId, Lookup,
+};
+pub(crate) use hir_def::{
+    expr_store::Body,
+    hir::{Expr, ExprId, MatchArm, Pat, PatId, Statement},
+    LocalFieldId, VariantId,
 };
 use intern::sym;
 use itertools::Itertools;
 use rustc_pattern_analysis::constructor::Constructor;
 use rustc_type_ir::inherent::{AdtDef, IntoKind};
 use syntax::{
-    AstNode,
     ast::{self, UnaryOp},
+    AstNode,
 };
 use tracing::debug;
 use triomphe::Arc;
 use typed_arena::Arena;
 
 use crate::{
-    Adjust, InferenceResult, TraitEnvironment,
     db::HirDatabase,
     diagnostics::match_check::{
-        self,
-        pat_analysis::{self, DeconstructedPat, MatchCheckCtx, WitnessPat},
+        self, pat_analysis::{self, DeconstructedPat, MatchCheckCtx, WitnessPat},
     },
     display::{DisplayTarget, HirDisplay},
-    next_solver::{
-        DbInterner, Ty, TyKind, TypingMode,
-        infer::{DbInternerInferExt, InferCtxt},
-    },
-};
-
-pub(crate) use hir_def::{
-    LocalFieldId, VariantId,
-    expr_store::Body,
-    hir::{Expr, ExprId, MatchArm, Pat, PatId, Statement},
+    next_solver::{infer::{DbInternerInferExt, InferCtxt}, DbInterner, Ty, TyKind, TypingMode},
+    Adjust, InferenceResult, TraitEnvironment,
 };
 
 pub enum BodyValidationDiagnostic {
         }
 
         for (id, pat) in body.pats() {
-            if let Some((variant, missed_fields, true)) =
-                record_pattern_missing_fields(db, &self.infer, id, pat)
-            {
+            if let Some((variant, missed_fields, true)) = record_pattern_missing_fields(db, &self.infer, id, pat) {
                 self.diagnostics.push(BodyValidationDiagnostic::RecordMissingFields {
                     record: Either::Right(id),
                     variant,
             return;
         }
         // Check that the number of arguments matches the number of parameters.
-
         if self.infer.expr_type_mismatches().next().is_some() {
-            // FIXME: Due to shortcomings in the current type system implementation, only emit
-            // this diagnostic if there are no type mismatches in the containing function.
         } else if let Expr::MethodCall { receiver, .. } = expr {
             let (callee, _) = match self.infer.method_resolution(call_id) {
                 Some(it) => it,
                 None => return,
             };
-
             let checker = filter_map_next_checker.get_or_insert_with(|| {
                 FilterMapNextChecker::new(&self.owner.resolver(self.db()), self.db())
             });
-
             if checker.check(call_id, receiver, &callee).is_some() {
                 self.diagnostics.push(BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap {
                     method_call_expr: call_id,
                 });
             }
-
             if let Some(receiver_ty) = self.infer.type_of_expr_with_adjust(*receiver) {
                 checker.prev_receiver_ty = Some(receiver_ty);
             }
             };
 
         // FIXME Report unreachable arms
-        // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200
 
+        // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200
         let witnesses = report.non_exhaustiveness_witnesses;
         if !witnesses.is_empty() {
             self.diagnostics.push(BodyValidationDiagnostic::MissingMatchArms {
         }
     }
 
-    // [rustc's `is_known_valid_scrutinee`](https://github.com/rust-lang/rust/blob/c9bd03cb724e13cca96ad320733046cbdb16fbbe/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L288)
-    //
-    // While the above function in rustc uses thir exprs, r-a doesn't have them.
-    // So, the logic here is getting same result as "hir lowering + match with lowered thir"
-    // with "hir only"
     fn is_known_valid_scrutinee(&self, scrutinee_expr: ExprId) -> bool {
         let db = self.db();
 
             if ty.references_non_lt_error() {
                 continue;
             }
-
             let mut have_errors = false;
             let deconstructed_pat = self.lower_pattern(&cx, pat, &mut have_errors);
-
-            // optimization, wildcard trivially hold
             if have_errors || matches!(deconstructed_pat.ctor(), Constructor::Wildcard) {
                 continue;
             }
-
             let match_arm = rustc_pattern_analysis::MatchArm {
                 pat: pattern_arena.alloc(deconstructed_pat),
                 has_guard: false,
                     Statement::Expr { expr, .. } => Some(*expr),
                     _ => None,
                 });
-                if let Some(last_then_expr) = last_then_expr
-                    && let Some(last_then_expr_ty) =
-                        self.infer.type_of_expr_with_adjust(last_then_expr)
-                    && last_then_expr_ty.is_never()
-                {
-                    // Only look at sources if the then branch diverges and we have an else branch.
+                if let Some(last_then_expr) = last_then_expr && let Some(last_then_expr_ty) = self.infer.type_of_expr_with_adjust(last_then_expr) && last_then_expr_ty.is_never() {
                     let source_map = self.db().body_with_source_map(self.owner).1;
                     let Ok(source_ptr) = source_map.expr_syntax(id) else {
                         return;
                         // Check parent if expr.
                         top_if_expr = parent_if_expr;
                     }
-
                     self.diagnostics
                         .push(BodyValidationDiagnostic::RemoveUnnecessaryElse { if_expr: id })
                 }
         }
     }
 
-    // check for instances of .filter_map(..).next()
     fn check(
         &mut self,
         current_expr_id: ExprId,