COMPARISON DIFF
============================================================

Original size: 15480 bytes
Chloro size:   15454 bytes
Rustfmt size:  15480 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! MIR lowering for places
 
 use hir_def::FunctionId;
 use intern::sym;
 use rustc_type_ir::inherent::{AdtDef, Region as _, Ty as _};
 
-use super::*;
 use crate::{
     mir::{MutBorrowKind, Operand, OperandKind},
     next_solver::Region,
 };
+use super::*;
 
 macro_rules! not_supported {
     ($it: expr) => {
                     };
                     it.0 = it.0.project(ProjectionElem::Deref, &mut self.result.projection_store);
                     Ok(Some(it))
-                }
+                },
                 Adjust::Deref(Some(od)) => {
                     let Some((r, current)) = self.lower_expr_as_place_with_adjust(
                         current,
                     self.lower_overloaded_deref(
                         current,
                         r,
-                        rest.last()
-                            .map(|it| it.target)
-                            .unwrap_or_else(|| self.expr_ty_without_adjust(expr_id)),
+                        rest.last().map(|it| it.target).unwrap_or_else(
+                        || self.expr_ty_without_adjust(expr_id),
+                    ),
                         last.target,
                         expr_id.into(),
                         match od.0 {
-                            Some(Mutability::Mut) => true,
-                            Some(Mutability::Not) => false,
-                            None => {
-                                not_supported!("implicit overloaded deref with unknown mutability")
-                            }
+                        Some(Mutability::Mut) => true,
+                        Some(Mutability::Not) => false,
+                        None => {
+                            not_supported!("implicit overloaded deref with unknown mutability")
                         },
+                    },
                     )
-                }
+                },
                 Adjust::NeverToAny | Adjust::Borrow(_) | Adjust::Pointer(_) => try_rvalue(self),
             }
         } else {
                 match pr {
                     ValueNs::LocalBinding(pat_id) => {
                         Ok(Some((self.binding_local(pat_id)?.into(), current)))
-                    }
+                    },
                     ValueNs::StaticId(s) => {
                         let ty = self.expr_ty_without_adjust(expr_id);
                         let ref_ty = Ty::new_ref(
                             temp.project(ProjectionElem::Deref, &mut self.result.projection_store),
                             current,
                         )))
-                    }
+                    },
                     _ => try_rvalue(self),
                 }
-            }
+            },
             Expr::UnaryOp { expr, op: hir_def::hir::UnaryOp::Deref } => {
                 let is_builtin = match self.expr_ty_without_adjust(*expr).kind() {
                     TyKind::Ref(..) | TyKind::RawPtr(..) => true,
                 };
                 r = r.project(ProjectionElem::Deref, &mut self.result.projection_store);
                 Ok(Some((r, current)))
-            }
+            },
             Expr::UnaryOp { .. } => try_rvalue(self),
             Expr::Field { expr, .. } => {
                 let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {
                 };
                 self.push_field_projection(&mut r, expr_id)?;
                 Ok(Some((r, current)))
-            }
+            },
             Expr::Index { base, index } => {
                 let base_ty = self.expr_ty_after_adjustments(*base);
                 let index_ty = self.expr_ty_after_adjustments(*index);
                 p_base = p_base
                     .project(ProjectionElem::Index(l_index), &mut self.result.projection_store);
                 Ok(Some((p_base, current)))
-            }
+            },
             _ => try_rvalue(self),
         }
     }