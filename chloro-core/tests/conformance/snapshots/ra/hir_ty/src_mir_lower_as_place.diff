COMPARISON DIFF
============================================================

Original size: 15480 bytes
Chloro size:   15480 bytes
Rustfmt size:  16065 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
                     else {
                         return Ok(None);
                     };
-                    it.0 =
-                        it.0.project(ProjectionElem::Deref, &mut self.result.projection_store);
+                    it.0 = it.0.project(ProjectionElem::Deref, &mut self.result.projection_store);
                     Ok(Some(it))
                 }
                 Adjust::Deref(Some(od)) => {
         };
         match &self.body[expr_id] {
             Expr::Path(p) => {
-                let resolver_guard = self
-                    .resolver
-                    .update_to_inner_scope(self.db, self.owner, expr_id);
+                let resolver_guard =
+                    self.resolver.update_to_inner_scope(self.db, self.owner, expr_id);
                 let hygiene = self.body.expr_path_hygiene(expr_id);
-                let resolved = self
-                    .resolver
-                    .resolve_path_in_value_ns_fully(self.db, p, hygiene);
+                let resolved = self.resolver.resolve_path_in_value_ns_fully(self.db, p, hygiene);
                 self.resolver.reset_to_guard(resolver_guard);
                 let Some(pr) = resolved else {
                     return try_rvalue(self);
                         self.push_assignment(
                             current,
                             temp,
-                            Operand {
-                                kind: OperandKind::Static(s),
-                                span: None,
-                            }
-                            .into(),
+                            Operand { kind: OperandKind::Static(s), span: None }.into(),
                             expr_id.into(),
                         );
                         Ok(Some((
                     _ => try_rvalue(self),
                 }
             }
-            Expr::UnaryOp {
-                expr,
-                op: hir_def::hir::UnaryOp::Deref,
-            } => {
+            Expr::UnaryOp { expr, op: hir_def::hir::UnaryOp::Deref } => {
                 let is_builtin = match self.expr_ty_without_adjust(*expr).kind() {
                     TyKind::Ref(..) | TyKind::RawPtr(..) => true,
                     TyKind::Adt(id, _) => {
                 else {
                     return Ok(None);
                 };
-                let l_index = self.temp(
-                    self.expr_ty_after_adjustments(*index),
-                    current,
-                    expr_id.into(),
-                )?;
+                let l_index =
+                    self.temp(self.expr_ty_after_adjustments(*index), current, expr_id.into())?;
                 let Some(current) = self.lower_expr_to_place(*index, l_index.into(), current)?
                 else {
                     return Ok(None);
                 };
-                p_base = p_base.project(
-                    ProjectionElem::Index(l_index),
-                    &mut self.result.projection_store,
-                );
+                p_base = p_base
+                    .project(ProjectionElem::Index(l_index), &mut self.result.projection_store);
                 Ok(Some((p_base, current)))
             }
             _ => try_rvalue(self),
             Some((_, _, mutability)) => mutability,
             None => Mutability::Not,
         };
-        let result_ref = Ty::new_ref(
-            self.interner(),
-            Region::error(self.interner()),
-            result_ty,
-            mutability,
-        );
+        let result_ref =
+            Ty::new_ref(self.interner(), Region::error(self.interner()), result_ty, mutability);
         let mut result: Place<'db> = self.temp(result_ref, current, span)?.into();
         let index_fn_op = Operand::const_zst(Ty::new_fn_def(
             self.interner(),
         ));
         let Some(current) = self.lower_call(
             index_fn_op,
-            Box::new([
-                Operand {
-                    kind: OperandKind::Copy(place),
-                    span: None,
-                },
-                index_operand,
-            ]),
+            Box::new([Operand { kind: OperandKind::Copy(place), span: None }, index_operand]),
             result,
             current,
             false,
                 Mutability::Mut,
                 LangItem::DerefMut,
                 Name::new_symbol_root(sym::deref_mut),
-                BorrowKind::Mut {
-                    kind: MutBorrowKind::Default,
-                },
+                BorrowKind::Mut { kind: MutBorrowKind::Default },
             )
         };
         let error_region = Region::error(self.interner());
         let mut result: Place<'db> = self.temp(target_ty_ref, current, span)?.into();
         let Some(current) = self.lower_call(
             deref_fn_op,
-            Box::new([Operand {
-                kind: OperandKind::Copy(ref_place),
-                span: None,
-            }]),
+            Box::new([Operand { kind: OperandKind::Copy(ref_place), span: None }]),
             result,
             current,
             false,