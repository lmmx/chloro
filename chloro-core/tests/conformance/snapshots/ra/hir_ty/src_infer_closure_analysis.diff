COMPARISON DIFF
============================================================

Original size: 52289 bytes
Chloro size:   52257 bytes
Rustfmt size:  52289 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Post-inference closure analysis: captures and closure kind.
 
 use std::{cmp, convert::Infallible, mem};
 
 use either::Either;
 use hir_def::{
-    DefWithBodyId, FieldId, HasModule, TupleFieldId, TupleId, VariantId,
     expr_store::path::Path,
     hir::{
         Array, AsmOperand, BinaryOp, BindingId, CaptureBy, Expr, ExprId, ExprOrPatId, Pat, PatId,
     item_tree::FieldsShape,
     lang_item::LangItem,
     resolver::ValueNs,
+    DefWithBodyId, FieldId, HasModule, TupleFieldId, TupleId, VariantId,
 };
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::inherent::{IntoKind, SliceLike, Ty as _};
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use stdx::{format_to, never};
 use syntax::utils::is_raw_identifier;
 
 use crate::{
-    Adjust, Adjustment, BindingMode,
     db::{HirDatabase, InternedClosure, InternedClosureId},
     infer::InferenceContext,
     mir::{BorrowKind, MirSpan, MutBorrowKind, ProjectionElem},
     next_solver::{DbInterner, EarlyBinder, GenericArgs, Ty, TyKind},
     traits::FnTrait,
+    Adjust, Adjustment, BindingMode,
 };
 
-// The below functions handle capture and closure kind (Fn, FnMut, ..)
 
+// The below functions handle capture and closure kind (Fn, FnMut, ..)
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub(crate) struct HirPlace<'db> {
     pub(crate) local: BindingId,
 impl<'db> InferenceContext<'_, 'db> {
     fn place_of_expr(&mut self, tgt_expr: ExprId) -> Option<HirPlace<'db>> {
         let r = self.place_of_expr_without_adjust(tgt_expr)?;
-        let adjustments =
-            self.result.expr_adjustments.get(&tgt_expr).map(|it| &**it).unwrap_or_default();
+        let adjustments = self.result.expr_adjustments.get(&tgt_expr).map(|it| &**it).unwrap_or_default();
         apply_adjusts_to_place(&mut self.current_capture_span_stack, r, adjustments)
     }
 
     }
 
     fn push_capture(&mut self, place: HirPlace<'db>, kind: CaptureKind) {
-        self.current_captures.push(CapturedItemWithoutTy {
+        self.current_captures
+            .push(CapturedItemWithoutTy {
             place,
             kind,
             span_stacks: smallvec![self.current_capture_span_stack.iter().copied().collect()],
             None => *result = Some(ck),
         };
 
-        self.walk_pat_inner(
+        self
+            .walk_pat_inner(
             pat,
             &mut update_result,
             BorrowKind::Mut { kind: MutBorrowKind::Default },
     }
 
     fn consume_with_pat(&mut self, mut place: HirPlace<'db>, tgt_pat: PatId) {
-        let adjustments_count =
-            self.result.pat_adjustments.get(&tgt_pat).map(|it| it.len()).unwrap_or_default();
+        let adjustments_count = self.result.pat_adjustments.get(&tgt_pat).map(|it| it.len()).unwrap_or_default();
         place.projections.extend((0..adjustments_count).map(|_| ProjectionElem::Deref));
         self.current_capture_span_stack
             .extend((0..adjustments_count).map(|_| MirSpan::PatId(tgt_pat)));
         self.minimize_captures();
         self.strip_captures_ref_span();
         let result = mem::take(&mut self.current_captures);
-        let captures = result.into_iter().map(|it| it.with_ty(self)).collect::<Vec<_>>();
+        let captures = result.into_iter().map(|it| it.with_ty(self)).collect();
         self.result.closure_info.insert(closure, (captures, closure_kind));
         closure_kind
     }
         &mut self,
     ) -> Vec<(InternedClosureId, Vec<(Ty<'db>, Ty<'db>, Vec<Ty<'db>>, ExprId)>)> {
         let mut deferred_closures = mem::take(&mut self.deferred_closures);
-        let mut dependents_count: FxHashMap<InternedClosureId, usize> =
-            deferred_closures.keys().map(|it| (*it, 0)).collect();
+        let mut dependents_count: FxHashMap<InternedClosureId, usize> = deferred_closures.keys().map(|it| (*it, 0)).collect();
         for deps in self.closure_dependencies.values() {
             for dep in deps {
                 *dependents_count.entry(*dep).or_default() += 1;
             }
         }
-        let mut queue: Vec<_> =
-            deferred_closures.keys().copied().filter(|&it| dependents_count[&it] == 0).collect();
+        let mut queue: Vec<_> = deferred_closures.keys().copied().filter(|&it| dependents_count[&it] == 0).collect();
         let mut result = vec![];
         while let Some(it) = queue.pop() {
             if let Some(d) = deferred_closures.remove(&it) {