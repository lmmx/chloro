COMPARISON DIFF
============================================================

Original size: 52289 bytes
Chloro size:   52263 bytes
Rustfmt size:  52289 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Post-inference closure analysis: captures and closure kind.
 
 use std::{cmp, convert::Infallible, mem};
 
 use either::Either;
 use hir_def::{
-    DefWithBodyId, FieldId, HasModule, TupleFieldId, TupleId, VariantId,
     expr_store::path::Path,
     hir::{
         Array, AsmOperand, BinaryOp, BindingId, CaptureBy, Expr, ExprId, ExprOrPatId, Pat, PatId,
     item_tree::FieldsShape,
     lang_item::LangItem,
     resolver::ValueNs,
+    DefWithBodyId, FieldId, HasModule, TupleFieldId, TupleId, VariantId,
 };
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::inherent::{IntoKind, SliceLike, Ty as _};
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use stdx::{format_to, never};
 use syntax::utils::is_raw_identifier;
 
 use crate::{
-    Adjust, Adjustment, BindingMode,
     db::{HirDatabase, InternedClosure, InternedClosureId},
     infer::InferenceContext,
     mir::{BorrowKind, MirSpan, MutBorrowKind, ProjectionElem},
     next_solver::{DbInterner, EarlyBinder, GenericArgs, Ty, TyKind},
     traits::FnTrait,
+    Adjust, Adjustment, BindingMode,
 };
 
 // The below functions handle capture and closure kind (Fn, FnMut, ..)
-
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub(crate) struct HirPlace<'db> {
     pub(crate) local: BindingId,
 
     fn mutate_path_pat(&mut self, path: &Path, id: PatId) {
         if let Some(place) = self.path_place(path, id.into()) {
+            // Remove the pattern span.
             self.add_capture(
                 place,
                 CaptureKind::ByRef(BorrowKind::Mut { kind: MutBorrowKind::Default }),
             );
-            self.current_capture_span_stack.pop(); // Remove the pattern span.
+            self.current_capture_span_stack.pop();
         }
     }
 
                     }
                 }
                 self.walk_expr(*expr);
-                if let Some(discr_place) = self.place_of_expr(*expr)
-                    && self.is_upvar(&discr_place)
-                {
+                if let Some(discr_place) = self.place_of_expr(*expr) && self.is_upvar(&discr_place) {
                     let mut capture_mode = None;
                     for arm in arms.iter() {
                         self.walk_pat(&mut capture_mode, arm.pat);
         for (closure, exprs) in deferred_closures.into_iter().rev() {
             self.current_captures = vec![];
             let kind = self.analyze_closure(closure);
-
             for (derefed_callee, callee_ty, params, expr) in exprs {
                 if let &Expr::Call { callee, .. } = &self.body[expr] {
                     let mut adjustments =