COMPARISON DIFF
============================================================

Original size: 131517 bytes
Chloro size:   131038 bytes
Rustfmt size:  131517 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module provides a MIR interpreter, which is used in const eval.
 
+mod shim;
+#[cfg(test)]
+mod tests;
+
 use std::{borrow::Cow, cell::RefCell, fmt::Write, iter, mem, ops::Range};
 
-use base_db::{Crate, target::TargetLoadError};
+use base_db::{target::TargetLoadError, Crate};
 use either::Either;
 use hir_def::{
-    AdtId, DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, HasModule, ItemContainerId,
-    Lookup, StaticId, VariantId,
     expr_store::HygieneId,
     item_tree::FieldsShape,
     lang_item::LangItem,
     layout::{TagEncoding, Variants},
     resolver::{HasResolver, TypeNs, ValueNs},
     signatures::{StaticFlags, StructFlags},
+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, HasModule, ItemContainerId,
+    Lookup, StaticId, VariantId,
 };
-use hir_expand::{InFile, mod_path::path, name::Name};
+use hir_expand::{mod_path::path, name::Name, InFile};
 use intern::sym;
 use la_arena::ArenaMap;
 use rustc_abi::TargetDataLayout;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use rustc_ast_ir::Mutability;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::{
-    AliasTyKind,
     inherent::{AdtDef, IntoKind, Region as _, SliceLike, Ty as _},
+    AliasTyKind,
 };
 use span::FileId;
 use stdx::never;
 use syntax::{SyntaxNodePtr, TextRange};
 use triomphe::Arc;
+use Address::*;
 
 use crate::{
-    CallableDefId, ComplexMemoryMap, MemoryMap, TraitEnvironment,
-    consteval::{self, ConstEvalError, try_const_usize},
+    consteval::{self, try_const_usize, ConstEvalError},
     db::{HirDatabase, InternedClosure, InternedClosureId},
     display::{ClosureStyle, DisplayTarget, HirDisplay},
     infer::PointerCast,
     layout::{Layout, LayoutError, RustcEnumVariantIdx},
     method_resolution::{is_dyn_method, lookup_impl_const},
     next_solver::{
-        Const, ConstBytes, ConstKind, DbInterner, ErrorGuaranteed, GenericArgs, Region,
-        SolverDefId, Ty, TyKind, TypingMode, UnevaluatedConst, ValueConst,
         infer::{DbInternerInferExt, InferCtxt, traits::ObligationCause},
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Const, ConstBytes, ConstKind, DbInterner,
+        ErrorGuaranteed, GenericArgs, Region, SolverDefId, Ty, TyKind, TypingMode,
+        UnevaluatedConst, ValueConst,
     },
     traits::FnTrait,
     utils::detect_variant_from_bytes,
+    CallableDefId, ComplexMemoryMap, MemoryMap, TraitEnvironment,
 };
-
 use super::{
-    AggregateKind, BasicBlockId, BinOp, CastKind, LocalId, MirBody, MirLowerError, MirSpan,
-    Operand, OperandKind, Place, PlaceElem, ProjectionElem, ProjectionStore, Rvalue, StatementKind,
-    TerminatorKind, UnOp, return_slot,
+    return_slot, AggregateKind, BasicBlockId, BinOp, CastKind, LocalId, MirBody, MirLowerError,
+    MirSpan, Operand, OperandKind, Place, PlaceElem, ProjectionElem, ProjectionStore, Rvalue,
+    StatementKind, TerminatorKind, UnOp,
 };
 
-mod shim;
-#[cfg(test)]
-mod tests;
-
 macro_rules! from_bytes {
     ($ty:tt, $value:expr) => {
         ($ty::from_le_bytes(match ($value).try_into() {
 }
 
 impl<'db> VTableMap<'db> {
-    const OFFSET: usize = 1000; // We should add some offset to ids to make 0 (null) an invalid id.
+    const OFFSET: usize = 1000;
+    // We should add some offset to ids to make 0 (null) an invalid id.
 
     fn id(&mut self, ty: Ty<'db>) -> usize {
         if let Some(it) = self.ty_to_id.get(&ty) {
     Invalid(usize),
 }
 
-use Address::*;
-
 #[derive(Debug, Clone, Copy)]
 struct Interval {
     addr: Address,
     }
 
     fn slice(self, range: Range<usize>) -> Interval {
-        Interval { addr: self.addr.offset(range.start), size: range.len() }
+        Interval {
+            addr: self.addr.offset(range.start),
+            size: range.len(),
+        }
     }
 }
 
 
 #[cfg(target_pointer_width = "64")]
 const STACK_OFFSET: usize = 1 << 60;
+
 #[cfg(target_pointer_width = "64")]
 const HEAP_OFFSET: usize = 1 << 59;
 
 #[cfg(target_pointer_width = "32")]
 const STACK_OFFSET: usize = 1 << 30;
+
 #[cfg(target_pointer_width = "32")]
 const HEAP_OFFSET: usize = 1 << 29;
 
     TypeIsUnsized(Ty<'db>, &'static str),
     NotSupported(String),
     InvalidConst(Const<'db>),
-    InFunction(
-        Box<MirEvalError<'db>>,
-        Vec<(Either<FunctionId, InternedClosureId>, MirSpan, DefWithBodyId)>,
-    ),
+    InFunction(Box<MirEvalError<'db>>, Vec<(Either<FunctionId, InternedClosureId>, MirSpan, DefWithBodyId)>),
     ExecutionLimitExceeded,
     StackOverflow,
     /// FIXME: Fold this into InternalError
     pub fn stdout(&self) -> Cow<'_, str> {
         String::from_utf8_lossy(&self.stdout)
     }
+
     pub fn stderr(&self) -> Cow<'_, str> {
         String::from_utf8_lossy(&self.stderr)
     }
 pub fn interpret_mir<'db>(
     db: &'db dyn HirDatabase,
     body: Arc<MirBody<'db>>,
-    // FIXME: This is workaround. Ideally, const generics should have a separate body (issue #7434), but now
-    // they share their body with their parent, so in MIR lowering we have locals of the parent body, which
-    // might have placeholders. With this argument, we (wrongly) assume that every placeholder type has
-    // a zero size, hoping that they are all outside of our current body. Even without a fix for #7434, we can
-    // (and probably should) do better here, for example by excluding bindings outside of the target expression.
     assert_placeholder_ty_is_unused: bool,
     trait_env: Option<Arc<TraitEnvironment<'db>>>,
 ) -> Result<'db, (Result<'db, Const<'db>>, MirOutput)> {
         };
         Ok(Const::new_valtree(evaluator.interner(), ty, bytes, memory_map))
     })();
-    Ok((it, MirOutput { stdout: evaluator.stdout, stderr: evaluator.stderr }))
+    Ok((it, MirOutput {
+        stdout: evaluator.stdout,
+        stderr: evaluator.stderr,
+    }))
 }
 
 #[cfg(test)]
 const EXECUTION_LIMIT: usize = 100_000;
+
 #[cfg(not(test))]
 const EXECUTION_LIMIT: usize = 10_000_000;
 
 
     fn place_interval(&self, p: &Place<'db>, locals: &Locals<'db>) -> Result<'db, Interval> {
         let place_addr_and_ty = self.place_addr_and_ty_and_metadata(p, locals)?;
-        Ok(Interval {
+        Ok(
+            Interval {
             addr: place_addr_and_ty.0,
             size: self.size_of_sized(
                 place_addr_and_ty.1,
                 locals,
                 "Type of place that we need its interval",
             )?,
-        })
+        },
+        )
     }
 
     fn ptr_size(&self) -> usize {
     ) -> Result<'db, (Address, Ty<'db>, Option<IntervalOrOwned>)> {
         let mut addr = locals.ptr[p.local].addr;
         let mut ty: Ty<'db> = locals.body.locals[p.local].ty;
-        let mut metadata: Option<IntervalOrOwned> = None; // locals are always sized
+        let mut metadata: Option<IntervalOrOwned> = None;
+        // locals are always sized
         for proj in p.projection.lookup(&locals.body.projection_store) {
             let prev_ty = ty;
             ty = self.projected_ty(ty, proj.clone());
         o: &Operand<'db>,
         locals: &mut Locals<'db>,
     ) -> Result<'db, IntervalAndTy<'db>> {
-        Ok(IntervalAndTy {
+        Ok(
+            IntervalAndTy {
             interval: self.eval_operand(o, locals)?,
             ty: self.operand_ty(o, locals)?,
-        })
+        },
+        )
     }
 
     fn interpret_mir(
 
     fn construct_with_layout(
         &mut self,
-        size: usize, // Not necessarily equal to variant_layout.size
+        size: usize,
         variant_layout: &Layout,
         tag: Option<(usize, usize, i128)>,
         values: impl Iterator<Item = IntervalOrOwned>,
 
     fn eval_place(&mut self, p: &Place<'db>, locals: &Locals<'db>) -> Result<'db, Interval> {
         let addr = self.place_addr(p, locals)?;
-        Ok(Interval::new(
+        Ok(
+            Interval::new(
             addr,
             self.size_of_sized(self.place_ty(p, locals)?, locals, "type of this place")?,
-        ))
+        ),
+        )
     }
 
     fn read_memory(&self, addr: Address, size: usize) -> Result<'db, &[u8]> {
         }
         for_each_int_type! { m, [] }
     }
-
     for_each_int_type!(checked_int_op, [checked_add]);
     for_each_int_type!(checked_int_op, [checked_sub]);
     for_each_int_type!(checked_int_op, [checked_div]);
     for_each_int_type!(checked_int_op, [checked_rem]);
     for_each_int_type!(checked_int_op, [checked_mul]);
-
     for_each_int_type!(int_bit_shifts, [checked_shl]);
     for_each_int_type!(int_bit_shifts, [checked_shr]);
 }
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitand, &]);
 }
+
 impl std::ops::BitOr for IntValue {
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitor, |]);
 }
+
 impl std::ops::BitXor for IntValue {
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitxor, ^]);