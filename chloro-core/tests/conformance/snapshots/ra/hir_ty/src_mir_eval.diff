COMPARISON DIFF
============================================================

Original size: 131517 bytes
Chloro size:   130855 bytes
Rustfmt size:  131517 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 }
 
 impl<'db> VTableMap<'db> {
-    const OFFSET: usize = 1000; // We should add some offset to ids to make 0 (null) an invalid id.
+    const OFFSET: usize = 1000;
+    // We should add some offset to ids to make 0 (null) an invalid id.
 
     fn id(&mut self, ty: Ty<'db>) -> usize {
         if let Some(it) = self.ty_to_id.get(&ty) {
 }
 
 #[derive(Debug, Default, Clone, PartialEq, Eq)]
-struct TlsData {
-    keys: Vec<u128>,
-}
+struct TlsData { keys: Vec<u128> }
 
 impl TlsData {
     fn create_key(&mut self) -> usize {
     }
 
     fn slice(self, range: Range<usize>) -> Interval {
-        Interval { addr: self.addr.offset(range.start), size: range.len() }
+        Interval {
+            addr: self.addr.offset(range.start),
+            size: range.len(),
+        }
     }
 }
 
 
 #[cfg(target_pointer_width = "64")]
 const STACK_OFFSET: usize = 1 << 60;
+
 #[cfg(target_pointer_width = "64")]
 const HEAP_OFFSET: usize = 1 << 59;
 
 #[cfg(target_pointer_width = "32")]
 const STACK_OFFSET: usize = 1 << 30;
+
 #[cfg(target_pointer_width = "32")]
 const HEAP_OFFSET: usize = 1 << 29;
 
     TypeIsUnsized(Ty<'db>, &'static str),
     NotSupported(String),
     InvalidConst(Const<'db>),
-    InFunction(
-        Box<MirEvalError<'db>>,
-        Vec<(Either<FunctionId, InternedClosureId>, MirSpan, DefWithBodyId)>,
-    ),
+    InFunction(Box<MirEvalError<'db>>, Vec<(Either<FunctionId, InternedClosureId>, MirSpan, DefWithBodyId)>),
     ExecutionLimitExceeded,
     StackOverflow,
     /// FIXME: Fold this into InternalError
 type Result<'db, T> = std::result::Result<T, MirEvalError<'db>>;
 
 #[derive(Debug, Default)]
-struct DropFlags<'db> {
-    need_drop: FxHashSet<Place<'db>>,
-}
+struct DropFlags<'db> { need_drop: FxHashSet<Place<'db>> }
 
 impl<'db> DropFlags<'db> {
     fn add_place(&mut self, p: Place<'db>, store: &ProjectionStore<'db>) {
     pub fn stdout(&self) -> Cow<'_, str> {
         String::from_utf8_lossy(&self.stdout)
     }
+
     pub fn stderr(&self) -> Cow<'_, str> {
         String::from_utf8_lossy(&self.stderr)
     }
 pub fn interpret_mir<'db>(
     db: &'db dyn HirDatabase,
     body: Arc<MirBody<'db>>,
-    // FIXME: This is workaround. Ideally, const generics should have a separate body (issue #7434), but now
-    // they share their body with their parent, so in MIR lowering we have locals of the parent body, which
-    // might have placeholders. With this argument, we (wrongly) assume that every placeholder type has
-    // a zero size, hoping that they are all outside of our current body. Even without a fix for #7434, we can
-    // (and probably should) do better here, for example by excluding bindings outside of the target expression.
     assert_placeholder_ty_is_unused: bool,
     trait_env: Option<Arc<TraitEnvironment<'db>>>,
 ) -> Result<'db, (Result<'db, Const<'db>>, MirOutput)> {
         };
         Ok(Const::new_valtree(evaluator.interner(), ty, bytes, memory_map))
     })();
-    Ok((it, MirOutput { stdout: evaluator.stdout, stderr: evaluator.stderr }))
+    Ok((it, MirOutput {
+        stdout: evaluator.stdout,
+        stderr: evaluator.stderr,
+    }))
 }
 
 #[cfg(test)]
 const EXECUTION_LIMIT: usize = 100_000;
+
 #[cfg(not(test))]
 const EXECUTION_LIMIT: usize = 10_000_000;
 
             Rvalue::ThreadLocalRef(n)
             | Rvalue::AddressOf(n)
             | Rvalue::BinaryOp(n)
-            | Rvalue::NullaryOp(n) => match *n {},
+            | Rvalue::NullaryOp(n) => match *n {
+            },
         })
     }
 
             }
             Variants::Multiple { tag, tag_encoding, variants, .. } => {
                 let size = tag.size(&*self.target_data_layout).bytes_usize();
-                let offset = layout.fields.offset(0).bytes_usize(); // The only field on enum variants is the tag field
+                let offset = layout.fields.offset(0).bytes_usize();
+                // The only field on enum variants is the tag field
                 let is_signed = tag.is_signed();
                 match tag_encoding {
                     TagEncoding::Direct => {
 
     fn construct_with_layout(
         &mut self,
-        size: usize, // Not necessarily equal to variant_layout.size
+        size: usize,
         variant_layout: &Layout,
         tag: Option<(usize, usize, i128)>,
         values: impl Iterator<Item = IntervalOrOwned>,
                     span,
                 )
             }
-            MirOrDynIndex::Mir(body) => self.exec_looked_up_function(
-                body,
-                locals,
-                def,
-                arg_bytes,
-                span,
-                destination,
-                target_bb,
-            ),
+            MirOrDynIndex::Mir(body) => self.exec_looked_up_function(body, locals, def, arg_bytes, span, destination, target_bb),
         }
     }
 
         }
         for_each_int_type! { m, [] }
     }
-
     for_each_int_type!(checked_int_op, [checked_add]);
     for_each_int_type!(checked_int_op, [checked_sub]);
     for_each_int_type!(checked_int_op, [checked_div]);
     for_each_int_type!(checked_int_op, [checked_rem]);
     for_each_int_type!(checked_int_op, [checked_mul]);
-
     for_each_int_type!(int_bit_shifts, [checked_shl]);
     for_each_int_type!(int_bit_shifts, [checked_shr]);
 }
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitand, &]);
 }
+
 impl std::ops::BitOr for IntValue {
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitor, |]);
 }
+
 impl std::ops::BitXor for IntValue {
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitxor, ^]);