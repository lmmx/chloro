COMPARISON DIFF
============================================================

Original size: 131517 bytes
Chloro size:   129945 bytes
Rustfmt size:  131517 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module provides a MIR interpreter, which is used in const eval.
 
+mod shim;
+#[cfg(test)]
+mod tests;
+
 use std::{borrow::Cow, cell::RefCell, fmt::Write, iter, mem, ops::Range};
 
-use base_db::{Crate, target::TargetLoadError};
+use base_db::{target::TargetLoadError, Crate};
 use either::Either;
 use hir_def::{
-    AdtId, DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, HasModule, ItemContainerId,
-    Lookup, StaticId, VariantId,
     expr_store::HygieneId,
     item_tree::FieldsShape,
     lang_item::LangItem,
     layout::{TagEncoding, Variants},
     resolver::{HasResolver, TypeNs, ValueNs},
     signatures::{StaticFlags, StructFlags},
+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, HasModule, ItemContainerId,
+    Lookup, StaticId, VariantId,
 };
-use hir_expand::{InFile, mod_path::path, name::Name};
+use hir_expand::{mod_path::path, name::Name, InFile};
 use intern::sym;
 use la_arena::ArenaMap;
 use rustc_abi::TargetDataLayout;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use rustc_ast_ir::Mutability;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::{
-    AliasTyKind,
     inherent::{AdtDef, IntoKind, Region as _, SliceLike, Ty as _},
+    AliasTyKind,
 };
 use span::FileId;
 use stdx::never;
 use syntax::{SyntaxNodePtr, TextRange};
 use triomphe::Arc;
+use Address::*;
 
 use crate::{
-    CallableDefId, ComplexMemoryMap, MemoryMap, TraitEnvironment,
-    consteval::{self, ConstEvalError, try_const_usize},
+    consteval::{self, try_const_usize, ConstEvalError},
     db::{HirDatabase, InternedClosure, InternedClosureId},
     display::{ClosureStyle, DisplayTarget, HirDisplay},
     infer::PointerCast,
     layout::{Layout, LayoutError, RustcEnumVariantIdx},
     method_resolution::{is_dyn_method, lookup_impl_const},
     next_solver::{
-        Const, ConstBytes, ConstKind, DbInterner, ErrorGuaranteed, GenericArgs, Region,
-        SolverDefId, Ty, TyKind, TypingMode, UnevaluatedConst, ValueConst,
         infer::{DbInternerInferExt, InferCtxt, traits::ObligationCause},
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Const, ConstBytes, ConstKind, DbInterner,
+        ErrorGuaranteed, GenericArgs, Region, SolverDefId, Ty, TyKind, TypingMode,
+        UnevaluatedConst, ValueConst,
     },
     traits::FnTrait,
     utils::detect_variant_from_bytes,
+    CallableDefId, ComplexMemoryMap, MemoryMap, TraitEnvironment,
 };
-
 use super::{
-    AggregateKind, BasicBlockId, BinOp, CastKind, LocalId, MirBody, MirLowerError, MirSpan,
-    Operand, OperandKind, Place, PlaceElem, ProjectionElem, ProjectionStore, Rvalue, StatementKind,
-    TerminatorKind, UnOp, return_slot,
+    return_slot, AggregateKind, BasicBlockId, BinOp, CastKind, LocalId, MirBody, MirLowerError,
+    MirSpan, Operand, OperandKind, Place, PlaceElem, ProjectionElem, ProjectionStore, Rvalue,
+    StatementKind, TerminatorKind, UnOp,
 };
 
-mod shim;
-#[cfg(test)]
-mod tests;
-
 macro_rules! from_bytes {
     ($ty:tt, $value:expr) => {
         ($ty::from_le_bytes(match ($value).try_into() {
 }
 
 impl<'db> VTableMap<'db> {
-    const OFFSET: usize = 1000; // We should add some offset to ids to make 0 (null) an invalid id.
+    const OFFSET: usize = 1000;
+    // We should add some offset to ids to make 0 (null) an invalid id.
 
     fn id(&mut self, ty: Ty<'db>) -> usize {
         if let Some(it) = self.ty_to_id.get(&ty) {
     }
 
     pub(crate) fn ty(&self, id: usize) -> Result<'db, Ty<'db>> {
-        id.checked_sub(VTableMap::OFFSET)
-            .and_then(|id| self.id_to_ty.get(id).copied())
-            .ok_or(MirEvalError::InvalidVTableId(id))
+        id.checked_sub(VTableMap::OFFSET).and_then(|id| self.id_to_ty.get(id).copied()).ok_or(
+            MirEvalError::InvalidVTableId(id),
+        )
     }
 
     fn ty_of_bytes(&self, bytes: &[u8]) -> Result<'db, Ty<'db>> {
     Invalid(usize),
 }
 
-use Address::*;
-
 #[derive(Debug, Clone, Copy)]
 struct Interval {
     addr: Address,
     }
 
     fn slice(self, range: Range<usize>) -> Interval {
-        Interval { addr: self.addr.offset(range.start), size: range.len() }
+        Interval {
+            addr: self.addr.offset(range.start),
+            size: range.len(),
+        }
     }
 }
 
 
 #[cfg(target_pointer_width = "64")]
 const STACK_OFFSET: usize = 1 << 60;
+
 #[cfg(target_pointer_width = "64")]
 const HEAP_OFFSET: usize = 1 << 59;
 
 #[cfg(target_pointer_width = "32")]
 const STACK_OFFSET: usize = 1 << 30;
+
 #[cfg(target_pointer_width = "32")]
 const HEAP_OFFSET: usize = 1 << 29;
 
     TypeIsUnsized(Ty<'db>, &'static str),
     NotSupported(String),
     InvalidConst(Const<'db>),
-    InFunction(
-        Box<MirEvalError<'db>>,
-        Vec<(Either<FunctionId, InternedClosureId>, MirSpan, DefWithBodyId)>,
-    ),
+    InFunction(Box<MirEvalError<'db>>, Vec<(Either<FunctionId, InternedClosureId>, MirSpan, DefWithBodyId)>),
     ExecutionLimitExceeded,
     StackOverflow,
     /// FIXME: Fold this into InternalError
         match self {
             Self::ConstEvalError(arg0, arg1) => {
                 f.debug_tuple("ConstEvalError").field(arg0).field(arg1).finish()
-            }
+            },
             Self::LayoutError(arg0, arg1) => {
                 f.debug_tuple("LayoutError").field(arg0).field(arg1).finish()
-            }
+            },
             Self::UndefinedBehavior(arg0) => {
                 f.debug_tuple("UndefinedBehavior").field(arg0).finish()
-            }
+            },
             Self::Panic(msg) => write!(f, "Panic with message:\n{msg:?}"),
             Self::TargetDataLayoutNotAvailable(arg0) => {
                 f.debug_tuple("TargetDataLayoutNotAvailable").field(arg0).finish()
-            }
+            },
             Self::TypeIsUnsized(ty, it) => write!(f, "{ty:?} is unsized. {it} should be sized."),
             Self::ExecutionLimitExceeded => write!(f, "execution limit exceeded"),
             Self::StackOverflow => write!(f, "stack overflow"),
             Self::MirLowerError(arg0, arg1) => {
                 f.debug_tuple("MirLowerError").field(arg0).field(arg1).finish()
-            }
+            },
             Self::MirLowerErrorForClosure(arg0, arg1) => {
                 f.debug_tuple("MirLowerError").field(arg0).field(arg1).finish()
-            }
+            },
             Self::CoerceUnsizedError(arg0) => {
                 f.debug_tuple("CoerceUnsizedError").field(arg0).finish()
-            }
+            },
             Self::InternalError(arg0) => f.debug_tuple("InternalError").field(arg0).finish(),
             Self::InvalidVTableId(arg0) => f.debug_tuple("InvalidVTableId").field(arg0).finish(),
             Self::NotSupported(arg0) => f.debug_tuple("NotSupported").field(arg0).finish(),
             Self::InvalidConst(arg0) => f.debug_tuple("InvalidConst").field(&arg0).finish(),
             Self::InFunction(e, stack) => {
                 f.debug_struct("WithStack").field("error", e).field("stack", &stack).finish()
-            }
+            },
         }
     }
 }
     pub fn stdout(&self) -> Cow<'_, str> {
         String::from_utf8_lossy(&self.stdout)
     }
+
     pub fn stderr(&self) -> Cow<'_, str> {
         String::from_utf8_lossy(&self.stderr)
     }
 pub fn interpret_mir<'db>(
     db: &'db dyn HirDatabase,
     body: Arc<MirBody<'db>>,
-    // FIXME: This is workaround. Ideally, const generics should have a separate body (issue #7434), but now
-    // they share their body with their parent, so in MIR lowering we have locals of the parent body, which
-    // might have placeholders. With this argument, we (wrongly) assume that every placeholder type has
-    // a zero size, hoping that they are all outside of our current body. Even without a fix for #7434, we can
-    // (and probably should) do better here, for example by excluding bindings outside of the target expression.
     assert_placeholder_ty_is_unused: bool,
     trait_env: Option<Arc<TraitEnvironment<'db>>>,
 ) -> Result<'db, (Result<'db, Const<'db>>, MirOutput)> {
         };
         Ok(Const::new_valtree(evaluator.interner(), ty, bytes, memory_map))
     })();
-    Ok((it, MirOutput { stdout: evaluator.stdout, stderr: evaluator.stderr }))
+    Ok((it, MirOutput {
+        stdout: evaluator.stdout,
+        stderr: evaluator.stderr,
+    }))
 }
 
 #[cfg(test)]
 const EXECUTION_LIMIT: usize = 100_000;
+
 #[cfg(not(test))]
 const EXECUTION_LIMIT: usize = 10_000_000;
 
     ) -> Result<'db, (Address, Ty<'db>, Option<IntervalOrOwned>)> {
         let mut addr = locals.ptr[p.local].addr;
         let mut ty: Ty<'db> = locals.body.locals[p.local].ty;
-        let mut metadata: Option<IntervalOrOwned> = None; // locals are always sized
+        let mut metadata: Option<IntervalOrOwned> = None;
+        // locals are always sized
         for proj in p.projection.lookup(&locals.body.projection_store) {
             let prev_ty = ty;
             ty = self.projected_ty(ty, proj.clone());
                     ty,
                     Mutability::Not,
                 )
-            }
+            },
         })
     }
 
                     self.code_stack = prev_code_stack;
                     self.stack_depth_limit += 1;
                     return Ok(return_interval);
-                }
+                },
                 Some(bb) => {
-                    // We don't support const promotion, so we can't truncate the stack yet.
                     let _ = my_stack_frame.prev_stack_ptr;
-                    // self.stack.truncate(my_stack_frame.prev_stack_ptr);
                     current_block_idx = bb;
-                }
+                },
             }
         }
     }
                     r.extend(metadata.get(self)?);
                 }
                 Owned(r)
-            }
+            },
             Rvalue::Len(p) => {
                 let (_, _, metadata) = self.place_addr_and_ty_and_metadata(p, locals)?;
                 match metadata {
                         return Err(MirEvalError::InternalError(
                             "type without metadata is used for Rvalue::Len".into(),
                         ));
-                    }
+                    },
                 }
-            }
+            },
             Rvalue::UnaryOp(op, val) => {
                 let mut c = self.eval_operand(val, locals)?.get(self)?;
                 let mut ty = self.operand_ty(val, locals)?;
                         rustc_type_ir::FloatTy::F16 => {
                             let c = -from_bytes!(f16, u16, c);
                             Owned(u16::try_from(c.to_bits()).unwrap().to_le_bytes().into())
-                        }
+                        },
                         rustc_type_ir::FloatTy::F32 => {
                             let c = -from_bytes!(f32, c);
                             Owned(c.to_le_bytes().into())
-                        }
+                        },
                         rustc_type_ir::FloatTy::F64 => {
                             let c = -from_bytes!(f64, c);
                             Owned(c.to_le_bytes().into())
-                        }
+                        },
                         rustc_type_ir::FloatTy::F128 => {
                             let c = -from_bytes!(f128, u128, c);
                             Owned(c.to_bits().to_le_bytes().into())
-                        }
+                        },
                     }
                 } else {
                     let mut c = c.to_vec();
                     }
                     Owned(c)
                 }
-            }
+            },
             Rvalue::CheckedBinaryOp(op, lhs, rhs) => 'binary_op: {
                 let lc = self.eval_operand(lhs, locals)?;
                 let rc = self.eval_operand(rhs, locals)?;
                                 | BinOp::Ne => {
                                     let r = op.run_compare(l, r) as u8;
                                     Owned(vec![r])
-                                }
+                                },
                                 BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div => {
                                     let r = match op {
                                         BinOp::Add => l + r,
                                         _ => unreachable!(),
                                     };
                                     Owned(
-                                        u16::try_from(r.value.to_bits())
-                                            .unwrap()
-                                            .to_le_bytes()
-                                            .into(),
+                                        u16::try_from(r.value.to_bits()).unwrap().to_le_bytes().into(),
                                     )
-                                }
+                                },
                                 it => not_supported!(
                                     "invalid binop {it:?} on floating point operators"
                                 ),
                             }
-                        }
+                        },
                         rustc_type_ir::FloatTy::F32 => {
                             let l = from_bytes!(f32, lc);
                             let r = from_bytes!(f32, rc);
                                 | BinOp::Ne => {
                                     let r = op.run_compare(l, r) as u8;
                                     Owned(vec![r])
-                                }
+                                },
                                 BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div => {
                                     let r = match op {
                                         BinOp::Add => l + r,
                                         _ => unreachable!(),
                                     };
                                     Owned(r.to_le_bytes().into())
-                                }
+                                },
                                 it => not_supported!(
                                     "invalid binop {it:?} on floating point operators"
                                 ),
                             }
-                        }
+                        },
                         rustc_type_ir::FloatTy::F64 => {
                             let l = from_bytes!(f64, lc);
                             let r = from_bytes!(f64, rc);
                                 | BinOp::Ne => {
                                     let r = op.run_compare(l, r) as u8;
                                     Owned(vec![r])
-                                }
+                                },
                                 BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div => {
                                     let r = match op {
                                         BinOp::Add => l + r,
                                         _ => unreachable!(),
                                     };
                                     Owned(r.to_le_bytes().into())
-                                }
+                                },
                                 it => not_supported!(
                                     "invalid binop {it:?} on floating point operators"
                                 ),
                             }
-                        }
+                        },
                         rustc_type_ir::FloatTy::F128 => {
                             let l = from_bytes!(f128, u128, lc);
                             let r = from_bytes!(f128, u128, rc);
                                 | BinOp::Ne => {
                                     let r = op.run_compare(l, r) as u8;
                                     Owned(vec![r])
-                                }
+                                },
                                 BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div => {
                                     let r = match op {
                                         BinOp::Add => l + r,
                                         _ => unreachable!(),
                                     };
                                     Owned(r.value.to_bits().to_le_bytes().into())
-                                }
+                                },
                                 it => not_supported!(
                                     "invalid binop {it:?} on floating point operators"
                                 ),
                             }
-                        }
+                        },
                     }
                 } else {
                     let is_signed = matches!(ty.kind(), TyKind::Int(_));
                         BinOp::Ge | BinOp::Gt | BinOp::Le | BinOp::Lt | BinOp::Eq | BinOp::Ne => {
                             let r = op.run_compare(l128, r128) as u8;
                             Owned(vec![r])
-                        }
+                        },
                         BinOp::BitAnd
                         | BinOp::BitOr
                         | BinOp::BitXor
                                 _ => unreachable!(),
                             };
                             Owned(r.to_bytes())
-                        }
+                        },
                         BinOp::Shl | BinOp::Shr => {
                             let r = 'b: {
                                 if let Some(shift_amount) = r128.as_u32() {
                                 return Err(MirEvalError::Panic(format!("Overflow in {op:?}")));
                             };
                             Owned(r.to_bytes())
-                        }
+                        },
                         BinOp::Offset => not_supported!("offset binop"),
                     }
                 }
-            }
+            },
             Rvalue::Discriminant(p) => {
                 let ty = self.place_ty(p, locals)?;
                 let bytes = self.eval_place(p, locals)?.get(self)?;
                 let result = self.compute_discriminant(ty, bytes)?;
                 Owned(result.to_le_bytes().to_vec())
-            }
+            },
             Rvalue::Repeat(it, len) => {
                 let len = match try_const_usize(self.db, *len) {
                     Some(it) => it as usize,
                 let val = self.eval_operand(it, locals)?.get(self)?;
                 let size = len * val.len();
                 Owned(val.iter().copied().cycle().take(size).collect())
-            }
+            },
             Rvalue::ShallowInitBox(_, _) => not_supported!("shallow init box"),
             Rvalue::ShallowInitBoxWithAlloc(ty) => {
                 let Some((size, align)) = self.size_align_of(*ty, locals)? else {
                 };
                 let addr = self.heap_allocate(size, align)?;
                 Owned(addr.to_bytes().to_vec())
-            }
+            },
             Rvalue::CopyForDeref(_) => not_supported!("copy for deref"),
             Rvalue::Aggregate(kind, values) => {
                 let values = values
                             r.extend(value);
                         }
                         Owned(r)
-                    }
+                    },
                     AggregateKind::Tuple(ty) => {
                         let layout = self.layout(*ty)?;
                         Owned(self.construct_with_layout(
                             None,
                             values.iter().map(|&it| it.into()),
                         )?)
-                    }
+                    },
                     AggregateKind::Union(it, f) => {
                         let layout = self.layout_adt(
                             (*it).into(),
                         let mut result = vec![0; layout.size.bytes_usize()];
                         result[offset..offset + op.len()].copy_from_slice(op);
                         Owned(result)
-                    }
+                    },
                     AggregateKind::Adt(it, subst) => {
                         let (size, variant_layout, tag) =
                             self.layout_of_variant(*it, *subst, locals)?;
                             tag,
                             values.iter().map(|&it| it.into()),
                         )?)
-                    }
+                    },
                     AggregateKind::Closure(ty) => {
                         let layout = self.layout(*ty)?;
                         Owned(self.construct_with_layout(
                             None,
                             values.iter().map(|&it| it.into()),
                         )?)
-                    }
+                    },
                 }
-            }
+            },
             Rvalue::Cast(kind, operand, target_ty) => match kind {
                 CastKind::PointerCoercion(cast) => match cast {
                     PointerCast::ReifyFnPointer | PointerCast::ClosureFnPointer(_) => {
                                 "creating a fn pointer from a non FnDef or Closure type"
                             );
                         }
-                    }
+                    },
                     PointerCast::Unsize => {
                         let current_ty = self.operand_ty(operand, locals)?;
                         let addr = self.eval_operand(operand, locals)?;
                         self.coerce_unsized(addr, current_ty, *target_ty)?
-                    }
+                    },
                     PointerCast::MutToConstPointer | PointerCast::UnsafeFnPointer => {
-                        // This is no-op
                         Borrowed(self.eval_operand(operand, locals)?)
-                    }
+                    },
                     PointerCast::ArrayToPointer => {
-                        // We should remove the metadata part if the current type is slice
                         Borrowed(self.eval_operand(operand, locals)?.slice(0..self.ptr_size()))
-                    }
+                    },
                 },
                 CastKind::DynStar => not_supported!("dyn star cast"),
                 CastKind::IntToInt
                     let dest_size =
                         self.size_of_sized(*target_ty, locals, "destination of int to int cast")?;
                     Owned(current[0..dest_size].to_vec())
-                }
+                },
                 CastKind::FloatToInt => {
                     let ty = self.operand_ty(operand, locals)?;
                     let TyKind::Float(ty) = ty.kind() else {
                     let value = (value as i128).min(max).max(min);
                     let result = value.to_le_bytes();
                     Owned(result[0..dest_size].to_vec())
-                }
+                },
                 CastKind::FloatToFloat => {
                     let ty = self.operand_ty(operand, locals)?;
                     let TyKind::Float(ty) = ty.kind() else {
                         rustc_type_ir::FloatTy::F64 => Owned((value as f64).to_le_bytes().to_vec()),
                         rustc_type_ir::FloatTy::F16 | rustc_type_ir::FloatTy::F128 => {
                             not_supported!("unstable floating point type f16 and f128");
-                        }
+                        },
                     }
-                }
+                },
                 CastKind::IntToFloat => {
                     let current_ty = self.operand_ty(operand, locals)?;
                     let is_signed = matches!(current_ty.kind(), TyKind::Int(_));
                         rustc_type_ir::FloatTy::F64 => Owned((value as f64).to_le_bytes().to_vec()),
                         rustc_type_ir::FloatTy::F16 | rustc_type_ir::FloatTy::F128 => {
                             not_supported!("unstable floating point type f16 and f128");
-                        }
+                        },
                     }
-                }
+                },
                 CastKind::FnPtrToPtr => not_supported!("fn ptr to ptr cast"),
             },
             Rvalue::ThreadLocalRef(n)
             | Rvalue::AddressOf(n)
             | Rvalue::BinaryOp(n)
-            | Rvalue::NullaryOp(n) => match *n {},
+            | Rvalue::NullaryOp(n) => match *n {
+            },
         })
     }
 
                 let r =
                     self.const_eval_discriminant(e.enum_variants(self.db).variants[index.0].0)?;
                 Ok(r)
-            }
+            },
             Variants::Multiple { tag, tag_encoding, variants, .. } => {
                 let size = tag.size(&*self.target_data_layout).bytes_usize();
-                let offset = layout.fields.offset(0).bytes_usize(); // The only field on enum variants is the tag field
+                let offset = layout.fields.offset(0).bytes_usize();
                 let is_signed = tag.is_signed();
                 match tag_encoding {
                     TagEncoding::Direct => {
                         let tag = &bytes[offset..offset + size];
                         Ok(i128::from_le_bytes(pad16(tag, is_signed)))
-                    }
+                    },
                     TagEncoding::Niche { untagged_variant, niche_start, .. } => {
                         let tag = &bytes[offset..offset + size];
                         let candidate_tag = i128::from_le_bytes(pad16(tag, is_signed))
                         let result =
                             self.const_eval_discriminant(e.enum_variants(self.db).variants[idx].0)?;
                         Ok(result)
-                    }
+                    },
                 }
-            }
+            },
         }
     }
 
                     r.extend(addr.iter().copied());
                     r.extend(len.to_le_bytes());
                     Owned(r)
-                }
+                },
                 t => {
                     not_supported!("slice unsizing from non array type {t:?}")
-                }
+                },
             },
             TyKind::Dynamic(..) => {
                 let vtable = self.vtable_map.id(current_ty);
                 r.extend(addr.iter().copied());
                 r.extend(vtable.to_le_bytes());
                 Owned(r)
-            }
+            },
             TyKind::Adt(adt_def, target_subst) => match &current_ty.kind() {
                 TyKind::Adt(current_adt_def, current_subst) => {
                     let id = adt_def.def_id().0;
                         current_last_field,
                         addr,
                     );
-                }
+                },
                 _ => not_supported!("unsizing struct with non adt type"),
             },
             _ => not_supported!("unknown unsized cast"),
                     layout.size.bytes_usize(),
                     Arc::new(variant_layout),
                     if have_tag {
-                        Some((
-                            layout.fields.offset(0).bytes_usize(),
-                            tag.size(&*self.target_data_layout).bytes_usize(),
-                            discriminant,
-                        ))
-                    } else {
-                        None
-                    },
+                    Some((
+                        layout.fields.offset(0).bytes_usize(),
+                        tag.size(&*self.target_data_layout).bytes_usize(),
+                        discriminant,
+                    ))
+                } else {
+                    None
+                },
                 )
-            }
+            },
         })
     }
 
     fn construct_with_layout(
         &mut self,
-        size: usize, // Not necessarily equal to variant_layout.size
+        size: usize,
         variant_layout: &Layout,
         tag: Option<(usize, usize, i128)>,
         values: impl Iterator<Item = IntervalOrOwned>,
             OperandKind::Copy(p) | OperandKind::Move(p) => {
                 locals.drop_flags.remove_place(p, &locals.body.projection_store);
                 self.eval_place(p, locals)?
-            }
+            },
             OperandKind::Static(st) => {
                 let addr = self.eval_static(*st, locals)?;
                 Interval::new(addr, self.ptr_size())
-            }
+            },
             OperandKind::Constant { konst, .. } => self.allocate_const_in_heap(locals, *konst)?,
         })
     }
                 )));
             }
         };
-        mem.get(pos..pos + size)
-            .ok_or_else(|| MirEvalError::UndefinedBehavior("out of bound memory read".to_owned()))
+        mem.get(pos..pos + size).ok_or_else(
+            || MirEvalError::UndefinedBehavior("out of bound memory read".to_owned()),
+        )
     }
 
     fn write_memory_using_ref(&mut self, addr: Address, size: usize) -> Result<'db, &mut [u8]> {
                 )));
             }
         };
-        mem.get_mut(pos..pos + size)
-            .ok_or_else(|| MirEvalError::UndefinedBehavior("out of bound memory write".to_owned()))
+        mem.get_mut(pos..pos + size).ok_or_else(
+            || MirEvalError::UndefinedBehavior("out of bound memory write".to_owned()),
+        )
     }
 
     fn write_memory(&mut self, addr: Address, r: &[u8]) -> Result<'db, ()> {
         match next_ty.kind() {
             TyKind::FnDef(def, generic_args) => {
                 self.exec_fn_def(def.0, generic_args, destination, args, locals, target_bb, span)
-            }
+            },
             TyKind::Closure(id, generic_args) => self.exec_closure(
                 id.0,
                 bytes.slice(0..0),
                     target_bb,
                     span,
                 )
-            }
+            },
             CallableDefId::StructId(id) => {
                 let (size, variant_layout, tag) =
                     self.layout_of_variant(id.into(), generic_args, locals)?;
                 )?;
                 destination.write_from_bytes(self, &result)?;
                 Ok(None)
-            }
+            },
             CallableDefId::EnumVariantId(id) => {
                 let (size, variant_layout, tag) =
                     self.layout_of_variant(id.into(), generic_args, locals)?;
                 )?;
                 destination.write_from_bytes(self, &result)?;
                 Ok(None)
-            }
+            },
         }
     }
 
         let arg_bytes = args.iter().map(|it| IntervalOrOwned::Borrowed(it.interval));
         match self.get_mir_or_dyn_index(def, generic_args, locals, span)? {
             MirOrDynIndex::Dyn(self_ty_idx) => {
-                // In the layout of current possible receiver, which at the moment of writing this code is one of
-                // `&T`, `&mut T`, `Box<T>`, `Rc<T>`, `Arc<T>`, and `Pin<P>` where `P` is one of possible receivers,
-                // the vtable is exactly in the `[ptr_size..2*ptr_size]` bytes. So we can use it without branching on
-                // the type.
                 let first_arg = arg_bytes.clone().next().unwrap();
                 let first_arg = first_arg.get(self)?;
                 let ty = self
                     target_bb,
                     span,
                 )
-            }
-            MirOrDynIndex::Mir(body) => self.exec_looked_up_function(
-                body,
-                locals,
-                def,
-                arg_bytes,
-                span,
-                destination,
-                target_bb,
-            ),
+            },
+            MirOrDynIndex::Mir(body) => self.exec_looked_up_function(body, locals, def, arg_bytes, span, destination, target_bb),
         }
     }
 
         match func_ty.kind() {
             TyKind::FnDef(def, subst) => {
                 self.exec_fn_def(def.0, subst, destination, &args[1..], locals, target_bb, span)
-            }
+            },
             TyKind::FnPtr(..) => {
                 self.exec_fn_pointer(func_data, destination, &args[1..], locals, target_bb, span)
-            }
+            },
             TyKind::Closure(closure, subst) => self.exec_closure(
                 closure.0,
                 func_data,
                 span,
             ),
             _ => {
-                // try to execute the manual impl of `FnTrait` for structs (nightly feature used in std)
                 let arg0 = func;
                 let args = &args[1..];
                 let arg1 = {
                     target_bb,
                     span,
                 )
-            }
+            },
         }
     }
 
                         .display(db, edition),
                 );
                 Err(MirEvalError::ConstEvalError(name, Box::new(e)))
-            }
+            },
         }
     }
 
             (len, is_signed) => {
                 never!("invalid integer size: {len}, signed: {is_signed}");
                 Self::I32(0)
-            }
+            },
         }
     }
 
         }
         for_each_int_type! { m, [] }
     }
-
     for_each_int_type!(checked_int_op, [checked_add]);
     for_each_int_type!(checked_int_op, [checked_sub]);
     for_each_int_type!(checked_int_op, [checked_div]);
     for_each_int_type!(checked_int_op, [checked_rem]);
     for_each_int_type!(checked_int_op, [checked_mul]);
-
     for_each_int_type!(int_bit_shifts, [checked_shl]);
     for_each_int_type!(int_bit_shifts, [checked_shr]);
 }
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitand, &]);
 }
+
 impl std::ops::BitOr for IntValue {
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitor, |]);
 }
+
 impl std::ops::BitXor for IntValue {
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitxor, ^]);