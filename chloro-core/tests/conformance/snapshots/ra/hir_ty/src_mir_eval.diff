COMPARISON DIFF
============================================================

Original size: 131517 bytes
Chloro size:   131132 bytes
Rustfmt size:  131517 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module provides a MIR interpreter, which is used in const eval.
 
+mod shim;
+#[cfg(test)]
+mod tests;
+
 use std::{borrow::Cow, cell::RefCell, fmt::Write, iter, mem, ops::Range};
 
-use base_db::{Crate, target::TargetLoadError};
+use base_db::{target::TargetLoadError, Crate};
 use either::Either;
 use hir_def::{
-    AdtId, DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, HasModule, ItemContainerId,
-    Lookup, StaticId, VariantId,
     expr_store::HygieneId,
     item_tree::FieldsShape,
     lang_item::LangItem,
     layout::{TagEncoding, Variants},
     resolver::{HasResolver, TypeNs, ValueNs},
     signatures::{StaticFlags, StructFlags},
+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, HasModule, ItemContainerId,
+    Lookup, StaticId, VariantId,
 };
-use hir_expand::{InFile, mod_path::path, name::Name};
+use hir_expand::{mod_path::path, name::Name, InFile};
 use intern::sym;
 use la_arena::ArenaMap;
 use rustc_abi::TargetDataLayout;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use rustc_ast_ir::Mutability;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::{
-    AliasTyKind,
     inherent::{AdtDef, IntoKind, Region as _, SliceLike, Ty as _},
+    AliasTyKind,
 };
 use span::FileId;
 use stdx::never;
 use syntax::{SyntaxNodePtr, TextRange};
 use triomphe::Arc;
+use Address::*;
 
 use crate::{
-    CallableDefId, ComplexMemoryMap, MemoryMap, TraitEnvironment,
-    consteval::{self, ConstEvalError, try_const_usize},
+    consteval::{self, try_const_usize, ConstEvalError},
     db::{HirDatabase, InternedClosure, InternedClosureId},
     display::{ClosureStyle, DisplayTarget, HirDisplay},
     infer::PointerCast,
     layout::{Layout, LayoutError, RustcEnumVariantIdx},
     method_resolution::{is_dyn_method, lookup_impl_const},
     next_solver::{
-        Const, ConstBytes, ConstKind, DbInterner, ErrorGuaranteed, GenericArgs, Region,
-        SolverDefId, Ty, TyKind, TypingMode, UnevaluatedConst, ValueConst,
         infer::{DbInternerInferExt, InferCtxt, traits::ObligationCause},
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Const, ConstBytes, ConstKind, DbInterner,
+        ErrorGuaranteed, GenericArgs, Region, SolverDefId, Ty, TyKind, TypingMode,
+        UnevaluatedConst, ValueConst,
     },
     traits::FnTrait,
     utils::detect_variant_from_bytes,
+    CallableDefId, ComplexMemoryMap, MemoryMap, TraitEnvironment,
 };
-
 use super::{
-    AggregateKind, BasicBlockId, BinOp, CastKind, LocalId, MirBody, MirLowerError, MirSpan,
-    Operand, OperandKind, Place, PlaceElem, ProjectionElem, ProjectionStore, Rvalue, StatementKind,
-    TerminatorKind, UnOp, return_slot,
+    return_slot, AggregateKind, BasicBlockId, BinOp, CastKind, LocalId, MirBody, MirLowerError,
+    MirSpan, Operand, OperandKind, Place, PlaceElem, ProjectionElem, ProjectionStore, Rvalue,
+    StatementKind, TerminatorKind, UnOp,
 };
 
-mod shim;
-#[cfg(test)]
-mod tests;
-
 macro_rules! from_bytes {
     ($ty:tt, $value:expr) => {
         ($ty::from_le_bytes(match ($value).try_into() {
 }
 
 impl<'db> VTableMap<'db> {
-    const OFFSET: usize = 1000; // We should add some offset to ids to make 0 (null) an invalid id.
+    const OFFSET: usize = 1000;
+    // We should add some offset to ids to make 0 (null) an invalid id.
 
     fn id(&mut self, ty: Ty<'db>) -> usize {
         if let Some(it) = self.ty_to_id.get(&ty) {
     Invalid(usize),
 }
 
-use Address::*;
-
 #[derive(Debug, Clone, Copy)]
 struct Interval {
     addr: Address,
     }
 
     fn slice(self, range: Range<usize>) -> Interval {
-        Interval { addr: self.addr.offset(range.start), size: range.len() }
+        Interval {
+            addr: self.addr.offset(range.start),
+            size: range.len(),
+        }
     }
 }
 
 
 impl IntervalOrOwned {
     fn get<'a, 'db>(&'a self, memory: &'a Evaluator<'db>) -> Result<'db, &'a [u8]> {
-        Ok(match self {
+        Ok(
+            match self {
             IntervalOrOwned::Owned(o) => o,
             IntervalOrOwned::Borrowed(b) => b.get(memory)?,
-        })
+        },
+        )
     }
 }
 
 #[cfg(target_pointer_width = "64")]
 const STACK_OFFSET: usize = 1 << 60;
+
 #[cfg(target_pointer_width = "64")]
 const HEAP_OFFSET: usize = 1 << 59;
 
 #[cfg(target_pointer_width = "32")]
 const STACK_OFFSET: usize = 1 << 30;
+
 #[cfg(target_pointer_width = "32")]
 const HEAP_OFFSET: usize = 1 << 29;
 
     TypeIsUnsized(Ty<'db>, &'static str),
     NotSupported(String),
     InvalidConst(Const<'db>),
-    InFunction(
-        Box<MirEvalError<'db>>,
-        Vec<(Either<FunctionId, InternedClosureId>, MirSpan, DefWithBodyId)>,
-    ),
+    InFunction(Box<MirEvalError<'db>>, Vec<(Either<FunctionId, InternedClosureId>, MirSpan, DefWithBodyId)>),
     ExecutionLimitExceeded,
     StackOverflow,
     /// FIXME: Fold this into InternalError
     pub fn stdout(&self) -> Cow<'_, str> {
         String::from_utf8_lossy(&self.stdout)
     }
+
     pub fn stderr(&self) -> Cow<'_, str> {
         String::from_utf8_lossy(&self.stderr)
     }
 pub fn interpret_mir<'db>(
     db: &'db dyn HirDatabase,
     body: Arc<MirBody<'db>>,
-    // FIXME: This is workaround. Ideally, const generics should have a separate body (issue #7434), but now
-    // they share their body with their parent, so in MIR lowering we have locals of the parent body, which
-    // might have placeholders. With this argument, we (wrongly) assume that every placeholder type has
-    // a zero size, hoping that they are all outside of our current body. Even without a fix for #7434, we can
-    // (and probably should) do better here, for example by excluding bindings outside of the target expression.
     assert_placeholder_ty_is_unused: bool,
     trait_env: Option<Arc<TraitEnvironment<'db>>>,
 ) -> Result<'db, (Result<'db, Const<'db>>, MirOutput)> {
 
 #[cfg(test)]
 const EXECUTION_LIMIT: usize = 100_000;
+
 #[cfg(not(test))]
 const EXECUTION_LIMIT: usize = 10_000_000;
 
         let cached_ptr_size = target_data_layout.pointer_size().bytes_usize();
         let interner = DbInterner::new_with(db, Some(crate_id), module.containing_block());
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
-        Ok(Evaluator {
+        Ok(
+            Evaluator {
             target_data_layout,
             stack: vec![0],
             heap: vec![0],
                 x.trait_items(db).method_by_name(&Name::new_symbol_root(sym::call_once))
             }),
             infcx,
-        })
+        },
+        )
     }
 
     #[inline]
     ) -> Result<'db, (Address, Ty<'db>, Option<IntervalOrOwned>)> {
         let mut addr = locals.ptr[p.local].addr;
         let mut ty: Ty<'db> = locals.body.locals[p.local].ty;
-        let mut metadata: Option<IntervalOrOwned> = None; // locals are always sized
+        let mut metadata: Option<IntervalOrOwned> = None;
+        // locals are always sized
         for proj in p.projection.lookup(&locals.body.projection_store) {
             let prev_ty = ty;
             ty = self.projected_ty(ty, proj.clone());
     }
 
     fn operand_ty(&self, o: &Operand<'db>, locals: &Locals<'db>) -> Result<'db, Ty<'db>> {
-        Ok(match &o.kind {
+        Ok(
+            match &o.kind {
             OperandKind::Copy(p) | OperandKind::Move(p) => self.place_ty(p, locals)?,
             OperandKind::Constant { konst: _, ty } => *ty,
             &OperandKind::Static(s) => {
                     Mutability::Not,
                 )
             }
-        })
+        },
+        )
     }
 
     fn operand_ty_and_eval(
         locals: &mut Locals<'db>,
     ) -> Result<'db, IntervalOrOwned> {
         use IntervalOrOwned::*;
-        Ok(match r {
+        Ok(
+            match r {
             Rvalue::Use(it) => Borrowed(self.eval_operand(it, locals)?),
             Rvalue::Ref(_, p) => {
                 let (addr, _, metadata) = self.place_addr_and_ty_and_metadata(p, locals)?;
             | Rvalue::AddressOf(n)
             | Rvalue::BinaryOp(n)
             | Rvalue::NullaryOp(n) => match *n {},
-        })
+        },
+        )
     }
 
     fn compute_discriminant(&self, ty: Ty<'db>, bytes: &[u8]) -> Result<'db, i128> {
         addr: Interval,
     ) -> Result<'db, IntervalOrOwned> {
         use IntervalOrOwned::*;
-        Ok(match &target_ty.kind() {
+        Ok(
+            match &target_ty.kind() {
             TyKind::Slice(_) => match &current_ty.kind() {
                 TyKind::Array(_, size) => {
                     let len = match try_const_usize(self.db, *size) {
                 _ => not_supported!("unsizing struct with non adt type"),
             },
             _ => not_supported!("unknown unsized cast"),
-        })
+        },
+        )
     }
 
     fn layout_of_variant(
             return Ok((16, self.layout(Ty::new_empty_tuple(self.interner()))?, Some((0, 16, i))));
         }
         let layout = self.layout_adt(adt, subst)?;
-        Ok(match &layout.variants {
+        Ok(
+            match &layout.variants {
             Variants::Single { .. } | Variants::Empty => (layout.size.bytes_usize(), layout, None),
             Variants::Multiple { variants, tag, tag_encoding, .. } => {
                 let enum_variant_id = match it {
                     },
                 )
             }
-        })
+        },
+        )
     }
 
     fn construct_with_layout(
         &mut self,
-        size: usize, // Not necessarily equal to variant_layout.size
+        size: usize,
         variant_layout: &Layout,
         tag: Option<(usize, usize, i128)>,
         values: impl Iterator<Item = IntervalOrOwned>,
         it: &Operand<'db>,
         locals: &mut Locals<'db>,
     ) -> Result<'db, Interval> {
-        Ok(match &it.kind {
+        Ok(
+            match &it.kind {
             OperandKind::Copy(p) | OperandKind::Move(p) => {
                 locals.drop_flags.remove_place(p, &locals.body.projection_store);
                 self.eval_place(p, locals)?
                 Interval::new(addr, self.ptr_size())
             }
             OperandKind::Constant { konst, .. } => self.allocate_const_in_heap(locals, *konst)?,
-        })
+        },
+        )
     }
 
     #[allow(clippy::double_parens)]
         destination: Interval,
         target_bb: Option<BasicBlockId<'db>>,
     ) -> Result<'db, Option<StackFrame<'db>>> {
-        Ok(if let Some(target_bb) = target_bb {
+        Ok(
+            if let Some(target_bb) = target_bb {
             let (mut locals, prev_stack_ptr) =
                 self.create_locals_for_body(&mir_body, Some(destination))?;
             self.fill_locals_for_body(&mir_body, &mut locals, arg_bytes.into_iter())?;
             })?;
             destination.write_from_interval(self, result)?;
             None
-        })
+        },
+        )
     }
 
     fn exec_fn_trait(
         }
         for_each_int_type! { m, [] }
     }
-
     for_each_int_type!(checked_int_op, [checked_add]);
     for_each_int_type!(checked_int_op, [checked_sub]);
     for_each_int_type!(checked_int_op, [checked_div]);
     for_each_int_type!(checked_int_op, [checked_rem]);
     for_each_int_type!(checked_int_op, [checked_mul]);
-
     for_each_int_type!(int_bit_shifts, [checked_shl]);
     for_each_int_type!(int_bit_shifts, [checked_shr]);
 }
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitand, &]);
 }
+
 impl std::ops::BitOr for IntValue {
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitor, |]);
 }
+
 impl std::ops::BitXor for IntValue {
     type Output = Self;
     for_each_int_type!(unchecked_int_op, [bitxor, ^]);