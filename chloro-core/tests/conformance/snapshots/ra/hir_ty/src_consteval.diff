COMPARISON DIFF
============================================================

Original size: 10586 bytes
Chloro size:   10287 bytes
Rustfmt size:  10586 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use base_db::Crate;
 use hir_def::{
-    EnumVariantId, GeneralConstId, HasModule, StaticId,
     expr_store::Body,
     hir::{Expr, ExprId},
     type_ref::LiteralConstRef,
+    EnumVariantId, GeneralConstId, HasModule, StaticId,
 };
 use hir_expand::Lookup;
 use rustc_type_ir::inherent::IntoKind;
 use triomphe::Arc;
 
 use crate::{
-    LifetimeElisionKind, MemoryMap, TraitEnvironment, TyLoweringContext,
     db::HirDatabase,
     display::DisplayTarget,
     infer::InferenceContext,
         Const, ConstBytes, ConstKind, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs,
         SolverDefId, Ty, ValueConst,
     },
+    LifetimeElisionKind, MemoryMap, TraitEnvironment, TyLoweringContext,
 };
-
 use super::mir::{interpret_mir, lower_to_mir, pad16};
 
 pub fn unknown_const<'db>(_ty: Ty<'db>) -> Const<'db> {
         match self {
             ConstEvalError::MirLowerError(e) => {
                 e.pretty_print(f, db, span_formatter, display_target)
-            }
+            },
             ConstEvalError::MirEvalError(e) => {
                 e.pretty_print(f, db, span_formatter, display_target)
-            }
+            },
         }
     }
 }
 }
 
 /// Interns a possibly-unknown target usize
-pub fn usize_const<'db>(db: &'db dyn HirDatabase, value: Option<u128>, krate: Crate) -> Const<'db> {
+pub fn usize_const<'db>(
+    db: &'db dyn HirDatabase,
+    value: Option<u128>,
+    krate: Crate,
+) -> Const<'db> {
     intern_const_ref(
         db,
         &value.map_or(LiteralConstRef::Unknown, LiteralConstRef::UInt),
             let subst = unevaluated_const.args;
             let ec = db.const_eval(c, subst, None).ok()?;
             try_const_usize(db, ec)
-        }
+        },
         ConstKind::Value(val) => Some(u128::from_le_bytes(pad16(&val.value.inner().memory, false))),
         ConstKind::Error(_) => None,
         ConstKind::Expr(_) => None,
             let subst = unevaluated_const.args;
             let ec = db.const_eval(c, subst, None).ok()?;
             try_const_isize(db, &ec)
-        }
+        },
         ConstKind::Value(val) => Some(i128::from_le_bytes(pad16(&val.value.inner().memory, true))),
         ConstKind::Error(_) => None,
         ConstKind::Expr(_) => None,
     Ok(c)
 }
 
-// FIXME: Ideally constants in const eval should have separate body (issue #7434), and this function should
-// get an `InferenceResult` instead of an `InferenceContext`. And we should remove `ctx.clone().resolve_all()` here
-// and make this function private. See the fixme comment on `InferenceContext::resolve_all`.
 pub(crate) fn eval_to_const<'db>(expr: ExprId, ctx: &mut InferenceContext<'_, 'db>) -> Const<'db> {
     let infer = ctx.fixme_resolve_all_clone();
     fn has_closure(body: &Body, expr: ExprId) -> bool {