COMPARISON DIFF
============================================================

Original size: 10586 bytes
Chloro size:   10281 bytes
Rustfmt size:  10586 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use base_db::Crate;
 use hir_def::{
-    EnumVariantId, GeneralConstId, HasModule, StaticId,
     expr_store::Body,
     hir::{Expr, ExprId},
     type_ref::LiteralConstRef,
+    EnumVariantId, GeneralConstId, HasModule, StaticId,
 };
 use hir_expand::Lookup;
 use rustc_type_ir::inherent::IntoKind;
 use triomphe::Arc;
 
 use crate::{
-    LifetimeElisionKind, MemoryMap, TraitEnvironment, TyLoweringContext,
     db::HirDatabase,
     display::DisplayTarget,
     infer::InferenceContext,
         Const, ConstBytes, ConstKind, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs,
         SolverDefId, Ty, ValueConst,
     },
+    LifetimeElisionKind, MemoryMap, TraitEnvironment, TyLoweringContext,
 };
-
 use super::mir::{interpret_mir, lower_to_mir, pad16};
 
 pub fn unknown_const<'db>(_ty: Ty<'db>) -> Const<'db> {
 }
 
 /// Interns a possibly-unknown target usize
-pub fn usize_const<'db>(db: &'db dyn HirDatabase, value: Option<u128>, krate: Crate) -> Const<'db> {
+pub fn usize_const<'db>(
+    db: &'db dyn HirDatabase,
+    value: Option<u128>,
+    krate: Crate,
+) -> Const<'db> {
     intern_const_ref(
         db,
         &value.map_or(LiteralConstRef::Unknown, LiteralConstRef::UInt),
         };
         return Ok(value);
     }
-
     let repr = db.enum_signature(loc.parent).repr;
     let is_signed = repr.and_then(|repr| repr.int).is_none_or(|int| int.is_signed());
-
     let mir_body = db.monomorphized_mir_body(
         def,
         GenericArgs::new_from_iter(interner, []),
     Ok(c)
 }
 
-// FIXME: Ideally constants in const eval should have separate body (issue #7434), and this function should
-// get an `InferenceResult` instead of an `InferenceContext`. And we should remove `ctx.clone().resolve_all()` here
-// and make this function private. See the fixme comment on `InferenceContext::resolve_all`.
 pub(crate) fn eval_to_const<'db>(expr: ExprId, ctx: &mut InferenceContext<'_, 'db>) -> Const<'db> {
     let infer = ctx.fixme_resolve_all_clone();
     fn has_closure(body: &Body, expr: ExprId) -> bool {