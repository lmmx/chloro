COMPARISON DIFF
============================================================

Original size: 10586 bytes
Chloro size:   10318 bytes
Rustfmt size:  10586 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use base_db::Crate;
 use hir_def::{
-    EnumVariantId, GeneralConstId, HasModule, StaticId,
     expr_store::Body,
-    hir::{Expr, ExprId},
+
+    hir::{Expr,
+
     type_ref::LiteralConstRef,
+
+    EnumVariantId, ExprId}, GeneralConstId, HasModule, StaticId,
 };
 use hir_expand::Lookup;
 use rustc_type_ir::inherent::IntoKind;
 use triomphe::Arc;
 
 use crate::{
-    LifetimeElisionKind, MemoryMap, TraitEnvironment, TyLoweringContext,
     db::HirDatabase,
-    display::DisplayTarget,
-    infer::InferenceContext,
-    mir::{MirEvalError, MirLowerError},
-    next_solver::{
-        Const, ConstBytes, ConstKind, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs,
-        SolverDefId, Ty, ValueConst,
-    },
-};
 
+    display::DisplayTarget,
+
+    infer::InferenceContext,
+
+    mir::{MirEvalError,
+
+    next_solver::{
+        Const,
+
+    ConstBytes, ConstKind, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs,
+    LifetimeElisionKind, MemoryMap, MirLowerError}, SolverDefId, TraitEnvironment, Ty,
+    TyLoweringContext, ValueConst, },
+};
 use super::mir::{interpret_mir, lower_to_mir, pad16};
 
 pub fn unknown_const<'db>(_ty: Ty<'db>) -> Const<'db> {
 }
 
 /// Interns a possibly-unknown target usize
-pub fn usize_const<'db>(db: &'db dyn HirDatabase, value: Option<u128>, krate: Crate) -> Const<'db> {
+pub fn usize_const<'db>(
+    db: &'db dyn HirDatabase,
+    value: Option<u128>,
+    krate: Crate,
+) -> Const<'db> {
     intern_const_ref(
         db,
         &value.map_or(LiteralConstRef::Unknown, LiteralConstRef::UInt),
     )
 }
 
-pub fn try_const_usize<'db>(db: &'db dyn HirDatabase, c: Const<'db>) -> Option<u128> {
+pub fn try_const_usize<'db>(
+    db: &'db dyn HirDatabase,
+    c: Const<'db>,
+) -> Option<u128> {
     match c.kind() {
         ConstKind::Param(_) => None,
         ConstKind::Infer(_) => None,
     }
 }
 
-pub fn try_const_isize<'db>(db: &'db dyn HirDatabase, c: &Const<'db>) -> Option<i128> {
+pub fn try_const_isize<'db>(
+    db: &'db dyn HirDatabase,
+    c: &Const<'db>,
+) -> Option<i128> {
     match (*c).kind() {
         ConstKind::Param(_) => None,
         ConstKind::Infer(_) => None,
         };
         return Ok(value);
     }
-
     let repr = db.enum_signature(loc.parent).repr;
     let is_signed = repr.and_then(|repr| repr.int).is_none_or(|int| int.is_signed());
-
     let mir_body = db.monomorphized_mir_body(
         def,
         GenericArgs::new_from_iter(interner, []),
     Ok(c)
 }
 
-// FIXME: Ideally constants in const eval should have separate body (issue #7434), and this function should
-// get an `InferenceResult` instead of an `InferenceContext`. And we should remove `ctx.clone().resolve_all()` here
-// and make this function private. See the fixme comment on `InferenceContext::resolve_all`.
-pub(crate) fn eval_to_const<'db>(expr: ExprId, ctx: &mut InferenceContext<'_, 'db>) -> Const<'db> {
+pub(crate) fn eval_to_const<'db>(
+    expr: ExprId,
+    ctx: &mut InferenceContext<'_, 'db>,
+) -> Const<'db> {
     let infer = ctx.fixme_resolve_all_clone();
     fn has_closure(body: &Body, expr: ExprId) -> bool {
         if matches!(body[expr], Expr::Closure { .. }) {