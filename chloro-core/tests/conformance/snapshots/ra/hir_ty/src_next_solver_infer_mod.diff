COMPARISON DIFF
============================================================

Original size: 49754 bytes
Chloro size:   49882 bytes
Rustfmt size:  51629 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
     error::{ExpectedFound, TypeError},
     inherent::{
-        Const as _, GenericArg as _, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _,
+        Const as _, GenericArgs as _, GenericArg as _, IntoKind, SliceLike, Term as _, Ty as _,
     },
 };
 use snapshot::undo_log::InferCtxtUndoLogs;
     pub value: T,
     pub obligations: PredicateObligations<'db>,
 }
+
 pub type InferResult<'db, T> = Result<InferOk<'db, T>, TypeError<DbInterner<'db>>>;
 
-pub(crate) type UnificationTable<'a, 'db, T> = ut::UnificationTable<
+pub(crate) type UnificationTable<'a, 'db, T> =
+    ut::UnificationTable<
     ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut InferCtxtUndoLogs<'db>>,
 >;
 
 #[derive(Clone)]
 pub struct InferCtxtInner<'db> {
     pub(crate) undo_log: InferCtxtUndoLogs<'db>,
-
     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types
     /// that might instantiate a general type variable have an order,
     /// represented by its upper and lower bounds.
     pub(crate) type_variable_storage: type_variable::TypeVariableStorage<'db>,
-
     /// Map from const parameter variable to the kind of const it represents.
     pub(crate) const_unification_storage: ut::UnificationTableStorage<ConstVidKey<'db>>,
-
     /// Map from integral variable to the kind of integer it represents.
     pub(crate) int_unification_storage: ut::UnificationTableStorage<IntVid>,
-
     /// Map from floating variable to the kind of float it represents.
     pub(crate) float_unification_storage: ut::UnificationTableStorage<FloatVid>,
-
     /// Tracks the set of region variables and the constraints between them.
     ///
     /// This is initially `Some(_)` but when
     /// -- further attempts to perform unification, etc., may fail if new
     /// region constraints would've been added.
     pub(crate) region_constraint_storage: Option<RegionConstraintStorage<'db>>,
-
     /// A set of constraints that regionck must validate.
     ///
     /// Each constraint has the form `T:'a`, meaning "some type `T` must
     /// obligations within. This is expected to be done 'late enough'
     /// that all type inference variables have been bound and so forth.
     pub(crate) region_obligations: Vec<RegionObligation<'db>>,
-
     /// Caches for opaque type inference.
     pub(crate) opaque_type_storage: OpaqueTypeStorage<'db>,
 }
     fn new() -> InferCtxtInner<'db> {
         InferCtxtInner {
             undo_log: InferCtxtUndoLogs::default(),
-
             type_variable_storage: Default::default(),
             const_unification_storage: Default::default(),
             int_unification_storage: Default::default(),
     ) -> Option<&type_variable::TypeVariableValue<'db>> {
         // Uses a read-only view of the unification table, this way we don't
         // need an undo log.
-        self.type_variable_storage
-            .eq_relations_ref()
-            .try_probe_value(vid)
+        self.type_variable_storage.eq_relations_ref().try_probe_value(vid)
     }
 
     #[inline]
 #[derive(Clone)]
 pub struct InferCtxt<'db> {
     pub interner: DbInterner<'db>,
-
     /// The mode of this inference context, see the struct documentation
     /// for more details.
     typing_mode: TypingMode<'db>,
-
     pub inner: RefCell<InferCtxtInner<'db>>,
-
     /// When an error occurs, we want to avoid reporting "derived"
     /// errors that are due to this original failure. We have this
     /// flag that one can set whenever one creates a type-error that
     /// Don't read this flag directly, call `is_tainted_by_errors()`
     /// and `set_tainted_by_errors()`.
     tainted_by_errors: Cell<Option<ErrorGuaranteed>>,
-
     /// What is the innermost universe we have created? Starts out as
     /// `UniverseIndex::root()` but grows from there as we enter
     /// universal quantifiers.
         &self,
         obligation: &PredicateObligation<'db>,
     ) -> bool {
-        <&SolverContext<'db>>::from(self).root_goal_may_hold_opaque_types_jank(Goal::new(
-            self.interner,
-            obligation.param_env,
-            obligation.predicate,
-        ))
+        <&SolverContext<'db>>::from(self).root_goal_may_hold_opaque_types_jank(
+            Goal::new(self.interner, obligation.param_env, obligation.predicate),
+        )
     }
 
     pub(crate) fn insert_type_vars<T>(&self, ty: T) -> T
                     return ty;
                 }
 
-                if ty.is_ty_error() {
-                    self.infcx.next_ty_var()
-                } else {
-                    ty.super_fold_with(self)
-                }
+                if ty.is_ty_error() { self.infcx.next_ty_var() } else { ty.super_fold_with(self) }
             }
 
             fn fold_const(&mut self, ct: Const<'db>) -> Const<'db> {
             }
 
             fn fold_region(&mut self, r: Region<'db>) -> Region<'db> {
-                if r.is_error() {
-                    self.infcx.next_region_var()
-                } else {
-                    r
-                }
+                if r.is_error() { self.infcx.next_region_var() } else { r }
             }
         }
 
         &self,
         obligation: &PredicateObligation<'db>,
     ) -> bool {
-        self.evaluate_obligation(obligation)
-            .must_apply_considering_regions()
+        self.evaluate_obligation(obligation).must_apply_considering_regions()
     }
 
     /// Evaluates whether the predicate can be satisfied in the given
     /// This version ignores all outlives constraints.
     #[expect(dead_code, reason = "this is used in rustc")]
     fn predicate_must_hold_modulo_regions(&self, obligation: &PredicateObligation<'db>) -> bool {
-        self.evaluate_obligation(obligation)
-            .must_apply_modulo_regions()
+        self.evaluate_obligation(obligation).must_apply_modulo_regions()
     }
 
     /// Evaluate a given predicate, capturing overflow and propagating it back.
         vars.extend(
             (0..inner.float_unification_table().len())
                 .map(FloatVid::from_usize)
-                .filter(|&vid| {
-                    inner
-                        .float_unification_table()
-                        .probe_value(vid)
-                        .is_unknown()
-                })
+                .filter(|&vid| inner.float_unification_table().probe_value(vid).is_unknown())
                 .map(|v| Ty::new_float_var(self.interner, v)),
         );
         vars
 
     #[instrument(skip(self), level = "debug")]
     pub fn sub_regions(&self, a: Region<'db>, b: Region<'db>) {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .make_subregion(a, b);
+        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(a, b);
     }
 
     /// Processes a `Coerce` predicate from the fulfillment context.
 
         self.enter_forall(
             predicate,
-            |SubtypePredicate {
-                 a_is_expected,
-                 a,
-                 b,
-             }| {
-                if a_is_expected {
-                    Ok(self.at(cause, param_env).sub(a, b))
-                } else {
-                    Ok(self.at(cause, param_env).sup(b, a))
-                }
-            },
+            |SubtypePredicate { a_is_expected, a, b }| {
+            if a_is_expected {
+                Ok(self.at(cause, param_env).sub(a, b))
+            } else {
+                Ok(self.at(cause, param_env).sup(b, a))
+            }
+        },
         )
     }
 
         _cause: &traits::ObligationCause,
         predicate: PolyRegionOutlivesPredicate<'db>,
     ) {
-        self.enter_forall(predicate, |OutlivesPredicate(r_a, r_b)| {
+        self.enter_forall(
+            predicate,
+            |OutlivesPredicate(r_a, r_b)| {
             self.sub_regions(r_b, r_a); // `b : a` ==> `a <= b`
-        })
+        },
+        )
     }
 
     /// Number of type variables created so far.
     }
 
     pub fn next_ty_var_with_origin(&self, origin: TypeVariableOrigin) -> Ty<'db> {
-        let vid = self
-            .inner
-            .borrow_mut()
-            .type_variables()
-            .new_var(self.universe(), origin);
+        let vid = self.inner.borrow_mut().type_variables().new_var(self.universe(), origin);
         Ty::new_var(self.interner, vid)
     }
 
     pub fn next_ty_var_id_in_universe(&self, universe: UniverseIndex) -> TyVid {
         let origin = TypeVariableOrigin { param_def_id: None };
-        self.inner
-            .borrow_mut()
-            .type_variables()
-            .new_var(universe, origin)
+        self.inner.borrow_mut().type_variables().new_var(universe, origin)
     }
 
     pub fn next_ty_var_in_universe(&self, universe: UniverseIndex) -> Ty<'db> {
             .inner
             .borrow_mut()
             .const_unification_table()
-            .new_key(ConstVariableValue::Unknown {
-                origin,
-                universe: self.universe(),
-            })
+            .new_key(ConstVariableValue::Unknown { origin, universe: self.universe() })
             .vid;
         Const::new_var(self.interner, vid)
     }
     }
 
     pub fn next_int_var(&self) -> Ty<'db> {
-        let next_int_var_id = self
-            .inner
-            .borrow_mut()
-            .int_unification_table()
-            .new_key(IntVarValue::Unknown);
+        let next_int_var_id =
+            self.inner.borrow_mut().int_unification_table().new_key(IntVarValue::Unknown);
         Ty::new_int_var(self.interner, next_int_var_id)
     }
 
     pub fn next_int_vid(&self) -> IntVid {
-        self.inner
-            .borrow_mut()
-            .int_unification_table()
-            .new_key(IntVarValue::Unknown)
+        self.inner.borrow_mut().int_unification_table().new_key(IntVarValue::Unknown)
     }
 
     pub fn next_float_var(&self) -> Ty<'db> {
     }
 
     pub fn next_float_vid(&self) -> FloatVid {
-        self.inner
-            .borrow_mut()
-            .float_unification_table()
-            .new_key(FloatVarValue::Unknown)
+        self.inner.borrow_mut().float_unification_table().new_key(FloatVarValue::Unknown)
     }
 
     /// Creates a fresh region variable with the next available index.
     }
 
     pub fn next_region_vid(&self) -> RegionVid {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .new_region_var(self.universe())
+        self.inner.borrow_mut().unwrap_region_constraints().new_region_var(self.universe())
     }
 
     /// Creates a fresh region variable with the next available index
     /// in the given universe; typically, you can use
     /// `next_region_var` and just use the maximal universe.
     pub fn next_region_var_in_universe(&self, universe: UniverseIndex) -> Region<'db> {
-        let region_var = self
-            .inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .new_region_var(universe);
+        let region_var =
+            self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe);
         Region::new_var(self.interner, region_var)
     }
 
     /// placeholders, however, it will return the universe which they
     /// are associated.
     pub fn universe_of_region(&self, r: Region<'db>) -> UniverseIndex {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .universe(r)
+        self.inner.borrow_mut().unwrap_region_constraints().universe(r)
     }
 
     /// Number of region variables created so far.
     pub fn num_region_vars(&self) -> usize {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .num_region_vars()
+        self.inner.borrow_mut().unwrap_region_constraints().num_region_vars()
     }
 
     /// Just a convenient wrapper of `next_region_var` for using during NLL.
                     .inner
                     .borrow_mut()
                     .const_unification_table()
-                    .new_key(ConstVariableValue::Unknown {
-                        origin,
-                        universe: self.universe(),
-                    })
+                    .new_key(ConstVariableValue::Unknown { origin, universe: self.universe() })
                     .vid;
                 Const::new_var(self.interner, const_var_id).into()
             }
     /// Given a set of generics defined on a type or impl, returns the generic parameters mapping
     /// each type/region parameter to a fresh inference variable.
     pub fn fresh_args_for_item(&self, def_id: SolverDefId) -> GenericArgs<'db> {
-        GenericArgs::for_item(self.interner, def_id, |_index, kind, _| {
-            self.var_for_def(kind)
-        })
+        GenericArgs::for_item(self.interner, def_id, |_index, kind, _| self.var_for_def(kind))
     }
 
     /// Like `fresh_args_for_item()`, but first uses the args from `first`.
         def_id: SolverDefId,
         first: impl IntoIterator<Item = GenericArg<'db>>,
     ) -> GenericArgs<'db> {
-        GenericArgs::fill_rest(self.interner, def_id, first, |_index, kind, _| {
+        GenericArgs::fill_rest(
+            self.interner,
+            def_id,
+            first,
+            |_index, kind, _| {
             self.var_for_def(kind)
-        })
+        },
+        )
     }
 
     /// Returns `true` if errors have been reported since this infcx was
 
     #[instrument(level = "debug", skip(self), ret)]
     pub fn take_opaque_types(&self) -> Vec<(OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
-        self.inner
-            .borrow_mut()
-            .opaque_type_storage
-            .take_opaque_types()
-            .collect()
+        self.inner.borrow_mut().opaque_type_storage.take_opaque_types().collect()
     }
 
     #[instrument(level = "debug", skip(self), ret)]
     pub fn clone_opaque_types(&self) -> Vec<(OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
-        self.inner
-            .borrow_mut()
-            .opaque_type_storage
-            .iter_opaque_types()
-            .collect()
+        self.inner.borrow_mut().opaque_type_storage.iter_opaque_types().collect()
     }
 
     #[inline(always)]
     pub fn can_define_opaque_ty(&self, id: impl Into<SolverDefId>) -> bool {
         match self.typing_mode_unchecked() {
-            TypingMode::Analysis {
-                defining_opaque_types_and_generators,
-            } => defining_opaque_types_and_generators.contains(&id.into()),
+            TypingMode::Analysis { defining_opaque_types_and_generators } => {
+                defining_opaque_types_and_generators.contains(&id.into())
+            }
             TypingMode::Coherence | TypingMode::PostAnalysis => false,
-            TypingMode::Borrowck {
-                defining_opaque_types: _,
-            } => unimplemented!(),
-            TypingMode::PostBorrowckAnalysis {
-                defined_opaque_types: _,
-            } => unimplemented!(),
+            TypingMode::Borrowck { defining_opaque_types: _ } => unimplemented!(),
+            TypingMode::PostBorrowckAnalysis { defined_opaque_types: _ } => unimplemented!(),
         }
     }
 
                 }
 
                 InferTy::IntVar(v) => {
-                    match self
-                        .inner
-                        .borrow_mut()
-                        .int_unification_table()
-                        .probe_value(v)
-                    {
+                    match self.inner.borrow_mut().int_unification_table().probe_value(v) {
                         IntVarValue::IntType(ty) => Ty::new_int(self.interner, ty),
                         IntVarValue::UintType(ty) => Ty::new_uint(self.interner, ty),
                         IntVarValue::Unknown => ty,
                 }
 
                 InferTy::FloatVar(v) => {
-                    match self
-                        .inner
-                        .borrow_mut()
-                        .float_unification_table()
-                        .probe_value(v)
-                    {
+                    match self.inner.borrow_mut().float_unification_table().probe_value(v) {
                         FloatVarValue::Known(ty) => Ty::new_float(self.interner, ty),
                         FloatVarValue::Unknown => ty,
                     }
     }
 
     pub fn root_const_var(&self, var: ConstVid) -> ConstVid {
-        self.inner
-            .borrow_mut()
-            .const_unification_table()
-            .find(var)
-            .vid
+        self.inner.borrow_mut().const_unification_table().find(var).vid
     }
 
     /// Resolves an int var to a rigid int type, if it was constrained to one,
     }
 
     pub fn probe_const_var(&self, vid: ConstVid) -> Result<Const<'db>, UniverseIndex> {
-        match self
-            .inner
-            .borrow_mut()
-            .const_unification_table()
-            .probe_value(vid)
-        {
+        match self.inner.borrow_mut().const_unification_table().probe_value(vid) {
             ConstVariableValue::Known { value } => Ok(value),
-            ConstVariableValue::Unknown {
-                origin: _,
-                universe,
-            } => Err(universe),
+            ConstVariableValue::Unknown { origin: _, universe } => Err(universe),
         }
     }
 
                 // If `inlined_probe_value` returns a value it's always a
                 // `Int(_)` or `UInt(_)`, which never matches a
                 // `Infer(_)`.
-                self.inner
-                    .borrow_mut()
-                    .int_unification_table()
-                    .inlined_probe_value(v)
-                    .is_known()
+                self.inner.borrow_mut().int_unification_table().inlined_probe_value(v).is_known()
             }
 
             TyOrConstInferVar::TyFloat(v) => {
                 // `Float(_)`, which never matches a `Infer(_)`.
                 //
                 // Not `inlined_probe_value(v)` because this call site is colder.
-                self.inner
-                    .borrow_mut()
-                    .float_unification_table()
-                    .probe_value(v)
-                    .is_known()
+                self.inner.borrow_mut().float_unification_table().probe_value(v).is_known()
             }
 
             TyOrConstInferVar::Const(v) => {
                 // `ConstKind::Infer(InferConst::Var(v))`.
                 //
                 // Not `inlined_probe_value(v)` because this call site is colder.
-                match self
-                    .inner
-                    .borrow_mut()
-                    .const_unification_table()
-                    .probe_value(v)
-                {
+                match self.inner.borrow_mut().const_unification_table().probe_value(v) {
                     ConstVariableValue::Unknown { .. } => false,
                     ConstVariableValue::Known { .. } => true,
                 }
     }
 
     fn sub_unification_table_root_var(&self, var: rustc_type_ir::TyVid) -> rustc_type_ir::TyVid {
-        self.inner
-            .borrow_mut()
-            .type_variables()
-            .sub_unification_table_root_var(var)
+        self.inner.borrow_mut().type_variables().sub_unification_table_root_var(var)
     }
 
     fn sub_unify_ty_vids_raw(&self, a: rustc_type_ir::TyVid, b: rustc_type_ir::TyVid) {
     /// The `DefId` and args of the opaque type causing this constraint.
     /// Used for error reporting.
     pub key: OpaqueTypeKey<'db>,
-
     /// The hidden type in which `member_region` appears: used for error reporting.
     pub hidden_ty: Ty<'db>,
-
     /// The region `R0`.
     pub member_region: Region<'db>,
-
     /// The options `O1..On`.
     pub choice_regions: Arc<Vec<Region<'db>>>,
 }