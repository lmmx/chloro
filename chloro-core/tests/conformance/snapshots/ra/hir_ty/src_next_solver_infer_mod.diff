COMPARISON DIFF
============================================================

Original size: 49754 bytes
Chloro size:   47104 bytes
Rustfmt size:  49754 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Infer context the next-trait-solver.
 
-use std::cell::{Cell, RefCell};
-use std::fmt;
-use std::ops::Range;
-use std::sync::Arc;
-
-pub use BoundRegionConversionTime::*;
-use ena::unify as ut;
-use hir_def::GenericParamId;
-use hir_def::lang_item::LangItem;
-use opaque_types::{OpaqueHiddenType, OpaqueTypeStorage};
-use region_constraints::{RegionConstraintCollector, RegionConstraintStorage};
-use rustc_next_trait_solver::solve::SolverDelegateEvalExt;
-use rustc_pattern_analysis::Captures;
-use rustc_type_ir::{
-    ClosureKind, ConstVid, FloatVarValue, FloatVid, GenericArgKind, InferConst, InferTy,
-    IntVarValue, IntVid, OutlivesPredicate, RegionVid, TermKind, TyVid, TypeFoldable, TypeFolder,
-    TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
-    error::{ExpectedFound, TypeError},
-    inherent::{
-        Const as _, GenericArg as _, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _,
-    },
-};
-use snapshot::undo_log::InferCtxtUndoLogs;
-use tracing::{debug, instrument};
-use traits::{ObligationCause, PredicateObligations};
-use type_variable::TypeVariableOrigin;
-use unify_key::{ConstVariableOrigin, ConstVariableValue, ConstVidKey};
-
-use crate::next_solver::{
-    BoundConst, BoundRegion, BoundTy, BoundVarKind, Goal, SolverContext,
-    fold::BoundVarReplacerDelegate,
-    infer::{select::EvaluationResult, traits::PredicateObligation},
-    obligation_ctxt::ObligationCtxt,
-};
-
-use super::{
-    AliasTerm, Binder, CanonicalQueryInput, CanonicalVarValues, Const, ConstKind, DbInterner,
-    ErrorGuaranteed, GenericArg, GenericArgs, OpaqueTypeKey, ParamEnv, PolyCoercePredicate,
-    PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, PolyRegionOutlivesPredicate,
-    PolySubtypePredicate, Region, SolverDefId, SubtypePredicate, Term, TraitRef, Ty, TyKind,
-    TypingMode,
-};
-
 pub mod at;
 pub mod canonical;
 mod context;
 mod type_variable;
 mod unify_key;
 
+use std::cell::{Cell, RefCell};
+use std::fmt;
+use std::ops::Range;
+use std::sync::Arc;
+
+use ena::unify as ut;
+use hir_def::GenericParamId;
+use hir_def::lang_item::LangItem;
+use opaque_types::{OpaqueHiddenType, OpaqueTypeStorage};
+use region_constraints::{RegionConstraintCollector, RegionConstraintStorage};
+use rustc_next_trait_solver::solve::SolverDelegateEvalExt;
+use rustc_pattern_analysis::Captures;
+use rustc_type_ir::{
+    error::{ExpectedFound, TypeError},
+    inherent::{
+        Const as _, GenericArg as _, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _,
+    },
+    ClosureKind, ConstVid, FloatVarValue, FloatVid, GenericArgKind, InferConst, InferTy,
+    IntVarValue, IntVid, OutlivesPredicate, RegionVid, TermKind, TyVid, TypeFoldable, TypeFolder,
+    TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
+};
+use snapshot::undo_log::InferCtxtUndoLogs;
+use tracing::{debug, instrument};
+use traits::{ObligationCause, PredicateObligations};
+use type_variable::TypeVariableOrigin;
+use unify_key::{ConstVariableOrigin, ConstVariableValue, ConstVidKey};
+pub use BoundRegionConversionTime::*;
+
+use crate::next_solver::{
+    fold::BoundVarReplacerDelegate,
+    infer::{select::EvaluationResult, traits::PredicateObligation},
+    obligation_ctxt::ObligationCtxt,
+    BoundConst, BoundRegion, BoundTy, BoundVarKind, Goal, SolverContext,
+};
+use super::{
+    AliasTerm, Binder, CanonicalQueryInput, CanonicalVarValues, Const, ConstKind, DbInterner,
+    ErrorGuaranteed, GenericArg, GenericArgs, OpaqueTypeKey, ParamEnv, PolyCoercePredicate,
+    PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, PolyRegionOutlivesPredicate,
+    PolySubtypePredicate, Region, SolverDefId, SubtypePredicate, Term, TraitRef, Ty, TyKind,
+    TypingMode,
+};
+
 /// `InferOk<'db, ()>` is used a lot. It may seem like a useless wrapper
 /// around `PredicateObligations`, but it has one important property:
 /// because `InferOk` is marked with `#[must_use]`, if you have a method
     pub value: T,
     pub obligations: PredicateObligations<'db>,
 }
+
 pub type InferResult<'db, T> = Result<InferOk<'db, T>, TypeError<DbInterner<'db>>>;
 
-pub(crate) type UnificationTable<'a, 'db, T> = ut::UnificationTable<
+pub(crate) type UnificationTable<'a, 'db, T> =
+    ut::UnificationTable<
     ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut InferCtxtUndoLogs<'db>>,
 >;
 
 #[derive(Clone)]
 pub struct InferCtxtInner<'db> {
     pub(crate) undo_log: InferCtxtUndoLogs<'db>,
-
     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types
     /// that might instantiate a general type variable have an order,
     /// represented by its upper and lower bounds.
     pub(crate) type_variable_storage: type_variable::TypeVariableStorage<'db>,
-
     /// Map from const parameter variable to the kind of const it represents.
     pub(crate) const_unification_storage: ut::UnificationTableStorage<ConstVidKey<'db>>,
-
     /// Map from integral variable to the kind of integer it represents.
     pub(crate) int_unification_storage: ut::UnificationTableStorage<IntVid>,
-
     /// Map from floating variable to the kind of float it represents.
     pub(crate) float_unification_storage: ut::UnificationTableStorage<FloatVid>,
-
     /// Tracks the set of region variables and the constraints between them.
     ///
     /// This is initially `Some(_)` but when
     /// -- further attempts to perform unification, etc., may fail if new
     /// region constraints would've been added.
     pub(crate) region_constraint_storage: Option<RegionConstraintStorage<'db>>,
-
     /// A set of constraints that regionck must validate.
     ///
     /// Each constraint has the form `T:'a`, meaning "some type `T` must
     /// obligations within. This is expected to be done 'late enough'
     /// that all type inference variables have been bound and so forth.
     pub(crate) region_obligations: Vec<RegionObligation<'db>>,
-
     /// Caches for opaque type inference.
     pub(crate) opaque_type_storage: OpaqueTypeStorage<'db>,
 }
     fn new() -> InferCtxtInner<'db> {
         InferCtxtInner {
             undo_log: InferCtxtUndoLogs::default(),
-
             type_variable_storage: Default::default(),
             const_unification_storage: Default::default(),
             int_unification_storage: Default::default(),
 
     #[inline]
     pub fn unwrap_region_constraints(&mut self) -> RegionConstraintCollector<'db, '_> {
-        self.region_constraint_storage
-            .as_mut()
-            .expect("region constraints already solved")
-            .with_log(&mut self.undo_log)
+        self.region_constraint_storage.as_mut().expect("region constraints already solved").with_log(
+            &mut self.undo_log,
+        )
     }
 }
 
 #[derive(Clone)]
 pub struct InferCtxt<'db> {
     pub interner: DbInterner<'db>,
-
     /// The mode of this inference context, see the struct documentation
     /// for more details.
     typing_mode: TypingMode<'db>,
-
     pub inner: RefCell<InferCtxtInner<'db>>,
-
     /// When an error occurs, we want to avoid reporting "derived"
     /// errors that are due to this original failure. We have this
     /// flag that one can set whenever one creates a type-error that
     /// Don't read this flag directly, call `is_tainted_by_errors()`
     /// and `set_tainted_by_errors()`.
     tainted_by_errors: Cell<Option<ErrorGuaranteed>>,
-
     /// What is the innermost universe we have created? Starts out as
     /// `UniverseIndex::root()` but grows from there as we enter
     /// universal quantifiers.
         &self,
         obligation: &PredicateObligation<'db>,
     ) -> bool {
-        <&SolverContext<'db>>::from(self).root_goal_may_hold_opaque_types_jank(Goal::new(
-            self.interner,
-            obligation.param_env,
-            obligation.predicate,
-        ))
+        <&SolverContext<'db>>::from(self).root_goal_may_hold_opaque_types_jank(
+            Goal::new(self.interner, obligation.param_env, obligation.predicate),
+        )
     }
 
     pub(crate) fn insert_type_vars<T>(&self, ty: T) -> T
         };
 
         // This can get called from typeck (by euv), and `moves_by_default`
+
         // rightly refuses to work with inference variables, but
+
         // moves_by_default has a cache, which we want to use in other
+
         // cases.
         traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id)
     }
             _ => {}
         }
 
-        self.enter_forall(predicate, |SubtypePredicate { a_is_expected, a, b }| {
+        self.enter_forall(
+            predicate,
+            |SubtypePredicate { a_is_expected, a, b }| {
             if a_is_expected {
                 Ok(self.at(cause, param_env).sub(a, b))
             } else {
                 Ok(self.at(cause, param_env).sup(b, a))
             }
-        })
+        },
+        )
     }
 
     pub fn region_outlives_predicate(
         _cause: &traits::ObligationCause,
         predicate: PolyRegionOutlivesPredicate<'db>,
     ) {
-        self.enter_forall(predicate, |OutlivesPredicate(r_a, r_b)| {
+        self.enter_forall(
+            predicate,
+            |OutlivesPredicate(r_a, r_b)| {
             self.sub_regions(r_b, r_a); // `b : a` ==> `a <= b`
-        })
+        },
+        )
     }
 
     /// Number of type variables created so far.
     }
 
     pub fn next_const_vid(&self) -> ConstVid {
-        self.inner
-            .borrow_mut()
-            .const_unification_table()
-            .new_key(ConstVariableValue::Unknown {
-                origin: ConstVariableOrigin {},
-                universe: self.universe(),
-            })
-            .vid
+        self.inner.borrow_mut().const_unification_table().new_key(ConstVariableValue::Unknown {
+            origin: ConstVariableOrigin {},
+            universe: self.universe(),
+        }).vid
     }
 
     pub fn next_const_var_with_origin(&self, origin: ConstVariableOrigin) -> Const<'db> {
     fn var_for_def(&self, id: GenericParamId) -> GenericArg<'db> {
         match id {
             GenericParamId::LifetimeParamId(_) => {
-                // Create a region inference variable for the given
-                // region parameter definition.
                 self.next_region_var().into()
             }
             GenericParamId::TypeParamId(_) => {
-                // Create a type inference variable for the given
-                // type parameter definition. The generic parameters are
-                // for actual parameters that may be referred to by
-                // the default of this type parameter, if it exists.
-                // e.g., `struct Foo<A, B, C = (A, B)>(...);` when
-                // used in a path such as `Foo::<T, U>::new()` will
-                // use an inference variable for `C` with `[T, U]`
-                // as the generic parameters for the default, `(T, U)`.
                 let ty_var_id = self
                     .inner
                     .borrow_mut()
                     .type_variables()
                     .new_var(self.universe(), TypeVariableOrigin { param_def_id: None });
-
                 Ty::new_var(self.interner, ty_var_id).into()
             }
             GenericParamId::ConstParamId(_) => {
         def_id: SolverDefId,
         first: impl IntoIterator<Item = GenericArg<'db>>,
     ) -> GenericArgs<'db> {
-        GenericArgs::fill_rest(self.interner, def_id, first, |_index, kind, _| {
+        GenericArgs::fill_rest(
+            self.interner,
+            def_id,
+            first,
+            |_index, kind, _| {
             self.var_for_def(kind)
-        })
+        },
+        )
     }
 
     /// Returns `true` if errors have been reported since this infcx was
         if let TyKind::Infer(v) = ty.kind() {
             match v {
                 InferTy::TyVar(v) => {
-                    // Not entirely obvious: if `typ` is a type variable,
-                    // it can be resolved to an int/float variable, which
-                    // can then be recursively resolved, hence the
-                    // recursion. Note though that we prevent type
-                    // variables from unifying to other type variables
-                    // directly (though they may be embedded
-                    // structurally), and we prevent cycles in any case,
-                    // so this recursion should always be of very limited
-                    // depth.
-                    //
-                    // Note: if these two lines are combined into one we get
-                    // dynamic borrow errors on `self.inner`.
                     let known = self.inner.borrow_mut().type_variables().probe(v).known();
                     known.map_or(ty, |t| self.shallow_resolve(t))
                 }
-
                 InferTy::IntVar(v) => {
                     match self.inner.borrow_mut().int_unification_table().probe_value(v) {
                         IntVarValue::IntType(ty) => Ty::new_int(self.interner, ty),
                         IntVarValue::Unknown => ty,
                     }
                 }
-
                 InferTy::FloatVar(v) => {
                     match self.inner.borrow_mut().float_unification_table().probe_value(v) {
                         FloatVarValue::Known(ty) => Ty::new_float(self.interner, ty),
                         FloatVarValue::Unknown => ty,
                     }
                 }
-
                 InferTy::FreshTy(_) | InferTy::FreshIntTy(_) | InferTy::FreshFloatTy(_) => ty,
             }
         } else {
     pub fn shallow_resolve_const(&self, ct: Const<'db>) -> Const<'db> {
         match ct.kind() {
             ConstKind::Infer(infer_ct) => match infer_ct {
-                InferConst::Var(vid) => self
-                    .inner
-                    .borrow_mut()
-                    .const_unification_table()
-                    .probe_value(vid)
-                    .known()
-                    .unwrap_or(ct),
+                InferConst::Var(vid) => self.inner.borrow_mut().const_unification_table().probe_value(vid).known().unwrap_or(
+                    ct,
+                ),
                 InferConst::Fresh(_) => ct,
             },
             ConstKind::Param(_)
         }
     }
 
-    // Instantiates the bound variables in a given binder with fresh inference
-    // variables in the current universe.
-    //
-    // Use this method if you'd like to find some generic parameters of the binder's
-    // variables (e.g. during a method call). If there isn't a [`BoundRegionConversionTime`]
-    // that corresponds to your use case, consider whether or not you should
-    // use [`InferCtxt::enter_forall`] instead.
     pub fn instantiate_binder_with_fresh_vars<T>(
         &self,
         _lbrct: BoundRegionConversionTime,
         match infer_var {
             TyOrConstInferVar::Ty(v) => {
                 use self::type_variable::TypeVariableValue;
-
-                // If `inlined_probe` returns a `Known` value, it never equals
-                // `Infer(TyVar(v))`.
                 match self.inner.borrow_mut().type_variables().inlined_probe(v) {
                     TypeVariableValue::Unknown { .. } => false,
                     TypeVariableValue::Known { .. } => true,
                 }
             }
-
             TyOrConstInferVar::TyInt(v) => {
-                // If `inlined_probe_value` returns a value it's always a
-                // `Int(_)` or `UInt(_)`, which never matches a
-                // `Infer(_)`.
                 self.inner.borrow_mut().int_unification_table().inlined_probe_value(v).is_known()
             }
-
             TyOrConstInferVar::TyFloat(v) => {
-                // If `probe_value` returns a value it's always a
-                // `Float(_)`, which never matches a `Infer(_)`.
-                //
-                // Not `inlined_probe_value(v)` because this call site is colder.
                 self.inner.borrow_mut().float_unification_table().probe_value(v).is_known()
             }
-
             TyOrConstInferVar::Const(v) => {
-                // If `probe_value` returns a `Known` value, it never equals
-                // `ConstKind::Infer(InferConst::Var(v))`.
-                //
-                // Not `inlined_probe_value(v)` because this call site is colder.
                 match self.inner.borrow_mut().const_unification_table().probe_value(v) {
                     ConstVariableValue::Unknown { .. } => false,
                     ConstVariableValue::Known { .. } => true,
         a: TraitRef<'db>,
         b: TraitRef<'db>,
     ) -> TypeTrace<'db> {
-        TypeTrace { cause: cause.clone(), values: ValuePairs::TraitRefs(ExpectedFound::new(a, b)) }
+        TypeTrace {
+            cause: cause.clone(),
+            values: ValuePairs::TraitRefs(ExpectedFound::new(a, b)),
+        }
     }
 
     pub fn consts(cause: &ObligationCause, a: Const<'db>, b: Const<'db>) -> TypeTrace<'db> {
     /// The `DefId` and args of the opaque type causing this constraint.
     /// Used for error reporting.
     pub key: OpaqueTypeKey<'db>,
-
     /// The hidden type in which `member_region` appears: used for error reporting.
     pub hidden_ty: Ty<'db>,
-
     /// The region `R0`.
     pub member_region: Region<'db>,
-
     /// The options `O1..On`.
     pub choice_regions: Arc<Vec<Region<'db>>>,
 }