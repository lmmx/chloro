COMPARISON DIFF
============================================================

Original size: 49754 bytes
Chloro size:   49872 bytes
Rustfmt size:  49754 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
     error::{ExpectedFound, TypeError},
     inherent::{
-        Const as _, GenericArg as _, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _,
+        Const as _, GenericArgs as _, GenericArg as _, IntoKind, SliceLike, Term as _, Ty as _,
     },
 };
 use snapshot::undo_log::InferCtxtUndoLogs;
     pub value: T,
     pub obligations: PredicateObligations<'db>,
 }
+
 pub type InferResult<'db, T> = Result<InferOk<'db, T>, TypeError<DbInterner<'db>>>;
 
-pub(crate) type UnificationTable<'a, 'db, T> = ut::UnificationTable<
+pub(crate) type UnificationTable<'a, 'db, T> =
+    ut::UnificationTable<
     ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut InferCtxtUndoLogs<'db>>,
 >;
 
 #[derive(Clone)]
 pub struct InferCtxtInner<'db> {
     pub(crate) undo_log: InferCtxtUndoLogs<'db>,
-
     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types
     /// that might instantiate a general type variable have an order,
     /// represented by its upper and lower bounds.
     pub(crate) type_variable_storage: type_variable::TypeVariableStorage<'db>,
-
     /// Map from const parameter variable to the kind of const it represents.
     pub(crate) const_unification_storage: ut::UnificationTableStorage<ConstVidKey<'db>>,
-
     /// Map from integral variable to the kind of integer it represents.
     pub(crate) int_unification_storage: ut::UnificationTableStorage<IntVid>,
-
     /// Map from floating variable to the kind of float it represents.
     pub(crate) float_unification_storage: ut::UnificationTableStorage<FloatVid>,
-
     /// Tracks the set of region variables and the constraints between them.
     ///
     /// This is initially `Some(_)` but when
     /// -- further attempts to perform unification, etc., may fail if new
     /// region constraints would've been added.
     pub(crate) region_constraint_storage: Option<RegionConstraintStorage<'db>>,
-
     /// A set of constraints that regionck must validate.
     ///
     /// Each constraint has the form `T:'a`, meaning "some type `T` must
     /// obligations within. This is expected to be done 'late enough'
     /// that all type inference variables have been bound and so forth.
     pub(crate) region_obligations: Vec<RegionObligation<'db>>,
-
     /// Caches for opaque type inference.
     pub(crate) opaque_type_storage: OpaqueTypeStorage<'db>,
 }
     fn new() -> InferCtxtInner<'db> {
         InferCtxtInner {
             undo_log: InferCtxtUndoLogs::default(),
-
             type_variable_storage: Default::default(),
             const_unification_storage: Default::default(),
             int_unification_storage: Default::default(),
 #[derive(Clone)]
 pub struct InferCtxt<'db> {
     pub interner: DbInterner<'db>,
-
     /// The mode of this inference context, see the struct documentation
     /// for more details.
     typing_mode: TypingMode<'db>,
-
     pub inner: RefCell<InferCtxtInner<'db>>,
-
     /// When an error occurs, we want to avoid reporting "derived"
     /// errors that are due to this original failure. We have this
     /// flag that one can set whenever one creates a type-error that
     /// Don't read this flag directly, call `is_tainted_by_errors()`
     /// and `set_tainted_by_errors()`.
     tainted_by_errors: Cell<Option<ErrorGuaranteed>>,
-
     /// What is the innermost universe we have created? Starts out as
     /// `UniverseIndex::root()` but grows from there as we enter
     /// universal quantifiers.
 }
 
 #[derive(Copy, Clone, Debug)]
-pub struct FixupError {
-    unresolved: TyOrConstInferVar,
-}
+pub struct FixupError { unresolved: TyOrConstInferVar }
 
 impl fmt::Display for FixupError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 }
 
 /// Used to configure inference contexts before their creation.
-pub struct InferCtxtBuilder<'db> {
-    interner: DbInterner<'db>,
-}
+pub struct InferCtxtBuilder<'db> { interner: DbInterner<'db> }
 
 pub trait DbInternerInferExt<'db> {
     fn infer_ctxt(self) -> InferCtxtBuilder<'db>;
         &self,
         obligation: &PredicateObligation<'db>,
     ) -> bool {
-        <&SolverContext<'db>>::from(self).root_goal_may_hold_opaque_types_jank(Goal::new(
-            self.interner,
-            obligation.param_env,
-            obligation.predicate,
-        ))
+        <&SolverContext<'db>>::from(self).root_goal_may_hold_opaque_types_jank(
+            Goal::new(self.interner, obligation.param_env, obligation.predicate),
+        )
     }
 
     pub(crate) fn insert_type_vars<T>(&self, ty: T) -> T
             _ => {}
         }
 
-        self.enter_forall(predicate, |SubtypePredicate { a_is_expected, a, b }| {
+        self.enter_forall(
+            predicate,
+            |SubtypePredicate { a_is_expected, a, b }| {
             if a_is_expected {
                 Ok(self.at(cause, param_env).sub(a, b))
             } else {
                 Ok(self.at(cause, param_env).sup(b, a))
             }
-        })
+        },
+        )
     }
 
     pub fn region_outlives_predicate(
         _cause: &traits::ObligationCause,
         predicate: PolyRegionOutlivesPredicate<'db>,
     ) {
-        self.enter_forall(predicate, |OutlivesPredicate(r_a, r_b)| {
+        self.enter_forall(
+            predicate,
+            |OutlivesPredicate(r_a, r_b)| {
             self.sub_regions(r_b, r_a); // `b : a` ==> `a <= b`
-        })
+        },
+        )
     }
 
     /// Number of type variables created so far.
         def_id: SolverDefId,
         first: impl IntoIterator<Item = GenericArg<'db>>,
     ) -> GenericArgs<'db> {
-        GenericArgs::fill_rest(self.interner, def_id, first, |_index, kind, _| {
+        GenericArgs::fill_rest(
+            self.interner,
+            def_id,
+            first,
+            |_index, kind, _| {
             self.var_for_def(kind)
-        })
+        },
+        )
     }
 
     /// Returns `true` if errors have been reported since this infcx was
         a: TraitRef<'db>,
         b: TraitRef<'db>,
     ) -> TypeTrace<'db> {
-        TypeTrace { cause: cause.clone(), values: ValuePairs::TraitRefs(ExpectedFound::new(a, b)) }
+        TypeTrace {
+            cause: cause.clone(),
+            values: ValuePairs::TraitRefs(ExpectedFound::new(a, b)),
+        }
     }
 
     pub fn consts(cause: &ObligationCause, a: Const<'db>, b: Const<'db>) -> TypeTrace<'db> {
     /// The `DefId` and args of the opaque type causing this constraint.
     /// Used for error reporting.
     pub key: OpaqueTypeKey<'db>,
-
     /// The hidden type in which `member_region` appears: used for error reporting.
     pub hidden_ty: Ty<'db>,
-
     /// The region `R0`.
     pub member_region: Region<'db>,
-
     /// The options `O1..On`.
     pub choice_regions: Arc<Vec<Region<'db>>>,
 }