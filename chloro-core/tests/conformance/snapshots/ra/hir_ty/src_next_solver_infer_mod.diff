COMPARISON DIFF
============================================================

Original size: 49754 bytes
Chloro size:   50169 bytes
Rustfmt size:  49754 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Infer context the next-trait-solver.
 
-use std::cell::{Cell, RefCell};
-use std::fmt;
-use std::ops::Range;
-use std::sync::Arc;
-
-pub use BoundRegionConversionTime::*;
-use ena::unify as ut;
-use hir_def::GenericParamId;
-use hir_def::lang_item::LangItem;
-use opaque_types::{OpaqueHiddenType, OpaqueTypeStorage};
-use region_constraints::{RegionConstraintCollector, RegionConstraintStorage};
-use rustc_next_trait_solver::solve::SolverDelegateEvalExt;
-use rustc_pattern_analysis::Captures;
-use rustc_type_ir::{
-    ClosureKind, ConstVid, FloatVarValue, FloatVid, GenericArgKind, InferConst, InferTy,
-    IntVarValue, IntVid, OutlivesPredicate, RegionVid, TermKind, TyVid, TypeFoldable, TypeFolder,
-    TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
-    error::{ExpectedFound, TypeError},
-    inherent::{
-        Const as _, GenericArg as _, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _,
-    },
-};
-use snapshot::undo_log::InferCtxtUndoLogs;
-use tracing::{debug, instrument};
-use traits::{ObligationCause, PredicateObligations};
-use type_variable::TypeVariableOrigin;
-use unify_key::{ConstVariableOrigin, ConstVariableValue, ConstVidKey};
-
-use crate::next_solver::{
-    BoundConst, BoundRegion, BoundTy, BoundVarKind, Goal, SolverContext,
-    fold::BoundVarReplacerDelegate,
-    infer::{select::EvaluationResult, traits::PredicateObligation},
-    obligation_ctxt::ObligationCtxt,
-};
-
-use super::{
-    AliasTerm, Binder, CanonicalQueryInput, CanonicalVarValues, Const, ConstKind, DbInterner,
-    ErrorGuaranteed, GenericArg, GenericArgs, OpaqueTypeKey, ParamEnv, PolyCoercePredicate,
-    PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, PolyRegionOutlivesPredicate,
-    PolySubtypePredicate, Region, SolverDefId, SubtypePredicate, Term, TraitRef, Ty, TyKind,
-    TypingMode,
-};
-
 pub mod at;
 pub mod canonical;
 mod context;
 mod type_variable;
 mod unify_key;
 
+use std::cell::{Cell, RefCell};
+use std::fmt;
+use std::ops::Range;
+use std::sync::Arc;
+
+use ena::unify as ut;
+use hir_def::GenericParamId;
+use hir_def::lang_item::LangItem;
+use opaque_types::{OpaqueHiddenType, OpaqueTypeStorage};
+use region_constraints::{RegionConstraintCollector, RegionConstraintStorage};
+use rustc_next_trait_solver::solve::SolverDelegateEvalExt;
+use rustc_pattern_analysis::Captures;
+use rustc_type_ir::{
+    error::{ExpectedFound,
+
+    inherent::{
+        Const as _,
+
+    ClosureKind, ConstVid, FloatVarValue, FloatVid, GenericArg as _, GenericArgKind,
+    GenericArgs as _, InferConst, InferTy, IntVarValue, IntVid, IntoKind, OutlivesPredicate,
+    RegionVid, SliceLike, Term as _, TermKind, Ty as _, TyVid, TypeError}, TypeFoldable, TypeFolder,
+    TypeSuperFoldable, TypeVisitableExt, UniverseIndex, },
+};
+use snapshot::undo_log::InferCtxtUndoLogs;
+use tracing::{debug, instrument};
+use traits::{ObligationCause, PredicateObligations};
+use type_variable::TypeVariableOrigin;
+use unify_key::{ConstVariableOrigin, ConstVariableValue, ConstVidKey};
+pub use BoundRegionConversionTime::*;
+
+use crate::next_solver::{
+    fold::BoundVarReplacerDelegate,
+
+    infer::{select::EvaluationResult,
+
+    obligation_ctxt::ObligationCtxt,
+
+    traits::PredicateObligation},
+
+    BoundConst, BoundRegion, BoundTy, BoundVarKind, Goal, SolverContext,
+};
+use super::{
+    AliasTerm, Binder, CanonicalQueryInput, CanonicalVarValues, Const, ConstKind, DbInterner,
+    ErrorGuaranteed, GenericArg, GenericArgs, OpaqueTypeKey, ParamEnv, PolyCoercePredicate,
+    PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, PolyRegionOutlivesPredicate,
+    PolySubtypePredicate, Region, SolverDefId, SubtypePredicate, Term, TraitRef, Ty, TyKind,
+    TypingMode,
+};
+
 /// `InferOk<'db, ()>` is used a lot. It may seem like a useless wrapper
 /// around `PredicateObligations`, but it has one important property:
 /// because `InferOk` is marked with `#[must_use]`, if you have a method
     pub value: T,
     pub obligations: PredicateObligations<'db>,
 }
+
 pub type InferResult<'db, T> = Result<InferOk<'db, T>, TypeError<DbInterner<'db>>>;
 
-pub(crate) type UnificationTable<'a, 'db, T> = ut::UnificationTable<
+pub(crate) type UnificationTable<'a, 'db, T> =
+    ut::UnificationTable<
     ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut InferCtxtUndoLogs<'db>>,
 >;
 
 #[derive(Clone)]
 pub struct InferCtxtInner<'db> {
     pub(crate) undo_log: InferCtxtUndoLogs<'db>,
-
     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types
     /// that might instantiate a general type variable have an order,
     /// represented by its upper and lower bounds.
     pub(crate) type_variable_storage: type_variable::TypeVariableStorage<'db>,
-
     /// Map from const parameter variable to the kind of const it represents.
     pub(crate) const_unification_storage: ut::UnificationTableStorage<ConstVidKey<'db>>,
-
     /// Map from integral variable to the kind of integer it represents.
     pub(crate) int_unification_storage: ut::UnificationTableStorage<IntVid>,
-
     /// Map from floating variable to the kind of float it represents.
     pub(crate) float_unification_storage: ut::UnificationTableStorage<FloatVid>,
-
     /// Tracks the set of region variables and the constraints between them.
     ///
     /// This is initially `Some(_)` but when
     /// -- further attempts to perform unification, etc., may fail if new
     /// region constraints would've been added.
     pub(crate) region_constraint_storage: Option<RegionConstraintStorage<'db>>,
-
     /// A set of constraints that regionck must validate.
     ///
     /// Each constraint has the form `T:'a`, meaning "some type `T` must
     /// obligations within. This is expected to be done 'late enough'
     /// that all type inference variables have been bound and so forth.
     pub(crate) region_obligations: Vec<RegionObligation<'db>>,
-
     /// Caches for opaque type inference.
     pub(crate) opaque_type_storage: OpaqueTypeStorage<'db>,
 }
 #[derive(Clone)]
 pub struct InferCtxt<'db> {
     pub interner: DbInterner<'db>,
-
     /// The mode of this inference context, see the struct documentation
     /// for more details.
     typing_mode: TypingMode<'db>,
-
     pub inner: RefCell<InferCtxtInner<'db>>,
-
     /// When an error occurs, we want to avoid reporting "derived"
     /// errors that are due to this original failure. We have this
     /// flag that one can set whenever one creates a type-error that
     /// Don't read this flag directly, call `is_tainted_by_errors()`
     /// and `set_tainted_by_errors()`.
     tainted_by_errors: Cell<Option<ErrorGuaranteed>>,
-
     /// What is the innermost universe we have created? Starts out as
     /// `UniverseIndex::root()` but grows from there as we enter
     /// universal quantifiers.
 pub enum BoundRegionConversionTime {
     /// when a fn is called
     FnCall,
-
     /// when two higher-ranked types are compared
     HigherRankedType,
-
     /// when projecting an associated type
     AssocTypeProjection(SolverDefId),
 }
 }
 
 impl fmt::Display for FixupError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         use TyOrConstInferVar::*;
-
         match self.unresolved {
             TyInt(_) => write!(
                 f,
         input: &CanonicalQueryInput<'db, T>,
     ) -> (InferCtxt<'db>, T, CanonicalVarValues<'db>)
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         let infcx = self.build(input.typing_mode);
         let (value, args) = infcx.instantiate_canonical(&input.canonical);
         (infcx, value, args)
     }
 
-    pub fn build(&mut self, typing_mode: TypingMode<'db>) -> InferCtxt<'db> {
+    pub fn build(
+        &mut self,
+        typing_mode: TypingMode<'db>,
+    ) -> InferCtxt<'db> {
         let InferCtxtBuilder { interner } = *self;
         InferCtxt {
             interner,
         ))
     }
 
-    pub(crate) fn insert_type_vars<T>(&self, ty: T) -> T
+    pub(crate) fn insert_type_vars<T>(
+        &self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         struct Folder<'a, 'db> {
             infcx: &'a InferCtxt<'db>,
         }
                 if r.is_error() { self.infcx.next_region_var() } else { r }
             }
         }
-
         ty.fold_with(&mut Folder { infcx: self })
     }
 
     ///
     /// This version ignores all outlives constraints.
     #[expect(dead_code, reason = "this is used in rustc")]
-    fn predicate_must_hold_modulo_regions(&self, obligation: &PredicateObligation<'db>) -> bool {
+    fn predicate_must_hold_modulo_regions(
+        &self,
+        obligation: &PredicateObligation<'db>,
+    ) -> bool {
         self.evaluate_obligation(obligation).must_apply_modulo_regions()
     }
 
     /// Evaluate a given predicate, capturing overflow and propagating it back.
-    fn evaluate_obligation(&self, obligation: &PredicateObligation<'db>) -> EvaluationResult {
+    fn evaluate_obligation(
+        &self,
+        obligation: &PredicateObligation<'db>,
+    ) -> EvaluationResult {
         self.probe(|snapshot| {
             let mut ocx = ObligationCtxt::new(self);
             ocx.register_obligation(obligation.clone());
         })
     }
 
-    pub fn type_is_copy_modulo_regions(&self, param_env: ParamEnv<'db>, ty: Ty<'db>) -> bool {
+    pub fn type_is_copy_modulo_regions(
+        &self,
+        param_env: ParamEnv<'db>,
+        ty: Ty<'db>,
+    ) -> bool {
         let ty = self.resolve_vars_if_possible(ty);
-
         let Some(copy_def_id) =
             LangItem::Copy.resolve_trait(self.interner.db, self.interner.krate.unwrap())
         else {
             return false;
         };
-
         // This can get called from typeck (by euv), and `moves_by_default`
         // rightly refuses to work with inference variables, but
         // moves_by_default has a cache, which we want to use in other
     }
 
     #[instrument(skip(self), level = "debug")]
-    pub fn sub_regions(&self, a: Region<'db>, b: Region<'db>) {
+    pub fn sub_regions(
+        &self,
+        a: Region<'db>,
+        b: Region<'db>,
+    ) {
         self.inner.borrow_mut().unwrap_region_constraints().make_subregion(a, b);
     }
 
             }
             _ => {}
         }
-
         self.enter_forall(predicate, |SubtypePredicate { a_is_expected, a, b }| {
             if a_is_expected {
                 Ok(self.at(cause, param_env).sub(a, b))
             .new_var(self.universe(), TypeVariableOrigin { param_def_id: None })
     }
 
-    pub fn next_ty_var_with_origin(&self, origin: TypeVariableOrigin) -> Ty<'db> {
+    pub fn next_ty_var_with_origin(
+        &self,
+        origin: TypeVariableOrigin,
+    ) -> Ty<'db> {
         let vid = self.inner.borrow_mut().type_variables().new_var(self.universe(), origin);
         Ty::new_var(self.interner, vid)
     }
 
-    pub fn next_ty_var_id_in_universe(&self, universe: UniverseIndex) -> TyVid {
+    pub fn next_ty_var_id_in_universe(
+        &self,
+        universe: UniverseIndex,
+    ) -> TyVid {
         let origin = TypeVariableOrigin { param_def_id: None };
         self.inner.borrow_mut().type_variables().new_var(universe, origin)
     }
 
-    pub fn next_ty_var_in_universe(&self, universe: UniverseIndex) -> Ty<'db> {
+    pub fn next_ty_var_in_universe(
+        &self,
+        universe: UniverseIndex,
+    ) -> Ty<'db> {
         let vid = self.next_ty_var_id_in_universe(universe);
         Ty::new_var(self.interner, vid)
     }
             .vid
     }
 
-    pub fn next_const_var_with_origin(&self, origin: ConstVariableOrigin) -> Const<'db> {
+    pub fn next_const_var_with_origin(
+        &self,
+        origin: ConstVariableOrigin,
+    ) -> Const<'db> {
         let vid = self
             .inner
             .borrow_mut()
         Const::new_var(self.interner, vid)
     }
 
-    pub fn next_const_var_in_universe(&self, universe: UniverseIndex) -> Const<'db> {
+    pub fn next_const_var_in_universe(
+        &self,
+        universe: UniverseIndex,
+    ) -> Const<'db> {
         let origin = ConstVariableOrigin {};
         let vid = self
             .inner
     /// Creates a fresh region variable with the next available index
     /// in the given universe; typically, you can use
     /// `next_region_var` and just use the maximal universe.
-    pub fn next_region_var_in_universe(&self, universe: UniverseIndex) -> Region<'db> {
+    pub fn next_region_var_in_universe(
+        &self,
+        universe: UniverseIndex,
+    ) -> Region<'db> {
         let region_var =
             self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe);
         Region::new_var(self.interner, region_var)
     }
 
-    pub fn next_term_var_of_kind(&self, term: Term<'db>) -> Term<'db> {
+    pub fn next_term_var_of_kind(
+        &self,
+        term: Term<'db>,
+    ) -> Term<'db> {
         match term.kind() {
             TermKind::Ty(_) => self.next_ty_var().into(),
             TermKind::Const(_) => self.next_const_var().into(),
     /// etc) this is the root universe U0. For inference variables or
     /// placeholders, however, it will return the universe which they
     /// are associated.
-    pub fn universe_of_region(&self, r: Region<'db>) -> UniverseIndex {
+    pub fn universe_of_region(
+        &self,
+        r: Region<'db>,
+    ) -> UniverseIndex {
         self.inner.borrow_mut().unwrap_region_constraints().universe(r)
     }
 
 
     /// Just a convenient wrapper of `next_region_var` for using during NLL.
     #[instrument(skip(self), level = "debug")]
-    pub fn next_nll_region_var_in_universe(&self, universe: UniverseIndex) -> Region<'db> {
+    pub fn next_nll_region_var_in_universe(
+        &self,
+        universe: UniverseIndex,
+    ) -> Region<'db> {
         self.next_region_var_in_universe(universe)
     }
 
-    fn var_for_def(&self, id: GenericParamId) -> GenericArg<'db> {
+    fn var_for_def(
+        &self,
+        id: GenericParamId,
+    ) -> GenericArg<'db> {
         match id {
             GenericParamId::LifetimeParamId(_) => {
                 // Create a region inference variable for the given
 
     /// Given a set of generics defined on a type or impl, returns the generic parameters mapping
     /// each type/region parameter to a fresh inference variable.
-    pub fn fresh_args_for_item(&self, def_id: SolverDefId) -> GenericArgs<'db> {
+    pub fn fresh_args_for_item(
+        &self,
+        def_id: SolverDefId,
+    ) -> GenericArgs<'db> {
         GenericArgs::for_item(self.interner, def_id, |_index, kind, _| self.var_for_def(kind))
     }
 
 
     /// Set the "tainted by errors" flag to true. We call this when we
     /// observe an error from a prior pass.
-    pub fn set_tainted_by_errors(&self, e: ErrorGuaranteed) {
+    pub fn set_tainted_by_errors(
+        &self,
+        e: ErrorGuaranteed,
+    ) {
         debug!("set_tainted_by_errors(ErrorGuaranteed)");
         self.tainted_by_errors.set(Some(e));
     }
     }
 
     #[inline(always)]
-    pub fn can_define_opaque_ty(&self, id: impl Into<SolverDefId>) -> bool {
+    pub fn can_define_opaque_ty(
+        &self,
+        id: impl Into<SolverDefId>,
+    ) -> bool {
         match self.typing_mode_unchecked() {
             TypingMode::Analysis { defining_opaque_types_and_generators } => {
                 defining_opaque_types_and_generators.contains(&id.into())
 
     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the
     /// universe index of `TyVar(vid)`.
-    pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'db>, UniverseIndex> {
+    pub fn probe_ty_var(
+        &self,
+        vid: TyVid,
+    ) -> Result<Ty<'db>, UniverseIndex> {
         use self::type_variable::TypeVariableValue;
-
         match self.inner.borrow_mut().type_variables().probe(vid) {
             TypeVariableValue::Known { value } => Ok(value),
             TypeVariableValue::Unknown { universe } => Err(universe),
         }
     }
 
-    pub fn shallow_resolve(&self, ty: Ty<'db>) -> Ty<'db> {
+    pub fn shallow_resolve(
+        &self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         if let TyKind::Infer(v) = ty.kind() {
             match v {
                 InferTy::TyVar(v) => {
         }
     }
 
-    pub fn shallow_resolve_const(&self, ct: Const<'db>) -> Const<'db> {
+    pub fn shallow_resolve_const(
+        &self,
+        ct: Const<'db>,
+    ) -> Const<'db> {
         match ct.kind() {
             ConstKind::Infer(infer_ct) => match infer_ct {
                 InferConst::Var(vid) => self
         }
     }
 
-    pub fn root_var(&self, var: TyVid) -> TyVid {
+    pub fn root_var(
+        &self,
+        var: TyVid,
+    ) -> TyVid {
         self.inner.borrow_mut().type_variables().root_var(var)
     }
 
-    pub fn root_const_var(&self, var: ConstVid) -> ConstVid {
+    pub fn root_const_var(
+        &self,
+        var: ConstVid,
+    ) -> ConstVid {
         self.inner.borrow_mut().const_unification_table().find(var).vid
     }
 
     /// Resolves an int var to a rigid int type, if it was constrained to one,
     /// or else the root int var in the unification table.
-    pub fn opportunistic_resolve_int_var(&self, vid: IntVid) -> Ty<'db> {
+    pub fn opportunistic_resolve_int_var(
+        &self,
+        vid: IntVid,
+    ) -> Ty<'db> {
         let mut inner = self.inner.borrow_mut();
         let value = inner.int_unification_table().probe_value(vid);
         match value {
         }
     }
 
-    pub fn resolve_int_var(&self, vid: IntVid) -> Option<Ty<'db>> {
+    pub fn resolve_int_var(
+        &self,
+        vid: IntVid,
+    ) -> Option<Ty<'db>> {
         let mut inner = self.inner.borrow_mut();
         let value = inner.int_unification_table().probe_value(vid);
         match value {
 
     /// Resolves a float var to a rigid int type, if it was constrained to one,
     /// or else the root float var in the unification table.
-    pub fn opportunistic_resolve_float_var(&self, vid: FloatVid) -> Ty<'db> {
+    pub fn opportunistic_resolve_float_var(
+        &self,
+        vid: FloatVid,
+    ) -> Ty<'db> {
         let mut inner = self.inner.borrow_mut();
         let value = inner.float_unification_table().probe_value(vid);
         match value {
         }
     }
 
-    pub fn resolve_float_var(&self, vid: FloatVid) -> Option<Ty<'db>> {
+    pub fn resolve_float_var(
+        &self,
+        vid: FloatVid,
+    ) -> Option<Ty<'db>> {
         let mut inner = self.inner.borrow_mut();
         let value = inner.float_unification_table().probe_value(vid);
         match value {
     /// is left as is. This is an idempotent operation that does
     /// not affect inference state in any way and so you can do it
     /// at will.
-    pub fn resolve_vars_if_possible<T>(&self, value: T) -> T
+    pub fn resolve_vars_if_possible<T>(
+        &self,
+        value: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         if let Err(guar) = value.error_reported() {
             self.set_tainted_by_errors(guar);
         }
         value.fold_with(&mut r)
     }
 
-    pub fn probe_const_var(&self, vid: ConstVid) -> Result<Const<'db>, UniverseIndex> {
+    pub fn probe_const_var(
+        &self,
+        vid: ConstVid,
+    ) -> Result<Const<'db>, UniverseIndex> {
         match self.inner.borrow_mut().const_unification_table().probe_value(vid) {
             ConstVariableValue::Known { value } => Ok(value),
             ConstVariableValue::Unknown { origin: _, universe } => Err(universe),
         }
     }
 
-    // Instantiates the bound variables in a given binder with fresh inference
-    // variables in the current universe.
-    //
-    // Use this method if you'd like to find some generic parameters of the binder's
-    // variables (e.g. during a method call). If there isn't a [`BoundRegionConversionTime`]
-    // that corresponds to your use case, consider whether or not you should
-    // use [`InferCtxt::enter_forall`] instead.
     pub fn instantiate_binder_with_fresh_vars<T>(
         &self,
         _lbrct: BoundRegionConversionTime,
         value: Binder<'db, T>,
     ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>> + Clone,
-    {
+        T: TypeFoldable<DbInterner<'db>> + Clone, {
         if let Some(inner) = value.clone().no_bound_vars() {
             return inner;
         }
-
         let bound_vars = value.clone().bound_vars();
         let mut args = Vec::with_capacity(bound_vars.len());
-
         for bound_var_kind in bound_vars {
             let arg: GenericArg<'db> = match bound_var_kind {
                 BoundVarKind::Ty(_) => self.next_ty_var().into(),
             };
             args.push(arg);
         }
-
         struct ToFreshVars<'db> {
             args: Vec<GenericArg<'db>>,
         }
-
         impl<'db> BoundVarReplacerDelegate<'db> for ToFreshVars<'db> {
             fn replace_region(&mut self, br: BoundRegion) -> Region<'db> {
                 self.args[br.var.index()].expect_region()
     /// Obtains the latest type of the given closure; this may be a
     /// closure in the current function, in which case its
     /// `ClosureKind` may not yet be known.
-    pub fn closure_kind(&self, closure_ty: Ty<'db>) -> Option<ClosureKind> {
+    pub fn closure_kind(
+        &self,
+        closure_ty: Ty<'db>,
+    ) -> Option<ClosureKind> {
         let unresolved_kind_ty = match closure_ty.kind() {
             TyKind::Closure(_, args) => args.as_closure().kind_ty(),
             TyKind::CoroutineClosure(_, args) => args.as_coroutine_closure().kind_ty(),
     /// The returned function is used in a fast path. If it returns `true` the variable is
     /// unchanged, `false` indicates that the status is unknown.
     #[inline]
-    pub fn is_ty_infer_var_definitely_unchanged<'a>(
-        &'a self,
-    ) -> impl Fn(TyOrConstInferVar) -> bool + Captures<'db> + 'a {
+    pub fn is_ty_infer_var_definitely_unchanged<'a>(&'a self) -> impl Fn(TyOrConstInferVar) -> bool + Captures<'db> + 'a {
         // This hoists the borrow/release out of the loop body.
         let inner = self.inner.try_borrow();
-
         move |infer_var: TyOrConstInferVar| match (infer_var, &inner) {
             (TyOrConstInferVar::Ty(ty_var), Ok(inner)) => {
                 use self::type_variable::TypeVariableValue;
     /// inference variables), and it handles both `Ty` and `Const` without
     /// having to resort to storing full `GenericArg`s in `stalled_on`.
     #[inline(always)]
-    pub fn ty_or_const_infer_var_changed(&self, infer_var: TyOrConstInferVar) -> bool {
+    pub fn ty_or_const_infer_var_changed(
+        &self,
+        infer_var: TyOrConstInferVar,
+    ) -> bool {
         match infer_var {
             TyOrConstInferVar::Ty(v) => {
                 use self::type_variable::TypeVariableValue;
         }
     }
 
-    fn sub_unification_table_root_var(&self, var: rustc_type_ir::TyVid) -> rustc_type_ir::TyVid {
+    fn sub_unification_table_root_var(
+        &self,
+        var: rustc_type_ir::TyVid,
+    ) -> rustc_type_ir::TyVid {
         self.inner.borrow_mut().type_variables().sub_unification_table_root_var(var)
     }
 
-    fn sub_unify_ty_vids_raw(&self, a: rustc_type_ir::TyVid, b: rustc_type_ir::TyVid) {
+    fn sub_unify_ty_vids_raw(
+        &self,
+        a: rustc_type_ir::TyVid,
+        b: rustc_type_ir::TyVid,
+    ) {
         self.inner.borrow_mut().type_variables().sub_unify(a, b);
     }
 }
     TyInt(IntVid),
     /// Equivalent to `Infer(FloatVar(_))`.
     TyFloat(FloatVid),
-
     /// Equivalent to `ConstKind::Infer(InferConst::Var(_))`.
     Const(ConstVid),
 }
 }
 
 impl<'db> TypeTrace<'db> {
-    pub fn types(cause: &ObligationCause, a: Ty<'db>, b: Ty<'db>) -> TypeTrace<'db> {
+    pub fn types(
+        cause: &ObligationCause,
+        a: Ty<'db>,
+        b: Ty<'db>,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: ValuePairs::Terms(ExpectedFound::new(a.into(), b.into())),
         TypeTrace { cause: cause.clone(), values: ValuePairs::TraitRefs(ExpectedFound::new(a, b)) }
     }
 
-    pub fn consts(cause: &ObligationCause, a: Const<'db>, b: Const<'db>) -> TypeTrace<'db> {
+    pub fn consts(
+        cause: &ObligationCause,
+        a: Const<'db>,
+        b: Const<'db>,
+    ) -> TypeTrace<'db> {
         TypeTrace {
             cause: cause.clone(),
             values: ValuePairs::Terms(ExpectedFound::new(a.into(), b.into())),
     /// The `DefId` and args of the opaque type causing this constraint.
     /// Used for error reporting.
     pub key: OpaqueTypeKey<'db>,
-
     /// The hidden type in which `member_region` appears: used for error reporting.
     pub hidden_ty: Ty<'db>,
-
     /// The region `R0`.
     pub member_region: Region<'db>,
-
     /// The options `O1..On`.
     pub choice_regions: Arc<Vec<Region<'db>>>,
 }