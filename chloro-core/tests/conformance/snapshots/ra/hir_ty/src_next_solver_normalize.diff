COMPARISON DIFF
============================================================

Original size: 9789 bytes
Chloro size:   9728 bytes
Rustfmt size:  9886 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::next_solver::{
     fulfill::{FulfillmentCtxt, NextSolverError},
-    infer::{
-        at::At,
-        traits::{Obligation, ObligationCause},
-        InferCtxt,
-    },
+    infer::{at::At, traits::{Obligation, ObligationCause}, InferCtxt},
     util::PlaceholderReplacer,
     Binder, Const, ConstKind, DbInterner, Goal, ParamEnv, Predicate, PredicateKind, Term, Ty,
     TyKind,
 
 /// Deeply normalize all aliases in `value`. This does not handle inference and expects
 /// its input to be already fully resolved.
-pub fn deeply_normalize<'db, T>(at: At<'_, 'db>, value: T) -> Result<T, Vec<NextSolverError<'db>>>
+pub fn deeply_normalize<'db, T>(
+    at: At<'_, 'db>,
+    value: T,
+) -> Result<T, Vec<NextSolverError<'db>>>
 where
     T: TypeFoldable<DbInterner<'db>>,
 {
         stalled_coroutine_goals: vec![],
     };
     let value = value.try_fold_with(&mut folder)?;
-    let errors = folder
-        .fulfill_cx
-        .evaluate_obligations_error_on_ambiguity(at.infcx);
-    if errors.is_empty() {
-        Ok((value, folder.stalled_coroutine_goals))
-    } else {
-        Err(errors)
-    }
+    let errors = folder.fulfill_cx.evaluate_obligations_error_on_ambiguity(at.infcx);
+    if errors.is_empty() { Ok((value, folder.stalled_coroutine_goals)) } else { Err(errors) }
 }
 
 struct NormalizationFolder<'me, 'db> {
             return Err(vec![NextSolverError::Overflow(obligation)]);
         }
 
-        self.fulfill_cx
-            .register_predicate_obligation(infcx, obligation);
+        self.fulfill_cx.register_predicate_obligation(infcx, obligation);
         self.select_all_and_stall_coroutine_predicates()?;
 
         // Alias is guaranteed to be fully structurally resolved,
+
         // so we can super fold here.
         let term = infcx.resolve_vars_if_possible(infer_term);
         // super-folding the `term` will directly fold the `Ty` or `Const` so
             return Ok(ty);
         }
 
-        let TyKind::Alias(..) = ty.kind() else {
-            return ty.try_super_fold_with(self);
-        };
+        let TyKind::Alias(..) = ty.kind() else { return ty.try_super_fold_with(self) };
 
         if ty.has_escaping_bound_vars() {
             let (ty, mapped_regions, mapped_types, mapped_consts) =
             return Ok(ct);
         }
 
-        let ConstKind::Unevaluated(..) = ct.kind() else {
-            return ct.try_super_fold_with(self);
-        };
+        let ConstKind::Unevaluated(..) = ct.kind() else { return ct.try_super_fold_with(self) };
 
         if ct.has_escaping_bound_vars() {
             let (ct, mapped_regions, mapped_types, mapped_consts) =
     }
 }
 
-// Deeply normalize a value and return it
 pub(crate) fn deeply_normalize_for_diagnostics<'db, T: TypeFoldable<DbInterner<'db>>>(
     infcx: &InferCtxt<'db>,
     param_env: ParamEnv<'db>,