COMPARISON DIFF
============================================================

Original size: 9789 bytes
Chloro size:   9759 bytes
Rustfmt size:  9886 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::next_solver::{
     fulfill::{FulfillmentCtxt, NextSolverError},
-    infer::{
-        at::At,
-        traits::{Obligation, ObligationCause},
-        InferCtxt,
-    },
+    infer::{at::At, traits::{Obligation, ObligationCause}, InferCtxt},
     util::PlaceholderReplacer,
     Binder, Const, ConstKind, DbInterner, Goal, ParamEnv, Predicate, PredicateKind, Term, Ty,
     TyKind,
 
 /// Deeply normalize all aliases in `value`. This does not handle inference and expects
 /// its input to be already fully resolved.
-pub fn deeply_normalize<'db, T>(at: At<'_, 'db>, value: T) -> Result<T, Vec<NextSolverError<'db>>>
+pub fn deeply_normalize<'db, T>(
+    at: At<'_, 'db>,
+    value: T,
+) -> Result<T, Vec<NextSolverError<'db>>>
 where
     T: TypeFoldable<DbInterner<'db>>,
 {
 where
     T: TypeFoldable<DbInterner<'db>>,
 {
-    let (value, coroutine_goals) =
-        deeply_normalize_with_skipped_universes_and_ambiguous_coroutine_goals(
+    let (value, coroutine_goals) = deeply_normalize_with_skipped_universes_and_ambiguous_coroutine_goals(
             at, value, universes,
         )?;
     assert_eq!(coroutine_goals, vec![]);
         stalled_coroutine_goals: vec![],
     };
     let value = value.try_fold_with(&mut folder)?;
-    let errors = folder
-        .fulfill_cx
-        .evaluate_obligations_error_on_ambiguity(at.infcx);
-    if errors.is_empty() {
-        Ok((value, folder.stalled_coroutine_goals))
-    } else {
-        Err(errors)
-    }
+    let errors = folder.fulfill_cx.evaluate_obligations_error_on_ambiguity(at.infcx);
+    if errors.is_empty() { Ok((value, folder.stalled_coroutine_goals)) } else { Err(errors) }
 }
 
 struct NormalizationFolder<'me, 'db> {
             return Err(vec![NextSolverError::Overflow(obligation)]);
         }
 
-        self.fulfill_cx
-            .register_predicate_obligation(infcx, obligation);
+        self.fulfill_cx.register_predicate_obligation(infcx, obligation);
         self.select_all_and_stall_coroutine_predicates()?;
 
         // Alias is guaranteed to be fully structurally resolved,
+
         // so we can super fold here.
         let term = infcx.resolve_vars_if_possible(infer_term);
         // super-folding the `term` will directly fold the `Ty` or `Const` so
             return Err(errors);
         }
 
-        self.stalled_coroutine_goals.extend(
+        self.stalled_coroutine_goals
+            .extend(
             self.fulfill_cx
                 .drain_stalled_obligations_for_coroutines(self.at.infcx)
                 .into_iter()
             return Ok(ty);
         }
 
-        let TyKind::Alias(..) = ty.kind() else {
-            return ty.try_super_fold_with(self);
-        };
+        let TyKind::Alias(..) = ty.kind() else { return ty.try_super_fold_with(self) };
 
         if ty.has_escaping_bound_vars() {
             let (ty, mapped_regions, mapped_types, mapped_consts) =
             return Ok(ct);
         }
 
-        let ConstKind::Unevaluated(..) = ct.kind() else {
-            return ct.try_super_fold_with(self);
-        };
+        let ConstKind::Unevaluated(..) = ct.kind() else { return ct.try_super_fold_with(self) };
 
         if ct.has_escaping_bound_vars() {
             let (ct, mapped_regions, mapped_types, mapped_consts) =
     }
 }
 
-// Deeply normalize a value and return it
 pub(crate) fn deeply_normalize_for_diagnostics<'db, T: TypeFoldable<DbInterner<'db>>>(
     infcx: &InferCtxt<'db>,
     param_env: ParamEnv<'db>,
 
     fn fold_ty(&mut self, ty: Ty<'db>) -> Ty<'db> {
         let infcx = self.at.infcx;
-        let result: Result<_, Vec<NextSolverError<'db>>> = infcx.commit_if_ok(|_| {
+        let result: Result<_, Vec<NextSolverError<'db>>> = infcx
+            .commit_if_ok(|_| {
             deeply_normalize_with_skipped_universes_and_ambiguous_coroutine_goals(
                 self.at,
                 ty,
 
     fn fold_const(&mut self, ct: Const<'db>) -> Const<'db> {
         let infcx = self.at.infcx;
-        let result: Result<_, Vec<NextSolverError<'db>>> = infcx.commit_if_ok(|_| {
+        let result: Result<_, Vec<NextSolverError<'db>>> = infcx
+            .commit_if_ok(|_| {
             deeply_normalize_with_skipped_universes_and_ambiguous_coroutine_goals(
                 self.at,
                 ct,