COMPARISON DIFF
============================================================

Original size: 9789 bytes
Chloro size:   9745 bytes
Rustfmt size:  9886 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use rustc_next_trait_solver::placeholder::BoundVarReplacer;
 use rustc_type_ir::{
     inherent::{IntoKind, Term as _},
-    AliasRelationDirection, FallibleTypeFolder, Flags, Interner, TermKind, TypeFoldable,
-    TypeFolder, TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
+    AliasRelationDirection, FallibleTypeFolder, Flags, Interner, TermKind, TypeFoldable, TypeFolder,
+    TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
 };
 
 use crate::next_solver::{
     fulfill::{FulfillmentCtxt, NextSolverError},
     infer::{
+        InferCtxt,
         at::At,
         traits::{Obligation, ObligationCause},
-        InferCtxt,
     },
     util::PlaceholderReplacer,
     Binder, Const, ConstKind, DbInterner, Goal, ParamEnv, Predicate, PredicateKind, Term, Ty,
 
 /// Deeply normalize all aliases in `value`. This does not handle inference and expects
 /// its input to be already fully resolved.
-pub fn deeply_normalize<'db, T>(at: At<'_, 'db>, value: T) -> Result<T, Vec<NextSolverError<'db>>>
+pub fn deeply_normalize<'db, T>(
+    at: At<'_, 'db>,
+    value: T,
+) -> Result<T, Vec<NextSolverError<'db>>>
 where
     T: TypeFoldable<DbInterner<'db>>,
 {
             at, value, universes,
         )?;
     assert_eq!(coroutine_goals, vec![]);
-
     Ok(value)
 }
 
         stalled_coroutine_goals: vec![],
     };
     let value = value.try_fold_with(&mut folder)?;
-    let errors = folder
-        .fulfill_cx
-        .evaluate_obligations_error_on_ambiguity(at.infcx);
-    if errors.is_empty() {
-        Ok((value, folder.stalled_coroutine_goals))
-    } else {
-        Err(errors)
-    }
+    let errors = folder.fulfill_cx.evaluate_obligations_error_on_ambiguity(at.infcx);
+    if errors.is_empty() { Ok((value, folder.stalled_coroutine_goals)) } else { Err(errors) }
 }
 
 struct NormalizationFolder<'me, 'db> {
         let infcx = self.at.infcx;
         let interner = infcx.interner;
         let recursion_limit = interner.recursion_limit();
-
         self.depth += 1;
-
         let infer_term = infcx.next_term_var_of_kind(alias_term);
         let obligation = Obligation::new(
             interner,
             self.at.param_env,
             PredicateKind::AliasRelate(alias_term, infer_term, AliasRelationDirection::Equate),
         );
-
         if self.depth > recursion_limit {
             //     let term = alias_term.to_alias_term().unwrap();
             //     self.at.infcx.err_ctxt().report_overflow_error(
             //     );
             return Err(vec![NextSolverError::Overflow(obligation)]);
         }
-
-        self.fulfill_cx
-            .register_predicate_obligation(infcx, obligation);
+        self.fulfill_cx.register_predicate_obligation(infcx, obligation);
         self.select_all_and_stall_coroutine_predicates()?;
-
         // Alias is guaranteed to be fully structurally resolved,
         // so we can super fold here.
         let term = infcx.resolve_vars_if_possible(infer_term);
         if !errors.is_empty() {
             return Err(errors);
         }
-
         self.stalled_coroutine_goals.extend(
             self.fulfill_cx
                 .drain_stalled_obligations_for_coroutines(self.at.infcx)
                 .into_iter()
                 .map(|obl| obl.as_goal()),
         );
-
         let errors = self.fulfill_cx.collect_remaining_errors(self.at.infcx);
         if !errors.is_empty() {
             return Err(errors);
         }
-
         Ok(())
     }
 }
         if !ty.has_aliases() {
             return Ok(ty);
         }
-
-        let TyKind::Alias(..) = ty.kind() else {
-            return ty.try_super_fold_with(self);
-        };
-
+        let TyKind::Alias(..) = ty.kind() else { return ty.try_super_fold_with(self) };
         if ty.has_escaping_bound_vars() {
             let (ty, mapped_regions, mapped_types, mapped_consts) =
                 BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, ty);
         if !ct.has_aliases() {
             return Ok(ct);
         }
-
-        let ConstKind::Unevaluated(..) = ct.kind() else {
-            return ct.try_super_fold_with(self);
-        };
-
+        let ConstKind::Unevaluated(..) = ct.kind() else { return ct.try_super_fold_with(self) };
         if ct.has_escaping_bound_vars() {
             let (ct, mapped_regions, mapped_types, mapped_consts) =
                 BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, ct);
     }
 }
 
-// Deeply normalize a value and return it
 pub(crate) fn deeply_normalize_for_diagnostics<'db, T: TypeFoldable<DbInterner<'db>>>(
     infcx: &InferCtxt<'db>,
     param_env: ParamEnv<'db>,