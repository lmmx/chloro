COMPARISON DIFF
============================================================

Original size: 87058 bytes
Chloro size:   85673 bytes
Rustfmt size:  87058 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!  - Building the type for an item: This happens through the `ty` query.
 //!
 //! This usually involves resolving names, collecting generic arguments etc.
+
 pub(crate) mod diagnostics;
 pub(crate) mod path;
 
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, CallableDefId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId,
-    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
-    LocalFieldId, Lookup, StaticId, StructId, TypeAliasId, TypeOrConstParamId, TypeParamId,
-    UnionId, VariantId,
     builtin_type::BuiltinType,
-    expr_store::{ExpressionStore, HygieneId, path::Path},
-    hir::generics::{
-        GenericParamDataRef, TypeOrConstParamData, TypeParamProvenance, WherePredicate,
-    },
+    expr_store::{path::Path, ExpressionStore, HygieneId},
+    hir::generics::{GenericParamDataRef, TypeOrConstParamData, TypeParamProvenance, WherePredicate},
     item_tree::FieldsShape,
     lang_item::LangItem,
     resolver::{HasResolver, LifetimeNs, Resolver, TypeNs, ValueNs},
         ConstRef, LifetimeRefId, LiteralConstRef, PathId, TraitBoundModifier,
         TraitRef as HirTraitRef, TypeBound, TypeRef, TypeRefId,
     },
+    AdtId, AssocItemId, CallableDefId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId,
+    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
+    LocalFieldId, Lookup, StaticId, StructId, TypeAliasId, TypeOrConstParamId, TypeParamId,
+    UnionId, VariantId,
 };
 use hir_expand::name::Name;
 use la_arena::{Arena, ArenaMap, Idx};
 use rustc_hash::FxHashSet;
 use rustc_pattern_analysis::Captures;
 use rustc_type_ir::{
+    inherent::{GenericArg as _, GenericArgs as _, IntoKind as _, Region as _, SliceLike, Ty as _},
     AliasTyKind, BoundVarIndexKind, ConstKind, DebruijnIndex, ExistentialPredicate,
     ExistentialProjection, ExistentialTraitRef, FnSig, OutlivesPredicate,
-    TyKind::{self},
+    TyKind::self,
     TypeVisitableExt,
-    inherent::{GenericArg as _, GenericArgs as _, IntoKind as _, Region as _, SliceLike, Ty as _},
 };
 use salsa::plumbing::AsId;
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use stdx::{impl_from, never};
 use triomphe::{Arc, ThinArc};
 
 use crate::{
-    FnAbi, ImplTraitId, TraitEnvironment, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
     consteval::intern_const_ref,
     db::HirDatabase,
-    generics::{Generics, generics, trait_self_param_idx},
+    generics::{generics, trait_self_param_idx, Generics},
     next_solver::{
-        AliasTy, Binder, BoundExistentialPredicates, Clause, Clauses, Const, DbInterner,
-        EarlyBinder, EarlyParamRegion, ErrorGuaranteed, GenericArg, GenericArgs, ParamConst,
-        ParamEnv, PolyFnSig, Predicate, Region, SolverDefId, TraitPredicate, TraitRef, Ty, Tys,
-        UnevaluatedConst, abi::Safety,
+        abi::Safety, AliasTy, Binder, BoundExistentialPredicates, Clause, Clauses, Const,
+        DbInterner, EarlyBinder, EarlyParamRegion, ErrorGuaranteed, GenericArg, GenericArgs,
+        ParamConst, ParamEnv, PolyFnSig, Predicate, Region, SolverDefId, TraitPredicate, TraitRef,
+        Ty, Tys, UnevaluatedConst,
     },
+    FnAbi, ImplTraitId, TraitEnvironment, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
 };
 
 pub(crate) struct PathDiagnosticCallbackData(pub(crate) TypeRefId);
     /// struct Foo<'a> { x: &'a () }
     /// async fn foo(Foo { x: _ }: Foo<'_>) {}
     /// ```
-    AnonymousCreateParameter { report_in_path: bool },
+    AnonymousCreateParameter {
+        report_in_path: bool,
+    },
 
     /// Replace all anonymous lifetimes by provided lifetime.
     Elided(Region<'db>),
     /// Resolves elided lifetimes to `'static` if there are no other lifetimes in scope,
     /// otherwise give a warning that the previous behavior of introducing a new early-bound
     /// lifetime is a bug and will be removed (if `only_lint` is enabled).
-    StaticIfNoLifetimeInScope { only_lint: bool },
+    StaticIfNoLifetimeInScope {
+        only_lint: bool,
+    },
 
     /// Signal we cannot find which should be the anonymous lifetime.
     ElisionFailure,
         match const_parent {
             ItemContainerId::ExternBlockId(_) | ItemContainerId::ModuleId(_) => {
                 LifetimeElisionKind::Elided(Region::new_static(interner))
-            }
+            },
             ItemContainerId::ImplId(_) => {
                 LifetimeElisionKind::StaticIfNoLifetimeInScope { only_lint: true }
-            }
+            },
             ItemContainerId::TraitId(_) => {
                 LifetimeElisionKind::StaticIfNoLifetimeInScope { only_lint: false }
-            }
+            },
         }
     }
 
         match const_ref {
             hir_def::hir::Expr::Path(path) => {
                 self.path_to_const(path).unwrap_or_else(|| unknown_const(const_type))
-            }
+            },
             hir_def::hir::Expr::Literal(literal) => intern_const_ref(
                 self.db,
                 &match *literal {
-                    hir_def::hir::Literal::Float(_, _)
+                hir_def::hir::Literal::Float(_, _)
                     | hir_def::hir::Literal::String(_)
                     | hir_def::hir::Literal::ByteString(_)
                     | hir_def::hir::Literal::CString(_) => LiteralConstRef::Unknown,
-                    hir_def::hir::Literal::Char(c) => LiteralConstRef::Char(c),
-                    hir_def::hir::Literal::Bool(b) => LiteralConstRef::Bool(b),
-                    hir_def::hir::Literal::Int(val, _) => LiteralConstRef::Int(val),
-                    hir_def::hir::Literal::Uint(val, _) => LiteralConstRef::UInt(val),
-                },
+                hir_def::hir::Literal::Char(c) => LiteralConstRef::Char(c),
+                hir_def::hir::Literal::Bool(b) => LiteralConstRef::Bool(b),
+                hir_def::hir::Literal::Int(val, _) => LiteralConstRef::Int(val),
+                hir_def::hir::Literal::Uint(val, _) => LiteralConstRef::UInt(val),
+            },
                 const_type,
                 self.resolver.krate(),
             ),
             hir_def::hir::Expr::UnaryOp { expr: inner_expr, op: hir_def::hir::UnaryOp::Neg } => {
                 if let hir_def::hir::Expr::Literal(literal) = &self.store[*inner_expr] {
-                    // Only handle negation for signed integers and floats
                     match literal {
                         hir_def::hir::Literal::Int(_, _) | hir_def::hir::Literal::Float(_, _) => {
                             if let Some(negated_literal) = literal.clone().negate() {
                             } else {
                                 unknown_const(const_type)
                             }
-                        }
-                        // For unsigned integers, chars, bools, etc., negation is not meaningful
+                        },
                         _ => unknown_const(const_type),
                     }
                 } else {
                     unknown_const(const_type)
                 }
-            }
+            },
             _ => unknown_const(const_type),
         }
     }
                             p
                         );
                         None
-                    }
+                    },
                 }
-            }
+            },
             Some(ValueNs::ConstId(c)) => {
                 let args = GenericArgs::new_from_iter(self.interner, []);
                 Some(Const::new(
                     self.interner,
-                    rustc_type_ir::ConstKind::Unevaluated(UnevaluatedConst::new(
-                        SolverDefId::ConstId(c),
-                        args,
-                    )),
+                    rustc_type_ir::ConstKind::Unevaluated(
+                    UnevaluatedConst::new(SolverDefId::ConstId(c), args),
+                ),
                 ))
-            }
+            },
             _ => None,
         }
     }
     }
 
     fn param_index_is_disallowed(&self, index: u32) -> bool {
-        self.lowering_param_default
-            .is_some_and(|disallow_params_after| index >= disallow_params_after)
+        self.lowering_param_default.is_some_and(
+            |disallow_params_after| index >= disallow_params_after,
+        )
     }
 
     fn type_param(&mut self, id: TypeParamId, index: u32) -> Ty<'db> {
         if self.param_index_is_disallowed(index) {
-            // FIXME: Report an error.
             Ty::new_error(self.interner, ErrorGuaranteed)
         } else {
             Ty::new_param(self.interner, id, index)
 
     fn const_param(&mut self, id: ConstParamId, index: u32) -> Const<'db> {
         if self.param_index_is_disallowed(index) {
-            // FIXME: Report an error.
             Const::error(self.interner)
         } else {
             Const::new_param(self.interner, ParamConst { id, index })
 
     fn region_param(&mut self, id: LifetimeParamId, index: u32) -> Region<'db> {
         if self.param_index_is_disallowed(index) {
-            // FIXME: Report an error.
             Region::error(self.interner)
         } else {
             Region::new_early_param(self.interner, EarlyParamRegion { id, index })
         )
     }
 
-    pub(crate) fn lower_path(&mut self, path: &Path, path_id: PathId) -> (Ty<'db>, Option<TypeNs>) {
+    pub(crate) fn lower_path(
+        &mut self,
+        path: &Path,
+        path_id: PathId,
+    ) -> (Ty<'db>, Option<TypeNs>) {
         // Resolve the path (in type namespace)
         if let Some(type_ref) = path.type_anchor() {
             let (ty, res) = self.lower_ty_ext(type_ref);
                 }
                 let self_ty = self.lower_ty(*target);
                 Either::Left(Either::Right(self.lower_type_bound(bound, self_ty, ignore_bindings)))
-            }
+            },
             &WherePredicate::Lifetime { bound, target } => {
                 Either::Right(iter::once(Clause(Predicate::new(
                     self.interner,
-                    Binder::dummy(rustc_type_ir::PredicateKind::Clause(
-                        rustc_type_ir::ClauseKind::RegionOutlives(OutlivesPredicate(
-                            self.lower_lifetime(bound),
-                            self.lower_lifetime(target),
-                        )),
-                    )),
+                    Binder::dummy(rustc_type_ir::PredicateKind::Clause(rustc_type_ir::ClauseKind::RegionOutlives(
+                    OutlivesPredicate(self.lower_lifetime(bound), self.lower_lifetime(target)),
+                ))),
                 ))))
-            }
-        }
-        .into_iter()
+            },
+        }.into_iter(
+        )
     }
 
     pub(crate) fn lower_type_bound<'b>(
             };
             Ty::new_dynamic(self.interner, bounds, region)
         } else {
-            // FIXME: report error
-            // (additional non-auto traits, associated type rebound, or no resolved trait)
             Ty::new_error(self.interner, ErrorGuaranteed)
         }
     }
                         Some(idx) => idx,
                     };
                     self.region_param(id, idx as u32)
-                }
+                },
             },
             None => Region::error(self.interner),
         }
     AdtId(AdtId),
     TypeAliasId(TypeAliasId),
 }
+
 impl_from!(BuiltinType, AdtId(StructId, EnumId, UnionId), TypeAliasId for TyDefId);
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, salsa_macros::Supertype)]
     ConstId(ConstId),
     StaticId(StaticId),
 }
+
 impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for ValueTyDefId);
 
 impl ValueTyDefId {
     let interner = DbInterner::new_with(db, None, None);
     match def {
         TyDefId::BuiltinType(it) => EarlyBinder::bind(Ty::from_builtin_type(interner, it)),
-        TyDefId::AdtId(it) => EarlyBinder::bind(Ty::new_adt(
-            interner,
-            it,
-            GenericArgs::identity_for_item(interner, it.into()),
-        )),
+        TyDefId::AdtId(it) => EarlyBinder::bind(
+            Ty::new_adt(interner, it, GenericArgs::identity_for_item(interner, it.into())),
+        ),
         TyDefId::TypeAliasId(it) => db.type_for_type_alias_with_diagnostics(it).0,
     }
 }
                 CallableDefId::StructId(def).into(),
                 GenericArgs::identity_for_item(interner, def.into()),
             )))
-        }
+        },
     }
 }
 
                 CallableDefId::EnumVariantId(def).into(),
                 GenericArgs::identity_for_item(interner, def.loc(db).parent.into()),
             )))
-        }
+        },
     }
 }
 
     db.const_param_ty_with_diagnostics(def).0
 }
 
-// returns None if def is a type arg
 pub(crate) fn const_param_ty_with_diagnostics_query<'db>(
     db: &'db dyn HirDatabase,
     def: ConstParamId,
         interner: DbInterner<'db>,
         args: GenericArgs<'db>,
     ) -> Option<impl Iterator<Item = Clause<'db>>> {
-        self.0
-            .as_ref()
-            .map(|it| EarlyBinder::bind(it.iter().copied()).iter_instantiated(interner, args))
+        self.0.as_ref().map(
+            |it| EarlyBinder::bind(it.iter().copied()).iter_instantiated(interner, args),
+        )
     }
 
     #[inline]
     }
 
     // FIXME: rustc gathers more predicates by recursing through resulting trait predicates.
-    // See https://github.com/rust-lang/rust/blob/76c5ed2847cdb26ef2822a3a165d710f6b772217/compiler/rustc_hir_analysis/src/collect/predicates_of.rs#L689-L715
 
+    // See https://github.com/rust-lang/rust/blob/76c5ed2847cdb26ef2822a3a165d710f6b772217/compiler/rustc_hir_analysis/src/collect/predicates_of.rs#L689-L715
     (
         GenericPredicates(predicates.is_empty().not().then(|| predicates.into())),
         create_diagnostics(ctx.diagnostics),
 
     let trait_self_idx = trait_self_param_idx(db, def);
 
-    Some(
-        args.iter()
-            .enumerate()
-            .filter_map(
-                move |(idx, generic_arg)| {
-                    if Some(idx) == trait_self_idx { None } else { Some(generic_arg) }
-                },
-            )
-            .filter_map(|generic_arg| generic_arg.as_type())
-            .filter(move |self_ty| !explicitly_unsized_tys.contains(self_ty))
-            .map(move |self_ty| {
-                let trait_ref = TraitRef::new_from_args(
+    Some(args.iter().enumerate().filter_map(move |(idx, generic_arg)| {
+        if Some(idx) == trait_self_idx {
+            None
+        } else {
+            Some(generic_arg)
+        }
+    }).filter_map(
+        |generic_arg| generic_arg.as_type(),
+    ).filter(
+        move |self_ty| !explicitly_unsized_tys.contains(self_ty),
+    ).map(move |self_ty| {
+        let trait_ref = TraitRef::new_from_args(
                     interner,
                     sized_trait.into(),
                     GenericArgs::new_from_iter(interner, [self_ty.into()]),
                 );
-                Clause(Predicate::new(
+        Clause(Predicate::new(
                     interner,
                     Binder::dummy(rustc_type_ir::PredicateKind::Clause(
                         rustc_type_ir::ClauseKind::Trait(TraitPredicate {
                         }),
                     )),
                 ))
-            }),
-    )
+    }))
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
             result
         })
         .collect::<Vec<_>>();
-    ctx.diagnostics.clear(); // Don't include diagnostics from the parent.
+    ctx.diagnostics.clear();
+    // Don't include diagnostics from the parent.
     defaults.extend(generic_params.iter_self().map(|(_id, p)| {
         let (result, has_default) = handle_generic_param(&mut ctx, idx, p);
         has_any_default |= has_default;
     }))
 }
 
-// FIXME(next-solver): should merge this with `explicit_item_bounds` in some way
 pub(crate) fn associated_ty_item_bounds<'db>(
     db: &'db dyn HirDatabase,
     type_alias: TypeAliasId,
     mut cb: impl FnMut(&Name, TypeAliasId) -> bool,
 ) -> Option<TypeAliasId> {
     let interner = DbInterner::new_with(db, None, None);
-    named_associated_type_shorthand_candidates(interner, def, res, None, |name, _, id| {
+    named_associated_type_shorthand_candidates(
+        interner,
+        def,
+        res,
+        None,
+        |name, _, id| {
         cb(name, id).then_some(id)
-    })
+    },
+    )
 }
 
 #[tracing::instrument(skip(interner, check_alias))]
 fn named_associated_type_shorthand_candidates<'db, R>(
     interner: DbInterner<'db>,
-    // If the type parameter is defined in an impl and we're in a method, there
-    // might be additional where clauses to consider
     def: GenericDefId,
     res: TypeNs,
     assoc_name: Option<Name>,
     match res {
         TypeNs::SelfType(impl_id) => {
             let trait_ref = db.impl_trait(impl_id)?;
-
-            // FIXME(next-solver): same method in `lower` checks for impl or not
-            // Is that needed here?
-
-            // we're _in_ the impl -- the binders get added back later. Correct,
-            // but it would be nice to make this more explicit
             search(trait_ref.skip_binder())
-        }
+        },
         TypeNs::GenericParam(param_id) => {
-            // Handle `Self::Type` referring to own associated type in trait definitions
-            // This *must* be done first to avoid cycles with
-            // `generic_predicates_for_param`, but not sure that it's sufficient,
             if let GenericDefId::TraitId(trait_id) = param_id.parent() {
                 let trait_name = &db.trait_signature(trait_id).name;
                 tracing::debug!(?trait_name);
                     return search(trait_ref);
                 }
             }
-
             let predicates =
                 db.generic_predicates_for_param(def, param_id.into(), assoc_name.clone());
-            predicates
-                .iter()
-                .find_map(|pred| match (*pred).kind().skip_binder() {
-                    rustc_type_ir::ClauseKind::Trait(trait_predicate) => Some(trait_predicate),
-                    _ => None,
-                })
-                .and_then(|trait_predicate| {
-                    let trait_ref = trait_predicate.trait_ref;
-                    assert!(
+            predicates.iter().find_map(|pred| match (*pred).kind().skip_binder() {
+                rustc_type_ir::ClauseKind::Trait(trait_predicate) => Some(trait_predicate),
+                _ => None,
+            }).and_then(|trait_predicate| {
+                let trait_ref = trait_predicate.trait_ref;
+                assert!(
                         !trait_ref.has_escaping_bound_vars(),
                         "FIXME unexpected higher-ranked trait bound"
                     );
-                    search(trait_ref)
-                })
-        }
+                search(trait_ref)
+            })
+        },
         _ => None,
     }
 }