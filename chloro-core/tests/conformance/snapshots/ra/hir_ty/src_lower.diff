COMPARISON DIFF
============================================================

Original size: 87058 bytes
Chloro size:   86851 bytes
Rustfmt size:  87058 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!  - Building the type for an item: This happens through the `ty` query.
 //!
 //! This usually involves resolving names, collecting generic arguments etc.
+
 pub(crate) mod diagnostics;
 pub(crate) mod path;
 
 use base_db::Crate;
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, CallableDefId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId,
-    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
-    LocalFieldId, Lookup, StaticId, StructId, TypeAliasId, TypeOrConstParamId, TypeParamId,
-    UnionId, VariantId,
     builtin_type::BuiltinType,
-    expr_store::{ExpressionStore, HygieneId, path::Path},
-    hir::generics::{
-        GenericParamDataRef, TypeOrConstParamData, TypeParamProvenance, WherePredicate,
-    },
+    expr_store::{path::Path, ExpressionStore, HygieneId},
+    hir::generics::{GenericParamDataRef, TypeOrConstParamData, TypeParamProvenance, WherePredicate},
     item_tree::FieldsShape,
     lang_item::LangItem,
     resolver::{HasResolver, LifetimeNs, Resolver, TypeNs, ValueNs},
         ConstRef, LifetimeRefId, LiteralConstRef, PathId, TraitBoundModifier,
         TraitRef as HirTraitRef, TypeBound, TypeRef, TypeRefId,
     },
+    AdtId, AssocItemId, CallableDefId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId,
+    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
+    LocalFieldId, Lookup, StaticId, StructId, TypeAliasId, TypeOrConstParamId, TypeParamId,
+    UnionId, VariantId,
 };
 use hir_expand::name::Name;
 use la_arena::{Arena, ArenaMap, Idx};
 use rustc_hash::FxHashSet;
 use rustc_pattern_analysis::Captures;
 use rustc_type_ir::{
+    inherent::{GenericArg as _, GenericArgs as _, IntoKind as _, Region as _, SliceLike, Ty as _},
     AliasTyKind, BoundVarIndexKind, ConstKind, DebruijnIndex, ExistentialPredicate,
     ExistentialProjection, ExistentialTraitRef, FnSig, OutlivesPredicate,
-    TyKind::{self},
+    TyKind::self,
     TypeVisitableExt,
-    inherent::{GenericArg as _, GenericArgs as _, IntoKind as _, Region as _, SliceLike, Ty as _},
 };
 use salsa::plumbing::AsId;
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use stdx::{impl_from, never};
 use triomphe::{Arc, ThinArc};
 
 use crate::{
-    FnAbi, ImplTraitId, TraitEnvironment, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
     consteval::intern_const_ref,
     db::HirDatabase,
-    generics::{Generics, generics, trait_self_param_idx},
+    generics::{generics, trait_self_param_idx, Generics},
     next_solver::{
-        AliasTy, Binder, BoundExistentialPredicates, Clause, Clauses, Const, DbInterner,
-        EarlyBinder, EarlyParamRegion, ErrorGuaranteed, GenericArg, GenericArgs, ParamConst,
-        ParamEnv, PolyFnSig, Predicate, Region, SolverDefId, TraitPredicate, TraitRef, Ty, Tys,
-        UnevaluatedConst, abi::Safety,
+        abi::Safety, AliasTy, Binder, BoundExistentialPredicates, Clause, Clauses, Const,
+        DbInterner, EarlyBinder, EarlyParamRegion, ErrorGuaranteed, GenericArg, GenericArgs,
+        ParamConst, ParamEnv, PolyFnSig, Predicate, Region, SolverDefId, TraitPredicate, TraitRef,
+        Ty, Tys, UnevaluatedConst,
     },
+    FnAbi, ImplTraitId, TraitEnvironment, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
 };
 
 pub(crate) struct PathDiagnosticCallbackData(pub(crate) TypeRefId);
     /// struct Foo<'a> { x: &'a () }
     /// async fn foo(Foo { x: _ }: Foo<'_>) {}
     /// ```
-    AnonymousCreateParameter { report_in_path: bool },
+    AnonymousCreateParameter {
+        report_in_path: bool,
+    },
 
     /// Replace all anonymous lifetimes by provided lifetime.
     Elided(Region<'db>),
     /// Resolves elided lifetimes to `'static` if there are no other lifetimes in scope,
     /// otherwise give a warning that the previous behavior of introducing a new early-bound
     /// lifetime is a bug and will be removed (if `only_lint` is enabled).
-    StaticIfNoLifetimeInScope { only_lint: bool },
+    StaticIfNoLifetimeInScope {
+        only_lint: bool,
+    },
 
     /// Signal we cannot find which should be the anonymous lifetime.
     ElisionFailure,
         )
     }
 
-    pub(crate) fn lower_path(&mut self, path: &Path, path_id: PathId) -> (Ty<'db>, Option<TypeNs>) {
+    pub(crate) fn lower_path(
+        &mut self,
+        path: &Path,
+        path_id: PathId,
+    ) -> (Ty<'db>, Option<TypeNs>) {
         // Resolve the path (in type namespace)
         if let Some(type_ref) = path.type_anchor() {
             let (ty, res) = self.lower_ty_ext(type_ref);
         // INVARIANT: If this function returns `DynTy`, there should be at least one trait bound.
         // These invariants are utilized by `TyExt::dyn_trait()` and chalk.
         let mut lifetime = None;
-        let bounds = self.with_shifted_in(DebruijnIndex::from_u32(1), |ctx| {
+        let bounds = self
+            .with_shifted_in(DebruijnIndex::from_u32(1), |ctx| {
             let mut lowered_bounds: Vec<
                 rustc_type_ir::Binder<DbInterner<'db>, ExistentialPredicate<DbInterner<'db>>>,
             > = Vec::new();
             rustc_type_ir::AliasTyKind::Opaque,
             AliasTy::new_from_args(interner, def_id, args),
         );
-        let predicates = self.with_shifted_in(DebruijnIndex::from_u32(1), |ctx| {
+        let predicates = self
+            .with_shifted_in(DebruijnIndex::from_u32(1), |ctx| {
             let mut predicates = Vec::new();
             for b in bounds {
                 predicates.extend(ctx.lower_type_bound(b, self_ty, false));
     // FIXME unify with fn_sig_for_fn instead of doing lowering twice, maybe
     let data = db.function_signature(def);
     let resolver = def.resolver(db);
-    let mut ctx_ret =
-        TyLoweringContext::new(db, &resolver, &data.store, def.into(), LifetimeElisionKind::Infer)
-            .with_impl_trait_mode(ImplTraitLoweringMode::Opaque);
+    let mut ctx_ret = TyLoweringContext::new(db, &resolver, &data.store, def.into(), LifetimeElisionKind::Infer)
+        .with_impl_trait_mode(ImplTraitLoweringMode::Opaque);
     if let Some(ret_type) = data.ret_type {
         let _ret = ctx_ret.lower_ty(ret_type);
     }
-    let return_type_impl_traits =
-        ImplTraits { impl_traits: ctx_ret.impl_trait_mode.opaque_type_data };
+    let return_type_impl_traits = ImplTraits { impl_traits: ctx_ret.impl_trait_mode.opaque_type_data };
     if return_type_impl_traits.impl_traits.is_empty() {
         None
     } else {
         def.into(),
         LifetimeElisionKind::AnonymousReportError,
     )
-    .with_impl_trait_mode(ImplTraitLoweringMode::Opaque);
+        .with_impl_trait_mode(ImplTraitLoweringMode::Opaque);
     if let Some(type_ref) = data.ty {
         let _ty = ctx.lower_ty(type_ref);
     }
     AdtId(AdtId),
     TypeAliasId(TypeAliasId),
 }
+
 impl_from!(BuiltinType, AdtId(StructId, EnumId, UnionId), TypeAliasId for TyDefId);
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, salsa_macros::Supertype)]
     ConstId(ConstId),
     StaticId(StaticId),
 }
+
 impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for ValueTyDefId);
 
 impl ValueTyDefId {
     db.const_param_ty_with_diagnostics(def).0
 }
 
-// returns None if def is a type arg
 pub(crate) fn const_param_ty_with_diagnostics_query<'db>(
     db: &'db dyn HirDatabase,
     def: ConstParamId,
     }
 
     // FIXME: rustc gathers more predicates by recursing through resulting trait predicates.
-    // See https://github.com/rust-lang/rust/blob/76c5ed2847cdb26ef2822a3a165d710f6b772217/compiler/rustc_hir_analysis/src/collect/predicates_of.rs#L689-L715
 
+    // See https://github.com/rust-lang/rust/blob/76c5ed2847cdb26ef2822a3a165d710f6b772217/compiler/rustc_hir_analysis/src/collect/predicates_of.rs#L689-L715
     (
         GenericPredicates(predicates.is_empty().not().then(|| predicates.into())),
         create_diagnostics(ctx.diagnostics),
         def,
         LifetimeElisionKind::AnonymousReportError,
     )
-    .with_impl_trait_mode(ImplTraitLoweringMode::Disallowed);
+        .with_impl_trait_mode(ImplTraitLoweringMode::Disallowed);
     let mut idx = 0;
     let mut has_any_default = false;
     let mut defaults = generic_params
             idx += 1;
             result
         })
-        .collect::<Vec<_>>();
-    ctx.diagnostics.clear(); // Don't include diagnostics from the parent.
-    defaults.extend(generic_params.iter_self().map(|(_id, p)| {
+        .collect();
+    ctx.diagnostics.clear();
+    // Don't include diagnostics from the parent.
+    defaults
+        .extend(generic_params.iter_self().map(|(_id, p)| {
         let (result, has_default) = handle_generic_param(&mut ctx, idx, p);
         has_any_default |= has_default;
         idx += 1;
     let params = field_tys.iter().map(|(_, ty)| ty.skip_binder());
     let ret = type_for_adt(db, def.into()).skip_binder();
 
-    let inputs_and_output =
-        Tys::new_from_iter(DbInterner::new_with(db, None, None), params.chain(Some(ret)));
+    let inputs_and_output = Tys::new_from_iter(DbInterner::new_with(db, None, None), params.chain(Some(ret)));
     EarlyBinder::bind(Binder::dummy(FnSig {
         abi: FnAbi::RustCall,
         c_variadic: false,
     let parent = def.lookup(db).parent;
     let ret = type_for_adt(db, parent.into()).skip_binder();
 
-    let inputs_and_output =
-        Tys::new_from_iter(DbInterner::new_with(db, None, None), params.chain(Some(ret)));
+    let inputs_and_output = Tys::new_from_iter(DbInterner::new_with(db, None, None), params.chain(Some(ret)));
     EarlyBinder::bind(Binder::dummy(FnSig {
         abi: FnAbi::RustCall,
         c_variadic: false,
     }))
 }
 
-// FIXME(next-solver): should merge this with `explicit_item_bounds` in some way
 pub(crate) fn associated_ty_item_bounds<'db>(
     db: &'db dyn HirDatabase,
     type_alias: TypeAliasId,
 #[tracing::instrument(skip(interner, check_alias))]
 fn named_associated_type_shorthand_candidates<'db, R>(
     interner: DbInterner<'db>,
-    // If the type parameter is defined in an impl and we're in a method, there
-    // might be additional where clauses to consider
     def: GenericDefId,
     res: TypeNs,
     assoc_name: Option<Name>,