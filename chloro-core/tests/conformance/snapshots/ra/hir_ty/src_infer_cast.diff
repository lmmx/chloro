COMPARISON DIFF
============================================================

Original size: 16583 bytes
Chloro size:   16405 bytes
Rustfmt size:  16583 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Type cast logic. Basically coercion + additional casts.
 
-use hir_def::{AdtId, hir::ExprId, signatures::TraitFlags};
+use hir_def::{hir::ExprId, signatures::TraitFlags, AdtId};
 use rustc_ast_ir::Mutability;
 use rustc_type_ir::{
-    Flags, InferTy, TypeFlags, UintTy,
     inherent::{AdtDef, BoundExistentialPredicates as _, IntoKind, SliceLike, Ty as _},
+    Flags, InferTy, TypeFlags, UintTy,
 };
 use stdx::never;
 
 use crate::{
-    InferenceDiagnostic,
     db::HirDatabase,
-    infer::{AllowTwoPhase, InferenceContext, coerce::CoerceNever},
+    infer::{coerce::CoerceNever, AllowTwoPhase, InferenceContext},
     next_solver::{BoundExistentialPredicates, DbInterner, ParamTy, Ty, TyKind},
+    InferenceDiagnostic,
 };
 
 #[derive(Debug)]
     Float,
     FnPtr,
     Ptr(Ty<'db>, Mutability),
-    // `DynStar` is Not supported yet in r-a
 }
 
 impl<'db> CastTy<'db> {
     NeedViaThinPtr,
     NeedViaInt,
     NonScalar,
-    // We don't want to report errors with unknown types currently.
-    // UnknownCastPtrKind,
-    // UnknownExprPtrKind,
 }
 
 impl CastError {
         }
 
         // Chalk doesn't support trait upcasting and fails to solve some obvious goals
+
         // when the trait environment contains some recursive traits (See issue #18047)
+
         // We skip cast checks for such cases for now, until the next-gen solver.
         if contains_dyn_trait(self.cast_ty) {
             return Ok(());
     }
 
     fn do_check(&self, ctx: &mut InferenceContext<'_, 'db>) -> Result<(), CastError> {
-        let (t_from, t_cast) =
-            match (CastTy::from_ty(ctx.db, self.expr_ty), CastTy::from_ty(ctx.db, self.cast_ty)) {
+        let (t_from, t_cast) = match (CastTy::from_ty(ctx.db, self.expr_ty), CastTy::from_ty(ctx.db, self.cast_ty)) {
                 (Some(t_from), Some(t_cast)) => (t_from, t_cast),
                 (None, Some(t_cast)) => match self.expr_ty.kind() {
                     TyKind::FnDef(..) => {
             };
 
         // rustc checks whether the `expr_ty` is foreign adt with `non_exhaustive` sym
-
         match (t_from, t_cast) {
             (_, CastTy::Int(Int::CEnum) | CastTy::FnPtr) => Err(CastError::NonScalar),
             (_, CastTy::Int(Int::Bool)) => Err(CastError::CastToBool),