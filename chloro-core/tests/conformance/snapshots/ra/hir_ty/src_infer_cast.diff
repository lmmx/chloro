COMPARISON DIFF
============================================================

Original size: 16583 bytes
Chloro size:   16467 bytes
Rustfmt size:  16583 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     Float,
     FnPtr,
     Ptr(Ty<'db>, Mutability),
-    // `DynStar` is Not supported yet in r-a
 }
 
 impl<'db> CastTy<'db> {
                     return None;
                 };
                 let enum_data = id.enum_variants(db);
-                if enum_data.is_payload_free(db) { Some(Self::Int(Int::CEnum)) } else { None }
+                if enum_data.is_payload_free(db) {
+                    Some(Self::Int(Int::CEnum))
+                } else {
+                    None
+                }
             }
             TyKind::RawPtr(ty, m) => Some(Self::Ptr(ty, m)),
             TyKind::FnPtr(..) => Some(Self::FnPtr),
     NeedViaThinPtr,
     NeedViaInt,
     NonScalar,
-    // We don't want to report errors with unknown types currently.
-    // UnknownCastPtrKind,
-    // UnknownExprPtrKind,
 }
 
 impl CastError {
         self.cast_ty = ctx.table.eagerly_normalize_and_resolve_shallow_in(self.cast_ty);
 
         // This should always come first so that we apply the coercion, which impacts infer vars.
+
         if ctx
             .coerce(
                 self.source_expr.into(),
         }
 
         // Chalk doesn't support trait upcasting and fails to solve some obvious goals
+
         // when the trait environment contains some recursive traits (See issue #18047)
+
         // We skip cast checks for such cases for now, until the next-gen solver.
+
         if contains_dyn_trait(self.cast_ty) {
             return Ok(());
         }
                         let src_principal = ctx.db.trait_signature(src_principal.0);
                         let dst_principal = ctx.db.trait_signature(dst_principal.0);
                         if src_principal.flags.contains(TraitFlags::AUTO)
-                            && dst_principal.flags.contains(TraitFlags::AUTO)
-                        {
+                            && dst_principal.flags.contains(TraitFlags::AUTO) {
                             Ok(())
                         } else {
                             Err(CastError::DifferingKinds)
                 never!("`{:?}` should be sized but is not?", ty);
                 return Err(());
             };
-
             let struct_data = id.fields(ctx.db);
             if let Some((last_field, _)) = struct_data.fields().iter().last() {
                 let last_field_ty =