COMPARISON DIFF
============================================================

Original size: 16583 bytes
Chloro size:   16406 bytes
Rustfmt size:  16583 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Type cast logic. Basically coercion + additional casts.
 
 use hir_def::{AdtId, hir::ExprId, signatures::TraitFlags};
 use rustc_ast_ir::Mutability;
 use rustc_type_ir::{
-    Flags, InferTy, TypeFlags, UintTy,
     inherent::{AdtDef, BoundExistentialPredicates as _, IntoKind, SliceLike, Ty as _},
+    Flags,
+    InferTy,
+    TypeFlags,
+    UintTy,
 };
 use stdx::never;
 
 use crate::{
-    InferenceDiagnostic,
     db::HirDatabase,
     infer::{AllowTwoPhase, InferenceContext, coerce::CoerceNever},
     next_solver::{BoundExistentialPredicates, DbInterner, ParamTy, Ty, TyKind},
+    InferenceDiagnostic,
 };
 
 #[derive(Debug)]
     Float,
     FnPtr,
     Ptr(Ty<'db>, Mutability),
-    // `DynStar` is Not supported yet in r-a
 }
 
 impl<'db> CastTy<'db> {
-    pub(crate) fn from_ty(db: &dyn HirDatabase, t: Ty<'db>) -> Option<Self> {
+    pub(crate) fn from_ty(
+        db: &dyn HirDatabase,
+        t: Ty<'db>,
+    ) -> Option<Self> {
         match t.kind() {
             TyKind::Bool => Some(Self::Int(Int::Bool)),
             TyKind::Char => Some(Self::Int(Int::Char)),
     NeedViaThinPtr,
     NeedViaInt,
     NonScalar,
-    // We don't want to report errors with unknown types currently.
-    // UnknownCastPtrKind,
-    // UnknownExprPtrKind,
 }
 
 impl CastError {
     ) -> Result<(), InferenceDiagnostic<'db>> {
         self.expr_ty = ctx.table.eagerly_normalize_and_resolve_shallow_in(self.expr_ty);
         self.cast_ty = ctx.table.eagerly_normalize_and_resolve_shallow_in(self.cast_ty);
-
         // This should always come first so that we apply the coercion, which impacts infer vars.
         if ctx
             .coerce(
             ctx.result.coercion_casts.insert(self.source_expr);
             return Ok(());
         }
-
         if self.expr_ty.references_non_lt_error() || self.cast_ty.references_non_lt_error() {
             return Ok(());
         }
-
         if !self.cast_ty.flags().contains(TypeFlags::HAS_TY_INFER)
             && !ctx.table.is_sized(self.cast_ty)
         {
                 cast_ty: self.cast_ty,
             });
         }
-
         // Chalk doesn't support trait upcasting and fails to solve some obvious goals
         // when the trait environment contains some recursive traits (See issue #18047)
         // We skip cast checks for such cases for now, until the next-gen solver.
         if contains_dyn_trait(self.cast_ty) {
             return Ok(());
         }
-
         self.do_check(ctx).map_err(|e| e.into_diagnostic(self.expr, self.expr_ty, self.cast_ty))
     }
 
-    fn do_check(&self, ctx: &mut InferenceContext<'_, 'db>) -> Result<(), CastError> {
+    fn do_check(
+        &self,
+        ctx: &mut InferenceContext<'_, 'db>,
+    ) -> Result<(), CastError> {
         let (t_from, t_cast) =
             match (CastTy::from_ty(ctx.db, self.expr_ty), CastTy::from_ty(ctx.db, self.cast_ty)) {
                 (Some(t_from), Some(t_cast)) => (t_from, t_cast),
                 },
                 _ => return Err(CastError::NonScalar),
             };
-
         // rustc checks whether the `expr_ty` is foreign adt with `non_exhaustive` sym
-
         match (t_from, t_cast) {
             (_, CastTy::Int(Int::CEnum) | CastTy::FnPtr) => Err(CastError::NonScalar),
             (_, CastTy::Int(Int::Bool)) => Err(CastError::CastToBool),
                 return Ok(());
             }
         }
-
         Err(CastError::IllegalCast)
     }
 
     ) -> Result<(), CastError> {
         let src_kind = pointer_kind(src, ctx).map_err(|_| CastError::Unknown)?;
         let dst_kind = pointer_kind(dst, ctx).map_err(|_| CastError::Unknown)?;
-
         match (src_kind, dst_kind) {
             (Some(PointerKind::Error), _) | (_, Some(PointerKind::Error)) => Ok(()),
             // (_, None) => Err(CastError::UnknownCastPtrKind),
 
 #[derive(Debug, PartialEq, Eq)]
 enum PointerKind<'db> {
-    // thin pointer
     Thin,
-    // trait object
     VTable(BoundExistentialPredicates<'db>),
-    // slice
     Length,
     OfAlias,
     OfParam(ParamTy),
     ctx: &mut InferenceContext<'_, 'db>,
 ) -> Result<Option<PointerKind<'db>>, ()> {
     let ty = ctx.table.eagerly_normalize_and_resolve_shallow_in(ty);
-
     if ctx.table.is_sized(ty) {
         return Ok(Some(PointerKind::Thin));
     }
-
     match ty.kind() {
         TyKind::Slice(_) | TyKind::Str => Ok(Some(PointerKind::Length)),
         TyKind::Dynamic(bounds, _) => Ok(Some(PointerKind::VTable(bounds))),
 
 fn contains_dyn_trait<'db>(ty: Ty<'db>) -> bool {
     use std::ops::ControlFlow;
-
     use rustc_type_ir::{TypeSuperVisitable, TypeVisitable, TypeVisitor};
-
     struct DynTraitVisitor;
-
     impl<'db> TypeVisitor<DbInterner<'db>> for DynTraitVisitor {
         type Result = ControlFlow<()>;
 
             }
         }
     }
-
     ty.visit_with(&mut DynTraitVisitor).is_break()
 }