COMPARISON DIFF
============================================================

Original size: 16583 bytes
Chloro size:   16138 bytes
Rustfmt size:  16583 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Type cast logic. Basically coercion + additional casts.
 
-use hir_def::{AdtId, hir::ExprId, signatures::TraitFlags};
+use hir_def::{hir::ExprId, signatures::TraitFlags, AdtId};
 use rustc_ast_ir::Mutability;
 use rustc_type_ir::{
-    Flags, InferTy, TypeFlags, UintTy,
     inherent::{AdtDef, BoundExistentialPredicates as _, IntoKind, SliceLike, Ty as _},
+    Flags, InferTy, TypeFlags, UintTy,
 };
 use stdx::never;
 
 use crate::{
-    InferenceDiagnostic,
     db::HirDatabase,
-    infer::{AllowTwoPhase, InferenceContext, coerce::CoerceNever},
+    infer::{coerce::CoerceNever, AllowTwoPhase, InferenceContext},
     next_solver::{BoundExistentialPredicates, DbInterner, ParamTy, Ty, TyKind},
+    InferenceDiagnostic,
 };
 
 #[derive(Debug)]
     Float,
     FnPtr,
     Ptr(Ty<'db>, Mutability),
-    // `DynStar` is Not supported yet in r-a
 }
 
 impl<'db> CastTy<'db> {
                     return None;
                 };
                 let enum_data = id.enum_variants(db);
-                if enum_data.is_payload_free(db) { Some(Self::Int(Int::CEnum)) } else { None }
-            }
+                if enum_data.is_payload_free(db) {
+                    Some(Self::Int(Int::CEnum))
+                } else {
+                    None
+                }
+            },
             TyKind::RawPtr(ty, m) => Some(Self::Ptr(ty, m)),
             TyKind::FnPtr(..) => Some(Self::FnPtr),
             _ => None,
     NeedViaThinPtr,
     NeedViaInt,
     NonScalar,
-    // We don't want to report errors with unknown types currently.
-    // UnknownCastPtrKind,
-    // UnknownExprPtrKind,
 }
 
 impl CastError {
         }
 
         // Chalk doesn't support trait upcasting and fails to solve some obvious goals
+
         // when the trait environment contains some recursive traits (See issue #18047)
+
         // We skip cast checks for such cases for now, until the next-gen solver.
         if contains_dyn_trait(self.cast_ty) {
             return Ok(());
             };
 
         // rustc checks whether the `expr_ty` is foreign adt with `non_exhaustive` sym
-
         match (t_from, t_cast) {
             (_, CastTy::Int(Int::CEnum) | CastTy::FnPtr) => Err(CastError::NonScalar),
             (_, CastTy::Int(Int::Bool)) => Err(CastError::CastToBool),
             (_, CastTy::Int(Int::Char)) => Err(CastError::CastToChar),
             (CastTy::Int(Int::Bool | Int::CEnum | Int::Char), CastTy::Float) => {
                 Err(CastError::NeedViaInt)
-            }
+            },
             (CastTy::Int(Int::Bool | Int::CEnum | Int::Char) | CastTy::Float, CastTy::Ptr(..))
             | (CastTy::Ptr(..) | CastTy::FnPtr, CastTy::Float) => Err(CastError::IllegalCast),
             (CastTy::Ptr(src, _), CastTy::Ptr(dst, _)) => self.check_ptr_ptr_cast(ctx, src, dst),
 
         match (src_kind, dst_kind) {
             (Some(PointerKind::Error), _) | (_, Some(PointerKind::Error)) => Ok(()),
-            // (_, None) => Err(CastError::UnknownCastPtrKind),
-            // (None, _) => Err(CastError::UnknownExprPtrKind),
             (_, None) | (None, _) => Ok(()),
             (_, Some(PointerKind::Thin)) => Ok(()),
             (Some(PointerKind::Thin), _) => Err(CastError::SizedUnsizedCast),
                         }
                         let src_principal = ctx.db.trait_signature(src_principal.0);
                         let dst_principal = ctx.db.trait_signature(dst_principal.0);
-                        if src_principal.flags.contains(TraitFlags::AUTO)
-                            && dst_principal.flags.contains(TraitFlags::AUTO)
-                        {
+                        if src_principal.flags.contains(TraitFlags::AUTO) && dst_principal.flags.contains(TraitFlags::AUTO) {
                             Ok(())
                         } else {
                             Err(CastError::DifferingKinds)
                         }
-                    }
+                    },
                     _ => Err(CastError::Unknown),
                 }
-            }
+            },
             (Some(src_kind), Some(dst_kind)) if src_kind == dst_kind => Ok(()),
             (_, _) => Err(CastError::DifferingKinds),
         }
         expr_ty: Ty<'db>,
     ) -> Result<(), CastError> {
         match pointer_kind(expr_ty, ctx).map_err(|_| CastError::Unknown)? {
-            // None => Err(CastError::UnknownExprPtrKind),
             None => Ok(()),
             Some(PointerKind::Error) => Ok(()),
             Some(PointerKind::Thin) => Ok(()),
         cast_ty: Ty<'db>,
     ) -> Result<(), CastError> {
         match pointer_kind(cast_ty, ctx).map_err(|_| CastError::Unknown)? {
-            // None => Err(CastError::UnknownCastPtrKind),
             None => Ok(()),
             Some(PointerKind::Error) => Ok(()),
             Some(PointerKind::Thin) => Ok(()),
         cast_ty: Ty<'db>,
     ) -> Result<(), CastError> {
         match pointer_kind(cast_ty, ctx).map_err(|_| CastError::Unknown)? {
-            // None => Err(CastError::UnknownCastPtrKind),
             None => Ok(()),
             Some(PointerKind::Error) => Ok(()),
             Some(PointerKind::Thin) => Ok(()),
                 never!("`{:?}` should be sized but is not?", ty);
                 return Err(());
             };
-
             let struct_data = id.fields(ctx.db);
             if let Some((last_field, _)) = struct_data.fields().iter().last() {
                 let last_field_ty =
             } else {
                 Ok(Some(PointerKind::Thin))
             }
-        }
+        },
         TyKind::Tuple(subst) => match subst.iter().next_back() {
             None => Ok(Some(PointerKind::Thin)),
             Some(ty) => pointer_kind(ty, ctx),
         | TyKind::Never => {
             never!("`{:?}` should be sized but is not?", ty);
             Err(())
-        }
+        },
         TyKind::UnsafeBinder(..) | TyKind::Pat(..) => {
             never!("we don't produce these types: {ty:?}");
             Err(())
-        }
+        },
     }
 }
 