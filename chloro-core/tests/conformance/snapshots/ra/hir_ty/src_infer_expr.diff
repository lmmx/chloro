COMPARISON DIFF
============================================================

Original size: 111676 bytes
Chloro size:   111472 bytes
Rustfmt size:  111676 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir_def::hir::ClosureKind;
 use hir_def::{
     BlockId, FieldId, GenericDefId, GenericParamId, ItemContainerId, Lookup, TupleFieldId, TupleId,
-    expr_store::path::{GenericArg as HirGenericArg, GenericArgs as HirGenericArgs, Path},
+    expr_store::path::{GenericArgs as HirGenericArgs, GenericArg as HirGenericArg, Path},
     hir::{
         ArithOp, Array, AsmOperand, AsmOptions, BinaryOp, Expr, ExprId, ExprOrPatId, LabelId,
         Literal, Pat, PatId, Statement, UnaryOp, generics::GenericParamDataRef,
     db::InternedCoroutine,
     generics::generics,
     infer::{
-        AllowTwoPhase, BreakableKind,
-        coerce::{CoerceMany, CoerceNever},
-        find_continuable,
+        AllowTwoPhase, BreakableKind, coerce::{CoerceMany, CoerceNever}, find_continuable,
         pat::contains_explicit_ref_binding,
     },
     lang_items::lang_items_for_bin_op,
                 self.interner(),
                 box_id,
                 GenericArgs::fill_with_defaults(
-                    self.interner(),
-                    box_id.into(),
-                    [inner_ty.into()],
-                    |_, id, _| self.table.next_var_for_param(id),
-                ),
+                self.interner(),
+                box_id.into(),
+                [inner_ty.into()],
+                |_, id, _| self.table.next_var_for_param(id),
+            ),
             )
         } else {
             self.err_ty()
     pub(in super::super) fn check_call_arguments(
         &mut self,
         call_expr: ExprId,
-        // Types (as defined in the *signature* of the target function)
         formal_input_tys: &[Ty<'db>],
         formal_output: Ty<'db>,
-        // Expected output from the parent expression or statement
         expectation: &Expectation<'db>,
-        // The expressions for each provided argument
         provided_args: &[ExprId],
         skip_indices: &[u32],
-        // Whether the function is variadic, for example when imported from C
         c_variadic: bool,
     ) {
         // First, let's unify the formal method signature with the expectation eagerly.
             }
         }
 
-        if !args_count_matches {}
+        if !args_count_matches {
+        }
     }
 
     fn substs_for_method_call(
 
     /// Enforces expectations on lhs type and rhs type depending on the operator and returns the
     /// output type of the binary op.
-    fn enforce_builtin_binop_types(&mut self, lhs: Ty<'db>, rhs: Ty<'db>, op: BinaryOp) -> Ty<'db> {
+    fn enforce_builtin_binop_types(
+        &mut self,
+        lhs: Ty<'db>,
+        rhs: Ty<'db>,
+        op: BinaryOp,
+    ) -> Ty<'db> {
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
             BinaryOp::Assignment { .. } => unreachable!("handled above"),
         };
 
-        if is_assign { self.types.unit } else { output_ty }
+        if is_assign {
+            self.types.unit
+        } else {
+            output_ty
+        }
     }
 
     fn is_builtin_binop(&mut self, lhs: Ty<'db>, rhs: Ty<'db>, op: BinaryOp) -> bool {
             BinaryOp::ArithOp(
                 ArithOp::Add | ArithOp::Sub | ArithOp::Mul | ArithOp::Div | ArithOp::Rem,
             ) => {
-                lhs.is_integral() && rhs.is_integral()
-                    || lhs.is_floating_point() && rhs.is_floating_point()
+                lhs.is_integral() && rhs.is_integral() || lhs.is_floating_point() && rhs.is_floating_point()
             }
 
             BinaryOp::ArithOp(ArithOp::BitAnd | ArithOp::BitOr | ArithOp::BitXor) => {
-                lhs.is_integral() && rhs.is_integral()
-                    || lhs.is_floating_point() && rhs.is_floating_point()
-                    || matches!((lhs.kind(), rhs.kind()), (TyKind::Bool, TyKind::Bool))
+                lhs.is_integral() && rhs.is_integral() || lhs.is_floating_point() && rhs.is_floating_point() || matches!((lhs.kind(), rhs.kind()), (TyKind::Bool, TyKind::Bool))
             }
 
             BinaryOp::CmpOp(_) => {
         });
         let res = cb(self);
         let ctx = self.breakables.pop().expect("breakable stack broken");
-        (if ctx.may_break { ctx.coerce.map(|ctx| ctx.complete(self)) } else { None }, res)
+        (
+            if ctx.may_break {
+            ctx.coerce.map(|ctx| ctx.complete(self))
+        } else {
+            None
+        },
+            res,
+        )
     }
 }