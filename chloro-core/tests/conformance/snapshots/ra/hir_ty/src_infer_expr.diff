COMPARISON DIFF
============================================================

Original size: 111676 bytes
Chloro size:   111514 bytes
Rustfmt size:  111676 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir_def::hir::ClosureKind;
 use hir_def::{
-    BlockId, FieldId, GenericDefId, GenericParamId, ItemContainerId, Lookup, TupleFieldId, TupleId,
     expr_store::path::{GenericArg as HirGenericArg, GenericArgs as HirGenericArgs, Path},
     hir::{
-        ArithOp, Array, AsmOperand, AsmOptions, BinaryOp, Expr, ExprId, ExprOrPatId, LabelId,
-        Literal, Pat, PatId, Statement, UnaryOp, generics::GenericParamDataRef,
+        generics::GenericParamDataRef, ArithOp, Array, AsmOperand, AsmOptions, BinaryOp, Expr,
+        ExprId, ExprOrPatId, LabelId, Literal, Pat, PatId, Statement, UnaryOp,
     },
     lang_item::{LangItem, LangItemTarget},
     resolver::ValueNs,
+    BlockId, FieldId, GenericDefId, GenericParamId, ItemContainerId, Lookup, TupleFieldId, TupleId,
 };
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_type_ir::{
-    CoroutineArgs, CoroutineArgsParts, InferTy, Interner,
     inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Ty as _},
+    CoroutineArgs, CoroutineArgsParts, InferTy, Interner,
 };
 use syntax::ast::RangeOp;
 use tracing::debug;
 
 use crate::{
-    Adjust, Adjustment, AutoBorrow, CallableDefId, DeclContext, DeclOrigin,
-    IncorrectGenericsLenKind, Rawness, TraitEnvironment,
     autoderef::overloaded_deref_ty,
     consteval,
     db::InternedCoroutine,
     generics::generics,
     infer::{
+        coerce::{CoerceMany, CoerceNever}, find_continuable, pat::contains_explicit_ref_binding,
         AllowTwoPhase, BreakableKind,
-        coerce::{CoerceMany, CoerceNever},
-        find_continuable,
-        pat::contains_explicit_ref_binding,
     },
     lang_items::lang_items_for_bin_op,
     lower::{
-        LifetimeElisionKind, lower_mutability,
+        lower_mutability,
         path::{GenericArgsLowerer, TypeLikeConst, substs_from_args_and_bindings},
+        LifetimeElisionKind,
     },
     method_resolution::{self, VisibleFromModule},
     next_solver::{
-        Const, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs, TraitRef, Ty, TyKind,
-        TypeError,
         infer::{
             InferOk,
             traits::{Obligation, ObligationCause},
         },
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Const, DbInterner, ErrorGuaranteed, GenericArg,
+        GenericArgs, TraitRef, Ty, TyKind, TypeError,
     },
     traits::FnTrait,
+    Adjust, Adjustment, AutoBorrow, CallableDefId, DeclContext, DeclOrigin,
+    IncorrectGenericsLenKind, Rawness, TraitEnvironment,
 };
-
 use super::{
-    BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch,
-    cast::CastCheck, find_breakable,
+    cast::CastCheck, find_breakable, BreakableContext, Diverges, Expectation, InferenceContext,
+    InferenceDiagnostic, TypeMismatch,
 };
 
 #[derive(Clone, Copy, PartialEq, Eq)]
         }
 
         // We only care about place exprs. Anything else returns an immediate
+
         // which would constitute a read. We don't care about distinguishing
+
         // "syntactic" place exprs since if the base of a field projection is
+
         // not a place then it would've been UB to read from it anyways since
+
         // that constitutes a read.
         if !self.is_syntactic_place_expr(expr) {
             return true;
         }
 
         // rustc queries parent hir node of `expr` here and determine whether
+
         // the current `expr` is read of value per its parent.
+
         // But since we don't have hir node, we cannot follow such "bottom-up"
+
         // method.
+
         // So, we pass down such readness from the parent expression through the
+
         // recursive `infer_expr*` calls in a "top-down" manner.
         is_read == ExprIsRead::Yes
     }
 
         // FIXME: We should handle async blocks like we handle closures
         let expected = &Expectation::has_type(ret_ty);
-        let (_, inner_ty) = self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {
+        let (_, inner_ty) = self
+            .with_breakable_ctx(BreakableKind::Border, None, None, |this| {
             let ty = this.infer_block(tgt_expr, *id, statements, *tail, None, expected);
             if let Some(target) = expected.only_has_type(&mut this.table) {
                 match this.coerce(tgt_expr.into(), ty, target, AllowTwoPhase::No, CoerceNever::Yes)
             .as_mut()
             .expect("infer_return called outside function body")
             .expected_ty();
-        let return_expr_ty =
-            self.infer_expr_inner(expr, &Expectation::HasType(ret_ty), ExprIsRead::Yes);
+        let return_expr_ty = self.infer_expr_inner(expr, &Expectation::HasType(ret_ty), ExprIsRead::Yes);
         let mut coerce_many = self.return_coercion.take().unwrap();
         coerce_many.coerce(self, &ObligationCause::new(), expr, return_expr_ty);
         self.return_coercion = Some(coerce_many);
         let lhs_ty = self.infer_expr(lhs, &lhs_expectation, is_read);
         let rhs_ty = self.table.next_ty_var();
 
-        let trait_func = lang_items_for_bin_op(op).and_then(|(name, lang_item)| {
+        let trait_func = lang_items_for_bin_op(op)
+            .and_then(|(name, lang_item)| {
             let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;
             let func = trait_id.trait_items(self.db).method_by_name(&name)?;
             Some((trait_id, func))
         };
 
         // HACK: We can use this substitution for the function because the function itself doesn't
+
         // have its own generic parameters.
         let args = GenericArgs::new_from_iter(self.interner(), [lhs_ty.into(), rhs_ty.into()]);
 
     ) -> Ty<'db> {
         let coerce_ty = expected.coercion_target_type(&mut self.table);
         let g = self.resolver.update_to_inner_scope(self.db, self.owner, expr);
-        let prev_state = block_id.map(|block_id| {
+        let prev_state = block_id
+            .map(|block_id| {
             let prev_env = self.table.trait_env.clone();
             TraitEnvironment::with_block(&mut self.table.trait_env, block_id);
             let prev_block = self.table.infer_ctxt.interner.block.replace(block_id);
             (prev_env, prev_block)
         });
 
-        let (break_ty, ty) =
-            self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty), label, |this| {
+        let (break_ty, ty) = self
+            .with_breakable_ctx(BreakableKind::Block, Some(coerce_ty), label, |this| {
                 for stmt in statements {
                     match stmt {
                         Statement::Let { pat, type_ref, initializer, else_branch } => {
         let interner = self.interner();
         let mut autoderef = self.table.autoderef(receiver_ty);
         let mut private_field = None;
-        let res = autoderef.by_ref().find_map(|(derefed_ty, _)| {
+        let res = autoderef
+            .by_ref()
+            .find_map(|(derefed_ty, _)| {
             let (field_id, parameters) = match derefed_ty.kind() {
                 TyKind::Tuple(substs) => {
                     return name.as_tuple_index().and_then(|idx| {
     ) -> Ty<'db> {
         self.register_obligations_for_call(callee_ty);
 
-        self.check_call_arguments(
+        self
+            .check_call_arguments(
             tgt_expr,
             param_tys,
             ret_ty,
         expected: &Expectation<'db>,
     ) -> Ty<'db> {
         self.register_obligations_for_call(method_ty);
-        let ((formal_receiver_ty, param_tys), ret_ty, is_varargs) =
-            match method_ty.callable_sig(self.interner()) {
+        let ((formal_receiver_ty, param_tys), ret_ty, is_varargs) = match method_ty.callable_sig(self.interner()) {
                 Some(sig) => {
                     let sig = sig.skip_binder();
                     (
     pub(in super::super) fn check_call_arguments(
         &mut self,
         call_expr: ExprId,
-        // Types (as defined in the *signature* of the target function)
         formal_input_tys: &[Ty<'db>],
         formal_output: Ty<'db>,
-        // Expected output from the parent expression or statement
         expectation: &Expectation<'db>,
-        // The expressions for each provided argument
         provided_args: &[ExprId],
         skip_indices: &[u32],
-        // Whether the function is variadic, for example when imported from C
         c_variadic: bool,
     ) {
         // First, let's unify the formal method signature with the expectation eagerly.
         let provided_arg_count = provided_args.len() - skip_indices.len();
 
         // Keep track of whether we *could possibly* be satisfied, i.e. whether we're on the happy path
+
         // if the wrong number of arguments were supplied, we CAN'T be satisfied,
+
         // and if we're c_variadic, the supplied arguments must be >= the minimum count from the function
+
         // otherwise, they need to be identical, because rust doesn't currently support variadic functions
         let args_count_matches = if c_variadic {
             provided_arg_count >= minimum_input_count
         }
 
         // We introduce a helper function to demand that a given argument satisfy a given input
+
         // This is more complicated than just checking type equality, as arguments could be coerced
+
         // This version writes those types back so further type checking uses the narrowed types
         let demand_compatible = |this: &mut InferenceContext<'_, 'db>, idx| {
             let formal_input_ty: Ty<'db> = formal_input_tys[idx];
         };
 
         // Check the arguments.
+
         // We do this in a pretty awful way: first we type-check any arguments
+
         // that are not closures, then we type-check the closures. This is so
+
         // that we have more information about the types of arguments when we
+
         // type-check the functions. This isn't really the right way to do this.
         for check_closures in [false, true] {
             // More awful hacks: before we check argument types, try to do
 
     /// Enforces expectations on lhs type and rhs type depending on the operator and returns the
     /// output type of the binary op.
-    fn enforce_builtin_binop_types(&mut self, lhs: Ty<'db>, rhs: Ty<'db>, op: BinaryOp) -> Ty<'db> {
+    fn enforce_builtin_binop_types(
+        &mut self,
+        lhs: Ty<'db>,
+        rhs: Ty<'db>,
+        op: BinaryOp,
+    ) -> Ty<'db> {
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
         label: Option<LabelId>,
         cb: impl FnOnce(&mut Self) -> T,
     ) -> (Option<Ty<'db>>, T) {
-        self.breakables.push({
+        self.breakables
+            .push({
             BreakableContext { kind, may_break: false, coerce: ty.map(CoerceMany::new), label }
         });
         let res = cb(self);