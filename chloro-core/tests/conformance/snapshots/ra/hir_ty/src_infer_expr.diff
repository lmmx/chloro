COMPARISON DIFF
============================================================

Original size: 111676 bytes
Chloro size:   111491 bytes
Rustfmt size:  111676 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir_def::hir::ClosureKind;
 use hir_def::{
     BlockId, FieldId, GenericDefId, GenericParamId, ItemContainerId, Lookup, TupleFieldId, TupleId,
-    expr_store::path::{GenericArg as HirGenericArg, GenericArgs as HirGenericArgs, Path},
+    expr_store::path::{GenericArgs as HirGenericArgs, GenericArg as HirGenericArg, Path},
     hir::{
         ArithOp, Array, AsmOperand, AsmOptions, BinaryOp, Expr, ExprId, ExprOrPatId, LabelId,
         Literal, Pat, PatId, Statement, UnaryOp, generics::GenericParamDataRef,
     db::InternedCoroutine,
     generics::generics,
     infer::{
-        AllowTwoPhase, BreakableKind,
-        coerce::{CoerceMany, CoerceNever},
-        find_continuable,
+        AllowTwoPhase, BreakableKind, coerce::{CoerceMany, CoerceNever}, find_continuable,
         pat::contains_explicit_ref_binding,
     },
     lang_items::lang_items_for_bin_op,
         }
 
         // We only care about place exprs. Anything else returns an immediate
+
         // which would constitute a read. We don't care about distinguishing
+
         // "syntactic" place exprs since if the base of a field projection is
+
         // not a place then it would've been UB to read from it anyways since
+
         // that constitutes a read.
+
         if !self.is_syntactic_place_expr(expr) {
             return true;
         }
 
         // rustc queries parent hir node of `expr` here and determine whether
+
         // the current `expr` is read of value per its parent.
+
         // But since we don't have hir node, we cannot follow such "bottom-up"
+
         // method.
+
         // So, we pass down such readness from the parent expression through the
+
         // recursive `infer_expr*` calls in a "top-down" manner.
+
         is_read == ExprIsRead::Yes
     }
 
                     self.err_ty()
                 };
             }
-
             if let Some(target) = expected.only_has_type(&mut self.table) {
                 self.coerce(expr.into(), ty, target, AllowTwoPhase::No, CoerceNever::Yes)
                     .expect("never-to-any coercion should always succeed")
         let prev_ret_coercion = self.return_coercion.replace(CoerceMany::new(ret_ty));
 
         // FIXME: We should handle async blocks like we handle closures
+
         let expected = &Expectation::has_type(ret_ty);
         let (_, inner_ty) = self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {
             let ty = this.infer_block(tgt_expr, *id, statements, *tail, None, expected);
                     Expectation::rvalue_hint(self, g)
                 })
                 .unwrap_or_else(Expectation::none);
-
             let inner_ty = self.infer_expr_inner(inner_expr, &inner_exp, ExprIsRead::Yes);
             Ty::new_adt(
                 self.interner(),
                 box_id,
                 GenericArgs::fill_with_defaults(
-                    self.interner(),
-                    box_id.into(),
-                    [inner_ty.into()],
-                    |_, id, _| self.table.next_var_for_param(id),
-                ),
+                self.interner(),
+                box_id.into(),
+                [inner_ty.into()],
+                |_, id, _| self.table.next_var_for_param(id),
+            ),
             )
         } else {
             self.err_ty()
         };
 
         // HACK: We can use this substitution for the function because the function itself doesn't
+
         // have its own generic parameters.
+
         let args = GenericArgs::new_from_iter(self.interner(), [lhs_ty.into(), rhs_ty.into()]);
 
         self.write_method_resolution(tgt_expr, func, args);
             Some((field_id, ty)) => {
                 let adjustments = autoderef.adjust_steps();
                 let ty = self.process_remote_user_written_ty(ty);
-
                 (ty, field_id, adjustments, true)
             }
             None => {
                 let ty = self.db.field_types(field_id.parent)[field_id.local_id]
                     .instantiate(self.interner(), subst);
                 let ty = self.process_remote_user_written_ty(ty);
-
                 (ty, Either::Left(field_id), adjustments, false)
             }
         })
                         let args = self.substs_for_method_call(tgt_expr, func.into(), None);
                         self.write_expr_adj(receiver, adjustments.into_boxed_slice());
                         self.write_method_resolution(tgt_expr, func, args);
-
                         self.check_method_call(
                             tgt_expr,
                             &[],
                         item: func.into(),
                     })
                 }
-
                 let (ty, adjustments) = adjust.apply(&mut self.table, receiver_ty);
                 self.write_expr_adj(receiver, adjustments.into_boxed_slice());
-
                 let gen_args = self.substs_for_method_call(tgt_expr, func.into(), generic_args);
                 self.write_method_resolution(tgt_expr, func, gen_args);
                 let interner = DbInterner::new_with(self.db, None, None);
                     }
                     None => None,
                 };
-
                 let assoc_func_with_same_name = method_resolution::iterate_method_candidates(
                     &canonicalized_receiver,
                     &mut self.table,
                         _ => None,
                     },
                 );
-
                 self.push_diagnostic(InferenceDiagnostic::UnresolvedMethodCall {
                     expr: tgt_expr,
                     receiver: receiver_ty,
                     field_with_same_name: field_with_same_name_exists,
                     assoc_func_with_same_name,
                 });
-
                 let recovered = match assoc_func_with_same_name {
                     Some(f) => {
                         let args = self.substs_for_method_call(tgt_expr, f.into(), generic_args);
     pub(in super::super) fn check_call_arguments(
         &mut self,
         call_expr: ExprId,
-        // Types (as defined in the *signature* of the target function)
         formal_input_tys: &[Ty<'db>],
         formal_output: Ty<'db>,
-        // Expected output from the parent expression or statement
         expectation: &Expectation<'db>,
-        // The expressions for each provided argument
         provided_args: &[ExprId],
         skip_indices: &[u32],
-        // Whether the function is variadic, for example when imported from C
         c_variadic: bool,
     ) {
         // First, let's unify the formal method signature with the expectation eagerly.
             .unwrap_or_default();
 
         // If there are no external expectations at the call site, just use the types from the function defn
+
         let expected_input_tys = if let Some(expected_input_tys) = &expected_input_tys {
             assert_eq!(expected_input_tys.len(), formal_input_tys.len());
             expected_input_tys
         let provided_arg_count = provided_args.len() - skip_indices.len();
 
         // Keep track of whether we *could possibly* be satisfied, i.e. whether we're on the happy path
+
         // if the wrong number of arguments were supplied, we CAN'T be satisfied,
+
         // and if we're c_variadic, the supplied arguments must be >= the minimum count from the function
+
         // otherwise, they need to be identical, because rust doesn't currently support variadic functions
+
         let args_count_matches = if c_variadic {
             provided_arg_count >= minimum_input_count
         } else {
         }
 
         // We introduce a helper function to demand that a given argument satisfy a given input
+
         // This is more complicated than just checking type equality, as arguments could be coerced
+
         // This version writes those types back so further type checking uses the narrowed types
+
         let demand_compatible = |this: &mut InferenceContext<'_, 'db>, idx| {
             let formal_input_ty: Ty<'db> = formal_input_tys[idx];
             let expected_input_ty: Ty<'db> = expected_input_tys[idx];
         };
 
         // Check the arguments.
+
         // We do this in a pretty awful way: first we type-check any arguments
+
         // that are not closures, then we type-check the closures. This is so
+
         // that we have more information about the types of arguments when we
+
         // type-check the functions. This isn't really the right way to do this.
+
         for check_closures in [false, true] {
             // More awful hacks: before we check argument types, try to do
             // an "opportunistic" trait resolution of any trait bounds on
             }
         }
 
-        if !args_count_matches {}
+        if !args_count_matches {
+        }
     }
 
     fn substs_for_method_call(
     fn register_obligations_for_call(&mut self, callable_ty: Ty<'db>) {
         let callable_ty = self.table.try_structurally_resolve_type(callable_ty);
         if let TyKind::FnDef(fn_def, parameters) = callable_ty.kind() {
+            // add obligation for trait implementation, if this is a trait method
             let generic_predicates =
                 self.db.generic_predicates(GenericDefId::from_callable(self.db, fn_def.0));
             if let Some(predicates) = generic_predicates.instantiate(self.interner(), parameters) {
                     Obligation::new(interner, ObligationCause::new(), param_env, predicate)
                 }));
             }
-            // add obligation for trait implementation, if this is a trait method
             match fn_def.0 {
                 CallableDefId::FunctionId(f) => {
                     if let ItemContainerId::TraitId(trait_) = f.lookup(self.db).container {
         };
 
         // only use legacy const generics if the param count matches with them
+
         if data.params.len() + legacy_const_generics_indices.len() != args.len() {
             if args.len() <= data.params.len() {
                 return Default::default();
         }
 
         // check legacy const parameters
+
         for arg_idx in legacy_const_generics_indices.iter().copied() {
             if arg_idx >= args.len() as u32 {
                 continue;
 
     /// Enforces expectations on lhs type and rhs type depending on the operator and returns the
     /// output type of the binary op.
-    fn enforce_builtin_binop_types(&mut self, lhs: Ty<'db>, rhs: Ty<'db>, op: BinaryOp) -> Ty<'db> {
+    fn enforce_builtin_binop_types(
+        &mut self,
+        lhs: Ty<'db>,
+        rhs: Ty<'db>,
+        op: BinaryOp,
+    ) -> Ty<'db> {
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
             BinaryOp::Assignment { .. } => unreachable!("handled above"),
         };
 
-        if is_assign { self.types.unit } else { output_ty }
+        if is_assign {
+            self.types.unit
+        } else {
+            output_ty
+        }
     }
 
     fn is_builtin_binop(&mut self, lhs: Ty<'db>, rhs: Ty<'db>, op: BinaryOp) -> bool {
             BinaryOp::ArithOp(
                 ArithOp::Add | ArithOp::Sub | ArithOp::Mul | ArithOp::Div | ArithOp::Rem,
             ) => {
-                lhs.is_integral() && rhs.is_integral()
-                    || lhs.is_floating_point() && rhs.is_floating_point()
+                lhs.is_integral() && rhs.is_integral() || lhs.is_floating_point() && rhs.is_floating_point()
             }
 
             BinaryOp::ArithOp(ArithOp::BitAnd | ArithOp::BitOr | ArithOp::BitXor) => {
-                lhs.is_integral() && rhs.is_integral()
-                    || lhs.is_floating_point() && rhs.is_floating_point()
-                    || matches!((lhs.kind(), rhs.kind()), (TyKind::Bool, TyKind::Bool))
+                lhs.is_integral() && rhs.is_integral() || lhs.is_floating_point() && rhs.is_floating_point() || matches!((lhs.kind(), rhs.kind()), (TyKind::Bool, TyKind::Bool))
             }
 
             BinaryOp::CmpOp(_) => {
         });
         let res = cb(self);
         let ctx = self.breakables.pop().expect("breakable stack broken");
-        (if ctx.may_break { ctx.coerce.map(|ctx| ctx.complete(self)) } else { None }, res)
+        (
+            if ctx.may_break {
+            ctx.coerce.map(|ctx| ctx.complete(self))
+        } else {
+            None
+        },
+            res,
+        )
     }
 }