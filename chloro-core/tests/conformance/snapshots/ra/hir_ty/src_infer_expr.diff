COMPARISON DIFF
============================================================

Original size: 111676 bytes
Chloro size:   111812 bytes
Rustfmt size:  111676 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir_def::hir::ClosureKind;
 use hir_def::{
-    BlockId, FieldId, GenericDefId, GenericParamId, ItemContainerId, Lookup, TupleFieldId, TupleId,
     expr_store::path::{GenericArg as HirGenericArg, GenericArgs as HirGenericArgs, Path},
     hir::{
         ArithOp, Array, AsmOperand, AsmOptions, BinaryOp, Expr, ExprId, ExprOrPatId, LabelId,
     },
     lang_item::{LangItem, LangItemTarget},
     resolver::ValueNs,
+    BlockId,
+    FieldId,
+    GenericDefId,
+    GenericParamId,
+    ItemContainerId,
+    Lookup,
+    TupleFieldId,
+    TupleId,
 };
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_type_ir::{
-    CoroutineArgs, CoroutineArgsParts, InferTy, Interner,
     inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Ty as _},
+    CoroutineArgs,
+    CoroutineArgsParts,
+    InferTy,
+    Interner,
 };
 use syntax::ast::RangeOp;
 use tracing::debug;
 
 use crate::{
-    Adjust, Adjustment, AutoBorrow, CallableDefId, DeclContext, DeclOrigin,
-    IncorrectGenericsLenKind, Rawness, TraitEnvironment,
     autoderef::overloaded_deref_ty,
     consteval,
     db::InternedCoroutine,
         obligation_ctxt::ObligationCtxt,
     },
     traits::FnTrait,
+    Adjust,
+    Adjustment,
+    AutoBorrow,
+    CallableDefId,
+    DeclContext,
+    DeclOrigin,
+    IncorrectGenericsLenKind,
+    Rawness,
+    TraitEnvironment,
 };
-
 use super::{
-    BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch,
-    cast::CastCheck, find_breakable,
+    cast::CastCheck,
+
+    find_breakable, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,
+    TypeMismatch,
 };
 
 #[derive(Clone, Copy, PartialEq, Eq)]
         if is_read == ExprIsRead::Yes {
             return true;
         }
-
         // We only care about place exprs. Anything else returns an immediate
         // which would constitute a read. We don't care about distinguishing
         // "syntactic" place exprs since if the base of a field projection is
         if !self.is_syntactic_place_expr(expr) {
             return true;
         }
-
         // rustc queries parent hir node of `expr` here and determine whether
         // the current `expr` is read of value per its parent.
         // But since we don't have hir node, we cannot follow such "bottom-up"
     /// Whether this pattern constitutes a read of value of the scrutinee that
     /// it is matching against. This is used to determine whether we should
     /// perform `NeverToAny` coercions.
-    fn pat_guaranteed_to_constitute_read_for_never(&self, pat: PatId) -> bool {
+    fn pat_guaranteed_to_constitute_read_for_never(
+        &self,
+        pat: PatId,
+    ) -> bool {
         match &self.body[pat] {
             // Does not constitute a read.
             Pat::Wild => false,
         }
     }
 
-    fn is_syntactic_place_expr(&self, expr: ExprId) -> bool {
+    fn is_syntactic_place_expr(
+        &self,
+        expr: ExprId,
+    ) -> bool {
         match &self.body[expr] {
             // Lang item paths cannot currently be local variables or statics.
             Expr::Path(Path::LangItem(_, _)) => false,
         is_read: ExprIsRead,
     ) -> Ty<'db> {
         self.db.unwind_if_revision_cancelled();
-
         let expr = &self.body[tgt_expr];
         tracing::trace!(?expr);
         let ty = match expr {
         ty
     }
 
-    fn infer_expr_path(&mut self, path: &Path, id: ExprOrPatId, scope_id: ExprId) -> Ty<'db> {
+    fn infer_expr_path(
+        &mut self,
+        path: &Path,
+        id: ExprOrPatId,
+        scope_id: ExprId,
+    ) -> Ty<'db> {
         let g = self.resolver.update_to_inner_scope(self.db, self.owner, scope_id);
         let ty = match self.infer_path(path, id) {
             Some(ty) => ty,
         let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);
         let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty);
         let prev_ret_coercion = self.return_coercion.replace(CoerceMany::new(ret_ty));
-
         // FIXME: We should handle async blocks like we handle closures
         let expected = &Expectation::has_type(ret_ty);
         let (_, inner_ty) = self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {
                 ty
             }
         });
-
         self.diverges = prev_diverges;
         self.return_ty = prev_ret_ty;
         self.return_coercion = prev_ret_coercion;
-
         self.lower_async_block_type_impl_trait(inner_ty, tgt_expr)
     }
 
         }
     }
 
-    fn infer_expr_array(&mut self, array: &Array, expected: &Expectation<'db>) -> Ty<'db> {
+    fn infer_expr_array(
+        &mut self,
+        array: &Array,
+        expected: &Expectation<'db>,
+    ) -> Ty<'db> {
         let elem_ty = match expected.to_option(&mut self.table).as_ref().map(|t| t.kind()) {
             Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st,
             _ => self.table.next_ty_var(),
         };
-
         let krate = self.resolver.krate();
-
         let expected = Expectation::has_type(elem_ty);
         let (elem_ty, len) = match array {
             Array::ElementList { elements, .. } if elements.is_empty() => {
         Ty::new_array_with_const_len(self.interner(), elem_ty, len)
     }
 
-    pub(super) fn infer_return(&mut self, expr: ExprId) {
+    pub(super) fn infer_return(
+        &mut self,
+        expr: ExprId,
+    ) {
         let ret_ty = self
             .return_coercion
             .as_mut()
         self.return_coercion = Some(coerce_many);
     }
 
-    fn infer_expr_return(&mut self, ret: ExprId, expr: Option<ExprId>) -> Ty<'db> {
+    fn infer_expr_return(
+        &mut self,
+        ret: ExprId,
+        expr: Option<ExprId>,
+    ) -> Ty<'db> {
         match self.return_coercion {
             Some(_) => {
                 if let Some(expr) = expr {
         self.types.never
     }
 
-    fn infer_expr_become(&mut self, expr: ExprId) -> Ty<'db> {
+    fn infer_expr_become(
+        &mut self,
+        expr: ExprId,
+    ) -> Ty<'db> {
         match &self.return_coercion {
             Some(return_coercion) => {
                 let ret_ty = return_coercion.expected_ty();
                 self.infer_expr_no_expect(expr, ExprIsRead::Yes);
             }
         }
-
         self.types.never
     }
 
-    fn infer_expr_box(&mut self, inner_expr: ExprId, expected: &Expectation<'db>) -> Ty<'db> {
+    fn infer_expr_box(
+        &mut self,
+        inner_expr: ExprId,
+        expected: &Expectation<'db>,
+    ) -> Ty<'db> {
         if let Some(box_id) = self.resolve_boxed_box() {
             let table = &mut self.table;
             let inner_exp = expected
         };
         let lhs_ty = self.infer_expr(lhs, &lhs_expectation, is_read);
         let rhs_ty = self.table.next_ty_var();
-
         let trait_func = lang_items_for_bin_op(op).and_then(|(name, lang_item)| {
             let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;
             let func = trait_id.trait_items(self.db).method_by_name(&name)?;
                 return ret_ty;
             }
         };
-
         // HACK: We can use this substitution for the function because the function itself doesn't
         // have its own generic parameters.
         let args = GenericArgs::new_from_iter(self.interner(), [lhs_ty.into(), rhs_ty.into()]);
-
         self.write_method_resolution(tgt_expr, func, args);
-
         let method_ty = self.db.value_ty(func.into()).unwrap().instantiate(self.interner(), args);
         self.register_obligations_for_call(method_ty);
-
         self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty), ExprIsRead::Yes);
-
         let ret_ty = match method_ty.callable_sig(self.interner()) {
             Some(sig) => {
                 let sig = sig.skip_binder();
             }
             None => self.err_ty(),
         };
-
         let ret_ty = self.process_remote_user_written_ty(ret_ty);
-
         if self.is_builtin_binop(lhs_ty, rhs_ty, op) {
             // use knowledge of built-in binary ops, which can sometimes help inference
             let builtin_ret = self.enforce_builtin_binop_types(lhs_ty, rhs_ty, op);
             let prev_block = self.table.infer_ctxt.interner.block.replace(block_id);
             (prev_env, prev_block)
         });
-
         let (break_ty, ty) =
             self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty), label, |this| {
                 for stmt in statements {
             self.table.trait_env = prev_env;
             self.table.infer_ctxt.interner.block = prev_block;
         }
-
         break_ty.unwrap_or(ty)
     }
 
                 .instantiate(interner, parameters);
             Some((Either::Left(field_id), ty))
         });
-
         Some(match res {
             Some((field_id, ty)) => {
                 let adjustments = autoderef.adjust_steps();
     ) -> Ty<'db> {
         // Field projections don't constitute reads.
         let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none(), ExprIsRead::No);
-
         if name.is_missing() {
             // Bail out early, don't even try to look up field. Also, we don't issue an unresolved
             // field diagnostic because this is a syntax error rather than a semantic error.
             return self.err_ty();
         }
-
         match self.lookup_field(receiver_ty, name) {
             Some((ty, field_id, adjustments, is_public)) => {
                 self.write_expr_adj(receiver, adjustments.into_boxed_slice());
         expected: &Expectation<'db>,
     ) -> Ty<'db> {
         self.register_obligations_for_call(callee_ty);
-
         self.check_call_arguments(
             tgt_expr,
             param_tys,
     ) -> Ty<'db> {
         let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none(), ExprIsRead::Yes);
         let receiver_ty = self.table.try_structurally_resolve_type(receiver_ty);
-
         if matches!(receiver_ty.kind(), TyKind::Error(_) | TyKind::Infer(InferTy::TyVar(_))) {
             // Don't probe on error type, or on a fully unresolved infer var.
             // FIXME: Emit an error if we're probing on an infer var (type annotations needed).
             }
             return receiver_ty;
         }
-
         let canonicalized_receiver = self.canonicalize(receiver_ty);
-
         let resolved = method_resolution::lookup_method(
             &canonicalized_receiver,
             &mut self.table,
                 }
             };
         self.table.unify(formal_receiver_ty, receiver_ty);
-
         self.check_call_arguments(tgt_expr, &param_tys, ret_ty, expected, args, &[], is_varargs);
         self.table.normalize_associated_types_in(ret_ty)
     }
     pub(in super::super) fn check_call_arguments(
         &mut self,
         call_expr: ExprId,
-        // Types (as defined in the *signature* of the target function)
         formal_input_tys: &[Ty<'db>],
         formal_output: Ty<'db>,
-        // Expected output from the parent expression or statement
         expectation: &Expectation<'db>,
-        // The expressions for each provided argument
         provided_args: &[ExprId],
         skip_indices: &[u32],
-        // Whether the function is variadic, for example when imported from C
         c_variadic: bool,
     ) {
         // First, let's unify the formal method signature with the expectation eagerly.
                     .ok()
             })
             .unwrap_or_default();
-
         // If there are no external expectations at the call site, just use the types from the function defn
         let expected_input_tys = if let Some(expected_input_tys) = &expected_input_tys {
             assert_eq!(expected_input_tys.len(), formal_input_tys.len());
         } else {
             formal_input_tys
         };
-
         let minimum_input_count = expected_input_tys.len();
         let provided_arg_count = provided_args.len() - skip_indices.len();
-
         // Keep track of whether we *could possibly* be satisfied, i.e. whether we're on the happy path
         // if the wrong number of arguments were supplied, we CAN'T be satisfied,
         // and if we're c_variadic, the supplied arguments must be >= the minimum count from the function
         } else {
             provided_arg_count == minimum_input_count
         };
-
         if !args_count_matches {
             self.push_diagnostic(InferenceDiagnostic::MismatchedArgCount {
                 call_expr,
                 found: provided_args.len(),
             });
         }
-
         // We introduce a helper function to demand that a given argument satisfy a given input
         // This is more complicated than just checking type equality, as arguments could be coerced
         // This version writes those types back so further type checking uses the narrowed types
                 Err(err) => Err((Some(err), coerced_ty, checked_ty)),
             }
         };
-
         // Check the arguments.
         // We do this in a pretty awful way: first we type-check any arguments
         // that are not closures, then we type-check the closures. This is so
                 }
             }
         }
-
         if !args_count_matches {}
     }
 
             ctx: &'a mut InferenceContext<'b, 'db>,
             expr: ExprId,
         }
-
         impl<'db> GenericArgsLowerer<'db> for LowererCtx<'_, '_, 'db> {
             fn report_len_mismatch(
                 &mut self,
                 unreachable!("we set `LifetimeElisionKind::Infer`")
             }
         }
-
         substs_from_args_and_bindings(
             self.db,
             self.body,
         )
     }
 
-    fn register_obligations_for_call(&mut self, callable_ty: Ty<'db>) {
+    fn register_obligations_for_call(
+        &mut self,
+        callable_ty: Ty<'db>,
+    ) {
         let callable_ty = self.table.try_structurally_resolve_type(callable_ty);
         if let TyKind::FnDef(fn_def, parameters) = callable_ty.kind() {
             let generic_predicates =
     }
 
     /// Returns the argument indices to skip.
-    fn check_legacy_const_generics(&mut self, callee: Ty<'db>, args: &[ExprId]) -> Box<[u32]> {
+    fn check_legacy_const_generics(
+        &mut self,
+        callee: Ty<'db>,
+        args: &[ExprId],
+    ) -> Box<[u32]> {
         let (func, _subst) = match callee.kind() {
             TyKind::FnDef(callable, subst) => {
                 let func = match callable.0 {
             }
             _ => return Default::default(),
         };
-
         let data = self.db.function_signature(func);
         let Some(legacy_const_generics_indices) = &data.legacy_const_generics_indices else {
             return Default::default();
         };
-
         // only use legacy const generics if the param count matches with them
         if data.params.len() + legacy_const_generics_indices.len() != args.len() {
             if args.len() <= data.params.len() {
                 return indices;
             }
         }
-
         // check legacy const parameters
         for arg_idx in legacy_const_generics_indices.iter().copied() {
             if arg_idx >= args.len() as u32 {
     }
 
     /// Dereferences a single level of immutable referencing.
-    fn deref_ty_if_possible(&mut self, ty: Ty<'db>) -> Ty<'db> {
+    fn deref_ty_if_possible(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         let ty = self.table.try_structurally_resolve_type(ty);
         match ty.kind() {
             TyKind::Ref(_, inner, Mutability::Not) => {
 
     /// Enforces expectations on lhs type and rhs type depending on the operator and returns the
     /// output type of the binary op.
-    fn enforce_builtin_binop_types(&mut self, lhs: Ty<'db>, rhs: Ty<'db>, op: BinaryOp) -> Ty<'db> {
+    fn enforce_builtin_binop_types(
+        &mut self,
+        lhs: Ty<'db>,
+        rhs: Ty<'db>,
+        op: BinaryOp,
+    ) -> Ty<'db> {
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
-
         let (op, is_assign) = match op {
             BinaryOp::Assignment { op: Some(inner) } => (BinaryOp::ArithOp(inner), true),
             _ => (op, false),
         };
-
         let output_ty = match op {
             BinaryOp::LogicOp(_) => {
                 let bool_ = self.types.bool;
 
             BinaryOp::Assignment { .. } => unreachable!("handled above"),
         };
-
         if is_assign { self.types.unit } else { output_ty }
     }
 
-    fn is_builtin_binop(&mut self, lhs: Ty<'db>, rhs: Ty<'db>, op: BinaryOp) -> bool {
+    fn is_builtin_binop(
+        &mut self,
+        lhs: Ty<'db>,
+        rhs: Ty<'db>,
+        op: BinaryOp,
+    ) -> bool {
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
-
         let op = match op {
             BinaryOp::Assignment { op: Some(inner) } => BinaryOp::ArithOp(inner),
             _ => op,
         };
-
         match op {
             BinaryOp::LogicOp(_) => true,
 