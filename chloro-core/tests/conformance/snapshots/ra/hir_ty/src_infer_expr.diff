COMPARISON DIFF
============================================================

Original size: 111676 bytes
Chloro size:   111387 bytes
Rustfmt size:  111676 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir_def::hir::ClosureKind;
 use hir_def::{
-    BlockId, FieldId, GenericDefId, GenericParamId, ItemContainerId, Lookup, TupleFieldId, TupleId,
     expr_store::path::{GenericArg as HirGenericArg, GenericArgs as HirGenericArgs, Path},
     hir::{
-        ArithOp, Array, AsmOperand, AsmOptions, BinaryOp, Expr, ExprId, ExprOrPatId, LabelId,
-        Literal, Pat, PatId, Statement, UnaryOp, generics::GenericParamDataRef,
+        generics::GenericParamDataRef, ArithOp, Array, AsmOperand, AsmOptions, BinaryOp, Expr,
+        ExprId, ExprOrPatId, LabelId, Literal, Pat, PatId, Statement, UnaryOp,
     },
     lang_item::{LangItem, LangItemTarget},
     resolver::ValueNs,
+    BlockId, FieldId, GenericDefId, GenericParamId, ItemContainerId, Lookup, TupleFieldId, TupleId,
 };
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_type_ir::{
-    CoroutineArgs, CoroutineArgsParts, InferTy, Interner,
     inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Ty as _},
+    CoroutineArgs, CoroutineArgsParts, InferTy, Interner,
 };
 use syntax::ast::RangeOp;
 use tracing::debug;
 
 use crate::{
-    Adjust, Adjustment, AutoBorrow, CallableDefId, DeclContext, DeclOrigin,
-    IncorrectGenericsLenKind, Rawness, TraitEnvironment,
     autoderef::overloaded_deref_ty,
     consteval,
     db::InternedCoroutine,
     generics::generics,
     infer::{
+        coerce::{CoerceMany, CoerceNever}, find_continuable, pat::contains_explicit_ref_binding,
         AllowTwoPhase, BreakableKind,
-        coerce::{CoerceMany, CoerceNever},
-        find_continuable,
-        pat::contains_explicit_ref_binding,
     },
     lang_items::lang_items_for_bin_op,
     lower::{
-        LifetimeElisionKind, lower_mutability,
+        lower_mutability,
         path::{GenericArgsLowerer, TypeLikeConst, substs_from_args_and_bindings},
+        LifetimeElisionKind,
     },
     method_resolution::{self, VisibleFromModule},
     next_solver::{
-        Const, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs, TraitRef, Ty, TyKind,
-        TypeError,
         infer::{
             InferOk,
             traits::{Obligation, ObligationCause},
         },
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Const, DbInterner, ErrorGuaranteed, GenericArg,
+        GenericArgs, TraitRef, Ty, TyKind, TypeError,
     },
     traits::FnTrait,
+    Adjust, Adjustment, AutoBorrow, CallableDefId, DeclContext, DeclOrigin,
+    IncorrectGenericsLenKind, Rawness, TraitEnvironment,
 };
-
 use super::{
-    BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch,
-    cast::CastCheck, find_breakable,
+    cast::CastCheck,
+    find_breakable, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,
+    TypeMismatch,
 };
 
 #[derive(Clone, Copy, PartialEq, Eq)]
         if is_read == ExprIsRead::Yes {
             return true;
         }
-
         // We only care about place exprs. Anything else returns an immediate
         // which would constitute a read. We don't care about distinguishing
         // "syntactic" place exprs since if the base of a field projection is
         if !self.is_syntactic_place_expr(expr) {
             return true;
         }
-
         // rustc queries parent hir node of `expr` here and determine whether
         // the current `expr` is read of value per its parent.
         // But since we don't have hir node, we cannot follow such "bottom-up"
         is_read: ExprIsRead,
     ) -> Ty<'db> {
         self.db.unwind_if_revision_cancelled();
-
         let expr = &self.body[tgt_expr];
         tracing::trace!(?expr);
         let ty = match expr {
         let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);
         let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty);
         let prev_ret_coercion = self.return_coercion.replace(CoerceMany::new(ret_ty));
-
         // FIXME: We should handle async blocks like we handle closures
         let expected = &Expectation::has_type(ret_ty);
         let (_, inner_ty) = self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {
                 ty
             }
         });
-
         self.diverges = prev_diverges;
         self.return_ty = prev_ret_ty;
         self.return_coercion = prev_ret_coercion;
-
         self.lower_async_block_type_impl_trait(inner_ty, tgt_expr)
     }
 
             Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st,
             _ => self.table.next_ty_var(),
         };
-
         let krate = self.resolver.krate();
-
         let expected = Expectation::has_type(elem_ty);
         let (elem_ty, len) = match array {
             Array::ElementList { elements, .. } if elements.is_empty() => {
                 self.infer_expr_no_expect(expr, ExprIsRead::Yes);
             }
         }
-
         self.types.never
     }
 
         };
         let lhs_ty = self.infer_expr(lhs, &lhs_expectation, is_read);
         let rhs_ty = self.table.next_ty_var();
-
         let trait_func = lang_items_for_bin_op(op).and_then(|(name, lang_item)| {
             let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;
             let func = trait_id.trait_items(self.db).method_by_name(&name)?;
                 return ret_ty;
             }
         };
-
         // HACK: We can use this substitution for the function because the function itself doesn't
         // have its own generic parameters.
         let args = GenericArgs::new_from_iter(self.interner(), [lhs_ty.into(), rhs_ty.into()]);
-
         self.write_method_resolution(tgt_expr, func, args);
-
         let method_ty = self.db.value_ty(func.into()).unwrap().instantiate(self.interner(), args);
         self.register_obligations_for_call(method_ty);
-
         self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty), ExprIsRead::Yes);
-
         let ret_ty = match method_ty.callable_sig(self.interner()) {
             Some(sig) => {
                 let sig = sig.skip_binder();
             }
             None => self.err_ty(),
         };
-
         let ret_ty = self.process_remote_user_written_ty(ret_ty);
-
         if self.is_builtin_binop(lhs_ty, rhs_ty, op) {
             // use knowledge of built-in binary ops, which can sometimes help inference
             let builtin_ret = self.enforce_builtin_binop_types(lhs_ty, rhs_ty, op);
             let prev_block = self.table.infer_ctxt.interner.block.replace(block_id);
             (prev_env, prev_block)
         });
-
         let (break_ty, ty) =
             self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty), label, |this| {
                 for stmt in statements {
             self.table.trait_env = prev_env;
             self.table.infer_ctxt.interner.block = prev_block;
         }
-
         break_ty.unwrap_or(ty)
     }
 
                 .instantiate(interner, parameters);
             Some((Either::Left(field_id), ty))
         });
-
         Some(match res {
             Some((field_id, ty)) => {
                 let adjustments = autoderef.adjust_steps();
     ) -> Ty<'db> {
         // Field projections don't constitute reads.
         let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none(), ExprIsRead::No);
-
         if name.is_missing() {
             // Bail out early, don't even try to look up field. Also, we don't issue an unresolved
             // field diagnostic because this is a syntax error rather than a semantic error.
             return self.err_ty();
         }
-
         match self.lookup_field(receiver_ty, name) {
             Some((ty, field_id, adjustments, is_public)) => {
                 self.write_expr_adj(receiver, adjustments.into_boxed_slice());
         expected: &Expectation<'db>,
     ) -> Ty<'db> {
         self.register_obligations_for_call(callee_ty);
-
         self.check_call_arguments(
             tgt_expr,
             param_tys,
     ) -> Ty<'db> {
         let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none(), ExprIsRead::Yes);
         let receiver_ty = self.table.try_structurally_resolve_type(receiver_ty);
-
         if matches!(receiver_ty.kind(), TyKind::Error(_) | TyKind::Infer(InferTy::TyVar(_))) {
             // Don't probe on error type, or on a fully unresolved infer var.
             // FIXME: Emit an error if we're probing on an infer var (type annotations needed).
             }
             return receiver_ty;
         }
-
         let canonicalized_receiver = self.canonicalize(receiver_ty);
-
         let resolved = method_resolution::lookup_method(
             &canonicalized_receiver,
             &mut self.table,
                 }
             };
         self.table.unify(formal_receiver_ty, receiver_ty);
-
         self.check_call_arguments(tgt_expr, &param_tys, ret_ty, expected, args, &[], is_varargs);
         self.table.normalize_associated_types_in(ret_ty)
     }
     pub(in super::super) fn check_call_arguments(
         &mut self,
         call_expr: ExprId,
-        // Types (as defined in the *signature* of the target function)
         formal_input_tys: &[Ty<'db>],
         formal_output: Ty<'db>,
-        // Expected output from the parent expression or statement
         expectation: &Expectation<'db>,
-        // The expressions for each provided argument
         provided_args: &[ExprId],
         skip_indices: &[u32],
-        // Whether the function is variadic, for example when imported from C
         c_variadic: bool,
     ) {
         // First, let's unify the formal method signature with the expectation eagerly.
                     .ok()
             })
             .unwrap_or_default();
-
         // If there are no external expectations at the call site, just use the types from the function defn
         let expected_input_tys = if let Some(expected_input_tys) = &expected_input_tys {
             assert_eq!(expected_input_tys.len(), formal_input_tys.len());
         } else {
             formal_input_tys
         };
-
         let minimum_input_count = expected_input_tys.len();
         let provided_arg_count = provided_args.len() - skip_indices.len();
-
         // Keep track of whether we *could possibly* be satisfied, i.e. whether we're on the happy path
         // if the wrong number of arguments were supplied, we CAN'T be satisfied,
         // and if we're c_variadic, the supplied arguments must be >= the minimum count from the function
         } else {
             provided_arg_count == minimum_input_count
         };
-
         if !args_count_matches {
             self.push_diagnostic(InferenceDiagnostic::MismatchedArgCount {
                 call_expr,
                 found: provided_args.len(),
             });
         }
-
         // We introduce a helper function to demand that a given argument satisfy a given input
         // This is more complicated than just checking type equality, as arguments could be coerced
         // This version writes those types back so further type checking uses the narrowed types
                 Err(err) => Err((Some(err), coerced_ty, checked_ty)),
             }
         };
-
         // Check the arguments.
         // We do this in a pretty awful way: first we type-check any arguments
         // that are not closures, then we type-check the closures. This is so
                 }
             }
         }
-
         if !args_count_matches {}
     }
 
             ctx: &'a mut InferenceContext<'b, 'db>,
             expr: ExprId,
         }
-
         impl<'db> GenericArgsLowerer<'db> for LowererCtx<'_, '_, 'db> {
             fn report_len_mismatch(
                 &mut self,
                 unreachable!("we set `LifetimeElisionKind::Infer`")
             }
         }
-
         substs_from_args_and_bindings(
             self.db,
             self.body,
             }
             _ => return Default::default(),
         };
-
         let data = self.db.function_signature(func);
         let Some(legacy_const_generics_indices) = &data.legacy_const_generics_indices else {
             return Default::default();
         };
-
         // only use legacy const generics if the param count matches with them
         if data.params.len() + legacy_const_generics_indices.len() != args.len() {
             if args.len() <= data.params.len() {
                 return indices;
             }
         }
-
         // check legacy const parameters
         for arg_idx in legacy_const_generics_indices.iter().copied() {
             if arg_idx >= args.len() as u32 {
 
     /// Enforces expectations on lhs type and rhs type depending on the operator and returns the
     /// output type of the binary op.
-    fn enforce_builtin_binop_types(&mut self, lhs: Ty<'db>, rhs: Ty<'db>, op: BinaryOp) -> Ty<'db> {
+    fn enforce_builtin_binop_types(
+        &mut self,
+        lhs: Ty<'db>,
+        rhs: Ty<'db>,
+        op: BinaryOp,
+    ) -> Ty<'db> {
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
-
         let (op, is_assign) = match op {
             BinaryOp::Assignment { op: Some(inner) } => (BinaryOp::ArithOp(inner), true),
             _ => (op, false),
         };
-
         let output_ty = match op {
             BinaryOp::LogicOp(_) => {
                 let bool_ = self.types.bool;
 
             BinaryOp::Assignment { .. } => unreachable!("handled above"),
         };
-
         if is_assign { self.types.unit } else { output_ty }
     }
 
         // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).
         let lhs = self.deref_ty_if_possible(lhs);
         let rhs = self.deref_ty_if_possible(rhs);
-
         let op = match op {
             BinaryOp::Assignment { op: Some(inner) } => BinaryOp::ArithOp(inner),
             _ => op,
         };
-
         match op {
             BinaryOp::LogicOp(_) => true,
 