COMPARISON DIFF
============================================================

Original size: 50684 bytes
Chloro size:   50698 bytes
Rustfmt size:  50684 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use rustc_next_trait_solver::solve::{GoalEvaluation, SolverDelegateEvalExt};
 use rustc_type_ir::{
-    AliasRelationDirection, AliasTermKind, HostEffectPredicate, Interner, PredicatePolarity,
     error::ExpectedFound,
     inherent::{IntoKind, SliceLike, Span as _},
     lang_items::SolverTraitLangItem,
     solve::{Certainty, GoalSource, MaybeCause, NoSolution},
+    AliasRelationDirection, AliasTermKind, HostEffectPredicate, Interner, PredicatePolarity,
 };
 use tracing::{instrument, trace};
 
 use crate::next_solver::{
-    AliasTerm, Binder, ClauseKind, Const, ConstKind, DbInterner, PolyTraitPredicate, PredicateKind,
-    SolverContext, Span, Term, TraitPredicate, Ty, TyKind, TypeError,
     fulfill::NextSolverError,
     infer::{
-        InferCtxt,
         select::SelectionError,
         traits::{Obligation, ObligationCause, PredicateObligation, PredicateObligations},
+        InferCtxt,
     },
     inspect::{self, ProofTreeVisitor},
     normalize::deeply_normalize_for_diagnostics,
+    AliasTerm, Binder, ClauseKind, Const, ConstKind, DbInterner, PolyTraitPredicate, PredicateKind,
+    SolverContext, Span, Term, TraitPredicate, Ty, TyKind, TypeError,
 };
 
 #[derive(Debug)]
     Cycle(PredicateObligations<'db>),
     Select(SelectionError<'db>),
     Project(MismatchedProjectionTypes<'db>),
-    Subtype(ExpectedFound<Ty<'db>>, TypeError<'db>), // always comes from a SubtypePredicate
+    Subtype(ExpectedFound<Ty<'db>>, TypeError<'db>),
+    // always comes from a SubtypePredicate
     ConstEquate(ExpectedFound<Const<'db>>, TypeError<'db>),
     Ambiguity {
         /// Overflow is only `Some(suggest_recursion_limit)` when using the next generation
     infcx: &InferCtxt<'db>,
     root_obligation: PredicateObligation<'db>,
 ) -> FulfillmentError<'db> {
-    let (code, refine_obligation) = infcx.probe(|_| {
+    let (code, refine_obligation) = infcx
+        .probe(|_| {
         match <&SolverContext<'db>>::from(infcx).evaluate_root_goal(
             root_obligation.as_goal(),
             Span::dummy(),
         };
 
         // // Don't walk into impls that have `do_not_recommend`.
+
         // if let inspect::ProbeKind::TraitCandidate {
+
         //     source: CandidateSource::Impl(impl_def_id),
+
         //     result: _,
+
         // } = candidate.kind()
+
         //     && interner.do_not_recommend_impl(impl_def_id)
+
         // {
+
         //     trace!("#[do_not_recommend] -> exit");
+
         //     return ControlFlow::Break(self.obligation.clone());
+
         // }
 
         // FIXME: Also, what about considering >1 layer up the stack? May be necessary
+
         // for normalizes-to.
         let child_mode = match pred.kind().skip_binder() {
             PredicateKind::Clause(ClauseKind::Trait(trait_pred)) => {
         let nested_goals = candidate.instantiate_nested_goals();
 
         // If the candidate requires some `T: FnPtr` bound which does not hold should not be treated as
+
         // an actual candidate, instead we should treat them as if the impl was never considered to
+
         // have potentially applied. As if `impl<A, R> Trait for for<..> fn(..A) -> R` was written
+
         // instead of `impl<T: FnPtr> Trait for T`.
+
         //
+
         // We do this as a separate loop so that we do not choose to tell the user about some nested
+
         // goal before we encounter a `T: FnPtr` nested goal.
         for nested_goal in &nested_goals {
             if let Some(poly_trait_pred) = nested_goal.goal().predicate.as_trait_clause()
         }
 
         // alias-relate may fail because the lhs or rhs can't be normalized,
+
         // and therefore is treated as rigid.
         if let Some(PredicateKind::AliasRelate(lhs, rhs, _)) = pred.kind().no_bound_vars() {
             goal.infcx().visit_proof_tree_at_depth(
         Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
     };
     use tracing::{debug, instrument};
-
     use crate::next_solver::infer::InferCtxt;
     use crate::next_solver::infer::traits::{Obligation, ObligationCause, PredicateObligations};
     use crate::next_solver::{
         Binder, ClauseKind, Const, ConstKind, Ctor, DbInterner, ExistentialPredicate, GenericArgs,
         ParamEnv, Predicate, PredicateKind, Region, SolverDefId, Term, TraitRef, Ty, TyKind,
     };
-
     /// Compute the predicates that are required for a type to be well-formed.
     ///
     /// This is only intended to be used in the new solver, since it does not
         debug_assert_eq!(term, infcx.resolve_vars_if_possible(term));
 
         // However, if `arg` IS an unresolved inference variable, returns `None`,
+
         // because we are not able to make any progress at all. This is to prevent
+
         // cycles where we say "?0 is WF if ?0 is WF".
         if term.is_infer() {
             return None;
         }
 
-        let mut wf =
-            WfPredicates { infcx, param_env, out: PredicateObligations::new(), recursion_depth: 0 };
+        let mut wf = WfPredicates { infcx, param_env, out: PredicateObligations::new(), recursion_depth: 0 };
         wf.add_wf_preds_for_term(term);
         Some(wf.out)
     }
-
     struct WfPredicates<'a, 'db> {
         infcx: &'a InferCtxt<'db>,
         param_env: ParamEnv<'db>,
         out: PredicateObligations<'db>,
         recursion_depth: usize,
     }
-
     impl<'a, 'db> WfPredicates<'a, 'db> {
         fn interner(&self) -> DbInterner<'db> {
             self.infcx.interner
             }
         }
     }
-
     impl<'a, 'db> TypeVisitor<DbInterner<'db>> for WfPredicates<'a, 'db> {
         type Result = ();
 
             panic!("predicate should not be checked for well-formedness");
         }
     }
-
     /// Given an object type like `SomeTrait + Send`, computes the lifetime
     /// bounds that must hold on the elided self type. These are derived
     /// from the declarations of `SomeTrait`, `Send`, and friends -- if