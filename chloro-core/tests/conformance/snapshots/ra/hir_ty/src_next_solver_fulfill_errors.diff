COMPARISON DIFF
============================================================

Original size: 50684 bytes
Chloro size:   50782 bytes
Rustfmt size:  50684 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     SolverContext, Span, Term, TraitPredicate, Ty, TyKind, TypeError,
     fulfill::NextSolverError,
     infer::{
-        InferCtxt,
-        select::SelectionError,
+        InferCtxt, select::SelectionError,
         traits::{Obligation, ObligationCause, PredicateObligation, PredicateObligations},
     },
     inspect::{self, ProofTreeVisitor},
                 goal.goal().param_env,
                 pred,
             );
-            self.with_derived_obligation(obligation, |this| {
+            self.with_derived_obligation(
+                obligation,
+                |this| {
                 goal.infcx().visit_proof_tree_at_depth(
                     goal.goal().with(interner, pred),
                     goal.depth() + 1,
                     this,
                 )
-            })
+            },
+            )
         } else {
             ControlFlow::Continue(())
         }
     ) -> ControlFlow<PredicateObligation<'db>> {
         let interner = goal.infcx().interner;
         if let Some(projection_clause) = goal.goal().predicate.as_projection_clause()
-            && !projection_clause.bound_vars().is_empty()
-        {
+            && !projection_clause.bound_vars().is_empty() {
             let pred = projection_clause.map_bound(|proj| proj.projection_term.trait_ref(interner));
             let obligation = Obligation::new(
                 interner,
                 goal.goal().param_env,
                 deeply_normalize_for_diagnostics(goal.infcx(), goal.goal().param_env, pred),
             );
-            self.with_derived_obligation(obligation, |this| {
+            self.with_derived_obligation(
+                obligation,
+                |this| {
                 goal.infcx().visit_proof_tree_at_depth(
                     goal.goal().with(interner, pred),
                     goal.depth() + 1,
                     this,
                 )
-            })
+            },
+            )
         } else {
             ControlFlow::Continue(())
         }
             goal.goal().param_env,
             alias.trait_ref(interner),
         );
-        self.with_derived_obligation(obligation, |this| {
+        self.with_derived_obligation(
+            obligation,
+            |this| {
             goal.infcx().visit_proof_tree_at_depth(
                 goal.goal().with(interner, alias.trait_ref(interner)),
                 goal.depth() + 1,
                 this,
             )
-        })
+        },
+        )
     }
 
     /// If we have no candidates, then it's likely that there is a
         //     trace!("#[do_not_recommend] -> exit");
         //     return ControlFlow::Break(self.obligation.clone());
         // }
-
         // FIXME: Also, what about considering >1 layer up the stack? May be necessary
         // for normalizes-to.
         let child_mode = match pred.kind().skip_binder() {
     // Try to derive an `ObligationCause::{ImplDerived,BuiltinDerived}`,
     // and skip all `GoalSource::Misc`, which represent useless obligations
     // such as alias-eq which may not hold.
-    Trait(PolyTraitPredicate<'db>),
-    // Try to derive an `ObligationCause::{ImplDerived,BuiltinDerived}`,
+    Trait(PolyTraitPredicate<'db>), // Try to derive an `ObligationCause::{ImplDerived,BuiltinDerived}`,
     // and skip all `GoalSource::Misc`, which represent useless obligations
     // such as alias-eq which may not hold.
-    Host(Binder<'db, HostEffectPredicate<DbInterner<'db>>>),
-    // Skip trying to derive an `ObligationCause` from this obligation, and
+    Host(Binder<'db, HostEffectPredicate<DbInterner<'db>>>), // Skip trying to derive an `ObligationCause` from this obligation, and
     // report *all* sub-obligations as if they came directly from the parent
     // obligation.
     PassThrough,
         Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
     };
     use tracing::{debug, instrument};
-
     use crate::next_solver::infer::InferCtxt;
     use crate::next_solver::infer::traits::{Obligation, ObligationCause, PredicateObligations};
     use crate::next_solver::{
         Binder, ClauseKind, Const, ConstKind, Ctor, DbInterner, ExistentialPredicate, GenericArgs,
         ParamEnv, Predicate, PredicateKind, Region, SolverDefId, Term, TraitRef, Ty, TyKind,
     };
-
     /// Compute the predicates that are required for a type to be well-formed.
     ///
     /// This is only intended to be used in the new solver, since it does not
         wf.add_wf_preds_for_term(term);
         Some(wf.out)
     }
-
     struct WfPredicates<'a, 'db> {
         infcx: &'a InferCtxt<'db>,
         param_env: ParamEnv<'db>,
         out: PredicateObligations<'db>,
         recursion_depth: usize,
     }
-
     impl<'a, 'db> WfPredicates<'a, 'db> {
         fn interner(&self) -> DbInterner<'db> {
             self.infcx.interner
             }
         }
     }
-
     impl<'a, 'db> TypeVisitor<DbInterner<'db>> for WfPredicates<'a, 'db> {
         type Result = ();
 
             panic!("predicate should not be checked for well-formedness");
         }
     }
-
     /// Given an object type like `SomeTrait + Send`, computes the lifetime
     /// bounds that must hold on the elided self type. These are derived
     /// from the declarations of `SomeTrait`, `Send`, and friends -- if