COMPARISON DIFF
============================================================

Original size: 50684 bytes
Chloro size:   50798 bytes
Rustfmt size:  51892 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     SolverContext, Span, Term, TraitPredicate, Ty, TyKind, TypeError,
     fulfill::NextSolverError,
     infer::{
-        InferCtxt,
-        select::SelectionError,
+        InferCtxt, select::SelectionError,
         traits::{Obligation, ObligationCause, PredicateObligation, PredicateObligations},
     },
     inspect::{self, ProofTreeVisitor},
         code: FulfillmentErrorCode<'db>,
         root_obligation: PredicateObligation<'db>,
     ) -> FulfillmentError<'db> {
-        FulfillmentError {
-            obligation,
-            code,
-            root_obligation,
-        }
+        FulfillmentError { obligation, code, root_obligation }
     }
 
     pub fn is_true_error(&self) -> bool {
         PredicateKind::Clause(ClauseKind::Projection(_)) => {
             FulfillmentErrorCode::Project(
                 // FIXME: This could be a `Sorts` if the term is a type
-                MismatchedProjectionTypes {
-                    err: TypeError::Mismatch,
-                },
+                MismatchedProjectionTypes { err: TypeError::Mismatch },
             )
         }
         PredicateKind::Clause(ClauseKind::ConstArgHasType(ct, expected_ty)) => {
             let ct_ty = match ct.kind() {
-                ConstKind::Unevaluated(uv) => infcx
-                    .interner
-                    .type_of(uv.def)
-                    .instantiate(infcx.interner, uv.args),
+                ConstKind::Unevaluated(uv) => {
+                    infcx.interner.type_of(uv.def).instantiate(infcx.interner, uv.args)
+                }
                 ConstKind::Param(param_ct) => param_ct.find_const_ty_from_env(obligation.param_env),
                 ConstKind::Value(cv) => cv.ty,
                 kind => panic!(
             })
         }
         PredicateKind::NormalizesTo(..) => {
-            FulfillmentErrorCode::Project(MismatchedProjectionTypes {
-                err: TypeError::Mismatch,
-            })
+            FulfillmentErrorCode::Project(MismatchedProjectionTypes { err: TypeError::Mismatch })
         }
         PredicateKind::AliasRelate(_, _, _) => {
-            FulfillmentErrorCode::Project(MismatchedProjectionTypes {
-                err: TypeError::Mismatch,
-            })
+            FulfillmentErrorCode::Project(MismatchedProjectionTypes { err: TypeError::Mismatch })
         }
         PredicateKind::Subtype(pred) => {
             let (a, b) = infcx.enter_forall_and_leak_universe(
         }
     };
 
-    FulfillmentError {
-        obligation,
-        code,
-        root_obligation,
-    }
+    FulfillmentError { obligation, code, root_obligation }
 }
 
 pub(super) fn fulfillment_error_for_stalled<'db>(
             None,
         ) {
             Ok(GoalEvaluation {
-                certainty:
-                    Certainty::Maybe {
-                        cause: MaybeCause::Ambiguity,
-                        ..
-                    },
+                certainty: Certainty::Maybe { cause: MaybeCause::Ambiguity, .. },
                 ..
             }) => (FulfillmentErrorCode::Ambiguity { overflow: None }, true),
             Ok(GoalEvaluation {
                 certainty:
                     Certainty::Maybe {
                         cause:
-                            MaybeCause::Overflow {
-                                suggest_increasing_limit,
-                                keep_constraints: _,
-                            },
+                            MaybeCause::Overflow { suggest_increasing_limit, keep_constraints: _ },
                         ..
                     },
                 ..
             }) => (
-                FulfillmentErrorCode::Ambiguity {
-                    overflow: Some(suggest_increasing_limit),
-                },
+                FulfillmentErrorCode::Ambiguity { overflow: Some(suggest_increasing_limit) },
                 // Don't look into overflows because we treat overflows weirdly anyways.
                 // We discard the inference constraints from overflowing goals, so
                 // recomputing the goal again during `find_best_leaf_obligation` may apply
                 // FIXME: We should probably just look into overflows here.
                 false,
             ),
-            Ok(GoalEvaluation {
-                certainty: Certainty::Yes,
-                ..
-            }) => {
+            Ok(GoalEvaluation { certainty: Certainty::Yes, .. }) => {
                 panic!(
                     "did not expect successful goal when collecting ambiguity errors for `{:?}`",
                     infcx.resolve_vars_if_possible(root_obligation.predicate),
 ) -> FulfillmentError<'db> {
     FulfillmentError {
         obligation: find_best_leaf_obligation(infcx, &root_obligation, true),
-        code: FulfillmentErrorCode::Ambiguity {
-            overflow: Some(true),
-        },
+        code: FulfillmentErrorCode::Ambiguity { overflow: Some(true) },
         root_obligation,
     }
 }
             infcx
                 .visit_proof_tree(
                     obligation.as_goal(),
-                    &mut BestObligation {
-                        obligation: obligation.clone(),
-                        consider_ambiguities,
-                    },
+                    &mut BestObligation { obligation: obligation.clone(), consider_ambiguities },
                 )
                 .break_value()
                 .ok_or(())
                 if candidates.len() > 1 {
                     candidates.retain(|candidate| {
                         goal.infcx().probe(|_| {
-                            candidate
-                                .instantiate_nested_goals()
-                                .iter()
-                                .any(|nested_goal| {
-                                    matches!(
-                                        nested_goal.source(),
-                                        GoalSource::ImplWhereBound
-                                            | GoalSource::AliasBoundConstCondition
-                                            | GoalSource::InstantiateHigherRanked
-                                            | GoalSource::AliasWellFormed
-                                    ) && nested_goal.result().is_err()
-                                })
+                            candidate.instantiate_nested_goals().iter().any(|nested_goal| {
+                                matches!(
+                                    nested_goal.source(),
+                                    GoalSource::ImplWhereBound
+                                        | GoalSource::AliasBoundConstCondition
+                                        | GoalSource::InstantiateHigherRanked
+                                        | GoalSource::AliasWellFormed
+                                ) && nested_goal.result().is_err()
+                            })
                         })
                     });
                 }
         let infcx = candidate.goal().infcx();
         let param_env = candidate.goal().goal().param_env;
 
-        for obligation in wf::unnormalized_obligations(infcx, param_env, term)
-            .into_iter()
-            .flatten()
+        for obligation in wf::unnormalized_obligations(infcx, param_env, term).into_iter().flatten()
         {
             let nested_goal = candidate
                 .instantiate_proof_tree_for_nested_goal(GoalSource::Misc, obligation.as_goal());
             // Skip nested goals that aren't the *reason* for our goal's failure.
             match (self.consider_ambiguities, nested_goal.result()) {
-                (
-                    true,
-                    Ok(Certainty::Maybe {
-                        cause: MaybeCause::Ambiguity,
-                        ..
-                    }),
-                )
+                (true, Ok(Certainty::Maybe { cause: MaybeCause::Ambiguity, .. }))
                 | (false, Err(_)) => {}
                 _ => continue,
             }
                 goal.goal().param_env,
                 pred,
             );
-            self.with_derived_obligation(obligation, |this| {
+            self.with_derived_obligation(
+                obligation,
+                |this| {
                 goal.infcx().visit_proof_tree_at_depth(
                     goal.goal().with(interner, pred),
                     goal.depth() + 1,
                     this,
                 )
-            })
+            },
+            )
         } else {
             ControlFlow::Continue(())
         }
                 goal.goal().param_env,
                 deeply_normalize_for_diagnostics(goal.infcx(), goal.goal().param_env, pred),
             );
-            self.with_derived_obligation(obligation, |this| {
+            self.with_derived_obligation(
+                obligation,
+                |this| {
                 goal.infcx().visit_proof_tree_at_depth(
                     goal.goal().with(interner, pred),
                     goal.depth() + 1,
                     this,
                 )
-            })
+            },
+            )
         } else {
             ControlFlow::Continue(())
         }
             goal.goal().param_env,
             alias.trait_ref(interner),
         );
-        self.with_derived_obligation(obligation, |this| {
+        self.with_derived_obligation(
+            obligation,
+            |this| {
             goal.infcx().visit_proof_tree_at_depth(
                 goal.goal().with(interner, alias.trait_ref(interner)),
                 goal.depth() + 1,
                 this,
             )
-        })
+        },
+        )
     }
 
     /// If we have no candidates, then it's likely that there is a
         let interner = goal.infcx().interner;
         // Skip goals that aren't the *reason* for our goal's failure.
         match (self.consider_ambiguities, goal.result()) {
-            (
-                true,
-                Ok(Certainty::Maybe {
-                    cause: MaybeCause::Ambiguity,
-                    ..
-                }),
-            )
-            | (false, Err(_)) => {}
+            (true, Ok(Certainty::Maybe { cause: MaybeCause::Ambiguity, .. })) | (false, Err(_)) => {
+            }
             _ => return ControlFlow::Continue(()),
         }
 
         //     trace!("#[do_not_recommend] -> exit");
         //     return ControlFlow::Break(self.obligation.clone());
         // }
-
         // FIXME: Also, what about considering >1 layer up the stack? May be necessary
         // for normalizes-to.
         let child_mode = match pred.kind().skip_binder() {
         Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
     };
     use tracing::{debug, instrument};
-
     use crate::next_solver::infer::InferCtxt;
     use crate::next_solver::infer::traits::{Obligation, ObligationCause, PredicateObligations};
     use crate::next_solver::{
         Binder, ClauseKind, Const, ConstKind, Ctor, DbInterner, ExistentialPredicate, GenericArgs,
         ParamEnv, Predicate, PredicateKind, Region, SolverDefId, Term, TraitRef, Ty, TyKind,
     };
-
     /// Compute the predicates that are required for a type to be well-formed.
     ///
     /// This is only intended to be used in the new solver, since it does not
             return None;
         }
 
-        let mut wf = WfPredicates {
-            infcx,
-            param_env,
-            out: PredicateObligations::new(),
-            recursion_depth: 0,
-        };
+        let mut wf =
+            WfPredicates { infcx, param_env, out: PredicateObligations::new(), recursion_depth: 0 };
         wf.add_wf_preds_for_term(term);
         Some(wf.out)
     }
-
     struct WfPredicates<'a, 'db> {
         infcx: &'a InferCtxt<'db>,
         param_env: ParamEnv<'db>,
         out: PredicateObligations<'db>,
         recursion_depth: usize,
     }
-
     impl<'a, 'db> WfPredicates<'a, 'db> {
         fn interner(&self) -> DbInterner<'db> {
             self.infcx.interner
                 let cause = ObligationCause::new();
                 let trait_ref = TraitRef::new(
                     self.interner(),
-                    self.interner()
-                        .require_trait_lang_item(SolverTraitLangItem::Sized),
+                    self.interner().require_trait_lang_item(SolverTraitLangItem::Sized),
                     [subty],
                 );
                 self.out.push(Obligation::with_depth(
             // the nominal obligations of `Sized` would in-effect just elaborate `MetaSized` and make
             // the compiler do a bunch of work needlessly.
             if let SolverDefId::TraitId(def_id) = def_id
-                && self
-                    .interner()
-                    .is_trait_lang_item(def_id.into(), SolverTraitLangItem::Sized)
+                && self.interner().is_trait_lang_item(def_id.into(), SolverTraitLangItem::Sized)
             {
                 return Default::default();
             }
             }
         }
     }
-
     impl<'a, 'db> TypeVisitor<DbInterner<'db>> for WfPredicates<'a, 'db> {
         type Result = ();
 
                         if let SolverDefId::ConstId(uv_def) = uv.def
                             && let ItemContainerId::ImplId(impl_) =
                                 uv_def.loc(self.interner().db).container
-                            && self
-                                .interner()
-                                .db
-                                .impl_signature(impl_)
-                                .target_trait
-                                .is_none()
+                            && self.interner().db.impl_signature(impl_).target_trait.is_none()
                         {
                             return; // Subtree is handled by above function
                         } else {
             panic!("predicate should not be checked for well-formedness");
         }
     }
-
     /// Given an object type like `SomeTrait + Send`, computes the lifetime
     /// bounds that must hold on the elided self type. These are derived
     /// from the declarations of `SomeTrait`, `Send`, and friends -- if