COMPARISON DIFF
============================================================

Original size: 50684 bytes
Chloro size:   50819 bytes
Rustfmt size:  50684 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use rustc_next_trait_solver::solve::{GoalEvaluation, SolverDelegateEvalExt};
 use rustc_type_ir::{
-    AliasRelationDirection, AliasTermKind, HostEffectPredicate, Interner, PredicatePolarity,
     error::ExpectedFound,
     inherent::{IntoKind, SliceLike, Span as _},
     lang_items::SolverTraitLangItem,
     solve::{Certainty, GoalSource, MaybeCause, NoSolution},
+    AliasRelationDirection, AliasTermKind, HostEffectPredicate, Interner, PredicatePolarity,
 };
 use tracing::{instrument, trace};
 
 use crate::next_solver::{
-    AliasTerm, Binder, ClauseKind, Const, ConstKind, DbInterner, PolyTraitPredicate, PredicateKind,
-    SolverContext, Span, Term, TraitPredicate, Ty, TyKind, TypeError,
     fulfill::NextSolverError,
     infer::{
-        InferCtxt,
         select::SelectionError,
         traits::{Obligation, ObligationCause, PredicateObligation, PredicateObligations},
+        InferCtxt,
     },
     inspect::{self, ProofTreeVisitor},
     normalize::deeply_normalize_for_diagnostics,
+    AliasTerm, Binder, ClauseKind, Const, ConstKind, DbInterner, PolyTraitPredicate, PredicateKind,
+    SolverContext, Span, Term, TraitPredicate, Ty, TyKind, TypeError,
 };
 
 #[derive(Debug)]
     Cycle(PredicateObligations<'db>),
     Select(SelectionError<'db>),
     Project(MismatchedProjectionTypes<'db>),
-    Subtype(ExpectedFound<Ty<'db>>, TypeError<'db>), // always comes from a SubtypePredicate
+    Subtype(ExpectedFound<Ty<'db>>, TypeError<'db>),
+    // always comes from a SubtypePredicate
     ConstEquate(ExpectedFound<Const<'db>>, TypeError<'db>),
     Ambiguity {
         /// Overflow is only `Some(suggest_recursion_limit)` when using the next generation
                 goal.goal().param_env,
                 pred,
             );
-            self.with_derived_obligation(obligation, |this| {
+            self.with_derived_obligation(
+                obligation,
+                |this| {
                 goal.infcx().visit_proof_tree_at_depth(
                     goal.goal().with(interner, pred),
                     goal.depth() + 1,
                     this,
                 )
-            })
+            },
+            )
         } else {
             ControlFlow::Continue(())
         }
     ) -> ControlFlow<PredicateObligation<'db>> {
         let interner = goal.infcx().interner;
         if let Some(projection_clause) = goal.goal().predicate.as_projection_clause()
-            && !projection_clause.bound_vars().is_empty()
-        {
+            && !projection_clause.bound_vars().is_empty() {
             let pred = projection_clause.map_bound(|proj| proj.projection_term.trait_ref(interner));
             let obligation = Obligation::new(
                 interner,
                 goal.goal().param_env,
                 deeply_normalize_for_diagnostics(goal.infcx(), goal.goal().param_env, pred),
             );
-            self.with_derived_obligation(obligation, |this| {
+            self.with_derived_obligation(
+                obligation,
+                |this| {
                 goal.infcx().visit_proof_tree_at_depth(
                     goal.goal().with(interner, pred),
                     goal.depth() + 1,
                     this,
                 )
-            })
+            },
+            )
         } else {
             ControlFlow::Continue(())
         }
             goal.goal().param_env,
             alias.trait_ref(interner),
         );
-        self.with_derived_obligation(obligation, |this| {
+        self.with_derived_obligation(
+            obligation,
+            |this| {
             goal.infcx().visit_proof_tree_at_depth(
                 goal.goal().with(interner, alias.trait_ref(interner)),
                 goal.depth() + 1,
                 this,
             )
-        })
+        },
+        )
     }
 
     /// If we have no candidates, then it's likely that there is a
         };
 
         // // Don't walk into impls that have `do_not_recommend`.
+
         // if let inspect::ProbeKind::TraitCandidate {
+
         //     source: CandidateSource::Impl(impl_def_id),
+
         //     result: _,
+
         // } = candidate.kind()
+
         //     && interner.do_not_recommend_impl(impl_def_id)
+
         // {
+
         //     trace!("#[do_not_recommend] -> exit");
+
         //     return ControlFlow::Break(self.obligation.clone());
+
         // }
 
         // FIXME: Also, what about considering >1 layer up the stack? May be necessary
+
         // for normalizes-to.
         let child_mode = match pred.kind().skip_binder() {
             PredicateKind::Clause(ClauseKind::Trait(trait_pred)) => {
         let nested_goals = candidate.instantiate_nested_goals();
 
         // If the candidate requires some `T: FnPtr` bound which does not hold should not be treated as
+
         // an actual candidate, instead we should treat them as if the impl was never considered to
+
         // have potentially applied. As if `impl<A, R> Trait for for<..> fn(..A) -> R` was written
+
         // instead of `impl<T: FnPtr> Trait for T`.
+
         //
+
         // We do this as a separate loop so that we do not choose to tell the user about some nested
+
         // goal before we encounter a `T: FnPtr` nested goal.
         for nested_goal in &nested_goals {
             if let Some(poly_trait_pred) = nested_goal.goal().predicate.as_trait_clause()
         }
 
         // alias-relate may fail because the lhs or rhs can't be normalized,
+
         // and therefore is treated as rigid.
         if let Some(PredicateKind::AliasRelate(lhs, rhs, _)) = pred.kind().no_bound_vars() {
             goal.infcx().visit_proof_tree_at_depth(
         Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
     };
     use tracing::{debug, instrument};
-
     use crate::next_solver::infer::InferCtxt;
     use crate::next_solver::infer::traits::{Obligation, ObligationCause, PredicateObligations};
     use crate::next_solver::{
         Binder, ClauseKind, Const, ConstKind, Ctor, DbInterner, ExistentialPredicate, GenericArgs,
         ParamEnv, Predicate, PredicateKind, Region, SolverDefId, Term, TraitRef, Ty, TyKind,
     };
-
     /// Compute the predicates that are required for a type to be well-formed.
     ///
     /// This is only intended to be used in the new solver, since it does not
         debug_assert_eq!(term, infcx.resolve_vars_if_possible(term));
 
         // However, if `arg` IS an unresolved inference variable, returns `None`,
+
         // because we are not able to make any progress at all. This is to prevent
+
         // cycles where we say "?0 is WF if ?0 is WF".
         if term.is_infer() {
             return None;
         wf.add_wf_preds_for_term(term);
         Some(wf.out)
     }
-
     struct WfPredicates<'a, 'db> {
         infcx: &'a InferCtxt<'db>,
         param_env: ParamEnv<'db>,
         out: PredicateObligations<'db>,
         recursion_depth: usize,
     }
-
     impl<'a, 'db> WfPredicates<'a, 'db> {
         fn interner(&self) -> DbInterner<'db> {
             self.infcx.interner
             // Note: in fact we only permit builtin traits, not `Bar<'d>`, I
             // am looking forward to the future here.
             if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {
+                // We don't add any wf predicates corresponding to the trait ref's generic arguments
+                // which allows code like this to compile:
+                // ```rust
+                // trait Trait<T: Sized> {}
+                // fn foo(_: &dyn Trait<[u32]>) {}
+                // ```
                 let implicit_bounds = object_region_bounds(self.interner(), data);
-
                 let explicit_bound = region;
-
                 self.out.reserve(implicit_bounds.len());
                 for implicit_bound in implicit_bounds {
                     let cause = ObligationCause::new();
                         outlives,
                     ));
                 }
-
-                // We don't add any wf predicates corresponding to the trait ref's generic arguments
-                // which allows code like this to compile:
-                // ```rust
-                // trait Trait<T: Sized> {}
-                // fn foo(_: &dyn Trait<[u32]>) {}
-                // ```
             }
         }
     }
-
     impl<'a, 'db> TypeVisitor<DbInterner<'db>> for WfPredicates<'a, 'db> {
         type Result = ();
 
             panic!("predicate should not be checked for well-formedness");
         }
     }
-
     /// Given an object type like `SomeTrait + Send`, computes the lifetime
     /// bounds that must hold on the elided self type. These are derived
     /// from the declarations of `SomeTrait`, `Send`, and friends -- if