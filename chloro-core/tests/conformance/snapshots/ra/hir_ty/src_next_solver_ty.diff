COMPARISON DIFF
============================================================

Original size: 51306 bytes
Chloro size:   49977 bytes
Rustfmt size:  52438 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     db::{HirDatabase, InternedCoroutine},
     next_solver::{
-        abi::Safety,
-        interner::InternedWrapperNoDebug,
-        util::{CoroutineArgsExt, IntegerTypeExt},
+        abi::Safety, interner::InternedWrapperNoDebug, util::{CoroutineArgsExt, IntegerTypeExt},
         AdtDef, AliasTy, Binder, CallableIdWrapper, Clause, ClauseKind, ClosureIdWrapper, Const,
         CoroutineIdWrapper, FnSig, GenericArg, PolyFnSig, Region, TraitRef, TypeAliasIdWrapper,
     },
     ImplTraitId,
 };
-
 use super::{
     interned_vec_db,
     util::{FloatExt, IntegerExt},
 };
 
 pub type TyKind<'db> = rustc_type_ir::TyKind<DbInterner<'db>>;
+
 pub type FnHeader<'db> = rustc_type_ir::FnHeader<DbInterner<'db>>;
 
 #[salsa::interned(constructor = new_)]
     kind_: InternedWrapperNoDebug<WithCachedTypeInfo<TyKind<'db>>>,
 }
 
-const _: () = {
+const () = {
     const fn is_copy<T: Copy>() {}
     is_copy::<Ty<'static>>();
 };
             | TyKind::CoroutineClosure(..)
             | TyKind::Never
             | TyKind::Error(_) => true,
-
             TyKind::Str | TyKind::Slice(_) | TyKind::Dynamic(_, _) => match sizedness {
                 SizedTraitKind::Sized => false,
                 SizedTraitKind::MetaSized => true,
             },
-
             TyKind::Foreign(..) => match sizedness {
                 SizedTraitKind::Sized | SizedTraitKind::MetaSized => false,
             },
-
-            TyKind::Tuple(tys) => tys
-                .last()
-                .is_none_or(|ty| ty.has_trivial_sizedness(tcx, sizedness)),
-
-            TyKind::Adt(def, args) => def.sizedness_constraint(tcx, sizedness).is_none_or(|ty| {
-                ty.instantiate(tcx, args)
-                    .has_trivial_sizedness(tcx, sizedness)
-            }),
-
+            TyKind::Tuple(tys) => {
+                tys.last().is_none_or(|ty| ty.has_trivial_sizedness(tcx, sizedness))
+            }
+            TyKind::Adt(def, args) => def.sizedness_constraint(tcx, sizedness).is_none_or(
+                |ty| ty.instantiate(tcx, args).has_trivial_sizedness(tcx, sizedness),
+            ),
             TyKind::Alias(..) | TyKind::Param(_) | TyKind::Placeholder(..) | TyKind::Bound(..) => {
                 false
             }
-
             TyKind::Infer(InferTy::TyVar(_)) => false,
-
             TyKind::Infer(
                 InferTy::FreshTy(_) | InferTy::FreshIntTy(_) | InferTy::FreshFloatTy(_),
             ) => {
     pub fn is_trivially_pure_clone_copy(self) -> bool {
         match self.kind() {
             TyKind::Bool | TyKind::Char | TyKind::Never => true,
-
-            // These aren't even `Clone`
             TyKind::Str | TyKind::Slice(..) | TyKind::Foreign(..) | TyKind::Dynamic(..) => false,
-
             TyKind::Infer(InferTy::FloatVar(_) | InferTy::IntVar(_))
             | TyKind::Int(..)
             | TyKind::Uint(..)
             | TyKind::Float(..) => true,
-
-            // ZST which can't be named are fine.
             TyKind::FnDef(..) => true,
-
             TyKind::Array(element_ty, _len) => element_ty.is_trivially_pure_clone_copy(),
-
-            // A 100-tuple isn't "trivial", so doing this only for reasonable sizes.
             TyKind::Tuple(field_tys) => {
                 field_tys.len() <= 3 && field_tys.iter().all(Self::is_trivially_pure_clone_copy)
             }
-
             TyKind::Pat(ty, _) => ty.is_trivially_pure_clone_copy(),
-
-            // Sometimes traits aren't implemented for every ABI or arity,
-            // because we can't be generic over everything yet.
             TyKind::FnPtr(..) => false,
-
-            // Definitely absolutely not copy.
             TyKind::Ref(_, _, Mutability::Mut) => false,
-
-            // The standard library has a blanket Copy impl for shared references and raw pointers,
-            // for all unsized types.
             TyKind::Ref(_, _, Mutability::Not) | TyKind::RawPtr(..) => true,
-
             TyKind::Coroutine(..) | TyKind::CoroutineWitness(..) => false,
-
-            // Might be, but not "trivial" so just giving the safe answer.
             TyKind::Adt(..) | TyKind::Closure(..) | TyKind::CoroutineClosure(..) => false,
-
             TyKind::UnsafeBinder(_) => false,
-
-            // Needs normalization or revealing to determine, so no is the safe answer.
             TyKind::Alias(..) => false,
-
             TyKind::Param(..)
             | TyKind::Placeholder(..)
             | TyKind::Bound(..)
             | TyKind::Param(_)
             | TyKind::Placeholder(_)
             | TyKind::Bound(..) => true,
-
             TyKind::Slice(ty) => {
                 ty.is_trivially_wf(tcx) && ty.has_trivial_sizedness(tcx, SizedTraitKind::Sized)
             }
             TyKind::RawPtr(ty, _) => ty.is_trivially_wf(tcx),
-
-            TyKind::FnPtr(sig_tys, _) => sig_tys
-                .skip_binder()
-                .inputs_and_output
-                .iter()
-                .all(|ty| ty.is_trivially_wf(tcx)),
+            TyKind::FnPtr(sig_tys, _) => {
+                sig_tys.skip_binder().inputs_and_output.iter().all(|ty| ty.is_trivially_wf(tcx))
+            }
             TyKind::Ref(_, ty, _) => ty.is_global() && ty.is_trivially_wf(tcx),
-
             TyKind::Infer(infer) => match infer {
                 InferTy::TyVar(_) => false,
                 InferTy::IntVar(_) | InferTy::FloatVar(_) => true,
                 InferTy::FreshTy(_) | InferTy::FreshIntTy(_) | InferTy::FreshFloatTy(_) => true,
             },
-
             TyKind::Adt(_, _)
             | TyKind::Tuple(_)
             | TyKind::Array(..)
     }
 
     pub fn is_union(self) -> bool {
-        self.as_adt()
-            .is_some_and(|(adt, _)| matches!(adt, AdtId::UnionId(_)))
+        self.as_adt().is_some_and(|(adt, _)| matches!(adt, AdtId::UnionId(_)))
     }
 
     #[inline]
     /// unsafe.
     pub fn safe_to_unsafe_fn_ty(interner: DbInterner<'db>, sig: PolyFnSig<'db>) -> Ty<'db> {
         assert!(sig.safety().is_safe());
-        Ty::new_fn_ptr(
-            interner,
-            sig.map_bound(|sig| FnSig {
-                safety: Safety::Unsafe,
-                ..sig
-            }),
-        )
+        Ty::new_fn_ptr(interner, sig.map_bound(|sig| FnSig { safety: Safety::Unsafe, ..sig }))
     }
 
     /// Returns the type of `*ty`.
                 Some(interner.fn_sig(callable).instantiate(interner, args))
             }
             TyKind::FnPtr(sig, hdr) => Some(sig.with(hdr)),
-            TyKind::Closure(_, closure_args) => closure_args
-                .split_closure_args_untupled()
-                .closure_sig_as_fn_ptr_ty
-                .callable_sig(interner),
+            TyKind::Closure(_, closure_args) => closure_args.split_closure_args_untupled().closure_sig_as_fn_ptr_ty.callable_sig(
+                interner,
+            ),
             TyKind::CoroutineClosure(coroutine_id, args) => {
-                Some(
-                    args.as_coroutine_closure()
-                        .coroutine_closure_sig()
-                        .map_bound(|sig| {
-                            let unit_ty = Ty::new_unit(interner);
-                            let return_ty = Ty::new_coroutine(
-                                interner,
-                                coroutine_id,
-                                CoroutineArgs::new(
-                                    interner,
-                                    CoroutineArgsParts {
-                                        parent_args: args.as_coroutine_closure().parent_args(),
-                                        kind_ty: unit_ty,
-                                        resume_ty: unit_ty,
-                                        yield_ty: unit_ty,
-                                        return_ty: sig.return_ty,
-                                        // FIXME: Deduce this from the coroutine closure's upvars.
-                                        tupled_upvars_ty: unit_ty,
-                                    },
-                                )
-                                .args,
-                            );
-                            FnSig {
-                                inputs_and_output: Tys::new_from_iter(
-                                    interner,
-                                    sig.tupled_inputs_ty
-                                        .tuple_fields()
-                                        .iter()
-                                        .chain(std::iter::once(return_ty)),
-                                ),
-                                c_variadic: sig.c_variadic,
-                                safety: sig.safety,
-                                abi: sig.abi,
-                            }
-                        }),
-                )
+                Some(args.as_coroutine_closure().coroutine_closure_sig().map_bound(|sig| {
+                    let unit_ty = Ty::new_unit(interner);
+                    let return_ty = Ty::new_coroutine(
+                        interner,
+                        coroutine_id,
+                        CoroutineArgs::new(
+                            interner,
+                            CoroutineArgsParts {
+                                parent_args: args.as_coroutine_closure().parent_args(),
+                                kind_ty: unit_ty,
+                                resume_ty: unit_ty,
+                                yield_ty: unit_ty,
+                                return_ty: sig.return_ty,
+                                // FIXME: Deduce this from the coroutine closure's upvars.
+                                tupled_upvars_ty: unit_ty,
+                            },
+                        )
+                        .args,
+                    );
+                    FnSig {
+                        inputs_and_output: Tys::new_from_iter(
+                            interner,
+                            sig.tupled_inputs_ty
+                                .tuple_fields()
+                                .iter()
+                                .chain(std::iter::once(return_ty)),
+                        ),
+                        c_variadic: sig.c_variadic,
+                        safety: sig.safety,
+                        abi: sig.abi,
+                    }
+                }))
             }
             _ => None,
         }
     }
 
     pub fn dyn_trait(self) -> Option<TraitId> {
-        let TyKind::Dynamic(bounds, _) = self.kind() else {
-            return None;
-        };
+        let TyKind::Dynamic(bounds, _) = self.kind() else { return None };
         Some(bounds.principal_def_id()?.0)
     }
 
         Some(builtin)
     }
 
-    // FIXME: Should this be here?
     pub fn impl_trait_bounds(self, db: &'db dyn HirDatabase) -> Option<Vec<Clause<'db>>> {
         let interner = DbInterner::new_with(db, None, None);
 
                 match db.lookup_intern_impl_trait_id(opaque_ty.def_id.expect_opaque_ty()) {
                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {
                         db.return_type_impl_traits(func).map(|it| {
-                            let data = (*it)
-                                .as_ref()
-                                .map_bound(|rpit| &rpit.impl_traits[idx].predicates);
+                            let data =
+                                (*it).as_ref().map_bound(|rpit| &rpit.impl_traits[idx].predicates);
                             data.iter_instantiated_copied(interner, opaque_ty.args.as_slice())
                                 .collect()
                         })
                     }
                     ImplTraitId::TypeAliasImplTrait(alias, idx) => {
                         db.type_alias_impl_traits(alias).map(|it| {
-                            let data = (*it)
-                                .as_ref()
-                                .map_bound(|rpit| &rpit.impl_traits[idx].predicates);
+                            let data =
+                                (*it).as_ref().map_bound(|rpit| &rpit.impl_traits[idx].predicates);
                             data.iter_instantiated_copied(interner, opaque_ty.args.as_slice())
                                 .collect()
                         })
                 }
             }
             TyKind::Param(param) => {
-                // FIXME: We shouldn't use `param.id` here.
                 let generic_params = db.generic_params(param.id.parent());
                 let param_data = &generic_params[param.id.local_id()];
                 match param_data {
                                     _ => false,
                                 })
                                 .collect::<Vec<_>>();
-
                             Some(predicates)
                         }
                         _ => None,
                 let InternedCoroutine(owner, _) = coroutine_id.0.loc(db);
                 let krate = owner.module(db).krate();
                 if let Some(future_trait) = LangItem::Future.resolve_trait(db, krate) {
-                    // This is only used by type walking.
-                    // Parameters will be walked outside, and projection predicate is not used.
-                    // So just provide the Future trait.
                     let impl_bound = TraitRef::new(
                         interner,
                         future_trait.into(),
             TyKind::Closure(_did, ref args) => args.visit_with(visitor),
             TyKind::CoroutineClosure(_did, ref args) => args.visit_with(visitor),
             TyKind::Alias(_, ref data) => data.visit_with(visitor),
-
             TyKind::Pat(ty, pat) => {
                 try_visit!(ty.visit_with(visitor));
                 pat.visit_with(visitor)
             }
-
             TyKind::Error(guar) => guar.visit_with(visitor),
-
             TyKind::Bool
             | TyKind::Char
             | TyKind::Str
     ) -> Result<Self, F::Error> {
         folder.try_fold_ty(self)
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
         folder.fold_ty(self)
     }
             }
             TyKind::Slice(typ) => TyKind::Slice(typ.try_fold_with(folder)?),
             TyKind::Adt(tid, args) => TyKind::Adt(tid, args.try_fold_with(folder)?),
-            TyKind::Dynamic(trait_ty, region) => TyKind::Dynamic(
-                trait_ty.try_fold_with(folder)?,
-                region.try_fold_with(folder)?,
-            ),
+            TyKind::Dynamic(trait_ty, region) => {
+                TyKind::Dynamic(trait_ty.try_fold_with(folder)?, region.try_fold_with(folder)?)
+            }
             TyKind::Tuple(ts) => TyKind::Tuple(ts.try_fold_with(folder)?),
             TyKind::FnDef(def_id, args) => TyKind::FnDef(def_id, args.try_fold_with(folder)?),
             TyKind::FnPtr(sig_tys, hdr) => TyKind::FnPtr(sig_tys.try_fold_with(folder)?, hdr),
             Ty::new(folder.cx(), kind)
         })
     }
+
     fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
         self,
         folder: &mut F,
     }
 
     fn new_bound(interner: DbInterner<'db>, debruijn: DebruijnIndex, var: BoundTy) -> Self {
-        Ty::new(
-            interner,
-            TyKind::Bound(BoundVarIndexKind::Bound(debruijn), var),
-        )
+        Ty::new(interner, TyKind::Bound(BoundVarIndexKind::Bound(debruijn), var))
     }
 
     fn new_anon_bound(interner: DbInterner<'db>, debruijn: DebruijnIndex, var: BoundVar) -> Self {
             interner,
             TyKind::Bound(
                 BoundVarIndexKind::Bound(debruijn),
-                BoundTy {
-                    var,
-                    kind: BoundTyKind::Anon,
-                },
+                BoundTy { var, kind: BoundTyKind::Anon },
             ),
         )
     }
     fn new_canonical_bound(interner: DbInterner<'db>, var: BoundVar) -> Self {
         Ty::new(
             interner,
-            TyKind::Bound(
-                BoundVarIndexKind::Canonical,
-                BoundTy {
-                    var,
-                    kind: BoundTyKind::Anon,
-                },
-            ),
+            TyKind::Bound(BoundVarIndexKind::Canonical, BoundTy { var, kind: BoundTyKind::Anon }),
         )
     }
 
     }
 
     fn new_tup(interner: DbInterner<'db>, tys: &[<DbInterner<'db> as Interner>::Ty]) -> Self {
-        Ty::new(
-            interner,
-            TyKind::Tuple(Tys::new_from_iter(interner, tys.iter().cloned())),
-        )
+        Ty::new(interner, TyKind::Tuple(Tys::new_from_iter(interner, tys.iter().cloned())))
     }
 
     fn new_tup_from_iter<It, T>(interner: DbInterner<'db>, iter: It) -> T::Output
                 IntTy::I32 => Some(ClosureKind::FnOnce),
                 _ => unreachable!("cannot convert type `{:?}` to a closure kind", self),
             },
-
-            // "Bound" types appear in canonical queries when the
-            // closure type is not yet known, and `Placeholder` and `Param`
-            // may be encountered in generic `AsyncFnKindHelper` goals.
             TyKind::Bound(..) | TyKind::Placeholder(_) | TyKind::Param(_) | TyKind::Infer(_) => {
                 None
             }
-
             TyKind::Error(_) => Some(ClosureKind::Fn),
-
             _ => unreachable!("cannot convert type `{:?}` to a closure kind", self),
         }
     }
         match self.kind() {
             TyKind::Adt(adt, _) if adt.is_enum() => adt.repr().discr_type().to_ty(interner),
             TyKind::Coroutine(_, args) => args.as_coroutine().discr_ty(interner),
-
             TyKind::Param(_) | TyKind::Alias(..) | TyKind::Infer(InferTy::TyVar(_)) => {
-                /*
-                let assoc_items = tcx.associated_item_def_ids(
-                    tcx.require_lang_item(hir::LangItem::DiscriminantKind, None),
-                );
-                TyKind::new_projection_from_args(tcx, assoc_items[0], tcx.mk_args(&[self.into()]))
-                */
                 unimplemented!()
             }
-
             TyKind::Pat(ty, _) => ty.discriminant_ty(interner),
-
             TyKind::Bool
             | TyKind::Char
             | TyKind::Int(_)
             | TyKind::Infer(InferTy::IntVar(_) | InferTy::FloatVar(_)) => {
                 Ty::new(interner, TyKind::Uint(UintTy::U8))
             }
-
             TyKind::Bound(..)
             | TyKind::Placeholder(_)
             | TyKind::Infer(
     ) -> Result<Self, F::Error> {
         Ok(self)
     }
+
     fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, _folder: &mut F) -> Self {
         self
     }
     }
 
     fn new(ui: rustc_type_ir::UniverseIndex, bound: BoundTy) -> Self {
-        Placeholder {
-            universe: ui,
-            bound,
-        }
+        Placeholder { universe: ui, bound }
     }
 
     fn new_anon(ui: rustc_type_ir::UniverseIndex, var: rustc_type_ir::BoundVar) -> Self {
         Placeholder {
             universe: ui,
-            bound: BoundTy {
-                var,
-                kind: BoundTyKind::Anon,
-            },
+            bound: BoundTy { var, kind: BoundTyKind::Anon },
         }
     }
 }