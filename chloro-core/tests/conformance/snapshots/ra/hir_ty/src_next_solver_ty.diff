COMPARISON DIFF
============================================================

Original size: 51306 bytes
Chloro size:   52074 bytes
Rustfmt size:  52438 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Things related to tys in the next-trait-solver.
 
 use std::ops::ControlFlow;
 
 use hir_def::{
-    hir::generics::{TypeOrConstParamData, TypeParamProvenance},
-    lang_item::LangItem,
-    AdtId, HasModule, TypeParamId,
+    hir::generics::{TypeOrConstParamData, lang_item::LangItem, AdtId, HasModule, TypeParamId,
+    TypeParamProvenance},
 };
-use hir_def::{type_ref::Rawness, TraitId};
+use hir_def::{TraitId, type_ref::Rawness};
 use rustc_abi::{Float, Integer, Size};
-use rustc_ast_ir::{try_visit, visit::VisitorResult, Mutability};
+use rustc_ast_ir::{Mutability, try_visit, visit::VisitorResult};
 use rustc_type_ir::{
     inherent::{
-        AdtDef as _, BoundExistentialPredicates, BoundVarLike, Const as _, GenericArgs as _,
-        IntoKind, ParamLike, PlaceholderLike, Safety as _, SliceLike, Ty as _,
-    },
-    relate::Relate,
-    solve::SizedTraitKind,
-    walk::TypeWalker,
-    AliasTyKind, BoundVar, BoundVarIndexKind, ClosureKind, CoroutineArgs, CoroutineArgsParts,
-    DebruijnIndex, FlagComputation, Flags, FloatTy, FloatVid, InferTy, IntTy, IntVid, Interner,
-    TyVid, TypeFoldable, TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,
-    TypeVisitor, UintTy, Upcast, WithCachedTypeInfo,
+        AdtDef as _, relate::Relate, solve::SizedTraitKind, walk::TypeWalker,
+    AliasTyKind, BoundExistentialPredicates, BoundVar, BoundVarIndexKind, BoundVarLike,
+    ClosureKind, Const as _, CoroutineArgs, CoroutineArgsParts, DebruijnIndex, FlagComputation,
+    Flags, FloatTy, FloatVid, GenericArgs as _, InferTy, IntTy, IntVid, Interner, IntoKind,
+    ParamLike, PlaceholderLike, Safety as _, SliceLike, Ty as _, TyVid, TypeFoldable,
+    TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor, UintTy,
+    Upcast, WithCachedTypeInfo, },
 };
 
 use crate::{
-    db::{HirDatabase, InternedCoroutine},
-    next_solver::{
-        abi::Safety,
-        interner::InternedWrapperNoDebug,
-        util::{CoroutineArgsExt, IntegerTypeExt},
-        AdtDef, AliasTy, Binder, CallableIdWrapper, Clause, ClauseKind, ClosureIdWrapper, Const,
-        CoroutineIdWrapper, FnSig, GenericArg, PolyFnSig, Region, TraitRef, TypeAliasIdWrapper,
-    },
-    ImplTraitId,
+    abi::Safety, db::{HirDatabase, interner::InternedWrapperNoDebug, next_solver::{
+        AdtDef,
+    util::{CoroutineArgsExt, AliasTy, Binder, CallableIdWrapper, Clause, ClauseKind,
+    ClosureIdWrapper, Const, CoroutineIdWrapper, FnSig, GenericArg, ImplTraitId, IntegerTypeExt},
+    InternedCoroutine}, PolyFnSig, Region, TraitRef, TypeAliasIdWrapper, },
 };
-
 use super::{
-    interned_vec_db,
-    util::{FloatExt, IntegerExt},
-    BoundVarKind, DbInterner, GenericArgs, Placeholder, SolverDefId,
+    interned_vec_db, util::{FloatExt, BoundVarKind, DbInterner, GenericArgs, IntegerExt},
+    Placeholder, SolverDefId,
 };
 
 pub type TyKind<'db> = rustc_type_ir::TyKind<DbInterner<'db>>;
+
 pub type FnHeader<'db> = rustc_type_ir::FnHeader<DbInterner<'db>>;
 
 #[salsa::interned(constructor = new_)]
     kind_: InternedWrapperNoDebug<WithCachedTypeInfo<TyKind<'db>>>,
 }
 
-const _: () = {
+const () = {
     const fn is_copy<T: Copy>() {}
     is_copy::<Ty<'static>>();
 };
 
 impl<'db> Ty<'db> {
-    pub fn new(interner: DbInterner<'db>, kind: TyKind<'db>) -> Self {
+    pub fn new(
+        interner: DbInterner<'db>,
+        kind: TyKind<'db>,
+    ) -> Self {
         let flags = FlagComputation::for_kind(&kind);
         let cached = WithCachedTypeInfo {
             internee: kind,
         })
     }
 
-    pub fn new_adt(interner: DbInterner<'db>, adt_id: AdtId, args: GenericArgs<'db>) -> Self {
+    pub fn new_adt(
+        interner: DbInterner<'db>,
+        adt_id: AdtId,
+        args: GenericArgs<'db>,
+    ) -> Self {
         Ty::new(interner, TyKind::Adt(AdtDef::new(adt_id, interner), args))
     }
 
-    pub fn new_param(interner: DbInterner<'db>, id: TypeParamId, index: u32) -> Self {
+    pub fn new_param(
+        interner: DbInterner<'db>,
+        id: TypeParamId,
+        index: u32,
+    ) -> Self {
         Ty::new(interner, TyKind::Param(ParamTy { id, index }))
     }
 
-    pub fn new_placeholder(interner: DbInterner<'db>, placeholder: PlaceholderTy) -> Self {
+    pub fn new_placeholder(
+        interner: DbInterner<'db>,
+        placeholder: PlaceholderTy,
+    ) -> Self {
         Ty::new(interner, TyKind::Placeholder(placeholder))
     }
 
-    pub fn new_infer(interner: DbInterner<'db>, infer: InferTy) -> Self {
+    pub fn new_infer(
+        interner: DbInterner<'db>,
+        infer: InferTy,
+    ) -> Self {
         Ty::new(interner, TyKind::Infer(infer))
     }
 
-    pub fn new_int_var(interner: DbInterner<'db>, v: IntVid) -> Self {
+    pub fn new_int_var(
+        interner: DbInterner<'db>,
+        v: IntVid,
+    ) -> Self {
         Ty::new_infer(interner, InferTy::IntVar(v))
     }
 
-    pub fn new_float_var(interner: DbInterner<'db>, v: FloatVid) -> Self {
+    pub fn new_float_var(
+        interner: DbInterner<'db>,
+        v: FloatVid,
+    ) -> Self {
         Ty::new_infer(interner, InferTy::FloatVar(v))
     }
 
-    pub fn new_int(interner: DbInterner<'db>, i: IntTy) -> Self {
+    pub fn new_int(
+        interner: DbInterner<'db>,
+        i: IntTy,
+    ) -> Self {
         Ty::new(interner, TyKind::Int(i))
     }
 
-    pub fn new_uint(interner: DbInterner<'db>, ui: UintTy) -> Self {
+    pub fn new_uint(
+        interner: DbInterner<'db>,
+        ui: UintTy,
+    ) -> Self {
         Ty::new(interner, TyKind::Uint(ui))
     }
 
-    pub fn new_float(interner: DbInterner<'db>, f: FloatTy) -> Self {
+    pub fn new_float(
+        interner: DbInterner<'db>,
+        f: FloatTy,
+    ) -> Self {
         Ty::new(interner, TyKind::Float(f))
     }
 
-    pub fn new_fresh(interner: DbInterner<'db>, n: u32) -> Self {
+    pub fn new_fresh(
+        interner: DbInterner<'db>,
+        n: u32,
+    ) -> Self {
         Ty::new_infer(interner, InferTy::FreshTy(n))
     }
 
-    pub fn new_fresh_int(interner: DbInterner<'db>, n: u32) -> Self {
+    pub fn new_fresh_int(
+        interner: DbInterner<'db>,
+        n: u32,
+    ) -> Self {
         Ty::new_infer(interner, InferTy::FreshIntTy(n))
     }
 
-    pub fn new_fresh_float(interner: DbInterner<'db>, n: u32) -> Self {
+    pub fn new_fresh_float(
+        interner: DbInterner<'db>,
+        n: u32,
+    ) -> Self {
         Ty::new_infer(interner, InferTy::FreshFloatTy(n))
     }
 
     }
 
     /// Returns the `Size` for primitive types (bool, uint, int, char, float).
-    pub fn primitive_size(self, interner: DbInterner<'db>) -> Size {
+    pub fn primitive_size(
+        self,
+        interner: DbInterner<'db>,
+    ) -> Size {
         match self.kind() {
             TyKind::Bool => Size::from_bytes(1),
             TyKind::Char => Size::from_bytes(4),
         }
     }
 
-    pub fn int_size_and_signed(self, interner: DbInterner<'db>) -> (Size, bool) {
+    pub fn int_size_and_signed(
+        self,
+        interner: DbInterner<'db>,
+    ) -> (Size, bool) {
         match self.kind() {
             TyKind::Int(ity) => (Integer::from_int_ty(&interner, ity).size(), true),
             TyKind::Uint(uty) => (Integer::from_uint_ty(&interner, uty).size(), false),
     /// such a bound obviously never can be called, but that doesn't mean it shouldn't typecheck.
     /// This is why this method doesn't return `Option<bool>`.
     #[tracing::instrument(skip(tcx), level = "debug")]
-    pub fn has_trivial_sizedness(self, tcx: DbInterner<'db>, sizedness: SizedTraitKind) -> bool {
+    pub fn has_trivial_sizedness(
+        self,
+        tcx: DbInterner<'db>,
+        sizedness: SizedTraitKind,
+    ) -> bool {
         match self.kind() {
             TyKind::Infer(InferTy::IntVar(_) | InferTy::FloatVar(_))
             | TyKind::Uint(_)
                 SizedTraitKind::Sized | SizedTraitKind::MetaSized => false,
             },
 
-            TyKind::Tuple(tys) => tys
-                .last()
-                .is_none_or(|ty| ty.has_trivial_sizedness(tcx, sizedness)),
+            TyKind::Tuple(tys) => {
+                tys.last().is_none_or(|ty| ty.has_trivial_sizedness(tcx, sizedness))
+            }
 
-            TyKind::Adt(def, args) => def.sizedness_constraint(tcx, sizedness).is_none_or(|ty| {
-                ty.instantiate(tcx, args)
-                    .has_trivial_sizedness(tcx, sizedness)
-            }),
+            TyKind::Adt(def, args) => def
+                .sizedness_constraint(tcx, sizedness)
+                .is_none_or(|ty| ty.instantiate(tcx, args).has_trivial_sizedness(tcx, sizedness)),
 
             TyKind::Alias(..) | TyKind::Param(_) | TyKind::Placeholder(..) | TyKind::Bound(..) => {
                 false
         }
     }
 
-    pub fn is_trivially_wf(self, tcx: DbInterner<'db>) -> bool {
+    pub fn is_trivially_wf(
+        self,
+        tcx: DbInterner<'db>,
+    ) -> bool {
         match self.kind() {
             TyKind::Bool
             | TyKind::Char
             }
             TyKind::RawPtr(ty, _) => ty.is_trivially_wf(tcx),
 
-            TyKind::FnPtr(sig_tys, _) => sig_tys
-                .skip_binder()
-                .inputs_and_output
-                .iter()
-                .all(|ty| ty.is_trivially_wf(tcx)),
+            TyKind::FnPtr(sig_tys, _) => {
+                sig_tys.skip_binder().inputs_and_output.iter().all(|ty| ty.is_trivially_wf(tcx))
+            }
             TyKind::Ref(_, ty, _) => ty.is_global() && ty.is_trivially_wf(tcx),
 
             TyKind::Infer(infer) => match infer {
     }
 
     pub fn is_union(self) -> bool {
-        self.as_adt()
-            .is_some_and(|(adt, _)| matches!(adt, AdtId::UnionId(_)))
+        self.as_adt().is_some_and(|(adt, _)| matches!(adt, AdtId::UnionId(_)))
     }
 
     #[inline]
     /// Given a `fn` type, returns an equivalent `unsafe fn` type;
     /// that is, a `fn` type that is equivalent in every way for being
     /// unsafe.
-    pub fn safe_to_unsafe_fn_ty(interner: DbInterner<'db>, sig: PolyFnSig<'db>) -> Ty<'db> {
+    pub fn safe_to_unsafe_fn_ty(
+        interner: DbInterner<'db>,
+        sig: PolyFnSig<'db>,
+    ) -> Ty<'db> {
         assert!(sig.safety().is_safe());
-        Ty::new_fn_ptr(
-            interner,
-            sig.map_bound(|sig| FnSig {
-                safety: Safety::Unsafe,
-                ..sig
-            }),
-        )
+        Ty::new_fn_ptr(interner, sig.map_bound(|sig| FnSig { safety: Safety::Unsafe, ..sig }))
     }
 
     /// Returns the type of `*ty`.
     ///
     /// The parameter `explicit` indicates if this is an *explicit* dereference.
     /// Some types -- notably raw ptrs -- can only be dereferenced explicitly.
-    pub fn builtin_deref(self, db: &dyn HirDatabase, explicit: bool) -> Option<Ty<'db>> {
+    pub fn builtin_deref(
+        self,
+        db: &dyn HirDatabase,
+        explicit: bool,
+    ) -> Option<Ty<'db>> {
         match self.kind() {
             TyKind::Adt(adt, substs) if crate::lang_items::is_box(db, adt.def_id().0) => {
                 Some(substs.as_slice()[0].expect_ty())
         references_non_lt_error(&self)
     }
 
-    pub fn callable_sig(self, interner: DbInterner<'db>) -> Option<Binder<'db, FnSig<'db>>> {
+    pub fn callable_sig(
+        self,
+        interner: DbInterner<'db>,
+    ) -> Option<Binder<'db, FnSig<'db>>> {
         match self.kind() {
             TyKind::FnDef(callable, args) => {
                 Some(interner.fn_sig(callable).instantiate(interner, args))
                 .closure_sig_as_fn_ptr_ty
                 .callable_sig(interner),
             TyKind::CoroutineClosure(coroutine_id, args) => {
-                Some(
-                    args.as_coroutine_closure()
-                        .coroutine_closure_sig()
-                        .map_bound(|sig| {
-                            let unit_ty = Ty::new_unit(interner);
-                            let return_ty = Ty::new_coroutine(
-                                interner,
-                                coroutine_id,
-                                CoroutineArgs::new(
-                                    interner,
-                                    CoroutineArgsParts {
-                                        parent_args: args.as_coroutine_closure().parent_args(),
-                                        kind_ty: unit_ty,
-                                        resume_ty: unit_ty,
-                                        yield_ty: unit_ty,
-                                        return_ty: sig.return_ty,
-                                        // FIXME: Deduce this from the coroutine closure's upvars.
-                                        tupled_upvars_ty: unit_ty,
-                                    },
-                                )
-                                .args,
-                            );
-                            FnSig {
-                                inputs_and_output: Tys::new_from_iter(
-                                    interner,
-                                    sig.tupled_inputs_ty
-                                        .tuple_fields()
-                                        .iter()
-                                        .chain(std::iter::once(return_ty)),
-                                ),
-                                c_variadic: sig.c_variadic,
-                                safety: sig.safety,
-                                abi: sig.abi,
-                            }
-                        }),
-                )
+                Some(args.as_coroutine_closure().coroutine_closure_sig().map_bound(|sig| {
+                    let unit_ty = Ty::new_unit(interner);
+                    let return_ty = Ty::new_coroutine(
+                        interner,
+                        coroutine_id,
+                        CoroutineArgs::new(
+                            interner,
+                            CoroutineArgsParts {
+                                parent_args: args.as_coroutine_closure().parent_args(),
+                                kind_ty: unit_ty,
+                                resume_ty: unit_ty,
+                                yield_ty: unit_ty,
+                                return_ty: sig.return_ty,
+                                // FIXME: Deduce this from the coroutine closure's upvars.
+                                tupled_upvars_ty: unit_ty,
+                            },
+                        )
+                        .args,
+                    );
+                    FnSig {
+                        inputs_and_output: Tys::new_from_iter(
+                            interner,
+                            sig.tupled_inputs_ty
+                                .tuple_fields()
+                                .iter()
+                                .chain(std::iter::once(return_ty)),
+                        ),
+                        c_variadic: sig.c_variadic,
+                        safety: sig.safety,
+                        abi: sig.abi,
+                    }
+                }))
             }
             _ => None,
         }
     }
 
     pub fn dyn_trait(self) -> Option<TraitId> {
-        let TyKind::Dynamic(bounds, _) = self.kind() else {
-            return None;
-        };
+        let TyKind::Dynamic(bounds, _) = self.kind() else { return None };
         Some(bounds.principal_def_id()?.0)
     }
 
     ///
     /// This needs to be called for every type that may contain infer vars and is yielded to outside inference,
     /// as things other than inference do not expect to see infer vars.
-    pub fn replace_infer_with_error(self, interner: DbInterner<'db>) -> Ty<'db> {
-        self.fold_with(
-            &mut crate::next_solver::infer::resolve::ReplaceInferWithError::new(interner),
-        )
+    pub fn replace_infer_with_error(
+        self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db> {
+        self.fold_with(&mut crate::next_solver::infer::resolve::ReplaceInferWithError::new(
+            interner,
+        ))
     }
 
     pub fn from_builtin_type(
         Some(builtin)
     }
 
-    // FIXME: Should this be here?
-    pub fn impl_trait_bounds(self, db: &'db dyn HirDatabase) -> Option<Vec<Clause<'db>>> {
+    pub fn impl_trait_bounds(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<Vec<Clause<'db>>> {
         let interner = DbInterner::new_with(db, None, None);
-
         match self.kind() {
             TyKind::Alias(AliasTyKind::Opaque, opaque_ty) => {
                 match db.lookup_intern_impl_trait_id(opaque_ty.def_id.expect_opaque_ty()) {
                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {
                         db.return_type_impl_traits(func).map(|it| {
-                            let data = (*it)
-                                .as_ref()
-                                .map_bound(|rpit| &rpit.impl_traits[idx].predicates);
+                            let data =
+                                (*it).as_ref().map_bound(|rpit| &rpit.impl_traits[idx].predicates);
                             data.iter_instantiated_copied(interner, opaque_ty.args.as_slice())
                                 .collect()
                         })
                     }
                     ImplTraitId::TypeAliasImplTrait(alias, idx) => {
                         db.type_alias_impl_traits(alias).map(|it| {
-                            let data = (*it)
-                                .as_ref()
-                                .map_bound(|rpit| &rpit.impl_traits[idx].predicates);
+                            let data =
+                                (*it).as_ref().map_bound(|rpit| &rpit.impl_traits[idx].predicates);
                             data.iter_instantiated_copied(interner, opaque_ty.args.as_slice())
                                 .collect()
                         })
     }
 
     /// FIXME: Get rid of this, it's not a good abstraction
-    pub fn equals_ctor(self, other: Ty<'db>) -> bool {
+    pub fn equals_ctor(
+        self,
+        other: Ty<'db>,
+    ) -> bool {
         match (self.kind(), other.kind()) {
             (TyKind::Adt(adt, ..), TyKind::Adt(adt2, ..)) => adt.def_id() == adt2.def_id(),
             (TyKind::Slice(_), TyKind::Slice(_)) | (TyKind::Array(_, _), TyKind::Array(_, _)) => {
 impl<'db> TypeVisitor<DbInterner<'db>> for ReferencesNonLifetimeError {
     type Result = ControlFlow<()>;
 
-    fn visit_ty(&mut self, ty: Ty<'db>) -> Self::Result {
-        if ty.is_ty_error() {
-            ControlFlow::Break(())
-        } else {
-            ty.super_visit_with(self)
-        }
+    fn visit_ty(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Self::Result {
+        if ty.is_ty_error() { ControlFlow::Break(()) } else { ty.super_visit_with(self) }
     }
 
-    fn visit_const(&mut self, c: Const<'db>) -> Self::Result {
-        if c.is_ct_error() {
-            ControlFlow::Break(())
-        } else {
-            c.super_visit_with(self)
-        }
+    fn visit_const(
+        &mut self,
+        c: Const<'db>,
+    ) -> Self::Result {
+        if c.is_ct_error() { ControlFlow::Break(()) } else { c.super_visit_with(self) }
     }
 }
 
 impl<'db> std::fmt::Debug for Ty<'db> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         self.inner().internee.fmt(f)
     }
 }
 
 impl<'db> std::fmt::Debug for InternedWrapperNoDebug<WithCachedTypeInfo<TyKind<'db>>> {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         self.0.internee.fmt(f)
     }
 }
     ) -> Result<Self, F::Error> {
         folder.try_fold_ty(self)
     }
-    fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, folder: &mut F) -> Self {
+
+    fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
+        self,
+        folder: &mut F,
+    ) -> Self {
         folder.fold_ty(self)
     }
 }
             }
             TyKind::Slice(typ) => TyKind::Slice(typ.try_fold_with(folder)?),
             TyKind::Adt(tid, args) => TyKind::Adt(tid, args.try_fold_with(folder)?),
-            TyKind::Dynamic(trait_ty, region) => TyKind::Dynamic(
-                trait_ty.try_fold_with(folder)?,
-                region.try_fold_with(folder)?,
-            ),
+            TyKind::Dynamic(trait_ty, region) => {
+                TyKind::Dynamic(trait_ty.try_fold_with(folder)?, region.try_fold_with(folder)?)
+            }
             TyKind::Tuple(ts) => TyKind::Tuple(ts.try_fold_with(folder)?),
             TyKind::FnDef(def_id, args) => TyKind::FnDef(def_id, args.try_fold_with(folder)?),
             TyKind::FnPtr(sig_tys, hdr) => TyKind::FnPtr(sig_tys.try_fold_with(folder)?, hdr),
             | TyKind::Never
             | TyKind::Foreign(..) => return Ok(self),
         };
-
-        Ok(if self.kind() == kind {
-            self
-        } else {
-            Ty::new(folder.cx(), kind)
-        })
+        Ok(if self.kind() == kind { self } else { Ty::new(folder.cx(), kind) })
     }
+
     fn super_fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
         self,
         folder: &mut F,
             | TyKind::Never
             | TyKind::Foreign(..) => return self,
         };
-
-        if self.kind() == kind {
-            self
-        } else {
-            Ty::new(folder.cx(), kind)
-        }
+        if self.kind() == kind { self } else { Ty::new(folder.cx(), kind) }
     }
 }
 
         Ty::new(interner, TyKind::Uint(rustc_type_ir::UintTy::Usize))
     }
 
-    fn new_infer(interner: DbInterner<'db>, var: rustc_type_ir::InferTy) -> Self {
+    fn new_infer(
+        interner: DbInterner<'db>,
+        var: rustc_type_ir::InferTy,
+    ) -> Self {
         Ty::new(interner, TyKind::Infer(var))
     }
 
-    fn new_var(interner: DbInterner<'db>, var: rustc_type_ir::TyVid) -> Self {
+    fn new_var(
+        interner: DbInterner<'db>,
+        var: rustc_type_ir::TyVid,
+    ) -> Self {
         Ty::new(interner, TyKind::Infer(rustc_type_ir::InferTy::TyVar(var)))
     }
 
-    fn new_param(interner: DbInterner<'db>, param: ParamTy) -> Self {
+    fn new_param(
+        interner: DbInterner<'db>,
+        param: ParamTy,
+    ) -> Self {
         Ty::new(interner, TyKind::Param(param))
     }
 
-    fn new_placeholder(interner: DbInterner<'db>, param: PlaceholderTy) -> Self {
+    fn new_placeholder(
+        interner: DbInterner<'db>,
+        param: PlaceholderTy,
+    ) -> Self {
         Ty::new(interner, TyKind::Placeholder(param))
     }
 
-    fn new_bound(interner: DbInterner<'db>, debruijn: DebruijnIndex, var: BoundTy) -> Self {
-        Ty::new(
-            interner,
-            TyKind::Bound(BoundVarIndexKind::Bound(debruijn), var),
-        )
+    fn new_bound(
+        interner: DbInterner<'db>,
+        debruijn: DebruijnIndex,
+        var: BoundTy,
+    ) -> Self {
+        Ty::new(interner, TyKind::Bound(BoundVarIndexKind::Bound(debruijn), var))
     }
 
-    fn new_anon_bound(interner: DbInterner<'db>, debruijn: DebruijnIndex, var: BoundVar) -> Self {
+    fn new_anon_bound(
+        interner: DbInterner<'db>,
+        debruijn: DebruijnIndex,
+        var: BoundVar,
+    ) -> Self {
         Ty::new(
             interner,
             TyKind::Bound(
                 BoundVarIndexKind::Bound(debruijn),
-                BoundTy {
-                    var,
-                    kind: BoundTyKind::Anon,
-                },
+                BoundTy { var, kind: BoundTyKind::Anon },
             ),
         )
     }
 
-    fn new_canonical_bound(interner: DbInterner<'db>, var: BoundVar) -> Self {
+    fn new_canonical_bound(
+        interner: DbInterner<'db>,
+        var: BoundVar,
+    ) -> Self {
         Ty::new(
             interner,
-            TyKind::Bound(
-                BoundVarIndexKind::Canonical,
-                BoundTy {
-                    var,
-                    kind: BoundTyKind::Anon,
-                },
-            ),
+            TyKind::Bound(BoundVarIndexKind::Canonical, BoundTy { var, kind: BoundTyKind::Anon }),
         )
     }
 
-    fn new_alias(interner: DbInterner<'db>, kind: AliasTyKind, alias_ty: AliasTy<'db>) -> Self {
+    fn new_alias(
+        interner: DbInterner<'db>,
+        kind: AliasTyKind,
+        alias_ty: AliasTy<'db>,
+    ) -> Self {
         Ty::new(interner, TyKind::Alias(kind, alias_ty))
     }
 
-    fn new_error(interner: DbInterner<'db>, guar: ErrorGuaranteed) -> Self {
+    fn new_error(
+        interner: DbInterner<'db>,
+        guar: ErrorGuaranteed,
+    ) -> Self {
         Ty::new(interner, TyKind::Error(guar))
     }
 
         Ty::new(interner, TyKind::Adt(adt_def, args))
     }
 
-    fn new_foreign(interner: DbInterner<'db>, def_id: TypeAliasIdWrapper) -> Self {
+    fn new_foreign(
+        interner: DbInterner<'db>,
+        def_id: TypeAliasIdWrapper,
+    ) -> Self {
         Ty::new(interner, TyKind::Foreign(def_id))
     }
 
         Ty::new_coroutine_witness(interner, def_id, coroutine_args)
     }
 
-    fn new_ptr(interner: DbInterner<'db>, ty: Self, mutbl: rustc_ast_ir::Mutability) -> Self {
+    fn new_ptr(
+        interner: DbInterner<'db>,
+        ty: Self,
+        mutbl: rustc_ast_ir::Mutability,
+    ) -> Self {
         Ty::new(interner, TyKind::RawPtr(ty, mutbl))
     }
 
         Ty::new(interner, TyKind::Array(ty, len))
     }
 
-    fn new_slice(interner: DbInterner<'db>, ty: Self) -> Self {
+    fn new_slice(
+        interner: DbInterner<'db>,
+        ty: Self,
+    ) -> Self {
         Ty::new(interner, TyKind::Slice(ty))
     }
 
-    fn new_tup(interner: DbInterner<'db>, tys: &[<DbInterner<'db> as Interner>::Ty]) -> Self {
-        Ty::new(
-            interner,
-            TyKind::Tuple(Tys::new_from_iter(interner, tys.iter().cloned())),
-        )
+    fn new_tup(
+        interner: DbInterner<'db>,
+        tys: &[<DbInterner<'db> as Interner>::Ty],
+    ) -> Self {
+        Ty::new(interner, TyKind::Tuple(Tys::new_from_iter(interner, tys.iter().cloned())))
     }
 
-    fn new_tup_from_iter<It, T>(interner: DbInterner<'db>, iter: It) -> T::Output
+    fn new_tup_from_iter<It, T>(
+        interner: DbInterner<'db>,
+        iter: It,
+    ) -> T::Output
     where
         It: Iterator<Item = T>,
-        T: rustc_type_ir::CollectAndApply<Self, Self>,
-    {
+        T: rustc_type_ir::CollectAndApply<Self, Self>, {
         T::collect_and_apply(iter, |ts| Ty::new_tup(interner, ts))
     }
 
         }
     }
 
-    fn from_closure_kind(interner: DbInterner<'db>, kind: rustc_type_ir::ClosureKind) -> Self {
+    fn from_closure_kind(
+        interner: DbInterner<'db>,
+        kind: rustc_type_ir::ClosureKind,
+    ) -> Self {
         match kind {
             ClosureKind::Fn => Ty::new(interner, TyKind::Int(IntTy::I8)),
             ClosureKind::FnMut => Ty::new(interner, TyKind::Int(IntTy::I16)),
         false
     }
 
-    fn discriminant_ty(self, interner: DbInterner<'db>) -> <DbInterner<'db> as Interner>::Ty {
+    fn discriminant_ty(
+        self,
+        interner: DbInterner<'db>,
+    ) -> <DbInterner<'db> as Interner>::Ty {
         match self.kind() {
             TyKind::Adt(adt, _) if adt.is_enum() => adt.repr().discr_type().to_ty(interner),
             TyKind::Coroutine(_, args) => args.as_coroutine().discr_ty(interner),
         }
     }
 }
-
-interned_vec_db!(Tys, Ty);
-
 impl<'db> Tys<'db> {
     pub fn inputs(&self) -> &[Ty<'db>] {
         self.as_slice().split_last().unwrap().1
 
 #[derive(Copy, Clone, PartialEq, Eq, Hash)]
 pub struct ParamTy {
-    // FIXME: I'm not pleased with this. Ideally a `Param` should only know its index - the defining item
-    // is known from the `EarlyBinder`. This should also be beneficial for memory usage. But code currently
-    // assumes it can get the definition from `Param` alone - so that's what we got.
     pub id: TypeParamId,
     pub index: u32,
 }
 
 impl ParamTy {
-    pub fn to_ty<'db>(self, interner: DbInterner<'db>) -> Ty<'db> {
+    pub fn to_ty<'db>(
+        self,
+        interner: DbInterner<'db>,
+    ) -> Ty<'db> {
         Ty::new_param(interner, self.id, self.index)
     }
 }
 
 impl std::fmt::Debug for ParamTy {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         write!(f, "#{}", self.index)
     }
 }
 #[derive(Copy, Clone, PartialEq, Eq, Hash)]
 pub struct BoundTy {
     pub var: BoundVar,
-    // FIXME: This is for diagnostics in rustc, do we really need it?
     pub kind: BoundTyKind,
 }
 
 impl std::fmt::Debug for BoundTy {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         match self.kind {
             BoundTyKind::Anon => write!(f, "{:?}", self.var),
             BoundTyKind::Param(def_id) => write!(f, "{def_id:?}"),
     ) -> Result<Self, F::Error> {
         Ok(self)
     }
-    fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(self, _folder: &mut F) -> Self {
+
+    fn fold_with<F: rustc_type_ir::TypeFolder<DbInterner<'db>>>(
+        self,
+        _folder: &mut F,
+    ) -> Self {
         self
     }
 }
         self.var
     }
 
-    fn assert_eq(self, var: BoundVarKind) {
+    fn assert_eq(
+        self,
+        var: BoundVarKind,
+    ) {
         assert_eq!(self.kind, var.expect_ty())
     }
 }
         self.bound.var
     }
 
-    fn with_updated_universe(self, ui: rustc_type_ir::UniverseIndex) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: self.bound,
-        }
+    fn with_updated_universe(
+        self,
+        ui: rustc_type_ir::UniverseIndex,
+    ) -> Self {
+        Placeholder { universe: ui, bound: self.bound }
     }
 
-    fn new(ui: rustc_type_ir::UniverseIndex, bound: BoundTy) -> Self {
-        Placeholder {
-            universe: ui,
-            bound,
-        }
+    fn new(
+        ui: rustc_type_ir::UniverseIndex,
+        bound: BoundTy,
+    ) -> Self {
+        Placeholder { universe: ui, bound }
     }
 
-    fn new_anon(ui: rustc_type_ir::UniverseIndex, var: rustc_type_ir::BoundVar) -> Self {
-        Placeholder {
-            universe: ui,
-            bound: BoundTy {
-                var,
-                kind: BoundTyKind::Anon,
-            },
-        }
+    fn new_anon(
+        ui: rustc_type_ir::UniverseIndex,
+        var: rustc_type_ir::BoundVar,
+    ) -> Self {
+        Placeholder { universe: ui, bound: BoundTy { var, kind: BoundTyKind::Anon } }
     }
 }