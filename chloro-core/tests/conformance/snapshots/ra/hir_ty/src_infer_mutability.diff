COMPARISON DIFF
============================================================

Original size: 12638 bytes
Chloro size:   12769 bytes
Rustfmt size:  12638 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::next_solver::infer::traits::{Obligation, ObligationCause};
 use crate::next_solver::{GenericArgs, TraitRef};
 use crate::{
-    Adjust, Adjustment, AutoBorrow, OverloadedDeref,
     infer::{Expectation, InferenceContext, expr::ExprIsRead},
     lower::lower_mutability,
     next_solver::TyKind,
+    Adjust, Adjustment, AutoBorrow, OverloadedDeref,
 };
 
 impl<'db> InferenceContext<'_, 'db> {
         self.infer_mut_expr(self.body.body_expr, Mutability::Not);
     }
 
-    fn infer_mut_expr(&mut self, tgt_expr: ExprId, mut mutability: Mutability) {
+    fn infer_mut_expr(
+        &mut self,
+        tgt_expr: ExprId,
+        mut mutability: Mutability,
+    ) {
         if let Some(adjustments) = self.result.expr_adjustments.get_mut(&tgt_expr) {
             for adj in adjustments.iter_mut().rev() {
                 match &mut adj.kind {
         self.infer_mut_expr_without_adjust(tgt_expr, mutability);
     }
 
-    fn infer_mut_expr_without_adjust(&mut self, tgt_expr: ExprId, mutability: Mutability) {
+    fn infer_mut_expr_without_adjust(
+        &mut self,
+        tgt_expr: ExprId,
+        mutability: Mutability,
+    ) {
         match &self.body[tgt_expr] {
             Expr::Missing => (),
             Expr::InlineAsm(e) => {
         }
     }
 
-    fn infer_mut_not_expr_iter(&mut self, exprs: impl Iterator<Item = ExprId>) {
+    fn infer_mut_not_expr_iter(
+        &mut self,
+        exprs: impl Iterator<Item = ExprId>,
+    ) {
         for expr in exprs {
             self.infer_mut_expr(expr, Mutability::Not);
         }
     }
 
-    fn pat_iter_bound_mutability(&self, mut pat: impl Iterator<Item = PatId>) -> Mutability {
+    fn pat_iter_bound_mutability(
+        &self,
+        mut pat: impl Iterator<Item = PatId>,
+    ) -> Mutability {
         if pat.any(|p| self.pat_bound_mutability(p) == Mutability::Mut) {
             Mutability::Mut
         } else {
     /// Checks if the pat contains a `ref mut` binding. Such paths makes the context of bounded expressions
     /// mutable. For example in `let (ref mut x0, ref x1) = *it;` we need to use `DerefMut` for `*it` but in
     /// `let (ref x0, ref x1) = *it;` we should use `Deref`.
-    fn pat_bound_mutability(&self, pat: PatId) -> Mutability {
+    fn pat_bound_mutability(
+        &self,
+        pat: PatId,
+    ) -> Mutability {
         let mut r = Mutability::Not;
         self.body.walk_bindings_in_pat(pat, |b| {
             if self.body[b].mode == BindingAnnotation::RefMut {