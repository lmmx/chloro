COMPARISON DIFF
============================================================

Original size: 16114 bytes
Chloro size:   16105 bytes
Rustfmt size:  16341 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     lower::LifetimeElisionKind,
     method_resolution::{self, VisibleFromModule},
     next_solver::{
-        infer::traits::{Obligation, ObligationCause},
-        GenericArg, GenericArgs, TraitRef, Ty,
+        infer::traits::{Obligation, ObligationCause}, GenericArg, GenericArgs, TraitRef, Ty,
     },
     InferenceDiagnostic, ValueTyDefId,
 };
-
 use super::{ExprOrPatId, InferenceContext, InferenceTyDiagnosticSource};
 
 impl<'db> InferenceContext<'_, 'db> {
 
         self.add_required_obligations_for_value_path(generic_def, args);
 
-        let ty = self
-            .db
-            .value_ty(value_def)?
-            .instantiate(self.interner(), args);
+        let ty = self.db.value_ty(value_def)?.instantiate(self.interner(), args);
         let ty = self.process_remote_user_written_ty(ty);
         Some(ty)
     }
                 };
             }
             ValueNs::GenericParam(it) => {
-                return Some(ValuePathResolution::NonGeneric(
-                    self.db.const_param_ty_ns(it),
-                ));
+                return Some(ValuePathResolution::NonGeneric(self.db.const_param_ty_ns(it)));
             }
         };
 
         let substs = GenericArgs::fill_rest(
             self.interner(),
             generic_def.into(),
-            self_subst
-                .iter()
-                .flat_map(|it| it.iter())
-                .chain(substs.iter().skip(parent_substs_len)),
+            self_subst.iter().flat_map(|it| it.iter()).chain(substs.iter().skip(parent_substs_len)),
             |_, id, _| GenericArg::error_from_id(self.interner(), id),
         );
 
-        Some(ValuePathResolution::GenericDef(
-            value_def,
-            generic_def,
-            substs,
-        ))
+        Some(ValuePathResolution::GenericDef(value_def, generic_def, substs))
     }
 
     pub(super) fn resolve_value_path_inner(
             let (ty, _) = path_ctx.lower_ty_relative_path(ty, orig_ns, true);
             drop_ctx(ctx, no_diagnostics);
             let ty = self.table.process_user_written_ty(ty);
-            self.resolve_ty_assoc_item(ty, last.name, id)
-                .map(|(it, substs)| (it, Some(substs)))?
+            self.resolve_ty_assoc_item(ty, last.name, id).map(|(it, substs)| (it, Some(substs)))?
         } else {
             let hygiene = self.body.expr_or_pat_path_hygiene(id);
             // FIXME: report error, unresolved first path segment
         };
 
         if let ItemContainerId::TraitId(trait_) = container {
-            let parent_len = generics(self.db, def)
-                .parent_generics()
-                .map_or(0, |g| g.len_self());
+            let parent_len = generics(self.db, def).parent_generics().map_or(0, |g| g.len_self());
             let parent_subst = GenericArgs::new_from_iter(
                 interner,
                 subst.as_slice()[..parent_len].iter().copied(),
         id: ExprOrPatId,
     ) -> Option<(ValueNs, GenericArgs<'db>)> {
         let trait_ = trait_ref.def_id.0;
-        let item = trait_
-            .trait_items(self.db)
-            .items
-            .iter()
-            .map(|(_name, id)| *id)
-            .find_map(|item| match item {
-                AssocItemId::FunctionId(func) => {
-                    if segment.name == &self.db.function_signature(func).name {
-                        Some(AssocItemId::FunctionId(func))
-                    } else {
-                        None
+        let item =
+            trait_.trait_items(self.db).items.iter().map(|(_name, id)| *id).find_map(|item| {
+                match item {
+                    AssocItemId::FunctionId(func) => {
+                        if segment.name == &self.db.function_signature(func).name {
+                            Some(AssocItemId::FunctionId(func))
+                        } else {
+                            None
+                        }
                     }
-                }
 
-                AssocItemId::ConstId(konst) => {
-                    if self.db.const_signature(konst).name.as_ref() == Some(segment.name) {
-                        Some(AssocItemId::ConstId(konst))
-                    } else {
-                        None
+                    AssocItemId::ConstId(konst) => {
+                        if self.db.const_signature(konst).name.as_ref() == Some(segment.name) {
+                            Some(AssocItemId::ConstId(konst))
+                        } else {
+                            None
+                        }
                     }
+                    AssocItemId::TypeAliasId(_) => None,
                 }
-                AssocItemId::TypeAliasId(_) => None,
             })?;
         let def = match item {
             AssocItemId::FunctionId(f) => ValueNs::FunctionId(f),
         let substs = match container {
             ItemContainerId::ImplId(impl_id) => {
                 let impl_substs = self.table.fresh_args_for_item(impl_id.into());
-                let impl_self_ty = self
-                    .db
-                    .impl_self_ty(impl_id)
-                    .instantiate(self.interner(), impl_substs);
+                let impl_self_ty =
+                    self.db.impl_self_ty(impl_id).instantiate(self.interner(), impl_substs);
                 self.unify(impl_self_ty, ty);
                 impl_substs
             }