COMPARISON DIFF
============================================================

Original size: 16114 bytes
Chloro size:   15988 bytes
Rustfmt size:  16341 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     lower::LifetimeElisionKind,
     method_resolution::{self, VisibleFromModule},
     next_solver::{
-        infer::traits::{Obligation, ObligationCause},
         GenericArg, GenericArgs, TraitRef, Ty,
+        infer::traits::{Obligation, ObligationCause},
     },
     InferenceDiagnostic, ValueTyDefId,
 };
-
 use super::{ExprOrPatId, InferenceContext, InferenceTyDiagnosticSource};
 
 impl<'db> InferenceContext<'_, 'db> {
-    pub(super) fn infer_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty<'db>> {
+    pub(super) fn infer_path(
+        &mut self,
+        path: &Path,
+        id: ExprOrPatId,
+    ) -> Option<Ty<'db>> {
         let (value_def, generic_def, substs) = match self.resolve_value_path(path, id)? {
             ValuePathResolution::GenericDef(value_def, generic_def, substs) => {
                 (value_def, generic_def, substs)
             ValuePathResolution::NonGeneric(ty) => return Some(ty),
         };
         let args = self.process_remote_user_written_ty(substs);
-
         self.add_required_obligations_for_value_path(generic_def, args);
-
-        let ty = self
-            .db
-            .value_ty(value_def)?
-            .instantiate(self.interner(), args);
+        let ty = self.db.value_ty(value_def)?.instantiate(self.interner(), args);
         let ty = self.process_remote_user_written_ty(ty);
         Some(ty)
     }
         id: ExprOrPatId,
     ) -> Option<ValuePathResolution<'db>> {
         let (value, self_subst) = self.resolve_value_path_inner(path, id, false)?;
-
         let value_def: ValueTyDefId = match value {
             ValueNs::FunctionId(it) => it.into(),
             ValueNs::ConstId(it) => it.into(),
                 };
             }
             ValueNs::GenericParam(it) => {
-                return Some(ValuePathResolution::NonGeneric(
-                    self.db.const_param_ty_ns(it),
-                ));
+                return Some(ValuePathResolution::NonGeneric(self.db.const_param_ty_ns(it)));
             }
         };
-
         let generic_def = value_def.to_generic_def_id(self.db);
         if let GenericDefId::StaticId(_) = generic_def {
             // `Static` is the kind of item that can never be generic currently. We can just skip the binders to get its type.
             let ty = self.db.value_ty(value_def)?.skip_binder();
             return Some(ValuePathResolution::NonGeneric(ty));
         };
-
         let substs = if self_subst.is_some_and(|it| !it.is_empty())
             && matches!(value_def, ValueTyDefId::EnumVariantId(_))
         {
                 path_ctx.substs_from_path(value_def, true, false)
             })
         };
-
         let parent_substs_len = self_subst.map_or(0, |it| it.len());
         let substs = GenericArgs::fill_rest(
             self.interner(),
             generic_def.into(),
-            self_subst
-                .iter()
-                .flat_map(|it| it.iter())
-                .chain(substs.iter().skip(parent_substs_len)),
+            self_subst.iter().flat_map(|it| it.iter()).chain(substs.iter().skip(parent_substs_len)),
             |_, id, _| GenericArg::error_from_id(self.interner(), id),
         );
-
-        Some(ValuePathResolution::GenericDef(
-            value_def,
-            generic_def,
-            substs,
-        ))
+        Some(ValuePathResolution::GenericDef(value_def, generic_def, substs))
     }
 
     pub(super) fn resolve_value_path_inner(
             let (ty, _) = path_ctx.lower_ty_relative_path(ty, orig_ns, true);
             drop_ctx(ctx, no_diagnostics);
             let ty = self.table.process_user_written_ty(ty);
-            self.resolve_ty_assoc_item(ty, last.name, id)
-                .map(|(it, substs)| (it, Some(substs)))?
+            self.resolve_ty_assoc_item(ty, last.name, id).map(|(it, substs)| (it, Some(substs)))?
         } else {
             let hygiene = self.body.expr_or_pat_path_hygiene(id);
             // FIXME: report error, unresolved first path segment
             }
         };
         return Some((value, self_subst));
-
         #[inline]
         fn drop_ctx(mut ctx: TyLoweringContext<'_, '_>, no_diagnostics: bool) {
             if no_diagnostics {
                 Obligation::new(interner, ObligationCause::new(), param_env, predicate)
             }));
         }
-
         // We need to add `Self: Trait` obligation when `def` is a trait assoc item.
         let container = match def {
             GenericDefId::FunctionId(id) => id.lookup(self.db).container,
             GenericDefId::ConstId(id) => id.lookup(self.db).container,
             _ => return,
         };
-
         if let ItemContainerId::TraitId(trait_) = container {
-            let parent_len = generics(self.db, def)
-                .parent_generics()
-                .map_or(0, |g| g.len_self());
+            let parent_len = generics(self.db, def).parent_generics().map_or(0, |g| g.len_self());
             let parent_subst = GenericArgs::new_from_iter(
                 interner,
                 subst.as_slice()[..parent_len].iter().copied(),
         id: ExprOrPatId,
     ) -> Option<(ValueNs, GenericArgs<'db>)> {
         let trait_ = trait_ref.def_id.0;
-        let item = trait_
-            .trait_items(self.db)
-            .items
-            .iter()
-            .map(|(_name, id)| *id)
-            .find_map(|item| match item {
-                AssocItemId::FunctionId(func) => {
-                    if segment.name == &self.db.function_signature(func).name {
-                        Some(AssocItemId::FunctionId(func))
-                    } else {
-                        None
+        let item =
+            trait_.trait_items(self.db).items.iter().map(|(_name, id)| *id).find_map(|item| {
+                match item {
+                    AssocItemId::FunctionId(func) => {
+                        if segment.name == &self.db.function_signature(func).name {
+                            Some(AssocItemId::FunctionId(func))
+                        } else {
+                            None
+                        }
                     }
-                }
 
-                AssocItemId::ConstId(konst) => {
-                    if self.db.const_signature(konst).name.as_ref() == Some(segment.name) {
-                        Some(AssocItemId::ConstId(konst))
-                    } else {
-                        None
+                    AssocItemId::ConstId(konst) => {
+                        if self.db.const_signature(konst).name.as_ref() == Some(segment.name) {
+                            Some(AssocItemId::ConstId(konst))
+                        } else {
+                            None
+                        }
                     }
+                    AssocItemId::TypeAliasId(_) => None,
                 }
-                AssocItemId::TypeAliasId(_) => None,
             })?;
         let def = match item {
             AssocItemId::FunctionId(f) => ValueNs::FunctionId(f),
             AssocItemId::ConstId(c) => ValueNs::ConstId(c),
             AssocItemId::TypeAliasId(_) => unreachable!(),
         };
-
         self.write_assoc_resolution(id, item, trait_ref.args);
         Some((def, trait_ref.args))
     }
         if ty.is_ty_error() {
             return None;
         }
-
         if let Some(result) = self.resolve_enum_variant_on_ty(ty, name, id) {
             return Some(result);
         }
-
         let canonical_ty = self.canonicalize(ty);
-
         let mut not_visible = None;
         let res = method_resolution::iterate_method_candidates(
             &canonical_ty,
             self.push_diagnostic(InferenceDiagnostic::UnresolvedAssocItem { id });
         }
         let (item, visible) = res?;
-
         let (def, container) = match item {
             AssocItemId::FunctionId(f) => (ValueNs::FunctionId(f), f.lookup(self.db).container),
             AssocItemId::ConstId(c) => (ValueNs::ConstId(c), c.lookup(self.db).container),
         let substs = match container {
             ItemContainerId::ImplId(impl_id) => {
                 let impl_substs = self.table.fresh_args_for_item(impl_id.into());
-                let impl_self_ty = self
-                    .db
-                    .impl_self_ty(impl_id)
-                    .instantiate(self.interner(), impl_substs);
+                let impl_self_ty =
+                    self.db.impl_self_ty(impl_id).instantiate(self.interner(), impl_substs);
                 self.unify(impl_self_ty, ty);
                 impl_substs
             }
                 return None;
             }
         };
-
         self.write_assoc_resolution(id, item, substs);
         if !visible {
             self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item });
 
 #[derive(Debug)]
 enum ValuePathResolution<'db> {
-    // It's awkward to wrap a single ID in two enums, but we need both and this saves fallible
-    // conversion between them + `unwrap()`.
     GenericDef(ValueTyDefId, GenericDefId, GenericArgs<'db>),
     NonGeneric(Ty<'db>),
 }