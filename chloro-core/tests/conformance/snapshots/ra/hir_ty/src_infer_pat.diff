COMPARISON DIFF
============================================================

Original size: 25364 bytes
Chloro size:   25438 bytes
Rustfmt size:  25364 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Type inference for patterns.
 
 use std::iter::repeat_with;
 
 use hir_def::{
-    HasModule,
-    expr_store::{Body, path::Path},
-    hir::{Binding, BindingAnnotation, BindingId, Expr, ExprId, Literal, Pat, PatId},
+    expr_store::{Body, hir::{Binding, path::Path}, BindingAnnotation, BindingId, Expr, ExprId,
+    HasModule, Literal, Pat, PatId},
 };
 use hir_expand::name::Name;
 use rustc_ast_ir::Mutability;
 use stdx::TupleExt;
 
 use crate::{
-    DeclContext, DeclOrigin, InferenceDiagnostic,
-    consteval::{self, try_const_usize, usize_const},
-    infer::{
-        AllowTwoPhase, BindingMode, Expectation, InferenceContext, TypeMismatch,
-        coerce::CoerceNever, expr::ExprIsRead,
-    },
-    lower::lower_mutability,
-    next_solver::{GenericArgs, Ty, TyKind},
+    coerce::CoerceNever, consteval::{self, expr::ExprIsRead, infer::{
+        AllowTwoPhase,
+    lower::lower_mutability, next_solver::{GenericArgs, try_const_usize, usize_const}, BindingMode,
+    DeclContext, DeclOrigin, Expectation, InferenceContext, InferenceDiagnostic, Ty, TyKind},
+    TypeMismatch, },
 };
 
 impl<'db> InferenceContext<'_, 'db> {
                 });
             }
         }
-
         self.unify(ty, expected);
-
         match def {
             _ if subs.is_empty() => {}
             Some(def) => {
                 }
             }
         }
-
         ty
     }
 
         if let Some(variant) = def {
             self.write_variant_resolution(id.into(), variant);
         }
-
         self.unify(ty, expected);
-
         match def {
             _ if subs.len() == 0 => {}
             Some(def) => {
                 }
             }
         }
-
         ty
     }
 
             TyKind::Tuple(parameters) => parameters,
             _ => self.types.empty_tys,
         };
-
         let ((pre, post), n_uncovered_patterns) = match ellipsis {
             Some(idx) => {
                 (subs.split_at(idx as usize), expectations.len().saturating_sub(subs.len()))
         };
         let mut expectations_iter =
             expectations.iter().chain(repeat_with(|| self.table.next_ty_var()));
-
         let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + subs.len());
-
         inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns + subs.len()));
-
         // Process pre
         for (ty, pat) in inner_tys.iter_mut().zip(pre) {
             *ty = self.infer_pat(*pat, *ty, default_bm, decl);
         }
-
         // Process post
         for (ty, pat) in inner_tys.iter_mut().skip(pre.len() + n_uncovered_patterns).zip(post) {
             *ty = self.infer_pat(*pat, *ty, default_bm, decl);
         }
-
         Ty::new_tup_from_iter(self.interner(), inner_tys.into_iter())
     }
 
         decl: Option<DeclContext>,
     ) -> Ty<'db> {
         let mut expected = self.table.structurally_resolve_type(expected);
-
         if matches!(&self.body[pat], Pat::Ref { .. }) || self.inside_assignment {
             cov_mark::hit!(match_ergonomics_ref);
             // When you encounter a `&pat` pattern, reset to Move.
                 self.result.pat_adjustments.insert(pat, pat_adjustments);
             }
         }
-
         // Lose mutability.
         let default_bm = default_bm;
         let expected = expected;
-
         let ty = match &self.body[pat] {
             Pat::Tuple { args, ellipsis } => {
                 self.infer_tuple_pat_like(expected, default_bm, *ellipsis, args, decl)
         self.pat_ty_after_adjustment(pat)
     }
 
-    fn pat_ty_after_adjustment(&self, pat: PatId) -> Ty<'db> {
+    fn pat_ty_after_adjustment(
+        &self,
+        pat: PatId,
+    ) -> Ty<'db> {
         *self
             .result
             .pat_adjustments
             BindingMode::convert(mode)
         };
         self.result.binding_modes.insert(pat, mode);
-
         let inner_ty = match subpat {
             Some(subpat) => self.infer_pat(subpat, expected, default_bm, decl),
             None => expected,
         };
         let inner_ty = self.insert_type_vars_shallow(inner_ty);
-
         let bound_ty = match mode {
             BindingMode::Ref(mutability) => {
                 let inner_lt = self.table.next_region_var();
         decl: Option<DeclContext>,
     ) -> Ty<'db> {
         let expected = self.table.structurally_resolve_type(expected);
-
         // If `expected` is an infer ty, we try to equate it to an array if the given pattern
         // allows it. See issue #16609
         if self.pat_is_irrefutable(decl)
         {
             self.unify(expected, resolved_array_ty);
         }
-
         let expected = self.table.try_structurally_resolve_type(expected);
         let elem_ty = match expected.kind() {
             TyKind::Array(st, _) | TyKind::Slice(st) => st,
             _ => self.err_ty(),
         };
-
         for &pat_id in prefix.iter().chain(suffix.iter()) {
             self.infer_pat(pat_id, elem_ty, default_bm, decl);
         }
-
         if let Some(slice_pat_id) = slice {
             let rest_pat_ty = match expected.kind() {
                 TyKind::Array(_, length) => {
             };
             self.infer_pat(slice_pat_id, rest_pat_ty, default_bm, decl);
         }
-
         match expected.kind() {
             TyKind::Array(_, const_) => {
                 Ty::new_array_with_const_len(self.interner(), elem_ty, const_)
         }
     }
 
-    fn infer_lit_pat(&mut self, expr: ExprId, expected: Ty<'db>) -> Ty<'db> {
+    fn infer_lit_pat(
+        &mut self,
+        expr: ExprId,
+        expected: Ty<'db>,
+    ) -> Ty<'db> {
         // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.
         if let Expr::Literal(Literal::ByteString(_)) = self.body[expr]
             && let TyKind::Ref(_, inner, _) = expected.kind()
                 return ty;
             }
         }
-
         self.infer_expr(expr, &Expectation::has_type(expected), ExprIsRead::Yes)
     }
 
-    fn is_non_ref_pat(&mut self, body: &hir_def::expr_store::Body, pat: PatId) -> bool {
+    fn is_non_ref_pat(
+        &mut self,
+        body: &hir_def::expr_store::Body,
+        pat: PatId,
+    ) -> bool {
         match &body[pat] {
             Pat::Tuple { .. }
             | Pat::TupleStruct { .. }
         if slice.is_some() {
             return None;
         }
-
         let len = before.len() + suffix.len();
         let size = consteval::usize_const(self.db, Some(len as u128), self.owner.krate(self.db));
-
         let elem_ty = self.table.next_ty_var();
         let array_ty = Ty::new_array_with_const_len(self.interner(), elem_ty, size);
         Some(array_ty)
     ///
     /// If we're in an irrefutable pattern we prefer the array impl candidate given that
     /// the slice impl candidate would be rejected anyway (if no ambiguity existed).
-    fn pat_is_irrefutable(&self, decl_ctxt: Option<DeclContext>) -> bool {
+    fn pat_is_irrefutable(
+        &self,
+        decl_ctxt: Option<DeclContext>,
+    ) -> bool {
         matches!(decl_ctxt, Some(DeclContext { origin: DeclOrigin::LocalDecl { has_else: false } }))
     }
 }
 
-pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {
+pub(super) fn contains_explicit_ref_binding(
+    body: &Body,
+    pat_id: PatId,
+) -> bool {
     let mut res = false;
     body.walk_pats(pat_id, &mut |pat| {
         res |= matches!(body[pat], Pat::Bind { id, .. } if body[id].mode == BindingAnnotation::Ref);