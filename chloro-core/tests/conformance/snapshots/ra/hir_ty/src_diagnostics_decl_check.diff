COMPARISON DIFF
============================================================

Original size: 23115 bytes
Chloro size:   22487 bytes
Rustfmt size:  23115 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::fmt;
 
 use hir_def::{
+    db::DefDatabase, hir::Pat, item_tree::FieldsShape, signatures::StaticFlags, src::HasSource,
     AdtId, ConstId, EnumId, EnumVariantId, FunctionId, HasModule, ItemContainerId, Lookup,
-    ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, db::DefDatabase, hir::Pat,
-    item_tree::FieldsShape, signatures::StaticFlags, src::HasSource,
+    ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId,
 };
 use hir_expand::{
-    HirFileId,
     name::{AsName, Name},
+    HirFileId,
 };
 use intern::sym;
 use stdx::{always, never};
 use syntax::{
-    AstNode, AstPtr, ToSmolStr,
     ast::{self, HasName},
     utils::is_raw_identifier,
+    AstNode, AstPtr, ToSmolStr,
 };
 
 use crate::db::HirDatabase;
-
 use self::case_conv::{to_camel_case, to_lower_snake_case, to_upper_snake_case};
 
 pub fn incorrect_case(db: &dyn HirDatabase, owner: ModuleDefId) -> Vec<IncorrectCase> {
             AdtId::StructId(struct_id) => self.validate_struct(struct_id),
             AdtId::EnumId(enum_id) => self.validate_enum(enum_id),
             AdtId::UnionId(_) => {
-                // FIXME: Unions aren't yet supported by this validator.
-            }
+            },
         }
     }
 
         }
 
         // Check the function name.
+
         // Skipped if function is an associated item of a trait implementation.
         if !self.is_trait_impl_container(container) {
             let data = self.db.function_signature(func);
             let Some(parent) = ident_pat.syntax().parent() else {
                 continue;
             };
-
             let is_shorthand = ast::RecordPatField::cast(parent.clone())
                 .map(|parent| parent.name_ref().is_none())
                 .unwrap_or_default();
                 // since the shorthand isn't the declaration.
                 continue;
             }
-
             let is_param = ast::Param::can_cast(parent.kind());
             let ident_type = if is_param { IdentType::Parameter } else { IdentType::Variable };
-
             self.create_incorrect_case_diagnostic_for_ast_node(
                 replacement,
                 source_ptr.file_id,
         };
         let mut struct_fields_iter = struct_fields_list.fields();
         for field_replacement in struct_fields_replacements {
-            // We assume that parameters in replacement are in the same order as in the
-            // actual params list, but just some of them (ones that named correctly) are skipped.
             let field = loop {
                 if let Some(field) = struct_fields_iter.next() {
                     let Some(field_name) = field.name() else {
                     return;
                 }
             };
-
             self.create_incorrect_case_diagnostic_for_ast_node(
                 field_replacement,
                 struct_src.file_id,
         };
         let mut enum_variants_iter = enum_variants_list.variants();
         for variant_replacement in enum_variants_replacements {
-            // We assume that parameters in replacement are in the same order as in the
-            // actual params list, but just some of them (ones that named correctly) are skipped.
             let variant = loop {
                 if let Some(variant) = enum_variants_iter.next() {
                     let Some(variant_name) = variant.name() else {
                     return;
                 }
             };
-
             self.create_incorrect_case_diagnostic_for_ast_node(
                 variant_replacement,
                 enum_src.file_id,
         };
         let mut variant_variants_iter = variant_fields_list.fields();
         for field_replacement in variant_field_replacements {
-            // We assume that parameters in replacement are in the same order as in the
-            // actual params list, but just some of them (ones that named correctly) are skipped.
             let field = loop {
                 if let Some(field) = variant_variants_iter.next() {
                     let Some(field_name) = field.name() else {
                     return;
                 }
             };
-
             self.create_incorrect_case_diagnostic_for_ast_node(
                 field_replacement,
                 variant_src.file_id,
         name: &Name,
         expected_case: CaseType,
         ident_type: IdentType,
-    ) where
+    )
+    where
         N: AstNode + HasName + fmt::Debug,
         S: HasSource<Value = N>,
         L: Lookup<Data = S, Database = dyn DefDatabase> + HasModule + Copy,
         file_id: HirFileId,
         node: &T,
         ident_type: IdentType,
-    ) where
+    )
+    where
         T: AstNode + HasName + fmt::Debug,
     {
         let Some(name_ast) = node.name() else {