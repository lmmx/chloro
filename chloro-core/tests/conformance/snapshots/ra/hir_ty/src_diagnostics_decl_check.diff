COMPARISON DIFF
============================================================

Original size: 23115 bytes
Chloro size:   23128 bytes
Rustfmt size:  23115 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         }
 
         // Check the function name.
+
         // Skipped if function is an associated item of a trait implementation.
+
         if !self.is_trait_impl_container(container) {
             let data = self.db.function_signature(func);
 
         }
 
         // Check the patterns inside the function body.
+
         self.validate_func_body(func);
     }
 
             .peekable();
 
         // XXX: only look at source_map if we do have missing fields
+
         if pats_replacements.peek().is_none() {
             return;
         }
             let Some(parent) = ident_pat.syntax().parent() else {
                 continue;
             };
-
             let is_shorthand = ast::RecordPatField::cast(parent.clone())
                 .map(|parent| parent.name_ref().is_none())
                 .unwrap_or_default();
                 // since the shorthand isn't the declaration.
                 continue;
             }
-
             let is_param = ast::Param::can_cast(parent.kind());
             let ident_type = if is_param { IdentType::Parameter } else { IdentType::Variable };
-
             self.create_incorrect_case_diagnostic_for_ast_node(
                 replacement,
                 source_ptr.file_id,
         );
 
         // Check the field names.
+
         self.validate_struct_fields(struct_id);
     }
 
             .peekable();
 
         // XXX: Only look at sources if we do have incorrect names.
+
         if struct_fields_replacements.peek().is_none() {
             return;
         }
                     return;
                 }
             };
-
             self.create_incorrect_case_diagnostic_for_ast_node(
                 field_replacement,
                 struct_src.file_id,
         let data = self.db.enum_signature(enum_id);
 
         // Check the enum name.
+
         self.create_incorrect_case_diagnostic_for_item_name(
             enum_id,
             &data.name,
         );
 
         // Check the variant names.
+
         self.validate_enum_variants(enum_id)
     }
 
             .peekable();
 
         // XXX: only look at sources if we do have incorrect names
+
         if enum_variants_replacements.peek().is_none() {
             return;
         }
                     return;
                 }
             };
-
             self.create_incorrect_case_diagnostic_for_ast_node(
                 variant_replacement,
                 enum_src.file_id,
             .peekable();
 
         // XXX: only look at sources if we do have incorrect names
+
         if variant_field_replacements.peek().is_none() {
             return;
         }
                     return;
                 }
             };
-
             self.create_incorrect_case_diagnostic_for_ast_node(
                 field_replacement,
                 variant_src.file_id,
         }
 
         // Check the type alias name.
+
         let data = self.db.type_alias_signature(type_alias_id);
         self.create_incorrect_case_diagnostic_for_item_name(
             type_alias_id,
         name: &Name,
         expected_case: CaseType,
         ident_type: IdentType,
-    ) where
+    )
+    where
         N: AstNode + HasName + fmt::Debug,
         S: HasSource<Value = N>,
         L: Lookup<Data = S, Database = dyn DefDatabase> + HasModule + Copy,
         file_id: HirFileId,
         node: &T,
         ident_type: IdentType,
-    ) where
+    )
+    where
         T: AstNode + HasName + fmt::Debug,
     {
         let Some(name_ast) = node.name() else {