COMPARISON DIFF
============================================================

Original size: 65944 bytes
Chloro size:   63786 bytes
Rustfmt size:  65944 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is concerned with finding methods that a given type provides.
 //! For details about how this works in rustc, see the method lookup page in the
 //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)
 //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.
+
 use std::ops::ControlFlow;
 
 use base_db::Crate;
 use hir_def::{
+    nameres::{block_def_map, crate_def_map, DefMap},
+    signatures::{ConstFlags, EnumFlags, FnFlags, StructFlags, TraitFlags, TypeAliasFlags},
     AdtId, AssocItemId, BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup,
     ModuleId, TraitId, TypeAliasId,
-    nameres::{DefMap, block_def_map, crate_def_map},
-    signatures::{ConstFlags, EnumFlags, FnFlags, StructFlags, TraitFlags, TypeAliasFlags},
 };
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::{
+    inherent::{AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
     FloatTy, IntTy, TypeVisitableExt, UintTy,
-    inherent::{
-        AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _,
-    },
 };
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use stdx::never;
 use triomphe::Arc;
 
 use crate::{
-    TraitEnvironment,
     autoderef::{self, AutoderefKind},
     db::HirDatabase,
-    infer::{Adjust, Adjustment, OverloadedDeref, PointerCast, unify::InferenceTable},
+    infer::{unify::InferenceTable, Adjust, Adjustment, OverloadedDeref, PointerCast},
     lang_items::is_box,
     next_solver::{
-        Canonical, DbInterner, ErrorGuaranteed, GenericArgs, Goal, Predicate, Region, SolverDefId,
-        TraitRef, Ty, TyKind, TypingMode,
         infer::{
             DbInternerInferExt, InferCtxt,
             select::ImplSource,
             traits::{Obligation, ObligationCause, PredicateObligation},
         },
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Canonical, DbInterner, ErrorGuaranteed, GenericArgs,
+        Goal, Predicate, Region, SolverDefId, TraitRef, Ty, TyKind, TypingMode,
     },
     traits::next_trait_solve_canonical_in_ctxt,
     utils::all_super_traits,
+    TraitEnvironment,
 };
 
 /// This is used as a key for indexing impls.
 ];
 
 type TraitFpMap = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Box<[ImplId]>>>;
+
 type TraitFpMapCollector = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>;
 
 /// Trait impls defined or available in some crate.
 
         Self::collect_def_map(db, &mut impls, block_def_map(db, block));
 
-        if impls.is_empty() { None } else { Some(Arc::new(Self::finish(impls))) }
+        if impls.is_empty() {
+            None
+        } else {
+            Some(Arc::new(Self::finish(impls)))
+        }
     }
 
     pub(crate) fn trait_impls_in_deps_query(
                 let self_ty_fp = TyFingerprint::for_trait_impl(self_ty.instantiate_identity());
                 map.entry(target_trait).or_default().entry(self_ty_fp).or_default().push(impl_id);
             }
-
-            // To better support custom derives, collect impls in all unnamed const items.
-            // const _: () = { ... };
             for konst in module_data.scope.unnamed_consts() {
                 let body = db.body(konst.into());
                 for (_, block_def_map) in body.blocks(db) {
         &self,
         fp: TyFingerprint,
     ) -> impl Iterator<Item = ImplId> + '_ {
-        self.map
-            .values()
-            .flat_map(move |impls| impls.get(&Some(fp)).into_iter())
-            .flat_map(|it| it.iter().copied())
+        self.map.values().flat_map(move |impls| impls.get(&Some(fp)).into_iter()).flat_map(
+            |it| it.iter().copied(),
+        )
     }
 
     /// Queries all impls of the given trait.
     pub fn for_trait(&self, trait_: TraitId) -> impl Iterator<Item = ImplId> + '_ {
-        self.map
-            .get(&trait_)
-            .into_iter()
-            .flat_map(|map| map.values().flat_map(|v| v.iter().copied()))
+        self.map.get(&trait_).into_iter().flat_map(
+            |map| map.values().flat_map(|v| v.iter().copied()),
+        )
     }
 
     /// Queries all impls of `trait_` that may apply to `self_ty`.
         trait_: TraitId,
         self_ty: TyFingerprint,
     ) -> impl Iterator<Item = ImplId> + '_ {
-        self.map
-            .get(&trait_)
-            .into_iter()
-            .flat_map(move |map| map.get(&Some(self_ty)).into_iter().chain(map.get(&None)))
-            .flat_map(|v| v.iter().copied())
+        self.map.get(&trait_).into_iter().flat_map(
+            move |map| map.get(&Some(self_ty)).into_iter().chain(map.get(&None)),
+        ).flat_map(
+            |v| v.iter().copied(),
+        )
     }
 
     /// Queries whether `self_ty` has potentially applicable implementations of `trait_`.
-    pub fn has_impls_for_trait_and_self_ty(&self, trait_: TraitId, self_ty: TyFingerprint) -> bool {
+    pub fn has_impls_for_trait_and_self_ty(
+        &self,
+        trait_: TraitId,
+        self_ty: TyFingerprint,
+    ) -> bool {
         self.for_trait_and_self_ty(trait_, self_ty).next().is_some()
     }
 
                     false => self.invalid_impls.push(impl_id),
                 }
             }
-
-            // To better support custom derives, collect impls in all unnamed const items.
-            // const _: () = { ... };
             for konst in module_data.scope.unnamed_consts() {
                 let body = db.body(konst.into());
                 for (_, block_def_map) in body.blocks(db) {
     let mut res = SmallVec::new();
 
     // should pass crate for finger print and do reverse deps
-
     for krate in db.transitive_deps(krate) {
         let impls = db.inherent_impls_in_crate(krate);
         if impls.map.get(&fp).is_some_and(|v| !v.is_empty()) {
         }
         TyKind::Foreign(alias) => {
             let alias = alias.0;
-            Some(
-                if db
-                    .type_alias_signature(alias)
-                    .flags
-                    .contains(TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL)
-                {
-                    db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::ForeignType(alias))
-                } else {
-                    smallvec![alias.module(db).krate()]
-                },
-            )
+            Some(if db.type_alias_signature(alias).flags.contains(
+                TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL,
+            ) {
+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::ForeignType(alias))
+            } else {
+                smallvec![alias.module(db).krate()]
+            })
         }
         TyKind::Dynamic(bounds, _) => {
             let trait_id = bounds.principal_def_id()?.0;
-            Some(
-                if db
-                    .trait_signature(trait_id)
-                    .flags
-                    .contains(TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS)
-                {
-                    db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Dyn(trait_id))
-                } else {
-                    smallvec![trait_id.module(db).krate()]
-                },
-            )
+            Some(if db.trait_signature(trait_id).flags.contains(
+                TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS,
+            ) {
+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Dyn(trait_id))
+            } else {
+                smallvec![trait_id.module(db).krate()]
+            })
         }
-        // for primitives, there may be impls in various places (core and alloc
-        // mostly). We just check the whole crate graph for crates with impls
-        // (cached behind a query).
         TyKind::Bool
         | TyKind::Char
         | TyKind::Int(_)
     }
 }
 
-// This would be nicer if it just returned an iterator, but that runs into
-// lifetime problems, because we need to borrow temp `CrateImplDefs`.
-// FIXME add a context type here?
 pub(crate) fn iterate_method_candidates<'db, T>(
     ty: &Canonical<'db, Ty<'db>>,
     table: &mut InferenceTable<'db>,
         None => return (const_id, subs),
     };
 
-    lookup_impl_assoc_item_for_trait_ref(infcx, trait_ref, env, name)
-        .and_then(
-            |assoc| if let (AssocItemId::ConstId(id), s) = assoc { Some((id, s)) } else { None },
-        )
-        .unwrap_or((const_id, subs))
+    lookup_impl_assoc_item_for_trait_ref(infcx, trait_ref, env, name).and_then(
+        |assoc| if let (AssocItemId::ConstId(id), s) = assoc { Some((id, s)) } else { None },
+    ).unwrap_or(
+        (const_id, subs),
+    )
 }
 
 /// Checks if the self parameter of `Trait` method is the `dyn Trait` and we should
     (
         impl_fn,
         GenericArgs::new_from_iter(
-            interner,
-            impl_subst.iter().chain(fn_subst.iter().skip(trait_params)),
-        ),
+        interner,
+        impl_subst.iter().chain(fn_subst.iter().skip(trait_params)),
+    ),
     )
 }
 
     let selection = infcx.select(&obligation).ok()??;
 
     // Currently, we use a fulfillment context to completely resolve
+
     // all nested obligations. This is because they can inform the
+
     // inference of the impl's type parameters.
     let mut ocx = ObligationCtxt::new(infcx);
     let impl_source = selection.map(|obligation| ocx.register_obligation(obligation));
             _ => false,
         };
         let items = impl_id.impl_items(db);
-        rustc_has_incoherent_inherent_impls
-            && !items.items.is_empty()
-            && items.items.iter().all(|&(_, assoc)| match assoc {
+        rustc_has_incoherent_inherent_impls && !items.items.is_empty() && items.items.iter().all(|&(_, assoc)| match assoc {
                 AssocItemId::FunctionId(it) => {
                     db.function_signature(it).flags.contains(FnFlags::RUSTC_ALLOW_INCOHERENT_IMPL)
                 }
     //   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
 
     // FIXME: param coverage
+
     //   - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti`` (excluding `Ti`)
     let is_not_orphan = trait_ref.args.types().any(|ty| match unwrap_fundamental(ty).kind() {
         TyKind::Adt(adt_def, _) => is_local(adt_def.def_id().0.module(db).krate()),
         visible_from_module,
         name,
         LookupMode::Path,
-        // the adjustments are not relevant for path lookup
         callback,
     )
 }
 
     match mode {
         LookupMode::MethodCall => {
-            // For method calls, rust first does any number of autoderef, and
-            // then one autoref (i.e. when the method takes &self or &mut self).
-            // Note that when we've got a receiver like &S, even if the method
-            // we find in the end takes &self, we still do the autoderef step
-            // (just as rustc does an autoderef and then autoref again).
-
-            // We have to be careful about the order we're looking at candidates
-            // in here. Consider the case where we're resolving `it.clone()`
-            // where `it: &Vec<_>`. This resolves to the clone method with self
-            // type `Vec<_>`, *not* `&_`. I.e. we need to consider methods where
-            // the receiver type exactly matches before cases where we have to
-            // do autoref. But in the autoderef steps, the `&_` self type comes
-            // up *before* the `Vec<_>` self type.
-            //
-            // On the other hand, we don't want to just pick any by-value method
-            // before any by-autoref method; it's just that we need to consider
-            // the methods by autoderef order of *receiver types*, not *self
-            // types*.
-
             table.run_in_snapshot(|table| {
                 let ty = table.instantiate_canonical(*ty);
                 let deref_chain = autoderef_method_receiver(table, ty);
             })
         }
         LookupMode::Path => {
-            // No autoderef for path lookups
             iterate_method_candidates_for_self_ty(
                 ty,
                 table,
     let env = table.trait_env.clone();
 
     // For trait object types and placeholder types with trait bounds, the methods of the trait and
+
     // its super traits are considered inherent methods. This matters because these methods have
+
     // higher priority than the other traits' methods, which would be considered in
+
     // `iterate_trait_method_candidates()` only after this function.
     match self_ty.kind() {
         TyKind::Param(_) => {
             let db = table.db;
             check_that!(receiver_ty.is_none());
             check_that!(name.is_none_or(|n| n == item_name));
-
             if let Some(from_module) = visible_from_module
                 && !db.assoc_visibility(c.into()).is_visible_from(db, from_module)
             {
     match item {
         AssocItemId::FunctionId(fn_id) => {
             let data = db.function_signature(fn_id);
-
             check_that!(name.is_none_or(|n| n == &data.name));
-
             table.run_in_snapshot(|table| {
                 let impl_subst = table.fresh_args_for_item(trait_id.into());
                 let expect_self_ty = impl_subst.type_at(0);
         AssocItemId::ConstId(c) => {
             check_that!(receiver_ty.is_none());
             check_that!(name.is_none_or(|n| db.const_signature(c).name.as_ref() == Some(n)));
-
             IsValidCandidate::Yes
         }
         _ => IsValidCandidate::No,