COMPARISON DIFF
============================================================

Original size: 65944 bytes
Chloro size:   65780 bytes
Rustfmt size:  65944 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is concerned with finding methods that a given type provides.
 //! For details about how this works in rustc, see the method lookup page in the
 //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)
 //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.
+
 use std::ops::ControlFlow;
 
 use base_db::Crate;
 use hir_def::{
+    nameres::{block_def_map, crate_def_map, DefMap},
+    signatures::{ConstFlags, EnumFlags, FnFlags, StructFlags, TraitFlags, TypeAliasFlags},
     AdtId, AssocItemId, BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup,
     ModuleId, TraitId, TypeAliasId,
-    nameres::{DefMap, block_def_map, crate_def_map},
-    signatures::{ConstFlags, EnumFlags, FnFlags, StructFlags, TraitFlags, TypeAliasFlags},
 };
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::{
+    inherent::{AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
     FloatTy, IntTy, TypeVisitableExt, UintTy,
-    inherent::{
-        AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _,
-    },
 };
 use smallvec::{SmallVec, smallvec};
 use stdx::never;
 use triomphe::Arc;
 
 use crate::{
-    TraitEnvironment,
     autoderef::{self, AutoderefKind},
     db::HirDatabase,
-    infer::{Adjust, Adjustment, OverloadedDeref, PointerCast, unify::InferenceTable},
+    infer::{unify::InferenceTable, Adjust, Adjustment, OverloadedDeref, PointerCast},
     lang_items::is_box,
     next_solver::{
-        Canonical, DbInterner, ErrorGuaranteed, GenericArgs, Goal, Predicate, Region, SolverDefId,
-        TraitRef, Ty, TyKind, TypingMode,
         infer::{
             DbInternerInferExt, InferCtxt,
             select::ImplSource,
             traits::{Obligation, ObligationCause, PredicateObligation},
         },
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Canonical, DbInterner, ErrorGuaranteed, GenericArgs,
+        Goal, Predicate, Region, SolverDefId, TraitRef, Ty, TyKind, TypingMode,
     },
     traits::next_trait_solve_canonical_in_ctxt,
     utils::all_super_traits,
+    TraitEnvironment,
 };
 
 /// This is used as a key for indexing impls.
 ];
 
 type TraitFpMap = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Box<[ImplId]>>>;
+
 type TraitFpMapCollector = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>;
 
 /// Trait impls defined or available in some crate.
     }
 
     /// Queries whether `self_ty` has potentially applicable implementations of `trait_`.
-    pub fn has_impls_for_trait_and_self_ty(&self, trait_: TraitId, self_ty: TyFingerprint) -> bool {
+    pub fn has_impls_for_trait_and_self_ty(
+        &self,
+        trait_: TraitId,
+        self_ty: TyFingerprint,
+    ) -> bool {
         self.for_trait_and_self_ty(trait_, self_ty).next().is_some()
     }
 
     let mut res = SmallVec::new();
 
     // should pass crate for finger print and do reverse deps
-
     for krate in db.transitive_deps(krate) {
         let impls = db.inherent_impls_in_crate(krate);
         if impls.map.get(&fp).is_some_and(|v| !v.is_empty()) {
     }
 }
 
-// This would be nicer if it just returned an iterator, but that runs into
-// lifetime problems, because we need to borrow temp `CrateImplDefs`.
-// FIXME add a context type here?
 pub(crate) fn iterate_method_candidates<'db, T>(
     ty: &Canonical<'db, Ty<'db>>,
     table: &mut InferenceTable<'db>,
     let selection = infcx.select(&obligation).ok()??;
 
     // Currently, we use a fulfillment context to completely resolve
+
     // all nested obligations. This is because they can inform the
+
     // inference of the impl's type parameters.
     let mut ocx = ObligationCtxt::new(infcx);
     let impl_source = selection.map(|obligation| ocx.register_obligation(obligation));
     //   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
 
     // FIXME: param coverage
+
     //   - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti`` (excluding `Ti`)
     let is_not_orphan = trait_ref.args.types().any(|ty| match unwrap_fundamental(ty).kind() {
         TyKind::Adt(adt_def, _) => is_local(adt_def.def_id().0.module(db).krate()),
     let env = table.trait_env.clone();
 
     // For trait object types and placeholder types with trait bounds, the methods of the trait and
+
     // its super traits are considered inherent methods. This matters because these methods have
+
     // higher priority than the other traits' methods, which would be considered in
+
     // `iterate_trait_method_candidates()` only after this function.
     match self_ty.kind() {
         TyKind::Param(_) => {