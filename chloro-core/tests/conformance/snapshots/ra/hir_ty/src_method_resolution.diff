COMPARISON DIFF
============================================================

Original size: 65944 bytes
Chloro size:   65734 bytes
Rustfmt size:  65944 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is concerned with finding methods that a given type provides.
 //! For details about how this works in rustc, see the method lookup page in the
 //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)
 //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.
+
 use std::ops::ControlFlow;
 
 use base_db::Crate;
 /// This is used as a key for indexing impls.
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
 pub enum TyFingerprint {
-    // These are lang item impls:
     Str,
     Slice,
     Array,
     Int(IntTy),
     Uint(UintTy),
     Float(FloatTy),
-    // These can have user-defined impls:
     Adt(hir_def::AdtId),
     Dyn(TraitId),
     ForeignType(TypeAliasId),
-    // These only exist for trait impls
     Unit,
     Unnameable,
     Function(u32),
 ];
 
 type TraitFpMap = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Box<[ImplId]>>>;
+
 type TraitFpMapCollector = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>;
 
 /// Trait impls defined or available in some crate.
 #[derive(Debug, Eq, PartialEq)]
 pub struct TraitImpls {
-    // If the `Option<TyFingerprint>` is `None`, the impl may apply to any self type.
     map: TraitFpMap,
 }
 
 impl TraitImpls {
-    pub(crate) fn trait_impls_in_crate_query(db: &dyn HirDatabase, krate: Crate) -> Arc<Self> {
+    pub(crate) fn trait_impls_in_crate_query(
+        db: &dyn HirDatabase,
+        krate: Crate,
+    ) -> Arc<Self> {
         let _p = tracing::info_span!("trait_impls_in_crate_query", ?krate).entered();
         let mut impls = FxHashMap::default();
-
         Self::collect_def_map(db, &mut impls, crate_def_map(db, krate));
-
         Arc::new(Self::finish(impls))
     }
 
     ) -> Option<Arc<Self>> {
         let _p = tracing::info_span!("trait_impls_in_block_query").entered();
         let mut impls = FxHashMap::default();
-
         Self::collect_def_map(db, &mut impls, block_def_map(db, block));
-
         if impls.is_empty() { None } else { Some(Arc::new(Self::finish(impls))) }
     }
 
         }
     }
 
-    fn collect_def_map(db: &dyn HirDatabase, map: &mut TraitFpMapCollector, def_map: &DefMap) {
+    fn collect_def_map(
+        db: &dyn HirDatabase,
+        map: &mut TraitFpMapCollector,
+        def_map: &DefMap,
+    ) {
         for (_module_id, module_data) in def_map.modules() {
             for impl_id in module_data.scope.impls() {
                 // Reservation impls should be ignored during trait resolution, so we never need
     }
 
     /// Queries all impls of the given trait.
-    pub fn for_trait(&self, trait_: TraitId) -> impl Iterator<Item = ImplId> + '_ {
+    pub fn for_trait(
+        &self,
+        trait_: TraitId,
+    ) -> impl Iterator<Item = ImplId> + '_ {
         self.map
             .get(&trait_)
             .into_iter()
     }
 
     /// Queries whether `self_ty` has potentially applicable implementations of `trait_`.
-    pub fn has_impls_for_trait_and_self_ty(&self, trait_: TraitId, self_ty: TyFingerprint) -> bool {
+    pub fn has_impls_for_trait_and_self_ty(
+        &self,
+        trait_: TraitId,
+        self_ty: TyFingerprint,
+    ) -> bool {
         self.for_trait_and_self_ty(trait_, self_ty).next().is_some()
     }
 
 }
 
 impl InherentImpls {
-    pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: Crate) -> Arc<Self> {
+    pub(crate) fn inherent_impls_in_crate_query(
+        db: &dyn HirDatabase,
+        krate: Crate,
+    ) -> Arc<Self> {
         let _p = tracing::info_span!("inherent_impls_in_crate_query", ?krate).entered();
         let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };
-
         let crate_def_map = crate_def_map(db, krate);
         impls.collect_def_map(db, crate_def_map);
         impls.shrink_to_fit();
-
         Arc::new(impls)
     }
 
     ) -> Option<Arc<Self>> {
         let _p = tracing::info_span!("inherent_impls_in_block_query").entered();
         let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };
-
         let block_def_map = block_def_map(db, block);
         impls.collect_def_map(db, block_def_map);
         impls.shrink_to_fit();
-
         if impls.map.is_empty() && impls.invalid_impls.is_empty() {
             None
         } else {
         self.map.shrink_to_fit();
     }
 
-    fn collect_def_map(&mut self, db: &dyn HirDatabase, def_map: &DefMap) {
+    fn collect_def_map(
+        &mut self,
+        db: &dyn HirDatabase,
+        def_map: &DefMap,
+    ) {
         for (_module_id, module_data) in def_map.modules() {
             for impl_id in module_data.scope.impls() {
                 let data = db.impl_signature(impl_id);
         }
     }
 
-    pub fn for_self_ty<'db>(&self, self_ty: Ty<'db>) -> &[ImplId] {
+    pub fn for_self_ty<'db>(
+        &self,
+        self_ty: Ty<'db>,
+    ) -> &[ImplId] {
         match TyFingerprint::for_inherent_impl(self_ty) {
             Some(fp) => self.map.get(&fp).map(|vec| vec.as_ref()).unwrap_or(&[]),
             None => &[],
 ) -> SmallVec<[Crate; 2]> {
     let _p = tracing::info_span!("incoherent_inherent_impl_crates").entered();
     let mut res = SmallVec::new();
-
     // should pass crate for finger print and do reverse deps
-
     for krate in db.transitive_deps(krate) {
         let impls = db.inherent_impls_in_crate(krate);
         if impls.map.get(&fp).is_some_and(|v| !v.is_empty()) {
             res.push(krate);
         }
     }
-
     res
 }
 
         (ty, adjust)
     }
 
-    fn with_autoref(&self, a: AutorefOrPtrAdjustment) -> ReceiverAdjustments {
+    fn with_autoref(
+        &self,
+        a: AutorefOrPtrAdjustment,
+    ) -> ReceiverAdjustments {
         Self { autoref: Some(a), ..*self }
     }
 }
 
-// This would be nicer if it just returned an iterator, but that runs into
-// lifetime problems, because we need to borrow temp `CrateImplDefs`.
-// FIXME add a context type here?
 pub(crate) fn iterate_method_candidates<'db, T>(
     ty: &Canonical<'db, Ty<'db>>,
     table: &mut InferenceTable<'db>,
 ) -> (ConstId, GenericArgs<'db>) {
     let interner = infcx.interner;
     let db = interner.db;
-
     let trait_id = match const_id.lookup(db).container {
         ItemContainerId::TraitId(id) => id,
         _ => return (const_id, subs),
     };
     let trait_ref = TraitRef::new(interner, trait_id.into(), subs);
-
     let const_signature = db.const_signature(const_id);
     let name = match const_signature.name.as_ref() {
         Some(name) => name,
         None => return (const_id, subs),
     };
-
     lookup_impl_assoc_item_for_trait_ref(infcx, trait_ref, env, name)
         .and_then(
             |assoc| if let (AssocItemId::ConstId(id), s) = assoc { Some((id, s)) } else { None },
     fn_subst: GenericArgs<'db>,
 ) -> Option<usize> {
     let db = interner.db;
-
     let ItemContainerId::TraitId(trait_id) = func.lookup(db).container else {
         return None;
     };
 ) -> (FunctionId, GenericArgs<'db>) {
     let interner = DbInterner::new_with(db, Some(env.krate), env.block);
     let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
-
     let ItemContainerId::TraitId(trait_id) = func.lookup(db).container else {
         return (func, fn_subst);
     };
         trait_id.into(),
         GenericArgs::new_from_iter(interner, fn_subst.iter().take(trait_params)),
     );
-
     let name = &db.function_signature(func).name;
     let Some((impl_fn, impl_subst)) =
         lookup_impl_assoc_item_for_trait_ref(&infcx, trait_ref, env, name).and_then(|assoc| {
     else {
         return (func, fn_subst);
     };
-
     (
         impl_fn,
         GenericArgs::new_from_iter(
 ) -> Option<(ImplId, GenericArgs<'db>)> {
     let trait_ref =
         infcx.at(&ObligationCause::dummy(), env.env).deeply_normalize(trait_ref).ok()?;
-
     let obligation = Obligation::new(infcx.interner, ObligationCause::dummy(), env.env, trait_ref);
-
     let selection = infcx.select(&obligation).ok()??;
-
     // Currently, we use a fulfillment context to completely resolve
     // all nested obligations. This is because they can inform the
     // inference of the impl's type parameters.
     let mut ocx = ObligationCtxt::new(infcx);
     let impl_source = selection.map(|obligation| ocx.register_obligation(obligation));
-
     let errors = ocx.evaluate_obligations_error_on_ambiguity();
     if !errors.is_empty() {
         return None;
     }
-
     let impl_source = infcx.resolve_vars_if_possible(impl_source);
     if impl_source.has_non_region_infer() {
         return None;
     }
-
     match impl_source {
         ImplSource::UserDefined(impl_source) => Some((impl_source.impl_def_id, impl_source.args)),
         ImplSource::Param(_) | ImplSource::Builtin(..) => None,
 /// - All of
 ///   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
 ///   - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti`` (excluding `Ti`)
-pub fn check_orphan_rules<'db>(db: &'db dyn HirDatabase, impl_: ImplId) -> bool {
+pub fn check_orphan_rules<'db>(
+    db: &'db dyn HirDatabase,
+    impl_: ImplId,
+) -> bool {
     let Some(impl_trait) = db.impl_trait(impl_) else {
         // not a trait impl
         return true;
     };
-
     let local_crate = impl_.lookup(db).container.krate();
     let is_local = |tgt_crate| tgt_crate == local_crate;
-
     let trait_ref = impl_trait.instantiate_identity();
     let trait_id = trait_ref.def_id.0;
     if is_local(trait_id.module(db).krate()) {
         // trait to be implemented is local
         return true;
     }
-
     let unwrap_fundamental = |mut ty: Ty<'db>| {
         // Unwrap all layers of fundamental types with a loop.
         loop {
         }
     };
     //   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
-
     // FIXME: param coverage
     //   - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti`` (excluding `Ti`)
     let is_not_orphan = trait_ref.args.types().any(|ty| match unwrap_fundamental(ty).kind() {
         traits_in_scope_len = traits_in_scope.len()
     )
     .entered();
-
     match mode {
         LookupMode::MethodCall => {
             // For method calls, rust first does any number of autoderef, and
     callback: &mut dyn MethodCandidateCallback,
 ) -> ControlFlow<()> {
     let interner = table.interner();
-
     let mut iterate_method_candidates_by_receiver = move |receiver_ty, first_adjustment| {
         iterate_method_candidates_by_receiver(
             table,
             callback,
         )
     };
-
     let mut maybe_reborrowed = first_adjustment.clone();
     if let TyKind::Ref(_, _, m) = receiver_ty.value.kind() {
         // Prefer reborrow of references to move
         maybe_reborrowed.autoref = Some(AutorefOrPtrAdjustment::Autoref(m));
         maybe_reborrowed.autoderefs += 1;
     }
-
     iterate_method_candidates_by_receiver(receiver_ty, maybe_reborrowed)?;
-
     let refed = Canonical {
         max_universe: receiver_ty.max_universe,
         variables: receiver_ty.variables,
         value: Ty::new_ref(interner, Region::error(interner), receiver_ty.value, Mutability::Not),
     };
-
     iterate_method_candidates_by_receiver(
         refed,
         first_adjustment.with_autoref(AutorefOrPtrAdjustment::Autoref(Mutability::Not)),
     )?;
-
     let ref_muted = Canonical {
         max_universe: receiver_ty.max_universe,
         variables: receiver_ty.variables,
         value: Ty::new_ref(interner, Region::error(interner), receiver_ty.value, Mutability::Mut),
     };
-
     iterate_method_candidates_by_receiver(
         ref_muted,
         first_adjustment.with_autoref(AutorefOrPtrAdjustment::Autoref(Mutability::Mut)),
     )?;
-
     if let TyKind::RawPtr(ty, Mutability::Mut) = receiver_ty.value.kind() {
         let const_ptr_ty = rustc_type_ir::Canonical {
             max_universe: rustc_type_ir::UniverseIndex::ZERO,
             first_adjustment.with_autoref(AutorefOrPtrAdjustment::ToConstPtr),
         )?;
     }
-
     ControlFlow::Continue(())
 }
 
 
 impl<F> MethodCandidateCallback for F
 where
-    F: FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,
-{
+    F: FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>, {
     fn on_inherent_method(
         &mut self,
         adjustments: ReceiverAdjustments,
     callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,
 ) -> ControlFlow<()> {
     let db = table.db;
-
     let canonical_self_ty = table.canonicalize(self_ty);
     let krate = table.trait_env.krate;
-
     'traits: for &t in traits_in_scope {
         let data = db.trait_signature(t);
 
 ) -> ControlFlow<()> {
     let db = table.db;
     let env = table.trait_env.clone();
-
     // For trait object types and placeholder types with trait bounds, the methods of the trait and
     // its super traits are considered inherent methods. This matters because these methods have
     // higher priority than the other traits' methods, which would be considered in
         }
         _ => {}
     }
-
     let def_crates = match def_crates(db, self_ty, env.krate) {
         Some(k) => k,
         None => return ControlFlow::Continue(()),
     };
-
     let (module, mut block) = match visible_from_module {
         VisibleFromModule::Filter(module) => (Some(module), module.containing_block()),
         VisibleFromModule::IncludeBlock(block) => (None, Some(block)),
         VisibleFromModule::None => (None, None),
     };
-
     while let Some(block_id) = block {
         if let Some(impls) = db.inherent_impls_in_block(block_id) {
             impls_for_self_ty(
 
         block = block_def_map(db, block_id).parent().and_then(|module| module.containing_block());
     }
-
     for krate in def_crates {
         let impls = db.inherent_impls_in_crate(krate);
         impls_for_self_ty(
         )?;
     }
     return ControlFlow::Continue(());
-
     #[tracing::instrument(skip_all, fields(name = ?name, visible_from_module, receiver_ty))]
     fn iterate_inherent_trait_methods<'db>(
         self_ty: Ty<'db>,
         }
         ControlFlow::Continue(())
     }
-
     #[tracing::instrument(skip_all, fields(name = ?name, visible_from_module, receiver_ty))]
     fn impls_for_self_ty<'db>(
         impls: &InherentImpls,
     item_name: &Name,
 ) -> IsValidCandidate {
     check_that!(name.is_none_or(|n| n == item_name));
-
     let db = table.db;
     let data = db.function_signature(fn_id);
-
     if let Some(from_module) = visible_from_module
         && !db.assoc_visibility(fn_id.into()).is_visible_from(db, from_module)
     {
         rustc_type_ir::TraitRef::new_from_args(table.infer_ctxt.interner, trait_.into(), args)
             .with_replaced_self_ty(table.infer_ctxt.interner, self_ty);
     let goal = Goal::new(table.infer_ctxt.interner, table.trait_env.env, trait_ref);
-
     table.canonicalize(goal)
 }
 