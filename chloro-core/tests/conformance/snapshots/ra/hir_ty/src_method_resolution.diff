COMPARISON DIFF
============================================================

Original size: 65944 bytes
Chloro size:   65638 bytes
Rustfmt size:  65944 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is concerned with finding methods that a given type provides.
 //! For details about how this works in rustc, see the method lookup page in the
 //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)
 //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.
+
 use std::ops::ControlFlow;
 
 use base_db::Crate;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::{
     FloatTy, IntTy, TypeVisitableExt, UintTy,
-    inherent::{
-        AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _,
-    },
+    inherent::{AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
 };
 use smallvec::{SmallVec, smallvec};
 use stdx::never;
 ];
 
 type TraitFpMap = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Box<[ImplId]>>>;
+
 type TraitFpMapCollector = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>;
 
 /// Trait impls defined or available in some crate.
 
         Self::collect_def_map(db, &mut impls, block_def_map(db, block));
 
-        if impls.is_empty() { None } else { Some(Arc::new(Self::finish(impls))) }
+        if impls.is_empty() {
+            None
+        } else {
+            Some(Arc::new(Self::finish(impls)))
+        }
     }
 
     pub(crate) fn trait_impls_in_deps_query(
 
     fn collect_def_map(db: &dyn HirDatabase, map: &mut TraitFpMapCollector, def_map: &DefMap) {
         for (_module_id, module_data) in def_map.modules() {
+            // To better support custom derives, collect impls in all unnamed const items.
+            // const _: () = { ... };
             for impl_id in module_data.scope.impls() {
                 // Reservation impls should be ignored during trait resolution, so we never need
                 // them during type analysis. See rust-lang/rust#64631 for details.
                 let self_ty_fp = TyFingerprint::for_trait_impl(self_ty.instantiate_identity());
                 map.entry(target_trait).or_default().entry(self_ty_fp).or_default().push(impl_id);
             }
-
-            // To better support custom derives, collect impls in all unnamed const items.
-            // const _: () = { ... };
             for konst in module_data.scope.unnamed_consts() {
                 let body = db.body(konst.into());
                 for (_, block_def_map) in body.blocks(db) {
     }
 
     /// Queries whether `self_ty` has potentially applicable implementations of `trait_`.
-    pub fn has_impls_for_trait_and_self_ty(&self, trait_: TraitId, self_ty: TyFingerprint) -> bool {
+    pub fn has_impls_for_trait_and_self_ty(
+        &self,
+        trait_: TraitId,
+        self_ty: TyFingerprint,
+    ) -> bool {
         self.for_trait_and_self_ty(trait_, self_ty).next().is_some()
     }
 
 
     fn collect_def_map(&mut self, db: &dyn HirDatabase, def_map: &DefMap) {
         for (_module_id, module_data) in def_map.modules() {
+            // To better support custom derives, collect impls in all unnamed const items.
+            // const _: () = { ... };
             for impl_id in module_data.scope.impls() {
                 let data = db.impl_signature(impl_id);
                 if data.target_trait.is_some() {
                     false => self.invalid_impls.push(impl_id),
                 }
             }
-
-            // To better support custom derives, collect impls in all unnamed const items.
-            // const _: () = { ... };
             for konst in module_data.scope.unnamed_consts() {
                 let body = db.body(konst.into());
                 for (_, block_def_map) in body.blocks(db) {
         }
         TyKind::Foreign(alias) => {
             let alias = alias.0;
-            Some(
-                if db
+            Some(if db
                     .type_alias_signature(alias)
                     .flags
-                    .contains(TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL)
-                {
-                    db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::ForeignType(alias))
-                } else {
-                    smallvec![alias.module(db).krate()]
-                },
-            )
+                    .contains(TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL) {
+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::ForeignType(alias))
+            } else {
+                smallvec![alias.module(db).krate()]
+            })
         }
         TyKind::Dynamic(bounds, _) => {
             let trait_id = bounds.principal_def_id()?.0;
-            Some(
-                if db
+            Some(if db
                     .trait_signature(trait_id)
                     .flags
-                    .contains(TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS)
-                {
-                    db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Dyn(trait_id))
-                } else {
-                    smallvec![trait_id.module(db).krate()]
-                },
-            )
+                    .contains(TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS) {
+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Dyn(trait_id))
+            } else {
+                smallvec![trait_id.module(db).krate()]
+            })
         }
         // for primitives, there may be impls in various places (core and alloc
         // mostly). We just check the whole crate graph for crates with impls
     }
 }
 
-// This would be nicer if it just returned an iterator, but that runs into
-// lifetime problems, because we need to borrow temp `CrateImplDefs`.
-// FIXME add a context type here?
 pub(crate) fn iterate_method_candidates<'db, T>(
     ty: &Canonical<'db, Ty<'db>>,
     table: &mut InferenceTable<'db>,
     let selection = infcx.select(&obligation).ok()??;
 
     // Currently, we use a fulfillment context to completely resolve
+
     // all nested obligations. This is because they can inform the
+
     // inference of the impl's type parameters.
+
     let mut ocx = ObligationCtxt::new(infcx);
     let impl_source = selection.map(|obligation| ocx.register_obligation(obligation));
 
     //   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
 
     // FIXME: param coverage
+
     //   - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti`` (excluding `Ti`)
+
     let is_not_orphan = trait_ref.args.types().any(|ty| match unwrap_fundamental(ty).kind() {
         TyKind::Adt(adt_def, _) => is_local(adt_def.def_id().0.module(db).krate()),
         TyKind::Error(_) => true,
         visible_from_module,
         name,
         LookupMode::Path,
-        // the adjustments are not relevant for path lookup
         callback,
     )
 }
             // Note that when we've got a receiver like &S, even if the method
             // we find in the end takes &self, we still do the autoderef step
             // (just as rustc does an autoderef and then autoref again).
-
             // We have to be careful about the order we're looking at candidates
             // in here. Consider the case where we're resolving `it.clone()`
             // where `it: &Vec<_>`. This resolves to the clone method with self
             // before any by-autoref method; it's just that we need to consider
             // the methods by autoderef order of *receiver types*, not *self
             // types*.
-
             table.run_in_snapshot(|table| {
                 let ty = table.instantiate_canonical(*ty);
                 let deref_chain = autoderef_method_receiver(table, ty);
     let env = table.trait_env.clone();
 
     // For trait object types and placeholder types with trait bounds, the methods of the trait and
+
     // its super traits are considered inherent methods. This matters because these methods have
+
     // higher priority than the other traits' methods, which would be considered in
+
     // `iterate_trait_method_candidates()` only after this function.
+
     match self_ty.kind() {
         TyKind::Param(_) => {
             let env = table.trait_env.clone();
             let db = table.db;
             check_that!(receiver_ty.is_none());
             check_that!(name.is_none_or(|n| n == item_name));
-
             if let Some(from_module) = visible_from_module
                 && !db.assoc_visibility(c.into()).is_visible_from(db, from_module)
             {
     match item {
         AssocItemId::FunctionId(fn_id) => {
             let data = db.function_signature(fn_id);
-
             check_that!(name.is_none_or(|n| n == &data.name));
-
             table.run_in_snapshot(|table| {
                 let impl_subst = table.fresh_args_for_item(trait_id.into());
                 let expect_self_ty = impl_subst.type_at(0);
         AssocItemId::ConstId(c) => {
             check_that!(receiver_ty.is_none());
             check_that!(name.is_none_or(|n| db.const_signature(c).name.as_ref() == Some(n)));
-
             IsValidCandidate::Yes
         }
         _ => IsValidCandidate::No,