COMPARISON DIFF
============================================================

Original size: 65944 bytes
Chloro size:   65813 bytes
Rustfmt size:  65944 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is concerned with finding methods that a given type provides.
 //! For details about how this works in rustc, see the method lookup page in the
 //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)
 //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.
+
 use std::ops::ControlFlow;
 
 use base_db::Crate;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::{
     FloatTy, IntTy, TypeVisitableExt, UintTy,
-    inherent::{
-        AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _,
-    },
+    inherent::{AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
 };
 use smallvec::{SmallVec, smallvec};
 use stdx::never;
 ];
 
 type TraitFpMap = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Box<[ImplId]>>>;
+
 type TraitFpMapCollector = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>;
 
 /// Trait impls defined or available in some crate.
 
         Self::collect_def_map(db, &mut impls, block_def_map(db, block));
 
-        if impls.is_empty() { None } else { Some(Arc::new(Self::finish(impls))) }
+        if impls.is_empty() {
+            None
+        } else {
+            Some(Arc::new(Self::finish(impls)))
+        }
     }
 
     pub(crate) fn trait_impls_in_deps_query(
     }
 
     /// Queries whether `self_ty` has potentially applicable implementations of `trait_`.
-    pub fn has_impls_for_trait_and_self_ty(&self, trait_: TraitId, self_ty: TyFingerprint) -> bool {
+    pub fn has_impls_for_trait_and_self_ty(
+        &self,
+        trait_: TraitId,
+        self_ty: TyFingerprint,
+    ) -> bool {
         self.for_trait_and_self_ty(trait_, self_ty).next().is_some()
     }
 
     let mut res = SmallVec::new();
 
     // should pass crate for finger print and do reverse deps
-
     for krate in db.transitive_deps(krate) {
         let impls = db.inherent_impls_in_crate(krate);
         if impls.map.get(&fp).is_some_and(|v| !v.is_empty()) {
         }
         TyKind::Foreign(alias) => {
             let alias = alias.0;
-            Some(
-                if db
+            Some(if db
                     .type_alias_signature(alias)
                     .flags
-                    .contains(TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL)
-                {
-                    db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::ForeignType(alias))
-                } else {
-                    smallvec![alias.module(db).krate()]
-                },
-            )
+                    .contains(TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL) {
+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::ForeignType(alias))
+            } else {
+                smallvec![alias.module(db).krate()]
+            })
         }
         TyKind::Dynamic(bounds, _) => {
             let trait_id = bounds.principal_def_id()?.0;
-            Some(
-                if db
+            Some(if db
                     .trait_signature(trait_id)
                     .flags
-                    .contains(TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS)
-                {
-                    db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Dyn(trait_id))
-                } else {
-                    smallvec![trait_id.module(db).krate()]
-                },
-            )
+                    .contains(TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS) {
+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Dyn(trait_id))
+            } else {
+                smallvec![trait_id.module(db).krate()]
+            })
         }
         // for primitives, there may be impls in various places (core and alloc
         // mostly). We just check the whole crate graph for crates with impls
             }
         }
     };
-    //   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
 
+    //   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
     // FIXME: param coverage
     //   - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti`` (excluding `Ti`)
     let is_not_orphan = trait_ref.args.types().any(|ty| match unwrap_fundamental(ty).kind() {
         visible_from_module,
         name,
         LookupMode::Path,
-        // the adjustments are not relevant for path lookup
         callback,
     )
 }
             // Note that when we've got a receiver like &S, even if the method
             // we find in the end takes &self, we still do the autoderef step
             // (just as rustc does an autoderef and then autoref again).
-
             // We have to be careful about the order we're looking at candidates
             // in here. Consider the case where we're resolving `it.clone()`
             // where `it: &Vec<_>`. This resolves to the clone method with self
             // before any by-autoref method; it's just that we need to consider
             // the methods by autoderef order of *receiver types*, not *self
             // types*.
-
             table.run_in_snapshot(|table| {
                 let ty = table.instantiate_canonical(*ty);
                 let deref_chain = autoderef_method_receiver(table, ty);