COMPARISON DIFF
============================================================

Original size: 65944 bytes
Chloro size:   65774 bytes
Rustfmt size:  65944 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is concerned with finding methods that a given type provides.
 //! For details about how this works in rustc, see the method lookup page in the
 //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)
 //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.
+
 use std::ops::ControlFlow;
 
 use base_db::Crate;
 use hir_def::{
+    nameres::{block_def_map, crate_def_map, DefMap},
+    signatures::{ConstFlags, EnumFlags, FnFlags, StructFlags, TraitFlags, TypeAliasFlags},
     AdtId, AssocItemId, BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup,
     ModuleId, TraitId, TypeAliasId,
-    nameres::{DefMap, block_def_map, crate_def_map},
-    signatures::{ConstFlags, EnumFlags, FnFlags, StructFlags, TraitFlags, TypeAliasFlags},
 };
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_hash::{FxHashMap, FxHashSet};
 use rustc_type_ir::{
+    inherent::{AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
     FloatTy, IntTy, TypeVisitableExt, UintTy,
-    inherent::{
-        AdtDef, BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _,
-    },
 };
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use stdx::never;
 use triomphe::Arc;
 
 use crate::{
-    TraitEnvironment,
     autoderef::{self, AutoderefKind},
     db::HirDatabase,
-    infer::{Adjust, Adjustment, OverloadedDeref, PointerCast, unify::InferenceTable},
+    infer::{unify::InferenceTable, Adjust, Adjustment, OverloadedDeref, PointerCast},
     lang_items::is_box,
     next_solver::{
-        Canonical, DbInterner, ErrorGuaranteed, GenericArgs, Goal, Predicate, Region, SolverDefId,
-        TraitRef, Ty, TyKind, TypingMode,
         infer::{
             DbInternerInferExt, InferCtxt,
             select::ImplSource,
             traits::{Obligation, ObligationCause, PredicateObligation},
         },
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Canonical, DbInterner, ErrorGuaranteed, GenericArgs,
+        Goal, Predicate, Region, SolverDefId, TraitRef, Ty, TyKind, TypingMode,
     },
     traits::next_trait_solve_canonical_in_ctxt,
     utils::all_super_traits,
+    TraitEnvironment,
 };
 
 /// This is used as a key for indexing impls.
 ];
 
 type TraitFpMap = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Box<[ImplId]>>>;
+
 type TraitFpMapCollector = FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>;
 
 /// Trait impls defined or available in some crate.
     }
 
     /// Queries whether `self_ty` has potentially applicable implementations of `trait_`.
-    pub fn has_impls_for_trait_and_self_ty(&self, trait_: TraitId, self_ty: TyFingerprint) -> bool {
+    pub fn has_impls_for_trait_and_self_ty(
+        &self,
+        trait_: TraitId,
+        self_ty: TyFingerprint,
+    ) -> bool {
         self.for_trait_and_self_ty(trait_, self_ty).next().is_some()
     }
 
     let mut res = SmallVec::new();
 
     // should pass crate for finger print and do reverse deps
-
     for krate in db.transitive_deps(krate) {
         let impls = db.inherent_impls_in_crate(krate);
         if impls.map.get(&fp).is_some_and(|v| !v.is_empty()) {
     }
 }
 
-// This would be nicer if it just returned an iterator, but that runs into
-// lifetime problems, because we need to borrow temp `CrateImplDefs`.
-// FIXME add a context type here?
 pub(crate) fn iterate_method_candidates<'db, T>(
     ty: &Canonical<'db, Ty<'db>>,
     table: &mut InferenceTable<'db>,
     name: &Name,
 ) -> Option<(AssocItemId, GenericArgs<'db>)> {
     let (impl_id, impl_subst) = find_matching_impl(infcx, &env, trait_ref)?;
-    let item =
-        impl_id.impl_items(infcx.interner.db).items.iter().find_map(|(n, it)| match *it {
+    let item = impl_id.impl_items(infcx.interner.db).items.iter().find_map(|(n, it)| match *it {
             AssocItemId::FunctionId(f) => (n == name).then_some(AssocItemId::FunctionId(f)),
             AssocItemId::ConstId(c) => (n == name).then_some(AssocItemId::ConstId(c)),
             AssocItemId::TypeAliasId(_) => None,
     env: &TraitEnvironment<'db>,
     trait_ref: TraitRef<'db>,
 ) -> Option<(ImplId, GenericArgs<'db>)> {
-    let trait_ref =
-        infcx.at(&ObligationCause::dummy(), env.env).deeply_normalize(trait_ref).ok()?;
+    let trait_ref = infcx.at(&ObligationCause::dummy(), env.env).deeply_normalize(trait_ref).ok()?;
 
     let obligation = Obligation::new(infcx.interner, ObligationCause::dummy(), env.env, trait_ref);
 
     let selection = infcx.select(&obligation).ok()??;
 
     // Currently, we use a fulfillment context to completely resolve
+
     // all nested obligations. This is because they can inform the
+
     // inference of the impl's type parameters.
     let mut ocx = ObligationCtxt::new(infcx);
     let impl_source = selection.map(|obligation| ocx.register_obligation(obligation));
     //   - At least one of the types `T0..=Tn`` must be a local type. Let `Ti`` be the first such type.
 
     // FIXME: param coverage
+
     //   - No uncovered type parameters `P1..=Pn` may appear in `T0..Ti`` (excluding `Ti`)
-    let is_not_orphan = trait_ref.args.types().any(|ty| match unwrap_fundamental(ty).kind() {
+    let is_not_orphan = trait_ref.args
+        .types()
+        .any(|ty| match unwrap_fundamental(ty).kind() {
         TyKind::Adt(adt_def, _) => is_local(adt_def.def_id().0.module(db).krate()),
         TyKind::Error(_) => true,
         TyKind::Dynamic(it, _) => {
         ?name,
         traits_in_scope_len = traits_in_scope.len()
     )
-    .entered();
+        .entered();
 
     match mode {
         LookupMode::MethodCall => {
     let env = table.trait_env.clone();
 
     // For trait object types and placeholder types with trait bounds, the methods of the trait and
+
     // its super traits are considered inherent methods. This matters because these methods have
+
     // higher priority than the other traits' methods, which would be considered in
+
     // `iterate_trait_method_candidates()` only after this function.
     match self_ty.kind() {
         TyKind::Param(_) => {
 ) -> Canonical<'db, Goal<'db, Predicate<'db>>> {
     let args = table.infer_ctxt.fresh_args_for_item(SolverDefId::TraitId(trait_));
     let self_ty = table.instantiate_canonical(self_ty);
-    let trait_ref =
-        rustc_type_ir::TraitRef::new_from_args(table.infer_ctxt.interner, trait_.into(), args)
-            .with_replaced_self_ty(table.infer_ctxt.interner, self_ty);
+    let trait_ref = rustc_type_ir::TraitRef::new_from_args(table.infer_ctxt.interner, trait_.into(), args)
+        .with_replaced_self_ty(table.infer_ctxt.interner, self_ty);
     let goal = Goal::new(table.infer_ctxt.interner, table.trait_env.env, trait_ref);
 
     table.canonicalize(goal)