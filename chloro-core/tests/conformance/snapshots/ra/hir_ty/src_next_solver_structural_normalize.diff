COMPARISON DIFF
============================================================

Original size: 1977 bytes
Chloro size:   1980 bytes
Rustfmt size:  2003 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use rustc_type_ir::{inherent::Term as _, AliasRelationDirection};
+use rustc_type_ir::{AliasRelationDirection, inherent::Term as _};
 
 use crate::next_solver::{
+    Const, PredicateKind, Term, Ty,
     fulfill::{FulfillmentCtxt, NextSolverError},
     infer::{at::At, traits::Obligation},
-    Const, PredicateKind, Term, Ty,
 };
 
 impl<'db> At<'_, 'db> {
         ty: Ty<'db>,
         fulfill_cx: &mut FulfillmentCtxt<'db>,
     ) -> Result<Ty<'db>, Vec<NextSolverError<'db>>> {
-        self.structurally_normalize_term(ty.into(), fulfill_cx)
-            .map(|term| term.expect_type())
+        self.structurally_normalize_term(ty.into(), fulfill_cx).map(|term| term.expect_type())
     }
 
     pub(crate) fn structurally_normalize_const(
         ct: Const<'db>,
         fulfill_cx: &mut FulfillmentCtxt<'db>,
     ) -> Result<Const<'db>, Vec<NextSolverError<'db>>> {
-        self.structurally_normalize_term(ct.into(), fulfill_cx)
-            .map(|term| term.expect_const())
+        self.structurally_normalize_term(ct.into(), fulfill_cx).map(|term| term.expect_const())
     }
 
     pub(crate) fn structurally_normalize_term(
         let new_infer = self.infcx.next_term_var_of_kind(term);
 
         // We simply emit an `alias-eq` goal here, since that will take care of
+
         // normalizing the LHS of the projection until it is a rigid projection
+
         // (or a not-yet-defined opaque in scope).
+
         let obligation = Obligation::new(
             self.infcx.interner,
             self.cause.clone(),