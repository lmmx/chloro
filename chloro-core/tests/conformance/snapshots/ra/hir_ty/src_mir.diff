COMPARISON DIFF
============================================================

Original size: 49552 bytes
Chloro size:   49318 bytes
Rustfmt size:  50490 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! MIR definitions and implementation
 
+mod borrowck;
+mod eval;
+mod lower;
+mod monomorphization;
+mod pretty;
+
 use std::{collections::hash_map::Entry, fmt::Display, iter};
 
 use base_db::Crate;
+pub use borrowck::{BorrowckResult, MutabilityReason, borrowck_query};
 use either::Either;
+pub use eval::{
+    interpret_mir, pad16, render_const_using_debug_impl, Evaluator, MirEvalError, VTableMap,
+};
 use hir_def::{
     expr_store::Body,
     hir::{BindingAnnotation, BindingId, Expr, ExprId, Ordering, PatId},
     DefWithBodyId, FieldId, StaticId, TupleFieldId, UnionId, VariantId,
 };
 use la_arena::{Arena, ArenaMap, Idx, RawIdx};
+pub(crate) use lower::mir_body_cycle_result;
+pub use lower::{MirLowerError, lower_to_mir, mir_body_for_closure_query, mir_body_query};
+pub(crate) use monomorphization::monomorphized_mir_body_cycle_result;
+pub use monomorphization::{
+    monomorphized_mir_body_for_closure_query, monomorphized_mir_body_query,
+};
 use rustc_ast_ir::Mutability;
 use rustc_hash::FxHashMap;
 use rustc_type_ir::inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Ty as _};
-use smallvec::{smallvec, SmallVec};
+use smallvec::{SmallVec, smallvec};
 use stdx::{impl_from, never};
 
 use crate::{
     infer::PointerCast,
     lang_items::is_box,
     next_solver::{
-        infer::{traits::ObligationCause, InferCtxt},
-        obligation_ctxt::ObligationCtxt,
-        Const, DbInterner, ErrorGuaranteed, GenericArgs, ParamEnv, Ty, TyKind,
+        infer::{InferCtxt, traits::ObligationCause}, obligation_ctxt::ObligationCtxt, Const,
+        DbInterner, ErrorGuaranteed, GenericArgs, ParamEnv, Ty, TyKind,
     },
     CallableDefId, InferenceResult, MemoryMap,
 };
-
-mod borrowck;
-mod eval;
-mod lower;
-mod monomorphization;
-mod pretty;
-
-pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};
-pub use eval::{
-    interpret_mir, pad16, render_const_using_debug_impl, Evaluator, MirEvalError, VTableMap,
-};
-pub use lower::{lower_to_mir, mir_body_for_closure_query, mir_body_query, MirLowerError};
-pub use monomorphization::{
-    monomorphized_mir_body_for_closure_query, monomorphized_mir_body_query,
-};
-
-pub(crate) use lower::mir_body_cycle_result;
-pub(crate) use monomorphization::monomorphized_mir_body_cycle_result;
-
 use super::consteval::try_const_usize;
 
 pub type BasicBlockId<'db> = Idx<BasicBlock<'db>>;
+
 pub type LocalId<'db> = Idx<Local<'db>>;
 
 fn return_slot<'db>() -> LocalId<'db> {
     /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188
     Move(Place<'db>),
     /// Constants are already semantically values, and remain unchanged.
-    Constant { konst: Const<'db>, ty: Ty<'db> },
+    Constant {
+        konst: Const<'db>,
+        ty: Ty<'db>,
+    },
     /// NON STANDARD: This kind of operand returns an immutable reference to that static memory. Rustc
     /// handles it with the `Constant` variant somehow.
     Static(StaticId),
         generic_args: GenericArgs<'db>,
     ) -> Operand<'db> {
         let interner = DbInterner::new_with(db, None, None);
-        let ty = Ty::new_fn_def(
-            interner,
-            CallableDefId::FunctionId(func_id).into(),
-            generic_args,
-        );
+        let ty = Ty::new_fn_def(interner, CallableDefId::FunctionId(func_id).into(), generic_args);
         Operand::from_bytes(Box::default(), ty)
     }
 }
     // FIXME: get rid of this, and use FieldId for tuples and closures
     ClosureField(usize),
     Index(V),
-    ConstantIndex { offset: u64, from_end: bool },
-    Subslice { from: u64, to: u64 },
+    ConstantIndex {
+        offset: u64,
+        from_end: bool,
+    },
+    Subslice {
+        from: u64,
+        to: u64,
+    },
     //Downcast(Option<Symbol>, VariantIdx),
     OpaqueCast(T),
 }
         let db = interner.db;
 
         // we only bail on mir building when there are type mismatches
+
         // but error types may pop up resulting in us still attempting to build the mir
+
         // so just propagate the error type
         if base.is_ty_error() {
             return Ty::new_error(interner, ErrorGuaranteed);
                 }
             },
             ProjectionElem::Field(Either::Right(f)) => match base.kind() {
-                TyKind::Tuple(subst) => subst
-                    .as_slice()
-                    .get(f.index as usize)
-                    .copied()
-                    .unwrap_or_else(|| {
+                TyKind::Tuple(subst) => {
+                    subst.as_slice().get(f.index as usize).copied().unwrap_or_else(|| {
                         never!("Out of bound tuple field");
                         Ty::new_error(interner, ErrorGuaranteed)
-                    }),
+                    })
+                }
                 ty => {
                     never!("Only tuple has tuple field: {:?}", ty);
                     Ty::new_error(interner, ErrorGuaranteed)
 
 impl Default for ProjectionStore<'_> {
     fn default() -> Self {
-        let mut this = Self {
-            id_to_proj: Default::default(),
-            proj_to_id: Default::default(),
-        };
+        let mut this = Self { id_to_proj: Default::default(), proj_to_id: Default::default() };
         // Ensure that [] will get the id 0 which is used in `ProjectionId::Empty`
         this.intern(Box::new([]));
         this
 impl<'db> Place<'db> {
     fn is_parent(&self, child: &Place<'db>, store: &ProjectionStore<'db>) -> bool {
         self.local == child.local
-            && child
-                .projection
-                .lookup(store)
-                .starts_with(self.projection.lookup(store))
+            && child.projection.lookup(store).starts_with(self.projection.lookup(store))
     }
 
     /// The place itself is not included
         store: &'a ProjectionStore<'db>,
     ) -> impl Iterator<Item = Place<'db>> + 'a {
         let projection = self.projection.lookup(store);
-        (0..projection.len())
-            .map(|x| &projection[0..x])
-            .filter_map(move |x| {
-                Some(Place {
-                    local: self.local,
-                    projection: store.intern_if_exist(x)?,
-                })
-            })
+        (0..projection.len()).map(|x| &projection[0..x]).filter_map(move |x| {
+            Some(Place { local: self.local, projection: store.intern_if_exist(x)? })
+        })
     }
 
     fn project(&self, projection: PlaceElem<'db>, store: &mut ProjectionStore<'db>) -> Place<'db> {
 
 impl<'db> From<LocalId<'db>> for Place<'db> {
     fn from(local: LocalId<'db>) -> Self {
-        Self {
-            local,
-            projection: ProjectionId::EMPTY,
-        }
+        Self { local, projection: ProjectionId::EMPTY }
     }
 }
 
     Adt(VariantId, GenericArgs<'db>),
     Union(UnionId, FieldId),
     Closure(Ty<'db>),
-    //Coroutine(LocalDefId, SubstsRef, Movability),
 }
 
 #[derive(Debug, Clone, Hash, PartialEq, Eq)]
     /// Possible values. The locations to branch to in each case
     /// are found in the corresponding indices from the `targets` vector.
     values: SmallVec<[u128; 1]>,
-
-    /// Possible branch sites. The last element of this vector is used
-    /// for the otherwise branch, so targets.len() == values.len() + 1
-    /// should hold.
     //
     // This invariant is quite non-obvious and also could be improved.
     // One way to make this invariant is to have something like this instead:
     //
     // However we’ve decided to keep this as-is until we figure a case
     // where some other approach seems to be strictly better than other.
+    /// Possible branch sites. The last element of this vector is used
+    /// for the otherwise branch, so targets.len() == values.len() + 1
+    /// should hold.
     targets: SmallVec<[BasicBlockId<'db>; 2]>,
 }
 
     /// specific value. This cannot fail, as it'll return the `otherwise`
     /// branch if there's not a specific match for the value.
     pub fn target_for_value(&self, value: u128) -> BasicBlockId<'db> {
-        self.iter()
-            .find_map(|(v, t)| (v == value).then_some(t))
-            .unwrap_or_else(|| self.otherwise())
+        self.iter().find_map(|(v, t)| (v == value).then_some(t)).unwrap_or_else(|| self.otherwise())
     }
 }
 
 #[derive(Debug, PartialEq, Eq, Clone)]
 pub enum TerminatorKind<'db> {
     /// Block has one successor; we continue execution there.
-    Goto { target: BasicBlockId<'db> },
+    Goto {
+        target: BasicBlockId<'db>,
+    },
 
     /// Switches based on the computed value.
     ///
     SwitchInt {
         /// The discriminant value being tested.
         discr: Operand<'db>,
-
         targets: SwitchTargets<'db>,
     },
 
         /// `true` if this is from a call in HIR rather than from an overloaded
         /// operator. True for overloaded function call.
         from_hir_call: bool,
-        // This `Span` is the span of the function, without the dot and receiver
-        // (e.g. `foo(a, b)` in `x.foo(a, b)`
-        //fn_span: Span,
     },
 
     /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,
     },
 }
 
-// Order of variants in this enum matter: they are used to compare borrow kinds.
 #[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Ord)]
 pub enum BorrowKind {
     /// Data must be immutable and is aliasable.
     Shallow,
 
     /// Data is mutable and not aliasable.
-    Mut { kind: MutBorrowKind },
+    Mut {
+        kind: MutBorrowKind,
+    },
 }
 
-// Order of variants in this enum matter: they are used to compare borrow kinds.
 #[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Ord)]
 pub enum MutBorrowKind {
     /// Data must be immutable but not aliasable. This kind of borrow cannot currently
     fn from_hir(m: hir_def::type_ref::Mutability) -> Self {
         match m {
             hir_def::type_ref::Mutability::Shared => BorrowKind::Shared,
-            hir_def::type_ref::Mutability::Mut => BorrowKind::Mut {
-                kind: MutBorrowKind::Default,
-            },
+            hir_def::type_ref::Mutability::Mut => BorrowKind::Mut { kind: MutBorrowKind::Default },
         }
     }
 
     fn from_rustc(m: rustc_ast_ir::Mutability) -> Self {
         match m {
             rustc_ast_ir::Mutability::Not => BorrowKind::Shared,
-            rustc_ast_ir::Mutability::Mut => BorrowKind::Mut {
-                kind: MutBorrowKind::Default,
-            },
+            rustc_ast_ir::Mutability::Mut => BorrowKind::Mut { kind: MutBorrowKind::Default },
         }
     }
 }
         match value {
             hir_def::hir::CmpOp::Eq { negated: false } => BinOp::Eq,
             hir_def::hir::CmpOp::Eq { negated: true } => BinOp::Ne,
-            hir_def::hir::CmpOp::Ord {
-                ordering: Ordering::Greater,
-                strict: false,
-            } => BinOp::Ge,
-            hir_def::hir::CmpOp::Ord {
-                ordering: Ordering::Greater,
-                strict: true,
-            } => BinOp::Gt,
-            hir_def::hir::CmpOp::Ord {
-                ordering: Ordering::Less,
-                strict: false,
-            } => BinOp::Le,
-            hir_def::hir::CmpOp::Ord {
-                ordering: Ordering::Less,
-                strict: true,
-            } => BinOp::Lt,
+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Greater, strict: false } => BinOp::Ge,
+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Greater, strict: true } => BinOp::Gt,
+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Less, strict: false } => BinOp::Le,
+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Less, strict: true } => BinOp::Lt,
         }
     }
 }
     /// `Shallow` borrows are disallowed after drop lowering.
     Ref(BorrowKind, Place<'db>),
 
+    // ThreadLocalRef(DefId),
     /// Creates a pointer/reference to the given thread local.
     ///
     /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a
     ///
     /// **Needs clarification**: Are there weird additional semantics here related to the runtime
     /// nature of this operation?
-    // ThreadLocalRef(DefId),
     ThreadLocalRef(std::convert::Infallible),
 
+    // AddressOf(Mutability, Place),
     /// Creates a pointer with the indicated mutability to the place.
     ///
     /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like
     ///
     /// Like with references, the semantics of this operation are heavily dependent on the aliasing
     /// model.
-    // AddressOf(Mutability, Place),
     AddressOf(std::convert::Infallible),
 
     /// Yields the length of the place, as a `usize`.
     Cast(CastKind, Operand<'db>, Ty<'db>),
 
     // FIXME link to `pointer::offset` when it hits stable.
+    //BinaryOp(BinOp, Box<(Operand, Operand)>),
     /// * `Offset` has the same semantics as `pointer::offset`, except that the second
     ///   parameter may be a `usize` as well.
     /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,
     ///   types and return a value of that type.
     /// * The remaining operations accept signed integers, unsigned integers, or floats with
     ///   matching types and return a value of that type.
-    //BinaryOp(BinOp, Box<(Operand, Operand)>),
     BinaryOp(std::convert::Infallible),
 
     /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.
     /// Other combinations of types and operators are unsupported.
     CheckedBinaryOp(BinOp, Operand<'db>, Operand<'db>),
 
-    /// Computes a value as described by the operation.
     //NullaryOp(NullOp, Ty),
+    /// Computes a value as described by the operation.
     NullaryOp(std::convert::Infallible),
 
     /// Exactly like `BinaryOp`, but less operands.
     //Intrinsic(Box<NonDivergingIntrinsic>),
     Nop,
 }
+
 impl<'db> StatementKind<'db> {
     fn with_span(self, span: MirSpan) -> Statement<'db> {
         Statement { kind: self, span }
 pub struct BasicBlock<'db> {
     /// List of statements in this block.
     pub statements: Vec<Statement<'db>>,
-
     /// Terminator for this block.
     ///
     /// N.B., this should generally ONLY be `None` during construction.
     /// out the terminator temporarily with `None` while they continue
     /// to recurse over the set of basic blocks.
     pub terminator: Option<Terminator<'db>>,
-
     /// If true, this block lies on an unwind path. This is used
     /// during codegen where distinct kinds of basic blocks may be
     /// generated (particularly for MSVC cleanup). Unwind blocks must
                         f(place, &mut self.projection_store);
                         for_operand(value, &mut f, &mut self.projection_store);
                     }
-                    TerminatorKind::Call {
-                        func,
-                        args,
-                        destination,
-                        ..
-                    } => {
+                    TerminatorKind::Call { func, args, destination, .. } => {
                         for_operand(func, &mut f, &mut self.projection_store);
                         args.iter_mut()
                             .for_each(|x| for_operand(x, &mut f, &mut self.projection_store));
                     TerminatorKind::Assert { cond, .. } => {
                         for_operand(cond, &mut f, &mut self.projection_store);
                     }
-                    TerminatorKind::Yield {
-                        value, resume_arg, ..
-                    } => {
+                    TerminatorKind::Yield { value, resume_arg, .. } => {
                         for_operand(value, &mut f, &mut self.projection_store);
                         f(resume_arg, &mut self.projection_store);
                     }
         param_locals.shrink_to_fit();
         closures.shrink_to_fit();
         for (_, b) in basic_blocks.iter_mut() {
-            let BasicBlock {
-                statements,
-                terminator: _,
-                is_cleanup: _,
-            } = b;
+            let BasicBlock { statements, terminator: _, is_cleanup: _ } = b;
             statements.shrink_to_fit();
         }
     }
             MirSpan::ExprId(expr) => matches!(body[expr], Expr::Ref { .. }),
             // FIXME: Figure out if this is correct wrt. match ergonomics.
             MirSpan::BindingId(binding) => {
-                matches!(
-                    body[binding].mode,
-                    BindingAnnotation::Ref | BindingAnnotation::RefMut
-                )
+                matches!(body[binding].mode, BindingAnnotation::Ref | BindingAnnotation::RefMut)
             }
             MirSpan::PatId(_) | MirSpan::SelfParam | MirSpan::Unknown => false,
         }
     }
 }
-
-impl_from!(ExprId, PatId for MirSpan);
-
 impl From<&ExprId> for MirSpan {
     fn from(value: &ExprId) -> Self {
         (*value).into()