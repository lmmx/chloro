COMPARISON DIFF
============================================================

Original size: 49552 bytes
Chloro size:   48513 bytes
Rustfmt size:  50490 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! MIR definitions and implementation
 
-use std::{collections::hash_map::Entry, fmt::Display, iter};
-
-use base_db::Crate;
-use either::Either;
-use hir_def::{
-    expr_store::Body,
-    hir::{BindingAnnotation, BindingId, Expr, ExprId, Ordering, PatId},
-    DefWithBodyId, FieldId, StaticId, TupleFieldId, UnionId, VariantId,
-};
-use la_arena::{Arena, ArenaMap, Idx, RawIdx};
-use rustc_ast_ir::Mutability;
-use rustc_hash::FxHashMap;
-use rustc_type_ir::inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Ty as _};
-use smallvec::{smallvec, SmallVec};
-use stdx::{impl_from, never};
-
-use crate::{
-    consteval::usize_const,
-    db::{HirDatabase, InternedClosureId},
-    display::{DisplayTarget, HirDisplay},
-    infer::PointerCast,
-    lang_items::is_box,
-    next_solver::{
-        infer::{traits::ObligationCause, InferCtxt},
-        obligation_ctxt::ObligationCtxt,
-        Const, DbInterner, ErrorGuaranteed, GenericArgs, ParamEnv, Ty, TyKind,
-    },
-    CallableDefId, InferenceResult, MemoryMap,
-};
-
 mod borrowck;
 mod eval;
 mod lower;
 mod monomorphization;
 mod pretty;
 
-pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};
+use std::{collections::hash_map::Entry, fmt::Display, iter};
+
+use base_db::Crate;
+pub use borrowck::{BorrowckResult, MutabilityReason, borrowck_query};
+use either::Either;
 pub use eval::{
-    interpret_mir, pad16, render_const_using_debug_impl, Evaluator, MirEvalError, VTableMap,
+    Evaluator, MirEvalError, VTableMap, interpret_mir, pad16, render_const_using_debug_impl,
 };
-pub use lower::{lower_to_mir, mir_body_for_closure_query, mir_body_query, MirLowerError};
+use hir_def::{
+    DefWithBodyId, FieldId, StaticId, TupleFieldId, UnionId, VariantId,
+    expr_store::Body,
+    hir::{BindingAnnotation, BindingId, Expr, ExprId, Ordering, PatId},
+};
+use la_arena::{Arena, ArenaMap, Idx, RawIdx};
+pub(crate) use lower::mir_body_cycle_result;
+pub use lower::{MirLowerError, lower_to_mir, mir_body_for_closure_query, mir_body_query};
+pub(crate) use monomorphization::monomorphized_mir_body_cycle_result;
 pub use monomorphization::{
     monomorphized_mir_body_for_closure_query, monomorphized_mir_body_query,
 };
+use rustc_ast_ir::Mutability;
+use rustc_hash::FxHashMap;
+use rustc_type_ir::inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Ty as _};
+use smallvec::{SmallVec, smallvec};
+use stdx::{impl_from, never};
 
-pub(crate) use lower::mir_body_cycle_result;
-pub(crate) use monomorphization::monomorphized_mir_body_cycle_result;
-
+use crate::{
+    CallableDefId, InferenceResult, MemoryMap,
+    consteval::usize_const,
+    db::{HirDatabase, InternedClosureId},
+    display::{DisplayTarget, HirDisplay},
+    infer::PointerCast,
+    lang_items::is_box,
+    next_solver::{
+        Const, DbInterner, ErrorGuaranteed, GenericArgs, ParamEnv, Ty, TyKind,
+        infer::{InferCtxt, traits::ObligationCause},
+        obligation_ctxt::ObligationCtxt,
+    },
+};
 use super::consteval::try_const_usize;
 
 pub type BasicBlockId<'db> = Idx<BasicBlock<'db>>;
+
 pub type LocalId<'db> = Idx<Local<'db>>;
 
 fn return_slot<'db>() -> LocalId<'db> {
 #[derive(Debug, PartialEq, Eq, Clone)]
 pub struct Operand<'db> {
     kind: OperandKind<'db>,
-    // FIXME : This should actually just be of type `MirSpan`.
     span: Option<MirSpan>,
 }
 
     /// Before drop elaboration, the type of the place must be `Copy`. After drop elaboration there
     /// is no such requirement.
     Copy(Place<'db>),
-
     /// Creates a value by performing loading the place, just like the `Copy` operand.
     ///
     /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide
     /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188
     Move(Place<'db>),
     /// Constants are already semantically values, and remain unchanged.
-    Constant { konst: Const<'db>, ty: Ty<'db> },
+    Constant {
+        konst: Const<'db>,
+        ty: Ty<'db>,
+    },
     /// NON STANDARD: This kind of operand returns an immutable reference to that static memory. Rustc
     /// handles it with the `Constant` variant somehow.
     Static(StaticId),
 }
 
 impl<'db> Operand<'db> {
-    fn from_concrete_const(data: Box<[u8]>, memory_map: MemoryMap<'db>, ty: Ty<'db>) -> Self {
+    fn from_concrete_const(
+        data: Box<[u8]>,
+        memory_map: MemoryMap<'db>,
+        ty: Ty<'db>,
+    ) -> Self {
         let interner = DbInterner::conjure();
         Operand {
             kind: OperandKind::Constant {
         }
     }
 
-    fn from_bytes(data: Box<[u8]>, ty: Ty<'db>) -> Self {
+    fn from_bytes(
+        data: Box<[u8]>,
+        ty: Ty<'db>,
+    ) -> Self {
         Operand::from_concrete_const(data, MemoryMap::default(), ty)
     }
 
         generic_args: GenericArgs<'db>,
     ) -> Operand<'db> {
         let interner = DbInterner::new_with(db, None, None);
-        let ty = Ty::new_fn_def(
-            interner,
-            CallableDefId::FunctionId(func_id).into(),
-            generic_args,
-        );
+        let ty = Ty::new_fn_def(interner, CallableDefId::FunctionId(func_id).into(), generic_args);
         Operand::from_bytes(Box::default(), ty)
     }
 }
 pub enum ProjectionElem<V, T> {
     Deref,
     Field(Either<FieldId, TupleFieldId>),
-    // FIXME: get rid of this, and use FieldId for tuples and closures
     ClosureField(usize),
     Index(V),
-    ConstantIndex { offset: u64, from_end: bool },
-    Subslice { from: u64, to: u64 },
-    //Downcast(Option<Symbol>, VariantIdx),
+    ConstantIndex {
+        offset: u64,
+        from_end: bool,
+    },
+    Subslice {
+        from: u64,
+        to: u64,
+    },
     OpaqueCast(T),
 }
 
     ) -> Ty<'db> {
         let interner = infcx.interner;
         let db = interner.db;
-
         // we only bail on mir building when there are type mismatches
         // but error types may pop up resulting in us still attempting to build the mir
         // so just propagate the error type
         if base.is_ty_error() {
             return Ty::new_error(interner, ErrorGuaranteed);
         }
-
         if matches!(base.kind(), TyKind::Alias(..)) {
             let mut ocx = ObligationCtxt::new(infcx);
             // FIXME: we should get this from caller
                 Err(_) => return Ty::new_error(interner, ErrorGuaranteed),
             }
         }
-
         match self {
             ProjectionElem::Deref => match base.kind() {
                 TyKind::RawPtr(inner, _) | TyKind::Ref(_, inner, _) => inner,
                 }
             },
             ProjectionElem::Field(Either::Right(f)) => match base.kind() {
-                TyKind::Tuple(subst) => subst
-                    .as_slice()
-                    .get(f.index as usize)
-                    .copied()
-                    .unwrap_or_else(|| {
+                TyKind::Tuple(subst) => {
+                    subst.as_slice().get(f.index as usize).copied().unwrap_or_else(|| {
                         never!("Out of bound tuple field");
                         Ty::new_error(interner, ErrorGuaranteed)
-                    }),
+                    })
+                }
                 ty => {
                     never!("Only tuple has tuple field: {:?}", ty);
                     Ty::new_error(interner, ErrorGuaranteed)
 
 impl Default for ProjectionStore<'_> {
     fn default() -> Self {
-        let mut this = Self {
-            id_to_proj: Default::default(),
-            proj_to_id: Default::default(),
-        };
+        let mut this = Self { id_to_proj: Default::default(), proj_to_id: Default::default() };
         // Ensure that [] will get the id 0 which is used in `ProjectionId::Empty`
         this.intern(Box::new([]));
         this
         self.proj_to_id.shrink_to_fit();
     }
 
-    pub fn intern_if_exist(&self, projection: &[PlaceElem<'db>]) -> Option<ProjectionId> {
+    pub fn intern_if_exist(
+        &self,
+        projection: &[PlaceElem<'db>],
+    ) -> Option<ProjectionId> {
         self.proj_to_id.get(projection).copied()
     }
 
-    pub fn intern(&mut self, projection: Box<[PlaceElem<'db>]>) -> ProjectionId {
+    pub fn intern(
+        &mut self,
+        projection: Box<[PlaceElem<'db>]>,
+    ) -> ProjectionId {
         let new_id = ProjectionId(self.proj_to_id.len() as u32);
         match self.proj_to_id.entry(projection) {
             Entry::Occupied(id) => *id.get(),
         self == ProjectionId::EMPTY
     }
 
-    pub fn lookup<'a, 'db>(self, store: &'a ProjectionStore<'db>) -> &'a [PlaceElem<'db>] {
+    pub fn lookup<'a, 'db>(
+        self,
+        store: &'a ProjectionStore<'db>,
+    ) -> &'a [PlaceElem<'db>] {
         store.id_to_proj.get(&self).unwrap()
     }
 
 }
 
 impl<'db> Place<'db> {
-    fn is_parent(&self, child: &Place<'db>, store: &ProjectionStore<'db>) -> bool {
+    fn is_parent(
+        &self,
+        child: &Place<'db>,
+        store: &ProjectionStore<'db>,
+    ) -> bool {
         self.local == child.local
-            && child
-                .projection
-                .lookup(store)
-                .starts_with(self.projection.lookup(store))
+            && child.projection.lookup(store).starts_with(self.projection.lookup(store))
     }
 
     /// The place itself is not included
         store: &'a ProjectionStore<'db>,
     ) -> impl Iterator<Item = Place<'db>> + 'a {
         let projection = self.projection.lookup(store);
-        (0..projection.len())
-            .map(|x| &projection[0..x])
-            .filter_map(move |x| {
-                Some(Place {
-                    local: self.local,
-                    projection: store.intern_if_exist(x)?,
-                })
-            })
+        (0..projection.len()).map(|x| &projection[0..x]).filter_map(move |x| {
+            Some(Place { local: self.local, projection: store.intern_if_exist(x)? })
+        })
     }
 
-    fn project(&self, projection: PlaceElem<'db>, store: &mut ProjectionStore<'db>) -> Place<'db> {
-        Place {
-            local: self.local,
-            projection: self.projection.project(projection, store),
-        }
+    fn project(
+        &self,
+        projection: PlaceElem<'db>,
+        store: &mut ProjectionStore<'db>,
+    ) -> Place<'db> {
+        Place { local: self.local, projection: self.projection.project(projection, store) }
     }
 }
 
 impl<'db> From<LocalId<'db>> for Place<'db> {
     fn from(local: LocalId<'db>) -> Self {
-        Self {
-            local,
-            projection: ProjectionId::EMPTY,
-        }
+        Self { local, projection: ProjectionId::EMPTY }
     }
 }
 
     Adt(VariantId, GenericArgs<'db>),
     Union(UnionId, FieldId),
     Closure(Ty<'db>),
-    //Coroutine(LocalDefId, SubstsRef, Movability),
 }
 
 #[derive(Debug, Clone, Hash, PartialEq, Eq)]
     /// Possible values. The locations to branch to in each case
     /// are found in the corresponding indices from the `targets` vector.
     values: SmallVec<[u128; 1]>,
-
     /// Possible branch sites. The last element of this vector is used
     /// for the otherwise branch, so targets.len() == values.len() + 1
     /// should hold.
-    //
-    // This invariant is quite non-obvious and also could be improved.
-    // One way to make this invariant is to have something like this instead:
-    //
-    // branches: Vec<(ConstInt, BasicBlock)>,
-    // otherwise: Option<BasicBlock> // exhaustive if None
-    //
-    // However we’ve decided to keep this as-is until we figure a case
-    // where some other approach seems to be strictly better than other.
     targets: SmallVec<[BasicBlockId<'db>; 2]>,
 }
 
 
     /// Builds a switch targets definition that jumps to `then` if the tested value equals `value`,
     /// and to `else_` if not.
-    pub fn static_if(value: u128, then: BasicBlockId<'db>, else_: BasicBlockId<'db>) -> Self {
-        Self {
-            values: smallvec![value],
-            targets: smallvec![then, else_],
-        }
+    pub fn static_if(
+        value: u128,
+        then: BasicBlockId<'db>,
+        else_: BasicBlockId<'db>,
+    ) -> Self {
+        Self { values: smallvec![value], targets: smallvec![then, else_] }
     }
 
     /// Returns the fallback target that is jumped to when none of the values match the operand.
     /// Finds the `BasicBlock` to which this `SwitchInt` will branch given the
     /// specific value. This cannot fail, as it'll return the `otherwise`
     /// branch if there's not a specific match for the value.
-    pub fn target_for_value(&self, value: u128) -> BasicBlockId<'db> {
-        self.iter()
-            .find_map(|(v, t)| (v == value).then_some(t))
-            .unwrap_or_else(|| self.otherwise())
+    pub fn target_for_value(
+        &self,
+        value: u128,
+    ) -> BasicBlockId<'db> {
+        self.iter().find_map(|(v, t)| (v == value).then_some(t)).unwrap_or_else(|| self.otherwise())
     }
 }
 
 #[derive(Debug, PartialEq, Eq, Clone)]
 pub enum TerminatorKind<'db> {
     /// Block has one successor; we continue execution there.
-    Goto { target: BasicBlockId<'db> },
-
+    Goto {
+        target: BasicBlockId<'db>,
+    },
     /// Switches based on the computed value.
     ///
     /// First, evaluates the `discr` operand. The type of the operand must be a signed or unsigned
     SwitchInt {
         /// The discriminant value being tested.
         discr: Operand<'db>,
-
         targets: SwitchTargets<'db>,
     },
-
     /// Indicates that the landing pad is finished and that the process should continue unwinding.
     ///
     /// Like a return, this marks the end of this invocation of the function.
     /// Only permitted in cleanup blocks. `Resume` is not permitted with `-C unwind=abort` after
     /// deaggregation runs.
     UnwindResume,
-
     /// Indicates that the landing pad is finished and that the process should abort.
     ///
     /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in
     /// cleanup blocks.
     Abort,
-
     /// Returns from the function.
     ///
     /// Like function calls, the exact semantics of returns in Rust are unclear. Returning very
     /// `CoroutineState::Returned(_0)` to be created (as if by an `Aggregate` rvalue) and assigned
     /// to the return place.
     Return,
-
     /// Indicates a terminator that can never be reached.
     ///
     /// Executing this terminator is UB.
     Unreachable,
-
     /// The behavior of this statement differs significantly before and after drop elaboration.
     /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which
     /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop
         target: BasicBlockId<'db>,
         unwind: Option<BasicBlockId<'db>>,
     },
-
     /// Drops the place and assigns a new value to it.
     ///
     /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;
         target: BasicBlockId<'db>,
         unwind: Option<BasicBlockId<'db>>,
     },
-
     /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of
     /// the referred to function. The operand types must match the argument types of the function.
     /// The return place type must match the return type. The type of the `func` operand must be
         /// `true` if this is from a call in HIR rather than from an overloaded
         /// operator. True for overloaded function call.
         from_hir_call: bool,
-        // This `Span` is the span of the function, without the dot and receiver
-        // (e.g. `foo(a, b)` in `x.foo(a, b)`
-        //fn_span: Span,
     },
-
     /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,
     /// initiates a panic. Initiating a panic corresponds to a `Call` terminator with some
     /// unspecified constant as the function to call, all the operands stored in the `AssertMessage`
     Assert {
         cond: Operand<'db>,
         expected: bool,
-        //msg: AssertMessage,
         target: BasicBlockId<'db>,
         cleanup: Option<BasicBlockId<'db>>,
     },
-
     /// Marks a suspend point.
     ///
     /// Like `Return` terminators in coroutine bodies, this computes `value` and then a
         /// Cleanup to be done if the coroutine is dropped at this suspend point.
         drop: Option<BasicBlockId<'db>>,
     },
-
     /// Indicates the end of dropping a coroutine.
     ///
     /// Semantically just a `return` (from the coroutines drop glue). Only permitted in the same situations
     /// **Needs clarification**: Are there type system constraints on these terminators? Should
     /// there be a "block type" like `cleanup` blocks for them?
     CoroutineDrop,
-
     /// A block where control flow only ever takes one real path, but borrowck needs to be more
     /// conservative.
     ///
         /// practice.
         imaginary_target: BasicBlockId<'db>,
     },
-
     /// A terminator for blocks that only take one path in reality, but where we reserve the right
     /// to unwind in borrowck, even if it won't happen in practice. This can arise in infinite loops
     /// with no function calls for example.
     },
 }
 
-// Order of variants in this enum matter: they are used to compare borrow kinds.
 #[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Ord)]
 pub enum BorrowKind {
     /// Data must be immutable and is aliasable.
     Shared,
-
     /// The immediately borrowed place must be immutable, but projections from
     /// it don't need to be. For example, a shallow borrow of `a.b` doesn't
     /// conflict with a mutable borrow of `a.b.c`.
     /// mutating `(*x as Some).0` can't affect the discriminant of `x`.
     /// We can also report errors with this kind of borrow differently.
     Shallow,
-
     /// Data is mutable and not aliasable.
-    Mut { kind: MutBorrowKind },
+    Mut {
+        kind: MutBorrowKind,
+    },
 }
 
-// Order of variants in this enum matter: they are used to compare borrow kinds.
 #[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Ord)]
 pub enum MutBorrowKind {
     /// Data must be immutable but not aliasable. This kind of borrow cannot currently
     fn from_hir(m: hir_def::type_ref::Mutability) -> Self {
         match m {
             hir_def::type_ref::Mutability::Shared => BorrowKind::Shared,
-            hir_def::type_ref::Mutability::Mut => BorrowKind::Mut {
-                kind: MutBorrowKind::Default,
-            },
+            hir_def::type_ref::Mutability::Mut => BorrowKind::Mut { kind: MutBorrowKind::Default },
         }
     }
 
     fn from_rustc(m: rustc_ast_ir::Mutability) -> Self {
         match m {
             rustc_ast_ir::Mutability::Not => BorrowKind::Shared,
-            rustc_ast_ir::Mutability::Mut => BorrowKind::Mut {
-                kind: MutBorrowKind::Default,
-            },
+            rustc_ast_ir::Mutability::Mut => BorrowKind::Mut { kind: MutBorrowKind::Default },
         }
     }
 }
 }
 
 impl BinOp {
-    fn run_compare<T: PartialEq + PartialOrd>(&self, l: T, r: T) -> bool {
+    fn run_compare<T: PartialEq + PartialOrd>(
+        &self,
+        l: T,
+        r: T,
+    ) -> bool {
         match self {
             BinOp::Ge => l >= r,
             BinOp::Gt => l > r,
 }
 
 impl Display for BinOp {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         f.write_str(match self {
             BinOp::Add => "+",
             BinOp::Sub => "-",
         match value {
             hir_def::hir::CmpOp::Eq { negated: false } => BinOp::Eq,
             hir_def::hir::CmpOp::Eq { negated: true } => BinOp::Ne,
-            hir_def::hir::CmpOp::Ord {
-                ordering: Ordering::Greater,
-                strict: false,
-            } => BinOp::Ge,
-            hir_def::hir::CmpOp::Ord {
-                ordering: Ordering::Greater,
-                strict: true,
-            } => BinOp::Gt,
-            hir_def::hir::CmpOp::Ord {
-                ordering: Ordering::Less,
-                strict: false,
-            } => BinOp::Le,
-            hir_def::hir::CmpOp::Ord {
-                ordering: Ordering::Less,
-                strict: true,
-            } => BinOp::Lt,
+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Greater, strict: false } => BinOp::Ge,
+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Greater, strict: true } => BinOp::Gt,
+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Less, strict: false } => BinOp::Le,
+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Less, strict: true } => BinOp::Lt,
         }
     }
 }
 pub enum Rvalue<'db> {
     /// Yields the operand unchanged
     Use(Operand<'db>),
-
     /// Creates an array where each element is the value of the operand.
     ///
     /// Corresponds to source code like `[x; 32]`.
     Repeat(Operand<'db>, Const<'db>),
-
     /// Creates a reference of the indicated kind to the place.
     ///
     /// There is not much to document here, because besides the obvious parts the semantics of this
     ///
     /// `Shallow` borrows are disallowed after drop lowering.
     Ref(BorrowKind, Place<'db>),
-
     /// Creates a pointer/reference to the given thread local.
     ///
     /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a
     ///
     /// **Needs clarification**: Are there weird additional semantics here related to the runtime
     /// nature of this operation?
-    // ThreadLocalRef(DefId),
     ThreadLocalRef(std::convert::Infallible),
-
     /// Creates a pointer with the indicated mutability to the place.
     ///
     /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like
     ///
     /// Like with references, the semantics of this operation are heavily dependent on the aliasing
     /// model.
-    // AddressOf(Mutability, Place),
     AddressOf(std::convert::Infallible),
-
     /// Yields the length of the place, as a `usize`.
     ///
     /// If the type of the place is an array, this is the array length. For slices (`[T]`, not
     /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is
     /// ill-formed for places of other types.
     Len(Place<'db>),
-
     /// Performs essentially all of the casts that can be performed via `as`.
     ///
     /// This allows for casts from/to a variety of types.
     /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why
     /// `ArrayToPointer` and `MutToConstPointer` are special.
     Cast(CastKind, Operand<'db>, Ty<'db>),
-
-    // FIXME link to `pointer::offset` when it hits stable.
     /// * `Offset` has the same semantics as `pointer::offset`, except that the second
     ///   parameter may be a `usize` as well.
     /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,
     ///   types and return a value of that type.
     /// * The remaining operations accept signed integers, unsigned integers, or floats with
     ///   matching types and return a value of that type.
-    //BinaryOp(BinOp, Box<(Operand, Operand)>),
     BinaryOp(std::convert::Infallible),
-
     /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.
     ///
     /// When overflow checking is disabled and we are generating run-time code, the error condition
     ///
     /// Other combinations of types and operators are unsupported.
     CheckedBinaryOp(BinOp, Operand<'db>, Operand<'db>),
-
     /// Computes a value as described by the operation.
-    //NullaryOp(NullOp, Ty),
     NullaryOp(std::convert::Infallible),
-
     /// Exactly like `BinaryOp`, but less operands.
     ///
     /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;
     /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds
     /// return a value with the same type as their operand.
     UnaryOp(UnOp, Operand<'db>),
-
     /// Computes the discriminant of the place, returning it as an integer of type
     /// [`discriminant_ty`]. Returns zero for types without discriminant.
     ///
     /// [#91095]: https://github.com/rust-lang/rust/issues/91095
     /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant
     Discriminant(Place<'db>),
-
     /// Creates an aggregate value, like a tuple or struct.
     ///
     /// This is needed because dataflow analysis needs to distinguish
     /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Coroutine`. After
     /// coroutine lowering, `Coroutine` aggregate kinds are disallowed too.
     Aggregate(AggregateKind<'db>, Box<[Operand<'db>]>),
-
     /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.
     ///
     /// This is different from a normal transmute because dataflow analysis will treat the box as
     /// initialized but its content as uninitialized. Like other pointer casts, this in general
     /// affects alias analysis.
     ShallowInitBox(Operand<'db>, Ty<'db>),
-
     /// NON STANDARD: allocates memory with the type's layout, and shallow init the box with the resulting pointer.
     ShallowInitBoxWithAlloc(Ty<'db>),
-
     /// A CopyForDeref is equivalent to a read from a place at the
     /// codegen level, but is treated specially by drop elaboration. When such a read happens, it
     /// is guaranteed (via nature of the mir_opt `Derefer` in rustc_mir_transform/src/deref_separator)
 pub enum StatementKind<'db> {
     Assign(Place<'db>, Rvalue<'db>),
     FakeRead(Place<'db>),
-    //SetDiscriminant {
-    //    place: Box<Place>,
-    //    variant_index: VariantIdx,
-    //},
     Deinit(Place<'db>),
     StorageLive(LocalId<'db>),
     StorageDead(LocalId<'db>),
-    //Retag(RetagKind, Box<Place>),
-    //AscribeUserType(Place, UserTypeProjection, Variance),
-    //Intrinsic(Box<NonDivergingIntrinsic>),
     Nop,
 }
+
 impl<'db> StatementKind<'db> {
-    fn with_span(self, span: MirSpan) -> Statement<'db> {
+    fn with_span(
+        self,
+        span: MirSpan,
+    ) -> Statement<'db> {
         Statement { kind: self, span }
     }
 }
 pub struct BasicBlock<'db> {
     /// List of statements in this block.
     pub statements: Vec<Statement<'db>>,
-
     /// Terminator for this block.
     ///
     /// N.B., this should generally ONLY be `None` during construction.
     /// out the terminator temporarily with `None` while they continue
     /// to recurse over the set of basic blocks.
     pub terminator: Option<Terminator<'db>>,
-
     /// If true, this block lies on an unwind path. This is used
     /// during codegen where distinct kinds of basic blocks may be
     /// generated (particularly for MSVC cleanup). Unwind blocks must
         self.binding_locals.iter().map(|(it, y)| (*y, it)).collect()
     }
 
-    fn walk_places(&mut self, mut f: impl FnMut(&mut Place<'db>, &mut ProjectionStore<'db>)) {
+    fn walk_places(
+        &mut self,
+        mut f: impl FnMut(&mut Place<'db>, &mut ProjectionStore<'db>),
+    ) {
         fn for_operand<'db>(
             op: &mut Operand<'db>,
             f: &mut impl FnMut(&mut Place<'db>, &mut ProjectionStore<'db>),
                         f(place, &mut self.projection_store);
                         for_operand(value, &mut f, &mut self.projection_store);
                     }
-                    TerminatorKind::Call {
-                        func,
-                        args,
-                        destination,
-                        ..
-                    } => {
+                    TerminatorKind::Call { func, args, destination, .. } => {
                         for_operand(func, &mut f, &mut self.projection_store);
                         args.iter_mut()
                             .for_each(|x| for_operand(x, &mut f, &mut self.projection_store));
                     TerminatorKind::Assert { cond, .. } => {
                         for_operand(cond, &mut f, &mut self.projection_store);
                     }
-                    TerminatorKind::Yield {
-                        value, resume_arg, ..
-                    } => {
+                    TerminatorKind::Yield { value, resume_arg, .. } => {
                         for_operand(value, &mut f, &mut self.projection_store);
                         f(resume_arg, &mut self.projection_store);
                     }
         param_locals.shrink_to_fit();
         closures.shrink_to_fit();
         for (_, b) in basic_blocks.iter_mut() {
-            let BasicBlock {
-                statements,
-                terminator: _,
-                is_cleanup: _,
-            } = b;
+            let BasicBlock { statements, terminator: _, is_cleanup: _ } = b;
             statements.shrink_to_fit();
         }
     }
 }
 
 impl MirSpan {
-    pub fn is_ref_span(&self, body: &Body) -> bool {
+    pub fn is_ref_span(
+        &self,
+        body: &Body,
+    ) -> bool {
         match *self {
             MirSpan::ExprId(expr) => matches!(body[expr], Expr::Ref { .. }),
             // FIXME: Figure out if this is correct wrt. match ergonomics.
             MirSpan::BindingId(binding) => {
-                matches!(
-                    body[binding].mode,
-                    BindingAnnotation::Ref | BindingAnnotation::RefMut
-                )
+                matches!(body[binding].mode, BindingAnnotation::Ref | BindingAnnotation::RefMut)
             }
             MirSpan::PatId(_) | MirSpan::SelfParam | MirSpan::Unknown => false,
         }
     }
 }
-
-impl_from!(ExprId, PatId for MirSpan);
-
 impl From<&ExprId> for MirSpan {
     fn from(value: &ExprId) -> Self {
         (*value).into()