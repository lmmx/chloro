COMPARISON DIFF
============================================================

Original size: 6718 bytes
Chloro size:   6311 bytes
Rustfmt size:  6767 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     db::HirDatabase,
     method_resolution::TyFingerprint,
     next_solver::{
-        infer::{traits::ObligationCause, InferCtxt},
-        obligation_ctxt::ObligationCtxt,
-        Ty, TyKind,
+        infer::{InferCtxt, traits::ObligationCause}, obligation_ctxt::ObligationCtxt, Ty, TyKind,
     },
     TraitEnvironment,
 };
         },
         None => db.trait_impls_in_crate(module.krate()),
     };
-    impls
-        .for_trait_and_self_ty(drop_trait, TyFingerprint::Adt(adt))
-        .next()
-        .is_some()
+    impls.for_trait_and_self_ty(drop_trait, TyFingerprint::Adt(adt)).next().is_some()
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
     visited: &mut FxHashSet<Ty<'db>>,
 ) -> DropGlue {
     let mut ocx = ObligationCtxt::new(infcx);
-    let ty = ocx
-        .structurally_normalize_ty(&ObligationCause::dummy(), env.env, ty)
-        .unwrap_or(ty);
+    let ty = ocx.structurally_normalize_ty(&ObligationCause::dummy(), env.env, ty).unwrap_or(ty);
 
     if !visited.insert(ty) {
         // Recursive type.
                     {
                         return DropGlue::None;
                     }
-                    db.field_types(id.into())
-                        .iter()
-                        .map(|(_, field_ty)| {
-                            has_drop_glue_impl(
-                                infcx,
-                                field_ty.instantiate(infcx.interner, subst),
-                                env.clone(),
-                                visited,
-                            )
-                        })
-                        .max()
-                        .unwrap_or(DropGlue::None)
-                }
-                // Unions cannot have fields with destructors.
+                    db.field_types(id.into()).iter().map(|(_, field_ty)| {
+                        has_drop_glue_impl(
+                            infcx,
+                            field_ty.instantiate(infcx.interner, subst),
+                            env.clone(),
+                            visited,
+                        )
+                    }).max(
+                    ).unwrap_or(
+                        DropGlue::None,
+                    )
+                },
                 AdtId::UnionId(_) => DropGlue::None,
-                AdtId::EnumId(id) => id
-                    .enum_variants(db)
-                    .variants
-                    .iter()
-                    .map(|&(variant, _, _)| {
-                        db.field_types(variant.into())
-                            .iter()
-                            .map(|(_, field_ty)| {
-                                has_drop_glue_impl(
-                                    infcx,
-                                    field_ty.instantiate(infcx.interner, subst),
-                                    env.clone(),
-                                    visited,
-                                )
-                            })
-                            .max()
-                            .unwrap_or(DropGlue::None)
-                    })
-                    .max()
-                    .unwrap_or(DropGlue::None),
+                AdtId::EnumId(id) => id.enum_variants(db).variants.iter().map(|&(variant, _, _)| {
+                    db.field_types(variant.into()).iter().map(|(_, field_ty)| {
+                        has_drop_glue_impl(
+                            infcx,
+                            field_ty.instantiate(infcx.interner, subst),
+                            env.clone(),
+                            visited,
+                        )
+                    }).max(
+                    ).unwrap_or(
+                        DropGlue::None,
+                    )
+                }).max(
+                ).unwrap_or(
+                    DropGlue::None,
+                ),
             }
-        }
-        TyKind::Tuple(tys) => tys
-            .iter()
-            .map(|ty| has_drop_glue_impl(infcx, ty, env.clone(), visited))
-            .max()
-            .unwrap_or(DropGlue::None),
+        },
+        TyKind::Tuple(tys) => tys.iter().map(|ty| has_drop_glue_impl(infcx, ty, env.clone(), visited)).max().unwrap_or(
+            DropGlue::None,
+        ),
         TyKind::Array(ty, len) => {
             if consteval::try_const_usize(db, len) == Some(0) {
                 // Arrays of size 0 don't have drop glue.
                 return DropGlue::None;
             }
             has_drop_glue_impl(infcx, ty, env, visited)
-        }
+        },
         TyKind::Slice(ty) => has_drop_glue_impl(infcx, ty, env, visited),
         TyKind::Closure(closure_id, subst) => {
             let owner = db.lookup_intern_closure(closure_id.0).0;
             let infer = db.infer(owner);
             let (captures, _) = infer.closure_info(closure_id.0);
             let env = db.trait_environment_for_body(owner);
-            captures
-                .iter()
-                .map(|capture| {
-                    has_drop_glue_impl(infcx, capture.ty(db, subst), env.clone(), visited)
-                })
-                .max()
-                .unwrap_or(DropGlue::None)
-        }
-        // FIXME: Handle coroutines.
+            captures.iter().map(|capture| {
+                has_drop_glue_impl(infcx, capture.ty(db, subst), env.clone(), visited)
+            }).max(
+            ).unwrap_or(
+                DropGlue::None,
+            )
+        },
         TyKind::Coroutine(..) | TyKind::CoroutineWitness(..) | TyKind::CoroutineClosure(..) => {
             DropGlue::None
-        }
+        },
         TyKind::Ref(..)
         | TyKind::RawPtr(..)
         | TyKind::FnDef(..)
             } else {
                 DropGlue::HasDropGlue
             }
-        }
+        },
         TyKind::Param(_) => {
             if infcx.type_is_copy_modulo_regions(env.env, ty) {
                 DropGlue::None
             } else {
                 DropGlue::DependOnParams
             }
-        }
+        },
         TyKind::Infer(..) => unreachable!("inference vars shouldn't exist out of inference"),
         TyKind::Pat(..) | TyKind::UnsafeBinder(..) => {
             never!("we do not handle pattern and unsafe binder types");
             DropGlue::None
-        }
+        },
     }
 }