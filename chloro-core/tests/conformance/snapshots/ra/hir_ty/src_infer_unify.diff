COMPARISON DIFF
============================================================

Original size: 34409 bytes
Chloro size:   35035 bytes
Rustfmt size:  35032 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Unification and canonicalization logic.
 
 use std::fmt;
 
-use hir_def::{lang_item::LangItem, AdtId, DefWithBodyId, GenericParamId};
+use hir_def::{AdtId, DefWithBodyId, GenericParamId, lang_item::LangItem};
 use hir_expand::name::Name;
 use intern::sym;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
-    inherent::{Const as _, IntoKind, Ty as _},
-    solve::{Certainty, GoalSource},
-    DebruijnIndex, InferConst, InferTy, RegionVid, TyVid, TypeFoldable, TypeFolder,
-    TypeSuperFoldable, TypeVisitableExt, UpcastFrom,
+    inherent::{Const as _, IntoKind, Ty as _}, solve::{Certainty, GoalSource}, DebruijnIndex,
+    InferConst, InferTy, RegionVid, TyVid, TypeFoldable, TypeFolder, TypeSuperFoldable,
+    TypeVisitableExt, UpcastFrom,
 };
 use smallvec::SmallVec;
 use triomphe::Arc;
 
 use crate::{
-    db::HirDatabase,
-    infer::InferenceContext,
+    db::HirDatabase, infer::InferenceContext,
     next_solver::{
-        self,
+        self, AliasTy, Binder, Canonical, ClauseKind, Const, ConstKind, DbInterner,
+        ErrorGuaranteed, GenericArg, GenericArgs, Predicate, PredicateKind, Region, RegionKind,
+        SolverDefId, TraitRef, Ty, TyKind, TypingMode,
         fulfill::{FulfillmentCtxt, NextSolverError},
         infer::{
+            DbInternerInferExt, InferCtxt, InferOk, InferResult,
             at::ToTrace,
             snapshot::CombinedSnapshot,
             traits::{Obligation, ObligationCause, PredicateObligation},
-            DbInternerInferExt, InferCtxt, InferOk, InferResult,
         },
         inspect::{InspectConfig, InspectGoal, ProofTreeVisitor},
         obligation_ctxt::ObligationCtxt,
-        AliasTy, Binder, Canonical, ClauseKind, Const, ConstKind, DbInterner, ErrorGuaranteed,
-        GenericArg, GenericArgs, Predicate, PredicateKind, Region, RegionKind, SolverDefId,
-        TraitRef, Ty, TyKind, TypingMode,
     },
     traits::{
-        next_trait_solve_canonical_in_ctxt, next_trait_solve_in_ctxt, FnTrait, NextTraitSolveResult,
+        FnTrait, NextTraitSolveResult, next_trait_solve_canonical_in_ctxt, next_trait_solve_in_ctxt,
     },
     TraitEnvironment,
 };
 
 impl<'db> InferenceContext<'_, 'db> {
-    pub(super) fn canonicalize<T>(&mut self, t: T) -> rustc_type_ir::Canonical<DbInterner<'db>, T>
+    pub(super) fn canonicalize<T>(
+        &mut self,
+        t: T,
+    ) -> rustc_type_ir::Canonical<DbInterner<'db>, T>
     where
-        T: rustc_type_ir::TypeFoldable<DbInterner<'db>>,
-    {
+        T: rustc_type_ir::TypeFoldable<DbInterner<'db>>, {
         self.table.canonicalize(t)
     }
 }
         InspectConfig { max_depth: 5 }
     }
 
-    fn visit_goal(&mut self, inspect_goal: &InspectGoal<'_, 'db>) {
+    fn visit_goal(
+        &mut self,
+        inspect_goal: &InspectGoal<'_, 'db>,
+    ) {
         // No need to walk into goal subtrees that certainly hold, since they
         // wouldn't then be stalled on an infer var.
         if inspect_goal.result() == Ok(Certainty::Yes) {
             return;
         }
-
         let db = self.ctx.interner();
         let goal = inspect_goal.goal();
         if self.ctx.predicate_has_self_ty(goal.predicate, self.self_ty)
                 goal.predicate,
             ));
         }
-
         // If there's a unique way to prove a given goal, recurse into
         // that candidate. This means that for `impl<F: FnOnce(u32)> Trait<F> for () {}`
         // and a `(): Trait<?0>` goal we recurse into the impl and look at
     env: Arc<TraitEnvironment<'db>>,
     tys: &Canonical<'db, (Ty<'db>, Ty<'db>)>,
 ) -> bool {
-    could_unify_impl(db, env, tys, |ctxt| {
-        ctxt.evaluate_obligations_error_on_ambiguity()
-    })
+    could_unify_impl(db, env, tys, |ctxt| ctxt.evaluate_obligations_error_on_ambiguity())
 }
 
 fn could_unify_impl<'db>(
         self.infer_ctxt.interner
     }
 
-    pub(crate) fn type_is_copy_modulo_regions(&self, ty: Ty<'db>) -> bool {
-        self.infer_ctxt
-            .type_is_copy_modulo_regions(self.trait_env.env, ty)
+    pub(crate) fn type_is_copy_modulo_regions(
+        &self,
+        ty: Ty<'db>,
+    ) -> bool {
+        self.infer_ctxt.type_is_copy_modulo_regions(self.trait_env.env, ty)
     }
 
-    pub(crate) fn type_var_is_sized(&self, self_ty: TyVid) -> bool {
+    pub(crate) fn type_var_is_sized(
+        &self,
+        self_ty: TyVid,
+    ) -> bool {
         let Some(sized_did) = LangItem::Sized.resolve_trait(self.db, self.trait_env.krate) else {
             return true;
         };
-        self.obligations_for_self_ty(self_ty)
-            .into_iter()
-            .any(
-                |obligation| match obligation.predicate.kind().skip_binder() {
-                    PredicateKind::Clause(ClauseKind::Trait(data)) => data.def_id().0 == sized_did,
-                    _ => false,
-                },
-            )
+        self.obligations_for_self_ty(self_ty).into_iter().any(|obligation| {
+            match obligation.predicate.kind().skip_binder() {
+                PredicateKind::Clause(ClauseKind::Trait(data)) => data.def_id().0 == sized_did,
+                _ => false,
+            }
+        })
     }
 
     pub(super) fn obligations_for_self_ty(
             let goal = obligation.as_goal();
             self.infer_ctxt.visit_proof_tree(goal, &mut visitor);
         }
-
         obligations_for_self_ty.retain_mut(|obligation| {
-            obligation.predicate = self
-                .infer_ctxt
-                .resolve_vars_if_possible(obligation.predicate);
+            obligation.predicate = self.infer_ctxt.resolve_vars_if_possible(obligation.predicate);
             !obligation.predicate.has_placeholders()
         });
         obligations_for_self_ty
     }
 
-    fn predicate_has_self_ty(&self, predicate: Predicate<'db>, expected_vid: TyVid) -> bool {
+    fn predicate_has_self_ty(
+        &self,
+        predicate: Predicate<'db>,
+        expected_vid: TyVid,
+    ) -> bool {
         match predicate.kind().skip_binder() {
             PredicateKind::Clause(ClauseKind::Trait(data)) => {
                 self.type_matches_expected_vid(expected_vid, data.self_ty())
         }
     }
 
-    fn type_matches_expected_vid(&self, expected_vid: TyVid, ty: Ty<'db>) -> bool {
+    fn type_matches_expected_vid(
+        &self,
+        expected_vid: TyVid,
+        ty: Ty<'db>,
+    ) -> bool {
         let ty = self.shallow_resolve(ty);
-
         match ty.kind() {
             TyKind::Infer(rustc_type_ir::TyVar(found_vid)) => {
                 self.infer_ctxt.root_var(expected_vid) == self.infer_ctxt.root_var(found_vid)
         }
     }
 
-    pub(super) fn set_diverging(&mut self, ty: Ty<'db>) {
+    pub(super) fn set_diverging(
+        &mut self,
+        ty: Ty<'db>,
+    ) {
         self.diverging_type_vars.insert(ty);
     }
 
-    pub(crate) fn canonicalize<T>(&mut self, t: T) -> rustc_type_ir::Canonical<DbInterner<'db>, T>
+    pub(crate) fn canonicalize<T>(
+        &mut self,
+        t: T,
+    ) -> rustc_type_ir::Canonical<DbInterner<'db>, T>
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         // try to resolve obligations before canonicalizing, since this might
         // result in new knowledge about variables
         self.select_obligations_where_possible();
         self.infer_ctxt.canonicalize_response(t)
     }
 
-    // FIXME: We should get rid of this method. We cannot deeply normalize during inference, only when finishing.
-    // Inference should use shallow normalization (`try_structurally_resolve_type()`) only, when needed.
-    pub(crate) fn normalize_associated_types_in<T>(&mut self, ty: T) -> T
+    pub(crate) fn normalize_associated_types_in<T>(
+        &mut self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>> + Clone,
-    {
+        T: TypeFoldable<DbInterner<'db>> + Clone, {
         let ty = self.resolve_vars_with_obligations(ty);
         self.infer_ctxt
             .at(&ObligationCause::new(), self.trait_env.env)
 
     /// Works almost same as [`Self::normalize_associated_types_in`], but this also resolves shallow
     /// the inference variables
-    pub(crate) fn eagerly_normalize_and_resolve_shallow_in<T>(&mut self, ty: T) -> T
+    pub(crate) fn eagerly_normalize_and_resolve_shallow_in<T>(
+        &mut self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         let ty = self.resolve_vars_with_obligations(ty);
         let ty = self.normalize_associated_types_in(ty);
         self.resolve_vars_with_obligations(ty)
     }
 
-    pub(crate) fn normalize_alias_ty(&mut self, alias: Ty<'db>) -> Ty<'db> {
+    pub(crate) fn normalize_alias_ty(
+        &mut self,
+        alias: Ty<'db>,
+    ) -> Ty<'db> {
         self.infer_ctxt
             .at(&ObligationCause::new(), self.trait_env.env)
             .structurally_normalize_ty(alias, &mut self.fulfillment_cx)
         self.infer_ctxt.next_region_var()
     }
 
-    pub(crate) fn next_var_for_param(&mut self, id: GenericParamId) -> GenericArg<'db> {
+    pub(crate) fn next_var_for_param(
+        &mut self,
+        id: GenericParamId,
+    ) -> GenericArg<'db> {
         match id {
             GenericParamId::TypeParamId(_) => self.next_ty_var().into(),
             GenericParamId::ConstParamId(_) => self.next_const_var().into(),
         fallback_region: &mut dyn FnMut(DebruijnIndex, RegionVid) -> Region<'db>,
     ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         struct Resolver<'a, 'db> {
             table: &'a mut InferenceTable<'db>,
             binder: DebruijnIndex,
             fallback_const: &'a mut dyn FnMut(DebruijnIndex, InferConst) -> Const<'db>,
             fallback_region: &'a mut dyn FnMut(DebruijnIndex, RegionVid) -> Region<'db>,
         }
-
         impl<'db> TypeFolder<DbInterner<'db>> for Resolver<'_, 'db> {
             fn cx(&self) -> DbInterner<'db> {
                 self.table.interner()
                 }
             }
         }
-
         t.fold_with(&mut Resolver {
             table: self,
             binder: DebruijnIndex::ZERO,
         canonical: rustc_type_ir::Canonical<DbInterner<'db>, T>,
     ) -> T
     where
-        T: rustc_type_ir::TypeFoldable<DbInterner<'db>>,
-    {
+        T: rustc_type_ir::TypeFoldable<DbInterner<'db>>, {
         self.infer_ctxt.instantiate_canonical(&canonical).0
     }
 
-    pub(crate) fn resolve_completely<T>(&mut self, value: T) -> T
+    pub(crate) fn resolve_completely<T>(
+        &mut self,
+        value: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         let value = self.infer_ctxt.resolve_vars_if_possible(value);
-
         let mut goals = vec![];
-
         // FIXME(next-solver): Handle `goals`.
-
-        value.fold_with(&mut resolve_completely::Resolver::new(
-            self, true, &mut goals,
-        ))
+        value.fold_with(&mut resolve_completely::Resolver::new(self, true, &mut goals))
     }
 
     /// Unify two relatable values (e.g. `Ty`) and register new trait goals that arise from that.
-    pub(crate) fn unify<T: ToTrace<'db>>(&mut self, ty1: T, ty2: T) -> bool {
-        self.try_unify(ty1, ty2)
-            .map(|infer_ok| self.register_infer_ok(infer_ok))
-            .is_ok()
+    pub(crate) fn unify<T: ToTrace<'db>>(
+        &mut self,
+        ty1: T,
+        ty2: T,
+    ) -> bool {
+        self.try_unify(ty1, ty2).map(|infer_ok| self.register_infer_ok(infer_ok)).is_ok()
     }
 
     /// Unify two relatable values (e.g. `Ty`) and return new trait goals arising from it, so the
     /// caller needs to deal with them.
-    pub(crate) fn try_unify<T: ToTrace<'db>>(&mut self, t1: T, t2: T) -> InferResult<'db, ()> {
-        self.infer_ctxt
-            .at(&ObligationCause::new(), self.trait_env.env)
-            .eq(t1, t2)
+    pub(crate) fn try_unify<T: ToTrace<'db>>(
+        &mut self,
+        t1: T,
+        t2: T,
+    ) -> InferResult<'db, ()> {
+        self.infer_ctxt.at(&ObligationCause::new(), self.trait_env.env).eq(t1, t2)
     }
 
-    pub(crate) fn shallow_resolve(&self, ty: Ty<'db>) -> Ty<'db> {
+    pub(crate) fn shallow_resolve(
+        &self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         self.infer_ctxt.shallow_resolve(ty)
     }
 
-    pub(crate) fn resolve_vars_with_obligations<T>(&mut self, t: T) -> T
+    pub(crate) fn resolve_vars_with_obligations<T>(
+        &mut self,
+        t: T,
+    ) -> T
     where
-        T: rustc_type_ir::TypeFoldable<DbInterner<'db>>,
-    {
+        T: rustc_type_ir::TypeFoldable<DbInterner<'db>>, {
         if !t.has_non_region_infer() {
             return t;
         }
-
         let t = self.infer_ctxt.resolve_vars_if_possible(t);
-
         if !t.has_non_region_infer() {
             return t;
         }
-
         self.select_obligations_where_possible();
         self.infer_ctxt.resolve_vars_if_possible(t)
     }
 
     /// Create a `GenericArgs` full of infer vars for `def`.
-    pub(crate) fn fresh_args_for_item(&self, def: SolverDefId) -> GenericArgs<'db> {
+    pub(crate) fn fresh_args_for_item(
+        &self,
+        def: SolverDefId,
+    ) -> GenericArgs<'db> {
         self.infer_ctxt.fresh_args_for_item(def)
     }
 
     /// In case there is still ambiguity, the returned type may be an inference
     /// variable. This is different from `structurally_resolve_type` which errors
     /// in this case.
-    pub(crate) fn try_structurally_resolve_type(&mut self, ty: Ty<'db>) -> Ty<'db> {
+    pub(crate) fn try_structurally_resolve_type(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         if let TyKind::Alias(..) = ty.kind() {
             // We need to use a separate variable here as otherwise the temporary for
             // `self.fulfillment_cx.borrow_mut()` is alive in the `Err` branch, resulting
         }
     }
 
-    pub(crate) fn structurally_resolve_type(&mut self, ty: Ty<'db>) -> Ty<'db> {
+    pub(crate) fn structurally_resolve_type(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         self.try_structurally_resolve_type(ty)
         // FIXME: Err if it still contain infer vars.
     }
     pub(crate) fn snapshot(&mut self) -> InferenceTableSnapshot<'db> {
         let ctxt_snapshot = self.infer_ctxt.start_snapshot();
         let obligations = self.fulfillment_cx.clone();
-        InferenceTableSnapshot {
-            ctxt_snapshot,
-            obligations,
-        }
+        InferenceTableSnapshot { ctxt_snapshot, obligations }
     }
 
     #[tracing::instrument(skip_all)]
-    pub(crate) fn rollback_to(&mut self, snapshot: InferenceTableSnapshot<'db>) {
+    pub(crate) fn rollback_to(
+        &mut self,
+        snapshot: InferenceTableSnapshot<'db>,
+    ) {
         self.infer_ctxt.rollback_to(snapshot.ctxt_snapshot);
         self.fulfillment_cx = snapshot.obligations;
     }
     /// whether a trait *might* be implemented before deciding to 'lock in' the
     /// choice (during e.g. method resolution or deref).
     #[tracing::instrument(level = "debug", skip(self))]
-    pub(crate) fn try_obligation(&mut self, predicate: Predicate<'db>) -> NextTraitSolveResult {
-        let goal = next_solver::Goal {
-            param_env: self.trait_env.env,
-            predicate,
-        };
+    pub(crate) fn try_obligation(
+        &mut self,
+        predicate: Predicate<'db>,
+    ) -> NextTraitSolveResult {
+        let goal = next_solver::Goal { param_env: self.trait_env.env, predicate };
         let canonicalized = self.canonicalize(goal);
-
         next_trait_solve_canonical_in_ctxt(&self.infer_ctxt, canonicalized)
     }
 
-    pub(crate) fn register_obligation(&mut self, predicate: Predicate<'db>) {
-        let goal = next_solver::Goal {
-            param_env: self.trait_env.env,
-            predicate,
-        };
+    pub(crate) fn register_obligation(
+        &mut self,
+        predicate: Predicate<'db>,
+    ) {
+        let goal = next_solver::Goal { param_env: self.trait_env.env, predicate };
         self.register_obligation_in_env(goal)
     }
 
         }
     }
 
-    pub(crate) fn register_infer_ok<T>(&mut self, infer_ok: InferOk<'db, T>) -> T {
+    pub(crate) fn register_infer_ok<T>(
+        &mut self,
+        infer_ok: InferOk<'db, T>,
+    ) -> T {
         let InferOk { value, obligations } = infer_ok;
         self.register_predicates(obligations);
         value
     }
 
     pub(crate) fn select_obligations_where_possible(&mut self) {
-        self.fulfillment_cx
-            .try_evaluate_obligations(&self.infer_ctxt);
+        self.fulfillment_cx.try_evaluate_obligations(&self.infer_ctxt);
     }
 
-    pub(super) fn register_predicate(&mut self, obligation: PredicateObligation<'db>) {
+    pub(super) fn register_predicate(
+        &mut self,
+        obligation: PredicateObligation<'db>,
+    ) {
         if obligation.has_escaping_bound_vars() {
             panic!("escaping bound vars in predicate {:?}", obligation);
         }
-
-        self.fulfillment_cx
-            .register_predicate_obligation(&self.infer_ctxt, obligation);
+        self.fulfillment_cx.register_predicate_obligation(&self.infer_ctxt, obligation);
     }
 
-    pub(super) fn register_predicates<I>(&mut self, obligations: I)
+    pub(super) fn register_predicates<I>(
+        &mut self,
+        obligations: I,
+    )
     where
-        I: IntoIterator<Item = PredicateObligation<'db>>,
-    {
+        I: IntoIterator<Item = PredicateObligation<'db>>, {
         obligations.into_iter().for_each(|obligation| {
             self.register_predicate(obligation);
         });
         num_args: usize,
     ) -> Option<(FnTrait, Vec<Ty<'db>>, Ty<'db>)> {
         for (fn_trait_name, output_assoc_name, subtraits) in [
-            (
-                FnTrait::FnOnce,
-                sym::Output,
-                &[FnTrait::Fn, FnTrait::FnMut][..],
-            ),
+            (FnTrait::FnOnce, sym::Output, &[FnTrait::Fn, FnTrait::FnMut][..]),
             (FnTrait::AsyncFnMut, sym::CallRefFuture, &[FnTrait::AsyncFn]),
             (FnTrait::AsyncFnOnce, sym::CallOnceFuture, &[]),
         ] {
         None
     }
 
-    pub(super) fn insert_type_vars<T>(&mut self, ty: T) -> T
+    pub(super) fn insert_type_vars<T>(
+        &mut self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         self.infer_ctxt.insert_type_vars(ty)
     }
 
     /// Replaces `Ty::Error` by a new type var, so we can maybe still infer it.
-    pub(super) fn insert_type_vars_shallow(&mut self, ty: Ty<'db>) -> Ty<'db> {
-        if ty.is_ty_error() {
-            self.next_ty_var()
-        } else {
-            ty
-        }
+    pub(super) fn insert_type_vars_shallow(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
+        if ty.is_ty_error() { self.next_ty_var() } else { ty }
     }
 
     /// Whenever you lower a user-written type, you should call this.
-    pub(crate) fn process_user_written_ty<T>(&mut self, ty: T) -> T
+    pub(crate) fn process_user_written_ty<T>(
+        &mut self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         self.process_remote_user_written_ty(ty)
         // FIXME: Register a well-formed obligation.
     }
 
     /// The difference of this method from `process_user_written_ty()` is that this method doesn't register a well-formed obligation,
     /// while `process_user_written_ty()` should (but doesn't currently).
-    pub(crate) fn process_remote_user_written_ty<T>(&mut self, ty: T) -> T
+    pub(crate) fn process_remote_user_written_ty<T>(
+        &mut self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         let ty = self.insert_type_vars(ty);
         // See https://github.com/rust-lang/rust/blob/cdb45c87e2cd43495379f7e867e3cc15dcee9f93/compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs#L487-L495:
         // Even though the new solver only lazily normalizes usually, here we eagerly normalize so that not everything needs
     }
 
     /// Replaces ConstScalar::Unknown by a new type var, so we can maybe still infer it.
-    pub(super) fn insert_const_vars_shallow(&mut self, c: Const<'db>) -> Const<'db> {
-        if c.is_ct_error() {
-            self.next_const_var()
-        } else {
-            c
-        }
+    pub(super) fn insert_const_vars_shallow(
+        &mut self,
+        c: Const<'db>,
+    ) -> Const<'db> {
+        if c.is_ct_error() { self.next_const_var() } else { c }
     }
 
     /// Check if given type is `Sized` or not
-    pub(crate) fn is_sized(&mut self, ty: Ty<'db>) -> bool {
+    pub(crate) fn is_sized(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> bool {
         fn short_circuit_trivial_tys(ty: Ty<'_>) -> Option<bool> {
             match ty.kind() {
                 TyKind::Bool
                 _ => None,
             }
         }
-
         let mut ty = ty;
         ty = self.eagerly_normalize_and_resolve_shallow_in(ty);
         if let Some(sized) = short_circuit_trivial_tys(ty) {
             return sized;
         }
-
         {
             let mut structs = SmallVec::<[_; 8]>::new();
             // Must use a loop here and not recursion because otherwise users will conduct completely
                 };
             }
         }
-
         let Some(sized) = LangItem::Sized.resolve_trait(self.db, self.trait_env.krate) else {
             return false;
         };
 }
 
 impl fmt::Debug for InferenceTable<'_> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("InferenceTable")
-            .field(
-                "name",
-                &self.infer_ctxt.inner.borrow().type_variable_storage,
-            )
+            .field("name", &self.infer_ctxt.inner.borrow().type_variable_storage)
             .field("fulfillment_cx", &self.fulfillment_cx)
             .finish()
     }
 
 mod resolve_completely {
     use rustc_type_ir::{DebruijnIndex, Flags, TypeFolder, TypeSuperFoldable};
-
     use crate::{
         infer::unify::InferenceTable,
         next_solver::{
+            Const, DbInterner, Goal, Predicate, Region, Term, Ty,
             infer::{resolve::ReplaceInferWithError, traits::ObligationCause},
             normalize::deeply_normalize_with_skipped_universes_and_ambiguous_coroutine_goals,
-            Const, DbInterner, Goal, Predicate, Region, Term, Ty,
         },
     };
-
     pub(super) struct Resolver<'a, 'db> {
         ctx: &'a mut InferenceTable<'db>,
         /// Whether we should normalize, disabled when resolving predicates.
         should_normalize: bool,
         nested_goals: &'a mut Vec<Goal<'db, Predicate<'db>>>,
     }
-
     impl<'a, 'db> Resolver<'a, 'db> {
         pub(super) fn new(
             ctx: &'a mut InferenceTable<'db>,
             should_normalize: bool,
             nested_goals: &'a mut Vec<Goal<'db, Predicate<'db>>>,
         ) -> Resolver<'a, 'db> {
-            Resolver {
-                ctx,
-                nested_goals,
-                should_normalize,
-            }
+            Resolver { ctx, nested_goals, should_normalize }
         }
 
         fn handle_term<T>(
             outer_exclusive_binder: impl FnOnce(T) -> DebruijnIndex,
         ) -> T
         where
-            T: Into<Term<'db>> + TypeSuperFoldable<DbInterner<'db>> + Copy,
-        {
+            T: Into<Term<'db>> + TypeSuperFoldable<DbInterner<'db>> + Copy, {
             let value = if self.should_normalize {
                 let cause = ObligationCause::new();
                 let at = self.ctx.infer_ctxt.at(&cause, self.ctx.trait_env.env);
             } else {
                 value
             };
-
             value.fold_with(&mut ReplaceInferWithError::new(self.ctx.interner()))
         }
     }
-
     impl<'cx, 'db> TypeFolder<DbInterner<'db>> for Resolver<'cx, 'db> {
         fn cx(&self) -> DbInterner<'db> {
             self.ctx.interner()
         }
 
-        fn fold_region(&mut self, r: Region<'db>) -> Region<'db> {
-            if r.is_var() {
-                Region::error(self.ctx.interner())
-            } else {
-                r
-            }
+        fn fold_region(
+            &mut self,
+            r: Region<'db>,
+        ) -> Region<'db> {
+            if r.is_var() { Region::error(self.ctx.interner()) } else { r }
         }
 
-        fn fold_ty(&mut self, ty: Ty<'db>) -> Ty<'db> {
+        fn fold_ty(
+            &mut self,
+            ty: Ty<'db>,
+        ) -> Ty<'db> {
             self.handle_term(ty, |it| it.outer_exclusive_binder())
         }
 
-        fn fold_const(&mut self, ct: Const<'db>) -> Const<'db> {
+        fn fold_const(
+            &mut self,
+            ct: Const<'db>,
+        ) -> Const<'db> {
             self.handle_term(ct, |it| it.outer_exclusive_binder())
         }
 
-        fn fold_predicate(&mut self, predicate: Predicate<'db>) -> Predicate<'db> {
+        fn fold_predicate(
+            &mut self,
+            predicate: Predicate<'db>,
+        ) -> Predicate<'db> {
             assert!(
                 !self.should_normalize,
                 "normalizing predicates in writeback is not generally sound"