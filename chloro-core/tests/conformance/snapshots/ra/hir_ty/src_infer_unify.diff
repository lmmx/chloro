COMPARISON DIFF
============================================================

Original size: 34409 bytes
Chloro size:   34217 bytes
Rustfmt size:  35032 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     db::HirDatabase,
     infer::InferenceContext,
     next_solver::{
-        self,
-        fulfill::{FulfillmentCtxt, NextSolverError},
+        self, fulfill::{FulfillmentCtxt, NextSolverError},
         infer::{
+            DbInternerInferExt, InferCtxt, InferOk, InferResult,
             at::ToTrace,
             snapshot::CombinedSnapshot,
             traits::{Obligation, ObligationCause, PredicateObligation},
-            DbInternerInferExt, InferCtxt, InferOk, InferResult,
         },
-        inspect::{InspectConfig, InspectGoal, ProofTreeVisitor},
-        obligation_ctxt::ObligationCtxt,
+        inspect::{InspectConfig, InspectGoal, ProofTreeVisitor}, obligation_ctxt::ObligationCtxt,
         AliasTy, Binder, Canonical, ClauseKind, Const, ConstKind, DbInterner, ErrorGuaranteed,
         GenericArg, GenericArgs, Predicate, PredicateKind, Region, RegionKind, SolverDefId,
         TraitRef, Ty, TyKind, TypingMode,
     },
     traits::{
-        next_trait_solve_canonical_in_ctxt, next_trait_solve_in_ctxt, FnTrait, NextTraitSolveResult,
+        next_trait_solve_canonical_in_ctxt, next_trait_solve_in_ctxt, FnTrait,
+        NextTraitSolveResult,
     },
     TraitEnvironment,
 };
 
 impl<'db> InferenceContext<'_, 'db> {
-    pub(super) fn canonicalize<T>(&mut self, t: T) -> rustc_type_ir::Canonical<DbInterner<'db>, T>
+    pub(super) fn canonicalize<T>(
+        &mut self,
+        t: T,
+    ) -> rustc_type_ir::Canonical<DbInterner<'db>, T>
     where
         T: rustc_type_ir::TypeFoldable<DbInterner<'db>>,
     {
         }
 
         // If there's a unique way to prove a given goal, recurse into
+
         // that candidate. This means that for `impl<F: FnOnce(u32)> Trait<F> for () {}`
+
         // and a `(): Trait<?0>` goal we recurse into the impl and look at
+
         // the nested `?0: FnOnce(u32)` goal.
         if let Some(candidate) = inspect_goal.unique_applicable_candidate() {
             candidate.visit_nested_no_probe(self)
     env: Arc<TraitEnvironment<'db>>,
     tys: &Canonical<'db, (Ty<'db>, Ty<'db>)>,
 ) -> bool {
-    could_unify_impl(db, env, tys, |ctxt| {
-        ctxt.evaluate_obligations_error_on_ambiguity()
-    })
+    could_unify_impl(db, env, tys, |ctxt| ctxt.evaluate_obligations_error_on_ambiguity())
 }
 
 fn could_unify_impl<'db>(
     }
 
     pub(crate) fn type_is_copy_modulo_regions(&self, ty: Ty<'db>) -> bool {
-        self.infer_ctxt
-            .type_is_copy_modulo_regions(self.trait_env.env, ty)
+        self.infer_ctxt.type_is_copy_modulo_regions(self.trait_env.env, ty)
     }
 
     pub(crate) fn type_var_is_sized(&self, self_ty: TyVid) -> bool {
         let Some(sized_did) = LangItem::Sized.resolve_trait(self.db, self.trait_env.krate) else {
             return true;
         };
-        self.obligations_for_self_ty(self_ty)
-            .into_iter()
-            .any(
-                |obligation| match obligation.predicate.kind().skip_binder() {
-                    PredicateKind::Clause(ClauseKind::Trait(data)) => data.def_id().0 == sized_did,
-                    _ => false,
-                },
-            )
+        self.obligations_for_self_ty(self_ty).into_iter().any(|obligation| {
+            match obligation.predicate.kind().skip_binder() {
+                PredicateKind::Clause(ClauseKind::Trait(data)) => data.def_id().0 == sized_did,
+                _ => false,
+            }
+        })
     }
 
     pub(super) fn obligations_for_self_ty(
         }
 
         obligations_for_self_ty.retain_mut(|obligation| {
-            obligation.predicate = self
-                .infer_ctxt
-                .resolve_vars_if_possible(obligation.predicate);
+            obligation.predicate = self.infer_ctxt.resolve_vars_if_possible(obligation.predicate);
             !obligation.predicate.has_placeholders()
         });
         obligations_for_self_ty
         match predicate.kind().skip_binder() {
             PredicateKind::Clause(ClauseKind::Trait(data)) => {
                 self.type_matches_expected_vid(expected_vid, data.self_ty())
-            }
+            },
             PredicateKind::Clause(ClauseKind::Projection(data)) => {
                 self.type_matches_expected_vid(expected_vid, data.projection_term.self_ty())
-            }
+            },
             PredicateKind::Clause(ClauseKind::ConstArgHasType(..))
             | PredicateKind::Subtype(..)
             | PredicateKind::Coerce(..)
         match ty.kind() {
             TyKind::Infer(rustc_type_ir::TyVar(found_vid)) => {
                 self.infer_ctxt.root_var(expected_vid) == self.infer_ctxt.root_var(found_vid)
-            }
+            },
             _ => false,
         }
     }
         self.diverging_type_vars.insert(ty);
     }
 
-    pub(crate) fn canonicalize<T>(&mut self, t: T) -> rustc_type_ir::Canonical<DbInterner<'db>, T>
+    pub(crate) fn canonicalize<T>(
+        &mut self,
+        t: T,
+    ) -> rustc_type_ir::Canonical<DbInterner<'db>, T>
     where
         T: TypeFoldable<DbInterner<'db>>,
     {
         self.infer_ctxt.canonicalize_response(t)
     }
 
-    // FIXME: We should get rid of this method. We cannot deeply normalize during inference, only when finishing.
-    // Inference should use shallow normalization (`try_structurally_resolve_type()`) only, when needed.
     pub(crate) fn normalize_associated_types_in<T>(&mut self, ty: T) -> T
     where
         T: TypeFoldable<DbInterner<'db>> + Clone,
     {
         let ty = self.resolve_vars_with_obligations(ty);
-        self.infer_ctxt
-            .at(&ObligationCause::new(), self.trait_env.env)
-            .deeply_normalize(ty.clone())
-            .unwrap_or(ty)
+        self.infer_ctxt.at(&ObligationCause::new(), self.trait_env.env).deeply_normalize(ty.clone()).unwrap_or(
+            ty,
+        )
     }
 
     /// Works almost same as [`Self::normalize_associated_types_in`], but this also resolves shallow
     }
 
     pub(crate) fn normalize_alias_ty(&mut self, alias: Ty<'db>) -> Ty<'db> {
-        self.infer_ctxt
-            .at(&ObligationCause::new(), self.trait_env.env)
-            .structurally_normalize_ty(alias, &mut self.fulfillment_cx)
-            .unwrap_or(alias)
+        self.infer_ctxt.at(&ObligationCause::new(), self.trait_env.env).structurally_normalize_ty(
+            alias,
+            &mut self.fulfillment_cx,
+        ).unwrap_or(
+            alias,
+        )
     }
 
     pub(crate) fn next_ty_var(&mut self) -> Ty<'db> {
         let mut goals = vec![];
 
         // FIXME(next-solver): Handle `goals`.
-
-        value.fold_with(&mut resolve_completely::Resolver::new(
-            self, true, &mut goals,
-        ))
+        value.fold_with(&mut resolve_completely::Resolver::new(self, true, &mut goals))
     }
 
     /// Unify two relatable values (e.g. `Ty`) and register new trait goals that arise from that.
     pub(crate) fn unify<T: ToTrace<'db>>(&mut self, ty1: T, ty2: T) -> bool {
-        self.try_unify(ty1, ty2)
-            .map(|infer_ok| self.register_infer_ok(infer_ok))
-            .is_ok()
+        self.try_unify(ty1, ty2).map(|infer_ok| self.register_infer_ok(infer_ok)).is_ok()
     }
 
     /// Unify two relatable values (e.g. `Ty`) and return new trait goals arising from it, so the
     /// caller needs to deal with them.
     pub(crate) fn try_unify<T: ToTrace<'db>>(&mut self, t1: T, t2: T) -> InferResult<'db, ()> {
-        self.infer_ctxt
-            .at(&ObligationCause::new(), self.trait_env.env)
-            .eq(t1, t2)
+        self.infer_ctxt.at(&ObligationCause::new(), self.trait_env.env).eq(t1, t2)
     }
 
     pub(crate) fn shallow_resolve(&self, ty: Ty<'db>) -> Ty<'db> {
     /// in this case.
     pub(crate) fn try_structurally_resolve_type(&mut self, ty: Ty<'db>) -> Ty<'db> {
         if let TyKind::Alias(..) = ty.kind() {
-            // We need to use a separate variable here as otherwise the temporary for
-            // `self.fulfillment_cx.borrow_mut()` is alive in the `Err` branch, resulting
-            // in a reentrant borrow, causing an ICE.
             let result = self
                 .infer_ctxt
                 .at(&ObligationCause::misc(), self.trait_env.env)
     pub(crate) fn snapshot(&mut self) -> InferenceTableSnapshot<'db> {
         let ctxt_snapshot = self.infer_ctxt.start_snapshot();
         let obligations = self.fulfillment_cx.clone();
-        InferenceTableSnapshot {
-            ctxt_snapshot,
-            obligations,
-        }
+        InferenceTableSnapshot { ctxt_snapshot, obligations }
     }
 
     #[tracing::instrument(skip_all)]
     /// choice (during e.g. method resolution or deref).
     #[tracing::instrument(level = "debug", skip(self))]
     pub(crate) fn try_obligation(&mut self, predicate: Predicate<'db>) -> NextTraitSolveResult {
-        let goal = next_solver::Goal {
-            param_env: self.trait_env.env,
-            predicate,
-        };
+        let goal = next_solver::Goal { param_env: self.trait_env.env, predicate };
         let canonicalized = self.canonicalize(goal);
 
         next_trait_solve_canonical_in_ctxt(&self.infer_ctxt, canonicalized)
     }
 
     pub(crate) fn register_obligation(&mut self, predicate: Predicate<'db>) {
-        let goal = next_solver::Goal {
-            param_env: self.trait_env.env,
-            predicate,
-        };
+        let goal = next_solver::Goal { param_env: self.trait_env.env, predicate };
         self.register_obligation_in_env(goal)
     }
 
         let result = next_trait_solve_in_ctxt(&self.infer_ctxt, goal);
         tracing::debug!(?result);
         match result {
-            Ok((_, Certainty::Yes)) => {}
-            Err(rustc_type_ir::solve::NoSolution) => {}
+            Ok((_, Certainty::Yes)) => {
+            },
+            Err(rustc_type_ir::solve::NoSolution) => {
+            },
             Ok((_, Certainty::Maybe { .. })) => {
                 self.fulfillment_cx.register_predicate_obligation(
                     &self.infer_ctxt,
                         goal.predicate,
                     ),
                 );
-            }
+            },
         }
     }
 
     }
 
     pub(crate) fn select_obligations_where_possible(&mut self) {
-        self.fulfillment_cx
-            .try_evaluate_obligations(&self.infer_ctxt);
+        self.fulfillment_cx.try_evaluate_obligations(&self.infer_ctxt);
     }
 
     pub(super) fn register_predicate(&mut self, obligation: PredicateObligation<'db>) {
             panic!("escaping bound vars in predicate {:?}", obligation);
         }
 
-        self.fulfillment_cx
-            .register_predicate_obligation(&self.infer_ctxt, obligation);
+        self.fulfillment_cx.register_predicate_obligation(&self.infer_ctxt, obligation);
     }
 
     pub(super) fn register_predicates<I>(&mut self, obligations: I)
             Some(sig) => {
                 let sig = sig.skip_binder();
                 Some((None, sig.inputs_and_output.inputs().to_vec(), sig.output()))
-            }
+            },
             None => {
                 let (f, args_ty, return_ty) = self.callable_sig_from_fn_trait(ty, num_args)?;
                 Some((Some(f), args_ty, return_ty))
-            }
+            },
         }
     }
 
         num_args: usize,
     ) -> Option<(FnTrait, Vec<Ty<'db>>, Ty<'db>)> {
         for (fn_trait_name, output_assoc_name, subtraits) in [
-            (
-                FnTrait::FnOnce,
-                sym::Output,
-                &[FnTrait::Fn, FnTrait::FnMut][..],
-            ),
+            (FnTrait::FnOnce, sym::Output, &[FnTrait::Fn, FnTrait::FnMut][..]),
             (FnTrait::AsyncFnMut, sym::CallRefFuture, &[FnTrait::AsyncFn]),
             (FnTrait::AsyncFnOnce, sym::CallOnceFuture, &[]),
         ] {
 
 impl fmt::Debug for InferenceTable<'_> {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        f.debug_struct("InferenceTable")
-            .field(
-                "name",
-                &self.infer_ctxt.inner.borrow().type_variable_storage,
-            )
-            .field("fulfillment_cx", &self.fulfillment_cx)
-            .finish()
+        f.debug_struct("InferenceTable").field(
+            "name",
+            &self.infer_ctxt.inner.borrow().type_variable_storage,
+        ).field(
+            "fulfillment_cx",
+            &self.fulfillment_cx,
+        ).finish(
+        )
     }
 }
 
 mod resolve_completely {
     use rustc_type_ir::{DebruijnIndex, Flags, TypeFolder, TypeSuperFoldable};
-
     use crate::{
         infer::unify::InferenceTable,
         next_solver::{
             Const, DbInterner, Goal, Predicate, Region, Term, Ty,
         },
     };
-
     pub(super) struct Resolver<'a, 'db> {
         ctx: &'a mut InferenceTable<'db>,
         /// Whether we should normalize, disabled when resolving predicates.
         should_normalize: bool,
         nested_goals: &'a mut Vec<Goal<'db, Predicate<'db>>>,
     }
-
     impl<'a, 'db> Resolver<'a, 'db> {
         pub(super) fn new(
             ctx: &'a mut InferenceTable<'db>,
             should_normalize: bool,
             nested_goals: &'a mut Vec<Goal<'db, Predicate<'db>>>,
         ) -> Resolver<'a, 'db> {
-            Resolver {
-                ctx,
-                nested_goals,
-                should_normalize,
-            }
+            Resolver { ctx, nested_goals, should_normalize }
         }
 
         fn handle_term<T>(
             value.fold_with(&mut ReplaceInferWithError::new(self.ctx.interner()))
         }
     }
-
     impl<'cx, 'db> TypeFolder<DbInterner<'db>> for Resolver<'cx, 'db> {
         fn cx(&self) -> DbInterner<'db> {
             self.ctx.interner()