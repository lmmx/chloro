COMPARISON DIFF
============================================================

Original size: 18694 bytes
Chloro size:   18344 bytes
Rustfmt size:  18694 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Compute the dyn-compatibility of a trait
 
+#[cfg(test)]
+mod tests;
+
 use std::ops::ControlFlow;
 
 use hir_def::{
+    hir::generics::LocalTypeOrConstParamId, lang_item::LangItem, signatures::TraitFlags,
     AssocItemId, ConstId, CrateRootModuleId, FunctionId, GenericDefId, HasModule, TraitId,
-    TypeAliasId, TypeOrConstParamId, TypeParamId, hir::generics::LocalTypeOrConstParamId,
-    lang_item::LangItem, signatures::TraitFlags,
+    TypeAliasId, TypeOrConstParamId, TypeParamId,
 };
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
-    AliasTyKind, ClauseKind, PredicatePolarity, TypeSuperVisitable as _, TypeVisitable as _,
-    Upcast, elaborate,
-    inherent::{IntoKind, SliceLike},
+    elaborate, inherent::{IntoKind, AliasTyKind, ClauseKind, PredicatePolarity, SliceLike},
+    TypeSuperVisitable as _, TypeVisitable as _, Upcast,
 };
 use smallvec::SmallVec;
 
 use crate::{
-    ImplTraitId,
-    db::{HirDatabase, InternedOpaqueTyId},
-    lower::associated_ty_item_bounds,
+    db::{HirDatabase, infer::DbInternerInferExt, lower::associated_ty_item_bounds, mk_param,
     next_solver::{
-        Binder, Clause, Clauses, DbInterner, EarlyBinder, GenericArgs, Goal, ParamEnv, ParamTy,
-        SolverDefId, TraitPredicate, TraitRef, Ty, TypingMode, infer::DbInternerInferExt, mk_param,
-    },
-    traits::next_trait_solve_in_ctxt,
+        Binder, traits::next_trait_solve_in_ctxt, Clause, Clauses, DbInterner,
+    EarlyBinder, GenericArgs, Goal, ImplTraitId, InternedOpaqueTyId}, ParamEnv, ParamTy,
+    SolverDefId, TraitPredicate, TraitRef, Ty, TypingMode, },
 };
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
     Method(FunctionId, MethodViolationCode),
     AssocConst(ConstId),
     GAT(TypeAliasId),
-    // This doesn't exist in rustc, but added for better visualization
     HasNonCompatibleSuperTrait(TraitId),
 }
 
             };
         }
     }
-
     None
 }
 
     cb: &mut F,
 ) -> ControlFlow<()>
 where
-    F: FnMut(DynCompatibilityViolation) -> ControlFlow<()>,
-{
+    F: FnMut(DynCompatibilityViolation) -> ControlFlow<()>, {
     let interner = DbInterner::new_with(db, Some(trait_.krate(db)), None);
     for super_trait in elaborate::supertrait_def_ids(interner, trait_.into()).skip(1) {
         if db.dyn_compatibility_of_trait(super_trait.0).is_some() {
             cb(DynCompatibilityViolation::HasNonCompatibleSuperTrait(trait_))?;
         }
     }
-
     dyn_compatibility_of_trait_with_callback(db, trait_, cb)
 }
 
     cb: &mut F,
 ) -> ControlFlow<()>
 where
-    F: FnMut(DynCompatibilityViolation) -> ControlFlow<()>,
-{
+    F: FnMut(DynCompatibilityViolation) -> ControlFlow<()>, {
     // Check whether this has a `Sized` bound
     if generics_require_sized_self(db, trait_.into()) {
         cb(DynCompatibilityViolation::SizedSelf)?;
     }
-
     // Check if there exist bounds that referencing self
     if predicates_reference_self(db, trait_) {
         cb(DynCompatibilityViolation::SelfReferential)?;
     if bounds_reference_self(db, trait_) {
         cb(DynCompatibilityViolation::SelfReferential)?;
     }
-
     // rustc checks for non-lifetime binders here, but we don't support HRTB yet
-
     let trait_data = trait_.trait_items(db);
     for (_, assoc_item) in &trait_data.items {
         dyn_compatibility_violation_for_assoc_item(db, trait_, *assoc_item, cb)?;
     }
-
     ControlFlow::Continue(())
 }
 
         res = Some(osv);
         ControlFlow::Break(())
     });
-
     res
 }
 
-pub fn generics_require_sized_self(db: &dyn HirDatabase, def: GenericDefId) -> bool {
+pub fn generics_require_sized_self(
+    db: &dyn HirDatabase,
+    def: GenericDefId,
+) -> bool {
     let krate = def.module(db).krate();
     let Some(sized) = LangItem::Sized.resolve_trait(db, krate) else {
         return false;
     };
-
     let interner = DbInterner::new_with(db, Some(krate), None);
     let predicates = db.generic_predicates(def);
     // FIXME: We should use `explicit_predicates_of` here, which hasn't been implemented to
     })
 }
 
-// rustc gathers all the spans that references `Self` for error rendering,
-// but we don't have good way to render such locations.
-// So, just return single boolean value for existence of such `Self` reference
-fn predicates_reference_self(db: &dyn HirDatabase, trait_: TraitId) -> bool {
+fn predicates_reference_self(
+    db: &dyn HirDatabase,
+    trait_: TraitId,
+) -> bool {
     db.generic_predicates(trait_.into())
         .iter()
         .any(|pred| predicate_references_self(db, trait_, pred, AllowSelfProjection::No))
 }
 
-// Same as the above, `predicates_reference_self`
-fn bounds_reference_self(db: &dyn HirDatabase, trait_: TraitId) -> bool {
+fn bounds_reference_self(
+    db: &dyn HirDatabase,
+    trait_: TraitId,
+) -> bool {
     let trait_data = trait_.trait_items(db);
     trait_data
         .items
             }
         }
     }
-
     let mut visitor =
         IllegalSelfTypeVisitor { db, trait_, super_traits: None, allow_self_projection };
     t.visit_with(&mut visitor).is_break()
     cb: &mut F,
 ) -> ControlFlow<()>
 where
-    F: FnMut(DynCompatibilityViolation) -> ControlFlow<()>,
-{
+    F: FnMut(DynCompatibilityViolation) -> ControlFlow<()>, {
     // Any item that has a `Self : Sized` requisite is otherwise
     // exempt from the regulations.
     if generics_require_sized_self(db, item.into()) {
         return ControlFlow::Continue(());
     }
-
     match item {
         AssocItemId::ConstId(it) => cb(DynCompatibilityViolation::AssocConst(it)),
         AssocItemId::FunctionId(it) => {
     cb: &mut F,
 ) -> ControlFlow<()>
 where
-    F: FnMut(MethodViolationCode) -> ControlFlow<()>,
-{
+    F: FnMut(MethodViolationCode) -> ControlFlow<()>, {
     let func_data = db.function_signature(func);
     if !func_data.has_self_param() {
         cb(MethodViolationCode::StaticMethod)?;
     }
-
     if func_data.is_async() {
         cb(MethodViolationCode::AsyncFn)?;
     }
-
     let sig = db.callable_item_signature(func.into());
     if sig
         .skip_binder()
     {
         cb(MethodViolationCode::ReferencesSelfInput)?;
     }
-
     if contains_illegal_self_type_reference(
         db,
         trait_,
     ) {
         cb(MethodViolationCode::ReferencesSelfOutput)?;
     }
-
     if !func_data.is_async()
         && let Some(mvc) = contains_illegal_impl_trait_in_trait(db, &sig)
     {
         cb(mvc)?;
     }
-
     let generic_params = db.generic_params(func.into());
     if generic_params.len_type_or_consts() > 0 {
         cb(MethodViolationCode::Generic)?;
     }
-
     if func_data.has_self_param() && !receiver_is_dispatchable(db, trait_, func, &sig) {
         cb(MethodViolationCode::UndispatchableReceiver)?;
     }
-
     let predicates = &*db.generic_predicates_without_parent(func.into());
     for pred in predicates {
         let pred = pred.kind().skip_binder();
             break;
         }
     }
-
     ControlFlow::Continue(())
 }
 
     sig: &EarlyBinder<'db, Binder<'db, rustc_type_ir::FnSig<DbInterner<'db>>>>,
 ) -> bool {
     let sig = sig.instantiate_identity();
-
     let interner: DbInterner<'_> = DbInterner::new_with(db, Some(trait_.krate(db)), None);
     let self_param_id = TypeParamId::from_unchecked(TypeOrConstParamId {
         parent: trait_.into(),
     });
     let self_param_ty =
         Ty::new(interner, rustc_type_ir::TyKind::Param(ParamTy { index: 0, id: self_param_id }));
-
     // `self: Self` can't be dispatched on, but this is already considered dyn-compatible
     // See rustc's comment on https://github.com/rust-lang/rust/blob/3f121b9461cce02a703a0e7e450568849dfaa074/compiler/rustc_trait_selection/src/traits/object_safety.rs#L433-L437
     if sig.inputs().iter().next().is_some_and(|p| p.skip_binder() == self_param_ty) {
         return true;
     }
-
     let Some(&receiver_ty) = sig.inputs().skip_binder().as_slice().first() else {
         return false;
     };
-
     let krate = func.module(db).krate();
     let traits = (
         LangItem::Unsize.resolve_trait(db, krate),
     let (Some(unsize_did), Some(dispatch_from_dyn_did)) = traits else {
         return false;
     };
-
     let meta_sized_did = LangItem::MetaSized.resolve_trait(db, krate);
     let Some(meta_sized_did) = meta_sized_did else {
         return false;
     };
-
     // Type `U`
     // FIXME: That seems problematic to fake a generic param like that?
     let unsized_self_ty = Ty::new_param(interner, self_param_id, u32::MAX);
     // `Receiver[Self => U]`
     let unsized_receiver_ty = receiver_for_self_ty(interner, func, receiver_ty, unsized_self_ty);
-
     let param_env = {
         let generic_predicates = &*db.generic_predicates(func.into());
 
             ),
         }
     };
-
     // Receiver: DispatchFromDyn<Receiver[Self => U]>
     let predicate =
         TraitRef::new(interner, dispatch_from_dyn_did.into(), [receiver_ty, unsized_receiver_ty]);
     let goal = Goal::new(interner, param_env, predicate);
-
     let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
     // the receiver is dispatchable iff the obligation holds
     let res = next_trait_solve_in_ctxt(&infcx, goal);
     let args = GenericArgs::for_item(interner, SolverDefId::FunctionId(func), |index, kind, _| {
         if index == 0 { self_ty.into() } else { mk_param(interner, index, kind) }
     });
-
     EarlyBinder::bind(receiver_ty).instantiate(interner, args)
 }
 
     sig: &EarlyBinder<'db, Binder<'db, rustc_type_ir::FnSig<DbInterner<'db>>>>,
 ) -> Option<MethodViolationCode> {
     struct OpaqueTypeCollector(FxHashSet<InternedOpaqueTyId>);
-
     impl<'db> rustc_type_ir::TypeVisitor<DbInterner<'db>> for OpaqueTypeCollector {
         type Result = ControlFlow<()>;
 
             ty.super_visit_with(self)
         }
     }
-
     let ret = sig.skip_binder().output();
     let mut visitor = OpaqueTypeCollector(FxHashSet::default());
     _ = ret.visit_with(&mut visitor);
-
     // Since we haven't implemented RPITIT in proper way like rustc yet,
     // just check whether `ret` contains RPIT for now
     for opaque_ty in visitor.0 {
             return Some(MethodViolationCode::ReferencesImplTraitInTrait);
         }
     }
-
     None
 }
-
-#[cfg(test)]
-mod tests;