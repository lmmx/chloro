COMPARISON DIFF
============================================================

Original size: 18694 bytes
Chloro size:   18776 bytes
Rustfmt size:  18694 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     lower::associated_ty_item_bounds,
     next_solver::{
         Binder, Clause, Clauses, DbInterner, EarlyBinder, GenericArgs, Goal, ParamEnv, ParamTy,
-        SolverDefId, TraitPredicate, TraitRef, Ty, TypingMode, infer::DbInternerInferExt, mk_param,
+        SolverDefId, TraitPredicate, TraitRef, Ty, TypingMode, infer::DbInternerInferExt,
+        mk_param,
     },
     traits::next_trait_solve_in_ctxt,
 };
     SelfReferential,
     Method(FunctionId, MethodViolationCode),
     AssocConst(ConstId),
-    GAT(TypeAliasId),
-    // This doesn't exist in rustc, but added for better visualization
+    GAT(TypeAliasId), // This doesn't exist in rustc, but added for better visualization
     HasNonCompatibleSuperTrait(TraitId),
 }
 
     }
 
     // rustc checks for non-lifetime binders here, but we don't support HRTB yet
-
     let trait_data = trait_.trait_items(db);
     for (_, assoc_item) in &trait_data.items {
         dyn_compatibility_violation_for_assoc_item(db, trait_, *assoc_item, cb)?;
     match item {
         AssocItemId::ConstId(it) => cb(DynCompatibilityViolation::AssocConst(it)),
         AssocItemId::FunctionId(it) => {
-            virtual_call_violations_for_method(db, trait_, it, &mut |mvc| {
+            virtual_call_violations_for_method(
+                db,
+                trait_,
+                it,
+                &mut |mvc| {
                 cb(DynCompatibilityViolation::Method(it, mvc))
-            })
+            },
+            )
         }
         AssocItemId::TypeAliasId(it) => {
             let def_map = CrateRootModuleId::from(trait_.krate(db)).def_map(db);