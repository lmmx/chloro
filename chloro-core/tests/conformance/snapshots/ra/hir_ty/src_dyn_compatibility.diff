COMPARISON DIFF
============================================================

Original size: 18694 bytes
Chloro size:   18783 bytes
Rustfmt size:  18694 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     lower::associated_ty_item_bounds,
     next_solver::{
         Binder, Clause, Clauses, DbInterner, EarlyBinder, GenericArgs, Goal, ParamEnv, ParamTy,
-        SolverDefId, TraitPredicate, TraitRef, Ty, TypingMode, infer::DbInternerInferExt, mk_param,
+        SolverDefId, TraitPredicate, TraitRef, Ty, TypingMode, infer::DbInternerInferExt,
+        mk_param,
     },
     traits::next_trait_solve_in_ctxt,
 };
     }
 
     // rustc checks for non-lifetime binders here, but we don't support HRTB yet
-
     let trait_data = trait_.trait_items(db);
     for (_, assoc_item) in &trait_data.items {
         dyn_compatibility_violation_for_assoc_item(db, trait_, *assoc_item, cb)?;
     match item {
         AssocItemId::ConstId(it) => cb(DynCompatibilityViolation::AssocConst(it)),
         AssocItemId::FunctionId(it) => {
-            virtual_call_violations_for_method(db, trait_, it, &mut |mvc| {
+            virtual_call_violations_for_method(
+                db,
+                trait_,
+                it,
+                &mut |mvc| {
                 cb(DynCompatibilityViolation::Method(it, mvc))
-            })
+            },
+            )
         }
         AssocItemId::TypeAliasId(it) => {
             let def_map = CrateRootModuleId::from(trait_.krate(db)).def_map(db);
         Ty::new(interner, rustc_type_ir::TyKind::Param(ParamTy { index: 0, id: self_param_id }));
 
     // `self: Self` can't be dispatched on, but this is already considered dyn-compatible
+
     // See rustc's comment on https://github.com/rust-lang/rust/blob/3f121b9461cce02a703a0e7e450568849dfaa074/compiler/rustc_trait_selection/src/traits/object_safety.rs#L433-L437
     if sig.inputs().iter().next().is_some_and(|p| p.skip_binder() == self_param_ty) {
         return true;
     };
 
     // Type `U`
+
     // FIXME: That seems problematic to fake a generic param like that?
     let unsized_self_ty = Ty::new_param(interner, self_param_id, u32::MAX);
     // `Receiver[Self => U]`
     _ = ret.visit_with(&mut visitor);
 
     // Since we haven't implemented RPITIT in proper way like rustc yet,
+
     // just check whether `ret` contains RPIT for now
     for opaque_ty in visitor.0 {
         let impl_trait_id = db.lookup_intern_impl_trait_id(opaque_ty);