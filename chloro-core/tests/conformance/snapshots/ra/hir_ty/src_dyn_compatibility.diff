COMPARISON DIFF
============================================================

Original size: 18694 bytes
Chloro size:   18424 bytes
Rustfmt size:  18694 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Compute the dyn-compatibility of a trait
 
+#[cfg(test)]
+mod tests;
+
 use std::ops::ControlFlow;
 
 use hir_def::{
+    hir::generics::LocalTypeOrConstParamId, lang_item::LangItem, signatures::TraitFlags,
     AssocItemId, ConstId, CrateRootModuleId, FunctionId, GenericDefId, HasModule, TraitId,
-    TypeAliasId, TypeOrConstParamId, TypeParamId, hir::generics::LocalTypeOrConstParamId,
-    lang_item::LangItem, signatures::TraitFlags,
+    TypeAliasId, TypeOrConstParamId, TypeParamId,
 };
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
-    AliasTyKind, ClauseKind, PredicatePolarity, TypeSuperVisitable as _, TypeVisitable as _,
-    Upcast, elaborate,
+    elaborate,
     inherent::{IntoKind, SliceLike},
+    AliasTyKind, ClauseKind, PredicatePolarity, TypeSuperVisitable as _, TypeVisitable as _,
+    Upcast,
 };
 use smallvec::SmallVec;
 
 use crate::{
-    ImplTraitId,
     db::{HirDatabase, InternedOpaqueTyId},
     lower::associated_ty_item_bounds,
     next_solver::{
-        Binder, Clause, Clauses, DbInterner, EarlyBinder, GenericArgs, Goal, ParamEnv, ParamTy,
-        SolverDefId, TraitPredicate, TraitRef, Ty, TypingMode, infer::DbInternerInferExt, mk_param,
+        infer::DbInternerInferExt, mk_param, Binder, Clause, Clauses, DbInterner, EarlyBinder,
+        GenericArgs, Goal, ParamEnv, ParamTy, SolverDefId, TraitPredicate, TraitRef, Ty,
+        TypingMode,
     },
     traits::next_trait_solve_in_ctxt,
+    ImplTraitId,
 };
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
     }
 
     // rustc checks for non-lifetime binders here, but we don't support HRTB yet
-
     let trait_data = trait_.trait_items(db);
     for (_, assoc_item) in &trait_data.items {
         dyn_compatibility_violation_for_assoc_item(db, trait_, *assoc_item, cb)?;
     })
 }
 
-// rustc gathers all the spans that references `Self` for error rendering,
-// but we don't have good way to render such locations.
-// So, just return single boolean value for existence of such `Self` reference
 fn predicates_reference_self(db: &dyn HirDatabase, trait_: TraitId) -> bool {
     db.generic_predicates(trait_.into())
         .iter()
         .any(|pred| predicate_references_self(db, trait_, pred, AllowSelfProjection::No))
 }
 
-// Same as the above, `predicates_reference_self`
 fn bounds_reference_self(db: &dyn HirDatabase, trait_: TraitId) -> bool {
     let trait_data = trait_.trait_items(db);
     trait_data
         }
     }
 
-    let mut visitor =
-        IllegalSelfTypeVisitor { db, trait_, super_traits: None, allow_self_projection };
+    let mut visitor = IllegalSelfTypeVisitor { db, trait_, super_traits: None, allow_self_projection };
     t.visit_with(&mut visitor).is_break()
 }
 
         parent: trait_.into(),
         local_id: LocalTypeOrConstParamId::from_raw(la_arena::RawIdx::from_u32(0)),
     });
-    let self_param_ty =
-        Ty::new(interner, rustc_type_ir::TyKind::Param(ParamTy { index: 0, id: self_param_id }));
+    let self_param_ty = Ty::new(interner, rustc_type_ir::TyKind::Param(ParamTy { index: 0, id: self_param_id }));
 
     // `self: Self` can't be dispatched on, but this is already considered dyn-compatible
+
     // See rustc's comment on https://github.com/rust-lang/rust/blob/3f121b9461cce02a703a0e7e450568849dfaa074/compiler/rustc_trait_selection/src/traits/object_safety.rs#L433-L437
     if sig.inputs().iter().next().is_some_and(|p| p.skip_binder() == self_param_ty) {
         return true;
     };
 
     // Type `U`
+
     // FIXME: That seems problematic to fake a generic param like that?
     let unsized_self_ty = Ty::new_param(interner, self_param_id, u32::MAX);
     // `Receiver[Self => U]`
     };
 
     // Receiver: DispatchFromDyn<Receiver[Self => U]>
-    let predicate =
-        TraitRef::new(interner, dispatch_from_dyn_did.into(), [receiver_ty, unsized_receiver_ty]);
+    let predicate = TraitRef::new(interner, dispatch_from_dyn_did.into(), [receiver_ty, unsized_receiver_ty]);
     let goal = Goal::new(interner, param_env, predicate);
 
     let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
     _ = ret.visit_with(&mut visitor);
 
     // Since we haven't implemented RPITIT in proper way like rustc yet,
+
     // just check whether `ret` contains RPIT for now
     for opaque_ty in visitor.0 {
         let impl_trait_id = db.lookup_intern_impl_trait_id(opaque_ty);
 
     None
 }
-
-#[cfg(test)]
-mod tests;