COMPARISON DIFF
============================================================

Original size: 22408 bytes
Chloro size:   22052 bytes
Rustfmt size:  22967 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 // For details, see the zulip discussion below:
 // https://rust-lang.zulipchat.com/#narrow/channel/185405-t-compiler.2Frust-analyzer/topic/relying.20on.20in-tree.20.60rustc_type_ir.60.2F.60rustc_next_trait_solver.60/with/541055689
 
-extern crate ra_ap_rustc_index as rustc_index;
-
-extern crate ra_ap_rustc_abi as rustc_abi;
-
-extern crate ra_ap_rustc_pattern_analysis as rustc_pattern_analysis;
-
-extern crate ra_ap_rustc_ast_ir as rustc_ast_ir;
-
-extern crate ra_ap_rustc_type_ir as rustc_type_ir;
-
-extern crate ra_ap_rustc_next_trait_solver as rustc_next_trait_solver;
-
-extern crate self as hir_ty;
-
 mod infer;
 mod inhabitedness;
 mod lower;
 mod target_feature;
 mod utils;
 mod variance;
-
 pub mod autoderef;
 pub mod consteval;
 pub mod db;
 pub mod mir;
 pub mod primitive;
 pub mod traits;
-
 #[cfg(test)]
 mod test_db;
 #[cfg(test)]
 
 use std::hash::Hash;
 
+pub use autoderef::autoderef;
 use hir_def::{type_ref::Rawness, CallableDefId, TypeOrConstParamId};
 use hir_expand::name::Name;
 use indexmap::{map::Entry, IndexMap};
-use intern::{sym, Symbol};
-use mir::{MirEvalError, VTableMap};
-use rustc_hash::{FxBuildHasher, FxHashMap, FxHashSet};
-use rustc_type_ir::{
-    inherent::{IntoKind, SliceLike, Ty as _},
-    BoundVarIndexKind, TypeSuperVisitable, TypeVisitableExt, UpcastFrom,
-};
-use syntax::ast::{make, ConstArg};
-use traits::FnTrait;
-use triomphe::Arc;
-
-use crate::{
-    db::HirDatabase,
-    display::{DisplayTarget, HirDisplay},
-    infer::unify::InferenceTable,
-    next_solver::{
-        abi, AliasTy, Binder, BoundConst, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind,
-        Canonical, CanonicalVarKind, CanonicalVars, Const, ConstKind, DbInterner, FnSig, PolyFnSig,
-        Predicate, Region, RegionKind, TraitRef, Ty, TyKind, Tys,
-    },
-};
-
-pub use autoderef::autoderef;
 pub use infer::{
     cast::CastError,
     closure::analysis::{CaptureKind, CapturedItem},
     InferenceDiagnostic, InferenceResult, InferenceTyDiagnosticSource, OverloadedDeref,
     PointerCast,
 };
+use intern::{sym, Symbol};
 pub use lower::{
     associated_type_shorthand_candidates, diagnostics::*, LifetimeElisionKind, TyDefId,
     TyLoweringContext, ValueTyDefId,
 };
 pub use method_resolution::check_orphan_rules;
+use mir::{MirEvalError, VTableMap};
 pub use next_solver::interner::{attach_db, attach_db_allow_change, with_attached_db};
+use rustc_hash::{FxBuildHasher, FxHashMap, FxHashSet};
+use rustc_type_ir::{
+    inherent::{IntoKind, SliceLike, Ty as _},
+    BoundVarIndexKind, TypeSuperVisitable, TypeVisitableExt, UpcastFrom,
+};
+use syntax::ast::{make, ConstArg};
 pub use target_feature::TargetFeatures;
+use traits::FnTrait;
 pub use traits::TraitEnvironment;
+use triomphe::Arc;
 pub use utils::{
     all_super_traits, direct_super_traits, is_fn_unsafe_to_call, target_feature_is_safe_in_target,
     TargetFeatureIsSafeInTarget, Unsafety,
 };
 
+use crate::{
+    db::HirDatabase,
+    display::{DisplayTarget, HirDisplay},
+    infer::unify::InferenceTable,
+    next_solver::{
+        abi, AliasTy, Binder, BoundConst, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind,
+        Canonical, CanonicalVarKind, CanonicalVars, Const, ConstKind, DbInterner, FnSig,
+        PolyFnSig, Predicate, Region, RegionKind, TraitRef, Ty, TyKind, Tys,
+    },
+};
+
 /// A constant can have reference to other things. Memory map job is holding
 /// the necessary bits of memory of the const eval session to keep the constant
 /// meaningful.
     ) -> Result<FxHashMap<usize, usize>, MirEvalError<'db>> {
         let mut transform = |(addr, val): (&usize, &[u8])| {
             let addr = *addr;
-            let align = if addr == 0 {
-                64
-            } else {
-                (addr - (addr & (addr - 1))).min(64)
-            };
+            let align = if addr == 0 { 64 } else { (addr - (addr & (addr - 1))).min(64) };
             f(val, align).map(|it| (addr, it))
         };
         match self {
                 map.insert(addr, val);
                 map
             }),
-            MemoryMap::Complex(cm) => cm
-                .memory
-                .iter()
-                .map(|(addr, val)| transform((addr, val)))
-                .collect(),
+            MemoryMap::Complex(cm) => {
+                cm.memory.iter().map(|(addr, val)| transform((addr, val))).collect()
+            }
         }
     }
 
 /// 'Canonicalizes' the `t` by replacing any errors with new variables. Also
 /// ensures there are no unbound variables or inference variables anywhere in
 /// the `t`.
-pub fn replace_errors_with_variables<'db, T>(interner: DbInterner<'db>, t: &T) -> Canonical<'db, T>
+pub fn replace_errors_with_variables<'db, T>(
+    interner: DbInterner<'db>,
+    t: &T,
+) -> Canonical<'db, T>
 where
     T: rustc_type_ir::TypeFoldable<DbInterner<'db>> + Clone,
 {
             #[cfg(debug_assertions)]
             let error = || Err(());
             #[cfg(not(debug_assertions))]
-            let error = || {
-                Ok(Ty::new_error(
-                    self.interner,
-                    crate::next_solver::ErrorGuaranteed,
-                ))
-            };
+            let error = || Ok(Ty::new_error(self.interner, crate::next_solver::ErrorGuaranteed));
 
             match t.kind() {
                 TyKind::Error(_) => {
                     Ok(Ty::new_bound(
                         self.interner,
                         self.binder,
-                        BoundTy {
-                            var,
-                            kind: BoundTyKind::Anon,
-                        },
+                        BoundTy { var, kind: BoundTyKind::Anon },
                     ))
                 }
                 TyKind::Infer(_) => error(),
             match ct.kind() {
                 ConstKind::Error(_) => {
                     let var = rustc_type_ir::BoundVar::from_usize(self.vars.len());
-                    self.vars
-                        .push(CanonicalVarKind::Const(rustc_type_ir::UniverseIndex::ZERO));
-                    Ok(Const::new_bound(
-                        self.interner,
-                        self.binder,
-                        BoundConst { var },
-                    ))
+                    self.vars.push(CanonicalVarKind::Const(rustc_type_ir::UniverseIndex::ZERO));
+                    Ok(Const::new_bound(self.interner, self.binder, BoundConst { var }))
                 }
                 ConstKind::Infer(_) => error(),
                 ConstKind::Bound(BoundVarIndexKind::Bound(index), _) if index > self.binder => {
             match region.kind() {
                 RegionKind::ReError(_) => {
                     let var = rustc_type_ir::BoundVar::from_usize(self.vars.len());
-                    self.vars
-                        .push(CanonicalVarKind::Region(rustc_type_ir::UniverseIndex::ZERO));
+                    self.vars.push(CanonicalVarKind::Region(rustc_type_ir::UniverseIndex::ZERO));
                     Ok(Region::new_bound(
                         self.interner,
                         self.binder,
-                        BoundRegion {
-                            var,
-                            kind: BoundRegionKind::Anon,
-                        },
+                        BoundRegion { var, kind: BoundRegionKind::Anon },
                     ))
                 }
                 RegionKind::ReVar(_) => error(),
         }
     }
 
-    let mut error_replacer = ErrorReplacer {
-        vars: Vec::new(),
-        binder: rustc_type_ir::DebruijnIndex::ZERO,
-        interner,
-    };
+    let mut error_replacer =
+        ErrorReplacer { vars: Vec::new(), binder: rustc_type_ir::DebruijnIndex::ZERO, interner };
     let value = match t.clone().try_fold_with(&mut error_replacer) {
         Ok(t) => t,
         Err(_) => panic!("Encountered unbound or inference vars in {t:?}"),
     let mut table = InferenceTable::new(db, trait_env.clone(), None);
 
     // Register two obligations:
+
     // - Self: FnOnce<?args_ty>
+
     // - <Self as FnOnce<?args_ty>>::Output == ?ret_ty
     let args_ty = table.next_ty_var();
     let args = [self_ty, args_ty];
 where
     T: ?Sized + rustc_type_ir::TypeVisitable<DbInterner<'db>>,
 {
-    let mut collector = ParamCollector {
-        params: FxHashSet::default(),
-    };
+    let mut collector = ParamCollector { params: FxHashSet::default() };
     value.visit_with(&mut collector);
     Vec::from_iter(collector.params)
 }
     db: &'db dyn HirDatabase,
     display_target: DisplayTarget,
 ) -> Option<ConstArg> {
-    Some(make::expr_const_value(
-        konst.display(db, display_target).to_string().as_str(),
-    ))
+    Some(make::expr_const_value(konst.display(db, display_target).to_string().as_str()))
 }
 
 #[derive(Debug, Copy, Clone)]
 pub fn setup_tracing() -> Option<tracing::subscriber::DefaultGuard> {
     use std::env;
     use std::sync::LazyLock;
-    use tracing_subscriber::{layer::SubscriberExt, Registry};
+    use tracing_subscriber::{Registry, layer::SubscriberExt};
     use tracing_tree::HierarchicalLayer;
 
     static ENABLE: LazyLock<bool> = LazyLock::new(|| env::var("CHALK_DEBUG").is_ok());
         return None;
     }
 
-    let filter: tracing_subscriber::filter::Targets = env::var("CHALK_DEBUG")
-        .ok()
-        .and_then(|it| it.parse().ok())
-        .unwrap_or_default();
+    let filter: tracing_subscriber::filter::Targets =
+        env::var("CHALK_DEBUG").ok().and_then(|it| it.parse().ok()).unwrap_or_default();
     let layer = HierarchicalLayer::default()
         .with_indent_lines(true)
         .with_ansi(false)