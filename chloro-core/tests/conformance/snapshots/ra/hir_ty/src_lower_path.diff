COMPARISON DIFF
============================================================

Original size: 55742 bytes
Chloro size:   55215 bytes
Rustfmt size:  55742 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! A wrapper around [`TyLoweringContext`] specifically for lowering paths.
 
 use either::Either;
 use hir_def::{
-    GenericDefId, GenericParamId, Lookup, TraitId, TypeAliasId,
     expr_store::{
-        ExpressionStore, HygieneId,
         path::{
             GenericArg as HirGenericArg, GenericArgs as HirGenericArgs, GenericArgsParentheses,
             Path, PathSegment, PathSegments,
         },
+        ExpressionStore, HygieneId,
     },
-    hir::generics::{
-        GenericParamDataRef, TypeOrConstParamData, TypeParamData, TypeParamProvenance,
-    },
+    hir::generics::{GenericParamDataRef, TypeOrConstParamData, TypeParamData, TypeParamProvenance},
     resolver::{ResolveValueResult, TypeNs, ValueNs},
     signatures::TraitFlags,
     type_ref::{TypeRef, TypeRefId},
+    GenericDefId, GenericParamId, Lookup, TraitId, TypeAliasId,
 };
 use hir_expand::name::Name;
 use rustc_type_ir::{
-    AliasTerm, AliasTy, AliasTyKind,
     inherent::{GenericArgs as _, Region as _, SliceLike, Ty as _},
+    AliasTerm, AliasTy, AliasTyKind,
 };
 use smallvec::SmallVec;
 use stdx::never;
 
 use crate::{
-    GenericArgsProhibitedReason, IncorrectGenericsLenKind, PathGenericsSource,
-    PathLoweringDiagnostic, TyDefId, ValueTyDefId,
     consteval::{unknown_const, unknown_const_as_generic},
     db::HirDatabase,
-    generics::{Generics, generics},
+    generics::{generics, Generics},
     lower::{
-        LifetimeElisionKind, PathDiagnosticCallbackData, named_associated_type_shorthand_candidates,
+        named_associated_type_shorthand_candidates, LifetimeElisionKind,
+        PathDiagnosticCallbackData,
     },
     next_solver::{
         Binder, Clause, Const, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs, Predicate,
         ProjectionPredicate, Region, TraitRef, Ty,
     },
+    GenericArgsProhibitedReason, IncorrectGenericsLenKind, PathGenericsSource,
+    PathLoweringDiagnostic, TyDefId, ValueTyDefId,
 };
-
 use super::{
-    ImplTraitLoweringMode, TyLoweringContext, associated_type_by_name_including_super_traits,
-    const_param_ty_query, ty_query,
+    associated_type_by_name_including_super_traits, const_param_ty_query, ty_query,
+    ImplTraitLoweringMode, TyLoweringContext,
 };
 
-type CallbackData<'a, 'db> = Either<
+type CallbackData<'a, 'db> =
+    Either<
     PathDiagnosticCallbackData,
     crate::infer::diagnostics::PathDiagnosticCallbackData<'a, 'db>,
 >;
 
-// We cannot use `&mut dyn FnMut()` because of lifetime issues, and we don't want to use `Box<dyn FnMut()>`
-// because of the allocation, so we create a lifetime-less callback, tailored for our needs.
 pub(crate) struct PathDiagnosticCallback<'a, 'db> {
     pub(crate) data: CallbackData<'a, 'db>,
-    pub(crate) callback:
-        fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
+    pub(crate) callback: fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
 }
 
 pub(crate) struct PathLoweringContext<'a, 'b, 'db> {
     pub(crate) fn lower_ty_relative_path(
         &mut self,
         ty: Ty<'db>,
-        // We need the original resolution to lower `Self::AssocTy` correctly
         res: Option<TypeNs>,
         infer_args: bool,
     ) -> (Ty<'db>, Option<TypeNs>) {
         }
     }
 
-    // When calling this, the current segment is the resolved segment (we don't advance it yet).
     pub(crate) fn lower_partly_resolved_path(
         &mut self,
         resolution: TypeNs,
     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.
     pub(crate) fn substs_from_path(
         &mut self,
-        // Note that we don't call `db.value_type(resolved)` here,
-        // `ValueTyDefId` is just a convenient way to pass generics and
-        // special-case enum variants
         resolved: ValueTyDefId,
         infer_args: bool,
         lowering_assoc_type_generics: bool,
         arg: &HirGenericArg,
     ) -> GenericArg<'db>;
 
-    fn provided_type_like_const(&mut self, const_ty: Ty<'db>, arg: TypeLikeConst<'_>)
-    -> Const<'db>;
+    fn provided_type_like_const(
+        &mut self,
+        const_ty: Ty<'db>,
+        arg: TypeLikeConst<'_>,
+    ) -> Const<'db>;
 
     fn inferred_kind(
         &mut self,
     let interner = DbInterner::new_with(db, None, None);
 
     tracing::debug!(?args_and_bindings);
-
     // Order is
     // - Parent parameters
     // - Optional Self parameter
     // - Lifetime parameters
     // - Type or Const parameters
+
     let def_generics = generics(db, def);
     let args_slice = args_and_bindings.map(|it| &*it.args).unwrap_or_default();
-
     // We do not allow inference if there are specified args, i.e. we do not allow partial inference.
+
     let has_non_lifetime_args =
         args_slice.iter().any(|arg| !matches!(arg, HirGenericArg::Lifetime(_)));
     infer_args &= !has_non_lifetime_args;
 
     let mut args = args_slice.iter().enumerate().peekable();
     let mut params = def_generics.iter_self().peekable();
-
     // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.
     // If we later encounter a lifetime, we know that the arguments were provided in the
     // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be
     // inferred, so we can use it for diagnostics later.
+
     let mut force_infer_lt = None;
 
     let has_self_arg = args_and_bindings.is_some_and(|it| it.has_self_type);
     }
 }
 
-fn unknown_subst<'db>(interner: DbInterner<'db>, def: impl Into<GenericDefId>) -> GenericArgs<'db> {
+fn unknown_subst<'db>(
+    interner: DbInterner<'db>,
+    def: impl Into<GenericDefId>,
+) -> GenericArgs<'db> {
     let params = generics(interner.db(), def.into());
     GenericArgs::new_from_iter(
         interner,