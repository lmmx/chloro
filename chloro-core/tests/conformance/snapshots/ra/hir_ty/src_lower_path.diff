COMPARISON DIFF
============================================================

Original size: 55742 bytes
Chloro size:   55327 bytes
Rustfmt size:  55742 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
             Path, PathSegment, PathSegments,
         },
     },
-    hir::generics::{
-        GenericParamDataRef, TypeOrConstParamData, TypeParamData, TypeParamProvenance,
-    },
+    hir::generics::{GenericParamDataRef, TypeOrConstParamData, TypeParamData, TypeParamProvenance},
     resolver::{ResolveValueResult, TypeNs, ValueNs},
     signatures::TraitFlags,
     type_ref::{TypeRef, TypeRefId},
     db::HirDatabase,
     generics::{Generics, generics},
     lower::{
-        LifetimeElisionKind, PathDiagnosticCallbackData, named_associated_type_shorthand_candidates,
+        LifetimeElisionKind, PathDiagnosticCallbackData,
+        named_associated_type_shorthand_candidates,
     },
     next_solver::{
         Binder, Clause, Const, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs, Predicate,
     const_param_ty_query, ty_query,
 };
 
-type CallbackData<'a, 'db> = Either<
+type CallbackData<'a, 'db> =
+    Either<
     PathDiagnosticCallbackData,
     crate::infer::diagnostics::PathDiagnosticCallbackData<'a, 'db>,
 >;
 
-// We cannot use `&mut dyn FnMut()` because of lifetime issues, and we don't want to use `Box<dyn FnMut()>`
-// because of the allocation, so we create a lifetime-less callback, tailored for our needs.
 pub(crate) struct PathDiagnosticCallback<'a, 'db> {
     pub(crate) data: CallbackData<'a, 'db>,
-    pub(crate) callback:
-        fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
+    pub(crate) callback: fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
 }
 
 pub(crate) struct PathLoweringContext<'a, 'b, 'db> {
     pub(crate) fn lower_ty_relative_path(
         &mut self,
         ty: Ty<'db>,
-        // We need the original resolution to lower `Self::AssocTy` correctly
         res: Option<TypeNs>,
         infer_args: bool,
     ) -> (Ty<'db>, Option<TypeNs>) {
             res,
             Some(assoc_name.clone()),
             check_alias,
+        ).unwrap_or_else(
+            || Ty::new_error(interner, ErrorGuaranteed),
         )
-        .unwrap_or_else(|| Ty::new_error(interner, ErrorGuaranteed))
     }
 
     fn lower_path_inner(&mut self, typeable: TyDefId, infer_args: bool) -> Ty<'db> {
     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.
     pub(crate) fn substs_from_path(
         &mut self,
-        // Note that we don't call `db.value_type(resolved)` here,
-        // `ValueTyDefId` is just a convenient way to pass generics and
-        // special-case enum variants
         resolved: ValueTyDefId,
         infer_args: bool,
         lowering_assoc_type_generics: bool,
         arg: &HirGenericArg,
     ) -> GenericArg<'db>;
 
-    fn provided_type_like_const(&mut self, const_ty: Ty<'db>, arg: TypeLikeConst<'_>)
-    -> Const<'db>;
+    fn provided_type_like_const(
+        &mut self,
+        const_ty: Ty<'db>,
+        arg: TypeLikeConst<'_>,
+    ) -> Const<'db>;
 
     fn inferred_kind(
         &mut self,
     }
 }
 
-fn unknown_subst<'db>(interner: DbInterner<'db>, def: impl Into<GenericDefId>) -> GenericArgs<'db> {
+fn unknown_subst<'db>(
+    interner: DbInterner<'db>,
+    def: impl Into<GenericDefId>,
+) -> GenericArgs<'db> {
     let params = generics(interner.db(), def.into());
     GenericArgs::new_from_iter(
         interner,