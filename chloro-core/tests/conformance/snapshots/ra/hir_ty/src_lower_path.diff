COMPARISON DIFF
============================================================

Original size: 55742 bytes
Chloro size:   55336 bytes
Rustfmt size:  57812 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
             Path, PathSegment, PathSegments,
         },
     },
-    hir::generics::{
-        GenericParamDataRef, TypeOrConstParamData, TypeParamData, TypeParamProvenance,
-    },
+    hir::generics::{GenericParamDataRef, TypeOrConstParamData, TypeParamData, TypeParamProvenance},
     resolver::{ResolveValueResult, TypeNs, ValueNs},
     signatures::TraitFlags,
     type_ref::{TypeRef, TypeRefId},
     db::HirDatabase,
     generics::{Generics, generics},
     lower::{
-        LifetimeElisionKind, PathDiagnosticCallbackData, named_associated_type_shorthand_candidates,
+        LifetimeElisionKind, PathDiagnosticCallbackData,
+        named_associated_type_shorthand_candidates,
     },
     next_solver::{
         Binder, Clause, Const, DbInterner, ErrorGuaranteed, GenericArg, GenericArgs, Predicate,
     const_param_ty_query, ty_query,
 };
 
-type CallbackData<'a, 'db> = Either<
+type CallbackData<'a, 'db> =
+    Either<
     PathDiagnosticCallbackData,
     crate::infer::diagnostics::PathDiagnosticCallbackData<'a, 'db>,
 >;
 
-// We cannot use `&mut dyn FnMut()` because of lifetime issues, and we don't want to use `Box<dyn FnMut()>`
-// because of the allocation, so we create a lifetime-less callback, tailored for our needs.
 pub(crate) struct PathDiagnosticCallback<'a, 'db> {
     pub(crate) data: CallbackData<'a, 'db>,
-    pub(crate) callback:
-        fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
+    pub(crate) callback: fn(&CallbackData<'_, 'db>, &mut TyLoweringContext<'db, '_>, PathLoweringDiagnostic),
 }
 
 pub(crate) struct PathLoweringContext<'a, 'b, 'db> {
 
     #[inline]
     fn update_current_segment(&mut self) {
-        self.current_or_prev_segment = self
-            .segments
-            .get(self.current_segment_idx)
-            .unwrap_or(self.current_or_prev_segment);
+        self.current_or_prev_segment =
+            self.segments.get(self.current_segment_idx).unwrap_or(self.current_or_prev_segment);
     }
 
     #[inline]
     pub(crate) fn lower_ty_relative_path(
         &mut self,
         ty: Ty<'db>,
-        // We need the original resolution to lower `Self::AssocTy` correctly
         res: Option<TypeNs>,
         infer_args: bool,
     ) -> (Ty<'db>, Option<TypeNs>) {
                         self.skip_resolved_segment();
                         let segment = self.current_or_prev_segment;
                         let trait_id = trait_ref.def_id.0;
-                        let found = trait_id
-                            .trait_items(self.ctx.db)
-                            .associated_type_by_name(segment.name);
+                        let found =
+                            trait_id.trait_items(self.ctx.db).associated_type_by_name(segment.name);
 
                         tracing::debug!(?found);
                         match found {
 
     #[tracing::instrument(skip(self), ret)]
     pub(crate) fn resolve_path_in_type_ns(&mut self) -> Option<(TypeNs, Option<usize>)> {
-        let (resolution, remaining_index, _, prefix_info) = self
-            .ctx
-            .resolver
-            .resolve_path_in_type_ns_with_prefix_info(self.ctx.db, self.path)?;
+        let (resolution, remaining_index, _, prefix_info) =
+            self.ctx.resolver.resolve_path_in_type_ns_with_prefix_info(self.ctx.db, self.path)?;
 
         let segments = self.segments;
         if segments.is_empty() || matches!(self.path, Path::LangItem(..)) {
         }
 
         let (module_segments, resolved_segment_idx, enum_segment) = match remaining_index {
-            None if prefix_info.enum_variant => (
-                segments.strip_last_two(),
-                segments.len() - 1,
-                Some(segments.len() - 2),
-            ),
+            None if prefix_info.enum_variant => {
+                (segments.strip_last_two(), segments.len() - 1, Some(segments.len() - 2))
+            }
             None => (segments.strip_last(), segments.len() - 1, None),
             Some(i) => (segments.take(i - 1), i - 1, None),
         };
 
         self.current_segment_idx = resolved_segment_idx;
-        self.current_or_prev_segment = segments
-            .get(resolved_segment_idx)
-            .expect("should have resolved segment");
+        self.current_or_prev_segment =
+            segments.get(resolved_segment_idx).expect("should have resolved segment");
 
         for (i, mod_segment) in module_segments.iter().enumerate() {
             if mod_segment.args_and_bindings.is_some() {
         }
 
         if let Some(enum_segment) = enum_segment
-            && segments
-                .get(enum_segment)
-                .is_some_and(|it| it.args_and_bindings.is_some())
-            && segments
-                .get(enum_segment + 1)
-                .is_some_and(|it| it.args_and_bindings.is_some())
+            && segments.get(enum_segment).is_some_and(|it| it.args_and_bindings.is_some())
+            && segments.get(enum_segment + 1).is_some_and(|it| it.args_and_bindings.is_some())
         {
             self.on_diagnostic(PathLoweringDiagnostic::GenericArgsProhibited {
                 segment: (enum_segment + 1) as u32,
         &mut self,
         hygiene_id: HygieneId,
     ) -> Option<ResolveValueResult> {
-        let (res, prefix_info) = self
-            .ctx
-            .resolver
-            .resolve_path_in_value_ns_with_prefix_info(self.ctx.db, self.path, hygiene_id)?;
+        let (res, prefix_info) = self.ctx.resolver.resolve_path_in_value_ns_with_prefix_info(
+            self.ctx.db,
+            self.path,
+            hygiene_id,
+        )?;
 
         let segments = self.segments;
         if segments.is_empty() || matches!(self.path, Path::LangItem(..)) {
         }
 
         let (mod_segments, enum_segment, resolved_segment_idx) = match res {
-            ResolveValueResult::Partial(_, unresolved_segment, _) => (
-                segments.take(unresolved_segment - 1),
-                None,
-                unresolved_segment - 1,
-            ),
+            ResolveValueResult::Partial(_, unresolved_segment, _) => {
+                (segments.take(unresolved_segment - 1), None, unresolved_segment - 1)
+            }
             ResolveValueResult::ValueNs(ValueNs::EnumVariantId(_), _)
                 if prefix_info.enum_variant =>
             {
-                (
-                    segments.strip_last_two(),
-                    segments.len().checked_sub(2),
-                    segments.len() - 1,
-                )
+                (segments.strip_last_two(), segments.len().checked_sub(2), segments.len() - 1)
             }
             ResolveValueResult::ValueNs(..) => (segments.strip_last(), None, segments.len() - 1),
         };
 
         self.current_segment_idx = resolved_segment_idx;
-        self.current_or_prev_segment = segments
-            .get(resolved_segment_idx)
-            .expect("should have resolved segment");
+        self.current_or_prev_segment =
+            segments.get(resolved_segment_idx).expect("should have resolved segment");
 
         for (i, mod_segment) in mod_segments.iter().enumerate() {
             if mod_segment.args_and_bindings.is_some() {
         }
 
         if let Some(enum_segment) = enum_segment
-            && segments
-                .get(enum_segment)
-                .is_some_and(|it| it.args_and_bindings.is_some())
-            && segments
-                .get(enum_segment + 1)
-                .is_some_and(|it| it.args_and_bindings.is_some())
+            && segments.get(enum_segment).is_some_and(|it| it.args_and_bindings.is_some())
+            && segments.get(enum_segment + 1).is_some_and(|it| it.args_and_bindings.is_some())
         {
             self.on_diagnostic(PathLoweringDiagnostic::GenericArgsProhibited {
                 segment: (enum_segment + 1) as u32,
             Some(assoc_name.clone()),
             check_alias,
         )
-        .unwrap_or_else(|| Ty::new_error(interner, ErrorGuaranteed))
+        .unwrap_or_else(
+            || Ty::new_error(interner, ErrorGuaranteed),
+        )
     }
 
     fn lower_path_inner(&mut self, typeable: TyDefId, infer_args: bool) -> Ty<'db> {
     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.
     pub(crate) fn substs_from_path(
         &mut self,
-        // Note that we don't call `db.value_type(resolved)` here,
-        // `ValueTyDefId` is just a convenient way to pass generics and
-        // special-case enum variants
         resolved: ValueTyDefId,
         infer_args: bool,
         lowering_assoc_type_generics: bool,
             }
 
             // `Fn()`-style generics are treated like functions for the purpose of lifetime elision.
-            self.ctx.lifetime_elision = LifetimeElisionKind::AnonymousCreateParameter {
-                report_in_path: false,
-            };
+            self.ctx.lifetime_elision =
+                LifetimeElisionKind::AnonymousCreateParameter { report_in_path: false };
         }
 
         let result = self.substs_from_args_and_bindings(
                 expected_count: u32,
                 kind: IncorrectGenericsLenKind,
             ) {
-                self.ctx
-                    .on_diagnostic(PathLoweringDiagnostic::IncorrectGenericsLen {
-                        generics_source: self.generics_source,
-                        provided_count,
-                        expected_count,
-                        kind,
-                        def,
-                    });
+                self.ctx.on_diagnostic(PathLoweringDiagnostic::IncorrectGenericsLen {
+                    generics_source: self.generics_source,
+                    provided_count,
+                    expected_count,
+                    kind,
+                    def,
+                });
             }
 
             fn report_arg_mismatch(
                 arg_idx: u32,
                 has_self_arg: bool,
             ) {
-                self.ctx
-                    .on_diagnostic(PathLoweringDiagnostic::IncorrectGenericsOrder {
-                        generics_source: self.generics_source,
-                        param_id,
-                        arg_idx,
-                        has_self_arg,
-                    });
+                self.ctx.on_diagnostic(PathLoweringDiagnostic::IncorrectGenericsOrder {
+                    generics_source: self.generics_source,
+                    param_id,
+                    arg_idx,
+                    has_self_arg,
+                });
             }
 
             fn provided_kind(
                 infer_args: bool,
                 preceding_args: &[GenericArg<'db>],
             ) -> GenericArg<'db> {
-                let default = || {
-                    self.ctx
-                        .ctx
-                        .db
-                        .generic_defaults(def)
-                        .get(preceding_args.len())
-                        .map(|default| default.instantiate(self.ctx.ctx.interner, preceding_args))
-                };
+                let default =
+                    || {
+                        self.ctx.ctx.db.generic_defaults(def).get(preceding_args.len()).map(
+                            |default| default.instantiate(self.ctx.ctx.interner, preceding_args),
+                        )
+                    };
                 match param {
-                    GenericParamDataRef::LifetimeParamData(_) => Region::new(
-                        self.ctx.ctx.interner,
-                        rustc_type_ir::ReError(ErrorGuaranteed),
-                    )
-                    .into(),
+                    GenericParamDataRef::LifetimeParamData(_) => {
+                        Region::new(self.ctx.ctx.interner, rustc_type_ir::ReError(ErrorGuaranteed))
+                            .into()
+                    }
                     GenericParamDataRef::TypeParamData(param) => {
                         if !infer_args
                             && param.default.is_some()
                     GenericParamId::ConstParamId(const_id) => {
                         unknown_const_as_generic(const_param_ty_query(self.ctx.ctx.db, const_id))
                     }
-                    GenericParamId::LifetimeParamId(_) => Region::new(
-                        self.ctx.ctx.interner,
-                        rustc_type_ir::ReError(ErrorGuaranteed),
-                    )
-                    .into(),
+                    GenericParamId::LifetimeParamId(_) => {
+                        Region::new(self.ctx.ctx.interner, rustc_type_ir::ReError(ErrorGuaranteed))
+                            .into()
+                    }
                 }
             }
 
                 expected_count: u32,
                 hard_error: bool,
             ) {
-                self.ctx
-                    .on_diagnostic(PathLoweringDiagnostic::ElidedLifetimesInPath {
-                        generics_source: self.generics_source,
-                        def,
-                        expected_count,
-                        hard_error,
-                    });
+                self.ctx.on_diagnostic(PathLoweringDiagnostic::ElidedLifetimesInPath {
+                    generics_source: self.generics_source,
+                    def,
+                    expected_count,
+                    hard_error,
+                });
             }
 
             fn report_elision_failure(&mut self, def: GenericDefId, expected_count: u32) {
-                self.ctx
-                    .on_diagnostic(PathLoweringDiagnostic::ElisionFailure {
-                        generics_source: self.generics_source,
-                        def,
-                        expected_count,
-                    });
+                self.ctx.on_diagnostic(PathLoweringDiagnostic::ElisionFailure {
+                    generics_source: self.generics_source,
+                    def,
+                    expected_count,
+                });
             }
 
             fn report_missing_lifetime(&mut self, def: GenericDefId, expected_count: u32) {
-                self.ctx
-                    .on_diagnostic(PathLoweringDiagnostic::MissingLifetime {
-                        generics_source: self.generics_source,
-                        def,
-                        expected_count,
-                    });
+                self.ctx.on_diagnostic(PathLoweringDiagnostic::MissingLifetime {
+                    generics_source: self.generics_source,
+                    def,
+                    expected_count,
+                });
             }
         }
 
             lifetime_elision,
             lowering_assoc_type_generics,
             explicit_self_ty,
-            &mut LowererCtx {
-                ctx: self,
-                generics_source,
-            },
+            &mut LowererCtx { ctx: self, generics_source },
         )
     }
 
         trait_ref: TraitRef<'db>,
     ) -> Option<impl Iterator<Item = Clause<'db>> + use<'a, 'b, 'c, 'db>> {
         let interner = self.ctx.interner;
-        self.current_or_prev_segment
-            .args_and_bindings
-            .map(|args_and_bindings| {
-                args_and_bindings.bindings.iter().enumerate().flat_map(
-                    move |(binding_idx, binding)| {
-                        let found = associated_type_by_name_including_super_traits(
-                            self.ctx.db,
-                            trait_ref,
-                            &binding.name,
-                        );
-                        let (super_trait_ref, associated_ty) = match found {
-                            None => return SmallVec::new(),
-                            Some(t) => t,
-                        };
-                        let args = self.with_lifetime_elision(
-                            LifetimeElisionKind::AnonymousReportError,
-                            |this| {
-                                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent
-                                // generic params. It's inefficient to splice the `Substitution`s, so we may want
-                                // that method to optionally take parent `Substitution` as we already know them at
-                                // this point (`super_trait_ref.substitution`).
-                                this.substs_from_args_and_bindings(
-                                    binding.args.as_ref(),
-                                    associated_ty.into(),
-                                    false, // this is not relevant
-                                    Some(super_trait_ref.self_ty()),
-                                    PathGenericsSource::AssocType {
-                                        segment: this.current_segment_u32(),
-                                        assoc_type: binding_idx as u32,
-                                    },
-                                    false,
-                                    this.ctx.lifetime_elision.clone(),
-                                )
+        self.current_or_prev_segment.args_and_bindings.map(|args_and_bindings| {
+            args_and_bindings.bindings.iter().enumerate().flat_map(move |(binding_idx, binding)| {
+                let found = associated_type_by_name_including_super_traits(
+                    self.ctx.db,
+                    trait_ref,
+                    &binding.name,
+                );
+                let (super_trait_ref, associated_ty) = match found {
+                    None => return SmallVec::new(),
+                    Some(t) => t,
+                };
+                let args =
+                    self.with_lifetime_elision(LifetimeElisionKind::AnonymousReportError, |this| {
+                        // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent
+                        // generic params. It's inefficient to splice the `Substitution`s, so we may want
+                        // that method to optionally take parent `Substitution` as we already know them at
+                        // this point (`super_trait_ref.substitution`).
+                        this.substs_from_args_and_bindings(
+                            binding.args.as_ref(),
+                            associated_ty.into(),
+                            false, // this is not relevant
+                            Some(super_trait_ref.self_ty()),
+                            PathGenericsSource::AssocType {
+                                segment: this.current_segment_u32(),
+                                assoc_type: binding_idx as u32,
                             },
-                        );
-                        let args = GenericArgs::new_from_iter(
-                            interner,
-                            super_trait_ref
-                                .args
-                                .iter()
-                                .chain(args.iter().skip(super_trait_ref.args.len())),
-                        );
-                        let projection_term =
-                            AliasTerm::new_from_args(interner, associated_ty.into(), args);
-                        let mut predicates: SmallVec<[_; 1]> = SmallVec::with_capacity(
-                            binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),
-                        );
-                        if let Some(type_ref) = binding.type_ref {
-                            let lifetime_elision = if args_and_bindings.parenthesized
-                                == GenericArgsParentheses::ParenSugar
-                            {
-                                // `Fn()`-style generics are elided like functions. This is `Output` (we lower to it in hir-def).
-                                LifetimeElisionKind::for_fn_ret(self.ctx.interner)
-                            } else {
-                                self.ctx.lifetime_elision.clone()
-                            };
-                            self.with_lifetime_elision(lifetime_elision, |this| {
-                                match (&this.ctx.store[type_ref], this.ctx.impl_trait_mode.mode) {
-                                    (TypeRef::ImplTrait(_), ImplTraitLoweringMode::Disallowed) => {
-                                        ()
-                                    }
-                                    (
-                                        _,
-                                        ImplTraitLoweringMode::Disallowed
-                                        | ImplTraitLoweringMode::Opaque,
-                                    ) => {
-                                        let ty = this.ctx.lower_ty(type_ref);
-                                        let pred = Clause(Predicate::new(
-                                            interner,
-                                            Binder::dummy(rustc_type_ir::PredicateKind::Clause(
-                                                rustc_type_ir::ClauseKind::Projection(
-                                                    ProjectionPredicate {
-                                                        projection_term,
-                                                        term: ty.into(),
-                                                    },
-                                                ),
-                                            )),
-                                        ));
-                                        predicates.push(pred);
-                                    }
-                                }
-                            })
+                            false,
+                            this.ctx.lifetime_elision.clone(),
+                        )
+                    });
+                let args = GenericArgs::new_from_iter(
+                    interner,
+                    super_trait_ref.args.iter().chain(args.iter().skip(super_trait_ref.args.len())),
+                );
+                let projection_term =
+                    AliasTerm::new_from_args(interner, associated_ty.into(), args);
+                let mut predicates: SmallVec<[_; 1]> = SmallVec::with_capacity(
+                    binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),
+                );
+                if let Some(type_ref) = binding.type_ref {
+                    let lifetime_elision =
+                        if args_and_bindings.parenthesized == GenericArgsParentheses::ParenSugar {
+                            // `Fn()`-style generics are elided like functions. This is `Output` (we lower to it in hir-def).
+                            LifetimeElisionKind::for_fn_ret(self.ctx.interner)
+                        } else {
+                            self.ctx.lifetime_elision.clone()
+                        };
+                    self.with_lifetime_elision(lifetime_elision, |this| {
+                        match (&this.ctx.store[type_ref], this.ctx.impl_trait_mode.mode) {
+                            (TypeRef::ImplTrait(_), ImplTraitLoweringMode::Disallowed) => (),
+                            (
+                                _,
+                                ImplTraitLoweringMode::Disallowed | ImplTraitLoweringMode::Opaque,
+                            ) => {
+                                let ty = this.ctx.lower_ty(type_ref);
+                                let pred = Clause(Predicate::new(
+                                    interner,
+                                    Binder::dummy(rustc_type_ir::PredicateKind::Clause(
+                                        rustc_type_ir::ClauseKind::Projection(
+                                            ProjectionPredicate {
+                                                projection_term,
+                                                term: ty.into(),
+                                            },
+                                        ),
+                                    )),
+                                ));
+                                predicates.push(pred);
+                            }
                         }
-                        for bound in binding.bounds.iter() {
-                            predicates.extend(self.ctx.lower_type_bound(
-                                bound,
-                                Ty::new_alias(
-                                    self.ctx.interner,
-                                    AliasTyKind::Projection,
-                                    AliasTy::new_from_args(
-                                        self.ctx.interner,
-                                        associated_ty.into(),
-                                        args,
-                                    ),
-                                ),
-                                false,
-                            ));
-                        }
-                        predicates
-                    },
-                )
+                    })
+                }
+                for bound in binding.bounds.iter() {
+                    predicates.extend(self.ctx.lower_type_bound(
+                        bound,
+                        Ty::new_alias(
+                            self.ctx.interner,
+                            AliasTyKind::Projection,
+                            AliasTy::new_from_args(self.ctx.interner, associated_ty.into(), args),
+                        ),
+                        false,
+                    ));
+                }
+                predicates
             })
+        })
     }
 }
 
         arg: &HirGenericArg,
     ) -> GenericArg<'db>;
 
-    fn provided_type_like_const(&mut self, const_ty: Ty<'db>, arg: TypeLikeConst<'_>)
-    -> Const<'db>;
+    fn provided_type_like_const(
+        &mut self,
+        const_ty: Ty<'db>,
+        arg: TypeLikeConst<'_>,
+    ) -> Const<'db>;
 
     fn inferred_kind(
         &mut self,
         had_error = true;
     }
 
-    let defaults_count = def_generics
-        .iter_self_type_or_consts()
-        .filter(|(_, param)| param.has_default())
-        .count();
+    let defaults_count =
+        def_generics.iter_self_type_or_consts().filter(|(_, param)| param.has_default()).count();
     let named_type_and_const_params_count = def_generics
         .iter_self_type_or_consts()
         .filter(|(_, param)| match param {
         })
         .count();
     let expected_max = named_type_and_const_params_count;
-    let expected_min = if infer_args {
-        0
-    } else {
-        named_type_and_const_params_count - defaults_count
-    };
+    let expected_min =
+        if infer_args { 0 } else { named_type_and_const_params_count - defaults_count };
     if provided_types_and_consts_count < expected_min
         || expected_max < provided_types_and_consts_count
     {
     let args_slice = args_and_bindings.map(|it| &*it.args).unwrap_or_default();
 
     // We do not allow inference if there are specified args, i.e. we do not allow partial inference.
-    let has_non_lifetime_args = args_slice
-        .iter()
-        .any(|arg| !matches!(arg, HirGenericArg::Lifetime(_)));
+    let has_non_lifetime_args =
+        args_slice.iter().any(|arg| !matches!(arg, HirGenericArg::Lifetime(_)));
     infer_args &= !has_non_lifetime_args;
 
     let had_count_error = check_generic_args_len(
     )) = params.peek()
     {
         let self_ty = if has_self_arg {
-            let (_, self_ty) = args
-                .next()
-                .expect("has_self_type=true, should have Self type");
+            let (_, self_ty) = args.next().expect("has_self_type=true, should have Self type");
             ctx.provided_kind(self_param_id, self_param, self_ty)
         } else {
             explicit_self_ty.map(|it| it.into()).unwrap_or_else(|| {
                 let param = if let GenericParamId::LifetimeParamId(_) = param_id {
                     match &lifetime_elision {
                         LifetimeElisionKind::ElisionFailure
-                        | LifetimeElisionKind::AnonymousCreateParameter {
-                            report_in_path: true,
-                        }
+                        | LifetimeElisionKind::AnonymousCreateParameter { report_in_path: true }
                         | LifetimeElisionKind::AnonymousReportError => {
                             assert!(had_count_error);
                             ctx.inferred_kind(def, param_id, param, infer_args, &substs)
                             Region::new_static(interner).into()
                         }
                         LifetimeElisionKind::Elided(lifetime) => (*lifetime).into(),
-                        LifetimeElisionKind::AnonymousCreateParameter {
-                            report_in_path: false,
-                        }
+                        LifetimeElisionKind::AnonymousCreateParameter { report_in_path: false }
                         | LifetimeElisionKind::Infer => {
                             // FIXME: With `AnonymousCreateParameter`, we need to create a new lifetime parameter here
                             // (but this will probably be done in hir-def lowering instead).
     }
 }
 
-fn unknown_subst<'db>(interner: DbInterner<'db>, def: impl Into<GenericDefId>) -> GenericArgs<'db> {
+fn unknown_subst<'db>(
+    interner: DbInterner<'db>,
+    def: impl Into<GenericDefId>,
+) -> GenericArgs<'db> {
     let params = generics(interner.db(), def.into());
     GenericArgs::new_from_iter(
         interner,