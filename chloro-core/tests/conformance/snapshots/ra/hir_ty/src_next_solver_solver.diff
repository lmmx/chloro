COMPARISON DIFF
============================================================

Original size: 13159 bytes
Chloro size:   13180 bytes
Rustfmt size:  13311 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     ImplTraitId,
     next_solver::{
-        AliasTy, CanonicalVarKind, Clause, ClauseKind, CoercePredicate, GenericArgs, ImplIdWrapper,
-        ParamEnv, Predicate, PredicateKind, SubtypePredicate, Ty, TyKind, fold::fold_tys,
-        util::sizedness_fast_path,
+        AliasTy, CanonicalVarKind, Clause, ClauseKind, CoercePredicate, GenericArgs,
+        ImplIdWrapper, ParamEnv, Predicate, PredicateKind, SubtypePredicate, Ty, TyKind,
+        fold::fold_tys, util::sizedness_fast_path,
     },
 };
 
 impl<'a, 'db> From<&'a InferCtxt<'db>> for &'a SolverContext<'db> {
     fn from(infcx: &'a InferCtxt<'db>) -> Self {
         // SAFETY: `repr(transparent)`
-        unsafe { std::mem::transmute(infcx) }
+        unsafe {
+            std::mem::transmute(infcx)
+        }
     }
 }
 
 
 impl<'db> SolverDelegate for SolverContext<'db> {
     type Interner = DbInterner<'db>;
+
     type Infcx = InferCtxt<'db>;
 
     fn cx(&self) -> Self::Interner {
         var_values: &[GenericArg<'db>],
         universe_map: impl Fn(rustc_type_ir::UniverseIndex) -> rustc_type_ir::UniverseIndex,
     ) -> GenericArg<'db> {
-        self.0
-            .instantiate_canonical_var(kind, var_values, universe_map)
+        self.0.instantiate_canonical_var(kind, var_values, universe_map)
     }
 
     fn add_item_bounds_for_hidden_type(
         // type during MIR borrowck, causing us to infer the wrong
         // lifetime for its member constraints which then results in
         // unexpected region errors.
-        goals.push(Goal::new(
-            interner,
-            param_env,
-            ClauseKind::WellFormed(hidden_ty.into()),
-        ));
+        goals.push(Goal::new(interner, param_env, ClauseKind::WellFormed(hidden_ty.into())));
 
         let replace_opaques_in = |clause: Clause<'db>| {
             fold_tys(interner, clause, |ty| match ty.kind() {
                 // as the bounds must hold on the hidden type after all.
                 TyKind::Alias(
                     AliasTyKind::Opaque,
-                    AliasTy {
-                        def_id: def_id2,
-                        args: args2,
-                        ..
-                    },
+                    AliasTy { def_id: def_id2, args: args2, .. },
                 ) if def_id == def_id2 && args == args2 => hidden_ty,
                 _ => ty,
             })