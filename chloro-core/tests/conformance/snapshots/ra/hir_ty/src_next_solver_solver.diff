COMPARISON DIFF
============================================================

Original size: 13159 bytes
Chloro size:   13164 bytes
Rustfmt size:  13159 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Defining `SolverContext` for next-trait-solver.
 
 use hir_def::{AssocItemId, GeneralConstId};
 use rustc_next_trait_solver::delegate::SolverDelegate;
 use rustc_type_ir::{
-    AliasTyKind, GenericArgKind, InferCtxtLike, Interner, PredicatePolarity, TypeFlags,
-    TypeVisitableExt,
     inherent::{IntoKind, SliceLike, Term as _, Ty as _},
     lang_items::SolverTraitLangItem,
     solve::{Certainty, NoSolution},
+    AliasTyKind, GenericArgKind, InferCtxtLike, Interner, PredicatePolarity, TypeFlags,
+    TypeVisitableExt,
 };
 use tracing::debug;
 
 use crate::{
-    ImplTraitId,
     next_solver::{
         AliasTy, CanonicalVarKind, Clause, ClauseKind, CoercePredicate, GenericArgs, ImplIdWrapper,
         ParamEnv, Predicate, PredicateKind, SubtypePredicate, Ty, TyKind, fold::fold_tys,
         util::sizedness_fast_path,
     },
+    ImplTraitId,
 };
-
 use super::{
-    DbInterner, ErrorGuaranteed, GenericArg, SolverDefId, Span,
     infer::{DbInternerInferExt, InferCtxt, canonical::instantiate::CanonicalExt},
+    DbInterner, ErrorGuaranteed, GenericArg, SolverDefId, Span,
 };
 
 pub type Goal<'db, P> = rustc_type_ir::solve::Goal<DbInterner<'db>, P>;
 
 impl<'db> SolverDelegate for SolverContext<'db> {
     type Interner = DbInterner<'db>;
+
     type Infcx = InferCtxt<'db>;
 
     fn cx(&self) -> Self::Interner {
         canonical: &rustc_type_ir::CanonicalQueryInput<Self::Interner, V>,
     ) -> (Self, V, rustc_type_ir::CanonicalVarValues<Self::Interner>)
     where
-        V: rustc_type_ir::TypeFoldable<Self::Interner>,
-    {
+        V: rustc_type_ir::TypeFoldable<Self::Interner>, {
         let (infcx, value, vars) = cx.infer_ctxt().build_with_canonical(canonical);
         (SolverContext(infcx), value, vars)
     }
 
-    fn fresh_var_for_kind_with_span(&self, arg: GenericArg<'db>, _span: Span) -> GenericArg<'db> {
+    fn fresh_var_for_kind_with_span(
+        &self,
+        arg: GenericArg<'db>,
+        _span: Span,
+    ) -> GenericArg<'db> {
         match arg.kind() {
             GenericArgKind::Lifetime(_) => self.next_region_var().into(),
             GenericArgKind::Type(_) => self.next_ty_var().into(),
         None
     }
 
-    fn make_deduplicated_outlives_constraints(
-        &self,
-    ) -> Vec<
+    fn make_deduplicated_outlives_constraints(&self) -> Vec<
         rustc_type_ir::OutlivesPredicate<
             Self::Interner,
             <Self::Interner as rustc_type_ir::Interner>::GenericArg,
         values: rustc_type_ir::CanonicalVarValues<Self::Interner>,
     ) -> V
     where
-        V: rustc_type_ir::TypeFoldable<Self::Interner>,
-    {
+        V: rustc_type_ir::TypeFoldable<Self::Interner>, {
         canonical.instantiate(self.cx(), &values)
     }
 
         // lifetime for its member constraints which then results in
         // unexpected region errors.
         goals.push(Goal::new(interner, param_env, ClauseKind::WellFormed(hidden_ty.into())));
-
         let replace_opaques_in = |clause: Clause<'db>| {
             fold_tys(interner, clause, |ty| match ty.kind() {
                 // Replace all other mentions of the same opaque type with the hidden type,
                 _ => ty,
             })
         };
-
         let db = interner.db;
         let (opaques_table, opaque_idx) = match opaque_id.loc(db) {
             ImplTraitId::ReturnTypeImplTrait(func, opaque_idx) => {
                 }
             }
         }
-
         let pred = goal.predicate.kind();
         match pred.no_bound_vars()? {
             PredicateKind::Clause(ClauseKind::RegionOutlives(_outlives)) => Some(Certainty::Yes),