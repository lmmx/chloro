COMPARISON DIFF
============================================================

Original size: 7261 bytes
Chloro size:   7255 bytes
Rustfmt size:  7430 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use triomphe::Arc;
 
 use crate::{
+    ImplTraitId,
     db::{HirDatabase, InternedOpaqueTyId},
     lower::{ImplTraitIdx, ImplTraits},
     next_solver::{
-        infer::{traits::ObligationCause, DbInternerInferExt},
-        obligation_ctxt::ObligationCtxt,
         DbInterner, EarlyBinder, ErrorGuaranteed, SolverDefId, Ty, TypingMode,
+        infer::{DbInternerInferExt, traits::ObligationCause}, obligation_ctxt::ObligationCtxt,
     },
-    ImplTraitId,
 };
 
 pub(crate) fn opaque_types_defined_by(
     };
 
     // Collect opaques from assoc items.
+
     let extend_with_atpit_from_assoc_items = |assoc_items: &[(Name, AssocItemId)]| {
         assoc_items
             .iter()
 }
 
 // These are firewall queries to prevent drawing dependencies between infers:
-
 #[salsa::tracked(returns(ref), unsafe(non_update_return_type))]
 pub(crate) fn rpit_hidden_types<'db>(
     db: &'db dyn HirDatabase,
                     entry.insert(EarlyBinder::bind(hidden_type));
                 }
                 la_arena::Entry::Occupied(entry) => {
-                    _ = ocx.eq(
-                        &cause,
-                        param_env,
-                        entry.get().instantiate_identity(),
-                        hidden_type,
-                    );
+                    _ = ocx.eq(&cause, param_env, entry.get().instantiate_identity(), hidden_type);
                 }
             }
         }
     _ = ocx.try_evaluate_obligations();
 
     // Fill missing entries.
+
     for idx in 0..taits_count {
         let idx = la_arena::Idx::from_raw(la_arena::RawIdx::from_u32(idx as u32));
         match result.entry(idx) {
             }
             la_arena::Entry::Occupied(mut entry) => {
                 *entry.get_mut() = entry.get().map_bound(|hidden_type| {
-                    infcx
-                        .resolve_vars_if_possible(hidden_type)
-                        .replace_infer_with_error(interner)
+                    infcx.resolve_vars_if_possible(hidden_type).replace_infer_with_error(interner)
                 });
             }
         }
     }
 
     // FIXME: Support general TAITs, or decisively decide not to.
+
     Vec::new()
 }