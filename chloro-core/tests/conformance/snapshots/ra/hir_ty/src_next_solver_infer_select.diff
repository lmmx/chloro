COMPARISON DIFF
============================================================

Original size: 16020 bytes
Chloro size:   16048 bytes
Rustfmt size:  16174 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     db::InternedOpaqueTyId,
     next_solver::{
         infer::{
+            InferCtxt,
             select::EvaluationResult::*,
             traits::{Obligation, ObligationCause, PredicateObligation, TraitObligation},
-            InferCtxt,
         },
-        inspect::{InspectCandidate, InspectGoal, ProofTreeVisitor},
-        Const, ErrorGuaranteed, GenericArgs, Goal, TraitRef, Ty, TypeError,
+        inspect::{InspectCandidate, InspectGoal, ProofTreeVisitor}, Const, ErrorGuaranteed,
+        GenericArgs, Goal, TraitRef, Ty, TypeError,
     },
 };
 
 pub(crate) enum ImplSource<'db, N> {
     /// ImplSource identifying a particular impl.
     UserDefined(ImplSourceUserDefinedData<'db, N>),
-
     /// Successful resolution to an obligation provided by the caller
     /// for some type parameter. The `Vec<N>` represents the
     /// obligations incurred from normalizing the where-clause (if
     /// any).
     Param(Vec<N>),
-
     /// Successful resolution for a builtin impl.
     Builtin(BuiltinImplSource, Vec<N>),
 }
     }
 }
 
-struct Select {}
+struct Select {
+}
 
 impl<'db> ProofTreeVisitor<'db> for Select {
     type Result = ControlFlow<SelectionResult<'db, Selection<'db>>>;
     fn visit_goal(&mut self, goal: &InspectGoal<'_, 'db>) -> Self::Result {
         let mut candidates = goal.candidates();
         candidates.retain(|cand| cand.result().is_ok());
-
         // No candidates -- not implemented.
+
         if candidates.is_empty() {
             return ControlFlow::Break(Err(SelectionError::Unimplemented));
         }
-
         // One candidate, no need to winnow.
+
         if candidates.len() == 1 {
             return ControlFlow::Break(Ok(to_selection(candidates.into_iter().next().unwrap())));
         }
-
         // Don't winnow until `Certainty::Yes` -- we don't need to winnow until
         // codegen, and only on the good path.
+
         if matches!(goal.result().unwrap(), Certainty::Maybe { .. }) {
             return ControlFlow::Break(Ok(None));
         }
-
         // We need to winnow. See comments on `candidate_should_be_dropped_in_favor_of`.
+
         let mut i = 0;
         while i < candidates.len() {
             let should_drop_i = (0..candidates.len())
         return false;
     }
 
-    let ProbeKind::TraitCandidate {
-        source: victim_source,
-        result: _,
-    } = victim.kind()
-    else {
+    let ProbeKind::TraitCandidate { source: victim_source, result: _ } = victim.kind() else {
         return false;
     };
-    let ProbeKind::TraitCandidate {
-        source: other_source,
-        result: _,
-    } = other.kind()
-    else {
+    let ProbeKind::TraitCandidate { source: other_source, result: _ } = other.kind() else {
         return false;
     };
 
         ) => true,
 
         // Prefer specializing candidates over specialized candidates.
-        (CandidateSource::Impl(victim_def_id), CandidateSource::Impl(other_def_id)) => victim
-            .goal()
-            .infcx()
-            .interner
-            .impl_specializes(other_def_id, victim_def_id),
+        (CandidateSource::Impl(victim_def_id), CandidateSource::Impl(other_def_id)) => {
+            victim.goal().infcx().interner.impl_specializes(other_def_id, victim_def_id)
+        }
 
         _ => false,
     }
         | ProbeKind::Root { result: _ }
         | ProbeKind::ShadowedEnvProbing
         | ProbeKind::RigidAlias { result: _ } => {
-            panic!(
-                "didn't expect to assemble trait candidate from {:#?}",
-                cand.kind()
-            )
+            panic!("didn't expect to assemble trait candidate from {:#?}", cand.kind())
         }
     })
 }