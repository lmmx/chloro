COMPARISON DIFF
============================================================

Original size: 16020 bytes
Chloro size:   15532 bytes
Rustfmt size:  16174 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     db::InternedOpaqueTyId,
     next_solver::{
         infer::{
+            InferCtxt,
             select::EvaluationResult::*,
             traits::{Obligation, ObligationCause, PredicateObligation, TraitObligation},
-            InferCtxt,
         },
-        inspect::{InspectCandidate, InspectGoal, ProofTreeVisitor},
-        Const, ErrorGuaranteed, GenericArgs, Goal, TraitRef, Ty, TypeError,
+        inspect::{InspectCandidate, InspectGoal, ProofTreeVisitor}, Const, ErrorGuaranteed,
+        GenericArgs, Goal, TraitRef, Ty, TypeError,
     },
 };
 
             | EvaluatedToOkModuloRegions
             | EvaluatedToAmbig
             | EvaluatedToAmbigStackDependent => true,
-
             EvaluatedToErr => false,
         }
     }
     pub(crate) fn is_stack_dependent(self) -> bool {
         match self {
             EvaluatedToAmbigStackDependent => true,
-
             EvaluatedToOkModuloOpaqueTypes
             | EvaluatedToOk
             | EvaluatedToOkModuloRegions
     }
 }
 
-struct Select {}
+struct Select {
+}
 
 impl<'db> ProofTreeVisitor<'db> for Select {
     type Result = ControlFlow<SelectionResult<'db, Selection<'db>>>;
         }
 
         // Don't winnow until `Certainty::Yes` -- we don't need to winnow until
+
         // codegen, and only on the good path.
         if matches!(goal.result().unwrap(), Certainty::Maybe { .. }) {
             return ControlFlow::Break(Ok(None));
         return false;
     }
 
-    let ProbeKind::TraitCandidate {
-        source: victim_source,
-        result: _,
-    } = victim.kind()
-    else {
+    let ProbeKind::TraitCandidate { source: victim_source, result: _ } = victim.kind() else {
         return false;
     };
-    let ProbeKind::TraitCandidate {
-        source: other_source,
-        result: _,
-    } = other.kind()
-    else {
+    let ProbeKind::TraitCandidate { source: other_source, result: _ } = other.kind() else {
         return false;
     };
 
         (_, CandidateSource::CoherenceUnknowable) | (CandidateSource::CoherenceUnknowable, _) => {
             panic!("should not have assembled a CoherenceUnknowable candidate")
         }
-
-        // In the old trait solver, we arbitrarily choose lower vtable candidates
-        // over higher ones.
         (
             CandidateSource::BuiltinImpl(BuiltinImplSource::Object(a)),
             CandidateSource::BuiltinImpl(BuiltinImplSource::Object(b)),
             CandidateSource::BuiltinImpl(BuiltinImplSource::TraitUpcasting(a)),
             CandidateSource::BuiltinImpl(BuiltinImplSource::TraitUpcasting(b)),
         ) => a >= b,
-        // Prefer dyn candidates over non-dyn candidates. This is necessary to
-        // handle the unsoundness between `impl<T: ?Sized> Any for T` and `dyn Any: Any`.
         (
             CandidateSource::Impl(_)
             | CandidateSource::ParamEnv(_)
             | CandidateSource::AliasBound(_),
             CandidateSource::BuiltinImpl(BuiltinImplSource::Object { .. }),
         ) => true,
-
-        // Prefer specializing candidates over specialized candidates.
-        (CandidateSource::Impl(victim_def_id), CandidateSource::Impl(other_def_id)) => victim
-            .goal()
-            .infcx()
-            .interner
-            .impl_specializes(other_def_id, victim_def_id),
-
+        (CandidateSource::Impl(victim_def_id), CandidateSource::Impl(other_def_id)) => {
+            victim.goal().infcx().interner.impl_specializes(other_def_id, victim_def_id)
+        }
         _ => false,
     }
 }
     Some(match cand.kind() {
         ProbeKind::TraitCandidate { source, result: _ } => match source {
             CandidateSource::Impl(impl_def_id) => {
-                // FIXME: Remove this in favor of storing this in the tree
-                // For impl candidates, we do the rematch manually to compute the args.
                 ImplSource::UserDefined(ImplSourceUserDefinedData {
                     impl_def_id: impl_def_id.0,
                     args: cand.instantiate_impl_args(),
         | ProbeKind::Root { result: _ }
         | ProbeKind::ShadowedEnvProbing
         | ProbeKind::RigidAlias { result: _ } => {
-            panic!(
-                "didn't expect to assemble trait candidate from {:#?}",
-                cand.kind()
-            )
+            panic!("didn't expect to assemble trait candidate from {:#?}", cand.kind())
         }
     })
 }