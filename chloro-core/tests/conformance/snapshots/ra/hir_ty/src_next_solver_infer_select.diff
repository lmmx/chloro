COMPARISON DIFF
============================================================

Original size: 16020 bytes
Chloro size:   16055 bytes
Rustfmt size:  16174 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir_def::{ImplId, TraitId};
 use macros::{TypeFoldable, TypeVisitable};
 use rustc_type_ir::{
-    solve::{inspect::ProbeKind, BuiltinImplSource, CandidateSource, Certainty},
     Interner,
+    solve::{BuiltinImplSource, CandidateSource, Certainty, inspect::ProbeKind},
 };
 
 use crate::{
     db::InternedOpaqueTyId,
     next_solver::{
+        Const, ErrorGuaranteed, GenericArgs, Goal, TraitRef, Ty, TypeError,
         infer::{
+            InferCtxt,
             select::EvaluationResult::*,
             traits::{Obligation, ObligationCause, PredicateObligation, TraitObligation},
-            InferCtxt,
         },
         inspect::{InspectCandidate, InspectGoal, ProofTreeVisitor},
-        Const, ErrorGuaranteed, GenericArgs, Goal, TraitRef, Ty, TypeError,
     },
 };
 
     }
 }
 
-struct Select {}
+struct Select {
+}
 
 impl<'db> ProofTreeVisitor<'db> for Select {
     type Result = ControlFlow<SelectionResult<'db, Selection<'db>>>;
         candidates.retain(|cand| cand.result().is_ok());
 
         // No candidates -- not implemented.
+
         if candidates.is_empty() {
             return ControlFlow::Break(Err(SelectionError::Unimplemented));
         }
 
         // One candidate, no need to winnow.
+
         if candidates.len() == 1 {
             return ControlFlow::Break(Ok(to_selection(candidates.into_iter().next().unwrap())));
         }
 
         // Don't winnow until `Certainty::Yes` -- we don't need to winnow until
+
         // codegen, and only on the good path.
+
         if matches!(goal.result().unwrap(), Certainty::Maybe { .. }) {
             return ControlFlow::Break(Ok(None));
         }
 
         // We need to winnow. See comments on `candidate_should_be_dropped_in_favor_of`.
+
         let mut i = 0;
         while i < candidates.len() {
             let should_drop_i = (0..candidates.len())
         return false;
     }
 
-    let ProbeKind::TraitCandidate {
-        source: victim_source,
-        result: _,
-    } = victim.kind()
-    else {
+    let ProbeKind::TraitCandidate { source: victim_source, result: _ } = victim.kind() else {
         return false;
     };
-    let ProbeKind::TraitCandidate {
-        source: other_source,
-        result: _,
-    } = other.kind()
-    else {
+    let ProbeKind::TraitCandidate { source: other_source, result: _ } = other.kind() else {
         return false;
     };
 
         ) => true,
 
         // Prefer specializing candidates over specialized candidates.
-        (CandidateSource::Impl(victim_def_id), CandidateSource::Impl(other_def_id)) => victim
-            .goal()
-            .infcx()
-            .interner
-            .impl_specializes(other_def_id, victim_def_id),
+        (CandidateSource::Impl(victim_def_id), CandidateSource::Impl(other_def_id)) => {
+            victim.goal().infcx().interner.impl_specializes(other_def_id, victim_def_id)
+        }
 
         _ => false,
     }
         | ProbeKind::Root { result: _ }
         | ProbeKind::ShadowedEnvProbing
         | ProbeKind::RigidAlias { result: _ } => {
-            panic!(
-                "didn't expect to assemble trait candidate from {:#?}",
-                cand.kind()
-            )
+            panic!("didn't expect to assemble trait candidate from {:#?}", cand.kind())
         }
     })
 }