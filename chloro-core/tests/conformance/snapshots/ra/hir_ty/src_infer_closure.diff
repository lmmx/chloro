COMPARISON DIFF
============================================================

Original size: 36953 bytes
Chloro size:   36567 bytes
Rustfmt size:  36953 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::{iter, mem, ops::ControlFlow};
 
 use hir_def::{
-    TraitId,
     hir::{ClosureKind, ExprId, PatId},
     lang_item::LangItem,
     type_ref::TypeRefId,
+    TraitId,
 };
 use rustc_type_ir::{
+    inherent::{BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
     ClosureArgs, ClosureArgsParts, CoroutineArgs, CoroutineArgsParts, CoroutineClosureArgs,
     CoroutineClosureArgsParts, Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,
     TypeVisitor,
-    inherent::{BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
 };
 use tracing::debug;
 
 use crate::{
-    FnAbi,
     db::{InternedClosure, InternedCoroutine},
-    infer::{BreakableKind, Diverges, coerce::CoerceMany},
+    infer::{coerce::CoerceMany, BreakableKind, Diverges},
     next_solver::{
-        AliasTy, Binder, BoundRegionKind, BoundVarKind, BoundVarKinds, ClauseKind, DbInterner,
-        ErrorGuaranteed, FnSig, GenericArgs, PolyFnSig, PolyProjectionPredicate, Predicate,
-        PredicateKind, SolverDefId, Ty, TyKind,
         abi::Safety,
         infer::{
             BoundRegionConversionTime, InferOk, InferResult,
             traits::{ObligationCause, PredicateObligations},
         },
-        util::explicit_item_bounds,
+        util::explicit_item_bounds, AliasTy, Binder, BoundRegionKind, BoundVarKind, BoundVarKinds,
+        ClauseKind, DbInterner, ErrorGuaranteed, FnSig, GenericArgs, PolyFnSig,
+        PolyProjectionPredicate, Predicate, PredicateKind, SolverDefId, Ty, TyKind,
     },
     traits::FnTrait,
+    FnAbi,
 };
-
 use super::{Expectation, InferenceContext};
 
 #[derive(Debug)]
         closure_kind: ClosureKind,
     ) -> (Option<PolyFnSig<'db>>, Option<rustc_type_ir::ClosureKind>) {
         match expected_ty.kind() {
-            TyKind::Alias(rustc_type_ir::Opaque, AliasTy { def_id, args, .. }) => self
-                .deduce_closure_signature_from_predicates(
-                    expected_ty,
-                    closure_kind,
-                    explicit_item_bounds(self.interner(), def_id)
-                        .iter_instantiated(self.interner(), args)
-                        .map(|clause| clause.as_predicate()),
-                ),
+            TyKind::Alias(rustc_type_ir::Opaque, AliasTy { def_id, args, .. }) => self.deduce_closure_signature_from_predicates(
+                expected_ty,
+                closure_kind,
+                explicit_item_bounds(self.interner(), def_id).iter_instantiated(self.interner(), args).map(
+                |clause| clause.as_predicate(),
+            ),
+            ),
             TyKind::Dynamic(object_type, ..) => {
                 let sig = object_type.projection_bounds().into_iter().find_map(|pb| {
                     let pb = pb.with_self_ty(self.interner(), Ty::new_unit(self.interner()));
                     .principal_def_id()
                     .and_then(|did| self.fn_trait_kind_from_def_id(did.0));
                 (sig, kind)
-            }
-            TyKind::Infer(rustc_type_ir::TyVar(vid)) => self
-                .deduce_closure_signature_from_predicates(
-                    Ty::new_var(self.interner(), self.table.infer_ctxt.root_var(vid)),
-                    closure_kind,
-                    self.table.obligations_for_self_ty(vid).into_iter().map(|obl| obl.predicate),
-                ),
+            },
+            TyKind::Infer(rustc_type_ir::TyVar(vid)) => self.deduce_closure_signature_from_predicates(
+                Ty::new_var(self.interner(), self.table.infer_ctxt.root_var(vid)),
+                closure_kind,
+                self.table.obligations_for_self_ty(vid).into_iter().map(|obl| obl.predicate),
+            ),
             TyKind::FnPtr(sig_tys, hdr) => match closure_kind {
                 ClosureKind::Closure => {
                     let expected_sig = sig_tys.with(hdr);
                     (Some(expected_sig), Some(rustc_type_ir::ClosureKind::Fn))
-                }
+                },
                 ClosureKind::Coroutine(_) | ClosureKind::Async => (None, None),
             },
             _ => (None, None),
         let lang_item = self.db.lang_attr(def_id.into());
 
         // For now, we only do signature deduction based off of the `Fn` and `AsyncFn` traits,
+
         // for closures and async closures, respectively.
         match closure_kind {
             ClosureKind::Closure if lang_item == Some(LangItem::FnOnceOutput) => {
                 self.extract_sig_from_projection(projection)
-            }
+            },
             ClosureKind::Async if lang_item == Some(LangItem::AsyncFnOnceOutput) => {
                 self.extract_sig_from_projection(projection)
-            }
-            // It's possible we've passed the closure to a (somewhat out-of-fashion)
-            // `F: FnOnce() -> Fut, Fut: Future<Output = T>` style bound. Let's still
-            // guide inference here, since it's beneficial for the user.
+            },
             ClosureKind::Async if lang_item == Some(LangItem::FnOnceOutput) => {
                 self.extract_sig_from_projection_and_future_bound(projection)
-            }
+            },
             _ => None,
         }
     }
         };
 
         // If the return type is a type variable, look for bounds on it.
+
         // We could theoretically support other kinds of return types here,
+
         // but none of them would be useful, since async closures return
+
         // concrete anonymous future types, and their futures are not coerced
+
         // into any other type within the body of the async closure.
         let TyKind::Infer(rustc_type_ir::TyVar(return_vid)) =
             projection.skip_binder().term.expect_type().kind()
         }
 
         // SUBTLE: If we didn't find a `Future<Output = ...>` bound for the return
+
         // vid, we still want to attempt to provide inference guidance for the async
+
         // closure's arguments. Instantiate a new vid to plug into the output type.
+
         //
+
         // You may be wondering, what if it's higher-ranked? Well, given that we
+
         // found a type variable for the `FnOnce::Output` projection above, we know
+
         // that the output can't mention any of the vars.
+
         //
+
         // Also note that we use a fresh var here for the signature since the signature
+
         // records the output of the *future*, and `return_vid` above is the type
+
         // variable of the future, not its output.
+
         //
+
         // FIXME: We probably should store this signature inference output in a way
+
         // that does not misuse a `FnSig` type, but that can be done separately.
         let return_ty = return_ty.unwrap_or_else(|| self.table.next_ty_var());
 
         }
 
         // Create a `PolyFnSig`. Note the oddity that late bound
+
         // regions appearing free in `expected_sig` are now bound up
+
         // in this binder we are creating.
         assert!(!expected_sig.skip_binder().has_vars_bound_above(rustc_type_ir::INNERMOST));
         let bound_sig = expected_sig.map_bound(|sig| {
         });
 
         // `deduce_expectations_from_expected_type` introduces
+
         // late-bound lifetimes defined elsewhere, which we now
+
         // anonymize away, so as not to confuse the user.
         let bound_sig = self.interner().anonymize_bound_vars(bound_sig);
 
         let closure_sigs = self.closure_sigs(bound_sig);
 
         // Up till this point, we have ignored the annotations that the user
+
         // gave. This function will check that they unify successfully.
+
         // Along the way, it also writes out entries for types that the user
+
         // wrote into our typeck results, which are then later used by the privacy
+
         // check.
         match self.merge_supplied_sig_with_expectation(decl_inputs, decl_output, closure_sigs) {
             Ok(infer_ok) => self.table.register_infer_ok(infer_ok),
         debug!(?supplied_sig);
 
         // FIXME(#45727): As discussed in [this comment][c1], naively
+
         // forcing equality here actually results in suboptimal error
+
         // messages in some cases. For now, if there would have been
+
         // an obvious error, we fallback to declaring the type of the
+
         // closure to be the one the user gave, which allows other
+
         // error message code to trigger.
+
         //
+
         // However, I think [there is potential to do even better
+
         // here][c2], since in *this* code we have the precise span of
+
         // the type parameter in question in hand when we report the
+
         // error.
+
         //
+
         // [c1]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341089706
+
         // [c2]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341096796
         self.table.commit_if_ok(|table| {
             let mut all_obligations = PredicateObligations::new();
                 BoundRegionConversionTime::FnCall,
                 supplied_sig,
             );
-
-            // The liberated version of this signature should be a subtype
-            // of the liberated form of the expectation.
             for (supplied_ty, expected_ty) in
                 iter::zip(supplied_sig.inputs(), expected_sigs.liberated_sig.inputs())
             {
                     .eq(expected_ty, supplied_ty)?;
                 all_obligations.extend(obligations);
             }
-
             let supplied_output_ty = supplied_sig.output();
             let cause = ObligationCause::new();
             let InferOk { value: (), obligations } = table
                 .at(&cause, table.trait_env.env)
                 .eq(expected_sigs.liberated_sig.output(), supplied_output_ty)?;
             all_obligations.extend(obligations);
-
             let inputs = supplied_sig
                 .inputs()
                 .into_iter()
                 .map(|ty| table.infer_ctxt.resolve_vars_if_possible(ty));
-
             expected_sigs.liberated_sig = table.interner().mk_fn_sig(
                 inputs,
                 supplied_output_ty,
                 Safety::Safe,
                 FnAbi::RustCall,
             );
-
-            Ok(InferOk { value: expected_sigs, obligations: all_obligations })
+            Ok(InferOk {
+                value: expected_sigs,
+                obligations: all_obligations,
+            })
         })
     }
 