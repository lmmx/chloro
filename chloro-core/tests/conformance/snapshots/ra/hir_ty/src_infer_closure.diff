COMPARISON DIFF
============================================================

Original size: 36953 bytes
Chloro size:   37075 bytes
Rustfmt size:  36953 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::{iter, mem, ops::ControlFlow};
 
 use hir_def::{
-    TraitId,
     hir::{ClosureKind, ExprId, PatId},
     lang_item::LangItem,
     type_ref::TypeRefId,
+    TraitId,
 };
 use rustc_type_ir::{
+    inherent::{BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
     ClosureArgs, ClosureArgsParts, CoroutineArgs, CoroutineArgsParts, CoroutineClosureArgs,
     CoroutineClosureArgsParts, Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,
     TypeVisitor,
-    inherent::{BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
 };
 use tracing::debug;
 
 use crate::{
-    FnAbi,
     db::{InternedClosure, InternedCoroutine},
-    infer::{BreakableKind, Diverges, coerce::CoerceMany},
+    infer::{coerce::CoerceMany, BreakableKind, Diverges},
     next_solver::{
-        AliasTy, Binder, BoundRegionKind, BoundVarKind, BoundVarKinds, ClauseKind, DbInterner,
-        ErrorGuaranteed, FnSig, GenericArgs, PolyFnSig, PolyProjectionPredicate, Predicate,
-        PredicateKind, SolverDefId, Ty, TyKind,
         abi::Safety,
         infer::{
             BoundRegionConversionTime, InferOk, InferResult,
             traits::{ObligationCause, PredicateObligations},
         },
-        util::explicit_item_bounds,
+        util::explicit_item_bounds, AliasTy, Binder, BoundRegionKind, BoundVarKind, BoundVarKinds,
+        ClauseKind, DbInterner, ErrorGuaranteed, FnSig, GenericArgs, PolyFnSig,
+        PolyProjectionPredicate, Predicate, PredicateKind, SolverDefId, Ty, TyKind,
     },
     traits::FnTrait,
+    FnAbi,
 };
-
 use super::{Expectation, InferenceContext};
 
 #[derive(Debug)]
             None => (None, None),
         };
 
-        let ClosureSignatures { bound_sig, liberated_sig } =
-            self.sig_of_closure(arg_types, ret_type, expected_sig);
+        let ClosureSignatures { bound_sig, liberated_sig } = self.sig_of_closure(arg_types, ret_type, expected_sig);
         let body_ret_ty = bound_sig.output().skip_binder();
         let sig_ty = Ty::new_fn_ptr(interner, bound_sig);
 
         let prev_ret_coercion = self.return_coercion.replace(CoerceMany::new(body_ret_ty));
         let prev_resume_yield_tys = mem::replace(&mut self.resume_yield_tys, resume_yield_tys);
 
-        self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {
+        self
+            .with_breakable_ctx(BreakableKind::Border, None, None, |this| {
             this.infer_return(body);
         });
 
         let lang_item = self.db.lang_attr(def_id.into());
 
         // For now, we only do signature deduction based off of the `Fn` and `AsyncFn` traits,
+
         // for closures and async closures, respectively.
         match closure_kind {
             ClosureKind::Closure if lang_item == Some(LangItem::FnOnceOutput) => {
         let ret_param_ty = projection.skip_binder().term.expect_type();
         debug!(?ret_param_ty);
 
-        let sig = projection.rebind(self.interner().mk_fn_sig(
+        let sig = projection
+            .rebind(self.interner().mk_fn_sig(
             input_tys,
             ret_param_ty,
             false,
         };
 
         // If the return type is a type variable, look for bounds on it.
+
         // We could theoretically support other kinds of return types here,
+
         // but none of them would be useful, since async closures return
+
         // concrete anonymous future types, and their futures are not coerced
+
         // into any other type within the body of the async closure.
         let TyKind::Infer(rustc_type_ir::TyVar(return_vid)) =
             projection.skip_binder().term.expect_type().kind()
         }
 
         // SUBTLE: If we didn't find a `Future<Output = ...>` bound for the return
+
         // vid, we still want to attempt to provide inference guidance for the async
+
         // closure's arguments. Instantiate a new vid to plug into the output type.
+
         //
+
         // You may be wondering, what if it's higher-ranked? Well, given that we
+
         // found a type variable for the `FnOnce::Output` projection above, we know
+
         // that the output can't mention any of the vars.
+
         //
+
         // Also note that we use a fresh var here for the signature since the signature
+
         // records the output of the *future*, and `return_vid` above is the type
+
         // variable of the future, not its output.
+
         //
+
         // FIXME: We probably should store this signature inference output in a way
+
         // that does not misuse a `FnSig` type, but that can be done separately.
         let return_ty = return_ty.unwrap_or_else(|| self.table.next_ty_var());
 
-        let sig = projection.rebind(self.interner().mk_fn_sig(
+        let sig = projection
+            .rebind(self.interner().mk_fn_sig(
             input_tys,
             return_ty,
             false,
         }
 
         // Create a `PolyFnSig`. Note the oddity that late bound
+
         // regions appearing free in `expected_sig` are now bound up
+
         // in this binder we are creating.
         assert!(!expected_sig.skip_binder().has_vars_bound_above(rustc_type_ir::INNERMOST));
-        let bound_sig = expected_sig.map_bound(|sig| {
+        let bound_sig = expected_sig
+            .map_bound(|sig| {
             self.interner().mk_fn_sig(
                 sig.inputs(),
                 sig.output(),
         });
 
         // `deduce_expectations_from_expected_type` introduces
+
         // late-bound lifetimes defined elsewhere, which we now
+
         // anonymize away, so as not to confuse the user.
         let bound_sig = self.interner().anonymize_bound_vars(bound_sig);
 
         let closure_sigs = self.closure_sigs(bound_sig);
 
         // Up till this point, we have ignored the annotations that the user
+
         // gave. This function will check that they unify successfully.
+
         // Along the way, it also writes out entries for types that the user
+
         // wrote into our typeck results, which are then later used by the privacy
+
         // check.
         match self.merge_supplied_sig_with_expectation(decl_inputs, decl_output, closure_sigs) {
             Ok(infer_ok) => self.table.register_infer_ok(infer_ok),
         debug!(?supplied_sig);
 
         // FIXME(#45727): As discussed in [this comment][c1], naively
+
         // forcing equality here actually results in suboptimal error
+
         // messages in some cases. For now, if there would have been
+
         // an obvious error, we fallback to declaring the type of the
+
         // closure to be the one the user gave, which allows other
+
         // error message code to trigger.
+
         //
+
         // However, I think [there is potential to do even better
+
         // here][c2], since in *this* code we have the precise span of
+
         // the type parameter in question in hand when we report the
+
         // error.
+
         //
+
         // [c1]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341089706
+
         // [c2]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341096796
         self.table.commit_if_ok(|table| {
             let mut all_obligations = PredicateObligations::new();
             None => self.table.next_ty_var(),
         };
         // First, convert the types that the user supplied (if any).
-        let supplied_arguments = decl_inputs.iter().map(|&input| match input {
+        let supplied_arguments = decl_inputs
+            .iter()
+            .map(|&input| match input {
             Some(input) => {
                 let input = self.make_body_ty(input);
                 self.process_user_written_ty(input)
         if let Some(output) = decl_output {
             self.make_body_ty(output);
         }
-        let supplied_arguments = decl_inputs.iter().map(|&input| match input {
+        let supplied_arguments = decl_inputs
+            .iter()
+            .map(|&input| match input {
             Some(input) => {
                 self.make_body_ty(input);
                 err_ty