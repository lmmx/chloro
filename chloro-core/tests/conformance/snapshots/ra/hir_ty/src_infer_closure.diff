COMPARISON DIFF
============================================================

Original size: 36953 bytes
Chloro size:   36932 bytes
Rustfmt size:  36953 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::{iter, mem, ops::ControlFlow};
 
 use hir_def::{
-    TraitId,
-    hir::{ClosureKind, ExprId, PatId},
+    hir::{ClosureKind,
+
     lang_item::LangItem,
+
     type_ref::TypeRefId,
+
+    ExprId, PatId}, TraitId,
 };
 use rustc_type_ir::{
+    inherent::{BoundExistentialPredicates,
+
     ClosureArgs, ClosureArgsParts, CoroutineArgs, CoroutineArgsParts, CoroutineClosureArgs,
-    CoroutineClosureArgsParts, Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,
-    TypeVisitor,
-    inherent::{BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
+    CoroutineClosureArgsParts, GenericArgs as _, Interner, IntoKind, SliceLike, Ty as _},
+    TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,
 };
 use tracing::debug;
 
 use crate::{
-    FnAbi,
-    db::{InternedClosure, InternedCoroutine},
-    infer::{BreakableKind, Diverges, coerce::CoerceMany},
-    next_solver::{
-        AliasTy, Binder, BoundRegionKind, BoundVarKind, BoundVarKinds, ClauseKind, DbInterner,
-        ErrorGuaranteed, FnSig, GenericArgs, PolyFnSig, PolyProjectionPredicate, Predicate,
-        PredicateKind, SolverDefId, Ty, TyKind,
-        abi::Safety,
-        infer::{
-            BoundRegionConversionTime, InferOk, InferResult,
-            traits::{ObligationCause, PredicateObligations},
-        },
-        util::explicit_item_bounds,
-    },
-    traits::FnTrait,
-};
+    abi::Safety,
 
+    coerce::CoerceMany},
+
+    db::{InternedClosure,
+
+    infer::{
+            BoundRegionConversionTime, infer::{BreakableKind,
+
+    next_solver::{
+        AliasTy,
+
+    traits::FnTrait, traits::{ObligationCause,
+
+    util::explicit_item_bounds,
+
+    Binder, BoundRegionKind, BoundVarKind, BoundVarKinds, ClauseKind, DbInterner, Diverges,
+    ErrorGuaranteed, FnAbi, FnSig, GenericArgs, InferOk, InferResult, InternedCoroutine}, PolyFnSig,
+    PolyProjectionPredicate, Predicate, PredicateKind, PredicateObligations}, SolverDefId, Ty,
+    TyKind, }, },
+};
 use super::{Expectation, InferenceContext};
 
 #[derive(Debug)]
         expected: &Expectation<'db>,
     ) -> Ty<'db> {
         assert_eq!(args.len(), arg_types.len());
-
         let interner = self.interner();
         let (expected_sig, expected_kind) = match expected.to_option(&mut self.table) {
             Some(expected_ty) => self.deduce_closure_signature(expected_ty, closure_kind),
             None => (None, None),
         };
-
         let ClosureSignatures { bound_sig, liberated_sig } =
             self.sig_of_closure(arg_types, ret_type, expected_sig);
         let body_ret_ty = bound_sig.output().skip_binder();
         let sig_ty = Ty::new_fn_ptr(interner, bound_sig);
-
         let parent_args = GenericArgs::identity_for_item(interner, self.generic_def.into());
         // FIXME: Make this an infer var and infer it later.
         let tupled_upvars_ty = self.types.unit;
                 (None, Ty::new_coroutine_closure(interner, coroutine_id, closure_args.args), None)
             }
         };
-
         // Now go through the argument patterns
         for (arg_pat, arg_ty) in args.iter().zip(bound_sig.skip_binder().inputs()) {
             self.infer_top_pat(*arg_pat, arg_ty, None);
         }
-
         // FIXME: lift these out into a struct
         let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);
         let prev_closure = mem::replace(&mut self.current_closure, id);
         let prev_ret_ty = mem::replace(&mut self.return_ty, body_ret_ty);
         let prev_ret_coercion = self.return_coercion.replace(CoerceMany::new(body_ret_ty));
         let prev_resume_yield_tys = mem::replace(&mut self.resume_yield_tys, resume_yield_tys);
-
         self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {
             this.infer_return(body);
         });
-
         self.diverges = prev_diverges;
         self.return_ty = prev_ret_ty;
         self.return_coercion = prev_ret_coercion;
         self.current_closure = prev_closure;
         self.resume_yield_tys = prev_resume_yield_tys;
-
         ty
     }
 
-    fn fn_trait_kind_from_def_id(&self, trait_id: TraitId) -> Option<rustc_type_ir::ClosureKind> {
+    fn fn_trait_kind_from_def_id(
+        &self,
+        trait_id: TraitId,
+    ) -> Option<rustc_type_ir::ClosureKind> {
         let lang_item = self.db.lang_attr(trait_id.into())?;
         match lang_item {
             LangItem::Fn => Some(rustc_type_ir::ClosureKind::Fn),
     ) -> (Option<PolyFnSig<'db>>, Option<rustc_type_ir::ClosureKind>) {
         let mut expected_sig = None;
         let mut expected_kind = None;
-
         for pred in rustc_type_ir::elaborate::elaborate(
             self.interner(),
             // Reverse the obligations here, since `elaborate_*` uses a stack,
                 }
             }
         }
-
         (expected_sig, expected_kind)
     }
 
     ) -> Option<PolyFnSig<'db>> {
         let SolverDefId::TypeAliasId(def_id) = projection.item_def_id() else { unreachable!() };
         let lang_item = self.db.lang_attr(def_id.into());
-
         // For now, we only do signature deduction based off of the `Fn` and `AsyncFn` traits,
         // for closures and async closures, respectively.
         match closure_kind {
         projection: PolyProjectionPredicate<'db>,
     ) -> Option<PolyFnSig<'db>> {
         let projection = self.table.infer_ctxt.resolve_vars_if_possible(projection);
-
         let arg_param_ty = projection.skip_binder().projection_term.args.type_at(1);
         debug!(?arg_param_ty);
-
         let TyKind::Tuple(input_tys) = arg_param_ty.kind() else {
             return None;
         };
-
         // Since this is a return parameter type it is safe to unwrap.
         let ret_param_ty = projection.skip_binder().term.expect_type();
         debug!(?ret_param_ty);
-
         let sig = projection.rebind(self.interner().mk_fn_sig(
             input_tys,
             ret_param_ty,
             Safety::Safe,
             FnAbi::Rust,
         ));
-
         Some(sig)
     }
 
         projection: PolyProjectionPredicate<'db>,
     ) -> Option<PolyFnSig<'db>> {
         let projection = self.table.infer_ctxt.resolve_vars_if_possible(projection);
-
         let arg_param_ty = projection.skip_binder().projection_term.args.type_at(1);
         debug!(?arg_param_ty);
-
         let TyKind::Tuple(input_tys) = arg_param_ty.kind() else {
             return None;
         };
-
         // If the return type is a type variable, look for bounds on it.
         // We could theoretically support other kinds of return types here,
         // but none of them would be useful, since async closures return
         else {
             return None;
         };
-
         // FIXME: We may want to elaborate here, though I assume this will be exceedingly rare.
         let mut return_ty = None;
         for bound in self.table.obligations_for_self_ty(return_vid) {
                 break;
             }
         }
-
         // SUBTLE: If we didn't find a `Future<Output = ...>` bound for the return
         // vid, we still want to attempt to provide inference guidance for the async
         // closure's arguments. Instantiate a new vid to plug into the output type.
         // FIXME: We probably should store this signature inference output in a way
         // that does not misuse a `FnSig` type, but that can be done separately.
         let return_ty = return_ty.unwrap_or_else(|| self.table.next_ty_var());
-
         let sig = projection.rebind(self.interner().mk_fn_sig(
             input_tys,
             return_ty,
             Safety::Safe,
             FnAbi::Rust,
         ));
-
         Some(sig)
     }
 
         decl_output: Option<TypeRefId>,
     ) -> ClosureSignatures<'db> {
         let bound_sig = self.supplied_sig_of_closure(decl_inputs, decl_output);
-
         self.closure_sigs(bound_sig)
     }
 
             return self
                 .sig_of_closure_with_mismatched_number_of_arguments(decl_inputs, decl_output);
         }
-
         // Create a `PolyFnSig`. Note the oddity that late bound
         // regions appearing free in `expected_sig` are now bound up
         // in this binder we are creating.
                 FnAbi::RustCall,
             )
         });
-
         // `deduce_expectations_from_expected_type` introduces
         // late-bound lifetimes defined elsewhere, which we now
         // anonymize away, so as not to confuse the user.
         let bound_sig = self.interner().anonymize_bound_vars(bound_sig);
-
         let closure_sigs = self.closure_sigs(bound_sig);
-
         // Up till this point, we have ignored the annotations that the user
         // gave. This function will check that they unify successfully.
         // Along the way, it also writes out entries for types that the user
         decl_output: Option<TypeRefId>,
     ) -> ClosureSignatures<'db> {
         let error_sig = self.error_sig_of_closure(decl_inputs, decl_output);
-
         self.closure_sigs(error_sig)
     }
 
         // (See comment on `sig_of_closure_with_expectation` for the
         // meaning of these letters.)
         let supplied_sig = self.supplied_sig_of_closure(decl_inputs, decl_output);
-
         debug!(?supplied_sig);
-
         // FIXME(#45727): As discussed in [this comment][c1], naively
         // forcing equality here actually results in suboptimal error
         // messages in some cases. For now, if there would have been
         decl_output: Option<TypeRefId>,
     ) -> PolyFnSig<'db> {
         let interner = self.interner();
-
         let supplied_return = match decl_output {
             Some(output) => {
                 let output = self.make_body_ty(output);
             }
             None => self.table.next_ty_var(),
         });
-
         Binder::dummy(interner.mk_fn_sig(
             supplied_arguments,
             supplied_return,
     ) -> PolyFnSig<'db> {
         let interner = self.interner();
         let err_ty = Ty::new_error(interner, ErrorGuaranteed);
-
         if let Some(output) = decl_output {
             self.make_body_ty(output);
         }
             }
             None => err_ty,
         });
-
         let result = Binder::dummy(interner.mk_fn_sig(
             supplied_arguments,
             err_ty,
             Safety::Safe,
             FnAbi::RustCall,
         ));
-
         debug!("supplied_sig_of_closure: result={:?}", result);
-
         result
     }
 
-    fn closure_sigs(&self, bound_sig: PolyFnSig<'db>) -> ClosureSignatures<'db> {
+    fn closure_sigs(
+        &self,
+        bound_sig: PolyFnSig<'db>,
+    ) -> ClosureSignatures<'db> {
         let liberated_sig = bound_sig.skip_binder();
         // FIXME: When we lower HRTB we'll need to actually liberate regions here.
         ClosureSignatures { bound_sig, liberated_sig }