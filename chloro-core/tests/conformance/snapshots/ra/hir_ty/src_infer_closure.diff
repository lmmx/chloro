COMPARISON DIFF
============================================================

Original size: 36953 bytes
Chloro size:   36944 bytes
Rustfmt size:  36953 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::{iter, mem, ops::ControlFlow};
 
 use hir_def::{
-    TraitId,
     hir::{ClosureKind, ExprId, PatId},
     lang_item::LangItem,
     type_ref::TypeRefId,
+    TraitId,
 };
 use rustc_type_ir::{
+    inherent::{BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
     ClosureArgs, ClosureArgsParts, CoroutineArgs, CoroutineArgsParts, CoroutineClosureArgs,
     CoroutineClosureArgsParts, Interner, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,
     TypeVisitor,
-    inherent::{BoundExistentialPredicates, GenericArgs as _, IntoKind, SliceLike, Ty as _},
 };
 use tracing::debug;
 
 use crate::{
-    FnAbi,
     db::{InternedClosure, InternedCoroutine},
-    infer::{BreakableKind, Diverges, coerce::CoerceMany},
+    infer::{coerce::CoerceMany, BreakableKind, Diverges},
     next_solver::{
-        AliasTy, Binder, BoundRegionKind, BoundVarKind, BoundVarKinds, ClauseKind, DbInterner,
-        ErrorGuaranteed, FnSig, GenericArgs, PolyFnSig, PolyProjectionPredicate, Predicate,
-        PredicateKind, SolverDefId, Ty, TyKind,
         abi::Safety,
         infer::{
             BoundRegionConversionTime, InferOk, InferResult,
             traits::{ObligationCause, PredicateObligations},
         },
-        util::explicit_item_bounds,
+        util::explicit_item_bounds, AliasTy, Binder, BoundRegionKind, BoundVarKind, BoundVarKinds,
+        ClauseKind, DbInterner, ErrorGuaranteed, FnSig, GenericArgs, PolyFnSig,
+        PolyProjectionPredicate, Predicate, PredicateKind, SolverDefId, Ty, TyKind,
     },
     traits::FnTrait,
+    FnAbi,
 };
-
 use super::{Expectation, InferenceContext};
 
 #[derive(Debug)]
                 (None, Ty::new_coroutine_closure(interner, coroutine_id, closure_args.args), None)
             }
         };
-
         // Now go through the argument patterns
+
         for (arg_pat, arg_ty) in args.iter().zip(bound_sig.skip_binder().inputs()) {
             self.infer_top_pat(*arg_pat, arg_ty, None);
         }
-
         // FIXME: lift these out into a struct
+
         let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);
         let prev_closure = mem::replace(&mut self.current_closure, id);
         let prev_ret_ty = mem::replace(&mut self.return_ty, body_ret_ty);
     ) -> Option<PolyFnSig<'db>> {
         let SolverDefId::TypeAliasId(def_id) = projection.item_def_id() else { unreachable!() };
         let lang_item = self.db.lang_attr(def_id.into());
-
         // For now, we only do signature deduction based off of the `Fn` and `AsyncFn` traits,
         // for closures and async closures, respectively.
+
         match closure_kind {
             ClosureKind::Closure if lang_item == Some(LangItem::FnOnceOutput) => {
                 self.extract_sig_from_projection(projection)
         let TyKind::Tuple(input_tys) = arg_param_ty.kind() else {
             return None;
         };
-
         // Since this is a return parameter type it is safe to unwrap.
+
         let ret_param_ty = projection.skip_binder().term.expect_type();
         debug!(?ret_param_ty);
 
         let TyKind::Tuple(input_tys) = arg_param_ty.kind() else {
             return None;
         };
-
         // If the return type is a type variable, look for bounds on it.
         // We could theoretically support other kinds of return types here,
         // but none of them would be useful, since async closures return
         // concrete anonymous future types, and their futures are not coerced
         // into any other type within the body of the async closure.
+
         let TyKind::Infer(rustc_type_ir::TyVar(return_vid)) =
             projection.skip_binder().term.expect_type().kind()
         else {
             return None;
         };
-
         // FIXME: We may want to elaborate here, though I assume this will be exceedingly rare.
+
         let mut return_ty = None;
         for bound in self.table.obligations_for_self_ty(return_vid) {
             if let PredicateKind::Clause(ClauseKind::Projection(ret_projection)) =
                 break;
             }
         }
-
         // SUBTLE: If we didn't find a `Future<Output = ...>` bound for the return
         // vid, we still want to attempt to provide inference guidance for the async
         // closure's arguments. Instantiate a new vid to plug into the output type.
         //
         // FIXME: We probably should store this signature inference output in a way
         // that does not misuse a `FnSig` type, but that can be done separately.
+
         let return_ty = return_ty.unwrap_or_else(|| self.table.next_ty_var());
 
         let sig = projection.rebind(self.interner().mk_fn_sig(
             return self
                 .sig_of_closure_with_mismatched_number_of_arguments(decl_inputs, decl_output);
         }
-
         // Create a `PolyFnSig`. Note the oddity that late bound
         // regions appearing free in `expected_sig` are now bound up
         // in this binder we are creating.
+
         assert!(!expected_sig.skip_binder().has_vars_bound_above(rustc_type_ir::INNERMOST));
         let bound_sig = expected_sig.map_bound(|sig| {
             self.interner().mk_fn_sig(
                 FnAbi::RustCall,
             )
         });
-
         // `deduce_expectations_from_expected_type` introduces
         // late-bound lifetimes defined elsewhere, which we now
         // anonymize away, so as not to confuse the user.
+
         let bound_sig = self.interner().anonymize_bound_vars(bound_sig);
 
         let closure_sigs = self.closure_sigs(bound_sig);
-
         // Up till this point, we have ignored the annotations that the user
         // gave. This function will check that they unify successfully.
         // Along the way, it also writes out entries for types that the user
         // wrote into our typeck results, which are then later used by the privacy
         // check.
+
         match self.merge_supplied_sig_with_expectation(decl_inputs, decl_output, closure_sigs) {
             Ok(infer_ok) => self.table.register_infer_ok(infer_ok),
             Err(_) => self.sig_of_closure_no_expectation(decl_inputs, decl_output),
         let supplied_sig = self.supplied_sig_of_closure(decl_inputs, decl_output);
 
         debug!(?supplied_sig);
-
         // FIXME(#45727): As discussed in [this comment][c1], naively
         // forcing equality here actually results in suboptimal error
         // messages in some cases. For now, if there would have been
         //
         // [c1]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341089706
         // [c2]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341096796
+
         self.table.commit_if_ok(|table| {
             let mut all_obligations = PredicateObligations::new();
             let supplied_sig = table.infer_ctxt.instantiate_binder_with_fresh_vars(