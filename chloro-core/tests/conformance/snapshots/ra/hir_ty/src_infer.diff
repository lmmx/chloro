COMPARISON DIFF
============================================================

Original size: 74236 bytes
Chloro size:   73269 bytes
Rustfmt size:  74236 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         expr::ExprIsRead,
     },
     lower::{
-        ImplTraitIdx, ImplTraitLoweringMode, LifetimeElisionKind, diagnostics::TyLoweringDiagnostic,
+        ImplTraitIdx, ImplTraitLoweringMode, LifetimeElisionKind,
+        diagnostics::TyLoweringDiagnostic,
     },
     mir::MirSpan,
     next_solver::{
     utils::TargetFeatureIsSafeInTarget,
 };
 
-// This lint has a false positive here. See the link below for details.
-//
-// https://github.com/rust-lang/rust/issues/57411
 #[allow(unreachable_pub)]
 pub use coerce::could_coerce;
 #[allow(unreachable_pub)]
     ctx.type_inference_fallback();
 
     // Comment from rustc:
+
     // Even though coercion casts provide type hints, we check casts after fallback for
+
     // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.
+
     let cast_checks = std::mem::take(&mut ctx.deferred_cast_checks);
     for mut cast in cast_checks.into_iter() {
         if let Err(diag) = cast.check(&mut ctx) {
 impl<'db> Adjustment<'db> {
     pub fn borrow(interner: DbInterner<'db>, m: Mutability, ty: Ty<'db>, lt: Region<'db>) -> Self {
         let ty = Ty::new_ref(interner, lt, ty, m);
-        Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(lt, m)), target: ty }
+        Adjustment {
+            kind: Adjust::Borrow(AutoBorrow::Ref(lt, m)),
+            target: ty,
+        }
     }
 }
 
     /// Go from a mut raw pointer to a const raw pointer.
     MutToConstPointer,
 
-    #[allow(dead_code)]
     /// Go from `*const [T; N]` to `*const T`
+    #[allow(dead_code)]
     ArrayToPointer,
 
     /// Unsize a pointer/reference value, e.g., `&[T; n]` to
     pub(crate) type_of_binding: ArenaMap<BindingId, Ty<'db>>,
     pub(crate) type_of_opaque: FxHashMap<InternedOpaqueTyId, Ty<'db>>,
     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch<'db>>,
-    /// Whether there are any type-mismatching errors in the result.
     // FIXME: This isn't as useful as initially thought due to us falling back placeholders to
     // `TyKind::Error`.
     // Which will then mark this field.
+    /// Whether there are any type-mismatching errors in the result.
     pub(crate) has_errors: bool,
-    /// Interned `Error` type to return references to.
     // FIXME: Remove this.
+    /// Interned `Error` type to return references to.
     error_ty: Ty<'db>,
     /// Stores the types which were implicitly dereferenced in pattern binding modes.
     pub(crate) pat_adjustments: FxHashMap<PatId, Vec<Ty<'db>>>,
     pub fn method_resolution(&self, expr: ExprId) -> Option<(FunctionId, GenericArgs<'db>)> {
         self.method_resolutions.get(&expr).copied()
     }
+
     pub fn field_resolution(&self, expr: ExprId) -> Option<Either<FieldId, TupleFieldId>> {
         self.field_resolutions.get(&expr).copied()
     }
+
     pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantId> {
         self.variant_resolutions.get(&id.into()).copied()
     }
+
     pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantId> {
         self.variant_resolutions.get(&id.into()).copied()
     }
+
     pub fn variant_resolution_for_expr_or_pat(&self, id: ExprOrPatId) -> Option<VariantId> {
         match id {
             ExprOrPatId::ExprId(id) => self.variant_resolution_for_expr(id),
             ExprOrPatId::PatId(id) => self.variant_resolution_for_pat(id),
         }
     }
+
     pub fn assoc_resolutions_for_expr(
         &self,
         id: ExprId,
     ) -> Option<(AssocItemId, GenericArgs<'db>)> {
         self.assoc_resolutions.get(&id.into()).copied()
     }
+
     pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<(AssocItemId, GenericArgs<'db>)> {
         self.assoc_resolutions.get(&id.into()).copied()
     }
+
     pub fn assoc_resolutions_for_expr_or_pat(
         &self,
         id: ExprOrPatId,
             ExprOrPatId::PatId(id) => self.assoc_resolutions_for_pat(id),
         }
     }
+
     pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch<'db>> {
         self.type_mismatches.get(&expr.into())
     }
+
     pub fn type_mismatch_for_pat(&self, pat: PatId) -> Option<&TypeMismatch<'db>> {
         self.type_mismatches.get(&pat.into())
     }
+
     pub fn type_mismatches(&self) -> impl Iterator<Item = (ExprOrPatId, &TypeMismatch<'db>)> {
         self.type_mismatches.iter().map(|(expr_or_pat, mismatch)| (*expr_or_pat, mismatch))
     }
+
     pub fn expr_type_mismatches(&self) -> impl Iterator<Item = (ExprId, &TypeMismatch<'db>)> {
         self.type_mismatches.iter().filter_map(|(expr_or_pat, mismatch)| match *expr_or_pat {
             ExprOrPatId::ExprId(expr) => Some((expr, mismatch)),
             _ => None,
         })
     }
+
     pub fn closure_info(&self, closure: InternedClosureId) -> &(Vec<CapturedItem<'db>>, FnTrait) {
         self.closure_info.get(&closure).unwrap()
     }
+
     pub fn type_of_expr_or_pat(&self, id: ExprOrPatId) -> Option<Ty<'db>> {
         match id {
             ExprOrPatId::ExprId(id) => self.type_of_expr.get(id).copied(),
             ExprOrPatId::PatId(id) => self.type_of_pat.get(id).copied(),
         }
     }
+
     pub fn type_of_expr_with_adjust(&self, id: ExprId) -> Option<Ty<'db>> {
         match self.expr_adjustments.get(&id).and_then(|adjustments| {
             adjustments
             None => self.type_of_expr.get(id).copied(),
         }
     }
+
     pub fn type_of_pat_with_adjust(&self, id: PatId) -> Option<Ty<'db>> {
         match self.pat_adjustments.get(&id).and_then(|adjustments| adjustments.last()) {
             Some(adjusted) => Some(*adjusted),
             None => self.type_of_pat.get(id).copied(),
         }
     }
+
     pub fn is_erroneous(&self) -> bool {
         self.has_errors && self.type_of_expr.iter().count() == 0
     }
         self.binding_modes.get(id).copied()
     }
 
-    // This method is consumed by external tools to run rust-analyzer as a library. Don't remove, please.
     pub fn expression_types(&self) -> impl Iterator<Item = (ExprId, Ty<'db>)> {
         self.type_of_expr.iter().map(|(k, v)| (k, *v))
     }
 
-    // This method is consumed by external tools to run rust-analyzer as a library. Don't remove, please.
     pub fn pattern_types(&self) -> impl Iterator<Item = (PatId, Ty<'db>)> {
         self.type_of_pat.iter().map(|(k, v)| (k, *v))
     }
 
-    // This method is consumed by external tools to run rust-analyzer as a library. Don't remove, please.
     pub fn binding_types(&self) -> impl Iterator<Item = (BindingId, Ty<'db>)> {
         self.type_of_binding.iter().map(|(k, v)| (k, *v))
     }
 
-    // This method is consumed by external tools to run rust-analyzer as a library. Don't remove, please.
     pub fn return_position_impl_trait_types(
         &self,
         db: &'db dyn HirDatabase,
     f128: Ty<'db>,
     static_str_ref: Ty<'db>,
     error: Ty<'db>,
-
     re_static: Region<'db>,
     re_error: Region<'db>,
     re_erased: Region<'db>,
-
     empty_args: GenericArgs<'db>,
     empty_tys: Tys<'db>,
 }
     /// The traits in scope, disregarding block modules. This is used for caching purposes.
     traits_in_scope: FxHashSet<TraitId>,
     pub(crate) result: InferenceResult<'db>,
-    tuple_field_accesses_rev:
-        IndexSet<Tys<'db>, std::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
+    tuple_field_accesses_rev: IndexSet<Tys<'db>, std::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
     /// The return type of the function being inferred, the closure or async block if we're
     /// currently within one.
     ///
     diverges: Diverges,
     breakables: Vec<BreakableContext<'db>>,
     types: InternedStandardTypes<'db>,
-
     /// Whether we are inside the pattern of a destructuring assignment.
     inside_assignment: bool,
-
     deferred_cast_checks: Vec<CastCheck<'db>>,
-
     // fields related to closure capture
     current_captures: Vec<CapturedItemWithoutTy<'db>>,
     /// A stack that has an entry for each projection in the current capture.
     /// comment on `InferenceContext::sort_closures`
     closure_dependencies: FxHashMap<InternedClosureId, Vec<InternedClosureId>>,
     deferred_closures: FxHashMap<InternedClosureId, Vec<(Ty<'db>, Ty<'db>, Vec<Ty<'db>>, ExprId)>>,
-
     diagnostics: Diagnostics<'db>,
 }
 
     }
 
     /// Clones `self` and calls `resolve_all()` on it.
-    // FIXME: Remove this.
     pub(crate) fn fixme_resolve_all_clone(&self) -> InferenceResult<'db> {
         let mut ctx = self.clone();
 
         ctx.type_inference_fallback();
 
         // Comment from rustc:
+
         // Even though coercion casts provide type hints, we check casts after fallback for
+
         // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.
+
         let cast_checks = std::mem::take(&mut ctx.deferred_cast_checks);
         for mut cast in cast_checks.into_iter() {
             if let Err(diag) = cast.check(&mut ctx) {
         ctx.resolve_all()
     }
 
-    // FIXME: This function should be private in module. It is currently only used in the consteval, since we need
-    // `InferenceResult` in the middle of inference. See the fixme comment in `consteval::eval_to_const`. If you
-    // used this function for another workaround, mention it here. If you really need this function and believe that
-    // there is no problem in it being `pub(crate)`, remove this comment.
     fn resolve_all(self) -> InferenceResult<'db> {
         let InferenceContext {
             mut table, mut result, tuple_field_accesses_rev, diagnostics, ..
         );
 
         // Check if function contains a va_list, if it does then we append it to the parameter types
+
         // that are collected from the function data
+
         if data.is_varargs() {
             let va_list_ty = match self.resolve_va_list() {
                 Some(va_list) => Ty::new_adt(
         self.result.pat_adjustments.entry(pat).or_default().extend(adjustments);
     }
 
-    fn write_method_resolution(&mut self, expr: ExprId, func: FunctionId, subst: GenericArgs<'db>) {
+    fn write_method_resolution(
+        &mut self,
+        expr: ExprId,
+        func: FunctionId,
+        subst: GenericArgs<'db>,
+    ) {
         self.result.method_resolutions.insert(expr, (func, subst));
     }
 
         &mut self,
         inner_ty: Ty<'db>,
         assoc_ty: Option<TypeAliasId>,
-        // FIXME(GATs): these are args for the trait ref, args for assoc type itself should be
-        // handled when we support them.
         params: &[GenericArg<'db>],
     ) -> Ty<'db> {
         match assoc_ty {
                 (ty, variant)
             }
             Some(1) => {
-                let segment = path.segments().last().unwrap();
                 // this could be an enum variant or associated type
+                // FIXME potentially resolve assoc type
+                let segment = path.segments().last().unwrap();
                 if let Some((AdtId::EnumId(enum_id), _)) = ty.as_adt() {
                     let enum_data = enum_id.enum_variants(self.db);
                     if let Some(variant) = enum_data.variant(segment) {
                         return (ty, Some(variant.into()));
                     }
                 }
-                // FIXME potentially resolve assoc type
                 (self.err_ty(), None)
             }
             Some(_) => {
         match *self {
             Expectation::HasType(ety) => {
                 let ety = table.structurally_resolve_type(ety);
-                if ety.is_ty_var() { Expectation::None } else { Expectation::HasType(ety) }
+                if ety.is_ty_var() {
+                    Expectation::None
+                } else {
+                    Expectation::HasType(ety)
+                }
             }
             Expectation::RValueLikeUnsized(ety) => Expectation::RValueLikeUnsized(ety),
             _ => Expectation::None,
 
 impl std::ops::BitAnd for Diverges {
     type Output = Self;
+
     fn bitand(self, other: Self) -> Self {
         std::cmp::min(self, other)
     }
 
 impl std::ops::BitOr for Diverges {
     type Output = Self;
+
     fn bitor(self, other: Self) -> Self {
         std::cmp::max(self, other)
     }