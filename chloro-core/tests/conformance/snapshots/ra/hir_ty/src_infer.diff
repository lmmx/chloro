COMPARISON DIFF
============================================================

Original size: 74236 bytes
Chloro size:   74102 bytes
Rustfmt size:  74236 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! to certain types. To record this, we use the union-find implementation from
 //! the `ena` crate, which is extracted from rustc.
 
-mod autoderef;
-pub(crate) mod cast;
-pub(crate) mod closure;
-mod coerce;
-pub(crate) mod diagnostics;
-mod expr;
-mod fallback;
-mod mutability;
-mod opaques;
-mod pat;
-mod path;
-pub(crate) mod unify;
-
 use std::{cell::OnceCell, convert::identity, iter, ops::Index};
 
 use base_db::Crate;
+use cast::{CastCheck, CastError};
+pub(crate) use closure::analysis::{CaptureKind, CapturedItem, CapturedItemWithoutTy};
+pub use coerce::could_coerce;
 use either::Either;
 use hir_def::{
     AdtId, AssocItemId, ConstId, DefWithBodyId, FieldId, FunctionId, GenericDefId, GenericParamId,
 };
 use stdx::never;
 use triomphe::Arc;
+pub use unify::{could_unify, could_unify_deeply};
 
 use crate::{
     ImplTraitId, IncorrectGenericsLenKind, PathLoweringDiagnostic, TargetFeatures,
     utils::TargetFeatureIsSafeInTarget,
 };
 
-// This lint has a false positive here. See the link below for details.
-//
-// https://github.com/rust-lang/rust/issues/57411
-#[allow(unreachable_pub)]
-pub use coerce::could_coerce;
-#[allow(unreachable_pub)]
-pub use unify::{could_unify, could_unify_deeply};
+mod autoderef;
 
-use cast::{CastCheck, CastError};
-pub(crate) use closure::analysis::{CaptureKind, CapturedItem, CapturedItemWithoutTy};
+pub(crate) mod cast;
+
+pub(crate) mod closure;
+
+mod coerce;
+
+pub(crate) mod diagnostics;
+
+mod expr;
+
+mod fallback;
+
+mod mutability;
+
+mod opaques;
+
+mod pat;
+
+mod path;
+
+pub(crate) mod unify;
 
 /// The entry point of type inference.
-pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult<'_>> {
+pub(crate) fn infer_query(
+    db: &dyn HirDatabase,
+    def: DefWithBodyId,
+) -> Arc<InferenceResult<'_>> {
     let _p = tracing::info_span!("infer_query").entered();
     let resolver = def.resolver(db);
     let body = db.body(def);
     let mut ctx = InferenceContext::new(db, def, &body, resolver);
-
     match def {
         DefWithBodyId::FunctionId(f) => {
             ctx.collect_fn(f);
             };
         }
     }
-
     ctx.infer_body();
-
     ctx.infer_mut_body();
-
     ctx.handle_opaque_type_uses();
-
     ctx.type_inference_fallback();
-
     // Comment from rustc:
     // Even though coercion casts provide type hints, we check casts after fallback for
     // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.
             ctx.diagnostics.push(diag);
         }
     }
-
     ctx.table.select_obligations_where_possible();
-
     ctx.infer_closures();
-
     ctx.table.select_obligations_where_possible();
-
     ctx.handle_opaque_type_uses();
-
     Arc::new(ctx.resolve_all())
 }
 
     UnresolvedIdent {
         id: ExprOrPatId,
     },
-    // FIXME: This should be emitted in body lowering
     BreakOutsideOfLoop {
         expr: ExprId,
         is_break: bool,
 }
 
 impl<'db> Adjustment<'db> {
-    pub fn borrow(interner: DbInterner<'db>, m: Mutability, ty: Ty<'db>, lt: Region<'db>) -> Self {
+    pub fn borrow(
+        interner: DbInterner<'db>,
+        m: Mutability,
+        ty: Ty<'db>,
+        lt: Region<'db>,
+    ) -> Self {
         let ty = Ty::new_ref(interner, lt, ty, m);
         Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(lt, m)), target: ty }
     }
 /// See #49434 for tracking.
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
 pub(crate) enum AllowTwoPhase {
-    // FIXME: We should use this when appropriate.
     Yes,
     No,
 }
 pub enum PointerCast {
     /// Go from a fn-item type to a fn-pointer type.
     ReifyFnPointer,
-
     /// Go from a safe fn pointer to an unsafe fn pointer.
     UnsafeFnPointer,
-
     /// Go from a non-capturing closure to an fn pointer or an unsafe fn pointer.
     /// It cannot convert a closure that requires unsafe.
     ClosureFnPointer(Safety),
-
     /// Go from a mut raw pointer to a const raw pointer.
     MutToConstPointer,
-
-    #[allow(dead_code)]
     /// Go from `*const [T; N]` to `*const T`
+    #[allow(dead_code)]
     ArrayToPointer,
-
     /// Unsize a pointer/reference value, e.g., `&[T; n]` to
     /// `&[T]`. Note that the source could be a thin or fat pointer.
     /// This will do things like convert thin pointers to fat
     pub(crate) type_of_opaque: FxHashMap<InternedOpaqueTyId, Ty<'db>>,
     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch<'db>>,
     /// Whether there are any type-mismatching errors in the result.
-    // FIXME: This isn't as useful as initially thought due to us falling back placeholders to
-    // `TyKind::Error`.
-    // Which will then mark this field.
     pub(crate) has_errors: bool,
     /// Interned `Error` type to return references to.
-    // FIXME: Remove this.
     error_ty: Ty<'db>,
     /// Stores the types which were implicitly dereferenced in pattern binding modes.
     pub(crate) pat_adjustments: FxHashMap<PatId, Vec<Ty<'db>>>,
     pub(crate) binding_modes: ArenaMap<PatId, BindingMode>,
     pub(crate) expr_adjustments: FxHashMap<ExprId, Box<[Adjustment<'db>]>>,
     pub(crate) closure_info: FxHashMap<InternedClosureId, (Vec<CapturedItem<'db>>, FnTrait)>,
-    // FIXME: remove this field
     pub mutated_bindings_in_closure: FxHashSet<BindingId>,
     pub(crate) coercion_casts: FxHashSet<ExprId>,
 }
         }
     }
 
-    pub fn method_resolution(&self, expr: ExprId) -> Option<(FunctionId, GenericArgs<'db>)> {
+    pub fn method_resolution(
+        &self,
+        expr: ExprId,
+    ) -> Option<(FunctionId, GenericArgs<'db>)> {
         self.method_resolutions.get(&expr).copied()
     }
-    pub fn field_resolution(&self, expr: ExprId) -> Option<Either<FieldId, TupleFieldId>> {
+
+    pub fn field_resolution(
+        &self,
+        expr: ExprId,
+    ) -> Option<Either<FieldId, TupleFieldId>> {
         self.field_resolutions.get(&expr).copied()
     }
-    pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantId> {
+
+    pub fn variant_resolution_for_expr(
+        &self,
+        id: ExprId,
+    ) -> Option<VariantId> {
         self.variant_resolutions.get(&id.into()).copied()
     }
-    pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantId> {
+
+    pub fn variant_resolution_for_pat(
+        &self,
+        id: PatId,
+    ) -> Option<VariantId> {
         self.variant_resolutions.get(&id.into()).copied()
     }
-    pub fn variant_resolution_for_expr_or_pat(&self, id: ExprOrPatId) -> Option<VariantId> {
+
+    pub fn variant_resolution_for_expr_or_pat(
+        &self,
+        id: ExprOrPatId,
+    ) -> Option<VariantId> {
         match id {
             ExprOrPatId::ExprId(id) => self.variant_resolution_for_expr(id),
             ExprOrPatId::PatId(id) => self.variant_resolution_for_pat(id),
         }
     }
+
     pub fn assoc_resolutions_for_expr(
         &self,
         id: ExprId,
     ) -> Option<(AssocItemId, GenericArgs<'db>)> {
         self.assoc_resolutions.get(&id.into()).copied()
     }
-    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<(AssocItemId, GenericArgs<'db>)> {
+
+    pub fn assoc_resolutions_for_pat(
+        &self,
+        id: PatId,
+    ) -> Option<(AssocItemId, GenericArgs<'db>)> {
         self.assoc_resolutions.get(&id.into()).copied()
     }
+
     pub fn assoc_resolutions_for_expr_or_pat(
         &self,
         id: ExprOrPatId,
             ExprOrPatId::PatId(id) => self.assoc_resolutions_for_pat(id),
         }
     }
-    pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch<'db>> {
+
+    pub fn type_mismatch_for_expr(
+        &self,
+        expr: ExprId,
+    ) -> Option<&TypeMismatch<'db>> {
         self.type_mismatches.get(&expr.into())
     }
-    pub fn type_mismatch_for_pat(&self, pat: PatId) -> Option<&TypeMismatch<'db>> {
+
+    pub fn type_mismatch_for_pat(
+        &self,
+        pat: PatId,
+    ) -> Option<&TypeMismatch<'db>> {
         self.type_mismatches.get(&pat.into())
     }
+
     pub fn type_mismatches(&self) -> impl Iterator<Item = (ExprOrPatId, &TypeMismatch<'db>)> {
         self.type_mismatches.iter().map(|(expr_or_pat, mismatch)| (*expr_or_pat, mismatch))
     }
+
     pub fn expr_type_mismatches(&self) -> impl Iterator<Item = (ExprId, &TypeMismatch<'db>)> {
         self.type_mismatches.iter().filter_map(|(expr_or_pat, mismatch)| match *expr_or_pat {
             ExprOrPatId::ExprId(expr) => Some((expr, mismatch)),
             _ => None,
         })
     }
-    pub fn closure_info(&self, closure: InternedClosureId) -> &(Vec<CapturedItem<'db>>, FnTrait) {
+
+    pub fn closure_info(
+        &self,
+        closure: InternedClosureId,
+    ) -> &(Vec<CapturedItem<'db>>, FnTrait) {
         self.closure_info.get(&closure).unwrap()
     }
-    pub fn type_of_expr_or_pat(&self, id: ExprOrPatId) -> Option<Ty<'db>> {
+
+    pub fn type_of_expr_or_pat(
+        &self,
+        id: ExprOrPatId,
+    ) -> Option<Ty<'db>> {
         match id {
             ExprOrPatId::ExprId(id) => self.type_of_expr.get(id).copied(),
             ExprOrPatId::PatId(id) => self.type_of_pat.get(id).copied(),
         }
     }
-    pub fn type_of_expr_with_adjust(&self, id: ExprId) -> Option<Ty<'db>> {
+
+    pub fn type_of_expr_with_adjust(
+        &self,
+        id: ExprId,
+    ) -> Option<Ty<'db>> {
         match self.expr_adjustments.get(&id).and_then(|adjustments| {
             adjustments
                 .iter()
             None => self.type_of_expr.get(id).copied(),
         }
     }
-    pub fn type_of_pat_with_adjust(&self, id: PatId) -> Option<Ty<'db>> {
+
+    pub fn type_of_pat_with_adjust(
+        &self,
+        id: PatId,
+    ) -> Option<Ty<'db>> {
         match self.pat_adjustments.get(&id).and_then(|adjustments| adjustments.last()) {
             Some(adjusted) => Some(*adjusted),
             None => self.type_of_pat.get(id).copied(),
         }
     }
+
     pub fn is_erroneous(&self) -> bool {
         self.has_errors && self.type_of_expr.iter().count() == 0
     }
         &self.diagnostics
     }
 
-    pub fn tuple_field_access_type(&self, id: TupleId) -> Tys<'db> {
+    pub fn tuple_field_access_type(
+        &self,
+        id: TupleId,
+    ) -> Tys<'db> {
         self.tuple_field_access_types[&id]
     }
 
-    pub fn pat_adjustment(&self, id: PatId) -> Option<&[Ty<'db>]> {
+    pub fn pat_adjustment(
+        &self,
+        id: PatId,
+    ) -> Option<&[Ty<'db>]> {
         self.pat_adjustments.get(&id).map(|it| &**it)
     }
 
-    pub fn expr_adjustment(&self, id: ExprId) -> Option<&[Adjustment<'db>]> {
+    pub fn expr_adjustment(
+        &self,
+        id: ExprId,
+    ) -> Option<&[Adjustment<'db>]> {
         self.expr_adjustments.get(&id).map(|it| &**it)
     }
 
-    pub fn binding_mode(&self, id: PatId) -> Option<BindingMode> {
+    pub fn binding_mode(
+        &self,
+        id: PatId,
+    ) -> Option<BindingMode> {
         self.binding_modes.get(id).copied()
     }
 
-    // This method is consumed by external tools to run rust-analyzer as a library. Don't remove, please.
     pub fn expression_types(&self) -> impl Iterator<Item = (ExprId, Ty<'db>)> {
         self.type_of_expr.iter().map(|(k, v)| (k, *v))
     }
 
-    // This method is consumed by external tools to run rust-analyzer as a library. Don't remove, please.
     pub fn pattern_types(&self) -> impl Iterator<Item = (PatId, Ty<'db>)> {
         self.type_of_pat.iter().map(|(k, v)| (k, *v))
     }
 
-    // This method is consumed by external tools to run rust-analyzer as a library. Don't remove, please.
     pub fn binding_types(&self) -> impl Iterator<Item = (BindingId, Ty<'db>)> {
         self.type_of_binding.iter().map(|(k, v)| (k, *v))
     }
 
-    // This method is consumed by external tools to run rust-analyzer as a library. Don't remove, please.
     pub fn return_position_impl_trait_types(
         &self,
         db: &'db dyn HirDatabase,
 impl<'db> Index<ExprId> for InferenceResult<'db> {
     type Output = Ty<'db>;
 
-    fn index(&self, expr: ExprId) -> &Ty<'db> {
+    fn index(
+        &self,
+        expr: ExprId,
+    ) -> &Ty<'db> {
         self.type_of_expr.get(expr).unwrap_or(&self.error_ty)
     }
 }
 impl<'db> Index<PatId> for InferenceResult<'db> {
     type Output = Ty<'db>;
 
-    fn index(&self, pat: PatId) -> &Ty<'db> {
+    fn index(
+        &self,
+        pat: PatId,
+    ) -> &Ty<'db> {
         self.type_of_pat.get(pat).unwrap_or(&self.error_ty)
     }
 }
 impl<'db> Index<ExprOrPatId> for InferenceResult<'db> {
     type Output = Ty<'db>;
 
-    fn index(&self, id: ExprOrPatId) -> &Ty<'db> {
+    fn index(
+        &self,
+        id: ExprOrPatId,
+    ) -> &Ty<'db> {
         match id {
             ExprOrPatId::ExprId(id) => &self[id],
             ExprOrPatId::PatId(id) => &self[id],
 impl<'db> Index<BindingId> for InferenceResult<'db> {
     type Output = Ty<'db>;
 
-    fn index(&self, b: BindingId) -> &Ty<'db> {
+    fn index(
+        &self,
+        b: BindingId,
+    ) -> &Ty<'db> {
         self.type_of_binding.get(b).unwrap_or(&self.error_ty)
     }
 }
     f128: Ty<'db>,
     static_str_ref: Ty<'db>,
     error: Ty<'db>,
-
     re_static: Region<'db>,
     re_error: Region<'db>,
     re_erased: Region<'db>,
-
     empty_args: GenericArgs<'db>,
     empty_tys: Tys<'db>,
 }
     /// The traits in scope, disregarding block modules. This is used for caching purposes.
     traits_in_scope: FxHashSet<TraitId>,
     pub(crate) result: InferenceResult<'db>,
-    tuple_field_accesses_rev:
-        IndexSet<Tys<'db>, std::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
+    tuple_field_accesses_rev: IndexSet<Tys<'db>, std::hash::BuildHasherDefault<rustc_hash::FxHasher>>,
     /// The return type of the function being inferred, the closure or async block if we're
     /// currently within one.
     ///
     diverges: Diverges,
     breakables: Vec<BreakableContext<'db>>,
     types: InternedStandardTypes<'db>,
-
     /// Whether we are inside the pattern of a destructuring assignment.
     inside_assignment: bool,
-
     deferred_cast_checks: Vec<CastCheck<'db>>,
-
-    // fields related to closure capture
     current_captures: Vec<CapturedItemWithoutTy<'db>>,
     /// A stack that has an entry for each projection in the current capture.
     ///
     /// comment on `InferenceContext::sort_closures`
     closure_dependencies: FxHashMap<InternedClosureId, Vec<InternedClosureId>>,
     deferred_closures: FxHashMap<InternedClosureId, Vec<(Ty<'db>, Ty<'db>, Vec<Ty<'db>>, ExprId)>>,
-
     diagnostics: Diagnostics<'db>,
 }
 
     }
 
     /// Clones `self` and calls `resolve_all()` on it.
-    // FIXME: Remove this.
     pub(crate) fn fixme_resolve_all_clone(&self) -> InferenceResult<'db> {
         let mut ctx = self.clone();
-
         ctx.type_inference_fallback();
-
         // Comment from rustc:
         // Even though coercion casts provide type hints, we check casts after fallback for
         // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.
                 ctx.diagnostics.push(diag);
             }
         }
-
         ctx.table.select_obligations_where_possible();
-
         ctx.resolve_all()
     }
 
-    // FIXME: This function should be private in module. It is currently only used in the consteval, since we need
-    // `InferenceResult` in the middle of inference. See the fixme comment in `consteval::eval_to_const`. If you
-    // used this function for another workaround, mention it here. If you really need this function and believe that
-    // there is no problem in it being `pub(crate)`, remove this comment.
     fn resolve_all(self) -> InferenceResult<'db> {
         let InferenceContext {
             mut table, mut result, tuple_field_accesses_rev, diagnostics, ..
             coercion_casts: _,
             diagnostics: _,
         } = &mut result;
-
         for ty in type_of_expr.values_mut() {
             *ty = table.resolve_completely(*ty);
             *has_errors = *has_errors || ty.references_non_lt_error();
         }
         type_of_binding.shrink_to_fit();
         type_of_opaque.shrink_to_fit();
-
         *has_errors |= !type_mismatches.is_empty();
-
         for mismatch in (*type_mismatches).values_mut() {
             mismatch.expected = table.resolve_completely(mismatch.expected);
             mismatch.actual = table.resolve_completely(mismatch.actual);
             })
             .collect();
         result.tuple_field_access_types.shrink_to_fit();
-
         result.diagnostics = diagnostics;
-
         result
     }
 
-    fn collect_const(&mut self, id: ConstId, data: &ConstSignature) {
+    fn collect_const(
+        &mut self,
+        id: ConstId,
+        data: &ConstSignature,
+    ) {
         let return_ty = self.make_ty(
             data.type_ref,
             &data.store,
             InferenceTyDiagnosticSource::Signature,
             LifetimeElisionKind::for_const(self.interner(), id.loc(self.db).container),
         );
-
         self.return_ty = return_ty;
     }
 
-    fn collect_static(&mut self, data: &StaticSignature) {
+    fn collect_static(
+        &mut self,
+        data: &StaticSignature,
+    ) {
         let return_ty = self.make_ty(
             data.type_ref,
             &data.store,
             InferenceTyDiagnosticSource::Signature,
             LifetimeElisionKind::Elided(self.types.re_static),
         );
-
         self.return_ty = return_ty;
     }
 
-    fn collect_fn(&mut self, func: FunctionId) {
+    fn collect_fn(
+        &mut self,
+        func: FunctionId,
+    ) {
         let data = self.db.function_signature(func);
         let mut param_tys = self.with_ty_lowering(
             &data.store,
             LifetimeElisionKind::for_fn_params(&data),
             |ctx| data.params.iter().map(|&type_ref| ctx.lower_ty(type_ref)).collect::<Vec<_>>(),
         );
-
         // Check if function contains a va_list, if it does then we append it to the parameter types
         // that are collected from the function data
         if data.is_varargs() {
             }
             None => self.types.unit,
         };
-
         self.return_coercion = Some(CoerceMany::new(self.return_ty));
     }
 
         }
     }
 
-    fn write_expr_ty(&mut self, expr: ExprId, ty: Ty<'db>) {
+    fn write_expr_ty(
+        &mut self,
+        expr: ExprId,
+        ty: Ty<'db>,
+    ) {
         self.result.type_of_expr.insert(expr, ty);
     }
 
-    fn write_expr_adj(&mut self, expr: ExprId, adjustments: Box<[Adjustment<'db>]>) {
+    fn write_expr_adj(
+        &mut self,
+        expr: ExprId,
+        adjustments: Box<[Adjustment<'db>]>,
+    ) {
         if adjustments.is_empty() {
             return;
         }
         }
     }
 
-    fn write_pat_adj(&mut self, pat: PatId, adjustments: Box<[Ty<'db>]>) {
+    fn write_pat_adj(
+        &mut self,
+        pat: PatId,
+        adjustments: Box<[Ty<'db>]>,
+    ) {
         if adjustments.is_empty() {
             return;
         }
         self.result.pat_adjustments.entry(pat).or_default().extend(adjustments);
     }
 
-    fn write_method_resolution(&mut self, expr: ExprId, func: FunctionId, subst: GenericArgs<'db>) {
+    fn write_method_resolution(
+        &mut self,
+        expr: ExprId,
+        func: FunctionId,
+        subst: GenericArgs<'db>,
+    ) {
         self.result.method_resolutions.insert(expr, (func, subst));
     }
 
-    fn write_variant_resolution(&mut self, id: ExprOrPatId, variant: VariantId) {
+    fn write_variant_resolution(
+        &mut self,
+        id: ExprOrPatId,
+        variant: VariantId,
+    ) {
         self.result.variant_resolutions.insert(id, variant);
     }
 
         self.result.assoc_resolutions.insert(id, (item, subs));
     }
 
-    fn write_pat_ty(&mut self, pat: PatId, ty: Ty<'db>) {
+    fn write_pat_ty(
+        &mut self,
+        pat: PatId,
+        ty: Ty<'db>,
+    ) {
         self.result.type_of_pat.insert(pat, ty);
     }
 
-    fn write_binding_ty(&mut self, id: BindingId, ty: Ty<'db>) {
+    fn write_binding_ty(
+        &mut self,
+        id: BindingId,
+        ty: Ty<'db>,
+    ) {
         self.result.type_of_binding.insert(id, ty);
     }
 
-    fn push_diagnostic(&self, diagnostic: InferenceDiagnostic<'db>) {
+    fn push_diagnostic(
+        &self,
+        diagnostic: InferenceDiagnostic<'db>,
+    ) {
         self.diagnostics.push(diagnostic);
     }
 
         self.process_user_written_ty(ty)
     }
 
-    fn make_body_ty(&mut self, type_ref: TypeRefId) -> Ty<'db> {
+    fn make_body_ty(
+        &mut self,
+        type_ref: TypeRefId,
+    ) -> Ty<'db> {
         self.make_ty(
             type_ref,
             self.body,
         )
     }
 
-    fn make_body_const(&mut self, const_ref: ConstRef, ty: Ty<'db>) -> Const<'db> {
+    fn make_body_const(
+        &mut self,
+        const_ref: ConstRef,
+        ty: Ty<'db>,
+    ) -> Const<'db> {
         let const_ = self.with_ty_lowering(
             self.body,
             InferenceTyDiagnosticSource::Body,
         self.insert_type_vars(const_)
     }
 
-    fn make_path_as_body_const(&mut self, path: &Path, ty: Ty<'db>) -> Const<'db> {
+    fn make_path_as_body_const(
+        &mut self,
+        path: &Path,
+        ty: Ty<'db>,
+    ) -> Const<'db> {
         let const_ = self.with_ty_lowering(
             self.body,
             InferenceTyDiagnosticSource::Body,
         self.types.error
     }
 
-    fn make_body_lifetime(&mut self, lifetime_ref: LifetimeRefId) -> Region<'db> {
+    fn make_body_lifetime(
+        &mut self,
+        lifetime_ref: LifetimeRefId,
+    ) -> Region<'db> {
         let lt = self.with_ty_lowering(
             self.body,
             InferenceTyDiagnosticSource::Body,
     }
 
     /// Replaces `Ty::Error` by a new type var, so we can maybe still infer it.
-    fn insert_type_vars_shallow(&mut self, ty: Ty<'db>) -> Ty<'db> {
+    fn insert_type_vars_shallow(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         self.table.insert_type_vars_shallow(ty)
     }
 
-    fn insert_type_vars<T>(&mut self, ty: T) -> T
+    fn insert_type_vars<T>(
+        &mut self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         self.table.insert_type_vars(ty)
     }
 
-    fn unify(&mut self, ty1: Ty<'db>, ty2: Ty<'db>) -> bool {
+    fn unify(
+        &mut self,
+        ty1: Ty<'db>,
+        ty2: Ty<'db>,
+    ) -> bool {
         self.table.unify(ty1, ty2)
     }
 
     /// Attempts to returns the deeply last field of nested structures, but
     /// does not apply any normalization in its search. Returns the same type
     /// if input `ty` is not a structure at all.
-    fn struct_tail_without_normalization(&mut self, ty: Ty<'db>) -> Ty<'db> {
+    fn struct_tail_without_normalization(
+        &mut self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         self.struct_tail_with_normalize(ty, identity)
     }
 
     }
 
     /// Whenever you lower a user-written type, you should call this.
-    fn process_user_written_ty<T>(&mut self, ty: T) -> T
+    fn process_user_written_ty<T>(
+        &mut self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         self.table.process_user_written_ty(ty)
     }
 
     /// The difference of this method from `process_user_written_ty()` is that this method doesn't register a well-formed obligation,
     /// while `process_user_written_ty()` should (but doesn't currently).
-    fn process_remote_user_written_ty<T>(&mut self, ty: T) -> T
+    fn process_remote_user_written_ty<T>(
+        &mut self,
+        ty: T,
+    ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         self.table.process_remote_user_written_ty(ty)
     }
 
-    fn shallow_resolve(&self, ty: Ty<'db>) -> Ty<'db> {
+    fn shallow_resolve(
+        &self,
+        ty: Ty<'db>,
+    ) -> Ty<'db> {
         self.table.shallow_resolve(ty)
     }
 
         self.resolve_associated_type_with_params(inner_ty, assoc_ty, &[])
     }
 
-    fn demand_eqtype(&mut self, expected: Ty<'db>, actual: Ty<'db>) {
+    fn demand_eqtype(
+        &mut self,
+        expected: Ty<'db>,
+        actual: Ty<'db>,
+    ) {
         let result = self
             .table
             .infer_ctxt
         &mut self,
         inner_ty: Ty<'db>,
         assoc_ty: Option<TypeAliasId>,
-        // FIXME(GATs): these are args for the trait ref, args for assoc type itself should be
-        // handled when we support them.
         params: &[GenericArg<'db>],
     ) -> Ty<'db> {
         match assoc_ty {
                 (self.err_ty(), None)
             }
         };
-
         fn forbid_unresolved_segments<'db>(
             ctx: &InferenceContext<'_, 'db>,
             result: (Ty<'db>, Option<VariantId>),
         }
     }
 
-    fn resolve_lang_item(&self, item: LangItem) -> Option<LangItemTarget> {
+    fn resolve_lang_item(
+        &self,
+        item: LangItem,
+    ) -> Option<LangItemTarget> {
         let krate = self.resolver.krate();
         lang_item(self.db, krate, item)
     }
 
-    fn resolve_output_on(&self, trait_: TraitId) -> Option<TypeAliasId> {
+    fn resolve_output_on(
+        &self,
+        trait_: TraitId,
+    ) -> Option<TypeAliasId> {
         trait_.trait_items(self.db).associated_type_by_name(&Name::new_symbol_root(sym::Output))
     }
 
-    fn resolve_lang_trait(&self, lang: LangItem) -> Option<TraitId> {
+    fn resolve_lang_trait(
+        &self,
+        lang: LangItem,
+    ) -> Option<TraitId> {
         self.resolve_lang_item(lang)?.as_trait()
     }
 
     /// which still is useful, because it informs integer literals and the like.
     /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169
     /// for examples of where this comes up,.
-    fn rvalue_hint(ctx: &mut InferenceContext<'_, 'db>, ty: Ty<'db>) -> Self {
+    fn rvalue_hint(
+        ctx: &mut InferenceContext<'_, 'db>,
+        ty: Ty<'db>,
+    ) -> Self {
         match ctx.struct_tail_without_normalization(ty).kind() {
             TyKind::Slice(_) | TyKind::Str | TyKind::Dynamic(..) => {
                 Expectation::RValueLikeUnsized(ty)
         Expectation::None
     }
 
-    fn resolve(&self, table: &mut unify::InferenceTable<'db>) -> Expectation<'db> {
+    fn resolve(
+        &self,
+        table: &mut unify::InferenceTable<'db>,
+    ) -> Expectation<'db> {
         match self {
             Expectation::None => Expectation::None,
             Expectation::HasType(t) => Expectation::HasType(table.shallow_resolve(*t)),
         }
     }
 
-    fn to_option(&self, table: &mut unify::InferenceTable<'db>) -> Option<Ty<'db>> {
+    fn to_option(
+        &self,
+        table: &mut unify::InferenceTable<'db>,
+    ) -> Option<Ty<'db>> {
         match self.resolve(table) {
             Expectation::None => None,
             Expectation::HasType(t)
         }
     }
 
-    fn only_has_type(&self, table: &mut unify::InferenceTable<'db>) -> Option<Ty<'db>> {
+    fn only_has_type(
+        &self,
+        table: &mut unify::InferenceTable<'db>,
+    ) -> Option<Ty<'db>> {
         match self {
             Expectation::HasType(t) => Some(table.shallow_resolve(*t)),
             Expectation::Castable(_) | Expectation::RValueLikeUnsized(_) | Expectation::None => {
         }
     }
 
-    fn coercion_target_type(&self, table: &mut unify::InferenceTable<'db>) -> Ty<'db> {
+    fn coercion_target_type(
+        &self,
+        table: &mut unify::InferenceTable<'db>,
+    ) -> Ty<'db> {
         self.only_has_type(table).unwrap_or_else(|| table.next_ty_var())
     }
 
     /// an expected type. Otherwise, we might write parts of the type
     /// when checking the 'then' block which are incompatible with the
     /// 'else' branch.
-    fn adjust_for_branches(&self, table: &mut unify::InferenceTable<'db>) -> Expectation<'db> {
+    fn adjust_for_branches(
+        &self,
+        table: &mut unify::InferenceTable<'db>,
+    ) -> Expectation<'db> {
         match *self {
             Expectation::HasType(ety) => {
                 let ety = table.structurally_resolve_type(ety);
 
 impl std::ops::BitAnd for Diverges {
     type Output = Self;
-    fn bitand(self, other: Self) -> Self {
+
+    fn bitand(
+        self,
+        other: Self,
+    ) -> Self {
         std::cmp::min(self, other)
     }
 }
 
 impl std::ops::BitOr for Diverges {
     type Output = Self;
-    fn bitor(self, other: Self) -> Self {
+
+    fn bitor(
+        self,
+        other: Self,
+    ) -> Self {
         std::cmp::max(self, other)
     }
 }
 
 impl std::ops::BitAndAssign for Diverges {
-    fn bitand_assign(&mut self, other: Self) {
+    fn bitand_assign(
+        &mut self,
+        other: Self,
+    ) {
         *self = *self & other;
     }
 }
 
 impl std::ops::BitOrAssign for Diverges {
-    fn bitor_assign(&mut self, other: Self) {
+    fn bitor_assign(
+        &mut self,
+        other: Self,
+    ) {
         *self = *self | other;
     }
 }