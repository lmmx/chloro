COMPARISON DIFF
============================================================

Original size: 5724 bytes
Chloro size:   5735 bytes
Rustfmt size:  5762 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Defining opaque types via inference.
 
-use rustc_type_ir::{fold_regions, TypeVisitableExt};
+use rustc_type_ir::{TypeVisitableExt, fold_regions};
 use tracing::{debug, instrument};
 
 use crate::{
-    infer::InferenceContext,
+    infer::InferenceContext, infer::{opaque_types::OpaqueHiddenType,
     next_solver::{
-        infer::{opaque_types::OpaqueHiddenType, traits::ObligationCause},
-        EarlyBinder, OpaqueTypeKey, SolverDefId, TypingMode,
-    },
+        EarlyBinder, traits::ObligationCause}, OpaqueTypeKey, SolverDefId,
+    TypingMode, },
 };
 
 impl<'db> InferenceContext<'_, 'db> {
         // We clone the opaques instead of stealing them here as they are still used for
         // normalization in the next generation trait solver.
         let opaque_types: Vec<_> = self.table.infer_ctxt.clone_opaque_types();
-
         self.compute_definition_site_hidden_types(opaque_types);
     }
 }
 }
 
 impl<'db> UsageKind<'db> {
-    fn merge(&mut self, other: UsageKind<'db>) {
+    fn merge(
+        &mut self,
+        other: UsageKind<'db>,
+    ) {
         match (&*self, &other) {
             (UsageKind::HasDefiningUse(_), _) | (_, UsageKind::None) => unreachable!(),
             (UsageKind::None, _) => *self = other,
             *entry = self.table.infer_ctxt.resolve_vars_if_possible(*entry);
         }
         debug!(?opaque_types);
-
         let interner = self.interner();
-        let TypingMode::Analysis {
-            defining_opaque_types_and_generators,
-        } = self.table.infer_ctxt.typing_mode()
+        let TypingMode::Analysis { defining_opaque_types_and_generators } =
+            self.table.infer_ctxt.typing_mode()
         else {
             unreachable!();
         };
-
         for def_id in defining_opaque_types_and_generators {
             let def_id = match def_id {
                 SolverDefId::InternedOpaqueTyId(it) => it,
         if hidden_type.ty.has_non_region_infer() {
             return UsageKind::UnconstrainedHiddenType(hidden_type);
         }
-
         let cause = ObligationCause::new();
         let at = self.table.infer_ctxt.at(&cause, self.table.trait_env.env);
         let hidden_type = match at.deeply_normalize(hidden_type) {
             Ok(hidden_type) => hidden_type,
-            Err(_errors) => OpaqueHiddenType {
-                ty: self.types.error,
-            },
+            Err(_errors) => OpaqueHiddenType { ty: self.types.error },
         };
         let hidden_type = fold_regions(self.interner(), hidden_type, |_, _| self.types.re_erased);
         UsageKind::HasDefiningUse(hidden_type)