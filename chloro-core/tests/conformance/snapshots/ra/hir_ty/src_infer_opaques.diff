COMPARISON DIFF
============================================================

Original size: 5724 bytes
Chloro size:   5087 bytes
Rustfmt size:  5762 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     infer::InferenceContext,
     next_solver::{
-        infer::{opaque_types::OpaqueHiddenType, traits::ObligationCause},
-        EarlyBinder, OpaqueTypeKey, SolverDefId, TypingMode,
+        infer::{opaque_types::OpaqueHiddenType, traits::ObligationCause}, EarlyBinder,
+        OpaqueTypeKey, SolverDefId, TypingMode,
     },
 };
 
         match (&*self, &other) {
             (UsageKind::HasDefiningUse(_), _) | (_, UsageKind::None) => unreachable!(),
             (UsageKind::None, _) => *self = other,
-            // When mergining non-defining uses, prefer earlier ones. This means
-            // the error happens as early as possible.
             (
                 UsageKind::NonDefiningUse(..) | UsageKind::UnconstrainedHiddenType(..),
                 UsageKind::NonDefiningUse(..),
-            ) => {}
-            // When merging unconstrained hidden types, we prefer later ones. This is
-            // used as in most cases, the defining use is the final return statement
-            // of our function, and other uses with defining arguments are likely not
-            // intended to be defining.
+            ) => {
+            }
             (
                 UsageKind::NonDefiningUse(..) | UsageKind::UnconstrainedHiddenType(..),
                 UsageKind::UnconstrainedHiddenType(..) | UsageKind::HasDefiningUse(_),
         debug!(?opaque_types);
 
         let interner = self.interner();
-        let TypingMode::Analysis {
-            defining_opaque_types_and_generators,
-        } = self.table.infer_ctxt.typing_mode()
+        let TypingMode::Analysis { defining_opaque_types_and_generators } =
+            self.table.infer_ctxt.typing_mode()
         else {
             unreachable!();
         };
                 SolverDefId::InternedOpaqueTyId(it) => it,
                 _ => continue,
             };
-
-            // We do actually need to check this the second pass (we can't just
-            // store this), because we can go from `UnconstrainedHiddenType` to
-            // `HasDefiningUse` (because of fallback)
             let mut usage_kind = UsageKind::None;
             for &(opaque_type_key, hidden_type) in &opaque_types {
                 if opaque_type_key.def_id != def_id.into() {
                     break;
                 }
             }
-
             if let UsageKind::HasDefiningUse(ty) = usage_kind {
                 for &(opaque_type_key, hidden_type) in &opaque_types {
                     if opaque_type_key.def_id != def_id.into() {
 
                 continue;
             }
-
             self.result.type_of_opaque.insert(def_id, self.types.error);
         }
     }
         let at = self.table.infer_ctxt.at(&cause, self.table.trait_env.env);
         let hidden_type = match at.deeply_normalize(hidden_type) {
             Ok(hidden_type) => hidden_type,
-            Err(_errors) => OpaqueHiddenType {
-                ty: self.types.error,
-            },
+            Err(_errors) => OpaqueHiddenType { ty: self.types.error },
         };
         let hidden_type = fold_regions(self.interner(), hidden_type, |_, _| self.types.re_erased);
         UsageKind::HasDefiningUse(hidden_type)