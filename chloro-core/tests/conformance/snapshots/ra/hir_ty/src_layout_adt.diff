COMPARISON DIFF
============================================================

Original size: 6298 bytes
Chloro size:   6299 bytes
Rustfmt size:  6451 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Compute the binary representation of structs, unions and enums
 
 use std::{cmp, ops::Bound};
 
 use hir_def::{
-    signatures::{StructFlags, VariantFields},
     AdtId, VariantId,
+    signatures::{StructFlags, VariantFields},
 };
 use intern::sym;
 use rustc_abi::{Integer, ReprOptions, TargetDataLayout};
 use triomphe::Arc;
 
 use crate::{
-    db::HirDatabase,
-    layout::{field_ty, Layout, LayoutCx, LayoutError},
-    next_solver::GenericArgs,
     TraitEnvironment,
+    db::HirDatabase,
+    layout::{Layout, LayoutCx, LayoutError, field_ty},
+    next_solver::GenericArgs,
 };
 
 pub fn layout_of_adt_query<'db>(
             (
                 r,
                 sig.repr.unwrap_or_default(),
-                sig.flags
-                    .intersects(StructFlags::IS_UNSAFE_CELL | StructFlags::IS_UNSAFE_PINNED),
+                sig.flags.intersects(StructFlags::IS_UNSAFE_CELL | StructFlags::IS_UNSAFE_PINNED),
             )
         }
         AdtId::UnionId(id) => {
         .iter()
         .map(|it| it.iter().map(|it| &**it).collect::<Vec<_>>())
         .collect::<SmallVec<[_; 1]>>();
-    let variants = variants
-        .iter()
-        .map(|it| it.iter().collect())
-        .collect::<IndexVec<_, _>>();
+    let variants = variants.iter().map(|it| it.iter().collect()).collect::<IndexVec<_, _>>();
     let result = if matches!(def, AdtId::UnionId(..)) {
         cx.calc.layout_of_union(&repr, &variants)?
     } else {
             |min, max| repr_discr(dl, &repr, min, max).unwrap_or((Integer::I8, false)),
             variants.iter_enumerated().filter_map(|(id, _)| {
                 let AdtId::EnumId(e) = def else { return None };
-                let d = db
-                    .const_eval_discriminant(e.enum_variants(db).variants[id.0].0)
-                    .ok()?;
+                let d = db.const_eval_discriminant(e.enum_variants(db).variants[id.0].0).ok()?;
                 Some((id, d))
             }),
             !matches!(def, AdtId::EnumId(..))
         }
         Bound::Unbounded
     };
-    (
-        get(sym::rustc_layout_scalar_valid_range_start),
-        get(sym::rustc_layout_scalar_valid_range_end),
-    )
+    (get(sym::rustc_layout_scalar_valid_range_start), get(sym::rustc_layout_scalar_valid_range_end))
 }
 
 /// Finds the appropriate Integer type and signedness for the given
 
     if let Some(ity) = repr.int {
         let discr = Integer::from_attr(dl, ity);
-        let fit = if ity.is_signed() {
-            signed_fit
-        } else {
-            unsigned_fit
-        };
+        let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };
         if discr < fit {
             return Err(LayoutError::UserReprTooSmall);
         }
     };
 
     // If there are no negative values, we can use the unsigned fit.
+
     Ok(if min >= 0 {
         (cmp::max(unsigned_fit, at_least), false)
     } else {