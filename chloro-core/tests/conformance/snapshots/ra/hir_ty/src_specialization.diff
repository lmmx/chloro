COMPARISON DIFF
============================================================

Original size: 6348 bytes
Chloro size:   6367 bytes
Rustfmt size:  6412 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Impl specialization related things
 
-use hir_def::{nameres::crate_def_map, ImplId};
+use hir_def::{ImplId, nameres::crate_def_map};
 use intern::sym;
 use tracing::debug;
 
 use crate::{
     db::HirDatabase,
     next_solver::{
+        DbInterner, TypingMode,
         infer::{
-            traits::{Obligation, ObligationCause},
             DbInternerInferExt,
+            traits::{Obligation, ObligationCause},
         },
         obligation_ctxt::ObligationCtxt,
-        DbInterner, TypingMode,
     },
 };
 
     let parent_impl_signature = db.impl_signature(parent_impl_def_id);
 
     // We determine whether there's a subset relationship by:
+
     //
+
     // - replacing bound vars with placeholders in impl1,
+
     // - assuming the where clauses for impl1,
+
     // - instantiating impl2 with fresh inference variables,
+
     // - unifying,
+
     // - attempting to prove the where clauses for impl2
+
     //
+
     // The last three steps are encapsulated in `fulfill_implication`.
+
     //
+
     // See RFC 1210 for more details and justification.
 
     // Currently we do not allow e.g., a negative impl to specialize a positive one
     }
 
     // create a parameter environment corresponding to an identity instantiation of the specializing impl,
+
     // i.e. the most generic instantiation of the specializing impl.
     let param_env = trait_env.env;
 
     // Create an infcx, taking the predicates of the specializing impl as assumptions:
     let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
 
-    let specializing_impl_trait_ref = db
-        .impl_trait(specializing_impl_def_id)
-        .unwrap()
-        .instantiate_identity();
+    let specializing_impl_trait_ref =
+        db.impl_trait(specializing_impl_def_id).unwrap().instantiate_identity();
     let cause = &ObligationCause::dummy();
     debug!(
         "fulfill_implication({:?}, trait_ref={:?} |- {:?} applies)",
     );
 
     // Attempt to prove that the parent impl applies, given all of the above.
-
     let mut ocx = ObligationCtxt::new(&infcx);
 
     let parent_args = infcx.fresh_args_for_item(parent_impl_def_id.into());
         .instantiate(interner, parent_args);
 
     // do the impls unify? If not, no specialization.
-    let Ok(()) = ocx.eq(
-        cause,
-        param_env,
-        specializing_impl_trait_ref,
-        parent_impl_trait_ref,
-    ) else {
+    let Ok(()) = ocx.eq(cause, param_env, specializing_impl_trait_ref, parent_impl_trait_ref)
+    else {
         return false;
     };
 
     // Now check that the source trait ref satisfies all the where clauses of the target impl.
+
     // This is not just for correctness; we also need this to constrain any params that may
+
     // only be referenced via projection predicates.
-    if let Some(predicates) = db
-        .generic_predicates(parent_impl_def_id.into())
-        .instantiate(interner, parent_args)
+    if let Some(predicates) =
+        db.generic_predicates(parent_impl_def_id.into()).instantiate(interner, parent_args)
     {
         ocx.register_obligations(
             predicates
     }
 
     // FIXME: Check impl constness (when we implement const impls).
-
     debug!(
         "fulfill_implication: an impl for {:?} specializes {:?}",
         specializing_impl_trait_ref, parent_impl_trait_ref
     let module = specializing_impl_def_id.loc(db).container;
 
     // We check that the specializing impl comes from a crate that has specialization enabled.
+
     //
+
     // We don't really care if the specialized impl (the parent) is in a crate that has
+
     // specialization enabled, since it's not being specialized.
+
     //
+
     // rustc also checks whether the specializing impls comes from a macro marked
+
     // `#[allow_internal_unstable(specialization)]`, but `#[allow_internal_unstable]`
+
     // is an internal feature, std is not using it for specialization nor is likely to
+
     // ever use it, and we don't have the span information necessary to replicate that.
     let def_map = crate_def_map(db, module.krate());
     if !def_map.is_unstable_feature_enabled(&sym::specialization)