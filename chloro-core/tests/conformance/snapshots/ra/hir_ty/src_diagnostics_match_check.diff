COMPARISON DIFF
============================================================

Original size: 15979 bytes
Chloro size:   16040 bytes
Rustfmt size:  15979 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.
 
 mod pat_util;
-
 pub(crate) mod pat_analysis;
 
 use hir_def::{
-    AdtId, EnumVariantId, LocalFieldId, Lookup, VariantId,
     expr_store::{Body, path::Path},
     hir::PatId,
     item_tree::FieldsShape,
+    AdtId,
+    EnumVariantId,
+    LocalFieldId,
+    Lookup,
+    VariantId,
 };
 use hir_expand::name::Name;
 use rustc_type_ir::inherent::{IntoKind, SliceLike};
 use stdx::{always, never, variance::PhantomCovariantLifetime};
 
 use crate::{
-    InferenceResult,
     db::HirDatabase,
     display::{HirDisplay, HirDisplayError, HirFormatter},
     infer::BindingMode,
     next_solver::{GenericArgs, Mutability, Ty, TyKind},
+    InferenceResult,
 };
-
 use self::pat_util::EnumerateAndAdjustIterator;
 
 #[derive(Clone, Debug)]
 pub(crate) enum PatKind<'db> {
     Wild,
     Never,
-
     /// `x`, `ref x`, `x @ P`, etc.
     Binding {
         name: Name,
         subpattern: Option<Pat<'db>>,
     },
-
     /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with
     /// multiple variants.
     Variant {
         enum_variant: EnumVariantId,
         subpatterns: Vec<FieldPat<'db>>,
     },
-
     /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with
     /// a single variant.
     Leaf {
         subpatterns: Vec<FieldPat<'db>>,
     },
-
     /// `&P`, `&mut P`, etc.
     Deref {
         subpattern: Pat<'db>,
     },
-
-    // FIXME: for now, only bool literals are implemented
     LiteralBool {
         value: bool,
     },
-
     /// An or-pattern, e.g. `p | q`.
     /// Invariant: `pats.len() >= 2`.
     Or {
         Self { db, infer, body, errors: Vec::new() }
     }
 
-    pub(crate) fn lower_pattern(&mut self, pat: PatId) -> Pat<'db> {
+    pub(crate) fn lower_pattern(
+        &mut self,
+        pat: PatId,
+    ) -> Pat<'db> {
         // XXX(iDawer): Collecting pattern adjustments feels imprecise to me.
         // When lowering of & and box patterns are implemented this should be tested
         // in a manner of `match_ergonomics_issue_9095` test.
         )
     }
 
-    fn lower_pattern_unadjusted(&mut self, pat: PatId) -> Pat<'db> {
+    fn lower_pattern_unadjusted(
+        &mut self,
+        pat: PatId,
+    ) -> Pat<'db> {
         let mut ty = self.infer[pat];
         let variant = self.infer.variant_resolution_for_pat(pat);
-
         let kind = match self.body[pat] {
             hir_def::hir::Pat::Wild => PatKind::Wild,
 
                 PatKind::Wild
             }
         };
-
         Pat { ty, kind: Box::new(kind) }
     }
 
             self.errors.push(PatternError::ExtraFields);
             return Vec::new();
         }
-
         pats.iter()
             .enumerate_and_adjust(expected_len, ellipsis.map(|it| it as usize))
             .map(|(i, &subpattern)| FieldPat {
             .collect()
     }
 
-    fn lower_patterns(&mut self, pats: &[PatId]) -> Vec<Pat<'db>> {
+    fn lower_patterns(
+        &mut self,
+        pats: &[PatId],
+    ) -> Vec<Pat<'db>> {
         pats.iter().map(|&p| self.lower_pattern(p)).collect()
     }
 
-    fn lower_opt_pattern(&mut self, pat: Option<PatId>) -> Option<Pat<'db>> {
+    fn lower_opt_pattern(
+        &mut self,
+        pat: Option<PatId>,
+    ) -> Option<Pat<'db>> {
         pat.map(|p| self.lower_pattern(p))
     }
 
         }
     }
 
-    fn lower_path(&mut self, pat: PatId, _path: &Path) -> Pat<'db> {
+    fn lower_path(
+        &mut self,
+        pat: PatId,
+        _path: &Path,
+    ) -> Pat<'db> {
         let ty = self.infer[pat];
-
         let pat_from_kind = |kind| Pat { ty, kind: Box::new(kind) };
-
         match self.infer.variant_resolution_for_pat(pat) {
             Some(_) => pat_from_kind(self.lower_variant_or_leaf(pat, ty, Vec::new())),
             None => {
         }
     }
 
-    fn lower_lit(&mut self, expr: hir_def::hir::ExprId) -> PatKind<'db> {
+    fn lower_lit(
+        &mut self,
+        expr: hir_def::hir::ExprId,
+    ) -> PatKind<'db> {
         use hir_def::hir::{Expr, Literal::Bool};
-
         match self.body[expr] {
             Expr::Literal(Bool(value)) => PatKind::LiteralBool { value },
             _ => {
 }
 
 impl<'db> HirDisplay<'db> for Pat<'db> {
-    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError> {
+    fn hir_fmt(
+        &self,
+        f: &mut HirFormatter<'_, 'db>,
+    ) -> Result<(), HirDisplayError> {
         match &*self.kind {
             PatKind::Wild => write!(f, "_"),
             PatKind::Never => write!(f, "!"),
     }
 }
 
-struct WriteWith<'db, F>(F, PhantomCovariantLifetime<'db>)
-where
-    F: Fn(&mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError>;
+struct WriteWith<'db, F>(F, PhantomCovariantLifetime<'db>);
 
 impl<'db, F> WriteWith<'db, F>
 where
-    F: Fn(&mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError>,
-{
+    F: Fn(&mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError>, {
     fn new(f: F) -> Self {
         Self(f, PhantomCovariantLifetime::new())
     }
 
 impl<'db, F> HirDisplay<'db> for WriteWith<'db, F>
 where
-    F: Fn(&mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError>,
-{
-    fn hir_fmt(&self, f: &mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError> {
+    F: Fn(&mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError>, {
+    fn hir_fmt(
+        &self,
+        f: &mut HirFormatter<'_, 'db>,
+    ) -> Result<(), HirDisplayError> {
         (self.0)(f)
     }
 }