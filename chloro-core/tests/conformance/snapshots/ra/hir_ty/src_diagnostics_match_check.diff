COMPARISON DIFF
============================================================

Original size: 15979 bytes
Chloro size:   15897 bytes
Rustfmt size:  15979 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.
 
 mod pat_util;
-
 pub(crate) mod pat_analysis;
 
 use hir_def::{
-    AdtId, EnumVariantId, LocalFieldId, Lookup, VariantId,
-    expr_store::{Body, path::Path},
+    expr_store::{path::Path, Body},
     hir::PatId,
     item_tree::FieldsShape,
+    AdtId, EnumVariantId, LocalFieldId, Lookup, VariantId,
 };
 use hir_expand::name::Name;
 use rustc_type_ir::inherent::{IntoKind, SliceLike};
 use stdx::{always, never, variance::PhantomCovariantLifetime};
 
 use crate::{
-    InferenceResult,
     db::HirDatabase,
     display::{HirDisplay, HirDisplayError, HirFormatter},
     infer::BindingMode,
     next_solver::{GenericArgs, Mutability, Ty, TyKind},
+    InferenceResult,
 };
-
 use self::pat_util::EnumerateAndAdjustIterator;
 
 #[derive(Clone, Debug)]
         let unadjusted_pat = self.lower_pattern_unadjusted(pat);
         self.infer.pat_adjustments.get(&pat).map(|it| &**it).unwrap_or_default().iter().rev().fold(
             unadjusted_pat,
-            |subpattern, ref_ty| Pat { ty: *ref_ty, kind: Box::new(PatKind::Deref { subpattern }) },
+            |subpattern, ref_ty| Pat {
+            ty: *ref_ty,
+            kind: Box::new(PatKind::Deref { subpattern }),
+        },
         )
     }
 
             return Vec::new();
         }
 
-        pats.iter()
-            .enumerate_and_adjust(expected_len, ellipsis.map(|it| it as usize))
-            .map(|(i, &subpattern)| FieldPat {
-                field: LocalFieldId::from_raw((i as u32).into()),
-                pattern: self.lower_pattern(subpattern),
-            })
-            .collect()
+        pats.iter().enumerate_and_adjust(expected_len, ellipsis.map(|it| it as usize)).map(|(i, &subpattern)| FieldPat {
+            field: LocalFieldId::from_raw((i as u32).into()),
+            pattern: self.lower_pattern(subpattern),
+        }).collect(
+        )
     }
 
     fn lower_patterns(&mut self, pats: &[PatId]) -> Vec<Pat<'db>> {
                 } else {
                     PatKind::Leaf { subpatterns }
                 }
-            }
+            },
             None => {
                 self.errors.push(PatternError::UnresolvedVariant);
                 PatKind::Wild
-            }
+            },
         }
     }
 
             None => {
                 self.errors.push(PatternError::UnresolvedVariant);
                 pat_from_kind(PatKind::Wild)
-            }
+            },
         }
     }
 
             _ => {
                 self.errors.push(PatternError::Unimplemented);
                 PatKind::Wild
-            }
+            },
         }
     }
 }
                     subpattern.hir_fmt(f)?;
                 }
                 Ok(())
-            }
+            },
             PatKind::Variant { subpatterns, .. } | PatKind::Leaf { subpatterns } => {
                 let variant = match *self.kind {
                     PatKind::Variant { enum_variant, .. } => Some(VariantId::from(enum_variant)),
                         AdtId::EnumId(_) => None,
                     }),
                 };
-
                 if let Some(variant) = variant {
                     match variant {
                         VariantId::EnumVariantId(v) => {
                         return write!(f, " }}");
                     }
                 }
-
                 let num_fields =
                     variant.map_or(subpatterns.len(), |v| v.fields(f.db).fields().len());
                 if num_fields != 0 || variant.is_none() {
                     }
                     write!(f, ")")?;
                 }
-
                 Ok(())
-            }
+            },
             PatKind::Deref { subpattern } => {
                 match self.ty.kind() {
                     TyKind::Ref(.., mutbl) => {
                     _ => never!("{:?} is a bad Deref pattern type", self.ty),
                 }
                 subpattern.hir_fmt(f)
-            }
+            },
             PatKind::LiteralBool { value } => write!(f, "{value}"),
             PatKind::Or { pats } => f.write_joined(pats.iter(), " | "),
         }
     }
 }
 
-struct WriteWith<'db, F>(F, PhantomCovariantLifetime<'db>)
-where
-    F: Fn(&mut HirFormatter<'_, 'db>) -> Result<(), HirDisplayError>;
+struct WriteWith<'db, F>(F, PhantomCovariantLifetime<'db>);
 
 impl<'db, F> WriteWith<'db, F>
 where