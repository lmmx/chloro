COMPARISON DIFF
============================================================

Original size: 7506 bytes
Chloro size:   7505 bytes
Rustfmt size:  7929 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {
     // we need to take care a bit here to avoid infinite loops in case of cycles
     // (i.e. if we have `trait A: B; trait B: A;`)
-
     let mut result = smallvec![trait_];
     let mut i = 0;
     while let Some(&t) = result.get(i) {
             WherePredicate::Lifetime { .. } => None,
         })
         .filter(|(_, bound_modifier)| matches!(bound_modifier, TraitBoundModifier::None))
-        .filter_map(
-            |(path, _)| match resolver.resolve_path_in_type_ns_fully(db, path) {
-                Some(TypeNs::TraitId(t)) => Some(t),
-                _ => None,
-            },
-        )
+        .filter_map(|(path, _)| match resolver.resolve_path_in_type_ns_fully(db, path) {
+            Some(TypeNs::TraitId(t)) => Some(t),
+            _ => None,
+        })
         .for_each(cb);
 }
 
         // RFC 2396 <https://rust-lang.github.io/rfcs/2396-target-feature-1.1.html>.
         let callee_target_features =
             TargetFeatures::from_attrs_no_implications(&db.attrs(func.into()));
-        if !caller_target_features
-            .enabled
-            .is_superset(&callee_target_features.enabled)
-        {
+        if !caller_target_features.enabled.is_superset(&callee_target_features.enabled) {
             return Unsafety::Unsafe;
         }
     }
             if is_intrinsic_block {
                 // legacy intrinsics
                 // extern "rust-intrinsic" intrinsics are unsafe unless they have the rustc_safe_intrinsic attribute
-                if db
-                    .attrs(func.into())
-                    .by_key(sym::rustc_safe_intrinsic)
-                    .exists()
-                {
+                if db.attrs(func.into()).by_key(sym::rustc_safe_intrinsic).exists() {
                     Unsafety::Safe
                 } else {
                     Unsafety::Unsafe
             } else {
                 // Function in an `extern` block are always unsafe to call, except when
                 // it is marked as `safe`.
-                if data.is_safe() {
-                    Unsafety::Safe
-                } else {
-                    Unsafety::Unsafe
-                }
+                if data.is_safe() { Unsafety::Safe } else { Unsafety::Unsafe }
             }
         }
         _ => Unsafety::Safe,
         hir_def::layout::Variants::Single { index } => {
             (e.enum_variants(db).variants[index.0].0, layout)
         }
-        hir_def::layout::Variants::Multiple {
-            tag,
-            tag_encoding,
-            variants,
-            ..
-        } => {
+        hir_def::layout::Variants::Multiple { tag, tag_encoding, variants, .. } => {
             let size = tag.size(target_data_layout).bytes_usize();
             let offset = layout.fields.offset(0).bytes_usize(); // The only field on enum variants is the tag field
             let tag = i128::from_le_bytes(pad16(&b[offset..offset + size], false));
                         })?;
                     (var_idx, layout)
                 }
-                TagEncoding::Niche {
-                    untagged_variant,
-                    niche_start,
-                    ..
-                } => {
+                TagEncoding::Niche { untagged_variant, niche_start, .. } => {
                     let candidate_tag = tag.wrapping_sub(*niche_start as i128) as usize;
                     let variant = variants
                         .iter_enumerated()
                         .filter(|x| x != untagged_variant)
                         .nth(candidate_tag)
                         .unwrap_or(*untagged_variant);
-                    (
-                        e.enum_variants(db).variants[variant.0].0,
-                        &variants[variant],
-                    )
+                    (e.enum_variants(db).variants[variant.0].0, &variants[variant])
                 }
             }
         }