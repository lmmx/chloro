COMPARISON DIFF
============================================================

Original size: 6139 bytes
Chloro size:   6096 bytes
Rustfmt size:  6179 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html
 
+use rustc_hash::FxHashMap;
+use rustc_type_ir::{
+    inherent::{GenericArg as _, BoundVarIndexKind, GenericArgKind, IntoKind, SliceLike}, TypeFlags,
+    TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitableExt,
+};
+
 use crate::next_solver::{
     fold::FnMutDelegate, BoundConst, BoundRegion, BoundTy, Canonical, CanonicalVarValues, Clauses,
     Const, ConstKind, DbInterner, GenericArg, Predicate, Region, RegionKind, Ty, TyKind,
 };
-use rustc_hash::FxHashMap;
-use rustc_type_ir::{
-    inherent::{GenericArg as _, IntoKind, SliceLike},
-    BoundVarIndexKind, GenericArgKind, TypeFlags, TypeFoldable, TypeFolder, TypeSuperFoldable,
-    TypeVisitableExt,
-};
 
 pub trait CanonicalExt<'db, V> {
-    fn instantiate(&self, tcx: DbInterner<'db>, var_values: &CanonicalVarValues<'db>) -> V
+    fn instantiate(
+        &self,
+        tcx: DbInterner<'db>,
+        var_values: &CanonicalVarValues<'db>,
+    ) -> V
     where
         V: TypeFoldable<DbInterner<'db>>;
+
     fn instantiate_projected<T>(
         &self,
         tcx: DbInterner<'db>,
 impl<'db, V> CanonicalExt<'db, V> for Canonical<'db, V> {
     /// Instantiate the wrapped value, replacing each canonical value
     /// with the value given in `var_values`.
-    fn instantiate(&self, tcx: DbInterner<'db>, var_values: &CanonicalVarValues<'db>) -> V
+    fn instantiate(
+        &self,
+        tcx: DbInterner<'db>,
+        var_values: &CanonicalVarValues<'db>,
+    ) -> V
     where
-        V: TypeFoldable<DbInterner<'db>>,
-    {
+        V: TypeFoldable<DbInterner<'db>>, {
         self.instantiate_projected(tcx, var_values, |value| value.clone())
     }
 
         projection_fn: impl FnOnce(&V) -> T,
     ) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         assert_eq!(self.variables.len(), var_values.len());
         let value = projection_fn(&self.value);
         instantiate_value(tcx, var_values, value)
     value: T,
 ) -> T
 where
-    T: TypeFoldable<DbInterner<'db>>,
-{
+    T: TypeFoldable<DbInterner<'db>>, {
     if var_values.var_values.is_empty() {
         value
     } else {
 /// Replaces the bound vars in a canonical binder with var values.
 struct CanonicalInstantiator<'db, 'a> {
     tcx: DbInterner<'db>,
-
-    // The values that the bound vars are being instantiated with.
     var_values: &'a [GenericArg<'db>],
-
-    // Because we use `BoundVarIndexKind::Canonical`, we can cache
-    // based only on the entire ty, not worrying about a `DebruijnIndex`
     cache: FxHashMap<Ty<'db>, Ty<'db>>,
 }
 
         self.tcx
     }
 
-    fn fold_ty(&mut self, t: Ty<'db>) -> Ty<'db> {
+    fn fold_ty(
+        &mut self,
+        t: Ty<'db>,
+    ) -> Ty<'db> {
         match t.kind() {
             TyKind::Bound(BoundVarIndexKind::Canonical, bound_ty) => {
                 self.var_values[bound_ty.var.as_usize()].expect_ty()
         }
     }
 
-    fn fold_region(&mut self, r: Region<'db>) -> Region<'db> {
+    fn fold_region(
+        &mut self,
+        r: Region<'db>,
+    ) -> Region<'db> {
         match r.kind() {
             RegionKind::ReBound(BoundVarIndexKind::Canonical, br) => {
                 self.var_values[br.var.as_usize()].expect_region()
         }
     }
 
-    fn fold_const(&mut self, ct: Const<'db>) -> Const<'db> {
+    fn fold_const(
+        &mut self,
+        ct: Const<'db>,
+    ) -> Const<'db> {
         match ct.kind() {
             ConstKind::Bound(BoundVarIndexKind::Canonical, bound_const) => {
                 self.var_values[bound_const.var.as_usize()].expect_const()
         }
     }
 
-    fn fold_predicate(&mut self, p: Predicate<'db>) -> Predicate<'db> {
-        if p.has_type_flags(TypeFlags::HAS_CANONICAL_BOUND) {
-            p.super_fold_with(self)
-        } else {
-            p
-        }
+    fn fold_predicate(
+        &mut self,
+        p: Predicate<'db>,
+    ) -> Predicate<'db> {
+        if p.has_type_flags(TypeFlags::HAS_CANONICAL_BOUND) { p.super_fold_with(self) } else { p }
     }
 
-    fn fold_clauses(&mut self, c: Clauses<'db>) -> Clauses<'db> {
+    fn fold_clauses(
+        &mut self,
+        c: Clauses<'db>,
+    ) -> Clauses<'db> {
         if !c.has_type_flags(TypeFlags::HAS_CANONICAL_BOUND) {
             return c;
         }
-
         // FIXME: We might need cache here for perf like rustc
         c.super_fold_with(self)
     }