COMPARISON DIFF
============================================================

Original size: 6139 bytes
Chloro size:   6182 bytes
Rustfmt size:  6179 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html
 
-use crate::next_solver::{
-    fold::FnMutDelegate, BoundConst, BoundRegion, BoundTy, Canonical, CanonicalVarValues, Clauses,
-    Const, ConstKind, DbInterner, GenericArg, Predicate, Region, RegionKind, Ty, TyKind,
-};
 use rustc_hash::FxHashMap;
 use rustc_type_ir::{
     inherent::{GenericArg as _, IntoKind, SliceLike},
     TypeVisitableExt,
 };
 
+use crate::next_solver::{
+    fold::FnMutDelegate, BoundConst, BoundRegion, BoundTy, Canonical, CanonicalVarValues, Clauses,
+    Const, ConstKind, DbInterner, GenericArg, Predicate, Region, RegionKind, Ty, TyKind,
+};
+
 pub trait CanonicalExt<'db, V> {
     fn instantiate(&self, tcx: DbInterner<'db>, var_values: &CanonicalVarValues<'db>) -> V
     where
         V: TypeFoldable<DbInterner<'db>>;
+
     fn instantiate_projected<T>(
         &self,
         tcx: DbInterner<'db>,
                 c => panic!("{bound_ct:?} is a const but value is {c:?}"),
             },
         };
-
         let value = tcx.replace_escaping_bound_vars_uncached(value, delegate);
         value.fold_with(&mut CanonicalInstantiator {
             tcx,
 /// Replaces the bound vars in a canonical binder with var values.
 struct CanonicalInstantiator<'db, 'a> {
     tcx: DbInterner<'db>,
-
     // The values that the bound vars are being instantiated with.
     var_values: &'a [GenericArg<'db>],
-
     // Because we use `BoundVarIndexKind::Canonical`, we can cache
     // based only on the entire ty, not worrying about a `DebruijnIndex`
     cache: FxHashMap<Ty<'db>, Ty<'db>>,
         match t.kind() {
             TyKind::Bound(BoundVarIndexKind::Canonical, bound_ty) => {
                 self.var_values[bound_ty.var.as_usize()].expect_ty()
-            }
+            },
             _ => {
                 if !t.has_type_flags(TypeFlags::HAS_CANONICAL_BOUND) {
                     t
                     assert!(self.cache.insert(t, res).is_none());
                     res
                 }
-            }
+            },
         }
     }
 
         match r.kind() {
             RegionKind::ReBound(BoundVarIndexKind::Canonical, br) => {
                 self.var_values[br.var.as_usize()].expect_region()
-            }
+            },
             _ => r,
         }
     }
         match ct.kind() {
             ConstKind::Bound(BoundVarIndexKind::Canonical, bound_const) => {
                 self.var_values[bound_const.var.as_usize()].expect_const()
-            }
+            },
             _ => ct.super_fold_with(self),
         }
     }