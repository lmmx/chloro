COMPARISON DIFF
============================================================

Original size: 5600 bytes
Chloro size:   5560 bytes
Rustfmt size:  5891 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ena::undo_log::UndoLogs;
 use tracing::instrument;
 
-use super::OpaqueHiddenType;
 use crate::next_solver::{
     infer::snapshot::undo_log::{InferCtxtUndoLogs, UndoLog},
     FxIndexMap, OpaqueTypeKey, Ty,
 };
+use super::OpaqueHiddenType;
 
 #[derive(Default, Debug, Clone)]
 pub(crate) struct OpaqueTypeStorage<'db> {
         if let Some(prev) = prev {
             *self.opaque_types.get_mut(&key).unwrap() = prev;
         } else {
-            // FIXME(#120456) - is `swap_remove` correct?
             match self.opaque_types.swap_remove(&key) {
                 None => {
                     panic!("reverted opaque type inference that was never registered: {key:?}")
                 }
-                Some(_) => {}
+                Some(_) => {
+                }
             }
         }
     }
     }
 
     pub(crate) fn is_empty(&self) -> bool {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
         opaque_types.is_empty() && duplicate_entries.is_empty()
     }
 
     pub(crate) fn take_opaque_types(
         &mut self,
     ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
-        std::mem::take(opaque_types)
-            .into_iter()
-            .chain(std::mem::take(duplicate_entries))
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
+        std::mem::take(opaque_types).into_iter().chain(std::mem::take(duplicate_entries))
     }
 
     pub(crate) fn num_entries(&self) -> OpaqueTypeStorageEntries {
             .iter()
             .skip(prev_entries.opaque_types)
             .map(|(k, v)| (*k, *v))
-            .chain(
-                self.duplicate_entries
-                    .iter()
-                    .skip(prev_entries.duplicate_entries)
-                    .copied(),
-            )
+            .chain(self.duplicate_entries.iter().skip(prev_entries.duplicate_entries).copied())
     }
 
     /// Only returns the opaque types from the lookup table. These are used
     pub(crate) fn iter_opaque_types(
         &self,
     ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
-        opaque_types
-            .iter()
-            .map(|(k, v)| (*k, *v))
-            .chain(duplicate_entries.iter().copied())
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
+        opaque_types.iter().map(|(k, v)| (*k, *v)).chain(duplicate_entries.iter().copied())
     }
 
     #[inline]
         &'a mut self,
         undo_log: &'a mut InferCtxtUndoLogs<'db>,
     ) -> OpaqueTypeTable<'a, 'db> {
-        OpaqueTypeTable {
-            storage: self,
-            undo_log,
-        }
+        OpaqueTypeTable { storage: self, undo_log }
     }
 }
 
 pub(crate) struct OpaqueTypeTable<'a, 'db> {
     storage: &'a mut OpaqueTypeStorage<'db>,
-
     undo_log: &'a mut InferCtxtUndoLogs<'db>,
 }
+
 impl<'db> Deref for OpaqueTypeTable<'_, 'db> {
     type Target = OpaqueTypeStorage<'db>;
+
     fn deref(&self) -> &Self::Target {
         self.storage
     }