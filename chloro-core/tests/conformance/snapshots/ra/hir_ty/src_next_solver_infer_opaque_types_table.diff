COMPARISON DIFF
============================================================

Original size: 5600 bytes
Chloro size:   5603 bytes
Rustfmt size:  5891 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ena::undo_log::UndoLogs;
 use tracing::instrument;
 
-use super::OpaqueHiddenType;
 use crate::next_solver::{
     infer::snapshot::undo_log::{InferCtxtUndoLogs, UndoLog},
-    FxIndexMap, OpaqueTypeKey, Ty,
+    FxIndexMap,
+    OpaqueTypeKey,
+    Ty,
 };
+use super::OpaqueHiddenType;
 
 #[derive(Default, Debug, Clone)]
 pub(crate) struct OpaqueTypeStorage<'db> {
 }
 
 impl rustc_type_ir::inherent::OpaqueTypeStorageEntries for OpaqueTypeStorageEntries {
-    fn needs_reevaluation(self, canonicalized: usize) -> bool {
+    fn needs_reevaluation(
+        self,
+        canonicalized: usize,
+    ) -> bool {
         self.opaque_types != canonicalized
     }
 }
 
 impl<'db> OpaqueTypeStorage<'db> {
     #[instrument(level = "debug")]
-    pub(crate) fn remove(&mut self, key: OpaqueTypeKey<'db>, prev: Option<OpaqueHiddenType<'db>>) {
+    pub(crate) fn remove(
+        &mut self,
+        key: OpaqueTypeKey<'db>,
+        prev: Option<OpaqueHiddenType<'db>>,
+    ) {
         if let Some(prev) = prev {
             *self.opaque_types.get_mut(&key).unwrap() = prev;
         } else {
     }
 
     pub(crate) fn is_empty(&self) -> bool {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
         opaque_types.is_empty() && duplicate_entries.is_empty()
     }
 
-    pub(crate) fn take_opaque_types(
-        &mut self,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
-        std::mem::take(opaque_types)
-            .into_iter()
-            .chain(std::mem::take(duplicate_entries))
+    pub(crate) fn take_opaque_types(&mut self) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
+        std::mem::take(opaque_types).into_iter().chain(std::mem::take(duplicate_entries))
     }
 
     pub(crate) fn num_entries(&self) -> OpaqueTypeStorageEntries {
             .iter()
             .skip(prev_entries.opaque_types)
             .map(|(k, v)| (*k, *v))
-            .chain(
-                self.duplicate_entries
-                    .iter()
-                    .skip(prev_entries.duplicate_entries)
-                    .copied(),
-            )
+            .chain(self.duplicate_entries.iter().skip(prev_entries.duplicate_entries).copied())
     }
 
     /// Only returns the opaque types from the lookup table. These are used
     ///
     /// Outside of canonicalization one should generally use `iter_opaque_types`
     /// to also consider duplicate entries.
-    pub(crate) fn iter_lookup_table(
-        &self,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+    pub(crate) fn iter_lookup_table(&self) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
         self.opaque_types.iter().map(|(k, v)| (*k, *v))
     }
 
     /// These have to considered when checking all opaque type uses but are e.g.
     /// irrelevant for canonical inputs as nested queries never meaningfully
     /// accesses them.
-    pub(crate) fn iter_duplicate_entries(
-        &self,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+    pub(crate) fn iter_duplicate_entries(&self) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
         self.duplicate_entries.iter().copied()
     }
 
-    pub(crate) fn iter_opaque_types(
-        &self,
-    ) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
-        let OpaqueTypeStorage {
-            opaque_types,
-            duplicate_entries,
-        } = self;
-        opaque_types
-            .iter()
-            .map(|(k, v)| (*k, *v))
-            .chain(duplicate_entries.iter().copied())
+    pub(crate) fn iter_opaque_types(&self) -> impl Iterator<Item = (OpaqueTypeKey<'db>, OpaqueHiddenType<'db>)> {
+        let OpaqueTypeStorage { opaque_types, duplicate_entries } = self;
+        opaque_types.iter().map(|(k, v)| (*k, *v)).chain(duplicate_entries.iter().copied())
     }
 
     #[inline]
         &'a mut self,
         undo_log: &'a mut InferCtxtUndoLogs<'db>,
     ) -> OpaqueTypeTable<'a, 'db> {
-        OpaqueTypeTable {
-            storage: self,
-            undo_log,
-        }
+        OpaqueTypeTable { storage: self, undo_log }
     }
 }
 
 pub(crate) struct OpaqueTypeTable<'a, 'db> {
     storage: &'a mut OpaqueTypeStorage<'db>,
-
     undo_log: &'a mut InferCtxtUndoLogs<'db>,
 }
+
 impl<'db> Deref for OpaqueTypeTable<'_, 'db> {
     type Target = OpaqueTypeStorage<'db>;
+
     fn deref(&self) -> &Self::Target {
         self.storage
     }