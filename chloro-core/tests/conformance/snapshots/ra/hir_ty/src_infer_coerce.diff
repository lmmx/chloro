COMPARISON DIFF
============================================================

Original size: 68687 bytes
Chloro size:   66964 bytes
Rustfmt size:  68687 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! ```
 
 use hir_def::{
-    CallableDefId,
     hir::{ExprId, ExprOrPatId},
     lang_item::LangItem,
     signatures::FunctionSignature,
+    CallableDefId,
 };
 use intern::sym;
 use rustc_ast_ir::Mutability;
 use rustc_type_ir::{
-    BoundVar, TypeAndMut,
     error::TypeError,
     inherent::{Const as _, GenericArg as _, IntoKind, Safety, SliceLike, Ty as _},
+    BoundVar, TypeAndMut,
 };
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use tracing::{debug, instrument};
 use triomphe::Arc;
 
 use crate::{
-    Adjust, Adjustment, AutoBorrow, PointerCast, TargetFeatures, TraitEnvironment,
     autoderef::Autoderef,
     db::{HirDatabase, InternedClosureId},
-    infer::{AllowTwoPhase, InferenceContext, TypeMismatch, unify::InferenceTable},
+    infer::{unify::InferenceTable, AllowTwoPhase, InferenceContext, TypeMismatch},
     next_solver::{
-        Binder, BoundConst, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, CallableIdWrapper,
-        Canonical, ClauseKind, CoercePredicate, Const, ConstKind, DbInterner, ErrorGuaranteed,
-        GenericArgs, PolyFnSig, PredicateKind, Region, RegionKind, TraitRef, Ty, TyKind,
         infer::{
             InferCtxt, InferOk, InferResult,
             relate::RelateResult,
             select::{ImplSource, SelectionError},
             traits::{Obligation, ObligationCause, PredicateObligation, PredicateObligations},
         },
-        obligation_ctxt::ObligationCtxt,
+        obligation_ctxt::ObligationCtxt, Binder, BoundConst, BoundRegion, BoundRegionKind,
+        BoundTy, BoundTyKind, CallableIdWrapper, Canonical, ClauseKind, CoercePredicate, Const,
+        ConstKind, DbInterner, ErrorGuaranteed, GenericArgs, PolyFnSig, PredicateKind, Region,
+        RegionKind, TraitRef, Ty, TyKind,
     },
     utils::TargetFeatureIsSafeInTarget,
+    Adjust, Adjustment, AutoBorrow, PointerCast, TargetFeatures, TraitEnvironment,
 };
 
 struct Coerce<'a, 'b, 'db> {
 /// Coercing a mutable reference to an immutable works, while
 /// coercing `&T` to `&mut T` should be forbidden.
 fn coerce_mutbls<'db>(from_mutbl: Mutability, to_mutbl: Mutability) -> RelateResult<'db, ()> {
-    if from_mutbl >= to_mutbl { Ok(()) } else { Err(TypeError::Mutability) }
+    if from_mutbl >= to_mutbl {
+        Ok(())
+    } else {
+        Err(TypeError::Mutability)
+    }
 }
 
 /// This always returns `Ok(...)`.
         }
 
         // Coercing *from* an unresolved inference variable means that
+
         // we have no information about the source type. This will always
+
         // ultimately fall back to some form of subtyping.
         if a.is_infer() {
             return self.coerce_from_inference_variable(a, b);
         }
 
         // Consider coercing the subtype to a DST
+
         //
+
         // NOTE: this is wrapped in a `commit_if_ok` because it creates
+
         // a "spurious" type variable, and we don't want to have that
+
         // type variable in memory if the coercion fails.
         let unsize = self.commit_if_ok(|this| this.coerce_unsized(a, b));
         match unsize {
         }
 
         // Examine the supertype and consider type-specific coercions, such
+
         // as auto-borrowing, coercing pointer mutability, a `dyn*` coercion,
+
         // or pin-ergonomics.
         match b.kind() {
             TyKind::RawPtr(_, b_mutbl) => {
 
         match a.kind() {
             TyKind::FnDef(..) => {
-                // Function items are coercible to any closure
-                // type; function pointers are not (that would
-                // require double indirection).
-                // Additionally, we permit coercion of function
-                // items to drop the unsafe qualifier.
                 self.coerce_from_fn_item(a, b)
             }
             TyKind::FnPtr(a_sig_tys, a_hdr) => {
-                // We permit coercion of fn pointers to drop the
-                // unsafe qualifier.
                 self.coerce_from_fn_pointer(a_sig_tys.with(a_hdr), b)
             }
             TyKind::Closure(closure_def_id_a, args_a) => {
-                // Non-capturing closures are coercible to
-                // function pointers or unsafe function pointers.
-                // It cannot convert closures that require unsafe.
                 self.coerce_closure_to_fn(a, closure_def_id_a.0, args_a, b)
             }
             _ => {
-                // Otherwise, just use unification rules.
                 self.unify(a, b)
             }
         }
         debug_assert!(self.table.shallow_resolve(b) == b);
 
         if b.is_infer() {
-            // Two unresolved type variables: create a `Coerce` predicate.
             let target_ty = if self.use_lub { self.table.next_ty_var() } else { b };
-
             let mut obligations = PredicateObligations::with_capacity(2);
             for &source_ty in &[a, b] {
                 if source_ty != target_ty {
                     ));
                 }
             }
-
             debug!(
                 "coerce_from_inference_variable: two inference variables, target_ty={:?}, obligations={:?}",
                 target_ty, obligations
             );
             success(vec![], target_ty, obligations)
         } else {
-            // One unresolved type variable: just apply subtyping, we may be able
-            // to do something useful.
             self.unify(a, b)
         }
     }
         debug_assert!(self.table.shallow_resolve(b) == b);
 
         // If we have a parameter of type `&M T_a` and the value
-        // provided is `expr`, we will be adding an implicit borrow,
-        // meaning that we convert `f(expr)` to `f(&M *expr)`. Therefore,
-        // to type check, we will construct the type that `&M*expr` would
-        // yield.
 
+        // provided is `expr`, we will be adding an implicit borrow,
+
+        // meaning that we convert `f(expr)` to `f(&M *expr)`. Therefore,
+
+        // to type check, we will construct the type that `&M*expr` would
+
+        // yield.
         let (r_a, mt_a) = match a.kind() {
             TyKind::Ref(r_a, ty, mutbl) => {
                 let mt_a = TypeAndMut::<DbInterner<'db>> { ty, mutbl };
         }
 
         // Extract type or return an error. We return the first error
+
         // we got, which should be from relating the "base" type
+
         // (e.g., in example above, the failure from relating `Vec<T>`
+
         // to the target type), since that should be the least
+
         // confusing.
         let Some(InferOk { value: ty, mut obligations }) = found else {
             if let Some(first_error) = first_error {
         obligations.extend(o);
 
         // Now apply the autoref. We have to extract the region out of
+
         // the final ref type we got.
         let TyKind::Ref(region, _, _) = ty.kind() else {
             panic!("expected a ref type, got {:?}", ty);
         debug_assert!(self.table.shallow_resolve(target) == target);
 
         // We don't apply any coercions incase either the source or target
+
         // aren't sufficiently well known but tend to instead just equate
+
         // them both.
         if source.is_infer() {
             debug!("coerce_unsized: source is a TyVar, bailing out");
         }
 
         // This is an optimization because coercion is one of the most common
+
         // operations that we do in typeck, since it happens at every assignment
+
         // and call arg (among other positions).
+
         //
+
         // These targets are known to never be RHS in `LHS: CoerceUnsized<RHS>`.
+
         // That's because these are built-in types for which a core-provided impl
+
         // doesn't exist, and for which a user-written impl is invalid.
+
         //
+
         // This is technically incomplete when users write impossible bounds like
+
         // `where T: CoerceUnsized<usize>`, for example, but that trait is unstable
+
         // and coercion is allowed to be incomplete. The only case where this matters
+
         // is impossible bounds.
+
         //
+
         // Note that some of these types implement `LHS: Unsize<RHS>`, but they
+
         // do not implement *`CoerceUnsized`* which is the root obligation of the
+
         // check below.
         match target.kind() {
             TyKind::Bool
         };
 
         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to
+
         // a DST unless we have to. This currently comes out in the wash since
+
         // we can't unify [T] with U. But to properly support DST, we need to allow
+
         // that, at which point we will need extra checks on the target here.
 
         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.
         let coerce_source = reborrow.as_ref().map_or(source, |(_, r)| r.target);
 
         // Setup either a subtyping or a LUB relationship between
+
         // the `CoerceUnsized` target type and the expected type.
+
         // We only have the latter, so we use an inference variable
+
         // for the former and let type inference do the rest.
         let coerce_target = self.table.next_ty_var();
 
         let cause = self.cause.clone();
 
         // Use a FIFO queue for this custom fulfillment procedure.
+
         //
+
         // A Vec (or SmallVec) is not a natural choice for a queue. However,
+
         // this code path is hot, and this queue usually has a max length of 1
+
         // and almost never more than 3. By using a SmallVec we avoid an
+
         // allocation, at the (very small) cost of (occasionally) having to
+
         // shift subsequent elements down when removing the front element.
         let mut queue: SmallVec<[PredicateObligation<'db>; 4]> = smallvec![Obligation::new(
             self.interner(),
         })
     }
 
-    fn coerce_from_fn_pointer(&mut self, fn_ty_a: PolyFnSig<'db>, b: Ty<'db>) -> CoerceResult<'db> {
+    fn coerce_from_fn_pointer(
+        &mut self,
+        fn_ty_a: PolyFnSig<'db>,
+        b: Ty<'db>,
+    ) -> CoerceResult<'db> {
         debug!(?fn_ty_a, ?b, "coerce_from_fn_pointer");
         debug_assert!(self.table.shallow_resolve(b) == b);
 
                         }
                     }
                 }
-
                 self.coerce_from_safe_fn(
                     a_sig,
                     b,
         debug_assert!(self.table.shallow_resolve(b) == b);
 
         match b.kind() {
-            // FIXME: We need to have an `upvars_mentioned()` query:
-            // At this point we haven't done capture analysis, which means
-            // that the ClosureArgs just contains an inference variable instead
-            // of tuple of captured types.
-            //
-            // All we care here is if any variable is being captured and not the exact paths,
-            // so we check `upvars_mentioned` for root variables being captured.
-            TyKind::FnPtr(_, hdr) =>
-            // if self
-            //     .db
-            //     .upvars_mentioned(closure_def_id_a.expect_local())
-            //     .is_none_or(|u| u.is_empty()) =>
-            {
-                // We coerce the closure, which has fn type
-                //     `extern "rust-call" fn((arg0,arg1,...)) -> _`
-                // to
-                //     `fn(arg0,arg1,...) -> _`
-                // or
-                //     `unsafe fn(arg0,arg1,...) -> _`
+            TyKind::FnPtr(_, hdr) => {
                 let safety = hdr.safety;
                 let closure_sig = args_a.closure_sig_untupled().map_bound(|mut sig| {
                     sig.safety = hdr.safety;
         }
     }
 
-    fn coerce_raw_ptr(&mut self, a: Ty<'db>, b: Ty<'db>, mutbl_b: Mutability) -> CoerceResult<'db> {
+    fn coerce_raw_ptr(
+        &mut self,
+        a: Ty<'db>,
+        b: Ty<'db>,
+        mutbl_b: Mutability,
+    ) -> CoerceResult<'db> {
         debug!("coerce_raw_ptr(a={:?}, b={:?})", a, b);
         debug_assert!(self.table.shallow_resolve(a) == a);
         debug_assert!(self.table.shallow_resolve(b) == b);
             self.unify_and(
                 a_raw,
                 b,
-                [Adjustment { kind: Adjust::Deref(None), target: mt_a.ty }],
+                [
+                Adjustment {
+                kind: Adjust::Deref(None),
+                target: mt_a.ty,
+            },
+            ],
                 Adjust::Borrow(AutoBorrow::RawPtr(mutbl_b)),
             )
         } else if mt_a.mutbl != mutbl_b {
         );
 
         // The following check fixes #88097, where the compiler erroneously
+
         // attempted to coerce a closure type to itself via a function pointer.
         if prev_ty == new_ty {
             return Ok(prev_ty);
         }
 
         // Special-case that coercion alone cannot handle:
+
         // Function items or non-capturing closures of differing IDs or GenericArgs.
         let (a_sig, b_sig) = {
             let is_capturing_closure = |_ty: Ty<'db>| {
         }
 
         // Configure a Coerce instance to compute the LUB.
+
         // We don't allow two-phase borrows on any autorefs this creates since we
+
         // probably aren't processing function arguments here and even if we were,
+
         // they're going to get autorefed again anyway and we can apply 2-phase borrows
+
         // at that time.
+
         //
+
         // NOTE: we set `coerce_never` to `true` here because coercion LUBs only
+
         // operate on values and not places, so a never coercion is valid.
         let krate = self.krate();
         let mut coerce = Coerce {
         };
 
         // First try to coerce the new expression to the type of the previous ones,
+
         // but only if the new expression has no coercion already applied to it.
         let mut first_error = None;
         if !self.result.expr_adjustments.contains_key(&new) {
 
         match coerce.commit_if_ok(|coerce| coerce.coerce(prev_ty, new_ty)) {
             Err(_) => {
-                // Avoid giving strange errors on failed attempts.
                 if let Some(e) = first_error {
                     Err(e)
                 } else {
         if let Some(final_ty) = self.final_ty {
             final_ty
         } else {
-            // If we only had inputs that were of type `!` (or no
-            // inputs at all), then the final type is `!`.
             assert_eq!(self.pushed, 0);
             icx.types.never
         }
     table.register_predicates(obligations);
 
     // default any type vars that weren't unified back to their original bound vars
+
     // (kind of hacky)
     let mut fallback_ty = |debruijn, infer| {
         let var = vars.var_values.iter().position(|arg| {