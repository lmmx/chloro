COMPARISON DIFF
============================================================

Original size: 17858 bytes
Chloro size:   17639 bytes
Rustfmt size:  18799 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     display::{ClosureStyle, DisplayTarget, HirDisplay},
     mir::{PlaceElem, ProjectionElem, StatementKind, TerminatorKind},
 };
-
 use super::{
     AggregateKind, BasicBlockId, BorrowKind, LocalId, MirBody, MutBorrowKind, Operand, OperandKind,
     Place, Rvalue, UnOp,
         ctx.for_body(|this| match ctx.body.owner {
             hir_def::DefWithBodyId::FunctionId(id) => {
                 let data = db.function_signature(id);
-                w!(
-                    this,
-                    "fn {}() ",
-                    data.name.display(db, this.display_target.edition)
-                );
+                w!(this, "fn {}() ", data.name.display(db, this.display_target.edition));
             }
             hir_def::DefWithBodyId::StaticId(id) => {
                 let data = db.static_signature(id);
-                w!(
-                    this,
-                    "static {}: _ = ",
-                    data.name.display(db, this.display_target.edition)
-                );
+                w!(this, "static {}: _ = ", data.name.display(db, this.display_target.edition));
             }
             hir_def::DefWithBodyId::ConstId(id) => {
                 let data = db.const_signature(id);
         ctx.result
     }
 
-    // String with lines is rendered poorly in `dbg` macros, which I use very much, so this
-    // function exists to solve that.
     pub fn dbg(&self, db: &'db dyn HirDatabase, display_target: DisplayTarget) -> impl Debug {
         struct StringDbg(String);
         impl Debug for StringDbg {
 
 impl Write for MirPrettyCtx<'_, '_> {
     fn write_str(&mut self, s: &str) -> std::fmt::Result {
-        let mut it = s.split('\n'); // note: `.lines()` is wrong here
+        let mut it = s.split('\n');
+        // note: `.lines()` is wrong here
         self.write(it.next().unwrap_or_default());
         for line in it {
             self.write_line();
         match self {
             LocalName::Unknown(l) => write!(f, "_{}", u32::from(l.into_raw())),
             LocalName::Binding(n, l) => {
-                write!(
-                    f,
-                    "{}_{}",
-                    n.display(f.db, f.edition()),
-                    u32::from(l.into_raw())
-                )
-            }
+                write!(f, "{}_{}", n.display(f.db, f.edition()), u32::from(l.into_raw()))
+            },
         }
     }
 }
             wln!(
                 self,
                 "let {}: {};",
-                self.local_name(id)
-                    .display_test(self.db, self.display_target),
+                self.local_name(id).display_test(self.db, self.display_target),
                 self.hir_display(&local.ty)
             );
         }
                             wln!(
                                 this,
                                 "StorageDead({})",
-                                this.local_name(*p)
-                                    .display_test(this.db, this.display_target)
+                                this.local_name(*p).display_test(this.db, this.display_target)
                             );
                         }
                         StatementKind::StorageLive(p) => {
                             wln!(
                                 this,
                                 "StorageLive({})",
-                                this.local_name(*p)
-                                    .display_test(this.db, this.display_target)
+                                this.local_name(*p).display_test(this.db, this.display_target)
                             );
                         }
                         StatementKind::Deinit(p) => {
                     Some(terminator) => match &terminator.kind {
                         TerminatorKind::Goto { target } => {
                             wln!(this, "goto 'bb{};", u32::from(target.into_raw()))
-                        }
+                        },
                         TerminatorKind::SwitchInt { discr, targets } => {
                             w!(this, "switch ");
                             this.operand(discr);
                                 }
                                 wln!(this, "_ => {},", this.basic_block_id(targets.otherwise()));
                             });
-                        }
-                        TerminatorKind::Call {
-                            func,
-                            args,
-                            destination,
-                            target,
-                            ..
-                        } => {
+                        },
+                        TerminatorKind::Call { func, args, destination, target, .. } => {
                             w!(this, "Call ");
                             this.with_block(|this| {
                                 w!(this, "func: ");
                                 }
                                 wln!(this, ",");
                             });
-                        }
+                        },
                         _ => wln!(this, "{:?};", terminator),
                     },
                     None => wln!(this, "<no-terminator>;"),
         ) {
             let Some((last, head)) = projections.split_last() else {
                 // no projection
-                w!(
-                    this,
-                    "{}",
-                    this.local_name(local)
-                        .display_test(this.db, this.display_target)
-                );
+                w!(this, "{}", this.local_name(local).display_test(this.db, this.display_target));
                 return;
             };
             match last {
                         }
                         hir_def::VariantId::StructId(_) | hir_def::VariantId::UnionId(_) => {
                             f(this, local, head);
-                            w!(
-                                this,
-                                ".{}",
-                                name.display(this.db, this.display_target.edition)
-                            );
+                            w!(this, ".{}", name.display(this.db, this.display_target.edition));
                         }
                     }
                 }
                     w!(
                         this,
                         "[{}]",
-                        this.local_name(*l)
-                            .display_test(this.db, this.display_target)
+                        this.local_name(*l).display_test(this.db, this.display_target)
                     );
                 }
                 it => {
                 }
             }
         }
-        f(
-            self,
-            p.local,
-            p.projection.lookup(&self.body.projection_store),
-        );
+        f(self, p.local, p.projection.lookup(&self.body.projection_store));
     }
 
     fn operand(&mut self, r: &Operand<'db>) {
         match &r.kind {
             OperandKind::Copy(p) | OperandKind::Move(p) => {
-                // MIR at the time of writing doesn't have difference between move and copy, so we show them
-                // equally. Feel free to change it.
                 self.place(p);
-            }
+            },
             OperandKind::Constant { konst, .. } => w!(self, "Const({})", self.hir_display(konst)),
             OperandKind::Static(s) => w!(self, "Static({:?})", s),
         }
                 match r {
                     BorrowKind::Shared => w!(self, "&"),
                     BorrowKind::Shallow => w!(self, "&shallow "),
-                    BorrowKind::Mut {
-                        kind: MutBorrowKind::ClosureCapture,
-                    } => w!(self, "&uniq "),
+                    BorrowKind::Mut { kind: MutBorrowKind::ClosureCapture } => w!(self, "&uniq "),
                     BorrowKind::Mut {
                         kind: MutBorrowKind::Default | MutBorrowKind::TwoPhasedBorrow,
                     } => w!(self, "&mut "),
                 }
                 self.place(p);
-            }
+            },
             Rvalue::Aggregate(AggregateKind::Tuple(_), it) => {
                 w!(self, "(");
                 self.operand_list(it);
                 w!(self, ")");
-            }
+            },
             Rvalue::Aggregate(AggregateKind::Array(_), it) => {
                 w!(self, "[");
                 self.operand_list(it);
                 w!(self, "]");
-            }
+            },
             Rvalue::Repeat(op, len) => {
                 w!(self, "[");
                 self.operand(op);
-                w!(
-                    self,
-                    "; {}]",
-                    len.display_test(self.db, self.display_target)
-                );
-            }
+                w!(self, "; {}]", len.display_test(self.db, self.display_target));
+            },
             Rvalue::Aggregate(AggregateKind::Adt(_, _), it) => {
                 w!(self, "Adt(");
                 self.operand_list(it);
                 w!(self, ")");
-            }
+            },
             Rvalue::Aggregate(AggregateKind::Closure(_), it) => {
                 w!(self, "Closure(");
                 self.operand_list(it);
                 w!(self, ")");
-            }
+            },
             Rvalue::Aggregate(AggregateKind::Union(_, _), it) => {
                 w!(self, "Union(");
                 self.operand_list(it);
                 w!(self, ")");
-            }
+            },
             Rvalue::Len(p) => {
                 w!(self, "Len(");
                 self.place(p);
                 w!(self, ")");
-            }
+            },
             Rvalue::Cast(ck, op, ty) => {
                 w!(self, "Cast({ck:?}, ");
                 self.operand(op);
                 w!(self, ", {})", self.hir_display(ty));
-            }
+            },
             Rvalue::CheckedBinaryOp(b, o1, o2) => {
                 self.operand(o1);
                 w!(self, " {b} ");
                 self.operand(o2);
-            }
+            },
             Rvalue::UnaryOp(u, o) => {
                 let u = match u {
                     UnOp::Not => "!",
                 };
                 w!(self, "{u} ");
                 self.operand(o);
-            }
+            },
             Rvalue::Discriminant(p) => {
                 w!(self, "Discriminant(");
                 self.place(p);
                 w!(self, ")");
-            }
+            },
             Rvalue::ShallowInitBoxWithAlloc(_) => w!(self, "ShallowInitBoxWithAlloc"),
             Rvalue::ShallowInitBox(op, _) => {
                 w!(self, "ShallowInitBox(");
                 self.operand(op);
                 w!(self, ")");
-            }
+            },
             Rvalue::CopyForDeref(p) => {
                 w!(self, "CopyForDeref(");
                 self.place(p);
                 w!(self, ")");
-            }
+            },
             Rvalue::ThreadLocalRef(n)
             | Rvalue::AddressOf(n)
             | Rvalue::BinaryOp(n)
-            | Rvalue::NullaryOp(n) => match *n {},
+            | Rvalue::NullaryOp(n) => match *n {
+            },
         }
     }
 
         }
     }
 
-    fn hir_display<'b, T: HirDisplay<'db>>(&self, ty: &'b T) -> impl Display + use<'a, 'b, 'db, T>
+    fn hir_display<'b, T: HirDisplay<'db>>(
+        &self,
+        ty: &'b T,
+    ) -> impl Display + use<'a, 'b, 'db, T>
     where
         'db: 'b,
     {
-        ty.display_test(self.db, self.display_target)
-            .with_closure_style(ClosureStyle::ClosureWithSubst)
+        ty.display_test(self.db, self.display_target).with_closure_style(
+            ClosureStyle::ClosureWithSubst,
+        )
     }
 }