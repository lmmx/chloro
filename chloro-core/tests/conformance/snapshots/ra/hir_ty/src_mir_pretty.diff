COMPARISON DIFF
============================================================

Original size: 17858 bytes
Chloro size:   18069 bytes
Rustfmt size:  18799 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 use either::Either;
 use hir_def::{expr_store::Body, hir::BindingId};
-use hir_expand::{name::Name, Lookup};
+use hir_expand::{Lookup, name::Name};
 use la_arena::ArenaMap;
 
 use crate::{
     display::{ClosureStyle, DisplayTarget, HirDisplay},
     mir::{PlaceElem, ProjectionElem, StatementKind, TerminatorKind},
 };
-
 use super::{
     AggregateKind, BasicBlockId, BorrowKind, LocalId, MirBody, MutBorrowKind, Operand, OperandKind,
     Place, Rvalue, UnOp,
 }
 
 impl<'db> MirBody<'db> {
-    pub fn pretty_print(&self, db: &'db dyn HirDatabase, display_target: DisplayTarget) -> String {
+    pub fn pretty_print(
+        &self,
+        db: &'db dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
         let hir_body = db.body(self.owner);
         let mut ctx = MirPrettyCtx::new(self, &hir_body, db, display_target);
         ctx.for_body(|this| match ctx.body.owner {
             hir_def::DefWithBodyId::FunctionId(id) => {
                 let data = db.function_signature(id);
-                w!(
-                    this,
-                    "fn {}() ",
-                    data.name.display(db, this.display_target.edition)
-                );
+                w!(this, "fn {}() ", data.name.display(db, this.display_target.edition));
             }
             hir_def::DefWithBodyId::StaticId(id) => {
                 let data = db.static_signature(id);
-                w!(
-                    this,
-                    "static {}: _ = ",
-                    data.name.display(db, this.display_target.edition)
-                );
+                w!(this, "static {}: _ = ", data.name.display(db, this.display_target.edition));
             }
             hir_def::DefWithBodyId::ConstId(id) => {
                 let data = db.const_signature(id);
         ctx.result
     }
 
-    // String with lines is rendered poorly in `dbg` macros, which I use very much, so this
-    // function exists to solve that.
-    pub fn dbg(&self, db: &'db dyn HirDatabase, display_target: DisplayTarget) -> impl Debug {
+    pub fn dbg(
+        &self,
+        db: &'db dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> impl Debug {
         struct StringDbg(String);
         impl Debug for StringDbg {
             fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 }
 
 impl Write for MirPrettyCtx<'_, '_> {
-    fn write_str(&mut self, s: &str) -> std::fmt::Result {
-        let mut it = s.split('\n'); // note: `.lines()` is wrong here
+    fn write_str(
+        &mut self,
+        s: &str,
+    ) -> std::fmt::Result {
+        let mut it = s.split('\n');
+        // note: `.lines()` is wrong here
         self.write(it.next().unwrap_or_default());
         for line in it {
             self.write_line();
         match self {
             LocalName::Unknown(l) => write!(f, "_{}", u32::from(l.into_raw())),
             LocalName::Binding(n, l) => {
-                write!(
-                    f,
-                    "{}_{}",
-                    n.display(f.db, f.edition()),
-                    u32::from(l.into_raw())
-                )
+                write!(f, "{}_{}", n.display(f.db, f.edition()), u32::from(l.into_raw()))
             }
         }
     }
 }
 
 impl<'a, 'db> MirPrettyCtx<'a, 'db> {
-    fn for_body(&mut self, name: impl FnOnce(&mut MirPrettyCtx<'_, 'db>)) {
+    fn for_body(
+        &mut self,
+        name: impl FnOnce(&mut MirPrettyCtx<'_, 'db>),
+    ) {
         name(self);
         self.with_block(|this| {
             this.locals();
         }
     }
 
-    fn for_closure(&mut self, closure: InternedClosureId) {
+    fn for_closure(
+        &mut self,
+        closure: InternedClosureId,
+    ) {
         let body = match self.db.mir_body_for_closure(closure) {
             Ok(it) => it,
             Err(e) => {
         self.indent = ctx.indent;
     }
 
-    fn with_block(&mut self, f: impl FnOnce(&mut MirPrettyCtx<'_, 'db>)) {
+    fn with_block(
+        &mut self,
+        f: impl FnOnce(&mut MirPrettyCtx<'_, 'db>),
+    ) {
         self.indent += "    ";
         wln!(self, "{{");
         f(self);
         self.result += &self.indent;
     }
 
-    fn write(&mut self, line: &str) {
+    fn write(
+        &mut self,
+        line: &str,
+    ) {
         self.result += line;
     }
 
             wln!(
                 self,
                 "let {}: {};",
-                self.local_name(id)
-                    .display_test(self.db, self.display_target),
+                self.local_name(id).display_test(self.db, self.display_target),
                 self.hir_display(&local.ty)
             );
         }
     }
 
-    fn local_name(&self, local: LocalId<'db>) -> LocalName<'db> {
+    fn local_name(
+        &self,
+        local: LocalId<'db>,
+    ) -> LocalName<'db> {
         match self.local_to_binding.get(local) {
             Some(b) => LocalName::Binding(self.hir_body[*b].name.clone(), local),
             None => LocalName::Unknown(local),
         }
     }
 
-    fn basic_block_id(&self, basic_block_id: BasicBlockId<'db>) -> String {
+    fn basic_block_id(
+        &self,
+        basic_block_id: BasicBlockId<'db>,
+    ) -> String {
         format!("'bb{}", u32::from(basic_block_id.into_raw()))
     }
 
                             wln!(
                                 this,
                                 "StorageDead({})",
-                                this.local_name(*p)
-                                    .display_test(this.db, this.display_target)
+                                this.local_name(*p).display_test(this.db, this.display_target)
                             );
                         }
                         StatementKind::StorageLive(p) => {
                             wln!(
                                 this,
                                 "StorageLive({})",
-                                this.local_name(*p)
-                                    .display_test(this.db, this.display_target)
+                                this.local_name(*p).display_test(this.db, this.display_target)
                             );
                         }
                         StatementKind::Deinit(p) => {
                                 wln!(this, "_ => {},", this.basic_block_id(targets.otherwise()));
                             });
                         }
-                        TerminatorKind::Call {
-                            func,
-                            args,
-                            destination,
-                            target,
-                            ..
-                        } => {
+                        TerminatorKind::Call { func, args, destination, target, .. } => {
                             w!(this, "Call ");
                             this.with_block(|this| {
                                 w!(this, "func: ");
         }
     }
 
-    fn place(&mut self, p: &Place<'db>) {
+    fn place(
+        &mut self,
+        p: &Place<'db>,
+    ) {
         fn f<'db>(
             this: &mut MirPrettyCtx<'_, 'db>,
             local: LocalId<'db>,
         ) {
             let Some((last, head)) = projections.split_last() else {
                 // no projection
-                w!(
-                    this,
-                    "{}",
-                    this.local_name(local)
-                        .display_test(this.db, this.display_target)
-                );
+                w!(this, "{}", this.local_name(local).display_test(this.db, this.display_target));
                 return;
             };
             match last {
                         }
                         hir_def::VariantId::StructId(_) | hir_def::VariantId::UnionId(_) => {
                             f(this, local, head);
-                            w!(
-                                this,
-                                ".{}",
-                                name.display(this.db, this.display_target.edition)
-                            );
+                            w!(this, ".{}", name.display(this.db, this.display_target.edition));
                         }
                     }
                 }
                     w!(
                         this,
                         "[{}]",
-                        this.local_name(*l)
-                            .display_test(this.db, this.display_target)
+                        this.local_name(*l).display_test(this.db, this.display_target)
                     );
                 }
                 it => {
                 }
             }
         }
-        f(
-            self,
-            p.local,
-            p.projection.lookup(&self.body.projection_store),
-        );
+        f(self, p.local, p.projection.lookup(&self.body.projection_store));
     }
 
-    fn operand(&mut self, r: &Operand<'db>) {
+    fn operand(
+        &mut self,
+        r: &Operand<'db>,
+    ) {
         match &r.kind {
             OperandKind::Copy(p) | OperandKind::Move(p) => {
                 // MIR at the time of writing doesn't have difference between move and copy, so we show them
         }
     }
 
-    fn rvalue(&mut self, r: &Rvalue<'db>) {
+    fn rvalue(
+        &mut self,
+        r: &Rvalue<'db>,
+    ) {
         match r {
             Rvalue::Use(op) => self.operand(op),
             Rvalue::Ref(r, p) => {
                 match r {
                     BorrowKind::Shared => w!(self, "&"),
                     BorrowKind::Shallow => w!(self, "&shallow "),
-                    BorrowKind::Mut {
-                        kind: MutBorrowKind::ClosureCapture,
-                    } => w!(self, "&uniq "),
+                    BorrowKind::Mut { kind: MutBorrowKind::ClosureCapture } => w!(self, "&uniq "),
                     BorrowKind::Mut {
                         kind: MutBorrowKind::Default | MutBorrowKind::TwoPhasedBorrow,
                     } => w!(self, "&mut "),
             Rvalue::Repeat(op, len) => {
                 w!(self, "[");
                 self.operand(op);
-                w!(
-                    self,
-                    "; {}]",
-                    len.display_test(self.db, self.display_target)
-                );
+                w!(self, "; {}]", len.display_test(self.db, self.display_target));
             }
             Rvalue::Aggregate(AggregateKind::Adt(_, _), it) => {
                 w!(self, "Adt(");
         }
     }
 
-    fn operand_list(&mut self, it: &[Operand<'db>]) {
+    fn operand_list(
+        &mut self,
+        it: &[Operand<'db>],
+    ) {
         let mut it = it.iter();
         if let Some(first) = it.next() {
             self.operand(first);
         }
     }
 
-    fn hir_display<'b, T: HirDisplay<'db>>(&self, ty: &'b T) -> impl Display + use<'a, 'b, 'db, T>
+    fn hir_display<'b, T: HirDisplay<'db>>(
+        &self,
+        ty: &'b T,
+    ) -> impl Display + use<'a, 'b, 'db, T>
     where
-        'db: 'b,
-    {
+        'db: 'b, {
         ty.display_test(self.db, self.display_target)
             .with_closure_style(ClosureStyle::ClosureWithSubst)
     }