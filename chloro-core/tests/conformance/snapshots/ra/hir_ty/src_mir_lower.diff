COMPARISON DIFF
============================================================

Original size: 95826 bytes
Chloro size:   95955 bytes
Rustfmt size:  95826 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     ItemContainerId, LocalFieldId, Lookup, TraitId, TupleId,
     expr_store::{Body, ExpressionStore, HygieneId, path::Path},
     hir::{
-        ArithOp, Array, BinaryOp, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm,
-        Pat, PatId, RecordFieldPat, RecordLitField,
+        ArithOp, Array, BinaryOp, BindingAnnotation, BindingId, ExprId, LabelId, Literal,
+        MatchArm, Pat, PatId, RecordFieldPat, RecordLitField,
     },
     item_tree::FieldsShape,
     lang_item::{LangItem, LangItemTarget, lang_item},
     infcx: InferCtxt<'db>,
 }
 
-// FIXME: Make this smaller, its stored in database queries
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum MirLowerError<'db> {
     ConstEvalError(Box<str>, Box<ConstEvalError<'db>>),
 
 /// A token to ensuring that each drop scope is popped at most once, thanks to the compiler that checks moves.
 struct DropScopeToken;
+
 impl DropScopeToken {
     fn pop_and_drop<'db>(
         self,
 //         never!("Drop scope doesn't popped");
 //     }
 // }
-
 impl MirLowerError<'_> {
     pub fn pretty_print(
         &self,
         let Some((p, current)) = self.lower_expr_as_place(current, expr_id, true)? else {
             return Ok(None);
         };
-        Ok(Some((Operand { kind: OperandKind::Copy(p), span: Some(expr_id.into()) }, current)))
+        Ok(Some((
+            Operand {
+            kind: OperandKind::Copy(p),
+            span: Some(expr_id.into()),
+        },
+            current,
+        )))
     }
 
     fn lower_expr_to_place_with_adjust(
                         Ok(Some(current))
                     }
                     ValueNs::EnumVariantId(variant_id) => {
+                        // Otherwise its a tuple like enum, treated like a zero sized function, so no action is needed
                         let variant_fields = variant_id.fields(self.db);
                         if variant_fields.shape == FieldsShape::Unit {
                             let ty = self.infer.type_of_expr[expr_id];
                                 expr_id.into(),
                             )?;
                         }
-                        // Otherwise its a tuple like enum, treated like a zero sized function, so no action is needed
                         Ok(Some(current))
                     }
                     ValueNs::GenericParam(p) => {
             }
             Expr::Block { id: _, statements, tail, label } => {
                 if let Some(label) = label {
-                    self.lower_loop(current, place, Some(*label), expr_id.into(), |this, begin| {
+                    self.lower_loop(
+                        current,
+                        place,
+                        Some(*label),
+                        expr_id.into(),
+                        |this, begin| {
                         if let Some(current) = this.lower_block_to_place(
                             statements,
                             begin,
                             this.set_goto(current, end, expr_id.into());
                         }
                         Ok(())
-                    })
+                    },
+                    )
                 } else {
                     self.lower_block_to_place(statements, current, *tail, place, expr_id.into())
                 }
             }
             Expr::Loop { body, label } => {
-                self.lower_loop(current, place, *label, expr_id.into(), |this, begin| {
+                self.lower_loop(
+                    current,
+                    place,
+                    *label,
+                    expr_id.into(),
+                    |this, begin| {
                     let scope = this.push_drop_scope();
                     if let Some((_, mut current)) = this.lower_expr_as_place(begin, *body, true)? {
                         current = scope.pop_and_drop(this, current, body.into());
                         scope.pop_assume_dropped(this);
                     }
                     Ok(())
-                })
+                },
+                )
             }
             Expr::Call { callee, args, .. } => {
                 if let Some((func_id, generic_args)) = self.infer.method_resolution(expr_id) {
                 not_supported!("const block")
             }
             Expr::Cast { expr, type_ref: _ } => {
+                // Since we don't have THIR, this is the "zipped" version of [rustc's HIR lowering](https://github.com/rust-lang/rust/blob/e71f9529121ca8f687e4b725e3c9adc3f1ebab4d/compiler/rustc_mir_build/src/thir/cx/expr.rs#L165-L178)
+                // and [THIR lowering as RValue](https://github.com/rust-lang/rust/blob/a4601859ae3875732797873612d424976d9e3dd0/compiler/rustc_mir_build/src/build/expr/as_rvalue.rs#L193-L313)
                 let Some((it, current)) = self.lower_expr_to_some_operand(*expr, current)? else {
                     return Ok(None);
                 };
-                // Since we don't have THIR, this is the "zipped" version of [rustc's HIR lowering](https://github.com/rust-lang/rust/blob/e71f9529121ca8f687e4b725e3c9adc3f1ebab4d/compiler/rustc_mir_build/src/thir/cx/expr.rs#L165-L178)
-                // and [THIR lowering as RValue](https://github.com/rust-lang/rust/blob/a4601859ae3875732797873612d424976d9e3dd0/compiler/rustc_mir_build/src/build/expr/as_rvalue.rs#L193-L313)
                 let rvalue = if self.infer.coercion_casts.contains(expr) {
                     Rvalue::Use(it)
                 } else {
             })
             .unwrap()
             .instantiate(self.interner(), subst);
-        Ok(Operand { kind: OperandKind::Constant { konst, ty }, span: None })
+        Ok(Operand {
+            kind: OperandKind::Constant { konst, ty },
+            span: None,
+        })
     }
 
     fn write_bytes_to_place(
     owner: DefWithBodyId,
     body: &Body,
     infer: &InferenceResult<'db>,
-    // FIXME: root_expr should always be the body.body_expr, but since `X` in `[(); X]` doesn't have its own specific body yet, we
-    // need to take this input explicitly.
     root_expr: ExprId,
 ) -> Result<'db, MirBody<'db>> {
     if infer.type_mismatches().next().is_some() || infer.is_erroneous() {