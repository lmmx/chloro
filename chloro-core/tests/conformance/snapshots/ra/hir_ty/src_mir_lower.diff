COMPARISON DIFF
============================================================

Original size: 95826 bytes
Chloro size:   95505 bytes
Rustfmt size:  95826 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     },
     traits::FnTrait,
 };
-
 use super::OperandKind;
 
 mod as_place;
+
 mod pattern_matching;
+
 #[cfg(test)]
 mod tests;
 
     infcx: InferCtxt<'db>,
 }
 
-// FIXME: Make this smaller, its stored in database queries
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum MirLowerError<'db> {
     ConstEvalError(Box<str>, Box<ConstEvalError<'db>>),
     UnresolvedLabel,
     UnresolvedUpvar(Place<'db>),
     InaccessibleLocal,
-
-    // monomorphization errors:
     GenericArgNotProvided(GenericParamId, GenericArgs<'db>),
 }
 
 /// A token to ensuring that each drop scope is popped at most once, thanks to the compiler that checks moves.
 struct DropScopeToken;
+
 impl DropScopeToken {
     fn pop_and_drop<'db>(
         self,
     /// code. Either when the control flow is diverging (so drop code doesn't reached) or when drop is handled
     /// for us (for example a block that ended with a return statement. Return will drop everything, so the block shouldn't
     /// do anything)
-    fn pop_assume_dropped(self, ctx: &mut MirLowerCtx<'_, '_>) {
+    fn pop_assume_dropped(
+        self,
+        ctx: &mut MirLowerCtx<'_, '_>,
+    ) {
         std::mem::forget(self);
         ctx.pop_drop_scope_assume_dropped_internal();
     }
 }
 
 impl Drop for DropScopeToken {
-    fn drop(&mut self) {}
+    fn drop(&mut self) {
+    }
 }
 
-// Uncomment this to make `DropScopeToken` a drop bomb. Unfortunately we can't do this in release, since
-// in cases that mir lowering fails, we don't handle (and don't need to handle) drop scopes so it will be
-// actually reached. `pop_drop_scope_assert_finished` will also detect this case, but doesn't show useful
-// stack trace.
-//
-// impl Drop for DropScopeToken {
-//     fn drop(&mut self) {
-//         never!("Drop scope doesn't popped");
-//     }
-// }
-
 impl MirLowerError<'_> {
     pub fn pretty_print(
         &self,
         let interner = DbInterner::new_with(db, Some(env.krate), env.block);
         // FIXME(next-solver): Is `non_body_analysis()` correct here? Don't we want to reveal opaque types defined by this body?
         let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
-
         MirLowerCtx {
             result: mir,
             db,
         }
     }
 
-    fn lower_literal_to_operand(&mut self, ty: Ty<'db>, l: &Literal) -> Result<'db, Operand<'db>> {
+    fn lower_literal_to_operand(
+        &mut self,
+        ty: Ty<'db>,
+        l: &Literal,
+    ) -> Result<'db, Operand<'db>> {
         let size = || self.db.layout_of_ty(ty, self.env.clone()).map(|it| it.size.bytes_usize());
         const USIZE_SIZE: usize = size_of::<usize>();
         let bytes: Box<[_]> = match l {
         Ok(b)
     }
 
-    fn is_unterminated(&mut self, source: BasicBlockId<'db>) -> bool {
+    fn is_unterminated(
+        &mut self,
+        source: BasicBlockId<'db>,
+    ) -> bool {
         self.result.basic_blocks[source].terminator.is_none()
     }
 
         self.result.basic_blocks[source].terminator = Some(Terminator { span, kind: terminator });
     }
 
-    fn set_goto(&mut self, source: BasicBlockId<'db>, target: BasicBlockId<'db>, span: MirSpan) {
+    fn set_goto(
+        &mut self,
+        source: BasicBlockId<'db>,
+        target: BasicBlockId<'db>,
+        span: MirSpan,
+    ) {
         self.set_terminator(source, TerminatorKind::Goto { target }, span);
     }
 
-    fn expr_ty_without_adjust(&self, e: ExprId) -> Ty<'db> {
+    fn expr_ty_without_adjust(
+        &self,
+        e: ExprId,
+    ) -> Ty<'db> {
         self.infer[e]
     }
 
-    fn expr_ty_after_adjustments(&self, e: ExprId) -> Ty<'db> {
+    fn expr_ty_after_adjustments(
+        &self,
+        e: ExprId,
+    ) -> Ty<'db> {
         let mut ty = None;
         if let Some(it) = self.infer.expr_adjustments.get(&e)
             && let Some(it) = it.last()
         ty.unwrap_or_else(|| self.expr_ty_without_adjust(e))
     }
 
-    fn push_statement(&mut self, block: BasicBlockId<'db>, statement: Statement<'db>) {
+    fn push_statement(
+        &mut self,
+        block: BasicBlockId<'db>,
+        statement: Statement<'db>,
+    ) {
         self.result.basic_blocks[block].statements.push(statement);
     }
 
-    fn push_fake_read(&mut self, block: BasicBlockId<'db>, p: Place<'db>, span: MirSpan) {
+    fn push_fake_read(
+        &mut self,
+        block: BasicBlockId<'db>,
+        p: Place<'db>,
+        span: MirSpan,
+    ) {
         self.push_statement(block, StatementKind::FakeRead(p).with_span(span));
     }
 
         self.push_statement(block, StatementKind::Assign(place, rvalue).with_span(span));
     }
 
-    fn discr_temp_place(&mut self, current: BasicBlockId<'db>) -> Place<'db> {
+    fn discr_temp_place(
+        &mut self,
+        current: BasicBlockId<'db>,
+    ) -> Place<'db> {
         match &self.discr_temp {
             Some(it) => *it,
             None => {
         Ok(my.end)
     }
 
-    fn has_adjustments(&self, expr_id: ExprId) -> bool {
+    fn has_adjustments(
+        &self,
+        expr_id: ExprId,
+    ) -> bool {
         !self.infer.expr_adjustments.get(&expr_id).map(|it| it.is_empty()).unwrap_or(true)
     }
 
         Ok(r)
     }
 
-    fn is_uninhabited(&self, expr_id: ExprId) -> bool {
+    fn is_uninhabited(
+        &self,
+        expr_id: ExprId,
+    ) -> bool {
         is_ty_uninhabited_from(
             &self.infcx,
             self.infer[expr_id],
 
     /// This function push `StorageLive` statement for the binding, and applies changes to add `StorageDead` and
     /// `Drop` in the appropriated places.
-    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId<'db>) -> Result<'db, ()> {
+    fn push_storage_live(
+        &mut self,
+        b: BindingId,
+        current: BasicBlockId<'db>,
+    ) -> Result<'db, ()> {
         let l = self.binding_local(b)?;
         self.push_storage_live_for_local(l, current, MirSpan::BindingId(b))
     }
         Ok(())
     }
 
-    fn resolve_lang_item(&self, item: LangItem) -> Result<'db, LangItemTarget> {
+    fn resolve_lang_item(
+        &self,
+        item: LangItem,
+    ) -> Result<'db, LangItemTarget> {
         let crate_id = self.owner.module(self.db).krate();
         lang_item(self.db, crate_id, item).ok_or(MirLowerError::LangItemNotFound(item))
     }
         Ok(current)
     }
 
-    fn binding_local(&self, b: BindingId) -> Result<'db, LocalId<'db>> {
+    fn binding_local(
+        &self,
+        b: BindingId,
+    ) -> Result<'db, LocalId<'db>> {
         match self.result.binding_locals.get(b) {
             Some(it) => Ok(*it),
             None => {
         }
     }
 
-    fn const_eval_discriminant(&self, variant: EnumVariantId) -> Result<'db, i128> {
+    fn const_eval_discriminant(
+        &self,
+        variant: EnumVariantId,
+    ) -> Result<'db, i128> {
         let r = self.db.const_eval_discriminant(variant);
         match r {
             Ok(r) => Ok(r),
     owner: DefWithBodyId,
     body: &Body,
     infer: &InferenceResult<'db>,
-    // FIXME: root_expr should always be the body.body_expr, but since `X` in `[(); X]` doesn't have its own specific body yet, we
-    // need to take this input explicitly.
     root_expr: ExprId,
 ) -> Result<'db, MirBody<'db>> {
     if infer.type_mismatches().next().is_some() || infer.is_erroneous() {