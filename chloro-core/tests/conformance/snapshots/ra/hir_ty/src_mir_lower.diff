COMPARISON DIFF
============================================================

Original size: 95826 bytes
Chloro size:   95680 bytes
Rustfmt size:  95826 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module generates a polymorphic MIR from a hir body
 
+mod as_place;
+mod pattern_matching;
+#[cfg(test)]
+mod tests;
+
 use std::{fmt::Write, iter, mem};
 
 use base_db::Crate;
 use hir_def::{
-    AdtId, DefWithBodyId, EnumVariantId, GeneralConstId, GenericParamId, HasModule,
-    ItemContainerId, LocalFieldId, Lookup, TraitId, TupleId,
-    expr_store::{Body, ExpressionStore, HygieneId, path::Path},
+    expr_store::{path::Path, Body, ExpressionStore, HygieneId},
     hir::{
-        ArithOp, Array, BinaryOp, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm,
-        Pat, PatId, RecordFieldPat, RecordLitField,
+        ArithOp, Array, BinaryOp, BindingAnnotation, BindingId, ExprId, LabelId, Literal,
+        MatchArm, Pat, PatId, RecordFieldPat, RecordLitField,
     },
     item_tree::FieldsShape,
-    lang_item::{LangItem, LangItemTarget, lang_item},
+    lang_item::{lang_item, LangItem, LangItemTarget},
     resolver::{HasResolver, ResolveValueResult, Resolver, ValueNs},
+    AdtId, DefWithBodyId, EnumVariantId, GeneralConstId, GenericParamId, HasModule,
+    ItemContainerId, LocalFieldId, Lookup, TraitId, TupleId,
 };
 use hir_expand::name::Name;
 use la_arena::ArenaMap;
 use triomphe::Arc;
 
 use crate::{
-    Adjust, Adjustment, AutoBorrow, CallableDefId, TraitEnvironment,
     consteval::ConstEvalError,
     db::{HirDatabase, InternedClosure, InternedClosureId},
-    display::{DisplayTarget, HirDisplay, hir_display_with_store},
+    display::{hir_display_with_store, DisplayTarget, HirDisplay},
     generics::generics,
-    infer::{CaptureKind, CapturedItem, TypeMismatch, cast::CastTy},
+    infer::{cast::CastTy, CaptureKind, CapturedItem, TypeMismatch},
     inhabitedness::is_ty_uninhabited_from,
     layout::LayoutError,
     mir::{
-        AggregateKind, Arena, BasicBlock, BasicBlockId, BinOp, BorrowKind, CastKind, Either, Expr,
-        FieldId, GenericArgs, Idx, InferenceResult, Local, LocalId, MemoryMap, MirBody, MirSpan,
-        Mutability, Operand, Place, PlaceElem, PointerCast, ProjectionElem, ProjectionStore,
-        RawIdx, Rvalue, Statement, StatementKind, SwitchTargets, Terminator, TerminatorKind,
-        TupleFieldId, Ty, UnOp, VariantId, return_slot,
+        return_slot, AggregateKind, Arena, BasicBlock, BasicBlockId, BinOp, BorrowKind, CastKind,
+        Either, Expr, FieldId, GenericArgs, Idx, InferenceResult, Local, LocalId, MemoryMap,
+        MirBody, MirSpan, Mutability, Operand, Place, PlaceElem, PointerCast, ProjectionElem,
+        ProjectionStore, RawIdx, Rvalue, Statement, StatementKind, SwitchTargets, Terminator,
+        TerminatorKind, TupleFieldId, Ty, UnOp, VariantId,
     },
     next_solver::{
-        Const, DbInterner, ParamConst, Region, TyKind, TypingMode, UnevaluatedConst,
-        infer::{DbInternerInferExt, InferCtxt},
+        infer::{DbInternerInferExt, InferCtxt}, Const, DbInterner, ParamConst, Region, TyKind,
+        TypingMode, UnevaluatedConst,
     },
     traits::FnTrait,
+    Adjust, Adjustment, AutoBorrow, CallableDefId, TraitEnvironment,
 };
-
 use super::OperandKind;
 
-mod as_place;
-mod pattern_matching;
-#[cfg(test)]
-mod tests;
-
 #[derive(Debug, Clone)]
 struct LoopBlocks<'db> {
     begin: BasicBlockId<'db>,
     infcx: InferCtxt<'db>,
 }
 
-// FIXME: Make this smaller, its stored in database queries
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum MirLowerError<'db> {
     ConstEvalError(Box<str>, Box<ConstEvalError<'db>>),
 
 /// A token to ensuring that each drop scope is popped at most once, thanks to the compiler that checks moves.
 struct DropScopeToken;
+
 impl DropScopeToken {
     fn pop_and_drop<'db>(
         self,
 }
 
 impl Drop for DropScopeToken {
-    fn drop(&mut self) {}
+    fn drop(&mut self) {
+    }
 }
 
 // Uncomment this to make `DropScopeToken` a drop bomb. Unfortunately we can't do this in release, since
-// in cases that mir lowering fails, we don't handle (and don't need to handle) drop scopes so it will be
-// actually reached. `pop_drop_scope_assert_finished` will also detect this case, but doesn't show useful
-// stack trace.
-//
-// impl Drop for DropScopeToken {
-//     fn drop(&mut self) {
-//         never!("Drop scope doesn't popped");
-//     }
-// }
 
+// in cases that mir lowering fails, we don't handle (and don't need to handle) drop scopes so it will be
+
+// actually reached. `pop_drop_scope_assert_finished` will also detect this case, but doesn't show useful
+
+// stack trace.
+
+//
+
+// impl Drop for DropScopeToken {
+
+//     fn drop(&mut self) {
+
+//         never!("Drop scope doesn't popped");
+
+//     }
+
+// }
 impl MirLowerError<'_> {
     pub fn pretty_print(
         &self,
         infer: &'a InferenceResult<'db>,
     ) -> Self {
         let mut basic_blocks = Arena::new();
-        let start_block = basic_blocks.alloc(BasicBlock {
+        let start_block = basic_blocks
+            .alloc(BasicBlock {
             statements: vec![],
             terminator: None,
             is_cleanup: false,
             TyKind::Adt(_, subst) => subst,
             _ => implementation_error!("Non ADT enum"),
         };
-        self.push_assignment(
+        self
+            .push_assignment(
             prev_block,
             place,
             Rvalue::Aggregate(AggregateKind::Adt(variant_id.into(), subst), fields),
         span: MirSpan,
     ) -> Result<'db, Option<BasicBlockId<'db>>> {
         let b = if is_uninhabited { None } else { Some(self.new_basic_block()) };
-        self.set_terminator(
+        self
+            .set_terminator(
             current,
             TerminatorKind::Call {
                 func,
         f: impl FnOnce(&mut MirLowerCtx<'_, 'db>, BasicBlockId<'db>) -> Result<'db, ()>,
     ) -> Result<'db, Option<BasicBlockId<'db>>> {
         let begin = self.new_basic_block();
-        let prev = self.current_loop_blocks.replace(LoopBlocks {
+        let prev = self.current_loop_blocks
+            .replace(LoopBlocks {
             begin,
             end: None,
             place,
             }
             None => None,
         };
-        self.result.param_locals.extend(params.clone().map(|(it, ty)| {
+        self.result.param_locals
+            .extend(params.clone().map(|(it, ty)| {
             let local_id = self.result.locals.alloc(Local { ty });
             self.drop_scopes.last_mut().unwrap().locals.push(local_id);
             if let Pat::Bind { id, subpat: None } = self.body[it]
     let mut ctx = MirLowerCtx::new(db, owner, &body, &infer);
     // 0 is return local
     ctx.result.locals.alloc(Local { ty: infer[*root] });
-    let closure_local = ctx.result.locals.alloc(Local {
+    let closure_local = ctx.result.locals
+        .alloc(Local {
         ty: match kind {
             FnTrait::FnOnce | FnTrait::AsyncFnOnce => infer[expr],
             FnTrait::FnMut | FnTrait::AsyncFnMut => Ty::new_ref(
         let current = ctx.pop_drop_scope_assert_finished(current, root.into())?;
         ctx.set_terminator(current, TerminatorKind::Return, (*root).into());
     }
-    let mut upvar_map: FxHashMap<LocalId<'db>, Vec<(&CapturedItem<'_>, usize)>> =
-        FxHashMap::default();
+    let mut upvar_map: FxHashMap<LocalId<'db>, Vec<(&CapturedItem<'_>, usize)>> = FxHashMap::default();
     for (i, capture) in captures.iter().enumerate() {
         let local = ctx.binding_local(capture.place.local)?;
         upvar_map.entry(local).or_default().push((capture, i));
             vec![ProjectionElem::Deref]
         }
     };
-    ctx.result.walk_places(|p, store| {
+    ctx.result
+        .walk_places(|p, store| {
         if let Some(it) = upvar_map.get(&p.local) {
             let r = it.iter().find(|it| {
                 if p.projection.lookup(store).len() < it.0.place.projections.len() {
     owner: DefWithBodyId,
     body: &Body,
     infer: &InferenceResult<'db>,
-    // FIXME: root_expr should always be the body.body_expr, but since `X` in `[(); X]` doesn't have its own specific body yet, we
-    // need to take this input explicitly.
     root_expr: ExprId,
 ) -> Result<'db, MirBody<'db>> {
     if infer.type_mismatches().next().is_some() || infer.is_erroneous() {