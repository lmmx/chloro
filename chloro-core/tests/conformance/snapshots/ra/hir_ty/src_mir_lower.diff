COMPARISON DIFF
============================================================

Original size: 95826 bytes
Chloro size:   95102 bytes
Rustfmt size:  95826 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module generates a polymorphic MIR from a hir body
 
+mod as_place;
+mod pattern_matching;
+#[cfg(test)]
+mod tests;
+
 use std::{fmt::Write, iter, mem};
 
 use base_db::Crate;
 use hir_def::{
-    AdtId, DefWithBodyId, EnumVariantId, GeneralConstId, GenericParamId, HasModule,
-    ItemContainerId, LocalFieldId, Lookup, TraitId, TupleId,
     expr_store::{Body, ExpressionStore, HygieneId, path::Path},
     hir::{
         ArithOp, Array, BinaryOp, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm,
     item_tree::FieldsShape,
     lang_item::{LangItem, LangItemTarget, lang_item},
     resolver::{HasResolver, ResolveValueResult, Resolver, ValueNs},
+    AdtId, DefWithBodyId, EnumVariantId, GeneralConstId, GenericParamId, HasModule, ItemContainerId,
+    LocalFieldId, Lookup, TraitId, TupleId,
 };
 use hir_expand::name::Name;
 use la_arena::ArenaMap;
 use triomphe::Arc;
 
 use crate::{
-    Adjust, Adjustment, AutoBorrow, CallableDefId, TraitEnvironment,
     consteval::ConstEvalError,
     db::{HirDatabase, InternedClosure, InternedClosureId},
     display::{DisplayTarget, HirDisplay, hir_display_with_store},
         infer::{DbInternerInferExt, InferCtxt},
     },
     traits::FnTrait,
+    Adjust, Adjustment, AutoBorrow, CallableDefId, TraitEnvironment,
 };
-
 use super::OperandKind;
 
-mod as_place;
-mod pattern_matching;
-#[cfg(test)]
-mod tests;
-
 #[derive(Debug, Clone)]
 struct LoopBlocks<'db> {
     begin: BasicBlockId<'db>,
     infcx: InferCtxt<'db>,
 }
 
-// FIXME: Make this smaller, its stored in database queries
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum MirLowerError<'db> {
     ConstEvalError(Box<str>, Box<ConstEvalError<'db>>),
     UnresolvedLabel,
     UnresolvedUpvar(Place<'db>),
     InaccessibleLocal,
-
-    // monomorphization errors:
     GenericArgNotProvided(GenericParamId, GenericArgs<'db>),
 }
 
 /// A token to ensuring that each drop scope is popped at most once, thanks to the compiler that checks moves.
 struct DropScopeToken;
+
 impl DropScopeToken {
     fn pop_and_drop<'db>(
         self,
 }
 
 impl Drop for DropScopeToken {
-    fn drop(&mut self) {}
+    fn drop(&mut self) {
+    }
 }
 
-// Uncomment this to make `DropScopeToken` a drop bomb. Unfortunately we can't do this in release, since
-// in cases that mir lowering fails, we don't handle (and don't need to handle) drop scopes so it will be
-// actually reached. `pop_drop_scope_assert_finished` will also detect this case, but doesn't show useful
-// stack trace.
-//
-// impl Drop for DropScopeToken {
-//     fn drop(&mut self) {
-//         never!("Drop scope doesn't popped");
-//     }
-// }
-
 impl MirLowerError<'_> {
     pub fn pretty_print(
         &self,
         let interner = DbInterner::new_with(db, Some(env.krate), env.block);
         // FIXME(next-solver): Is `non_body_analysis()` correct here? Don't we want to reveal opaque types defined by this body?
         let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
-
         MirLowerCtx {
             result: mir,
             db,
     owner: DefWithBodyId,
     body: &Body,
     infer: &InferenceResult<'db>,
-    // FIXME: root_expr should always be the body.body_expr, but since `X` in `[(); X]` doesn't have its own specific body yet, we
-    // need to take this input explicitly.
     root_expr: ExprId,
 ) -> Result<'db, MirBody<'db>> {
     if infer.type_mismatches().next().is_some() || infer.is_erroneous() {