COMPARISON DIFF
============================================================

Original size: 69401 bytes
Chloro size:   67998 bytes
Rustfmt size:  69401 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Interpret intrinsics, lang items and `extern "C"` wellknown functions which their implementation
 //! is not available.
 //!
+
+mod simd;
+
 use std::cmp::{self, Ordering};
 
-use hir_def::{CrateRootModuleId, resolver::HasResolver, signatures::FunctionSignature};
+use hir_def::{resolver::HasResolver, signatures::FunctionSignature, CrateRootModuleId};
 use hir_expand::name::Name;
-use intern::{Symbol, sym};
+use intern::{sym, Symbol};
 use rustc_type_ir::inherent::{AdtDef, IntoKind, SliceLike, Ty as _};
 use stdx::never;
 
 use crate::{
     display::DisplayTarget,
-    drop::{DropGlue, has_drop_glue},
+    drop::{has_drop_glue, DropGlue},
     mir::eval::{
-        Address, AdtId, Arc, Evaluator, FunctionId, GenericArgs, HasModule, HirDisplay,
+        pad16, Address, AdtId, Arc, Evaluator, FunctionId, GenericArgs, HasModule, HirDisplay,
         InternedClosure, Interval, IntervalAndTy, IntervalOrOwned, ItemContainerId, LangItem,
-        Layout, Locals, Lookup, MirEvalError, MirSpan, Mutability, Result, Ty, TyKind, pad16,
+        Layout, Locals, Lookup, MirEvalError, MirSpan, Mutability, Result, Ty, TyKind,
     },
     next_solver::Region,
 };
 
-mod simd;
-
 macro_rules! from_bytes {
     ($ty:tt, $value:expr) => {
         ($ty::from_le_bytes(match ($value).try_into() {
     ) -> Result<'db, ()> {
         match id {
             318 => {
-                // SYS_getrandom
                 let [buf, len, _flags] = args else {
                     return Err(MirEvalError::InternalError(
                         "SYS_getrandom args are not provided".into(),
                     self.size_of_sized(key_ty, locals, "pthread_key_create key arg")?,
                 );
                 arg0_interval.write_from_bytes(self, &key.to_le_bytes()[0..arg0_interval.size])?;
-                // return 0 as success
                 destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;
                 Ok(())
             }
                 };
                 let value = from_bytes!(u128, pad16(arg1.get(self)?, false));
                 self.thread_local_storage.set_key(key, value)?;
-                // return 0 as success
                 destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;
                 Ok(())
             }
             "pthread_key_delete" => {
-                // we ignore this currently
-                // return 0 as success
                 destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;
                 Ok(())
             }
                     ));
                 };
                 let set = Address::from_bytes(set.get(self)?)?;
-                // Only enable core 0 (we are single threaded anyway), which is bitset 0x0000001
                 self.write_memory(set, &[1])?;
-                // return 0 as success
                 self.write_memory_using_ref(destination.addr, destination.size)?.fill(0);
                 Ok(())
             }
                 let size = self.size_of_sized(ty, locals, "size_of arg")?;
                 destination.write_from_bytes(self, &size.to_le_bytes()[0..destination.size])
             }
-            // FIXME: `min_align_of` was renamed to `align_of` in Rust 1.89
-            // (https://github.com/rust-lang/rust/pull/142410)
             "min_align_of" | "align_of" => {
                 let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
                     return Err(MirEvalError::InternalError(
                     destination.write_from_bytes(self, &size.to_le_bytes())
                 }
             }
-            // FIXME: `min_align_of_val` was renamed to `align_of_val` in Rust 1.89
-            // (https://github.com/rust-lang/rust/pull/142410)
             "min_align_of_val" | "align_of_val" => {
                 let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
                     return Err(MirEvalError::InternalError(
                 destination.write_from_bytes(self, &[u8::from(result)])
             }
             "ptr_guaranteed_cmp" => {
-                // FIXME: this is wrong for const eval, it should return 2 in some
-                // cases.
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "wrapping_add args are not provided".into(),
                     _ => unreachable!(),
                 };
                 let bits = destination.size * 8;
-                // FIXME: signed
                 let is_signed = false;
                 let mx: u128 = if is_signed { (1 << (bits - 1)) - 1 } else { (1 << bits) - 1 };
-                // FIXME: signed
                 let mn: u128 = 0;
                 let ans = cmp::min(mx, cmp::max(mn, ans));
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
             }
             "wrapping_shl" | "unchecked_shl" => {
-                // FIXME: signed
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "unchecked_shl args are not provided".into(),
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
             }
             "wrapping_shr" | "unchecked_shr" => {
-                // FIXME: signed
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "unchecked_shr args are not provided".into(),
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
             }
             "unchecked_rem" => {
-                // FIXME: signed
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "unchecked_rem args are not provided".into(),
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
             }
             "unchecked_div" | "exact_div" => {
-                // FIXME: signed
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "unchecked_div args are not provided".into(),
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
             }
             "assert_inhabited" | "assert_zero_valid" | "assert_uninit_valid" | "assume" => {
-                // FIXME: We should actually implement these checks
                 Ok(())
             }
             "forget" => {
-                // We don't call any drop glue yet, so there is nothing here
                 Ok(())
             }
             "transmute" | "transmute_unchecked" => {
                     return Err(MirEvalError::InternalError("ctpop arg is not provided".into()));
                 };
                 let result = u128::from_le_bytes(pad16(arg.get(self)?, false)).count_ones();
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
             }
             "ctlz" | "ctlz_nonzero" => {
                 let [arg] = args else {
                 let result =
                     u128::from_le_bytes(pad16(arg.get(self)?, false)).leading_zeros() as usize;
                 let result = result - (128 - arg.interval.size * 8);
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
             }
             "cttz" | "cttz_nonzero" => {
                 let [arg] = args else {
                     return Err(MirEvalError::InternalError("cttz arg is not provided".into()));
                 };
                 let result = u128::from_le_bytes(pad16(arg.get(self)?, false)).trailing_zeros();
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
             }
             "rotate_left" => {
                 let [lhs, rhs] = args else {
             }
             _ if needs_override => not_supported!("intrinsic {name} is not implemented"),
             _ => return Ok(false),
-        }
-        .map(|()| true)
+        }.map(
+            |()| true,
+        )
     }
 
     fn size_align_of_unsized(
                     self.size_align_of_unsized(last_field_ty, metadata, locals)?;
                 let align = sized_part_align.max(unsized_part_align) as isize;
                 let size = (sized_part_size + unsized_part_size) as isize;
-                // Must add any necessary padding to `size`
-                // (to make it a multiple of `align`) before returning it.
-                //
-                // Namely, the returned size should be, in C notation:
-                //
-                //   `size + ((size & (align-1)) ? align : 0)`
-                //
-                // emulated via the semi-standard fast bit trick:
-                //
-                //   `(size + (align-1)) & -align`
                 let size = (size + (align - 1)) & (-align);
                 (size as usize, align as usize)
             }
     ) -> Result<'db, ()> {
         // We are a single threaded runtime with no UB checking and no optimization, so
         // we can implement atomic intrinsics as normal functions.
-
         if name.starts_with("singlethreadfence_") || name.starts_with("fence_") {
             return Ok(());
         }
 
         // The rest of atomic intrinsics have exactly one generic arg
-
         let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
             return Err(MirEvalError::InternalError(
                 "atomic intrinsic generic arg is not provided".into(),