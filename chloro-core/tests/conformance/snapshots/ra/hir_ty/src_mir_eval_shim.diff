COMPARISON DIFF
============================================================

Original size: 69401 bytes
Chloro size:   69528 bytes
Rustfmt size:  69401 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Interpret intrinsics, lang items and `extern "C"` wellknown functions which their implementation
 //! is not available.
 //!
+
 use std::cmp::{self, Ordering};
 
 use hir_def::{CrateRootModuleId, resolver::HasResolver, signatures::FunctionSignature};
                     return Err(MirEvalError::InternalError("ctpop arg is not provided".into()));
                 };
                 let result = u128::from_le_bytes(pad16(arg.get(self)?, false)).count_ones();
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
             }
             "ctlz" | "ctlz_nonzero" => {
                 let [arg] = args else {
                 let result =
                     u128::from_le_bytes(pad16(arg.get(self)?, false)).leading_zeros() as usize;
                 let result = result - (128 - arg.interval.size * 8);
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
             }
             "cttz" | "cttz_nonzero" => {
                 let [arg] = args else {
                     return Err(MirEvalError::InternalError("cttz arg is not provided".into()));
                 };
                 let result = u128::from_le_bytes(pad16(arg.get(self)?, false)).trailing_zeros();
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
             }
             "rotate_left" => {
                 let [lhs, rhs] = args else {
             }
             _ if needs_override => not_supported!("intrinsic {name} is not implemented"),
             _ => return Ok(false),
-        }
-        .map(|()| true)
+        }.map(
+            |()| true,
+        )
     }
 
     fn size_align_of_unsized(
     ) -> Result<'db, ()> {
         // We are a single threaded runtime with no UB checking and no optimization, so
         // we can implement atomic intrinsics as normal functions.
-
         if name.starts_with("singlethreadfence_") || name.starts_with("fence_") {
             return Ok(());
         }
 
         // The rest of atomic intrinsics have exactly one generic arg
-
         let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
             return Err(MirEvalError::InternalError(
                 "atomic intrinsic generic arg is not provided".into(),