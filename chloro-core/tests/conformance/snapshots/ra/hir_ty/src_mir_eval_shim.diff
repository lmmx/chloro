COMPARISON DIFF
============================================================

Original size: 69401 bytes
Chloro size:   68076 bytes
Rustfmt size:  69401 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Interpret intrinsics, lang items and `extern "C"` wellknown functions which their implementation
 //! is not available.
 //!
+
+mod simd;
+
 use std::cmp::{self, Ordering};
 
-use hir_def::{CrateRootModuleId, resolver::HasResolver, signatures::FunctionSignature};
+use hir_def::{resolver::HasResolver, signatures::FunctionSignature, CrateRootModuleId};
 use hir_expand::name::Name;
-use intern::{Symbol, sym};
+use intern::{sym, Symbol};
 use rustc_type_ir::inherent::{AdtDef, IntoKind, SliceLike, Ty as _};
 use stdx::never;
 
 use crate::{
     display::DisplayTarget,
-    drop::{DropGlue, has_drop_glue},
+    drop::{has_drop_glue, DropGlue},
     mir::eval::{
-        Address, AdtId, Arc, Evaluator, FunctionId, GenericArgs, HasModule, HirDisplay,
+        pad16, Address, AdtId, Arc, Evaluator, FunctionId, GenericArgs, HasModule, HirDisplay,
         InternedClosure, Interval, IntervalAndTy, IntervalOrOwned, ItemContainerId, LangItem,
-        Layout, Locals, Lookup, MirEvalError, MirSpan, Mutability, Result, Ty, TyKind, pad16,
+        Layout, Locals, Lookup, MirEvalError, MirSpan, Mutability, Result, Ty, TyKind,
     },
     next_solver::Region,
 };
 
-mod simd;
-
 macro_rules! from_bytes {
     ($ty:tt, $value:expr) => {
         ($ty::from_le_bytes(match ($value).try_into() {
                     };
                 }
                 Err(MirEvalError::Panic(format!("unknown-panic-payload: {:?}", arg.ty.kind())))
-            }
+            },
             SliceLen => {
                 let arg = args.next().ok_or(MirEvalError::InternalError(
                     "argument of <[T]>::len() is not provided".into(),
                 let arg = arg.get(self)?;
                 let ptr_size = arg.len() / 2;
                 Ok(arg[ptr_size..].into())
-            }
+            },
             DropInPlace => {
                 let ty = generic_args.as_slice().first().and_then(|it| it.ty()).ok_or(
                     MirEvalError::InternalError(
                     span,
                 )?;
                 Ok(vec![])
-            }
+            },
             it => not_supported!("Executing lang item {it:?}"),
         }
     }
     ) -> Result<'db, ()> {
         match id {
             318 => {
-                // SYS_getrandom
                 let [buf, len, _flags] = args else {
                     return Err(MirEvalError::InternalError(
                         "SYS_getrandom args are not provided".into(),
                     self.write_memory(addr.offset(i), &[rand_byte])?;
                 }
                 destination.write_from_interval(self, len.interval)
-            }
+            },
             _ => {
                 not_supported!("Unknown syscall id {id:?}")
-            }
+            },
         }
     }
 
                     cmp::Ordering::Greater => 1,
                 };
                 destination.write_from_bytes(self, &r.to_le_bytes()[..destination.size])
-            }
+            },
             "write" => {
                 let [fd, ptr, len] = args else {
                     return Err(MirEvalError::InternalError(
                 }
                 destination.write_from_interval(self, len.interval)?;
                 Ok(())
-            }
+            },
             "pthread_key_create" => {
                 let key = self.thread_local_storage.create_key();
                 let Some(arg0) = args.first() else {
                     self.size_of_sized(key_ty, locals, "pthread_key_create key arg")?,
                 );
                 arg0_interval.write_from_bytes(self, &key.to_le_bytes()[0..arg0_interval.size])?;
-                // return 0 as success
                 destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;
                 Ok(())
-            }
+            },
             "pthread_getspecific" => {
                 let Some(arg0) = args.first() else {
                     return Err(MirEvalError::InternalError(
                 let value = self.thread_local_storage.get_key(key)?;
                 destination.write_from_bytes(self, &value.to_le_bytes()[0..destination.size])?;
                 Ok(())
-            }
+            },
             "pthread_setspecific" => {
                 let Some(arg0) = args.first() else {
                     return Err(MirEvalError::InternalError(
                 };
                 let value = from_bytes!(u128, pad16(arg1.get(self)?, false));
                 self.thread_local_storage.set_key(key, value)?;
-                // return 0 as success
                 destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;
                 Ok(())
-            }
+            },
             "pthread_key_delete" => {
-                // we ignore this currently
-                // return 0 as success
                 destination.write_from_bytes(self, &0u64.to_le_bytes()[0..destination.size])?;
                 Ok(())
-            }
+            },
             "syscall" => {
                 let Some((id, rest)) = args.split_first() else {
                     return Err(MirEvalError::InternalError("syscall arg1 is not provided".into()));
                 };
                 let id = from_bytes!(i64, id.get(self)?);
                 self.exec_syscall(id, rest, destination, locals, span)
-            }
+            },
             "sched_getaffinity" => {
                 let [_pid, _set_size, set] = args else {
                     return Err(MirEvalError::InternalError(
                     ));
                 };
                 let set = Address::from_bytes(set.get(self)?)?;
-                // Only enable core 0 (we are single threaded anyway), which is bitset 0x0000001
                 self.write_memory(set, &[1])?;
-                // return 0 as success
                 self.write_memory_using_ref(destination.addr, destination.size)?.fill(0);
                 Ok(())
-            }
+            },
             "getenv" => {
                 let [name] = args else {
                     return Err(MirEvalError::InternalError(
                     }
                 }
                 Ok(())
-            }
+            },
             _ => not_supported!("unknown external function {as_str}"),
         }
     }
                 };
                 let size = self.size_of_sized(ty, locals, "size_of arg")?;
                 destination.write_from_bytes(self, &size.to_le_bytes()[0..destination.size])
-            }
-            // FIXME: `min_align_of` was renamed to `align_of` in Rust 1.89
-            // (https://github.com/rust-lang/rust/pull/142410)
+            },
             "min_align_of" | "align_of" => {
                 let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
                     return Err(MirEvalError::InternalError(
                 };
                 let align = self.layout(ty)?.align.bytes();
                 destination.write_from_bytes(self, &align.to_le_bytes()[0..destination.size])
-            }
+            },
             "size_of_val" => {
                 let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
                     return Err(MirEvalError::InternalError(
                     let (size, _) = self.size_align_of_unsized(ty, metadata, locals)?;
                     destination.write_from_bytes(self, &size.to_le_bytes())
                 }
-            }
-            // FIXME: `min_align_of_val` was renamed to `align_of_val` in Rust 1.89
-            // (https://github.com/rust-lang/rust/pull/142410)
+            },
             "min_align_of_val" | "align_of_val" => {
                 let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
                     return Err(MirEvalError::InternalError(
                     let (_, align) = self.size_align_of_unsized(ty, metadata, locals)?;
                     destination.write_from_bytes(self, &align.to_le_bytes())
                 }
-            }
+            },
             "type_name" => {
                 let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
                     return Err(MirEvalError::InternalError(
                 let addr = self.heap_allocate(len, 1)?;
                 self.write_memory(addr, ty_name.as_bytes())?;
                 destination.slice(0..self.ptr_size()).write_from_bytes(self, &addr.to_bytes())?;
-                destination
-                    .slice(self.ptr_size()..2 * self.ptr_size())
-                    .write_from_bytes(self, &len.to_le_bytes())
-            }
+                destination.slice(self.ptr_size()..2 * self.ptr_size()).write_from_bytes(
+                    self,
+                    &len.to_le_bytes(),
+                )
+            },
             "needs_drop" => {
                 let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
                     return Err(MirEvalError::InternalError(
                     }
                 };
                 destination.write_from_bytes(self, &[u8::from(result)])
-            }
+            },
             "ptr_guaranteed_cmp" => {
-                // FIXME: this is wrong for const eval, it should return 2 in some
-                // cases.
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "wrapping_add args are not provided".into(),
                 };
                 let ans = lhs.get(self)? == rhs.get(self)?;
                 destination.write_from_bytes(self, &[u8::from(ans)])
-            }
+            },
             "saturating_add" | "saturating_sub" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                     _ => unreachable!(),
                 };
                 let bits = destination.size * 8;
-                // FIXME: signed
                 let is_signed = false;
                 let mx: u128 = if is_signed { (1 << (bits - 1)) - 1 } else { (1 << bits) - 1 };
-                // FIXME: signed
                 let mn: u128 = 0;
                 let ans = cmp::min(mx, cmp::max(mn, ans));
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "wrapping_add" | "unchecked_add" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                 let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));
                 let ans = lhs.wrapping_add(rhs);
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "ptr_offset_from_unsigned" | "ptr_offset_from" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                 let size = self.size_of_sized(ty, locals, "ptr_offset_from arg")? as i128;
                 let ans = ans / size;
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "wrapping_sub" | "unchecked_sub" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                 let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));
                 let ans = lhs.wrapping_sub(rhs);
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "wrapping_mul" | "unchecked_mul" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                 let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));
                 let ans = lhs.wrapping_mul(rhs);
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "wrapping_shl" | "unchecked_shl" => {
-                // FIXME: signed
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "unchecked_shl args are not provided".into(),
                 let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));
                 let ans = lhs.wrapping_shl(rhs as u32);
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "wrapping_shr" | "unchecked_shr" => {
-                // FIXME: signed
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "unchecked_shr args are not provided".into(),
                 let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));
                 let ans = lhs.wrapping_shr(rhs as u32);
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "unchecked_rem" => {
-                // FIXME: signed
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "unchecked_rem args are not provided".into(),
                     MirEvalError::UndefinedBehavior("unchecked_rem with bad inputs".to_owned())
                 })?;
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "unchecked_div" | "exact_div" => {
-                // FIXME: signed
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         "unchecked_div args are not provided".into(),
                     MirEvalError::UndefinedBehavior("unchecked_rem with bad inputs".to_owned())
                 })?;
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "add_with_overflow" | "sub_with_overflow" | "mul_with_overflow" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                         .map(IntervalOrOwned::Owned),
                 )?;
                 destination.write_from_bytes(self, &result)
-            }
+            },
             "copy" | "copy_nonoverlapping" => {
                 let [src, dst, offset] = args else {
                     return Err(MirEvalError::InternalError(
                 let src = Interval { addr: src, size };
                 let dst = Interval { addr: dst, size };
                 dst.write_from_interval(self, src)
-            }
+            },
             "offset" | "arith_offset" => {
                 let [ptr, offset] = args else {
                     return Err(MirEvalError::InternalError("offset args are not provided".into()));
                 let size = self.size_of_sized(ty, locals, "offset ptr type")? as u128;
                 let ans = ptr + offset * size;
                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])
-            }
+            },
             "assert_inhabited" | "assert_zero_valid" | "assert_uninit_valid" | "assume" => {
-                // FIXME: We should actually implement these checks
                 Ok(())
-            }
+            },
             "forget" => {
-                // We don't call any drop glue yet, so there is nothing here
                 Ok(())
-            }
+            },
             "transmute" | "transmute_unchecked" => {
                 let [arg] = args else {
                     return Err(MirEvalError::InternalError(
                     ));
                 };
                 destination.write_from_interval(self, arg.interval)
-            }
+            },
             "ctpop" => {
                 let [arg] = args else {
                     return Err(MirEvalError::InternalError("ctpop arg is not provided".into()));
                 };
                 let result = u128::from_le_bytes(pad16(arg.get(self)?, false)).count_ones();
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
-            }
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
+            },
             "ctlz" | "ctlz_nonzero" => {
                 let [arg] = args else {
                     return Err(MirEvalError::InternalError("ctlz arg is not provided".into()));
                 let result =
                     u128::from_le_bytes(pad16(arg.get(self)?, false)).leading_zeros() as usize;
                 let result = result - (128 - arg.interval.size * 8);
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
-            }
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
+            },
             "cttz" | "cttz_nonzero" => {
                 let [arg] = args else {
                     return Err(MirEvalError::InternalError("cttz arg is not provided".into()));
                 };
                 let result = u128::from_le_bytes(pad16(arg.get(self)?, false)).trailing_zeros();
-                destination
-                    .write_from_bytes(self, &(result as u128).to_le_bytes()[0..destination.size])
-            }
+                destination.write_from_bytes(
+                    self,
+                    &(result as u128).to_le_bytes()[0..destination.size],
+                )
+            },
             "rotate_left" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                     1 => {
                         let r = from_bytes!(u8, lhs).rotate_left(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     2 => {
                         let r = from_bytes!(u16, lhs).rotate_left(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     4 => {
                         let r = from_bytes!(u32, lhs).rotate_left(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     8 => {
                         let r = from_bytes!(u64, lhs).rotate_left(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     16 => {
                         let r = from_bytes!(u128, lhs).rotate_left(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     s => not_supported!("destination with size {s} for rotate_left"),
                 }
-            }
+            },
             "rotate_right" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                     1 => {
                         let r = from_bytes!(u8, lhs).rotate_right(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     2 => {
                         let r = from_bytes!(u16, lhs).rotate_right(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     4 => {
                         let r = from_bytes!(u32, lhs).rotate_right(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     8 => {
                         let r = from_bytes!(u64, lhs).rotate_right(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     16 => {
                         let r = from_bytes!(u128, lhs).rotate_right(rhs);
                         destination.write_from_bytes(self, &r.to_le_bytes())
-                    }
+                    },
                     s => not_supported!("destination with size {s} for rotate_right"),
                 }
-            }
+            },
             "discriminant_value" => {
                 let [arg] = args else {
                     return Err(MirEvalError::InternalError(
                 let interval = Interval { addr, size };
                 let r = self.compute_discriminant(ty, interval.get(self)?)?;
                 destination.write_from_bytes(self, &r.to_le_bytes()[0..destination.size])
-            }
+            },
             "const_eval_select" => {
                 let [tuple, const_fn, _] = args else {
                     return Err(MirEvalError::InternalError(
                     return Ok(true);
                 }
                 not_supported!("FnOnce was not available for executing const_eval_select");
-            }
+            },
             "read_via_copy" | "volatile_load" => {
                 let [arg] = args else {
                     return Err(MirEvalError::InternalError(
                 };
                 let addr = Address::from_bytes(arg.interval.get(self)?)?;
                 destination.write_from_interval(self, Interval { addr, size: destination.size })
-            }
+            },
             "write_via_move" => {
                 let [ptr, val] = args else {
                     return Err(MirEvalError::InternalError(
                 let size = self.size_of_sized(ty, locals, "write_via_move ptr type")?;
                 Interval { addr: dst, size }.write_from_interval(self, val.interval)?;
                 Ok(())
-            }
+            },
             "write_bytes" => {
                 let [dst, val, count] = args else {
                     return Err(MirEvalError::InternalError(
                 let size = count * size;
                 self.write_memory_using_ref(dst, size)?.fill(val);
                 Ok(())
-            }
+            },
             "ptr_metadata" => {
                 let [ptr] = args else {
                     return Err(MirEvalError::InternalError(
                 let metadata = &arg[self.ptr_size()..];
                 destination.write_from_bytes(self, metadata)?;
                 Ok(())
-            }
+            },
             "three_way_compare" => {
                 let [lhs, rhs] = args else {
                     return Err(MirEvalError::InternalError(
                 } else {
                     Err(MirEvalError::InternalError("Ordering enum not found".into()))
                 }
-            }
+            },
             "aggregate_raw_ptr" => {
                 let [data, meta] = args else {
                     return Err(MirEvalError::InternalError(
                 }
                 .write_from_interval(self, meta.interval)?;
                 Ok(())
-            }
+            },
             _ if needs_override => not_supported!("intrinsic {name} is not implemented"),
             _ => return Ok(false),
-        }
-        .map(|()| true)
+        }.map(
+            |()| true,
+        )
     }
 
     fn size_align_of_unsized(
                 let len = from_bytes!(usize, metadata.get(self)?);
                 let (size, align) = self.size_align_of_sized(inner, locals, "slice inner type")?;
                 (size * len, align)
-            }
+            },
             TyKind::Dynamic(..) => self.size_align_of_sized(
                 self.vtable_map.ty_of_bytes(metadata.get(self)?)?,
                 locals,
                     self.size_align_of_unsized(last_field_ty, metadata, locals)?;
                 let align = sized_part_align.max(unsized_part_align) as isize;
                 let size = (sized_part_size + unsized_part_size) as isize;
-                // Must add any necessary padding to `size`
-                // (to make it a multiple of `align`) before returning it.
-                //
-                // Namely, the returned size should be, in C notation:
-                //
-                //   `size + ((size & (align-1)) ? align : 0)`
-                //
-                // emulated via the semi-standard fast bit trick:
-                //
-                //   `(size + (align-1)) & -align`
                 let size = (size + (align - 1)) & (-align);
                 (size as usize, align as usize)
-            }
+            },
             _ => not_supported!("unsized type other than str, slice, struct and dyn"),
         })
     }
     ) -> Result<'db, ()> {
         // We are a single threaded runtime with no UB checking and no optimization, so
         // we can implement atomic intrinsics as normal functions.
-
         if name.starts_with("singlethreadfence_") || name.starts_with("fence_") {
             return Ok(());
         }
 
         // The rest of atomic intrinsics have exactly one generic arg
-
         let Some(ty) = generic_args.as_slice().first().and_then(|it| it.ty()) else {
             return Err(MirEvalError::InternalError(
                 "atomic intrinsic generic arg is not provided".into(),