COMPARISON DIFF
============================================================

Original size: 63433 bytes
Chloro size:   63253 bytes
Rustfmt size:  63433 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 #[test]
 fn param_overrides_fn() {
-    check_types(
-        r#"
+    check_types(r#"
         fn example(example: i32) {
             fn f() {}
             example;
           //^^^^^^^ i32
         }
-        "#,
-    )
+        "#)
 }
 
 #[test]
 fn lifetime_from_chalk_during_deref() {
-    check_types(
-        r#"
+    check_types(r#"
 //- minicore: deref
 struct Box<T: ?Sized>(T);
 impl<T: ?Sized> core::ops::Deref for Box<T> {
     s.inner.clone_box();
   //^^^^^^^^^^^^^^^^^^^ ()
 }
-"#,
-    )
+"#)
 }
 
 #[test]
 
 #[test]
 fn impl_trait_in_option_9530() {
-    check_types(
-        r#"
+    check_types(r#"
 //- minicore: sized
 struct Option<T>(T);
 impl<T> Option<T> {
     o.unwrap();
   //^^^^^^^^^^ impl Copy
 }
-        "#,
-    )
+        "#)
 }
 
 #[test]
 fn bare_dyn_trait_binders_9639() {
-    check_no_mismatches(
-        r#"
+    check_no_mismatches(r#"
 //- minicore: fn, coerce_unsized, dispatch_from_dyn
 fn infix_parse<T, S>(_state: S, _level_code: &Fn(S)) -> T {
     loop {}
 fn parse_a_rule() {
     infix_parse((), &(|_recurse| ()))
 }
-        "#,
-    )
+        "#)
 }
 
 #[test]
 
 #[test]
 fn macro_expands_to_impl_trait() {
-    check_no_mismatches(
-        r#"
+    check_no_mismatches(r#"
 trait Foo {}
 
 macro_rules! ty {
 fn bar() {
     foo(());
 }
-    "#,
-    )
+    "#)
 }
 
 #[test]
 fn nested_macro_in_fn_params() {
-    check_no_mismatches(
-        r#"
+    check_no_mismatches(r#"
 macro_rules! U32Inner {
     () => {
         u32
 fn mamba(a: U32!(), p: u32) -> u32 {
     a
 }
-    "#,
-    )
+    "#)
 }
 
 #[test]
 
 #[test]
 fn nalgebra_factorial() {
-    check_no_mismatches(
-        r#"
+    check_no_mismatches(r#"
         const FACTORIAL: [u128; 4] = [1, 1, 2, 6];
 
         fn factorial(n: usize) -> u128 {
                 None => panic!("{}! is greater than u128::MAX", n),
             }
         }
-        "#,
-    )
+        "#)
 }
 
 #[test]
 
 #[test]
 fn regression_11688_4() {
-    check_types(
-        r#"
+    check_types(r#"
         //- minicore: dispatch_from_dyn
         trait Bar<const C: usize> {
             fn baz(&self) -> [i32; C];
             x.baz();
           //^^^^^^^ [i32; 2]
         }
-        "#,
-    )
+        "#)
 }
 
 #[test]
 
 #[test]
 fn incorrect_variant_form_through_alias_caught() {
-    check_types(
-        r#"
+    check_types(r#"
 enum Enum { Braced {}, Unit, Tuple() }
 type Alias = Enum;
 
     let Alias::Unit{} = loop {};
       //^^^^^^^^^^^^^ Enum
 }
-"#,
-    )
+"#)
 }
 
 #[test]
 fn cfg_first_trait_param_16141() {
-    check_no_mismatches(
-        r#"
+    check_no_mismatches(r#"
 //- minicore: sized, coerce_unsized
 trait Bar {
     fn bar(&self) {}
 }
 
 impl<#[cfg(feature = "a-feature")] A> Bar for (){}
-"#,
-    )
+"#)
 }
 
 #[test]
 
 #[test]
 fn issue_17734() {
-    check_types(
-        r#"
+    check_types(r#"
 fn test() {
     let x = S::foo::<'static, &()>(&S);
      // ^ Wrap<'?, ()>
 impl<'a, T> Trait<'a> for &'a T {
     type Proj = Wrap<'a, T>;
 }
-"#,
-    )
+"#)
 }
 
 #[test]
 fn issue_17738() {
-    check_types(
-        r#"
+    check_types(r#"
 //- minicore: index
 use core::ops::{Index, IndexMut};
 
      // ^^^^^^ Foo<&'? (), Bar>
     t2[&()].bar();
 }
-"#,
-    )
+"#)
 }
 
 #[test]