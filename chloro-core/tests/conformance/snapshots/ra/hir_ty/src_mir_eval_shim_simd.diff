COMPARISON DIFF
============================================================

Original size: 7864 bytes
Chloro size:   7868 bytes
Rustfmt size:  7864 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Shim implementation for simd intrinsics
 
 use std::cmp::Ordering;
 
 use crate::consteval::try_const_usize;
-
 use super::*;
 
 macro_rules! from_bytes {
                             ));
                         };
                         Ok((len as usize, ty))
-                    }
-                    None => Err(MirEvalError::InternalError(
-                        "simd type with unevaluatable len param".into(),
-                    )),
+                    },
+                    None => Err(
+                        MirEvalError::InternalError("simd type with unevaluatable len param".into()),
+                    ),
                 }
-            }
+            },
             _ => Err(MirEvalError::InternalError("simd type which is not a struct".into())),
         }
     }
                     })
                     .collect::<Vec<_>>();
                 destination.write_from_bytes(self, &result)
-            }
+            },
             "eq" | "ne" | "lt" | "le" | "gt" | "ge" => {
                 let [left, right] = args else {
                     return Err(MirEvalError::InternalError("simd args are not provided".into()));
                     let result = if result { 255 } else { 0 };
                     destination_bytes.extend(std::iter::repeat_n(result, dest_size));
                 }
-
                 destination.write_from_bytes(self, &destination_bytes)
-            }
+            },
             "bitmask" => {
                 let [op] = args else {
                     return Err(MirEvalError::InternalError(
                     }
                 }
                 destination.write_from_bytes(self, &result.to_le_bytes()[0..destination.size])
-            }
+            },
             "shuffle" => {
                 let [left, right, index] = args else {
                     return Err(MirEvalError::InternalError(
                     result.extend(val);
                 }
                 destination.write_from_bytes(self, &result)
-            }
+            },
             _ => not_supported!("unknown simd intrinsic {name}"),
         }
     }