COMPARISON DIFF
============================================================

Original size: 21126 bytes
Chloro size:   21184 bytes
Rustfmt size:  22047 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Interface with `rustc_pattern_analysis`.
 
 use std::{cell::LazyCell, fmt};
 
+use Constructor::*;
 use hir_def::{EnumId, EnumVariantId, HasModule, LocalFieldId, ModuleId, VariantId};
 use intern::sym;
 use rustc_pattern_analysis::{
-    constructor::{Constructor, ConstructorSet, VariantVisibility},
-    usefulness::{compute_match_usefulness, PlaceValidity, UsefulnessReport},
     IndexVec, PatCx, PrivateUninhabitedField,
+    constructor::{Constructor, ConstructorSet, VariantVisibility},
+    usefulness::{PlaceValidity, UsefulnessReport, compute_match_usefulness},
 };
 use rustc_type_ir::inherent::{AdtDef, IntoKind, SliceLike};
-use smallvec::{smallvec, SmallVec};
+use smallvec::{SmallVec, smallvec};
 use stdx::never;
 use triomphe::Arc;
 
 use crate::{
+    TraitEnvironment,
     db::HirDatabase,
     inhabitedness::{is_enum_variant_uninhabited_from, is_ty_uninhabited_from},
     next_solver::{
-        infer::{traits::ObligationCause, InferCtxt},
         Ty, TyKind,
+        infer::{InferCtxt, traits::ObligationCause},
     },
-    TraitEnvironment,
 };
-
 use super::{FieldPat, Pat, PatKind};
 
-use Constructor::*;
+pub(crate) type DeconstructedPat<'a, 'db> = rustc_pattern_analysis::pat::DeconstructedPat<MatchCheckCtx<'a, 'db>>;
 
-// Re-export r-a-specific versions of all these types.
-pub(crate) type DeconstructedPat<'a, 'db> =
-    rustc_pattern_analysis::pat::DeconstructedPat<MatchCheckCtx<'a, 'db>>;
-pub(crate) type MatchArm<'a, 'b, 'db> =
-    rustc_pattern_analysis::MatchArm<'b, MatchCheckCtx<'a, 'db>>;
-pub(crate) type WitnessPat<'a, 'db> =
-    rustc_pattern_analysis::pat::WitnessPat<MatchCheckCtx<'a, 'db>>;
+pub(crate) type MatchArm<'a, 'b, 'db> = rustc_pattern_analysis::MatchArm<'b, MatchCheckCtx<'a, 'db>>;
+
+pub(crate) type WitnessPat<'a, 'db> = rustc_pattern_analysis::pat::WitnessPat<MatchCheckCtx<'a, 'db>>;
 
 /// [Constructor] uses this in unimplemented variants.
 /// It allows porting match expressions from upstream algorithm without losing semantics.
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub(crate) enum Void {}
+pub(crate) enum Void {
+}
 
 /// An index type for enum variants. This ranges from 0 to `variants.len()`, whereas `EnumVariantId`
 /// can take arbitrary large values (and hence mustn't be used with `IndexVec`/`BitSet`).
 pub(crate) struct EnumVariantContiguousIndex(usize);
 
 impl EnumVariantContiguousIndex {
-    fn from_enum_variant_id(db: &dyn HirDatabase, target_evid: EnumVariantId) -> Self {
+    fn from_enum_variant_id(
+        db: &dyn HirDatabase,
+        target_evid: EnumVariantId,
+    ) -> Self {
         // Find the index of this variant in the list of variants.
         use hir_def::Lookup;
         let i = target_evid.lookup(db).index as usize;
         EnumVariantContiguousIndex(i)
     }
 
-    fn to_enum_variant_id(self, db: &dyn HirDatabase, eid: EnumId) -> EnumVariantId {
+    fn to_enum_variant_id(
+        self,
+        db: &dyn HirDatabase,
+        eid: EnumId,
+    ) -> EnumVariantId {
         eid.enum_variants(db).variants[self.0].0
     }
 }
         let db = infcx.interner.db;
         let def_map = module.crate_def_map(db);
         let exhaustive_patterns = def_map.is_unstable_feature_enabled(&sym::exhaustive_patterns);
-        Self {
-            module,
-            db,
-            exhaustive_patterns,
-            env,
-            infcx,
-        }
+        Self { module, db, exhaustive_patterns, env, infcx }
     }
 
     pub(crate) fn compute_match_usefulness<'b>(
                 return Err(());
             }
         }
-
         let place_validity = PlaceValidity::from_bool(known_valid_scrutinee.unwrap_or(true));
         // Measured to take ~100ms on modern hardware.
         let complexity_limit = 500000;
         compute_match_usefulness(self, arms, scrut_ty, place_validity, complexity_limit)
     }
 
-    fn is_uninhabited(&self, ty: Ty<'db>) -> bool {
+    fn is_uninhabited(
+        &self,
+        ty: Ty<'db>,
+    ) -> bool {
         is_ty_uninhabited_from(self.infcx, ty, self.module, self.env.clone())
     }
 
     /// Returns whether the given ADT is from another crate declared `#[non_exhaustive]`.
-    fn is_foreign_non_exhaustive(&self, adt: hir_def::AdtId) -> bool {
+    fn is_foreign_non_exhaustive(
+        &self,
+        adt: hir_def::AdtId,
+    ) -> bool {
         let is_local = adt.krate(self.db) == self.module.krate();
-        !is_local
-            && self
-                .db
-                .attrs(adt.into())
-                .by_key(sym::non_exhaustive)
-                .exists()
+        !is_local && self.db.attrs(adt.into()).by_key(sym::non_exhaustive).exists()
     }
 
     fn variant_id_for_adt(
         }
     }
 
-    // This lists the fields of a variant along with their types.
     fn list_variant_fields(
         &self,
         ty: Ty<'db>,
         variant: VariantId,
     ) -> impl Iterator<Item = (LocalFieldId, Ty<'db>)> {
         let (_, substs) = ty.as_adt().unwrap();
-
         let field_tys = self.db.field_types(variant);
         let fields_len = variant.fields(self.db).fields().len() as u32;
-
-        (0..fields_len)
-            .map(|idx| LocalFieldId::from_raw(idx.into()))
-            .map(move |fid| {
-                let ty = field_tys[fid].instantiate(self.infcx.interner, substs);
-                let ty = self
-                    .infcx
-                    .at(&ObligationCause::dummy(), self.env.env)
-                    .deeply_normalize(ty)
-                    .unwrap_or(ty);
-                (fid, ty)
-            })
+        (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).map(move |fid| {
+            let ty = field_tys[fid].instantiate(self.infcx.interner, substs);
+            let ty = self
+                .infcx
+                .at(&ObligationCause::dummy(), self.env.env)
+                .deeply_normalize(ty)
+                .unwrap_or(ty);
+            (fid, ty)
+        })
     }
 
-    pub(crate) fn lower_pat(&self, pat: &Pat<'db>) -> DeconstructedPat<'a, 'db> {
+    pub(crate) fn lower_pat(
+        &self,
+        pat: &Pat<'db>,
+    ) -> DeconstructedPat<'a, 'db> {
         let singleton = |pat: DeconstructedPat<'a, 'db>| vec![pat.at_index(0)];
         let ctor;
         let mut fields: Vec<_>;
         let arity;
-
         match pat.kind.as_ref() {
-            PatKind::Binding {
-                subpattern: Some(subpat),
-                ..
-            } => return self.lower_pat(subpat),
-            PatKind::Binding {
-                subpattern: None, ..
-            }
-            | PatKind::Wild => {
+            PatKind::Binding { subpattern: Some(subpat), .. } => return self.lower_pat(subpat),
+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => {
                 ctor = Wildcard;
                 fields = Vec::new();
                 arity = 0;
                 ctor = match pat.ty.kind() {
                     TyKind::Ref(..) => Ref,
                     _ => {
-                        never!(
-                            "pattern has unexpected type: pat: {:?}, ty: {:?}",
-                            pat,
-                            &pat.ty
-                        );
+                        never!("pattern has unexpected type: pat: {:?}, ty: {:?}", pat, &pat.ty);
                         Wildcard
                     }
                 };
                         arity = variant.fields(self.db).fields().len();
                     }
                     _ => {
-                        never!(
-                            "pattern has unexpected type: pat: {:?}, ty: {:?}",
-                            pat,
-                            &pat.ty
-                        );
+                        never!("pattern has unexpected type: pat: {:?}, ty: {:?}", pat, &pat.ty);
                         ctor = Wildcard;
                         fields.clear();
                         arity = 0;
         DeconstructedPat::new(ctor, fields, arity, pat.ty, ())
     }
 
-    pub(crate) fn hoist_witness_pat(&self, pat: &WitnessPat<'a, 'db>) -> Pat<'db> {
+    pub(crate) fn hoist_witness_pat(
+        &self,
+        pat: &WitnessPat<'a, 'db>,
+    ) -> Pat<'db> {
         let mut subpatterns = pat.iter_fields().map(|p| self.hoist_witness_pat(p));
         let kind = match pat.ctor() {
             &Bool(value) => PatKind::LiteralBool { value },
                         .collect();
 
                     if let VariantId::EnumVariantId(enum_variant) = variant {
-                        PatKind::Variant {
-                            substs,
-                            enum_variant,
-                            subpatterns,
-                        }
+                        PatKind::Variant { substs, enum_variant, subpatterns }
                     } else {
                         PatKind::Leaf { subpatterns }
                     }
             // be careful to reconstruct the correct constant pattern here. However a string
             // literal pattern will never be reported as a non-exhaustiveness witness, so we
             // ignore this issue.
-            Ref => PatKind::Deref {
-                subpattern: subpatterns.next().unwrap(),
-            },
+            Ref => PatKind::Deref { subpattern: subpatterns.next().unwrap() },
             Slice(_) => unimplemented!(),
             DerefPattern(_) => unimplemented!(),
             &Str(void) => match void {},
                 PatKind::Wild
             }
         };
-        Pat {
-            ty: *pat.ty(),
-            kind: Box::new(kind),
-        }
+        Pat { ty: *pat.ty(), kind: Box::new(kind) }
     }
 }
 
 impl<'a, 'db> PatCx for MatchCheckCtx<'a, 'db> {
     type Error = ();
+
     type Ty = Ty<'db>;
+
     type VariantIdx = EnumVariantContiguousIndex;
+
     type StrLit = Void;
+
     type ArmData = ();
+
     type PatData = ();
 
     fn is_exhaustive_patterns_feature_on(&self) -> bool {
         let single = |ty| smallvec![(ty, PrivateUninhabitedField(false))];
         let tys: SmallVec<[_; 2]> = match ctor {
             Struct | Variant(_) | UnionField => match ty.kind() {
-                TyKind::Tuple(substs) => substs
-                    .iter()
-                    .map(|ty| (ty, PrivateUninhabitedField(false)))
-                    .collect(),
+                TyKind::Tuple(substs) => {
+                    substs.iter().map(|ty| (ty, PrivateUninhabitedField(false))).collect()
+                }
                 TyKind::Ref(_, rty, _) => single(rty),
                 TyKind::Adt(adt_def, ..) => {
                     let adt = adt_def.def_id().0;
                         .collect()
                 }
                 ty_kind => {
-                    never!(
-                        "Unexpected type for `{:?}` constructor: {:?}",
-                        ctor,
-                        ty_kind
-                    );
+                    never!("Unexpected type for `{:?}` constructor: {:?}", ctor, ty_kind);
                     single(*ty)
                 }
             },
             Ref => match ty.kind() {
                 TyKind::Ref(_, rty, _) => single(rty),
                 ty_kind => {
-                    never!(
-                        "Unexpected type for `{:?}` constructor: {:?}",
-                        ctor,
-                        ty_kind
-                    );
+                    never!("Unexpected type for `{:?}` constructor: {:?}", ctor, ty_kind);
                     single(*ty)
                 }
             },
         ty: &Self::Ty,
     ) -> Result<rustc_pattern_analysis::constructor::ConstructorSet<Self>, Self::Error> {
         let cx = self;
-
         // Unhandled types are treated as non-exhaustive. Being explicit here instead of falling
         // to catchall arm to ease further implementation.
         let unhandled = || ConstructorSet::Unlistable;
-
         // This determines the set of all possible constructors for the type `ty`. For numbers,
         // arrays and slices we use ranges and variable-length slices when appropriate.
         //
                         }
                     }
                     hir_def::AdtId::UnionId(_) => ConstructorSet::Union,
-                    hir_def::AdtId::StructId(_) => ConstructorSet::Struct {
-                        empty: cx.is_uninhabited(*ty),
-                    },
+                    hir_def::AdtId::StructId(_) => {
+                        ConstructorSet::Struct { empty: cx.is_uninhabited(*ty) }
+                    }
                 }
             }
-            TyKind::Tuple(..) => ConstructorSet::Struct {
-                empty: cx.is_uninhabited(*ty),
-            },
+            TyKind::Tuple(..) => ConstructorSet::Struct { empty: cx.is_uninhabited(*ty) },
             TyKind::Ref(..) => ConstructorSet::Ref,
             TyKind::Never => ConstructorSet::NoConstructors,
             // This type is one for which we cannot list constructors, like `str` or `f64`.
         write!(f, "<write_variant_name unsupported>")
         // We lack the database here ...
         // let variant = ty.as_adt().and_then(|(adt, _)| Self::variant_id_for_adt(db, ctor, adt));
-
         // if let Some(variant) = variant {
         //     match variant {
         //         VariantId::EnumVariantId(v) => {
         // Ok(())
     }
 
-    fn bug(&self, fmt: fmt::Arguments<'_>) {
+    fn bug(
+        &self,
+        fmt: fmt::Arguments<'_>,
+    ) {
         never!("{}", fmt)
     }
 
 }
 
 impl fmt::Debug for MatchCheckCtx<'_, '_> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("MatchCheckCtx").finish()
     }
 }