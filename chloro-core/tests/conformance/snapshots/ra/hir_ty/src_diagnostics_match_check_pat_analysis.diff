COMPARISON DIFF
============================================================

Original size: 21126 bytes
Chloro size:   21030 bytes
Rustfmt size:  22047 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     db::HirDatabase,
     inhabitedness::{is_enum_variant_uninhabited_from, is_ty_uninhabited_from},
-    next_solver::{
-        infer::{traits::ObligationCause, InferCtxt},
-        Ty, TyKind,
-    },
+    next_solver::{infer::{InferCtxt, traits::ObligationCause}, Ty, TyKind},
     TraitEnvironment,
 };
 
 
 use Constructor::*;
 
-// Re-export r-a-specific versions of all these types.
-pub(crate) type DeconstructedPat<'a, 'db> =
-    rustc_pattern_analysis::pat::DeconstructedPat<MatchCheckCtx<'a, 'db>>;
-pub(crate) type MatchArm<'a, 'b, 'db> =
-    rustc_pattern_analysis::MatchArm<'b, MatchCheckCtx<'a, 'db>>;
-pub(crate) type WitnessPat<'a, 'db> =
-    rustc_pattern_analysis::pat::WitnessPat<MatchCheckCtx<'a, 'db>>;
+pub(crate) type DeconstructedPat<'a, 'db> = rustc_pattern_analysis::pat::DeconstructedPat<MatchCheckCtx<'a, 'db>>;
+
+pub(crate) type MatchArm<'a, 'b, 'db> = rustc_pattern_analysis::MatchArm<'b, MatchCheckCtx<'a, 'db>>;
+
+pub(crate) type WitnessPat<'a, 'db> = rustc_pattern_analysis::pat::WitnessPat<MatchCheckCtx<'a, 'db>>;
 
 /// [Constructor] uses this in unimplemented variants.
 /// It allows porting match expressions from upstream algorithm without losing semantics.
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub(crate) enum Void {}
+pub(crate) enum Void {
+}
 
 /// An index type for enum variants. This ranges from 0 to `variants.len()`, whereas `EnumVariantId`
 /// can take arbitrary large values (and hence mustn't be used with `IndexVec`/`BitSet`).
         let db = infcx.interner.db;
         let def_map = module.crate_def_map(db);
         let exhaustive_patterns = def_map.is_unstable_feature_enabled(&sym::exhaustive_patterns);
-        Self {
-            module,
-            db,
-            exhaustive_patterns,
-            env,
-            infcx,
-        }
+        Self { module, db, exhaustive_patterns, env, infcx }
     }
 
     pub(crate) fn compute_match_usefulness<'b>(
     /// Returns whether the given ADT is from another crate declared `#[non_exhaustive]`.
     fn is_foreign_non_exhaustive(&self, adt: hir_def::AdtId) -> bool {
         let is_local = adt.krate(self.db) == self.module.krate();
-        !is_local
-            && self
-                .db
-                .attrs(adt.into())
-                .by_key(sym::non_exhaustive)
-                .exists()
+        !is_local && self.db.attrs(adt.into()).by_key(sym::non_exhaustive).exists()
     }
 
     fn variant_id_for_adt(
         }
     }
 
-    // This lists the fields of a variant along with their types.
     fn list_variant_fields(
         &self,
         ty: Ty<'db>,
         let field_tys = self.db.field_types(variant);
         let fields_len = variant.fields(self.db).fields().len() as u32;
 
-        (0..fields_len)
-            .map(|idx| LocalFieldId::from_raw(idx.into()))
-            .map(move |fid| {
-                let ty = field_tys[fid].instantiate(self.infcx.interner, substs);
-                let ty = self
-                    .infcx
-                    .at(&ObligationCause::dummy(), self.env.env)
-                    .deeply_normalize(ty)
-                    .unwrap_or(ty);
-                (fid, ty)
-            })
+        (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).map(move |fid| {
+            let ty = field_tys[fid].instantiate(self.infcx.interner, substs);
+            let ty = self
+                .infcx
+                .at(&ObligationCause::dummy(), self.env.env)
+                .deeply_normalize(ty)
+                .unwrap_or(ty);
+            (fid, ty)
+        })
     }
 
     pub(crate) fn lower_pat(&self, pat: &Pat<'db>) -> DeconstructedPat<'a, 'db> {
         let arity;
 
         match pat.kind.as_ref() {
-            PatKind::Binding {
-                subpattern: Some(subpat),
-                ..
-            } => return self.lower_pat(subpat),
-            PatKind::Binding {
-                subpattern: None, ..
-            }
-            | PatKind::Wild => {
+            PatKind::Binding { subpattern: Some(subpat), .. } => return self.lower_pat(subpat),
+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => {
                 ctor = Wildcard;
                 fields = Vec::new();
                 arity = 0;
                 ctor = match pat.ty.kind() {
                     TyKind::Ref(..) => Ref,
                     _ => {
-                        never!(
-                            "pattern has unexpected type: pat: {:?}, ty: {:?}",
-                            pat,
-                            &pat.ty
-                        );
+                        never!("pattern has unexpected type: pat: {:?}, ty: {:?}", pat, &pat.ty);
                         Wildcard
                     }
                 };
                         arity = variant.fields(self.db).fields().len();
                     }
                     _ => {
-                        never!(
-                            "pattern has unexpected type: pat: {:?}, ty: {:?}",
-                            pat,
-                            &pat.ty
-                        );
+                        never!("pattern has unexpected type: pat: {:?}, ty: {:?}", pat, &pat.ty);
                         ctor = Wildcard;
                         fields.clear();
                         arity = 0;
                         .collect();
 
                     if let VariantId::EnumVariantId(enum_variant) = variant {
-                        PatKind::Variant {
-                            substs,
-                            enum_variant,
-                            subpatterns,
-                        }
+                        PatKind::Variant { substs, enum_variant, subpatterns }
                     } else {
                         PatKind::Leaf { subpatterns }
                     }
             // be careful to reconstruct the correct constant pattern here. However a string
             // literal pattern will never be reported as a non-exhaustiveness witness, so we
             // ignore this issue.
-            Ref => PatKind::Deref {
-                subpattern: subpatterns.next().unwrap(),
-            },
+            Ref => PatKind::Deref { subpattern: subpatterns.next().unwrap() },
             Slice(_) => unimplemented!(),
             DerefPattern(_) => unimplemented!(),
             &Str(void) => match void {},
 
 impl<'a, 'db> PatCx for MatchCheckCtx<'a, 'db> {
     type Error = ();
+
     type Ty = Ty<'db>;
+
     type VariantIdx = EnumVariantContiguousIndex;
+
     type StrLit = Void;
+
     type ArmData = ();
+
     type PatData = ();
 
     fn is_exhaustive_patterns_feature_on(&self) -> bool {
         let single = |ty| smallvec![(ty, PrivateUninhabitedField(false))];
         let tys: SmallVec<[_; 2]> = match ctor {
             Struct | Variant(_) | UnionField => match ty.kind() {
-                TyKind::Tuple(substs) => substs
-                    .iter()
-                    .map(|ty| (ty, PrivateUninhabitedField(false)))
-                    .collect(),
+                TyKind::Tuple(substs) => {
+                    substs.iter().map(|ty| (ty, PrivateUninhabitedField(false))).collect()
+                }
                 TyKind::Ref(_, rty, _) => single(rty),
                 TyKind::Adt(adt_def, ..) => {
                     let adt = adt_def.def_id().0;
                         .collect()
                 }
                 ty_kind => {
-                    never!(
-                        "Unexpected type for `{:?}` constructor: {:?}",
-                        ctor,
-                        ty_kind
-                    );
+                    never!("Unexpected type for `{:?}` constructor: {:?}", ctor, ty_kind);
                     single(*ty)
                 }
             },
             Ref => match ty.kind() {
                 TyKind::Ref(_, rty, _) => single(rty),
                 ty_kind => {
-                    never!(
-                        "Unexpected type for `{:?}` constructor: {:?}",
-                        ctor,
-                        ty_kind
-                    );
+                    never!("Unexpected type for `{:?}` constructor: {:?}", ctor, ty_kind);
                     single(*ty)
                 }
             },
         let cx = self;
 
         // Unhandled types are treated as non-exhaustive. Being explicit here instead of falling
+
         // to catchall arm to ease further implementation.
         let unhandled = || ConstructorSet::Unlistable;
 
         // This determines the set of all possible constructors for the type `ty`. For numbers,
+
         // arrays and slices we use ranges and variable-length slices when appropriate.
+
         //
+
         // If the `exhaustive_patterns` feature is enabled, we make sure to omit constructors that
+
         // are statically impossible. E.g., for `Option<!>`, we do not include `Some(_)` in the
+
         // returned list of constructors.
+
         // Invariant: this is empty if and only if the type is uninhabited (as determined by
+
         // `cx.is_uninhabited()`).
         Ok(match ty.kind() {
             TyKind::Bool => ConstructorSet::Bool,
                     hir_def::AdtId::EnumId(enum_id) => {
                         let enum_data = enum_id.enum_variants(cx.db);
                         let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive(adt);
-
                         if enum_data.variants.is_empty() && !is_declared_nonexhaustive {
                             ConstructorSet::NoConstructors
                         } else {
                                 };
                                 variants.push(visibility);
                             }
-
                             ConstructorSet::Variants {
                                 variants,
                                 non_exhaustive: is_declared_nonexhaustive,
                         }
                     }
                     hir_def::AdtId::UnionId(_) => ConstructorSet::Union,
-                    hir_def::AdtId::StructId(_) => ConstructorSet::Struct {
-                        empty: cx.is_uninhabited(*ty),
-                    },
+                    hir_def::AdtId::StructId(_) => {
+                        ConstructorSet::Struct { empty: cx.is_uninhabited(*ty) }
+                    }
                 }
             }
-            TyKind::Tuple(..) => ConstructorSet::Struct {
-                empty: cx.is_uninhabited(*ty),
-            },
+            TyKind::Tuple(..) => ConstructorSet::Struct { empty: cx.is_uninhabited(*ty) },
             TyKind::Ref(..) => ConstructorSet::Ref,
             TyKind::Never => ConstructorSet::NoConstructors,
             // This type is one for which we cannot list constructors, like `str` or `f64`.
         // let variant = ty.as_adt().and_then(|(adt, _)| Self::variant_id_for_adt(db, ctor, adt));
 
         // if let Some(variant) = variant {
+
         //     match variant {
+
         //         VariantId::EnumVariantId(v) => {
+
         //             write!(f, "{}", db.enum_variant_data(v).name.display(db))?;
+
         //         }
+
         //         VariantId::StructId(s) => {
+
         //             write!(f, "{}", db.struct_data(s).name.display(db))?
+
         //         }
+
         //         VariantId::UnionId(u) => {
+
         //             write!(f, "{}", db.union_data(u).name.display(db))?
+
         //         }
+
         //     }
+
         // }
+
         // Ok(())
     }
 