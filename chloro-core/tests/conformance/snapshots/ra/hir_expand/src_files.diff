COMPARISON DIFF
============================================================

Original size: 19253 bytes
Chloro size:   19485 bytes
Rustfmt size:  20465 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Things to wrap other things in file ids.
+
 use std::borrow::Borrow;
 
 use either::Either;
 use syntax::{AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextSize};
 
 use crate::{
+    EditionedFileId, HirFileId, MacroCallId, MacroKind,
     db::{self, ExpandDatabase},
-    map_node_range_up, map_node_range_up_rooted, span_for_offset, EditionedFileId, HirFileId,
-    MacroCallId, MacroKind,
+    map_node_range_up, map_node_range_up_rooted, span_for_offset,
 };
 
 /// `InFile<T>` stores a value of `T` inside a particular file/syntax tree.
     pub file_id: FileKind,
     pub value: T,
 }
+
 pub type InFile<T> = InFileWrapper<HirFileId, T>;
+
 pub type InMacroFile<T> = InFileWrapper<MacroCallId, T>;
+
 pub type InRealFile<T> = InFileWrapper<EditionedFileId, T>;
 
 #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
     pub file_id: FileKind,
     pub offset: TextSize,
 }
+
 pub type HirFilePosition = FilePositionWrapper<HirFileId>;
+
 pub type MacroFilePosition = FilePositionWrapper<MacroCallId>;
+
 pub type FilePosition = FilePositionWrapper<EditionedFileId>;
 
 impl FilePosition {
     pub file_id: FileKind,
     pub range: TextRange,
 }
+
 pub type HirFileRange = FileRangeWrapper<HirFileId>;
+
 pub type MacroFileRange = FileRangeWrapper<MacroCallId>;
+
 pub type FileRange = FileRangeWrapper<EditionedFileId>;
 
 impl FileRange {
     pub fn to_node(&self, db: &dyn ExpandDatabase) -> N {
         self.to_ptr(db).to_node(&db.parse_or_expand(self.file_id))
     }
+
     pub fn to_range(&self, db: &dyn ExpandDatabase) -> TextRange {
         self.to_ptr(db).text_range()
     }
+
     pub fn to_in_file_node(&self, db: &dyn ExpandDatabase) -> crate::InFile<N> {
-        crate::InFile::new(
-            self.file_id,
-            self.to_ptr(db).to_node(&db.parse_or_expand(self.file_id)),
-        )
+        crate::InFile::new(self.file_id, self.to_ptr(db).to_node(&db.parse_or_expand(self.file_id)))
     }
+
     pub fn to_ptr(&self, db: &dyn ExpandDatabase) -> AstPtr<N> {
         db.ast_id_map(self.file_id).get(self.value)
     }
+
     pub fn erase(&self) -> ErasedAstId {
         crate::InFile::new(self.file_id, self.value.erase())
     }
+
     #[inline]
     pub fn upcast<M: AstIdNode>(self) -> AstId<M>
     where
     pub fn to_range(&self, db: &dyn ExpandDatabase) -> TextRange {
         self.to_ptr(db).text_range()
     }
+
     pub fn to_ptr(&self, db: &dyn ExpandDatabase) -> SyntaxNodePtr {
         db.ast_id_map(self.file_id).get_erased(self.value)
     }
 
 impl<T> From<InMacroFile<T>> for InFile<T> {
     fn from(InMacroFile { file_id, value }: InMacroFile<T>) -> Self {
-        InFile {
-            file_id: file_id.into(),
-            value,
-        }
+        InFile { file_id: file_id.into(), value }
     }
 }
 
 impl<T> From<InRealFile<T>> for InFile<T> {
     fn from(InRealFile { file_id, value }: InRealFile<T>) -> Self {
-        InFile {
-            file_id: file_id.into(),
-            value,
-        }
+        InFile { file_id: file_id.into(), value }
     }
 }
 
 // region:transpose impls
-
 impl<FileKind, T> InFileWrapper<FileKind, Option<T>> {
     pub fn transpose(self) -> Option<InFileWrapper<FileKind, T>> {
         Some(InFileWrapper::new(self.file_id, self.value?))
 }
 
 // endregion:transpose impls
-
-trait FileIdToSyntax: Copy {
+trait FileIdToSyntax {
     fn file_syntax(self, db: &dyn db::ExpandDatabase) -> SyntaxNode;
 }
 
         db.parse(self).syntax_node()
     }
 }
+
 impl FileIdToSyntax for MacroCallId {
     fn file_syntax(self, db: &dyn db::ExpandDatabase) -> SyntaxNode {
         db.parse_macro_expansion(self).value.0.syntax_node()
     }
 }
+
 impl FileIdToSyntax for HirFileId {
     fn file_syntax(self, db: &dyn db::ExpandDatabase) -> SyntaxNode {
         db.parse_or_expand(self)
     pub fn syntax(&self) -> InFileWrapper<FileId, &SyntaxNode> {
         self.with_value(self.value.syntax())
     }
+
     pub fn node_file_range(&self) -> FileRangeWrapper<FileId> {
         FileRangeWrapper {
             file_id: self.file_id,
 }
 
 impl<FileId: Copy, N: AstNode> InFileWrapper<FileId, &N> {
-    // unfortunately `syntax` collides with the impl above, because `&_` is fundamental
     pub fn syntax_ref(&self) -> InFileWrapper<FileId, &SyntaxNode> {
         self.with_value(self.value.syntax())
     }
 }
 
-// region:specific impls
 impl<FileId: Copy, SN: Borrow<SyntaxNode>> InFileWrapper<FileId, SN> {
     pub fn file_range(&self) -> FileRangeWrapper<FileId> {
         FileRangeWrapper {
     /// For attributes and derives, this will point back to the attribute only.
     /// For the entire item use [`InFile::original_file_range_full`].
     pub fn original_file_range_rooted(self, db: &dyn db::ExpandDatabase) -> FileRange {
-        self.borrow()
-            .map(SyntaxNode::text_range)
-            .original_node_file_range_rooted(db)
+        self.borrow().map(SyntaxNode::text_range).original_node_file_range_rooted(db)
     }
 
     /// Falls back to the macro call range if the node cannot be mapped up fully.
         self,
         db: &dyn db::ExpandDatabase,
     ) -> FileRange {
-        self.borrow()
-            .map(SyntaxNode::text_range)
-            .original_node_file_range_with_macro_call_input(db)
+        self.borrow().map(SyntaxNode::text_range).original_node_file_range_with_macro_call_input(db)
     }
 
     pub fn original_syntax_node_rooted(
         // as we don't have node inputs otherwise and therefore can't find an `N` node in the input
         let file_id = match self.file_id {
             HirFileId::FileId(file_id) => {
-                return Some(InRealFile {
-                    file_id,
-                    value: self.value.borrow().clone(),
-                });
+                return Some(InRealFile { file_id, value: self.value.borrow().clone() });
             }
             HirFileId::MacroFile(m)
                 if matches!(m.kind(db), MacroKind::Attr | MacroKind::AttrBuiltIn) =>
             _ => return None,
         };
 
-        let FileRange {
-            file_id: editioned_file_id,
-            range,
-        } = map_node_range_up_rooted(
+        let FileRange { file_id: editioned_file_id, range } = map_node_range_up_rooted(
             db,
             &db.expansion_span_map(file_id),
             self.value.borrow().text_range(),
         self,
         db: &dyn db::ExpandDatabase,
     ) -> Option<(FileRange, SyntaxContext)> {
-        self.borrow()
-            .map(SyntaxNode::text_range)
-            .original_node_file_range_opt(db)
+        self.borrow().map(SyntaxNode::text_range).original_node_file_range_opt(db)
     }
 }
 
         self,
         db: &dyn db::ExpandDatabase,
     ) -> InFile<smallvec::SmallVec<[TextRange; 1]>> {
-        self.file_id
-            .expansion_info(db)
-            .map_range_up_once(db, self.value.text_range())
+        self.file_id.expansion_info(db).map_range_up_once(db, self.value.text_range())
     }
 }
 
     /// Falls back to the macro call range if the node cannot be mapped up fully.
     pub fn original_file_range(self, db: &dyn db::ExpandDatabase) -> FileRange {
         match self.file_id {
-            HirFileId::FileId(file_id) => FileRange {
-                file_id,
-                range: self.value.text_range(),
-            },
+            HirFileId::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },
             HirFileId::MacroFile(mac_file) => {
+                // FIXME: Figure out an API that makes proper use of ctx, this only exists to
+                // keep pre-token map rewrite behaviour.
+                // Fall back to whole macro call.
                 let (range, ctxt) = span_for_offset(
                     db,
                     &db.expansion_span_map(mac_file),
                     self.value.text_range().start(),
                 );
-
-                // FIXME: Figure out an API that makes proper use of ctx, this only exists to
-                // keep pre-token map rewrite behaviour.
                 if ctxt.is_root() {
                     return range;
                 }
-
-                // Fall back to whole macro call.
                 let loc = db.lookup_intern_macro_call(mac_file);
                 loc.kind.original_call_range(db)
             }
     /// Attempts to map the syntax node back up its macro calls.
     pub fn original_file_range_opt(self, db: &dyn db::ExpandDatabase) -> Option<FileRange> {
         match self.file_id {
-            HirFileId::FileId(file_id) => Some(FileRange {
-                file_id,
-                range: self.value.text_range(),
-            }),
+            HirFileId::FileId(file_id) => {
+                Some(FileRange { file_id, range: self.value.text_range() })
+            }
             HirFileId::MacroFile(mac_file) => {
+                // FIXME: Figure out an API that makes proper use of ctx, this only exists to
+                // keep pre-token map rewrite behaviour.
                 let (range, ctxt) = span_for_offset(
                     db,
                     &db.expansion_span_map(mac_file),
                     self.value.text_range().start(),
                 );
-
-                // FIXME: Figure out an API that makes proper use of ctx, this only exists to
-                // keep pre-token map rewrite behaviour.
                 if ctxt.is_root() {
                     Some(range)
                 } else {
         db: &dyn db::ExpandDatabase,
     ) -> (FileRange, SyntaxContext) {
         match self.file_id {
-            HirFileId::FileId(file_id) => (
-                FileRange {
-                    file_id,
-                    range: self.value,
-                },
-                SyntaxContext::root(file_id.edition(db)),
-            ),
+            HirFileId::FileId(file_id) => {
+                (FileRange { file_id, range: self.value }, SyntaxContext::root(file_id.edition(db)))
+            }
             HirFileId::MacroFile(mac_file) => {
                 match map_node_range_up(db, &db.expansion_span_map(mac_file), self.value) {
                     Some(it) => it,
                     None => {
                         let loc = db.lookup_intern_macro_call(mac_file);
-                        (
-                            loc.kind.original_call_range(db),
-                            SyntaxContext::root(loc.def.edition),
-                        )
+                        (loc.kind.original_call_range(db), SyntaxContext::root(loc.def.edition))
                     }
                 }
             }
 
     pub fn original_node_file_range_rooted(self, db: &dyn db::ExpandDatabase) -> FileRange {
         match self.file_id {
-            HirFileId::FileId(file_id) => FileRange {
-                file_id,
-                range: self.value,
-            },
+            HirFileId::FileId(file_id) => FileRange { file_id, range: self.value },
             HirFileId::MacroFile(mac_file) => {
                 match map_node_range_up_rooted(db, &db.expansion_span_map(mac_file), self.value) {
                     Some(it) => it,
         db: &dyn db::ExpandDatabase,
     ) -> FileRange {
         match self.file_id {
-            HirFileId::FileId(file_id) => FileRange {
-                file_id,
-                range: self.value,
-            },
+            HirFileId::FileId(file_id) => FileRange { file_id, range: self.value },
             HirFileId::MacroFile(mac_file) => {
                 match map_node_range_up_rooted(db, &db.expansion_span_map(mac_file), self.value) {
                     Some(it) => it,
     ) -> Option<(FileRange, SyntaxContext)> {
         match self.file_id {
             HirFileId::FileId(file_id) => Some((
-                FileRange {
-                    file_id,
-                    range: self.value,
-                },
+                FileRange { file_id, range: self.value },
                 SyntaxContext::root(file_id.edition(db)),
             )),
             HirFileId::MacroFile(mac_file) => {
         db: &dyn db::ExpandDatabase,
     ) -> Option<FileRange> {
         match self.file_id {
-            HirFileId::FileId(file_id) => Some(FileRange {
-                file_id,
-                range: self.value,
-            }),
+            HirFileId::FileId(file_id) => Some(FileRange { file_id, range: self.value }),
             HirFileId::MacroFile(mac_file) => {
                 map_node_range_up_rooted(db, &db.expansion_span_map(mac_file), self.value)
             }
         // as we don't have node inputs otherwise and therefore can't find an `N` node in the input
         let file_id = match self.file_id {
             HirFileId::FileId(file_id) => {
-                return Some(InRealFile {
-                    file_id,
-                    value: self.value,
-                });
+                return Some(InRealFile { file_id, value: self.value });
             }
             HirFileId::MacroFile(m) => m,
         };
             return None;
         }
 
-        let FileRange {
-            file_id: editioned_file_id,
-            range,
-        } = map_node_range_up_rooted(
+        let FileRange { file_id: editioned_file_id, range } = map_node_range_up_rooted(
             db,
             &db.expansion_span_map(file_id),
             self.value.syntax().text_range(),
         )?;
 
         // FIXME: This heuristic is brittle and with the right macro may select completely unrelated nodes?
-        let anc = db
-            .parse(editioned_file_id)
-            .syntax_node()
-            .covering_element(range);
+
+        let anc = db.parse(editioned_file_id).syntax_node().covering_element(range);
         let value = anc.ancestors().find_map(N::cast)?;
         Some(InRealFile::new(editioned_file_id, value))
     }
 impl<T> InFile<T> {
     pub fn into_real_file(self) -> Result<InRealFile<T>, InFile<T>> {
         match self.file_id {
-            HirFileId::FileId(file_id) => Ok(InRealFile {
-                file_id,
-                value: self.value,
-            }),
+            HirFileId::FileId(file_id) => Ok(InRealFile { file_id, value: self.value }),
             HirFileId::MacroFile(_) => Err(self),
         }
     }