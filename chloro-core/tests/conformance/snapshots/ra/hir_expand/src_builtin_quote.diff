COMPARISON DIFF
============================================================

Original size: 12531 bytes
Chloro size:   12525 bytes
Rustfmt size:  12665 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! A simplified version of quote-crate like quasi quote macro
+
 #![allow(clippy::crate_in_macro_def)]
 
 use intern::{sym, Symbol};
 use crate::{name::Name, tt::TopSubtreeBuilder};
 
 pub(crate) fn dollar_crate(span: Span) -> tt::Ident<Span> {
-    tt::Ident {
-        sym: sym::dollar_crate,
-        span,
-        is_raw: tt::IdentIsRaw::No,
-    }
+    tt::Ident { sym: sym::dollar_crate, span, is_raw: tt::IdentIsRaw::No }
 }
 
 // A helper macro quote macro
         )*
     }
 }
+
 impl<T: ToTokenTree + Clone> ToTokenTree for &T {
     fn to_tokens(self, span: Span, builder: &mut TopSubtreeBuilder) {
         self.clone().to_tokens(span, builder);
     use intern::Symbol;
     use span::{Edition, SpanAnchor, SyntaxContext, ROOT_ERASED_FILE_AST_ID};
     use syntax::{TextRange, TextSize};
-
     const DUMMY: tt::Span = tt::Span {
         range: TextRange::empty(TextSize::new(0)),
         anchor: SpanAnchor {
         },
         ctx: SyntaxContext::root(Edition::CURRENT),
     };
-
     #[test]
     fn test_quote_delimiters() {
         assert_eq!(quote!(DUMMY =>{}).to_string(), "{}");
         assert_eq!(quote!(DUMMY =>()).to_string(), "()");
         assert_eq!(quote!(DUMMY =>[]).to_string(), "[]");
     }
-
     #[test]
     fn test_quote_idents() {
         assert_eq!(quote!(DUMMY =>32).to_string(), "32");
         assert_eq!(quote!(DUMMY =>struct).to_string(), "struct");
     }
-
     #[test]
     fn test_quote_hash_simple_literal() {
         let a = 20;
         let s: String = "hello".into();
         assert_eq!(quote!(DUMMY =>#s).to_string(), "\"hello\"");
     }
-
     fn mk_ident(name: &str) -> crate::tt::Ident {
         let (is_raw, s) = IdentIsRaw::split_from_symbol(name);
-        crate::tt::Ident {
-            sym: Symbol::intern(s),
-            span: DUMMY,
-            is_raw,
-        }
+        crate::tt::Ident { sym: Symbol::intern(s), span: DUMMY, is_raw }
     }
-
     #[test]
     fn test_quote_hash_token_tree() {
         let a = mk_ident("hello");
               IDENT   hello 937550:Root[0000, 0]@0..0#ROOT2024"#]]
         .assert_eq(&t);
     }
-
     #[test]
     fn test_quote_simple_derive_copy() {
         let name = mk_ident("Foo");
             }
         };
 
-        assert_eq!(
-            quoted.to_string(),
-            "impl Clone for Foo {fn clone (& self) -> Self {Self {}}}"
-        );
+        assert_eq!(quoted.to_string(), "impl Clone for Foo {fn clone (& self) -> Self {Self {}}}");
     }
-
     #[test]
     fn test_quote_derive_copy_hack() {
         // Assume the given struct is:
         // }
         let struct_name = mk_ident("Foo");
         let fields = [mk_ident("name"), mk_ident("id")];
-        let fields = fields
-            .iter()
-            .map(|it| quote!(DUMMY =>#it: self.#it.clone(), ));
+        let fields = fields.iter().map(|it| quote!(DUMMY =>#it: self.#it.clone(), ));
 
         let mut builder = tt::TopSubtreeBuilder::new(crate::tt::Delimiter {
             kind: crate::tt::DelimiterKind::Brace,