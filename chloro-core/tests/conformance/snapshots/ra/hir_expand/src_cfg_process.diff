COMPARISON DIFF
============================================================

Original size: 14552 bytes
Chloro size:   14421 bytes
Rustfmt size:  14552 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Processes out #[cfg] and #[cfg_attr] attributes from the input for the derive macro
+
 use std::iter::Peekable;
 
 use base_db::Crate;
 
 use crate::{MacroCallLoc, MacroDefKind, db::ExpandDatabase, proc_macro::ProcMacroKind};
 
-fn check_cfg(db: &dyn ExpandDatabase, attr: &Attr, krate: Crate) -> Option<bool> {
+fn check_cfg(
+    db: &dyn ExpandDatabase,
+    attr: &Attr,
+    krate: Crate,
+) -> Option<bool> {
     if !attr.simple_name().as_deref().map(|v| v == "cfg")? {
         return None;
     }
     Some(enabled)
 }
 
-fn check_cfg_attr(db: &dyn ExpandDatabase, attr: &Attr, krate: Crate) -> Option<bool> {
+fn check_cfg_attr(
+    db: &dyn ExpandDatabase,
+    attr: &Attr,
+    krate: Crate,
+) -> Option<bool> {
     if !attr.simple_name().as_deref().map(|v| v == "cfg_attr")? {
         return None;
     }
     /// Found the comma after the CFGExpr. Will keep all tokens until the next comma or the end of the attribute
     FoundComma,
     /// Everything following the attribute. This could be another attribute or the end of the attribute.
-    // FIXME: cfg_attr with multiple attributes will not be handled correctly. We will only keep the first attribute
-    // Related Issue: https://github.com/rust-lang/rust-analyzer/issues/10110
     EverythingElse,
 }
 
     let meta_path = meta.path()?;
     debug!("Removing {:?}", meta_path.syntax());
     remove.insert(meta_path.syntax().clone().into());
-
     let meta_tt = meta.token_tree()?;
     debug!("meta_tt {}", meta_tt);
     let mut stage = CfgExprStage::StrippigCfgExpr;
     }
     Some(remove)
 }
+
 /// Removes a possible comma after the [AstNode]
-fn remove_possible_comma(item: &impl AstNode, res: &mut FxHashSet<SyntaxElement>) {
+fn remove_possible_comma(
+    item: &impl AstNode,
+    res: &mut FxHashSet<SyntaxElement>,
+) {
     if let Some(comma) = item.syntax().next_sibling_or_token().filter(|it| it.kind() == T![,]) {
         res.insert(comma);
     }
 }
+
 fn process_enum(
     db: &dyn ExpandDatabase,
     variants: VariantList,
         _ => false,
     };
     let mut remove = FxHashSet::default();
-
     let item = ast::Item::cast(node.clone())?;
     for attr in item.attrs() {
         if let Some(enabled) = check_cfg_attr(db, &attr, loc.krate) {
             }
         }
     }
-
     if is_derive {
         // Only derives get their code cfg-clean, normal attribute macros process only the cfg at their level
         // (cfg_attr is handled above, cfg is handled in the def map).
     }
     Some(remove)
 }
+
 /// Parses a `cfg` attribute from the meta
 fn parse_from_attr_token_tree(tt: &TokenTree) -> Option<CfgExpr> {
     let mut iter = tt
 fn is_not_closing_paren(element: &NodeOrToken<ast::TokenTree, syntax::SyntaxToken>) -> bool {
     !matches!(element, NodeOrToken::Token(token) if (token.kind() == syntax::T![')']))
 }
+
 fn is_not_whitespace(element: &NodeOrToken<ast::TokenTree, syntax::SyntaxToken>) -> bool {
     !matches!(element, NodeOrToken::Token(token) if (token.kind() == SyntaxKind::WHITESPACE))
 }
 
 fn next_cfg_expr_from_syntax<I>(iter: &mut Peekable<I>) -> Option<CfgExpr>
 where
-    I: Iterator<Item = NodeOrToken<ast::TokenTree, syntax::SyntaxToken>>,
-{
+    I: Iterator<Item = NodeOrToken<ast::TokenTree, syntax::SyntaxToken>>, {
     let name = match iter.next() {
         None => return None,
         Some(NodeOrToken::Token(element)) => match element.kind() {
     }
     result
 }
+
 #[cfg(test)]
 mod tests {
     use cfg::DnfExpr;
     use expect_test::{Expect, expect};
     use syntax::{AstNode, SourceFile, ast::Attr};
-
     use crate::cfg_process::parse_from_attr_token_tree;
-
-    fn check_dnf_from_syntax(input: &str, expect: Expect) {
+    fn check_dnf_from_syntax(
+        input: &str,
+        expect: Expect,
+    ) {
         let parse = SourceFile::parse(input, span::Edition::CURRENT);
         let node = match parse.tree().syntax().descendants().find_map(Attr::cast) {
             Some(it) => it,
         };
         let node = node.clone_subtree();
         assert_eq!(node.syntax().text_range().start(), 0.into());
-
         let cfg = parse_from_attr_token_tree(&node.meta().unwrap().token_tree().unwrap()).unwrap();
         let actual = format!("#![cfg({})]", DnfExpr::new(&cfg));
         expect.assert_eq(&actual);