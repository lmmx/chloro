COMPARISON DIFF
============================================================

Original size: 6275 bytes
Chloro size:   6288 bytes
Rustfmt size:  6621 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Span maps for real files and macro expansions.
 
+pub use span::RealSpanMap;
 use span::{Span, SyntaxContext};
 use stdx::TupleExt;
 use syntax::{ast, AstNode, TextRange};
 use triomphe::Arc;
 
-pub use span::RealSpanMap;
-
 use crate::{attrs::collect_attrs, db::ExpandDatabase, HirFileId, MacroCallId};
 
 pub type ExpansionSpanMap = span::SpanMap<SyntaxContext>;
     // them again, something we might get access to in the future. But even then, proc-macros doing
     // this kind of joining makes them as stable as the AstIdMap (which is basically changing on
     // every input of the file)…
-
-    let item_to_entry = |item: ast::Item| {
-        (
-            item.syntax().text_range().start(),
-            ast_id_map.ast_id(&item).erase(),
-        )
-    };
+    let item_to_entry =
+        |item: ast::Item| (item.syntax().text_range().start(), ast_id_map.ast_id(&item).erase());
     // Top level items make for great anchors as they are the most stable and a decent boundary
     pairs.extend(tree.items().map(item_to_entry));
     // Unfortunately, assoc items are very common in Rust, so descend into those as well and make
         {
             if let Some(extern_item_list) = it.extern_item_list() {
                 pairs.extend(
-                    extern_item_list
-                        .extern_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
+                    extern_item_list.extern_items().map(ast::Item::from).map(item_to_entry),
                 );
             }
         }
         ast::Item::Impl(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
             if let Some(assoc_item_list) = it.assoc_item_list() {
-                pairs.extend(
-                    assoc_item_list
-                        .assoc_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
-                );
+                pairs.extend(assoc_item_list.assoc_items().map(ast::Item::from).map(item_to_entry));
             }
         }
         ast::Item::Module(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
         }
         ast::Item::Trait(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
             if let Some(assoc_item_list) = it.assoc_item_list() {
-                pairs.extend(
-                    assoc_item_list
-                        .assoc_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
-                );
+                pairs.extend(assoc_item_list.assoc_items().map(ast::Item::from).map(item_to_entry));
             }
         }
         _ => (),
     });
 
-    Arc::new(RealSpanMap::from_file(
+    Arc::new(
+        RealSpanMap::from_file(
         editioned_file_id.editioned_file_id(db),
         pairs.into_boxed_slice(),
         tree.syntax().text_range().end(),
-    ))
+    ),
+    )
 }
 
 pub(crate) fn expansion_span_map(