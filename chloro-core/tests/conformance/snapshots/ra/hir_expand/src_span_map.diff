COMPARISON DIFF
============================================================

Original size: 6275 bytes
Chloro size:   6282 bytes
Rustfmt size:  6621 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Span maps for real files and macro expansions.
 
+pub use span::RealSpanMap;
 use span::{Span, SyntaxContext};
 use stdx::TupleExt;
 use syntax::{ast, AstNode, TextRange};
 use triomphe::Arc;
 
-pub use span::RealSpanMap;
-
 use crate::{attrs::collect_attrs, db::ExpandDatabase, HirFileId, MacroCallId};
 
 pub type ExpansionSpanMap = span::SpanMap<SyntaxContext>;
     // them again, something we might get access to in the future. But even then, proc-macros doing
     // this kind of joining makes them as stable as the AstIdMap (which is basically changing on
     // every input of the file)…
-
-    let item_to_entry = |item: ast::Item| {
-        (
-            item.syntax().text_range().start(),
-            ast_id_map.ast_id(&item).erase(),
-        )
-    };
+    let item_to_entry =
+        |item: ast::Item| (item.syntax().text_range().start(), ast_id_map.ast_id(&item).erase());
     // Top level items make for great anchors as they are the most stable and a decent boundary
     pairs.extend(tree.items().map(item_to_entry));
     // Unfortunately, assoc items are very common in Rust, so descend into those as well and make
     // them anchors too, but only if they have no attributes attached, as those might be proc-macros
     // and using different anchors inside of them will prevent spans from being joinable.
-    tree.items().for_each(|item| match &item {
+    tree.items()
+        .for_each(|item| match &item {
         ast::Item::ExternBlock(it)
             if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) =>
         {
             if let Some(extern_item_list) = it.extern_item_list() {
                 pairs.extend(
-                    extern_item_list
-                        .extern_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
+                    extern_item_list.extern_items().map(ast::Item::from).map(item_to_entry),
                 );
             }
         }
         ast::Item::Impl(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
             if let Some(assoc_item_list) = it.assoc_item_list() {
-                pairs.extend(
-                    assoc_item_list
-                        .assoc_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
-                );
+                pairs.extend(assoc_item_list.assoc_items().map(ast::Item::from).map(item_to_entry));
             }
         }
         ast::Item::Module(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
         }
         ast::Item::Trait(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
             if let Some(assoc_item_list) = it.assoc_item_list() {
-                pairs.extend(
-                    assoc_item_list
-                        .assoc_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
-                );
+                pairs.extend(assoc_item_list.assoc_items().map(ast::Item::from).map(item_to_entry));
             }
         }
         _ => (),