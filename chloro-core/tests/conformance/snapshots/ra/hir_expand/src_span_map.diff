COMPARISON DIFF
============================================================

Original size: 6275 bytes
Chloro size:   5900 bytes
Rustfmt size:  6621 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Span maps for real files and macro expansions.
 
+pub use span::RealSpanMap;
 use span::{Span, SyntaxContext};
 use stdx::TupleExt;
 use syntax::{ast, AstNode, TextRange};
 use triomphe::Arc;
 
-pub use span::RealSpanMap;
-
 use crate::{attrs::collect_attrs, db::ExpandDatabase, HirFileId, MacroCallId};
 
 pub type ExpansionSpanMap = span::SpanMap<SyntaxContext>;
 impl SpanMap {
     pub fn span_for_range(&self, range: TextRange) -> Span {
         match self {
-            // FIXME: Is it correct for us to only take the span at the start? This feels somewhat
-            // wrong. The context will be right, but the range could be considered wrong. See
-            // https://github.com/rust-lang/rust/issues/23480, we probably want to fetch the span at
-            // the start and end, then merge them like rustc does in `Span::to
             Self::ExpansionSpanMap(span_map) => span_map.span_at(range.start()),
             Self::RealSpanMap(span_map) => span_map.span_for_range(range),
         }
     // them again, something we might get access to in the future. But even then, proc-macros doing
     // this kind of joining makes them as stable as the AstIdMap (which is basically changing on
     // every input of the file)…
-
-    let item_to_entry = |item: ast::Item| {
-        (
-            item.syntax().text_range().start(),
-            ast_id_map.ast_id(&item).erase(),
-        )
-    };
+    let item_to_entry =
+        |item: ast::Item| (item.syntax().text_range().start(), ast_id_map.ast_id(&item).erase());
     // Top level items make for great anchors as they are the most stable and a decent boundary
     pairs.extend(tree.items().map(item_to_entry));
     // Unfortunately, assoc items are very common in Rust, so descend into those as well and make
         {
             if let Some(extern_item_list) = it.extern_item_list() {
                 pairs.extend(
-                    extern_item_list
-                        .extern_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
+                    extern_item_list.extern_items().map(ast::Item::from).map(item_to_entry),
                 );
             }
         }
         ast::Item::Impl(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
             if let Some(assoc_item_list) = it.assoc_item_list() {
-                pairs.extend(
-                    assoc_item_list
-                        .assoc_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
-                );
+                pairs.extend(assoc_item_list.assoc_items().map(ast::Item::from).map(item_to_entry));
             }
         }
         ast::Item::Module(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
         }
         ast::Item::Trait(it) if !collect_attrs(it).map(TupleExt::tail).any(|it| it.is_left()) => {
             if let Some(assoc_item_list) = it.assoc_item_list() {
-                pairs.extend(
-                    assoc_item_list
-                        .assoc_items()
-                        .map(ast::Item::from)
-                        .map(item_to_entry),
-                );
+                pairs.extend(assoc_item_list.assoc_items().map(ast::Item::from).map(item_to_entry));
             }
         }
         _ => (),