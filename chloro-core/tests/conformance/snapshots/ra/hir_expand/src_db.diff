COMPARISON DIFF
============================================================

Original size: 32207 bytes
Chloro size:   31937 bytes
Rustfmt size:  33429 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     EagerExpander, EditionedFileId, ExpandError, ExpandResult, ExpandTo, HirFileId, MacroCallId,
     MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind,
 };
+
 /// This is just to ensure the types of smart_macro_arg and macro_arg are the same
 type MacroArgResult = (Arc<tt::TopSubtree>, SyntaxFixupUndoInfo, Span);
+
 /// Total limit on the number of tokens produced by any macro invocation.
 ///
 /// If an invocation produces more tokens than this limit, it will not be stored in the database and
 }
 
 #[query_group::query_group]
-pub trait ExpandDatabase: RootQueryDb {
+pub trait ExpandDatabase {
     /// The proc macros. Do not use this! Use `proc_macros_for_crate()` instead.
     #[salsa::input]
     fn proc_macros(&self) -> Arc<ProcMacros>;
     #[salsa::transparent]
     #[salsa::invoke(crate::span_map::expansion_span_map)]
     fn expansion_span_map(&self, file_id: MacroCallId) -> Arc<ExpansionSpanMap>;
+
     #[salsa::invoke(crate::span_map::real_span_map)]
     fn real_span_map(&self, file_id: EditionedFileId) -> Arc<RealSpanMap>;
 
     /// to be incremental.
     #[salsa::transparent]
     fn intern_macro_call(&self, macro_call: MacroCallLoc) -> MacroCallId;
+
     #[salsa::transparent]
     fn lookup_intern_macro_call(&self, macro_call: MacroCallId) -> MacroCallLoc;
 
     /// @edwin0cheng heroically debugged this once! See #4315 for details
     #[salsa::invoke(expand_proc_macro)]
     fn expand_proc_macro(&self, call: MacroCallId) -> ExpandResult<Arc<tt::TopSubtree>>;
+
     /// Retrieves the span to be used for a proc-macro expansions spans.
     /// This is a firewall query as it requires parsing the file, which we don't want proc-macros to
     /// directly depend on as that would cause to frequent invalidations, mainly because of the
             ),
             SyntaxFixupUndoInfo::NONE,
         ),
-        MacroCallKind::Derive {
-            derive_attr_index: index,
-            ..
-        }
-        | MacroCallKind::Attr {
-            invoc_attr_index: index,
-            ..
-        } => {
+        MacroCallKind::Derive { derive_attr_index: index, .. }
+        | MacroCallKind::Attr { invoc_attr_index: index, .. } => {
             let censor = if let MacroCallKind::Derive { .. } = loc.kind {
                 censor_derive_input(index, &ast::Adt::cast(speculative_args.clone())?)
             } else {
     };
 
     let attr_arg = match loc.kind {
-        MacroCallKind::Attr {
-            invoc_attr_index, ..
-        } => {
+        MacroCallKind::Attr { invoc_attr_index, .. } => {
             if loc.def.is_attribute_derive() {
                 // for pseudo-derive expansion we actually pass the attribute itself only
-                ast::Attr::cast(speculative_args.clone())
-                    .and_then(|attr| attr.token_tree())
-                    .map(|token_tree| {
+                ast::Attr::cast(speculative_args.clone()).and_then(|attr| attr.token_tree()).map(
+                    |token_tree| {
                         let mut tree = syntax_node_to_token_tree(
                             token_tree.syntax(),
                             span_map,
                         );
                         *tree.top_subtree_delimiter_mut() = tt::Delimiter::invisible_spanned(span);
                         tree
-                    })
+                    },
+                )
             } else {
                 // Attributes may have an input token tree, build the subtree and map for this as well
                 // then try finding a token id for our token if it is inside this input subtree.
                 let item = ast::Item::cast(speculative_args.clone())?;
                 let attrs = RawAttrs::new_expanded(db, &item, span_map, loc.krate.cfg_options(db));
-                attrs
-                    .iter()
-                    .find(|attr| attr.id == invoc_attr_index)
-                    .and_then(|attr| match attr.input.as_deref()? {
+                attrs.iter().find(|attr| attr.id == invoc_attr_index).and_then(|attr| {
+                    match attr.input.as_deref()? {
                         AttrInput::TokenTree(tt) => {
                             let mut attr_arg = tt.clone();
                             attr_arg.top_subtree_delimiter_mut().kind =
                             Some(attr_arg)
                         }
                         AttrInput::Literal(_) => None,
-                    })
+                    }
+                })
             }
         }
         _ => None,
     };
 
     // Do the actual expansion, we need to directly expand the proc macro due to the attribute args
+
     // Otherwise the expand query will fetch the non speculative attribute args and pass those instead.
     let mut speculative_expansion = match loc.def.kind {
         MacroDefKind::ProcMacro(ast, expander, _) => {
             pseudo_derive_attr_expansion(&tt, attr_arg.as_ref()?, span)
         }
         MacroDefKind::Declarative(it) => {
-            db.decl_macro_expander(loc.krate, it)
-                .expand_unhygienic(tt, span, loc.def.edition)
+            db.decl_macro_expander(loc.krate, it).expand_unhygienic(tt, span, loc.def.edition)
+        }
+        MacroDefKind::BuiltIn(_, it) => {
+            it.expand(db, actual_macro_call, &tt, span).map_err(Into::into)
+        }
+        MacroDefKind::BuiltInDerive(_, it) => {
+            it.expand(db, actual_macro_call, &tt, span).map_err(Into::into)
+        }
+        MacroDefKind::BuiltInEager(_, it) => {
+            it.expand(db, actual_macro_call, &tt, span).map_err(Into::into)
         }
-        MacroDefKind::BuiltIn(_, it) => it
-            .expand(db, actual_macro_call, &tt, span)
-            .map_err(Into::into),
-        MacroDefKind::BuiltInDerive(_, it) => it
-            .expand(db, actual_macro_call, &tt, span)
-            .map_err(Into::into),
-        MacroDefKind::BuiltInEager(_, it) => it
-            .expand(db, actual_macro_call, &tt, span)
-            .map_err(Into::into),
         MacroDefKind::BuiltInAttr(_, it) => it.expand(db, actual_macro_call, &tt, span),
     };
 
     let syntax_node = node.syntax_node();
     let token = rev_tmap
         .ranges_with_span(span_map.span_for_range(token_to_map.text_range()))
-        .filter_map(|(range, ctx)| {
-            syntax_node
-                .covering_element(range)
-                .into_token()
-                .zip(Some(ctx))
-        })
+        .filter_map(|(range, ctx)| syntax_node.covering_element(range).into_token().zip(Some(ctx)))
         .map(|(t, ctx)| {
             // prefer tokens of the same kind and text, as well as non opaque marked ones
             // Note the inversion of the score here, as we want to prefer the first token in case
     }
 }
 
-// FIXME: We should verify that the parsed node is one of the many macro node variants we expect
-// instead of having it be untyped
 fn parse_macro_expansion(
     db: &dyn ExpandDatabase,
     macro_file: MacroCallId,
     let loc = db.lookup_intern_macro_call(macro_file);
     let def_edition = loc.def.edition;
     let expand_to = loc.expand_to();
-    let mbe::ValueResult {
-        value: (tt, matched_arm),
-        err,
-    } = macro_expand(db, macro_file, loc);
+    let mbe::ValueResult { value: (tt, matched_arm), err } = macro_expand(db, macro_file, loc);
 
     let (parse, mut rev_token_map) = token_tree_to_syntax_node(
         db,
     );
     rev_token_map.matched_arm = matched_arm;
 
-    ExpandResult {
-        value: (parse, Arc::new(rev_token_map)),
-        err,
-    }
+    ExpandResult { value: (parse, Arc::new(rev_token_map)), err }
 }
 
 fn parse_macro_expansion_error(
     db: &dyn ExpandDatabase,
     macro_call_id: MacroCallId,
 ) -> Option<Arc<ExpandResult<Arc<[SyntaxError]>>>> {
-    let e: ExpandResult<Arc<[SyntaxError]>> = db
-        .parse_macro_expansion(macro_call_id)
-        .map(|it| Arc::from(it.0.errors()));
-    if e.value.is_empty() && e.err.is_none() {
-        None
-    } else {
-        Some(Arc::new(e))
-    }
+    let e: ExpandResult<Arc<[SyntaxError]>> =
+        db.parse_macro_expansion(macro_call_id).map(|it| Arc::from(it.0.errors()));
+    if e.value.is_empty() && e.err.is_none() { None } else { Some(Arc::new(e)) }
 }
 
 pub(crate) fn parse_with_map(
     file_id: HirFileId,
 ) -> (Parse<SyntaxNode>, SpanMap) {
     match file_id {
-        HirFileId::FileId(file_id) => (
-            db.parse(file_id).to_syntax(),
-            SpanMap::RealSpanMap(db.real_span_map(file_id)),
-        ),
+        HirFileId::FileId(file_id) => {
+            (db.parse(file_id).to_syntax(), SpanMap::RealSpanMap(db.real_span_map(file_id)))
+        }
         HirFileId::MacroFile(macro_file) => {
             let (parse, map) = db.parse_macro_expansion(macro_file).value;
             (parse, SpanMap::ExpansionSpanMap(map))
 /// Other wise return the [macro_arg] for the macro_call_id.
 ///
 /// This is not connected to the database so it does not cached the result. However, the inner [macro_arg] query is
-#[allow(deprecated)] // we are macro_arg_considering_derives
+#[allow(deprecated)]
 fn macro_arg_considering_derives(
     db: &dyn ExpandDatabase,
     id: MacroCallId,
 ) -> MacroArgResult {
     match kind {
         // Get the macro arg for the derive macro
-        MacroCallKind::Derive {
-            derive_macro_id, ..
-        } => db.macro_arg(*derive_macro_id),
+        MacroCallKind::Derive { derive_macro_id, .. } => db.macro_arg(*derive_macro_id),
         // Normal macro arg
         _ => db.macro_arg(id),
     }
     let loc = db.lookup_intern_macro_call(id);
 
     if let MacroCallLoc {
-        def: MacroDefId {
-            kind: MacroDefKind::BuiltInEager(..),
-            ..
-        },
-        kind: MacroCallKind::FnLike {
-            eager: Some(eager), ..
-        },
+        def: MacroDefId { kind: MacroDefKind::BuiltInEager(..), .. },
+        kind: MacroCallKind::FnLike { eager: Some(eager), .. },
         ..
     } = &loc
     {
     let (censor, item_node, span) = match loc.kind {
         MacroCallKind::FnLike { ast_id, .. } => {
             let node = &ast_id.to_ptr(db).to_node(&root);
-            let path_range = node.path().map_or_else(
-                || node.syntax().text_range(),
-                |path| path.syntax().text_range(),
-            );
+            let path_range = node
+                .path()
+                .map_or_else(|| node.syntax().text_range(), |path| path.syntax().text_range());
             let span = map.span_for_range(path_range);
 
             let dummy_tt = |kind| {
                 (
                     Arc::new(tt::TopSubtree::from_token_trees(
-                        tt::Delimiter {
-                            open: span,
-                            close: span,
-                            kind,
-                        },
+                        tt::Delimiter { open: span, close: span, kind },
                         tt::TokenTreesView::new(&[]),
                     )),
                     SyntaxFixupUndoInfo::default(),
             let Some(tt) = node.token_tree() else {
                 return dummy_tt(tt::DelimiterKind::Invisible);
             };
-            let first = tt
-                .left_delimiter_token()
-                .map(|it| it.kind())
-                .unwrap_or(T!['(']);
-            let last = tt
-                .right_delimiter_token()
-                .map(|it| it.kind())
-                .unwrap_or(T![.]);
+            let first = tt.left_delimiter_token().map(|it| it.kind()).unwrap_or(T!['(']);
+            let last = tt.right_delimiter_token().map(|it| it.kind()).unwrap_or(T![.]);
 
             let mismatched_delimiters = !matches!(
                 (first, last),
         MacroCallKind::Derive { .. } => {
             unreachable!("`ExpandDatabase::macro_arg` called with `MacroCallKind::Derive`")
         }
-        MacroCallKind::Attr {
-            ast_id,
-            invoc_attr_index,
-            ..
-        } => {
+        MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {
             let node = ast_id.to_ptr(db).to_node(&root);
             let attr_source = attr_source(invoc_attr_index, &node);
 
                 let censor_derive_input = censor_derive_input(invoc_attr_index, &adt);
                 (censor_derive_input, node, span)
             } else {
-                (
-                    attr_source
-                        .into_iter()
-                        .map(|it| it.syntax().clone().into())
-                        .collect(),
-                    node,
-                    span,
-                )
+                (attr_source.into_iter().map(|it| it.syntax().clone().into()).collect(), node, span)
             }
         }
     };
     (Arc::new(tt), undo_info, span)
 }
 
-// FIXME: Censoring info should be calculated by the caller! Namely by name resolution
 /// Derives expect all `#[derive(..)]` invocations up to (and including) the currently invoked one to be stripped
 fn censor_derive_input(derive_attr_index: AttrId, node: &ast::Adt) -> FxHashSet<SyntaxElement> {
     // FIXME: handle `cfg_attr`
 fn attr_source(invoc_attr_index: AttrId, node: &ast::Item) -> Option<ast::Attr> {
     // FIXME: handle `cfg_attr`
     cov_mark::hit!(attribute_macro_attr_censoring);
-    collect_attrs(node)
-        .nth(invoc_attr_index.ast_index())
-        .and_then(|(_, attr)| Either::left(attr))
+    collect_attrs(node).nth(invoc_attr_index.ast_index()).and_then(|(_, attr)| Either::left(attr))
 }
 
 impl TokenExpander {
 ) -> ExpandResult<(CowArc<tt::TopSubtree>, MatchedArmIndex)> {
     let _p = tracing::info_span!("macro_expand").entered();
 
-    let (
-        ExpandResult {
-            value: (tt, matched_arm),
-            err,
-        },
-        span,
-    ) = match loc.def.kind {
+    let (ExpandResult { value: (tt, matched_arm), err }, span) = match loc.def.kind {
         MacroDefKind::ProcMacro(..) => {
-            return db
-                .expand_proc_macro(macro_call_id)
-                .map(CowArc::Arc)
-                .zip_val(None);
+            return db.expand_proc_macro(macro_call_id).map(CowArc::Arc).zip_val(None);
         }
         _ => {
             let (macro_arg, undo_info, span) =
                     MacroDefKind::Declarative(id) => db
                         .decl_macro_expander(loc.def.krate, id)
                         .expand(db, arg.clone(), macro_call_id, span),
-                    MacroDefKind::BuiltIn(_, it) => it
-                        .expand(db, macro_call_id, arg, span)
-                        .map_err(Into::into)
-                        .zip_val(None),
-                    MacroDefKind::BuiltInDerive(_, it) => it
-                        .expand(db, macro_call_id, arg, span)
-                        .map_err(Into::into)
-                        .zip_val(None),
+                    MacroDefKind::BuiltIn(_, it) => {
+                        it.expand(db, macro_call_id, arg, span).map_err(Into::into).zip_val(None)
+                    }
+                    MacroDefKind::BuiltInDerive(_, it) => {
+                        it.expand(db, macro_call_id, arg, span).map_err(Into::into).zip_val(None)
+                    }
                     MacroDefKind::BuiltInEager(_, it) => {
                         // This might look a bit odd, but we do not expand the inputs to eager macros here.
                         // Eager macros inputs are expanded, well, eagerly when we collect the macro calls.
                                 return ExpandResult::ok(CowArc::Arc(macro_arg.clone()))
                                     .zip_val(None);
                             }
-                            MacroCallKind::FnLike {
-                                eager: Some(eager), ..
-                            } => Some(&**eager),
+                            MacroCallKind::FnLike { eager: Some(eager), .. } => Some(&**eager),
                             _ => None,
                         };
 
                     }
                     MacroDefKind::ProcMacro(_, _, _) => unreachable!(),
                 };
-            (
-                ExpandResult {
-                    value: res.value,
-                    err: res.err,
-                },
-                span,
-            )
+            (ExpandResult { value: res.value, err: res.err }, span)
         }
     };
 
         }
     }
 
-    ExpandResult {
-        value: (CowArc::Owned(tt), matched_arm),
-        err,
-    }
+    ExpandResult { value: (CowArc::Owned(tt), matched_arm), err }
 }
 
 fn proc_macro_span(db: &dyn ExpandDatabase, ast: AstId<ast::Fn>) -> Span {
     let span_map = &db.span_map(ast.file_id);
 
     let node = ast_id_map.get(ast.value).to_node(&root);
-    let range = ast::HasName::name(&node).map_or_else(
-        || node.syntax().text_range(),
-        |name| name.syntax().text_range(),
-    );
+    let range = ast::HasName::name(&node)
+        .map_or_else(|| node.syntax().text_range(), |name| name.syntax().text_range());
     span_map.span_for_range(range)
 }
 
     };
 
     let attr_arg = match &loc.kind {
-        MacroCallKind::Attr {
-            attr_args: Some(attr_args),
-            ..
-        } => Some(&**attr_args),
+        MacroCallKind::Attr { attr_args: Some(attr_args), .. } => Some(&**attr_args),
         _ => None,
     };
 
 
     fixup::reverse_fixups(&mut tt, &undo_info);
 
-    ExpandResult {
-        value: Arc::new(tt),
-        err,
-    }
+    ExpandResult { value: Arc::new(tt), err }
 }
 
 pub(crate) fn token_tree_to_syntax_node(