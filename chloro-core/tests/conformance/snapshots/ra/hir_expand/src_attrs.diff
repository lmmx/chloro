COMPARISON DIFF
============================================================

Original size: 16886 bytes
Chloro size:   16574 bytes
Rustfmt size:  17571 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! A higher level attributes based on TokenTree, with also some shortcuts.
+
 use std::iter;
 use std::{borrow::Cow, fmt, ops};
 
 use base_db::Crate;
 use cfg::{CfgExpr, CfgOptions};
 use either::Either;
-use intern::{sym, Interned, Symbol};
-
+use intern::{Interned, Symbol, sym};
 use mbe::{DelimiterKind, Punct};
-use smallvec::{smallvec, SmallVec};
+use smallvec::{SmallVec, smallvec};
 use span::{Span, SyntaxContext};
 use syntax::unescape;
-use syntax::{ast, match_ast, AstNode, AstToken, SyntaxNode};
-use syntax_bridge::{desugar_doc_comment_text, syntax_node_to_token_tree, DocCommentDesugarMode};
+use syntax::{AstNode, AstToken, SyntaxNode, ast, match_ast};
+use syntax_bridge::{DocCommentDesugarMode, desugar_doc_comment_text, syntax_node_to_token_tree};
 use triomphe::ThinArc;
 
 use crate::{
-    db::ExpandDatabase,
-    mod_path::ModPath,
-    name::Name,
-    span_map::SpanMapRef,
-    tt::{self, token_to_literal, TopSubtree},
+    db::ExpandDatabase, mod_path::ModPath, name::Name, span_map::SpanMapRef,
+    tt::{self, TopSubtree, token_to_literal},
 };
 
 /// Syntactical attributes, without filtering of `cfg_attr`s.
 #[derive(Default, Debug, Clone, PartialEq, Eq)]
 pub struct RawAttrs {
-    // FIXME: This can become `Box<[Attr]>` if https://internals.rust-lang.org/t/layout-of-dst-box/21728?u=chrefr is accepted.
     entries: Option<ThinArc<(), Attr>>,
 }
 
         span_map: SpanMapRef<'_>,
     ) -> Self {
         let entries: Vec<_> = Self::attrs_iter::<true>(db, owner, span_map).collect();
-
         let entries = if entries.is_empty() {
             None
         } else {
             Some(ThinArc::from_header_and_iter((), entries.into_iter()))
         };
-
         RawAttrs { entries }
     }
 
     ) -> Self {
         let entries: Vec<_> =
             Self::attrs_iter_expanded::<true>(db, owner, span_map, cfg_options).collect();
-
         let entries = if entries.is_empty() {
             None
         } else {
             Some(ThinArc::from_header_and_iter((), entries.into_iter()))
         };
-
         RawAttrs { entries }
     }
 
         span_map: SpanMapRef<'_>,
     ) -> impl Iterator<Item = Attr> {
         collect_attrs(owner).filter_map(move |(id, attr)| match attr {
-            Either::Left(attr) => attr
-                .meta()
-                .and_then(|meta| Attr::from_src(db, meta, span_map, id)),
+            Either::Left(attr) => {
+                attr.meta().and_then(|meta| Attr::from_src(db, meta, span_map, id))
+            }
             Either::Right(comment) if DESUGAR_COMMENTS => comment.doc_comment().map(|doc| {
                 let span = span_map.span_for_range(comment.syntax().text_range());
                 let (text, kind) = desugar_doc_comment_text(doc, DocCommentDesugarMode::ProcMacro);
             .flat_map(|attr| attr.expand_cfg_attr(db, cfg_options))
     }
 
-    pub fn merge(&self, other: Self) -> Self {
+    pub fn merge(
+        &self,
+        other: Self,
+    ) -> Self {
         match (&self.entries, other.entries) {
             (None, None) => Self::EMPTY,
             (None, entries @ Some(_)) => Self { entries },
-            (Some(entries), None) => Self {
-                entries: Some(entries.clone()),
-            },
+            (Some(entries), None) => Self { entries: Some(entries.clone()) },
             (Some(a), Some(b)) => {
                 let last_ast_index = a.slice.last().map_or(0, |it| it.id.ast_index() + 1);
                 let items = a
                         it
                     }))
                     .collect::<Vec<_>>();
-                Self {
-                    entries: Some(ThinArc::from_header_and_iter((), items.into_iter())),
-                }
+                Self { entries: Some(ThinArc::from_header_and_iter((), items.into_iter())) }
             }
         }
     }
 
     /// Processes `cfg_attr`s
-    pub fn expand_cfg_attr(self, db: &dyn ExpandDatabase, krate: Crate) -> RawAttrs {
-        let has_cfg_attrs = self.iter().any(|attr| {
-            attr.path
-                .as_ident()
-                .is_some_and(|name| *name == sym::cfg_attr)
-        });
+    pub fn expand_cfg_attr(
+        self,
+        db: &dyn ExpandDatabase,
+        krate: Crate,
+    ) -> RawAttrs {
+        let has_cfg_attrs =
+            self.iter().any(|attr| attr.path.as_ident().is_some_and(|name| *name == sym::cfg_attr));
         if !has_cfg_attrs {
             return self;
         }
-
         let cfg_options = krate.cfg_options(db);
         let new_attrs = self
             .iter()
     id: u32,
 }
 
-// FIXME: This only handles a single level of cfg_attr nesting
-// that is `#[cfg_attr(all(), cfg_attr(all(), cfg(any())))]` breaks again
 impl AttrId {
     const INNER_ATTR_SET_BIT: u32 = 1 << 31;
 
-    pub fn new(id: usize, is_inner: bool) -> Self {
+    pub fn new(
+        id: usize,
+        is_inner: bool,
+    ) -> Self {
         assert!(id <= !Self::INNER_ATTR_SET_BIT as usize);
         let id = id as u32;
-        Self {
-            id: if is_inner {
-                id | Self::INNER_ATTR_SET_BIT
-            } else {
-                id
-            },
-        }
+        Self { id: if is_inner { id | Self::INNER_ATTR_SET_BIT } else { id } }
     }
 
     pub fn ast_index(&self) -> usize {
 }
 
 impl fmt::Display for AttrInput {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         match self {
             AttrInput::Literal(lit) => write!(f, " = {lit}"),
             AttrInput::TokenTree(tt) => tt.fmt(f),
         let span = span_map.span_for_range(range);
         let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {
             let token = lit.token();
-            Some(Box::new(AttrInput::Literal(token_to_literal(
-                token.text(),
-                span,
-            ))))
+            Some(Box::new(AttrInput::Literal(token_to_literal(token.text(), span))))
         } else if let Some(tt) = ast.token_tree() {
             let tree = syntax_node_to_token_tree(
                 tt.syntax(),
         } else {
             None
         };
-        Some(Attr {
-            id,
-            path,
-            input,
-            ctxt: span.ctx,
-        })
+        Some(Attr { id, path, input, ctxt: span.ctx })
     }
 
     fn from_tt(
                 if !matches!(
                     tt,
                     tt::TtElement::Leaf(
-                        tt::Leaf::Punct(tt::Punct {
-                            char: ':' | '$',
-                            ..
-                        }) | tt::Leaf::Ident(_),
+                        tt::Leaf::Punct(tt::Punct { char: ':' | '$', .. }) | tt::Leaf::Ident(_),
                     )
                 ) {
                     input = path_split_savepoint.remaining();
             }
             (path, input)
         };
-
         let path = Interned::new(ModPath::from_tt(db, path)?);
-
         let input = match (input.flat_tokens().first(), input.try_into_subtree()) {
-            (_, Some(tree)) => Some(Box::new(AttrInput::TokenTree(
-                tt::TopSubtree::from_subtree(tree),
-            ))),
+            (_, Some(tree)) => {
+                Some(Box::new(AttrInput::TokenTree(tt::TopSubtree::from_subtree(tree))))
+            }
             (Some(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: '=', .. }))), _) => {
                 match input.flat_tokens().get(1) {
                     Some(tt::TokenTree::Leaf(tt::Leaf::Literal(lit))) => {
             }
             _ => None,
         };
-        Some(Attr {
-            id,
-            path,
-            input,
-            ctxt,
-        })
+        Some(Attr { id, path, input, ctxt })
     }
 
     pub fn path(&self) -> &ModPath {
         db: &dyn ExpandDatabase,
         cfg_options: &CfgOptions,
     ) -> impl IntoIterator<Item = Self> {
-        let is_cfg_attr = self
-            .path
-            .as_ident()
-            .is_some_and(|name| *name == sym::cfg_attr);
+        let is_cfg_attr = self.path.as_ident().is_some_and(|name| *name == sym::cfg_attr);
         if !is_cfg_attr {
             return smallvec![self];
         }
-
         let subtree = match self.token_tree_value() {
             Some(it) => it,
             _ => return smallvec![self.clone()],
         };
-
         let (cfg, parts) = match parse_cfg_attr_input(subtree) {
             Some(it) => it,
             None => return smallvec![self.clone()],
         };
         let index = self.id;
         let attrs = parts.filter_map(|attr| Attr::from_tt(db, attr, index));
-
         let cfg = TopSubtree::from_token_trees(subtree.top_subtree().delimiter, cfg);
         let cfg = CfgExpr::parse(&cfg);
         if cfg_options.check(&cfg) == Some(false) {
     pub fn string_value_unescape(&self) -> Option<Cow<'_, str>> {
         match self.input.as_deref()? {
             AttrInput::Literal(tt::Literal {
-                symbol: text,
-                kind: tt::LitKind::StrRaw(_),
-                ..
+                symbol: text, kind: tt::LitKind::StrRaw(_), ..
             }) => Some(Cow::Borrowed(text.as_str())),
-            AttrInput::Literal(tt::Literal {
-                symbol: text,
-                kind: tt::LitKind::Str,
-                ..
-            }) => unescape(text.as_str()),
+            AttrInput::Literal(tt::Literal { symbol: text, kind: tt::LitKind::Str, .. }) => {
+                unescape(text.as_str())
+            }
             _ => None,
         }
     }
         db: &'a dyn ExpandDatabase,
     ) -> Option<impl Iterator<Item = (ModPath, Span)> + 'a> {
         let args = self.token_tree_value()?;
-
         if args.top_subtree().delimiter.kind != DelimiterKind::Parenthesis {
             return None;
         }
         let paths = args
             .token_trees()
-            .split(|tt| {
-                matches!(
-                    tt,
-                    tt::TtElement::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))
-                )
-            })
+            .split(|tt| matches!(tt, tt::TtElement::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))))
             .filter_map(move |tts| {
                 let span = tts.flat_tokens().first()?.first_span();
                 Some((ModPath::from_tt(db, tts)?, span))
             });
-
         Some(paths)
     }
 
             (Err(_), _) => has_error = true,
         }
     });
-
     match (has_error, buf.capacity() == 0) {
         (true, _) => None,
         (false, false) => Some(Cow::Owned(buf)),
     }
 }
 
-pub fn collect_attrs(
-    owner: &dyn ast::HasAttrs,
-) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {
-    let inner_attrs = inner_attributes(owner.syntax())
-        .into_iter()
-        .flatten()
-        .zip(iter::repeat(true));
+pub fn collect_attrs(owner: &dyn ast::HasAttrs) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {
+    let inner_attrs =
+        inner_attributes(owner.syntax()).into_iter().flatten().zip(iter::repeat(true));
     let outer_attrs = ast::AttrDocCommentIter::from_syntax_node(owner.syntax())
         .filter(|el| match el {
             Either::Left(attr) => attr.kind().is_outer(),
         .map(|(id, (attr, is_inner))| (AttrId::new(id, is_inner), attr))
 }
 
-fn inner_attributes(
-    syntax: &SyntaxNode,
-) -> Option<impl Iterator<Item = Either<ast::Attr, ast::Comment>>> {
+fn inner_attributes(syntax: &SyntaxNode) -> Option<impl Iterator<Item = Either<ast::Attr, ast::Comment>>> {
     let node = match_ast! {
         match syntax {
             ast::SourceFile(_) => syntax.clone(),
             _ => return None,
         }
     };
-
     let attrs = ast::AttrDocCommentIter::from_syntax_node(&node).filter(|el| match el {
         Either::Left(attr) => attr.kind().is_inner(),
         Either::Right(comment) => comment.is_inner(),
     Some(attrs)
 }
 
-// Input subtree is: `(cfg, $(attr),+)`
-// Split it up into a `cfg` subtree and the `attr` subtrees.
-fn parse_cfg_attr_input(
-    subtree: &TopSubtree,
-) -> Option<(
-    tt::TokenTreesView<'_>,
-    impl Iterator<Item = tt::TokenTreesView<'_>>,
-)> {
-    let mut parts = subtree.token_trees().split(|tt| {
-        matches!(
-            tt,
-            tt::TtElement::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))
-        )
-    });
+fn parse_cfg_attr_input(subtree: &TopSubtree) -> Option<(tt::TokenTreesView<'_>, impl Iterator<Item = tt::TokenTreesView<'_>>)> {
+    let mut parts = subtree
+        .token_trees()
+        .split(|tt| matches!(tt, tt::TtElement::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))));
     let cfg = parts.next()?;
     Some((cfg, parts.filter(|it| !it.is_empty())))
 }