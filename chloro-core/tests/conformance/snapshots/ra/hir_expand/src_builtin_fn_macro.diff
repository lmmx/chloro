COMPARISON DIFF
============================================================

Original size: 32290 bytes
Chloro size:   32282 bytes
Rustfmt size:  32801 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Builtin macro
 
 use base_db::AnchoredPath;
 use cfg::CfgExpr;
 use either::Either;
-use intern::{
-    Symbol,
-    sym::{self},
-};
+use intern::{Symbol, sym::self};
 use itertools::Itertools;
 use mbe::{DelimiterKind, expect_fragment};
 use span::{Edition, FileId, Span};
 use stdx::format_to;
+use syntax_bridge::syntax_node_to_token_tree;
 use syntax::{
     format_smolstr,
     unescape::{unescape_byte, unescape_char, unescape_str},
 };
-use syntax_bridge::syntax_node_to_token_tree;
 
 use crate::{
     EditionedFileId, ExpandError, ExpandResult, Lookup as _, MacroCallId,
 }
 
 fn mk_pound(span: Span) -> tt::Leaf {
-    crate::tt::Leaf::Punct(crate::tt::Punct {
-        char: '#',
-        spacing: crate::tt::Spacing::Alone,
-        span,
-    })
+    crate::tt::Leaf::Punct(crate::tt::Punct { char: '#', spacing: crate::tt::Spacing::Alone, span })
 }
 
 fn module_path_expand(
         }
         None => ExpandResult::new(
             tt::TopSubtree::empty(tt::DelimSpan::from_single(span)),
-            ExpandError::other(
-                span,
-                "none of the predicates in this `cfg_select` evaluated to true",
-            ),
+            ExpandError::other(span, "none of the predicates in this `cfg_select` evaluated to true"),
         ),
     }
 }
     let loc = db.lookup_intern_macro_call(id);
     let expr = CfgExpr::parse(tt);
     let enabled = loc.krate.cfg_options(db).check(&expr) != Some(false);
-    let expanded = if enabled {
-        quote!(span=>true)
-    } else {
-        quote!(span=>false)
-    };
+    let expanded = if enabled { quote!(span=>true) } else { quote!(span=>false) };
     ExpandResult::ok(expanded)
 }
 
     let dollar_crate = dollar_crate(span);
     let call_site_span = span_with_call_site_ctxt(db, span, id.into(), Edition::CURRENT);
 
-    let mac = if use_panic_2021(db, call_site_span) {
-        sym::panic_2021
-    } else {
-        sym::panic_2015
-    };
+    let mac = if use_panic_2021(db, call_site_span) { sym::panic_2021 } else { sym::panic_2015 };
 
     // Pass the original arguments
     let subtree = WithDelimiter {
         i += 1;
     }
     let span = span.unwrap_or_else(|| tt.top_subtree().delimiter.open);
-    ExpandResult {
-        value: quote!(span =>#text),
-        err,
-    }
+    ExpandResult { value: quote!(span =>#text), err }
 }
 
 fn concat_bytes_expand(
     err_span: Span,
 ) -> Result<EditionedFileId, ExpandError> {
     let lookup = db.lookup_intern_macro_call(call_id);
-    let call_site = lookup
-        .kind
-        .file_id()
-        .original_file_respecting_includes(db)
-        .file_id(db);
-    let path = AnchoredPath {
-        anchor: call_site,
-        path: path_str,
-    };
+    let call_site = lookup.kind.file_id().original_file_respecting_includes(db).file_id(db);
+    let path = AnchoredPath { anchor: call_site, path: path_str };
     let res: FileId = db
         .resolve_path(path)
         .ok_or_else(|| ExpandError::other(err_span, format!("failed to load file `{path_str}`")))?;
     // Prevent include itself
     if res == call_site && !allow_recursion {
-        Err(ExpandError::other(
-            err_span,
-            format!("recursive inclusion of `{path_str}`"),
-        ))
+        Err(ExpandError::other(err_span, format!("recursive inclusion of `{path_str}`")))
     } else {
         Ok(EditionedFileId::new(db, res, lookup.krate.data(db).edition))
     }
         while let TtElement::Subtree(sub, tt_iter) = &mut tt
             && let DelimiterKind::Parenthesis | DelimiterKind::Invisible = sub.delimiter.kind
         {
-            tt = tt_iter
-                .exactly_one()
-                .map_err(|_| sub.delimiter.open.cover(sub.delimiter.close))?;
+            tt =
+                tt_iter.exactly_one().map_err(|_| sub.delimiter.open.cover(sub.delimiter.close))?;
         }
 
         match tt {
             TtElement::Leaf(l) => Err(*l.span()),
             TtElement::Subtree(tt, _) => Err(tt.delimiter.open.cover(tt.delimiter.close)),
         }
-    })()
-    .map_err(|span| ExpandError::other(span, "expected string literal"))
+    })().map_err(
+        |span| ExpandError::other(span, "expected string literal"),
+    )
 }
 
 fn include_expand(
         Ok(editioned_file_id) => editioned_file_id,
         Err(e) => {
             return ExpandResult::new(
-                tt::TopSubtree::empty(DelimSpan {
-                    open: span,
-                    close: span,
-                }),
+                tt::TopSubtree::empty(DelimSpan { open: span, close: span }),
                 e,
             );
         }
         Ok(it) => it,
         Err(e) => {
             return ExpandResult::new(
-                tt::TopSubtree::empty(DelimSpan {
-                    open: call_site,
-                    close: call_site,
-                }),
+                tt::TopSubtree::empty(DelimSpan { open: call_site, close: call_site }),
                 e,
             );
         }
         Ok(it) => it,
         Err(e) => {
             return ExpandResult::new(
-                tt::TopSubtree::empty(DelimSpan {
-                    open: span,
-                    close: span,
-                }),
+                tt::TopSubtree::empty(DelimSpan { open: span, close: span }),
                 e,
             );
         }
     });
     let expanded = quote! {span => #s };
 
-    ExpandResult {
-        value: expanded,
-        err,
-    }
+    ExpandResult { value: expanded, err }
 }
 
 fn option_env_expand(
         Ok(it) => it,
         Err(e) => {
             return ExpandResult::new(
-                tt::TopSubtree::empty(DelimSpan {
-                    open: call_site,
-                    close: call_site,
-                }),
+                tt::TopSubtree::empty(DelimSpan { open: call_site, close: call_site }),
                 e,
             );
         }
 ) -> ExpandResult<tt::TopSubtree> {
     ExpandResult::new(
         tt::TopSubtree::empty(tt::DelimSpan {
-            open: span,
-            close: span,
-        }),
+        open: span,
+        close: span,
+    }),
         ExpandError::other(span, "quote! is not implemented"),
     )
 }