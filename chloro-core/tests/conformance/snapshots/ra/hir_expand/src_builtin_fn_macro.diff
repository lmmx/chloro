COMPARISON DIFF
============================================================

Original size: 32290 bytes
Chloro size:   32285 bytes
Rustfmt size:  32290 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Builtin macro
 
 use base_db::AnchoredPath;
 use cfg::CfgExpr;
 use either::Either;
-use intern::{
-    Symbol,
-    sym::{self},
-};
+use intern::{Symbol, sym::self};
 use itertools::Itertools;
 use mbe::{DelimiterKind, expect_fragment};
 use span::{Edition, FileId, Span};
 use stdx::format_to;
+use syntax_bridge::syntax_node_to_token_tree;
 use syntax::{
     format_smolstr,
     unescape::{unescape_byte, unescape_char, unescape_str},
 };
-use syntax_bridge::syntax_node_to_token_tree;
 
 use crate::{
     EditionedFileId, ExpandError, ExpandResult, Lookup as _, MacroCallId,
         }
         None => ExpandResult::new(
             tt::TopSubtree::empty(tt::DelimSpan::from_single(span)),
-            ExpandError::other(
-                span,
-                "none of the predicates in this `cfg_select` evaluated to true",
-            ),
+            ExpandError::other(span, "none of the predicates in this `cfg_select` evaluated to true"),
         ),
     }
 }
     // stack that does not have #[allow_internal_unstable(edition_panic)].
     // (To avoid using the edition of e.g. the assert!() or debug_assert!() definition.)
     loop {
-        let Some(expn) = span.ctx.outer_expn(db) else {
-            break false;
-        };
-        let expn = db.lookup_intern_macro_call(expn.into());
         // FIXME: Record allow_internal_unstable in the macro def (not been done yet because it
         // would consume quite a bit extra memory for all call locs...)
         // if let Some(features) = expn.def.allow_internal_unstable {
         //         continue;
         //     }
         // }
+        let Some(expn) = span.ctx.outer_expn(db) else {
+            break false;
+        };
+        let expn = db.lookup_intern_macro_call(expn.into());
         break expn.def.edition >= Edition::Edition2021;
     }
 }
         _ => ExpandError::other(span, "`compile_error!` argument must be a string"),
     };
 
-    ExpandResult { value: quote! {span =>}, err: Some(err) }
+    ExpandResult {
+        value: quote! {span =>},
+        err: Some(err),
+    }
 }
 
 fn concat_expand(
             TtElement::Leaf(l) => Err(*l.span()),
             TtElement::Subtree(tt, _) => Err(tt.delimiter.open.cover(tt.delimiter.close)),
         }
-    })()
-    .map_err(|span| ExpandError::other(span, "expected string literal"))
+    })().map_err(
+        |span| ExpandError::other(span, "expected string literal"),
+    )
 }
 
 fn include_expand(
     };
 
     // FIXME: we're not able to read excluded files (which is most of them because
+
     // it's unusual to `include_str!` a Rust file), but we can return an empty string.
+
     // Ideally, we'd be able to offer a precise expansion if the user asks for macro
+
     // expansion.
     let file_id = match relative_file(db, arg_id, path.as_str(), true, input_span) {
         Ok(file_id) => file_id,
     span: Span,
 ) -> ExpandResult<tt::TopSubtree> {
     ExpandResult::new(
-        tt::TopSubtree::empty(tt::DelimSpan { open: span, close: span }),
+        tt::TopSubtree::empty(tt::DelimSpan {
+        open: span,
+        close: span,
+    }),
         ExpandError::other(span, "quote! is not implemented"),
     )
 }