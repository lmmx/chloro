COMPARISON DIFF
============================================================

Original size: 4655 bytes
Chloro size:   4663 bytes
Rustfmt size:  4904 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! # The Call-site Hierarchy
 //!
 //! `ExpnData::call_site` in rustc, [`MacroCallLoc::call_site`] in rust-analyzer.
+
 // FIXME: Move this into the span crate? Not quite possible today as that depends on `MacroCallLoc`
 // which contains a bunch of unrelated things
-
 use std::convert::identity;
 
 use span::{Edition, MacroCallId, Span, SyntaxContext};
     edition: Edition,
 ) -> Span {
     Span {
-        ctx: apply_mark(
-            db,
-            SyntaxContext::root(edition),
-            expn_id,
-            transparency,
-            edition,
-        ),
+        ctx: apply_mark(db, SyntaxContext::root(edition), expn_id, transparency, edition),
         ..span
     }
 }
     }
 
     // Otherwise, `expn_id` is a macros 1.0 definition and the call site is in a
+
     // macros 2.0 expansion, i.e., a macros 1.0 invocation is in a macros 2.0 definition.
+
     //
+
     // In this case, the tokens from the macros 1.0 definition inherit the hygiene
+
     // at their invocation. That is, we pretend that the macros 1.0 definition
+
     // was defined at its invocation (i.e., inside the macros 2.0 definition)
+
     // so that the macros 2.0 definition remains hygienic.
+
     //
+
     // See the example at `test/ui/hygiene/legacy_interaction.rs`.
     for (call_id, transparency) in ctxt.marks(db) {
         call_site_ctxt = apply_mark_internal(db, call_site_ctxt, call_id, transparency, edition);
 
     if transparency >= Transparency::Opaque {
         let parent = opaque;
-        opaque = SyntaxContext::new(
-            db,
-            call_id,
-            transparency,
-            edition,
-            parent,
-            identity,
-            identity,
-        );
+        opaque = SyntaxContext::new(db, call_id, transparency, edition, parent, identity, identity);
     }
 
     if transparency >= Transparency::SemiTransparent {
         let parent = opaque_and_semitransparent;
-        opaque_and_semitransparent = SyntaxContext::new(
-            db,
-            call_id,
-            transparency,
-            edition,
-            parent,
-            |_| opaque,
-            identity,
-        );
+        opaque_and_semitransparent =
+            SyntaxContext::new(db, call_id, transparency, edition, parent, |_| opaque, identity);
     }
 
     let parent = ctxt;