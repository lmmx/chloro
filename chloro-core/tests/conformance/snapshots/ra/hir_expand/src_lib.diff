COMPARISON DIFF
============================================================

Original size: 40650 bytes
Chloro size:   40439 bytes
Rustfmt size:  42265 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! `hir_expand` deals with macro expansion.
 //!
 //! Specifically, it implements a concept of `MacroFile` -- a file whose syntax
 //! tree originates not from the text of some `FileId`, but from some macro
 //! expansion.
+
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
 pub use intern;
 pub mod tt {
     pub use span::Span;
     pub use tt::{DelimiterKind, IdentIsRaw, LitKind, Spacing, token_to_literal};
-
     pub type Delimiter = ::tt::Delimiter<Span>;
     pub type DelimSpan = ::tt::DelimSpan<Span>;
     pub type Subtree = ::tt::Subtree<Span>;
     };
 }
 
-// ideally these would be defined in base-db, but the orphan rule doesn't let us
 pub trait Intern {
-    type Database: ?Sized;
+    type Database;
+
     type ID;
+
     fn intern(self, db: &Self::Database) -> Self::ID;
 }
 
 pub trait Lookup {
-    type Database: ?Sized;
+    type Database;
+
     type Data;
+
     fn lookup(&self, db: &Self::Database) -> Self::Data;
 }
 
 
 impl ExpandError {
     pub fn new(span: Span, kind: ExpandErrorKind) -> Self {
-        ExpandError {
-            inner: Arc::new((kind, span)),
-        }
+        ExpandError { inner: Arc::new((kind, span)) }
     }
+
     pub fn other(span: Span, msg: impl Into<Box<str>>) -> Self {
-        ExpandError {
-            inner: Arc::new((ExpandErrorKind::Other(msg.into()), span)),
-        }
+        ExpandError { inner: Arc::new((ExpandErrorKind::Other(msg.into()), span)) }
     }
+
     pub fn kind(&self) -> &ExpandErrorKind {
         &self.inner.0
     }
+
     pub fn span(&self) -> Span {
         self.inner.1
     }
 
 impl RenderedExpandError {
     const GENERAL_KIND: &str = "macro-error";
+
     const DISABLED: &str = "proc-macro-disabled";
+
     const ATTR_EXP_DISABLED: &str = "attribute-expansion-disabled";
 }
 
                 kind: RenderedExpandError::DISABLED,
             },
             &ExpandErrorKind::MissingProcMacroExpander(def_crate) => {
-                match db
-                    .proc_macros_for_crate(def_crate)
-                    .as_ref()
-                    .and_then(|it| it.get_error())
-                {
+                match db.proc_macros_for_crate(def_crate).as_ref().and_then(|it| it.get_error()) {
                     Some(e) => RenderedExpandError {
                         message: e.to_string(),
                         error: e.is_hard_error(),
 
 impl From<mbe::ExpandError> for ExpandError {
     fn from(mbe: mbe::ExpandError) -> Self {
-        ExpandError {
-            inner: Arc::new((ExpandErrorKind::Mbe(mbe.inner.1.clone()), mbe.inner.0)),
-        }
+        ExpandError { inner: Arc::new((ExpandErrorKind::Mbe(mbe.inner.1.clone()), mbe.inner.0)) }
     }
 }
+
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub struct MacroCallLoc {
     pub def: MacroDefId,
     FnLike {
         ast_id: AstId<ast::MacroCall>,
         expand_to: ExpandTo,
-        /// Some if this is a macro call for an eager macro. Note that this is `None`
-        /// for the eager input macro file.
         // FIXME: This is being interned, subtrees can vary quickly differing just slightly causing
         // leakage problems here
+        /// Some if this is a macro call for an eager macro. Note that this is `None`
+        /// for the eager input macro file.
         eager: Option<Arc<EagerCallInfo>>,
     },
     Derive {
             HirFileId::MacroFile(m) => db.lookup_intern_macro_call(m).def.edition,
         }
     }
+
     pub fn original_file(self, db: &dyn ExpandDatabase) -> EditionedFileId {
         let mut file_id = self;
         loop {
         }
     }
 
-    pub fn original_file_respecting_includes(mut self, db: &dyn ExpandDatabase) -> EditionedFileId {
+    pub fn original_file_respecting_includes(
+        mut self,
+        db: &dyn ExpandDatabase,
+    ) -> EditionedFileId {
         loop {
             match self {
                 HirFileId::FileId(id) => break id,
                 HirFileId::MacroFile(file) => {
                     let loc = db.lookup_intern_macro_call(file);
                     if loc.def.is_include()
-                        && let MacroCallKind::FnLike {
-                            eager: Some(eager), ..
-                        } = &loc.kind
+                        && let MacroCallKind::FnLike { eager: Some(eager), .. } = &loc.kind
                         && let Ok(it) = include_input_to_file_id(db, file, &eager.arg)
                     {
                         break it;
         loop {
             match call.file_id {
                 HirFileId::FileId(file_id) => {
-                    break Some(InRealFile {
-                        file_id,
-                        value: call.value,
-                    });
+                    break Some(InRealFile { file_id, value: call.value });
                 }
                 HirFileId::MacroFile(macro_call_id) => {
                     call = db.lookup_intern_macro_call(macro_call_id).to_node(db);
     pub fn call_node(self, db: &dyn ExpandDatabase) -> InFile<SyntaxNode> {
         db.lookup_intern_macro_call(self).to_node(db)
     }
+
     pub fn expansion_level(self, db: &dyn ExpandDatabase) -> u32 {
         let mut level = 0;
         let mut macro_file = self;
             };
         }
     }
+
     pub fn parent(self, db: &dyn ExpandDatabase) -> HirFileId {
         db.lookup_intern_macro_call(self).kind.file_id()
     }
         kind: MacroCallKind,
         ctxt: SyntaxContext,
     ) -> MacroCallId {
-        db.intern_macro_call(MacroCallLoc {
-            def: self,
-            krate,
-            kind,
-            ctxt,
-        })
+        db.intern_macro_call(MacroCallLoc { def: self, krate, kind, ctxt })
     }
 
     pub fn definition_range(&self, db: &dyn ExpandDatabase) -> InFile<TextRange> {
             MacroCallKind::FnLike { ast_id, .. } => {
                 ast_id.with_value(ast_id.to_node(db).syntax().clone())
             }
-            MacroCallKind::Derive {
-                ast_id,
-                derive_attr_index,
-                ..
-            } => {
+            MacroCallKind::Derive { ast_id, derive_attr_index, .. } => {
                 // FIXME: handle `cfg_attr`
                 ast_id.with_value(ast_id.to_node(db)).map(|it| {
                     collect_attrs(&it)
                         .unwrap_or_else(|| it.syntax().clone())
                 })
             }
-            MacroCallKind::Attr {
-                ast_id,
-                invoc_attr_index,
-                ..
-            } => {
+            MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {
                 if self.def.is_attribute_derive() {
                     // FIXME: handle `cfg_attr`
                     ast_id.with_value(ast_id.to_node(db)).map(|it| {
         macro_call_id: MacroCallId,
     ) -> Option<EditionedFileId> {
         if self.def.is_include()
-            && let MacroCallKind::FnLike {
-                eager: Some(eager), ..
-            } = &self.kind
+            && let MacroCallKind::FnLike { eager: Some(eager), .. } = &self.kind
             && let Ok(it) = include_input_to_file_id(db, macro_call_id, &eager.arg)
         {
             return Some(it);
     /// Returns the file containing the macro invocation.
     pub fn file_id(&self) -> HirFileId {
         match *self {
-            MacroCallKind::FnLike {
-                ast_id: InFile { file_id, .. },
-                ..
-            }
-            | MacroCallKind::Derive {
-                ast_id: InFile { file_id, .. },
-                ..
-            }
-            | MacroCallKind::Attr {
-                ast_id: InFile { file_id, .. },
-                ..
-            } => file_id,
+            MacroCallKind::FnLike { ast_id: InFile { file_id, .. }, .. }
+            | MacroCallKind::Derive { ast_id: InFile { file_id, .. }, .. }
+            | MacroCallKind::Attr { ast_id: InFile { file_id, .. }, .. } => file_id,
         }
     }
 
     pub fn erased_ast_id(&self) -> ErasedFileAstId {
         match *self {
-            MacroCallKind::FnLike {
-                ast_id: InFile { value, .. },
-                ..
-            } => value.erase(),
-            MacroCallKind::Derive {
-                ast_id: InFile { value, .. },
-                ..
-            } => value.erase(),
-            MacroCallKind::Attr {
-                ast_id: InFile { value, .. },
-                ..
-            } => value.erase(),
+            MacroCallKind::FnLike { ast_id: InFile { value, .. }, .. } => value.erase(),
+            MacroCallKind::Derive { ast_id: InFile { value, .. }, .. } => value.erase(),
+            MacroCallKind::Attr { ast_id: InFile { value, .. }, .. } => value.erase(),
         }
     }
 
                     .text_range()
                     .cover(node.excl_token().unwrap().text_range())
             }
-            MacroCallKind::Derive {
-                ast_id,
-                derive_attr_index,
-                ..
-            } => {
+            MacroCallKind::Derive { ast_id, derive_attr_index, .. } => {
                 // FIXME: should be the range of the macro name, not the whole derive
                 // FIXME: handle `cfg_attr`
                 collect_attrs(&ast_id.to_node(db))
                     .text_range()
             }
             // FIXME: handle `cfg_attr`
-            MacroCallKind::Attr {
-                ast_id,
-                invoc_attr_index,
-                ..
-            } => collect_attrs(&ast_id.to_node(db))
-                .nth(invoc_attr_index.ast_index())
-                .expect("missing attribute")
-                .1
-                .expect_left("attribute macro is a doc comment?")
-                .syntax()
-                .text_range(),
+            MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {
+                collect_attrs(&ast_id.to_node(db))
+                    .nth(invoc_attr_index.ast_index())
+                    .expect("missing attribute")
+                    .1
+                    .expect_left("attribute macro is a doc comment?")
+                    .syntax()
+                    .text_range()
+            }
         };
 
         FileRange { range, file_id }
 
     fn arg(&self, db: &dyn ExpandDatabase) -> InFile<Option<SyntaxNode>> {
         match self {
-            MacroCallKind::FnLike { ast_id, .. } => ast_id
-                .to_in_file_node(db)
-                .map(|it| Some(it.token_tree()?.syntax().clone())),
+            MacroCallKind::FnLike { ast_id, .. } => {
+                ast_id.to_in_file_node(db).map(|it| Some(it.token_tree()?.syntax().clone()))
+            }
             MacroCallKind::Derive { ast_id, .. } => {
                 ast_id.to_in_file_node(db).syntax().cloned().map(Some)
             }
 }
 
 /// ExpansionInfo mainly describes how to map text range between src and expanded macro
-// FIXME: can be expensive to create, we should check the use sites and maybe replace them with
-// simpler function calls if the map is only used once
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct ExpansionInfo {
     expanded: InMacroFile<SyntaxNode>,
         )
     }
 
+    // FIXME: Consider adding a reverse map to ExpansionInfo to get rid of the linear search which
+    // potentially results in quadratic look ups (notably this might improve semantic highlighting perf)
     /// Maps the passed in file range down into a macro expansion if it is the input to a macro call.
     ///
     /// Note this does a linear search through the entire backing vector of the spanmap.
-    // FIXME: Consider adding a reverse map to ExpansionInfo to get rid of the linear search which
-    // potentially results in quadratic look ups (notably this might improve semantic highlighting perf)
     pub fn map_range_down_exact(
         &self,
         span: Span,
     ) -> Option<InMacroFile<impl Iterator<Item = (SyntaxToken, SyntaxContext)> + '_>> {
-        let tokens = self
-            .exp_map
-            .ranges_with_span_exact(span)
-            .flat_map(move |(range, ctx)| {
-                self.expanded
-                    .value
-                    .covering_element(range)
-                    .into_token()
-                    .zip(Some(ctx))
-            });
+        let tokens = self.exp_map.ranges_with_span_exact(span).flat_map(move |(range, ctx)| {
+            self.expanded.value.covering_element(range).into_token().zip(Some(ctx))
+        });
 
         Some(InMacroFile::new(self.expanded.file_id, tokens))
     }
         &self,
         span: Span,
     ) -> Option<InMacroFile<impl Iterator<Item = (SyntaxToken, SyntaxContext)> + '_>> {
-        let tokens = self
-            .exp_map
-            .ranges_with_span(span)
-            .flat_map(move |(range, ctx)| {
-                self.expanded
-                    .value
-                    .covering_element(range)
-                    .into_token()
-                    .zip(Some(ctx))
-            });
+        let tokens = self.exp_map.ranges_with_span(span).flat_map(move |(range, ctx)| {
+            self.expanded.value.covering_element(range).into_token().zip(Some(ctx))
+        });
 
         Some(InMacroFile::new(self.expanded.file_id, tokens))
     }
         match &self.arg_map {
             SpanMap::RealSpanMap(_) => {
                 let file_id = EditionedFileId::from_span(db, span.anchor.file_id).into();
-                let anchor_offset = db
-                    .ast_id_map(file_id)
-                    .get_erased(span.anchor.ast_id)
-                    .text_range()
-                    .start();
-                InFile {
-                    file_id,
-                    value: smallvec::smallvec![span.range + anchor_offset],
-                }
+                let anchor_offset =
+                    db.ast_id_map(file_id).get_erased(span.anchor.ast_id).text_range().start();
+                InFile { file_id, value: smallvec::smallvec![span.range + anchor_offset] }
             }
             SpanMap::ExpansionSpanMap(arg_map) => {
                 let Some(arg_node) = &self.arg.value else {
         let arg_map = db.span_map(arg_tt.file_id);
 
         let (parse, exp_map) = db.parse_macro_expansion(macro_file).value;
-        let expanded = InMacroFile {
-            file_id: macro_file,
-            value: parse.syntax_node(),
-        };
+        let expanded = InMacroFile { file_id: macro_file, value: parse.syntax_node() };
 
-        ExpansionInfo {
-            expanded,
-            loc,
-            arg: arg_tt,
-            exp_map,
-            arg_map,
-        }
+        ExpansionInfo { expanded, loc, arg: arg_tt, exp_map, arg_map }
     }
 }
 
     exp_map: &ExpansionSpanMap,
     range: TextRange,
 ) -> Option<FileRange> {
-    let mut spans = exp_map
-        .spans_for_range(range)
-        .filter(|span| span.ctx.is_root());
-    let Span {
-        range,
-        anchor,
-        ctx: _,
-    } = spans.next()?;
+    let mut spans = exp_map.spans_for_range(range).filter(|span| span.ctx.is_root());
+    let Span { range, anchor, ctx: _ } = spans.next()?;
     let mut start = range.start();
     let mut end = range.end();
 
         end = end.max(span.range.end());
     }
     let file_id = EditionedFileId::from_span(db, anchor.file_id);
-    let anchor_offset = db
-        .ast_id_map(file_id.into())
-        .get_erased(anchor.ast_id)
-        .text_range()
-        .start();
-    Some(FileRange {
-        file_id,
-        range: TextRange::new(start, end) + anchor_offset,
-    })
+    let anchor_offset =
+        db.ast_id_map(file_id.into()).get_erased(anchor.ast_id).text_range().start();
+    Some(FileRange { file_id, range: TextRange::new(start, end) + anchor_offset })
 }
 
 /// Maps up the text range out of the expansion hierarchy back into the original file its from.
         end = end.max(span.range.end());
     }
     let file_id = EditionedFileId::from_span(db, anchor.file_id);
-    let anchor_offset = db
-        .ast_id_map(file_id.into())
-        .get_erased(anchor.ast_id)
-        .text_range()
-        .start();
-    Some((
-        FileRange {
-            file_id,
-            range: TextRange::new(start, end) + anchor_offset,
-        },
-        ctx,
-    ))
+    let anchor_offset =
+        db.ast_id_map(file_id.into()).get_erased(anchor.ast_id).text_range().start();
+    Some((FileRange { file_id, range: TextRange::new(start, end) + anchor_offset }, ctx))
 }
 
 /// Maps up the text range out of the expansion hierarchy back into the original file its from.
 ) -> FxHashMap<(SpanAnchor, SyntaxContext), TextRange> {
     let mut map = FxHashMap::default();
     for span in exp_map.spans_for_range(range) {
-        let range = map
-            .entry((span.anchor, span.ctx))
-            .or_insert_with(|| span.range);
+        let range = map.entry((span.anchor, span.ctx)).or_insert_with(|| span.range);
         *range = TextRange::new(
             range.start().min(span.range.start()),
             range.end().max(span.range.end()),
     }
     for ((anchor, _), range) in &mut map {
         let file_id = EditionedFileId::from_span(db, anchor.file_id);
-        let anchor_offset = db
-            .ast_id_map(file_id.into())
-            .get_erased(anchor.ast_id)
-            .text_range()
-            .start();
+        let anchor_offset =
+            db.ast_id_map(file_id.into()).get_erased(anchor.ast_id).text_range().start();
         *range += anchor_offset;
     }
     map
 ) -> (FileRange, SyntaxContext) {
     let span = exp_map.span_at(offset);
     let file_id = EditionedFileId::from_span(db, span.anchor.file_id);
-    let anchor_offset = db
-        .ast_id_map(file_id.into())
-        .get_erased(span.anchor.ast_id)
-        .text_range()
-        .start();
-    (
-        FileRange {
-            file_id,
-            range: span.range + anchor_offset,
-        },
-        span.ctx,
-    )
+    let anchor_offset =
+        db.ast_id_map(file_id.into()).get_erased(span.anchor.ast_id).text_range().start();
+    (FileRange { file_id, range: span.range + anchor_offset }, span.ctx)
 }
 
 /// In Rust, macros expand token trees to token trees. When we want to turn a
         *self == HirFileId::from(other)
     }
 }
+
 impl PartialEq<HirFileId> for EditionedFileId {
     fn eq(&self, &other: &HirFileId) -> bool {
         other == HirFileId::from(*self)