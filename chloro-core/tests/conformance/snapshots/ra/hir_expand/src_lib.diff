COMPARISON DIFF
============================================================

Original size: 40650 bytes
Chloro size:   39747 bytes
Rustfmt size:  40650 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! `hir_expand` deals with macro expansion.
 //!
 //! Specifically, it implements a concept of `MacroFile` -- a file whose syntax
 //! tree originates not from the text of some `FileId`, but from some macro
 //! expansion.
-#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
-pub use intern;
+#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
 pub mod attrs;
 pub mod builtin;
 pub mod name;
 pub mod proc_macro;
 pub mod span_map;
-
 mod cfg_process;
 mod fixup;
 mod prettify_macro_expansion_;
 
-use attrs::collect_attrs;
-use rustc_hash::FxHashMap;
-use salsa::plumbing::{AsId, FromId};
-use stdx::TupleExt;
-use triomphe::Arc;
-
 use core::fmt;
 use std::hash::Hash;
 
+use attrs::collect_attrs;
 use base_db::Crate;
+pub use base_db::EditionedFileId;
 use either::Either;
+pub use intern;
+pub use mbe::{DeclarativeMacro, ValueResult};
+use rustc_hash::FxHashMap;
+use salsa::plumbing::{AsId, FromId};
 use span::{Edition, ErasedFileAstId, FileAstId, Span, SpanAnchor, SyntaxContext};
+use stdx::TupleExt;
 use syntax::{
     SyntaxNode, SyntaxToken, TextRange, TextSize,
     ast::{self, AstNode},
 };
+use triomphe::Arc;
 
 use crate::{
     attrs::AttrId,
     proc_macro::{CustomProcMacroExpander, ProcMacroKind},
     span_map::{ExpansionSpanMap, SpanMap},
 };
-
 pub use crate::{
     cfg_process::check_cfg_attr_value,
     files::{AstId, ErasedAstId, FileRange, InFile, InMacroFile, InRealFile},
     prettify_macro_expansion_::prettify_macro_expansion,
 };
 
-pub use base_db::EditionedFileId;
-pub use mbe::{DeclarativeMacro, ValueResult};
-
 pub mod tt {
     pub use span::Span;
     pub use tt::{DelimiterKind, IdentIsRaw, LitKind, Spacing, token_to_literal};
-
     pub type Delimiter = ::tt::Delimiter<Span>;
     pub type DelimSpan = ::tt::DelimSpan<Span>;
     pub type Subtree = ::tt::Subtree<Span>;
     };
 }
 
-// ideally these would be defined in base-db, but the orphan rule doesn't let us
 pub trait Intern {
-    type Database: ?Sized;
+    type Database;
+
     type ID;
+
     fn intern(self, db: &Self::Database) -> Self::ID;
 }
 
 pub trait Lookup {
-    type Database: ?Sized;
+    type Database;
+
     type Data;
+
     fn lookup(&self, db: &Self::Database) -> Self::Data;
 }
-
-impl_intern_lookup!(
-    ExpandDatabase,
-    MacroCallId,
-    MacroCallLoc,
-    intern_macro_call,
-    lookup_intern_macro_call
-);
-
 pub type ExpandResult<T> = ValueResult<T, ExpandError>;
 
 #[derive(Debug, PartialEq, Eq, Clone, Hash)]
     pub fn new(span: Span, kind: ExpandErrorKind) -> Self {
         ExpandError { inner: Arc::new((kind, span)) }
     }
+
     pub fn other(span: Span, msg: impl Into<Box<str>>) -> Self {
         ExpandError { inner: Arc::new((ExpandErrorKind::Other(msg.into()), span)) }
     }
+
     pub fn kind(&self) -> &ExpandErrorKind {
         &self.inner.0
     }
+
     pub fn span(&self) -> Span {
         self.inner.1
     }
 
 impl RenderedExpandError {
     const GENERAL_KIND: &str = "macro-error";
+
     const DISABLED: &str = "proc-macro-disabled";
+
     const ATTR_EXP_DISABLED: &str = "attribute-expansion-disabled";
 }
 
         ExpandError { inner: Arc::new((ExpandErrorKind::Mbe(mbe.inner.1.clone()), mbe.inner.0)) }
     }
 }
+
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub struct MacroCallLoc {
     pub def: MacroDefId,
         expand_to: ExpandTo,
         /// Some if this is a macro call for an eager macro. Note that this is `None`
         /// for the eager input macro file.
-        // FIXME: This is being interned, subtrees can vary quickly differing just slightly causing
-        // leakage problems here
         eager: Option<Arc<EagerCallInfo>>,
     },
     Derive {
     },
     Attr {
         ast_id: AstId<ast::Item>,
-        // FIXME: This shouldn't be here, we can derive this from `invoc_attr_index`
-        // but we need to fix the `cfg_attr` handling first.
         attr_args: Option<Arc<tt::TopSubtree>>,
         /// Syntactical index of the invoking `#[attribute]`.
         ///
             HirFileId::MacroFile(m) => db.lookup_intern_macro_call(m).def.edition,
         }
     }
+
     pub fn original_file(self, db: &dyn ExpandDatabase) -> EditionedFileId {
         let mut file_id = self;
         loop {
         }
     }
 
-    pub fn original_file_respecting_includes(mut self, db: &dyn ExpandDatabase) -> EditionedFileId {
+    pub fn original_file_respecting_includes(
+        mut self,
+        db: &dyn ExpandDatabase,
+    ) -> EditionedFileId {
         loop {
             match self {
                 HirFileId::FileId(id) => break id,
     pub fn call_node(self, db: &dyn ExpandDatabase) -> InFile<SyntaxNode> {
         db.lookup_intern_macro_call(self).to_node(db)
     }
+
     pub fn expansion_level(self, db: &dyn ExpandDatabase) -> u32 {
         let mut level = 0;
         let mut macro_file = self;
             };
         }
     }
+
     pub fn parent(self, db: &dyn ExpandDatabase) -> HirFileId {
         db.lookup_intern_macro_call(self).kind.file_id()
     }
         {
             return Some(it);
         }
-
         None
     }
 }
                 HirFileId::FileId(file_id) => break file_id,
             }
         };
-
         let range = match kind {
             MacroCallKind::FnLike { ast_id, .. } => ast_id.to_ptr(db).text_range(),
             MacroCallKind::Derive { ast_id, .. } => ast_id.to_ptr(db).text_range(),
             MacroCallKind::Attr { ast_id, .. } => ast_id.to_ptr(db).text_range(),
         };
-
         FileRange { range, file_id }
     }
 
                 HirFileId::FileId(file_id) => break file_id,
             }
         };
-
         let range = match kind {
             MacroCallKind::FnLike { ast_id, .. } => {
                 let node = ast_id.to_node(db);
                     .text_range()
             }
         };
-
         FileRange { range, file_id }
     }
 
 }
 
 /// ExpansionInfo mainly describes how to map text range between src and expanded macro
-// FIXME: can be expensive to create, we should check the use sites and maybe replace them with
-// simpler function calls if the map is only used once
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct ExpansionInfo {
     expanded: InMacroFile<SyntaxNode>,
     /// Maps the passed in file range down into a macro expansion if it is the input to a macro call.
     ///
     /// Note this does a linear search through the entire backing vector of the spanmap.
-    // FIXME: Consider adding a reverse map to ExpansionInfo to get rid of the linear search which
-    // potentially results in quadratic look ups (notably this might improve semantic highlighting perf)
     pub fn map_range_down_exact(
         &self,
         span: Span,
         let tokens = self.exp_map.ranges_with_span_exact(span).flat_map(move |(range, ctx)| {
             self.expanded.value.covering_element(range).into_token().zip(Some(ctx))
         });
-
         Some(InMacroFile::new(self.expanded.file_id, tokens))
     }
 
         let tokens = self.exp_map.ranges_with_span(span).flat_map(move |(range, ctx)| {
             self.expanded.value.covering_element(range).into_token().zip(Some(ctx))
         });
-
         Some(InMacroFile::new(self.expanded.file_id, tokens))
     }
 
     pub fn new(db: &dyn ExpandDatabase, macro_file: MacroCallId) -> ExpansionInfo {
         let _p = tracing::info_span!("ExpansionInfo::new").entered();
         let loc = db.lookup_intern_macro_call(macro_file);
-
         let arg_tt = loc.kind.arg(db);
         let arg_map = db.span_map(arg_tt.file_id);
-
         let (parse, exp_map) = db.parse_macro_expansion(macro_file).value;
         let expanded = InMacroFile { file_id: macro_file, value: parse.syntax_node() };
-
         ExpansionInfo { expanded, loc, arg: arg_tt, exp_map, arg_map }
     }
 }
     let Span { range, anchor, ctx: _ } = spans.next()?;
     let mut start = range.start();
     let mut end = range.end();
-
     for span in spans {
         if span.anchor != anchor {
             return None;
     let Span { range, anchor, ctx } = spans.next()?;
     let mut start = range.start();
     let mut end = range.end();
-
     for span in spans {
         if span.anchor != anchor || span.ctx != ctx {
             return None;
 impl ExpandTo {
     pub fn from_call_site(call: &ast::MacroCall) -> ExpandTo {
         use syntax::SyntaxKind::*;
-
         let syn = call.syntax();
-
         let parent = match syn.parent() {
             Some(it) => it,
             None => return ExpandTo::Statements,
         };
-
         // FIXME: macros in statement position are treated as expression statements, they should
         // probably be their own statement kind. The *grand*parent indicates what's valid.
         if parent.kind() == MACRO_EXPR
         {
             return ExpandTo::Statements;
         }
-
         match parent.kind() {
             MACRO_ITEMS | SOURCE_FILE | ITEM_LIST => ExpandTo::Items,
             MACRO_STMTS | EXPR_STMT | STMT_LIST => ExpandTo::Statements,
         }
     }
 }
-
-intern::impl_internable!(ModPath, attrs::AttrInput);
-
 #[salsa_macros::interned(no_lifetime, debug, revisions = usize::MAX)]
 #[doc(alias = "MacroFileId")]
 pub struct MacroCallId {
         *self == HirFileId::from(other)
     }
 }
+
 impl PartialEq<HirFileId> for EditionedFileId {
     fn eq(&self, &other: &HirFileId) -> bool {
         other == HirFileId::from(*self)