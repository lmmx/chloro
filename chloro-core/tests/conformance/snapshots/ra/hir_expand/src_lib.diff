COMPARISON DIFF
============================================================

Original size: 40650 bytes
Chloro size:   40452 bytes
Rustfmt size:  40650 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! `hir_expand` deals with macro expansion.
 //!
 //! Specifically, it implements a concept of `MacroFile` -- a file whose syntax
 //! tree originates not from the text of some `FileId`, but from some macro
 //! expansion.
-#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
-pub use intern;
+#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
 pub mod attrs;
 pub mod builtin;
 pub mod name;
 pub mod proc_macro;
 pub mod span_map;
-
 mod cfg_process;
 mod fixup;
 mod prettify_macro_expansion_;
 
-use attrs::collect_attrs;
-use rustc_hash::FxHashMap;
-use salsa::plumbing::{AsId, FromId};
-use stdx::TupleExt;
-use triomphe::Arc;
-
 use core::fmt;
 use std::hash::Hash;
 
+use attrs::collect_attrs;
 use base_db::Crate;
+pub use base_db::EditionedFileId;
 use either::Either;
+pub use intern;
+pub use mbe::{DeclarativeMacro, ValueResult};
+use rustc_hash::FxHashMap;
+use salsa::plumbing::{AsId, FromId};
 use span::{Edition, ErasedFileAstId, FileAstId, Span, SpanAnchor, SyntaxContext};
+use stdx::TupleExt;
 use syntax::{
     SyntaxNode, SyntaxToken, TextRange, TextSize,
     ast::{self, AstNode},
 };
+use triomphe::Arc;
 
 use crate::{
     attrs::AttrId,
         BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerExpander,
         include_input_to_file_id,
     },
-    db::ExpandDatabase,
-    mod_path::ModPath,
-    proc_macro::{CustomProcMacroExpander, ProcMacroKind},
+    db::ExpandDatabase, mod_path::ModPath, proc_macro::{CustomProcMacroExpander, ProcMacroKind},
     span_map::{ExpansionSpanMap, SpanMap},
 };
-
 pub use crate::{
     cfg_process::check_cfg_attr_value,
     files::{AstId, ErasedAstId, FileRange, InFile, InMacroFile, InRealFile},
     prettify_macro_expansion_::prettify_macro_expansion,
 };
 
-pub use base_db::EditionedFileId;
-pub use mbe::{DeclarativeMacro, ValueResult};
-
 pub mod tt {
     pub use span::Span;
     pub use tt::{DelimiterKind, IdentIsRaw, LitKind, Spacing, token_to_literal};
-
     pub type Delimiter = ::tt::Delimiter<Span>;
     pub type DelimSpan = ::tt::DelimSpan<Span>;
     pub type Subtree = ::tt::Subtree<Span>;
     };
 }
 
-// ideally these would be defined in base-db, but the orphan rule doesn't let us
 pub trait Intern {
-    type Database: ?Sized;
+    type Database;
+
     type ID;
-    fn intern(self, db: &Self::Database) -> Self::ID;
+
+    fn intern(
+        self,
+        db: &Self::Database,
+    ) -> Self::ID;
 }
 
 pub trait Lookup {
-    type Database: ?Sized;
+    type Database;
+
     type Data;
-    fn lookup(&self, db: &Self::Database) -> Self::Data;
+
+    fn lookup(
+        &self,
+        db: &Self::Database,
+    ) -> Self::Data;
 }
-
-impl_intern_lookup!(
-    ExpandDatabase,
-    MacroCallId,
-    MacroCallLoc,
-    intern_macro_call,
-    lookup_intern_macro_call
-);
-
 pub type ExpandResult<T> = ValueResult<T, ExpandError>;
 
 #[derive(Debug, PartialEq, Eq, Clone, Hash)]
 }
 
 impl ExpandError {
-    pub fn new(span: Span, kind: ExpandErrorKind) -> Self {
+    pub fn new(
+        span: Span,
+        kind: ExpandErrorKind,
+    ) -> Self {
         ExpandError { inner: Arc::new((kind, span)) }
     }
-    pub fn other(span: Span, msg: impl Into<Box<str>>) -> Self {
+
+    pub fn other(
+        span: Span,
+        msg: impl Into<Box<str>>,
+    ) -> Self {
         ExpandError { inner: Arc::new((ExpandErrorKind::Other(msg.into()), span)) }
     }
+
     pub fn kind(&self) -> &ExpandErrorKind {
         &self.inner.0
     }
+
     pub fn span(&self) -> Span {
         self.inner.1
     }
 
-    pub fn render_to_string(&self, db: &dyn ExpandDatabase) -> RenderedExpandError {
+    pub fn render_to_string(
+        &self,
+        db: &dyn ExpandDatabase,
+    ) -> RenderedExpandError {
         self.inner.0.render_to_string(db)
     }
 }
 }
 
 impl fmt::Display for RenderedExpandError {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         write!(f, "{}", self.message)
     }
 }
 
 impl RenderedExpandError {
     const GENERAL_KIND: &str = "macro-error";
+
     const DISABLED: &str = "proc-macro-disabled";
+
     const ATTR_EXP_DISABLED: &str = "attribute-expansion-disabled";
 }
 
 impl ExpandErrorKind {
-    pub fn render_to_string(&self, db: &dyn ExpandDatabase) -> RenderedExpandError {
+    pub fn render_to_string(
+        &self,
+        db: &dyn ExpandDatabase,
+    ) -> RenderedExpandError {
         match self {
             ExpandErrorKind::ProcMacroAttrExpansionDisabled => RenderedExpandError {
                 message: "procedural attribute macro expansion is disabled".to_owned(),
         ExpandError { inner: Arc::new((ExpandErrorKind::Mbe(mbe.inner.1.clone()), mbe.inner.0)) }
     }
 }
+
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub struct MacroCallLoc {
     pub def: MacroDefId,
         expand_to: ExpandTo,
         /// Some if this is a macro call for an eager macro. Note that this is `None`
         /// for the eager input macro file.
-        // FIXME: This is being interned, subtrees can vary quickly differing just slightly causing
-        // leakage problems here
         eager: Option<Arc<EagerCallInfo>>,
     },
     Derive {
     },
     Attr {
         ast_id: AstId<ast::Item>,
-        // FIXME: This shouldn't be here, we can derive this from `invoc_attr_index`
-        // but we need to fix the `cfg_attr` handling first.
         attr_args: Option<Arc<tt::TopSubtree>>,
         /// Syntactical index of the invoking `#[attribute]`.
         ///
 }
 
 impl HirFileId {
-    pub fn edition(self, db: &dyn ExpandDatabase) -> Edition {
+    pub fn edition(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> Edition {
         match self {
             HirFileId::FileId(file_id) => file_id.editioned_file_id(db).edition(),
             HirFileId::MacroFile(m) => db.lookup_intern_macro_call(m).def.edition,
         }
     }
-    pub fn original_file(self, db: &dyn ExpandDatabase) -> EditionedFileId {
+
+    pub fn original_file(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> EditionedFileId {
         let mut file_id = self;
         loop {
             match file_id {
         }
     }
 
-    pub fn original_file_respecting_includes(mut self, db: &dyn ExpandDatabase) -> EditionedFileId {
+    pub fn original_file_respecting_includes(
+        mut self,
+        db: &dyn ExpandDatabase,
+    ) -> EditionedFileId {
         loop {
             match self {
                 HirFileId::FileId(id) => break id,
         }
     }
 
-    pub fn original_call_node(self, db: &dyn ExpandDatabase) -> Option<InRealFile<SyntaxNode>> {
+    pub fn original_call_node(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> Option<InRealFile<SyntaxNode>> {
         let mut call = db.lookup_intern_macro_call(self.macro_file()?).to_node(db);
         loop {
             match call.file_id {
         }
     }
 
-    pub fn call_node(self, db: &dyn ExpandDatabase) -> Option<InFile<SyntaxNode>> {
+    pub fn call_node(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> Option<InFile<SyntaxNode>> {
         Some(db.lookup_intern_macro_call(self.macro_file()?).to_node(db))
     }
 
 }
 
 impl MacroCallId {
-    pub fn call_node(self, db: &dyn ExpandDatabase) -> InFile<SyntaxNode> {
+    pub fn call_node(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> InFile<SyntaxNode> {
         db.lookup_intern_macro_call(self).to_node(db)
     }
-    pub fn expansion_level(self, db: &dyn ExpandDatabase) -> u32 {
+
+    pub fn expansion_level(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> u32 {
         let mut level = 0;
         let mut macro_file = self;
         loop {
             };
         }
     }
-    pub fn parent(self, db: &dyn ExpandDatabase) -> HirFileId {
+
+    pub fn parent(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> HirFileId {
         db.lookup_intern_macro_call(self).kind.file_id()
     }
 
     /// Return expansion information if it is a macro-expansion file
-    pub fn expansion_info(self, db: &dyn ExpandDatabase) -> ExpansionInfo {
+    pub fn expansion_info(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> ExpansionInfo {
         ExpansionInfo::new(db, self)
     }
 
-    pub fn kind(self, db: &dyn ExpandDatabase) -> MacroKind {
+    pub fn kind(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> MacroKind {
         match db.lookup_intern_macro_call(self).def.kind {
             MacroDefKind::Declarative(..) => MacroKind::Declarative,
             MacroDefKind::BuiltIn(..) | MacroDefKind::BuiltInEager(..) => {
         }
     }
 
-    pub fn is_include_macro(self, db: &dyn ExpandDatabase) -> bool {
+    pub fn is_include_macro(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> bool {
         db.lookup_intern_macro_call(self).def.is_include()
     }
 
-    pub fn is_include_like_macro(self, db: &dyn ExpandDatabase) -> bool {
+    pub fn is_include_like_macro(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> bool {
         db.lookup_intern_macro_call(self).def.is_include_like()
     }
 
-    pub fn is_env_or_option_env(self, db: &dyn ExpandDatabase) -> bool {
+    pub fn is_env_or_option_env(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> bool {
         db.lookup_intern_macro_call(self).def.is_env_or_option_env()
     }
 
-    pub fn is_eager(self, db: &dyn ExpandDatabase) -> bool {
+    pub fn is_eager(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> bool {
         let loc = db.lookup_intern_macro_call(self);
         matches!(loc.def.kind, MacroDefKind::BuiltInEager(..))
     }
 
-    pub fn eager_arg(self, db: &dyn ExpandDatabase) -> Option<MacroCallId> {
+    pub fn eager_arg(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> Option<MacroCallId> {
         let loc = db.lookup_intern_macro_call(self);
         match &loc.kind {
             MacroCallKind::FnLike { eager, .. } => eager.as_ref().map(|it| it.arg_id),
         }
     }
 
-    pub fn is_derive_attr_pseudo_expansion(self, db: &dyn ExpandDatabase) -> bool {
+    pub fn is_derive_attr_pseudo_expansion(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> bool {
         let loc = db.lookup_intern_macro_call(self);
         loc.def.is_attribute_derive()
     }
         db.intern_macro_call(MacroCallLoc { def: self, krate, kind, ctxt })
     }
 
-    pub fn definition_range(&self, db: &dyn ExpandDatabase) -> InFile<TextRange> {
+    pub fn definition_range(
+        &self,
+        db: &dyn ExpandDatabase,
+    ) -> InFile<TextRange> {
         match self.kind {
             MacroDefKind::Declarative(id)
             | MacroDefKind::BuiltIn(id, _)
 }
 
 impl MacroCallLoc {
-    pub fn to_node(&self, db: &dyn ExpandDatabase) -> InFile<SyntaxNode> {
+    pub fn to_node(
+        &self,
+        db: &dyn ExpandDatabase,
+    ) -> InFile<SyntaxNode> {
         match self.kind {
             MacroCallKind::FnLike { ast_id, .. } => {
                 ast_id.with_value(ast_id.to_node(db).syntax().clone())
         }
     }
 
-    pub fn to_node_item(&self, db: &dyn ExpandDatabase) -> InFile<ast::Item> {
+    pub fn to_node_item(
+        &self,
+        db: &dyn ExpandDatabase,
+    ) -> InFile<ast::Item> {
         match self.kind {
             MacroCallKind::FnLike { ast_id, .. } => {
                 InFile::new(ast_id.file_id, ast_id.map(FileAstId::upcast).to_node(db))
         {
             return Some(it);
         }
-
         None
     }
 }
     /// - fn_like! {}, it spans the path and token tree
     /// - #\[derive], it spans the `#[derive(...)]` attribute and the annotated item
     /// - #\[attr], it spans the `#[attr(...)]` attribute and the annotated item
-    pub fn original_call_range_with_input(self, db: &dyn ExpandDatabase) -> FileRange {
+    pub fn original_call_range_with_input(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> FileRange {
         let mut kind = self;
         let file_id = loop {
             match kind.file_id() {
                 HirFileId::FileId(file_id) => break file_id,
             }
         };
-
         let range = match kind {
             MacroCallKind::FnLike { ast_id, .. } => ast_id.to_ptr(db).text_range(),
             MacroCallKind::Derive { ast_id, .. } => ast_id.to_ptr(db).text_range(),
             MacroCallKind::Attr { ast_id, .. } => ast_id.to_ptr(db).text_range(),
         };
-
         FileRange { range, file_id }
     }
 
     /// Here we try to roughly match what rustc does to improve diagnostics: fn-like macros
     /// get the macro path (rustc shows the whole `ast::MacroCall`), attribute macros get the
     /// attribute's range, and derives get only the specific derive that is being referred to.
-    pub fn original_call_range(self, db: &dyn ExpandDatabase) -> FileRange {
+    pub fn original_call_range(
+        self,
+        db: &dyn ExpandDatabase,
+    ) -> FileRange {
         let mut kind = self;
         let file_id = loop {
             match kind.file_id() {
                 HirFileId::FileId(file_id) => break file_id,
             }
         };
-
         let range = match kind {
             MacroCallKind::FnLike { ast_id, .. } => {
                 let node = ast_id.to_node(db);
                     .text_range()
             }
         };
-
         FileRange { range, file_id }
     }
 
-    fn arg(&self, db: &dyn ExpandDatabase) -> InFile<Option<SyntaxNode>> {
+    fn arg(
+        &self,
+        db: &dyn ExpandDatabase,
+    ) -> InFile<Option<SyntaxNode>> {
         match self {
             MacroCallKind::FnLike { ast_id, .. } => {
                 ast_id.to_in_file_node(db).map(|it| Some(it.token_tree()?.syntax().clone()))
 }
 
 /// ExpansionInfo mainly describes how to map text range between src and expanded macro
-// FIXME: can be expensive to create, we should check the use sites and maybe replace them with
-// simpler function calls if the map is only used once
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct ExpansionInfo {
     expanded: InMacroFile<SyntaxNode>,
     /// Maps the passed in file range down into a macro expansion if it is the input to a macro call.
     ///
     /// Note this does a linear search through the entire backing vector of the spanmap.
-    // FIXME: Consider adding a reverse map to ExpansionInfo to get rid of the linear search which
-    // potentially results in quadratic look ups (notably this might improve semantic highlighting perf)
     pub fn map_range_down_exact(
         &self,
         span: Span,
         let tokens = self.exp_map.ranges_with_span_exact(span).flat_map(move |(range, ctx)| {
             self.expanded.value.covering_element(range).into_token().zip(Some(ctx))
         });
-
         Some(InMacroFile::new(self.expanded.file_id, tokens))
     }
 
         let tokens = self.exp_map.ranges_with_span(span).flat_map(move |(range, ctx)| {
             self.expanded.value.covering_element(range).into_token().zip(Some(ctx))
         });
-
         Some(InMacroFile::new(self.expanded.file_id, tokens))
     }
 
         }
     }
 
-    pub fn new(db: &dyn ExpandDatabase, macro_file: MacroCallId) -> ExpansionInfo {
+    pub fn new(
+        db: &dyn ExpandDatabase,
+        macro_file: MacroCallId,
+    ) -> ExpansionInfo {
         let _p = tracing::info_span!("ExpansionInfo::new").entered();
         let loc = db.lookup_intern_macro_call(macro_file);
-
         let arg_tt = loc.kind.arg(db);
         let arg_map = db.span_map(arg_tt.file_id);
-
         let (parse, exp_map) = db.parse_macro_expansion(macro_file).value;
         let expanded = InMacroFile { file_id: macro_file, value: parse.syntax_node() };
-
         ExpansionInfo { expanded, loc, arg: arg_tt, exp_map, arg_map }
     }
 }
     let Span { range, anchor, ctx: _ } = spans.next()?;
     let mut start = range.start();
     let mut end = range.end();
-
     for span in spans {
         if span.anchor != anchor {
             return None;
     let Span { range, anchor, ctx } = spans.next()?;
     let mut start = range.start();
     let mut end = range.end();
-
     for span in spans {
         if span.anchor != anchor || span.ctx != ctx {
             return None;
 impl ExpandTo {
     pub fn from_call_site(call: &ast::MacroCall) -> ExpandTo {
         use syntax::SyntaxKind::*;
-
         let syn = call.syntax();
-
         let parent = match syn.parent() {
             Some(it) => it,
             None => return ExpandTo::Statements,
         };
-
         // FIXME: macros in statement position are treated as expression statements, they should
         // probably be their own statement kind. The *grand*parent indicates what's valid.
         if parent.kind() == MACRO_EXPR
         {
             return ExpandTo::Statements;
         }
-
         match parent.kind() {
             MACRO_ITEMS | SOURCE_FILE | ITEM_LIST => ExpandTo::Items,
             MACRO_STMTS | EXPR_STMT | STMT_LIST => ExpandTo::Statements,
         }
     }
 }
-
-intern::impl_internable!(ModPath, attrs::AttrInput);
-
 #[salsa_macros::interned(no_lifetime, debug, revisions = usize::MAX)]
 #[doc(alias = "MacroFileId")]
 pub struct MacroCallId {
 }
 
 impl PartialEq<EditionedFileId> for HirFileId {
-    fn eq(&self, &other: &EditionedFileId) -> bool {
+    fn eq(
+        &self,
+        &other: &EditionedFileId,
+    ) -> bool {
         *self == HirFileId::from(other)
     }
 }
+
 impl PartialEq<HirFileId> for EditionedFileId {
-    fn eq(&self, &other: &HirFileId) -> bool {
+    fn eq(
+        &self,
+        &other: &HirFileId,
+    ) -> bool {
         other == HirFileId::from(*self)
     }
 }