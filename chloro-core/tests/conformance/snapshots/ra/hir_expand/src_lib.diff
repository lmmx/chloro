COMPARISON DIFF
============================================================

Original size: 40650 bytes
Chloro size:   40229 bytes
Rustfmt size:  40650 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! `hir_expand` deals with macro expansion.
 //!
 //! Specifically, it implements a concept of `MacroFile` -- a file whose syntax
 //! tree originates not from the text of some `FileId`, but from some macro
 //! expansion.
+
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
+use core::fmt;
+use std::hash::Hash;
+
+use attrs::collect_attrs;
+use base_db::Crate;
+pub use base_db::EditionedFileId;
+use either::Either;
 pub use intern;
+pub use mbe::{DeclarativeMacro, ValueResult};
+use rustc_hash::FxHashMap;
+use salsa::plumbing::{AsId, FromId};
+use span::{Edition, ErasedFileAstId, FileAstId, Span, SpanAnchor, SyntaxContext};
+use stdx::TupleExt;
+use syntax::{
+    ast::{self, AstNode},
+    SyntaxNode, SyntaxToken, TextRange, TextSize,
+};
+use triomphe::Arc;
+
+use crate::{
+    attrs::AttrId,
+    builtin::{
+        include_input_to_file_id, BuiltinAttrExpander, BuiltinDeriveExpander,
+        BuiltinFnLikeExpander, EagerExpander,
+    },
+    db::ExpandDatabase,
+    mod_path::ModPath,
+    proc_macro::{CustomProcMacroExpander, ProcMacroKind},
+    span_map::{ExpansionSpanMap, SpanMap},
+};
+pub use crate::{
+    cfg_process::check_cfg_attr_value,
+    files::{AstId, ErasedAstId, FileRange, InFile, InMacroFile, InRealFile},
+    prettify_macro_expansion_::prettify_macro_expansion,
+};
 
 pub mod attrs;
 pub mod builtin;
 pub mod name;
 pub mod proc_macro;
 pub mod span_map;
-
 mod cfg_process;
 mod fixup;
 mod prettify_macro_expansion_;
-
-use attrs::collect_attrs;
-use rustc_hash::FxHashMap;
-use salsa::plumbing::{AsId, FromId};
-use stdx::TupleExt;
-use triomphe::Arc;
-
-use core::fmt;
-use std::hash::Hash;
-
-use base_db::Crate;
-use either::Either;
-use span::{Edition, ErasedFileAstId, FileAstId, Span, SpanAnchor, SyntaxContext};
-use syntax::{
-    SyntaxNode, SyntaxToken, TextRange, TextSize,
-    ast::{self, AstNode},
-};
-
-use crate::{
-    attrs::AttrId,
-    builtin::{
-        BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerExpander,
-        include_input_to_file_id,
-    },
-    db::ExpandDatabase,
-    mod_path::ModPath,
-    proc_macro::{CustomProcMacroExpander, ProcMacroKind},
-    span_map::{ExpansionSpanMap, SpanMap},
-};
-
-pub use crate::{
-    cfg_process::check_cfg_attr_value,
-    files::{AstId, ErasedAstId, FileRange, InFile, InMacroFile, InRealFile},
-    prettify_macro_expansion_::prettify_macro_expansion,
-};
-
-pub use base_db::EditionedFileId;
-pub use mbe::{DeclarativeMacro, ValueResult};
-
 pub mod tt {
     pub use span::Span;
-    pub use tt::{DelimiterKind, IdentIsRaw, LitKind, Spacing, token_to_literal};
-
+    pub use tt::{token_to_literal, DelimiterKind, IdentIsRaw, LitKind, Spacing};
     pub type Delimiter = ::tt::Delimiter<Span>;
     pub type DelimSpan = ::tt::DelimSpan<Span>;
     pub type Subtree = ::tt::Subtree<Span>;
     };
 }
 
-// ideally these would be defined in base-db, but the orphan rule doesn't let us
 pub trait Intern {
-    type Database: ?Sized;
+    type Database;
+
     type ID;
+
     fn intern(self, db: &Self::Database) -> Self::ID;
 }
 
 pub trait Lookup {
-    type Database: ?Sized;
+    type Database;
+
     type Data;
+
     fn lookup(&self, db: &Self::Database) -> Self::Data;
 }
 
     pub fn new(span: Span, kind: ExpandErrorKind) -> Self {
         ExpandError { inner: Arc::new((kind, span)) }
     }
+
     pub fn other(span: Span, msg: impl Into<Box<str>>) -> Self {
         ExpandError { inner: Arc::new((ExpandErrorKind::Other(msg.into()), span)) }
     }
+
     pub fn kind(&self) -> &ExpandErrorKind {
         &self.inner.0
     }
+
     pub fn span(&self) -> Span {
         self.inner.1
     }
 
 impl RenderedExpandError {
     const GENERAL_KIND: &str = "macro-error";
+
     const DISABLED: &str = "proc-macro-disabled";
+
     const ATTR_EXP_DISABLED: &str = "attribute-expansion-disabled";
 }
 
         ExpandError { inner: Arc::new((ExpandErrorKind::Mbe(mbe.inner.1.clone()), mbe.inner.0)) }
     }
 }
+
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub struct MacroCallLoc {
     pub def: MacroDefId,
     FnLike {
         ast_id: AstId<ast::MacroCall>,
         expand_to: ExpandTo,
-        /// Some if this is a macro call for an eager macro. Note that this is `None`
-        /// for the eager input macro file.
         // FIXME: This is being interned, subtrees can vary quickly differing just slightly causing
         // leakage problems here
+        /// Some if this is a macro call for an eager macro. Note that this is `None`
+        /// for the eager input macro file.
         eager: Option<Arc<EagerCallInfo>>,
     },
     Derive {
             HirFileId::MacroFile(m) => db.lookup_intern_macro_call(m).def.edition,
         }
     }
+
     pub fn original_file(self, db: &dyn ExpandDatabase) -> EditionedFileId {
         let mut file_id = self;
         loop {
         }
     }
 
-    pub fn original_file_respecting_includes(mut self, db: &dyn ExpandDatabase) -> EditionedFileId {
+    pub fn original_file_respecting_includes(
+        mut self,
+        db: &dyn ExpandDatabase,
+    ) -> EditionedFileId {
         loop {
             match self {
                 HirFileId::FileId(id) => break id,
     pub fn call_node(self, db: &dyn ExpandDatabase) -> InFile<SyntaxNode> {
         db.lookup_intern_macro_call(self).to_node(db)
     }
+
     pub fn expansion_level(self, db: &dyn ExpandDatabase) -> u32 {
         let mut level = 0;
         let mut macro_file = self;
         loop {
             let loc = db.lookup_intern_macro_call(macro_file);
-
             level += 1;
             macro_file = match loc.kind.file_id() {
                 HirFileId::FileId(_) => break level,
             };
         }
     }
+
     pub fn parent(self, db: &dyn ExpandDatabase) -> HirFileId {
         db.lookup_intern_macro_call(self).kind.file_id()
     }
 }
 
 /// ExpansionInfo mainly describes how to map text range between src and expanded macro
-// FIXME: can be expensive to create, we should check the use sites and maybe replace them with
-// simpler function calls if the map is only used once
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct ExpansionInfo {
     expanded: InMacroFile<SyntaxNode>,
     /// Maps the passed in file range down into a macro expansion if it is the input to a macro call.
     ///
     /// Note this does a linear search through the entire backing vector of the spanmap.
-    // FIXME: Consider adding a reverse map to ExpansionInfo to get rid of the linear search which
-    // potentially results in quadratic look ups (notably this might improve semantic highlighting perf)
     pub fn map_range_down_exact(
         &self,
         span: Span,
         };
 
         // FIXME: macros in statement position are treated as expression statements, they should
+
         // probably be their own statement kind. The *grand*parent indicates what's valid.
         if parent.kind() == MACRO_EXPR
             && parent
         *self == HirFileId::from(other)
     }
 }
+
 impl PartialEq<HirFileId> for EditionedFileId {
     fn eq(&self, &other: &HirFileId) -> bool {
         other == HirFileId::from(*self)