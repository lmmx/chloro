COMPARISON DIFF
============================================================

Original size: 40650 bytes
Chloro size:   39967 bytes
Rustfmt size:  40650 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! `hir_expand` deals with macro expansion.
 //!
 //! Specifically, it implements a concept of `MacroFile` -- a file whose syntax
 //! tree originates not from the text of some `FileId`, but from some macro
 //! expansion.
-#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
-pub use intern;
+#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
 pub mod attrs;
 pub mod builtin;
 pub mod name;
 pub mod proc_macro;
 pub mod span_map;
-
 mod cfg_process;
 mod fixup;
 mod prettify_macro_expansion_;
 
-use attrs::collect_attrs;
-use rustc_hash::FxHashMap;
-use salsa::plumbing::{AsId, FromId};
-use stdx::TupleExt;
-use triomphe::Arc;
-
 use core::fmt;
 use std::hash::Hash;
 
+use attrs::collect_attrs;
 use base_db::Crate;
+pub use base_db::EditionedFileId;
 use either::Either;
+pub use intern;
+pub use mbe::{DeclarativeMacro, ValueResult};
+use rustc_hash::FxHashMap;
+use salsa::plumbing::{AsId, FromId};
 use span::{Edition, ErasedFileAstId, FileAstId, Span, SpanAnchor, SyntaxContext};
+use stdx::TupleExt;
 use syntax::{
-    SyntaxNode, SyntaxToken, TextRange, TextSize,
     ast::{self, AstNode},
+    SyntaxNode, SyntaxToken, TextRange, TextSize,
 };
+use triomphe::Arc;
 
 use crate::{
     attrs::AttrId,
     builtin::{
-        BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerExpander,
-        include_input_to_file_id,
+        include_input_to_file_id, BuiltinAttrExpander, BuiltinDeriveExpander,
+        BuiltinFnLikeExpander, EagerExpander,
     },
     db::ExpandDatabase,
     mod_path::ModPath,
     proc_macro::{CustomProcMacroExpander, ProcMacroKind},
     span_map::{ExpansionSpanMap, SpanMap},
 };
-
 pub use crate::{
     cfg_process::check_cfg_attr_value,
     files::{AstId, ErasedAstId, FileRange, InFile, InMacroFile, InRealFile},
     prettify_macro_expansion_::prettify_macro_expansion,
 };
 
-pub use base_db::EditionedFileId;
-pub use mbe::{DeclarativeMacro, ValueResult};
-
 pub mod tt {
     pub use span::Span;
-    pub use tt::{DelimiterKind, IdentIsRaw, LitKind, Spacing, token_to_literal};
-
+    pub use tt::{token_to_literal, DelimiterKind, IdentIsRaw, LitKind, Spacing};
     pub type Delimiter = ::tt::Delimiter<Span>;
     pub type DelimSpan = ::tt::DelimSpan<Span>;
     pub type Subtree = ::tt::Subtree<Span>;
     };
 }
 
-// ideally these would be defined in base-db, but the orphan rule doesn't let us
 pub trait Intern {
-    type Database: ?Sized;
+    type Database;
+
     type ID;
+
     fn intern(self, db: &Self::Database) -> Self::ID;
 }
 
 pub trait Lookup {
-    type Database: ?Sized;
+    type Database;
+
     type Data;
+
     fn lookup(&self, db: &Self::Database) -> Self::Data;
 }
 
     pub fn new(span: Span, kind: ExpandErrorKind) -> Self {
         ExpandError { inner: Arc::new((kind, span)) }
     }
+
     pub fn other(span: Span, msg: impl Into<Box<str>>) -> Self {
         ExpandError { inner: Arc::new((ExpandErrorKind::Other(msg.into()), span)) }
     }
+
     pub fn kind(&self) -> &ExpandErrorKind {
         &self.inner.0
     }
+
     pub fn span(&self) -> Span {
         self.inner.1
     }
 
 impl RenderedExpandError {
     const GENERAL_KIND: &str = "macro-error";
+
     const DISABLED: &str = "proc-macro-disabled";
+
     const ATTR_EXP_DISABLED: &str = "attribute-expansion-disabled";
 }
 
                         kind: RenderedExpandError::GENERAL_KIND,
                     },
                 }
-            }
+            },
             ExpandErrorKind::MacroDefinition => RenderedExpandError {
                 message: "macro definition has parse errors".to_owned(),
                 error: true,
         ExpandError { inner: Arc::new((ExpandErrorKind::Mbe(mbe.inner.1.clone()), mbe.inner.0)) }
     }
 }
+
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub struct MacroCallLoc {
     pub def: MacroDefId,
     FnLike {
         ast_id: AstId<ast::MacroCall>,
         expand_to: ExpandTo,
-        /// Some if this is a macro call for an eager macro. Note that this is `None`
-        /// for the eager input macro file.
         // FIXME: This is being interned, subtrees can vary quickly differing just slightly causing
         // leakage problems here
+        /// Some if this is a macro call for an eager macro. Note that this is `None`
+        /// for the eager input macro file.
         eager: Option<Arc<EagerCallInfo>>,
     },
     Derive {
             HirFileId::MacroFile(m) => db.lookup_intern_macro_call(m).def.edition,
         }
     }
+
     pub fn original_file(self, db: &dyn ExpandDatabase) -> EditionedFileId {
         let mut file_id = self;
         loop {
                 HirFileId::FileId(id) => break id,
                 HirFileId::MacroFile(macro_call_id) => {
                     file_id = db.lookup_intern_macro_call(macro_call_id).kind.file_id()
-                }
+                },
             }
         }
     }
 
-    pub fn original_file_respecting_includes(mut self, db: &dyn ExpandDatabase) -> EditionedFileId {
+    pub fn original_file_respecting_includes(
+        mut self,
+        db: &dyn ExpandDatabase,
+    ) -> EditionedFileId {
         loop {
             match self {
                 HirFileId::FileId(id) => break id,
                         break it;
                     }
                     self = loc.kind.file_id();
-                }
+                },
             }
         }
     }
             match call.file_id {
                 HirFileId::FileId(file_id) => {
                     break Some(InRealFile { file_id, value: call.value });
-                }
+                },
                 HirFileId::MacroFile(macro_call_id) => {
                     call = db.lookup_intern_macro_call(macro_call_id).to_node(db);
-                }
+                },
             }
         }
     }
     pub fn call_node(self, db: &dyn ExpandDatabase) -> InFile<SyntaxNode> {
         db.lookup_intern_macro_call(self).to_node(db)
     }
+
     pub fn expansion_level(self, db: &dyn ExpandDatabase) -> u32 {
         let mut level = 0;
         let mut macro_file = self;
         loop {
             let loc = db.lookup_intern_macro_call(macro_file);
-
             level += 1;
             macro_file = match loc.kind.file_id() {
                 HirFileId::FileId(_) => break level,
             };
         }
     }
+
     pub fn parent(self, db: &dyn ExpandDatabase) -> HirFileId {
         db.lookup_intern_macro_call(self).kind.file_id()
     }
             MacroDefKind::Declarative(..) => MacroKind::Declarative,
             MacroDefKind::BuiltIn(..) | MacroDefKind::BuiltInEager(..) => {
                 MacroKind::DeclarativeBuiltIn
-            }
+            },
             MacroDefKind::BuiltInDerive(..) => MacroKind::DeriveBuiltIn,
             MacroDefKind::ProcMacro(_, _, ProcMacroKind::CustomDerive) => MacroKind::Derive,
             MacroDefKind::ProcMacro(_, _, ProcMacroKind::Attr) => MacroKind::Attr,
             | MacroDefKind::BuiltInDerive(id, _)
             | MacroDefKind::BuiltInEager(id, _) => {
                 id.with_value(db.ast_id_map(id.file_id).get(id.value).text_range())
-            }
+            },
             MacroDefKind::ProcMacro(id, _, _) => {
                 id.with_value(db.ast_id_map(id.file_id).get(id.value).text_range())
-            }
+            },
         }
     }
 
         match self.kind {
             MacroCallKind::FnLike { ast_id, .. } => {
                 ast_id.with_value(ast_id.to_node(db).syntax().clone())
-            }
+            },
             MacroCallKind::Derive { ast_id, derive_attr_index, .. } => {
-                // FIXME: handle `cfg_attr`
                 ast_id.with_value(ast_id.to_node(db)).map(|it| {
-                    collect_attrs(&it)
-                        .nth(derive_attr_index.ast_index())
-                        .and_then(|it| match it.1 {
-                            Either::Left(attr) => Some(attr.syntax().clone()),
-                            Either::Right(_) => None,
-                        })
-                        .unwrap_or_else(|| it.syntax().clone())
+                    collect_attrs(&it).nth(derive_attr_index.ast_index()).and_then(|it| match it.1 {
+                        Either::Left(attr) => Some(attr.syntax().clone()),
+                        Either::Right(_) => None,
+                    }).unwrap_or_else(
+                        || it.syntax().clone(),
+                    )
                 })
-            }
+            },
             MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {
                 if self.def.is_attribute_derive() {
-                    // FIXME: handle `cfg_attr`
                     ast_id.with_value(ast_id.to_node(db)).map(|it| {
-                        collect_attrs(&it)
-                            .nth(invoc_attr_index.ast_index())
-                            .and_then(|it| match it.1 {
-                                Either::Left(attr) => Some(attr.syntax().clone()),
-                                Either::Right(_) => None,
-                            })
-                            .unwrap_or_else(|| it.syntax().clone())
+                        collect_attrs(&it).nth(invoc_attr_index.ast_index()).and_then(|it| match it.1 {
+                            Either::Left(attr) => Some(attr.syntax().clone()),
+                            Either::Right(_) => None,
+                        }).unwrap_or_else(
+                            || it.syntax().clone(),
+                        )
                     })
                 } else {
                     ast_id.with_value(ast_id.to_node(db).syntax().clone())
                 }
-            }
+            },
         }
     }
 
         match self.kind {
             MacroCallKind::FnLike { ast_id, .. } => {
                 InFile::new(ast_id.file_id, ast_id.map(FileAstId::upcast).to_node(db))
-            }
+            },
             MacroCallKind::Derive { ast_id, .. } => {
                 InFile::new(ast_id.file_id, ast_id.map(FileAstId::upcast).to_node(db))
-            }
+            },
             MacroCallKind::Attr { ast_id, .. } => InFile::new(ast_id.file_id, ast_id.to_node(db)),
         }
     }
             MacroCallKind::Derive { .. } => ExpandTo::Items,
             MacroCallKind::Attr { .. } if self.def.is_attribute_derive() => ExpandTo::Items,
             MacroCallKind::Attr { .. } => {
-                // FIXME(stmt_expr_attributes)
                 ExpandTo::Items
-            }
+            },
         }
     }
 
         match self {
             MacroCallKind::FnLike { ast_id, .. } => {
                 ast_id.to_in_file_node(db).map(|it| Some(it.token_tree()?.syntax().clone()))
-            }
+            },
             MacroCallKind::Derive { ast_id, .. } => {
                 ast_id.to_in_file_node(db).syntax().cloned().map(Some)
-            }
+            },
             MacroCallKind::Attr { ast_id, .. } => {
                 ast_id.to_in_file_node(db).syntax().cloned().map(Some)
-            }
+            },
         }
     }
 }
 
 /// ExpansionInfo mainly describes how to map text range between src and expanded macro
-// FIXME: can be expensive to create, we should check the use sites and maybe replace them with
-// simpler function calls if the map is only used once
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct ExpansionInfo {
     expanded: InMacroFile<SyntaxNode>,
     /// Maps the passed in file range down into a macro expansion if it is the input to a macro call.
     ///
     /// Note this does a linear search through the entire backing vector of the spanmap.
-    // FIXME: Consider adding a reverse map to ExpansionInfo to get rid of the linear search which
-    // potentially results in quadratic look ups (notably this might improve semantic highlighting perf)
     pub fn map_range_down_exact(
         &self,
         span: Span,
                 let anchor_offset =
                     db.ast_id_map(file_id).get_erased(span.anchor.ast_id).text_range().start();
                 InFile { file_id, value: smallvec::smallvec![span.range + anchor_offset] }
-            }
+            },
             SpanMap::ExpansionSpanMap(arg_map) => {
                 let Some(arg_node) = &self.arg.value else {
                     return InFile::new(self.arg.file_id, smallvec::smallvec![]);
                 let arg_range = arg_node.text_range();
                 InFile::new(
                     self.arg.file_id,
-                    arg_map
-                        .ranges_with_span_exact(span)
-                        .filter(|(range, _)| range.intersect(arg_range).is_some())
-                        .map(TupleExt::head)
-                        .collect(),
+                    arg_map.ranges_with_span_exact(span).filter(
+                    |(range, _)| range.intersect(arg_range).is_some(),
+                ).map(
+                    TupleExt::head,
+                ).collect(
+                ),
                 )
-            }
+            },
         }
     }
 
         };
 
         // FIXME: macros in statement position are treated as expression statements, they should
+
         // probably be their own statement kind. The *grand*parent indicates what's valid.
         if parent.kind() == MACRO_EXPR
             && parent
             MACRO_STMTS | EXPR_STMT | STMT_LIST => ExpandTo::Statements,
             MACRO_PAT => ExpandTo::Pattern,
             MACRO_TYPE => ExpandTo::Type,
-
             ARG_LIST | ARRAY_EXPR | AWAIT_EXPR | BIN_EXPR | BREAK_EXPR | CALL_EXPR | CAST_EXPR
             | CLOSURE_EXPR | FIELD_EXPR | FOR_EXPR | IF_EXPR | INDEX_EXPR | LET_EXPR
             | MATCH_ARM | MATCH_EXPR | MATCH_GUARD | METHOD_CALL_EXPR | PAREN_EXPR | PATH_EXPR
             | PREFIX_EXPR | RANGE_EXPR | RECORD_EXPR_FIELD | REF_EXPR | RETURN_EXPR | TRY_EXPR
             | TUPLE_EXPR | WHILE_EXPR | MACRO_EXPR => ExpandTo::Expr,
             _ => {
-                // Unknown , Just guess it is `Items`
                 ExpandTo::Items
-            }
+            },
         }
     }
 }
         *self == HirFileId::from(other)
     }
 }
+
 impl PartialEq<HirFileId> for EditionedFileId {
     fn eq(&self, &other: &HirFileId) -> bool {
         other == HirFileId::from(*self)