COMPARISON DIFF
============================================================

Original size: 10482 bytes
Chloro size:   10474 bytes
Rustfmt size:  10879 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //!
 //! See the full discussion : <https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Eager.20expansion.20of.20built-in.20macros>
+
 use base_db::Crate;
 use span::SyntaxContext;
-use syntax::{ted, AstPtr, Parse, SyntaxElement, SyntaxNode, TextSize, WalkEvent};
+use syntax::{AstPtr, Parse, SyntaxElement, SyntaxNode, TextSize, WalkEvent, ted};
 use syntax_bridge::DocCommentDesugarMode;
 use triomphe::Arc;
 
     MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind,
 };
 
-pub type EagerCallBackFn<'a> = &'a mut dyn FnMut(
-    InFile<(
-        syntax::AstPtr<ast::MacroCall>,
-        span::FileAstId<ast::MacroCall>,
-    )>,
+pub type EagerCallBackFn<'a> =
+    &'a mut dyn FnMut(
+    InFile<(syntax::AstPtr<ast::MacroCall>, span::FileAstId<ast::MacroCall>)>,
     MacroCallId,
 );
 
     eager_callback: EagerCallBackFn<'_>,
 ) -> ExpandResult<Option<MacroCallId>> {
     let expand_to = ExpandTo::from_call_site(macro_call);
-
     // Note:
     // When `lazy_expand` is called, its *parent* file must already exist.
     // Here we store an eager macro id for the argument expanded subtree
     let loc = MacroCallLoc {
         def,
         krate,
-        kind: MacroCallKind::FnLike {
-            ast_id,
-            expand_to: ExpandTo::Expr,
-            eager: None,
-        },
+        kind: MacroCallKind::FnLike { ast_id, expand_to: ExpandTo::Expr, eager: None },
         ctxt: call_site,
     };
     let arg_id = db.intern_macro_call(loc);
     #[allow(deprecated)] // builtin eager macros are never derives
     let (_, _, span) = db.macro_arg(arg_id);
-    let ExpandResult {
-        value: (arg_exp, arg_exp_map),
-        err: parse_err,
-    } = db.parse_macro_expansion(arg_id);
-
+    let ExpandResult { value: (arg_exp, arg_exp_map), err: parse_err } =
+        db.parse_macro_expansion(arg_id);
     let mut arg_map = ExpansionSpanMap::empty();
-
-    let ExpandResult {
-        value: expanded_eager_input,
-        err,
-    } = {
+    let ExpandResult { value: expanded_eager_input, err } = {
         eager_macro_recur(
             db,
             &arg_exp_map,
     if cfg!(debug_assertions) {
         arg_map.finish();
     }
-
     let Some((expanded_eager_input, _mapping)) = expanded_eager_input else {
         return ExpandResult { value: None, err };
     };
-
     let mut subtree = syntax_bridge::syntax_node_to_token_tree(
         &expanded_eager_input,
         arg_map,
         span,
         DocCommentDesugarMode::Mbe,
     );
-
     subtree.top_subtree_delimiter_mut().kind = crate::tt::DelimiterKind::Invisible;
-
     let loc = MacroCallLoc {
         def,
         krate,
         },
         ctxt: call_site,
     };
-
-    ExpandResult {
-        value: Some(db.intern_macro_call(loc)),
-        err,
-    }
+    ExpandResult { value: Some(db.intern_macro_call(loc)), err }
 }
 
 fn lazy_expand(
     let id = def.make_call(
         db,
         krate,
-        MacroCallKind::FnLike {
-            ast_id,
-            expand_to,
-            eager: None,
-        },
+        MacroCallKind::FnLike { ast_id, expand_to, eager: None },
         call_site,
     );
     eager_callback(ast_id.map(|ast_id| (AstPtr::new(macro_call), ast_id)), id);
-
-    db.parse_macro_expansion(id)
-        .map(|parse| (InFile::new(id.into(), parse.0), parse.1))
+    db.parse_macro_expansion(id).map(|parse| (InFile::new(id.into(), parse.0), parse.1))
 }
 
 fn eager_macro_recur(
     eager_callback: EagerCallBackFn<'_>,
 ) -> ExpandResult<Option<(SyntaxNode, TextSize)>> {
     let original = curr.value.clone_for_update();
-
     let mut replacements = Vec::new();
-
     // FIXME: We only report a single error inside of eager expansions
     let mut error = None;
     let mut children = original.preorder_with_tokens();
-
     // Collect replacement
     while let Some(child) = children.next() {
         let call = match child {
                 match value {
                     Some(call_id) => {
                         eager_callback(
-                            curr.with_value(ast_id)
-                                .map(|ast_id| (AstPtr::new(&call), ast_id)),
+                            curr.with_value(ast_id).map(|ast_id| (AstPtr::new(&call), ast_id)),
                             call_id,
                         );
-                        let ExpandResult {
-                            value: (parse, map),
-                            err: err2,
-                        } = db.parse_macro_expansion(call_id);
+                        let ExpandResult { value: (parse, map), err: err2 } =
+                            db.parse_macro_expansion(call_id);
 
-                        map.iter()
-                            .for_each(|(o, span)| expanded_map.push(o + offset, span));
+                        map.iter().for_each(|(o, span)| expanded_map.push(o + offset, span));
 
                         let syntax_node = parse.syntax_node();
                         ExpandResult {
             | MacroDefKind::BuiltInAttr(..)
             | MacroDefKind::BuiltInDerive(..)
             | MacroDefKind::ProcMacro(..) => {
-                let ExpandResult {
-                    value: (parse, tm),
-                    err,
-                } = lazy_expand(
+                let ExpandResult { value: (parse, tm), err } = lazy_expand(
                     db,
                     &def,
                     &call,
             None => offset += call.syntax().text_range().len(),
         }
     }
-
-    replacements
-        .into_iter()
-        .rev()
-        .for_each(|(old, new)| ted::replace(old.syntax(), new));
-    ExpandResult {
-        value: Some((original, offset)),
-        err: error,
-    }
+    replacements.into_iter().rev().for_each(|(old, new)| ted::replace(old.syntax(), new));
+    ExpandResult { value: Some((original, offset)), err: error }
 }