COMPARISON DIFF
============================================================

Original size: 10482 bytes
Chloro size:   10445 bytes
Rustfmt size:  10879 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //!
 //! See the full discussion : <https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Eager.20expansion.20of.20built-in.20macros>
+
 use base_db::Crate;
 use span::SyntaxContext;
 use syntax::{ted, AstPtr, Parse, SyntaxElement, SyntaxNode, TextSize, WalkEvent};
     MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind,
 };
 
-pub type EagerCallBackFn<'a> = &'a mut dyn FnMut(
-    InFile<(
-        syntax::AstPtr<ast::MacroCall>,
-        span::FileAstId<ast::MacroCall>,
-    )>,
+pub type EagerCallBackFn<'a> =
+    &'a mut dyn FnMut(
+    InFile<(syntax::AstPtr<ast::MacroCall>, span::FileAstId<ast::MacroCall>)>,
     MacroCallId,
 );
 
     let expand_to = ExpandTo::from_call_site(macro_call);
 
     // Note:
+
     // When `lazy_expand` is called, its *parent* file must already exist.
+
     // Here we store an eager macro id for the argument expanded subtree
+
     // for that purpose.
     let loc = MacroCallLoc {
         def,
         krate,
-        kind: MacroCallKind::FnLike {
-            ast_id,
-            expand_to: ExpandTo::Expr,
-            eager: None,
-        },
+        kind: MacroCallKind::FnLike { ast_id, expand_to: ExpandTo::Expr, eager: None },
         ctxt: call_site,
     };
     let arg_id = db.intern_macro_call(loc);
-    #[allow(deprecated)] // builtin eager macros are never derives
     let (_, _, span) = db.macro_arg(arg_id);
-    let ExpandResult {
-        value: (arg_exp, arg_exp_map),
-        err: parse_err,
-    } = db.parse_macro_expansion(arg_id);
+    let ExpandResult { value: (arg_exp, arg_exp_map), err: parse_err } = db.parse_macro_expansion(arg_id);
 
     let mut arg_map = ExpansionSpanMap::empty();
 
-    let ExpandResult {
-        value: expanded_eager_input,
-        err,
-    } = {
+    let ExpandResult { value: expanded_eager_input, err } = {
         eager_macro_recur(
             db,
             &arg_exp_map,
         ctxt: call_site,
     };
 
-    ExpandResult {
-        value: Some(db.intern_macro_call(loc)),
-        err,
-    }
+    ExpandResult { value: Some(db.intern_macro_call(loc)), err }
 }
 
 fn lazy_expand(
     eager_callback: EagerCallBackFn<'_>,
 ) -> ExpandResult<(InFile<Parse<SyntaxNode>>, Arc<ExpansionSpanMap>)> {
     let expand_to = ExpandTo::from_call_site(macro_call);
-    let id = def.make_call(
+    let id = def
+        .make_call(
         db,
         krate,
-        MacroCallKind::FnLike {
-            ast_id,
-            expand_to,
-            eager: None,
-        },
+        MacroCallKind::FnLike { ast_id, expand_to, eager: None },
         call_site,
     );
     eager_callback(ast_id.map(|ast_id| (AstPtr::new(macro_call), ast_id)), id);
 
-    db.parse_macro_expansion(id)
-        .map(|parse| (InFile::new(id.into(), parse.0), parse.1))
+    db.parse_macro_expansion(id).map(|parse| (InFile::new(id.into(), parse.0), parse.1))
 }
 
 fn eager_macro_recur(
                 match value {
                     Some(call_id) => {
                         eager_callback(
-                            curr.with_value(ast_id)
-                                .map(|ast_id| (AstPtr::new(&call), ast_id)),
+                            curr.with_value(ast_id).map(|ast_id| (AstPtr::new(&call), ast_id)),
                             call_id,
                         );
-                        let ExpandResult {
-                            value: (parse, map),
-                            err: err2,
-                        } = db.parse_macro_expansion(call_id);
+                        let ExpandResult { value: (parse, map), err: err2 } =
+                            db.parse_macro_expansion(call_id);
 
-                        map.iter()
-                            .for_each(|(o, span)| expanded_map.push(o + offset, span));
+                        map.iter().for_each(|(o, span)| expanded_map.push(o + offset, span));
 
                         let syntax_node = parse.syntax_node();
                         ExpandResult {
             | MacroDefKind::BuiltInAttr(..)
             | MacroDefKind::BuiltInDerive(..)
             | MacroDefKind::ProcMacro(..) => {
-                let ExpandResult {
-                    value: (parse, tm),
-                    err,
-                } = lazy_expand(
+                let ExpandResult { value: (parse, tm), err } = lazy_expand(
                     db,
                     &def,
                     &call,
         }
     }
 
-    replacements
-        .into_iter()
-        .rev()
-        .for_each(|(old, new)| ted::replace(old.syntax(), new));
+    replacements.into_iter().rev().for_each(|(old, new)| ted::replace(old.syntax(), new));
     ExpandResult {
         value: Some((original, offset)),
         err: error,