COMPARISON DIFF
============================================================

Original size: 33220 bytes
Chloro size:   33224 bytes
Rustfmt size:  33220 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Re-export diagnostics such that clients of `hir` don't have to depend on
 //! low-level crates.
 //!
 //! This probably isn't the best way to do this -- ideally, diagnostics should
 //! be expressed in terms of hir types themselves.
+
 use cfg::{CfgExpr, CfgOptions};
 use either::Either;
+pub use hir_def::VariantId;
 use hir_def::{
-    DefWithBodyId, GenericParamId, SyntheticSyntax,
     expr_store::{
-        ExprOrPatPtr, ExpressionStoreSourceMap, hir_assoc_type_binding_to_ast,
-        hir_generic_arg_to_ast, hir_segment_to_ast_segment,
+        hir_assoc_type_binding_to_ast, hir_generic_arg_to_ast, hir_segment_to_ast_segment,
+        ExprOrPatPtr, ExpressionStoreSourceMap,
     },
     hir::ExprOrPatId,
+    DefWithBodyId, GenericParamId, SyntheticSyntax,
 };
-use hir_expand::{HirFileId, InFile, mod_path::ModPath, name::Name};
+use hir_expand::{mod_path::ModPath, name::Name, HirFileId, InFile};
 use hir_ty::{
-    CastError, InferenceDiagnostic, InferenceTyDiagnosticSource, PathGenericsSource,
-    PathLoweringDiagnostic, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
     db::HirDatabase,
     diagnostics::{BodyValidationDiagnostic, UnsafetyReason},
+    CastError, InferenceDiagnostic, InferenceTyDiagnosticSource, PathGenericsSource,
+    PathLoweringDiagnostic, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
+};
+pub use hir_ty::{
+    diagnostics::{CaseType, IncorrectCase},
+    GenericArgsProhibitedReason, IncorrectGenericsLenKind,
 };
 use syntax::{
-    AstNode, AstPtr, SyntaxError, SyntaxNodePtr, TextRange,
     ast::{self, HasGenericArgs},
-    match_ast,
+    match_ast, AstNode, AstPtr, SyntaxError, SyntaxNodePtr, TextRange,
 };
 use triomphe::Arc;
 
 use crate::{AssocItem, Field, Function, GenericDef, Local, Trait, Type};
 
-pub use hir_def::VariantId;
-pub use hir_ty::{
-    GenericArgsProhibitedReason, IncorrectGenericsLenKind,
-    diagnostics::{CaseType, IncorrectCase},
-};
-
 macro_rules! diagnostics {
     ($AnyDiagnostic:ident <$db:lifetime> -> $($diag:ident $(<$lt:lifetime>)?,)*) => {
         #[derive(Debug)]
         )*
     };
 }
-// FIXME Accept something like the following in the macro call instead
-// diagnostics![
-// pub struct BreakOutsideOfLoop {
-//     pub expr: InFile<AstPtr<ast::Expr>>,
-//     pub is_break: bool,
-//     pub bad_value_break: bool,
-// }, ...
-// or more concisely
-// BreakOutsideOfLoop {
-//     expr: InFile<AstPtr<ast::Expr>>,
-//     is_break: bool,
-//     bad_value_break: bool,
-// }, ...
-// ]
 
+// FIXME Accept something like the following in the macro call instead
+
+// diagnostics![
+
+// pub struct BreakOutsideOfLoop {
+
+//     pub expr: InFile<AstPtr<ast::Expr>>,
+
+//     pub is_break: bool,
+
+//     pub bad_value_break: bool,
+
+// }, ...
+
+// or more concisely
+
+// BreakOutsideOfLoop {
+
+//     expr: InFile<AstPtr<ast::Expr>>,
+
+//     is_break: bool,
+
+//     bad_value_break: bool,
+
+// }, ...
+
+// ]
 diagnostics![AnyDiagnostic<'db> ->
     AwaitOutsideOfAsync,
     BreakOutsideOfLoop,
     pub path: ModPath,
     pub is_bang: bool,
 }
+
 #[derive(Debug, Clone, Eq, PartialEq)]
 pub struct UnreachableLabel {
     pub node: InFile<AstPtr<ast::Lifetime>>,
     pub impl_: AstPtr<ast::Impl>,
 }
 
-// FIXME: Split this off into the corresponding 4 rustc errors
 #[derive(Debug, PartialEq, Eq)]
 pub struct TraitImplIncorrectSafety {
     pub file_id: HirFileId,
                 };
                 let private = private.map(|id| Field { id, parent: variant.into() });
                 NoSuchField { field: expr_or_pat, private, variant }.into()
-            }
+            },
             &InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {
                 MismatchedArgCount { call_expr: expr_syntax(call_expr)?, expected, found }.into()
-            }
+            },
             &InferenceDiagnostic::PrivateField { expr, field } => {
                 let expr = expr_syntax(expr)?;
                 let field = field.into();
                 PrivateField { expr, field }.into()
-            }
+            },
             &InferenceDiagnostic::PrivateAssocItem { id, item } => {
                 let expr_or_pat = expr_or_pat_syntax(id)?;
                 let item = item.into();
                 PrivateAssocItem { expr_or_pat, item }.into()
-            }
+            },
             InferenceDiagnostic::ExpectedFunction { call_expr, found } => {
                 let call_expr = expr_syntax(*call_expr)?;
-                ExpectedFunction { call: call_expr, found: Type::new(db, def, *found) }.into()
-            }
+                ExpectedFunction {
+                    call: call_expr,
+                    found: Type::new(db, def, *found),
+                }.into(
+                )
+            },
             InferenceDiagnostic::UnresolvedField {
                 expr,
                 receiver,
                     method_with_same_name_exists: *method_with_same_name_exists,
                 }
                 .into()
-            }
+            },
             InferenceDiagnostic::UnresolvedMethodCall {
                 expr,
                 receiver,
                     assoc_func_with_same_name: assoc_func_with_same_name.map(Into::into),
                 }
                 .into()
-            }
+            },
             &InferenceDiagnostic::UnresolvedAssocItem { id } => {
                 let expr_or_pat = expr_or_pat_syntax(id)?;
                 UnresolvedAssocItem { expr_or_pat }.into()
-            }
+            },
             &InferenceDiagnostic::UnresolvedIdent { id } => {
                 let node = match id {
                     ExprOrPatId::ExprId(id) => match source_map.expr_syntax(id) {
                     ExprOrPatId::PatId(id) => pat_syntax(id)?.map(|it| (it, None)),
                 };
                 UnresolvedIdent { node }.into()
-            }
+            },
             &InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break, bad_value_break } => {
                 let expr = expr_syntax(expr)?;
                 BreakOutsideOfLoop { expr, is_break, bad_value_break }.into()
-            }
+            },
             InferenceDiagnostic::TypedHole { expr, expected } => {
                 let expr = expr_syntax(*expr)?;
                 TypedHole { expr, expected: Type::new(db, def, *expected) }.into()
-            }
+            },
             &InferenceDiagnostic::MismatchedTupleStructPatArgCount { pat, expected, found } => {
                 let expr_or_pat = match pat {
                     ExprOrPatId::ExprId(expr) => expr_syntax(expr)?,
                     }
                 };
                 MismatchedTupleStructPatArgCount { expr_or_pat, expected, found }.into()
-            }
+            },
             InferenceDiagnostic::CastToUnsized { expr, cast_ty } => {
                 let expr = expr_syntax(*expr)?;
                 CastToUnsized { expr, cast_ty: Type::new(db, def, *cast_ty) }.into()
-            }
+            },
             InferenceDiagnostic::InvalidCast { expr, error, expr_ty, cast_ty } => {
                 let expr = expr_syntax(*expr)?;
                 let expr_ty = Type::new(db, def, *expr_ty);
                 let cast_ty = Type::new(db, def, *cast_ty);
                 InvalidCast { expr, error: *error, expr_ty, cast_ty }.into()
-            }
+            },
             InferenceDiagnostic::TyDiagnostic { source, diag } => {
                 let source_map = match source {
                     InferenceTyDiagnosticSource::Body => source_map,
                     InferenceTyDiagnosticSource::Signature => sig_map,
                 };
                 Self::ty_diagnostic(diag, source_map, db)?
-            }
+            },
             InferenceDiagnostic::PathDiagnostic { node, diag } => {
                 let source = expr_or_pat_syntax(*node)?;
                 let syntax = source.value.to_node(&db.parse_or_expand(source.file_id));
                     }
                 };
                 Self::path_diagnostic(diag, source.with_value(path))?
-            }
+            },
             &InferenceDiagnostic::MethodCallIncorrectGenericsLen {
                 expr,
                 provided_count,
                     def: def.into(),
                 }
                 .into()
-            }
+            },
             &InferenceDiagnostic::MethodCallIncorrectGenericsOrder {
                 expr,
                 param_id,
                 let provided_arg = InFile::new(file_id, AstPtr::new(&provided_arg));
                 let expected_kind = GenericArgKind::from_id(param_id);
                 IncorrectGenericsOrder { provided_arg, expected_kind }.into()
-            }
+            },
         })
     }
 
         Some(match *diag {
             PathLoweringDiagnostic::GenericArgsProhibited { segment, reason } => {
                 let segment = hir_segment_to_ast_segment(&path.value, segment)?;
-
                 if let Some(rtn) = segment.return_type_syntax() {
                     // RTN errors are emitted as `GenericArgsProhibited` or `ParenthesizedGenericArgsWithoutFnTrait`.
                     return Some(BadRtn { rtn: path.with_value(AstPtr::new(&rtn)) }.into());
                 }
-
                 let args = if let Some(generics) = segment.generic_arg_list() {
                     AstPtr::new(&generics).wrap_left()
                 } else {
                 };
                 let args = path.with_value(args);
                 GenericArgsProhibited { args, reason }.into()
-            }
+            },
             PathLoweringDiagnostic::ParenthesizedGenericArgsWithoutFnTrait { segment } => {
                 let segment = hir_segment_to_ast_segment(&path.value, segment)?;
-
                 if let Some(rtn) = segment.return_type_syntax() {
                     // RTN errors are emitted as `GenericArgsProhibited` or `ParenthesizedGenericArgsWithoutFnTrait`.
                     return Some(BadRtn { rtn: path.with_value(AstPtr::new(&rtn)) }.into());
                 }
-
                 let args = AstPtr::new(&segment.parenthesized_arg_list()?);
                 let args = path.with_value(args);
                 ParenthesizedGenericArgsWithoutFnTrait { args }.into()
-            }
+            },
             PathLoweringDiagnostic::IncorrectGenericsLen {
                 generics_source,
                 provided_count,
                     def: def.into(),
                 }
                 .into()
-            }
+            },
             PathLoweringDiagnostic::IncorrectGenericsOrder {
                 generics_source,
                 param_id,
                 let provided_arg = path.with_value(AstPtr::new(&provided_arg));
                 let expected_kind = GenericArgKind::from_id(param_id);
                 IncorrectGenericsOrder { provided_arg, expected_kind }.into()
-            }
+            },
             PathLoweringDiagnostic::MissingLifetime { generics_source, expected_count, def }
             | PathLoweringDiagnostic::ElisionFailure { generics_source, expected_count, def } => {
                 let generics_or_segment =
                 let generics_or_segment = path.with_value(AstPtr::new(&generics_or_segment));
                 MissingLifetime { generics_or_segment, expected: expected_count, def: def.into() }
                     .into()
-            }
+            },
             PathLoweringDiagnostic::ElidedLifetimesInPath {
                 generics_source,
                 expected_count,
                     hard_error,
                 }
                 .into()
-            }
+            },
         })
     }
 
             TyLoweringDiagnosticKind::PathDiagnostic(diag) => {
                 let ast::Type::PathType(syntax) = syntax() else { return None };
                 Self::path_diagnostic(diag, source.with_value(syntax.path()?))?
-            }
+            },
         })
     }
 }
     Some(match generics_source {
         PathGenericsSource::Segment(segment) => {
             let segment = hir_segment_to_ast_segment(path, segment)?;
-            segment
-                .generic_arg_list()
-                .map(Either::Left)
-                .or_else(|| segment.name_ref().map(Either::Right))?
-        }
+            segment.generic_arg_list().map(Either::Left).or_else(
+                || segment.name_ref().map(Either::Right),
+            )?
+        },
         PathGenericsSource::AssocType { segment, assoc_type } => {
             let segment = hir_segment_to_ast_segment(path, segment)?;
             let segment_args = segment.generic_arg_list()?;
             let assoc = hir_assoc_type_binding_to_ast(&segment_args, assoc_type)?;
-            assoc
-                .generic_arg_list()
-                .map(Either::Left)
-                .or_else(|| assoc.name_ref().map(Either::Right))?
-        }
+            assoc.generic_arg_list().map(Either::Left).or_else(
+                || assoc.name_ref().map(Either::Right),
+            )?
+        },
     })
 }