COMPARISON DIFF
============================================================

Original size: 33220 bytes
Chloro size:   33225 bytes
Rustfmt size:  33220 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Re-export diagnostics such that clients of `hir` don't have to depend on
 //! low-level crates.
 //!
 //! This probably isn't the best way to do this -- ideally, diagnostics should
 //! be expressed in terms of hir types themselves.
+
 use cfg::{CfgExpr, CfgOptions};
 use either::Either;
 use hir_def::{
         )*
     };
 }
-// FIXME Accept something like the following in the macro call instead
-// diagnostics![
-// pub struct BreakOutsideOfLoop {
-//     pub expr: InFile<AstPtr<ast::Expr>>,
-//     pub is_break: bool,
-//     pub bad_value_break: bool,
-// }, ...
-// or more concisely
-// BreakOutsideOfLoop {
-//     expr: InFile<AstPtr<ast::Expr>>,
-//     is_break: bool,
-//     bad_value_break: bool,
-// }, ...
-// ]
 
+// FIXME Accept something like the following in the macro call instead
+
+// diagnostics![
+
+// pub struct BreakOutsideOfLoop {
+
+//     pub expr: InFile<AstPtr<ast::Expr>>,
+
+//     pub is_break: bool,
+
+//     pub bad_value_break: bool,
+
+// }, ...
+
+// or more concisely
+
+// BreakOutsideOfLoop {
+
+//     expr: InFile<AstPtr<ast::Expr>>,
+
+//     is_break: bool,
+
+//     bad_value_break: bool,
+
+// }, ...
+
+// ]
 diagnostics![AnyDiagnostic<'db> ->
     AwaitOutsideOfAsync,
     BreakOutsideOfLoop,
     pub path: ModPath,
     pub is_bang: bool,
 }
+
 #[derive(Debug, Clone, Eq, PartialEq)]
 pub struct UnreachableLabel {
     pub node: InFile<AstPtr<ast::Lifetime>>,
     pub impl_: AstPtr<ast::Impl>,
 }
 
-// FIXME: Split this off into the corresponding 4 rustc errors
 #[derive(Debug, PartialEq, Eq)]
 pub struct TraitImplIncorrectSafety {
     pub file_id: HirFileId,
             }
             InferenceDiagnostic::ExpectedFunction { call_expr, found } => {
                 let call_expr = expr_syntax(*call_expr)?;
-                ExpectedFunction { call: call_expr, found: Type::new(db, def, *found) }.into()
+                ExpectedFunction {
+                    call: call_expr,
+                    found: Type::new(db, def, *found),
+                }.into()
             }
             InferenceDiagnostic::UnresolvedField {
                 expr,
         Some(match *diag {
             PathLoweringDiagnostic::GenericArgsProhibited { segment, reason } => {
                 let segment = hir_segment_to_ast_segment(&path.value, segment)?;
-
                 if let Some(rtn) = segment.return_type_syntax() {
                     // RTN errors are emitted as `GenericArgsProhibited` or `ParenthesizedGenericArgsWithoutFnTrait`.
                     return Some(BadRtn { rtn: path.with_value(AstPtr::new(&rtn)) }.into());
                 }
-
                 let args = if let Some(generics) = segment.generic_arg_list() {
                     AstPtr::new(&generics).wrap_left()
                 } else {
             }
             PathLoweringDiagnostic::ParenthesizedGenericArgsWithoutFnTrait { segment } => {
                 let segment = hir_segment_to_ast_segment(&path.value, segment)?;
-
                 if let Some(rtn) = segment.return_type_syntax() {
                     // RTN errors are emitted as `GenericArgsProhibited` or `ParenthesizedGenericArgsWithoutFnTrait`.
                     return Some(BadRtn { rtn: path.with_value(AstPtr::new(&rtn)) }.into());
                 }
-
                 let args = AstPtr::new(&segment.parenthesized_arg_list()?);
                 let args = path.with_value(args);
                 ParenthesizedGenericArgsWithoutFnTrait { args }.into()