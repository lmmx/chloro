COMPARISON DIFF
============================================================

Original size: 33220 bytes
Chloro size:   33251 bytes
Rustfmt size:  33220 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Re-export diagnostics such that clients of `hir` don't have to depend on
 //! low-level crates.
 //!
 //! This probably isn't the best way to do this -- ideally, diagnostics should
 //! be expressed in terms of hir types themselves.
+
 use cfg::{CfgExpr, CfgOptions};
 use either::Either;
+pub use hir_def::VariantId;
 use hir_def::{
-    DefWithBodyId, GenericParamId, SyntheticSyntax,
     expr_store::{
-        ExprOrPatPtr, ExpressionStoreSourceMap, hir_assoc_type_binding_to_ast,
-        hir_generic_arg_to_ast, hir_segment_to_ast_segment,
+        hir_assoc_type_binding_to_ast, hir_generic_arg_to_ast, hir_segment_to_ast_segment,
+        ExprOrPatPtr, ExpressionStoreSourceMap,
     },
     hir::ExprOrPatId,
+    DefWithBodyId, GenericParamId, SyntheticSyntax,
 };
-use hir_expand::{HirFileId, InFile, mod_path::ModPath, name::Name};
+use hir_expand::{mod_path::ModPath, name::Name, HirFileId, InFile};
 use hir_ty::{
-    CastError, InferenceDiagnostic, InferenceTyDiagnosticSource, PathGenericsSource,
-    PathLoweringDiagnostic, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
     db::HirDatabase,
     diagnostics::{BodyValidationDiagnostic, UnsafetyReason},
+    CastError, InferenceDiagnostic, InferenceTyDiagnosticSource, PathGenericsSource,
+    PathLoweringDiagnostic, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
+};
+pub use hir_ty::{
+    diagnostics::{CaseType, IncorrectCase},
+    GenericArgsProhibitedReason, IncorrectGenericsLenKind,
 };
 use syntax::{
-    AstNode, AstPtr, SyntaxError, SyntaxNodePtr, TextRange,
     ast::{self, HasGenericArgs},
-    match_ast,
+    match_ast, AstNode, AstPtr, SyntaxError, SyntaxNodePtr, TextRange,
 };
 use triomphe::Arc;
 
 use crate::{AssocItem, Field, Function, GenericDef, Local, Trait, Type};
 
-pub use hir_def::VariantId;
-pub use hir_ty::{
-    GenericArgsProhibitedReason, IncorrectGenericsLenKind,
-    diagnostics::{CaseType, IncorrectCase},
-};
-
 macro_rules! diagnostics {
     ($AnyDiagnostic:ident <$db:lifetime> -> $($diag:ident $(<$lt:lifetime>)?,)*) => {
         #[derive(Debug)]
         )*
     };
 }
-// FIXME Accept something like the following in the macro call instead
-// diagnostics![
-// pub struct BreakOutsideOfLoop {
-//     pub expr: InFile<AstPtr<ast::Expr>>,
-//     pub is_break: bool,
-//     pub bad_value_break: bool,
-// }, ...
-// or more concisely
-// BreakOutsideOfLoop {
-//     expr: InFile<AstPtr<ast::Expr>>,
-//     is_break: bool,
-//     bad_value_break: bool,
-// }, ...
-// ]
 
+// FIXME Accept something like the following in the macro call instead
+
+// diagnostics![
+
+// pub struct BreakOutsideOfLoop {
+
+//     pub expr: InFile<AstPtr<ast::Expr>>,
+
+//     pub is_break: bool,
+
+//     pub bad_value_break: bool,
+
+// }, ...
+
+// or more concisely
+
+// BreakOutsideOfLoop {
+
+//     expr: InFile<AstPtr<ast::Expr>>,
+
+//     is_break: bool,
+
+//     bad_value_break: bool,
+
+// }, ...
+
+// ]
 diagnostics![AnyDiagnostic<'db> ->
     AwaitOutsideOfAsync,
     BreakOutsideOfLoop,
     pub path: ModPath,
     pub is_bang: bool,
 }
+
 #[derive(Debug, Clone, Eq, PartialEq)]
 pub struct UnreachableLabel {
     pub node: InFile<AstPtr<ast::Lifetime>>,
     pub impl_: AstPtr<ast::Impl>,
 }
 
-// FIXME: Split this off into the corresponding 4 rustc errors
 #[derive(Debug, PartialEq, Eq)]
 pub struct TraitImplIncorrectSafety {
     pub file_id: HirFileId,
             ExprOrPatId::ExprId(expr) => expr_syntax(expr),
             ExprOrPatId::PatId(pat) => pat_syntax(pat),
         };
-        Some(match d {
+        Some(
+            match d {
             &InferenceDiagnostic::NoSuchField { field: expr, private, variant } => {
                 let expr_or_pat = match expr {
                     ExprOrPatId::ExprId(expr) => {
                 let expected_kind = GenericArgKind::from_id(param_id);
                 IncorrectGenericsOrder { provided_arg, expected_kind }.into()
             }
-        })
+        },
+        )
     }
 
     fn path_diagnostic(
         diag: &PathLoweringDiagnostic,
         path: InFile<ast::Path>,
     ) -> Option<AnyDiagnostic<'db>> {
-        Some(match *diag {
+        Some(
+            match *diag {
             PathLoweringDiagnostic::GenericArgsProhibited { segment, reason } => {
                 let segment = hir_segment_to_ast_segment(&path.value, segment)?;
 
                 }
                 .into()
             }
-        })
+        },
+        )
     }
 
     pub(crate) fn ty_diagnostic(
             return None;
         };
         let syntax = || source.value.to_node(&db.parse_or_expand(source.file_id));
-        Some(match &diag.kind {
+        Some(
+            match &diag.kind {
             TyLoweringDiagnosticKind::PathDiagnostic(diag) => {
                 let ast::Type::PathType(syntax) = syntax() else { return None };
                 Self::path_diagnostic(diag, source.with_value(syntax.path()?))?
             }
-        })
+        },
+        )
     }
 }
 
     path: &ast::Path,
     generics_source: PathGenericsSource,
 ) -> Option<Either<ast::GenericArgList, ast::NameRef>> {
-    Some(match generics_source {
+    Some(
+        match generics_source {
         PathGenericsSource::Segment(segment) => {
             let segment = hir_segment_to_ast_segment(path, segment)?;
             segment
                 .map(Either::Left)
                 .or_else(|| assoc.name_ref().map(Either::Right))?
         }
-    })
+    },
+    )
 }