COMPARISON DIFF
============================================================

Original size: 33220 bytes
Chloro size:   33197 bytes
Rustfmt size:  33220 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Re-export diagnostics such that clients of `hir` don't have to depend on
 //! low-level crates.
 //!
 //! This probably isn't the best way to do this -- ideally, diagnostics should
 //! be expressed in terms of hir types themselves.
+
 use cfg::{CfgExpr, CfgOptions};
 use either::Either;
+pub use hir_def::VariantId;
 use hir_def::{
-    DefWithBodyId, GenericParamId, SyntheticSyntax,
     expr_store::{
-        ExprOrPatPtr, ExpressionStoreSourceMap, hir_assoc_type_binding_to_ast,
-        hir_generic_arg_to_ast, hir_segment_to_ast_segment,
+        hir_assoc_type_binding_to_ast, hir_generic_arg_to_ast, hir_segment_to_ast_segment,
+        ExprOrPatPtr, ExpressionStoreSourceMap,
     },
     hir::ExprOrPatId,
+    DefWithBodyId, GenericParamId, SyntheticSyntax,
 };
-use hir_expand::{HirFileId, InFile, mod_path::ModPath, name::Name};
+use hir_expand::{mod_path::ModPath, name::Name, HirFileId, InFile};
 use hir_ty::{
-    CastError, InferenceDiagnostic, InferenceTyDiagnosticSource, PathGenericsSource,
-    PathLoweringDiagnostic, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
     db::HirDatabase,
     diagnostics::{BodyValidationDiagnostic, UnsafetyReason},
+    CastError, InferenceDiagnostic, InferenceTyDiagnosticSource, PathGenericsSource,
+    PathLoweringDiagnostic, TyLoweringDiagnostic, TyLoweringDiagnosticKind,
+};
+pub use hir_ty::{
+    diagnostics::{CaseType, IncorrectCase},
+    GenericArgsProhibitedReason, IncorrectGenericsLenKind,
 };
 use syntax::{
-    AstNode, AstPtr, SyntaxError, SyntaxNodePtr, TextRange,
     ast::{self, HasGenericArgs},
-    match_ast,
+    match_ast, AstNode, AstPtr, SyntaxError, SyntaxNodePtr, TextRange,
 };
 use triomphe::Arc;
 
 use crate::{AssocItem, Field, Function, GenericDef, Local, Trait, Type};
 
-pub use hir_def::VariantId;
-pub use hir_ty::{
-    GenericArgsProhibitedReason, IncorrectGenericsLenKind,
-    diagnostics::{CaseType, IncorrectCase},
-};
-
 macro_rules! diagnostics {
     ($AnyDiagnostic:ident <$db:lifetime> -> $($diag:ident $(<$lt:lifetime>)?,)*) => {
         #[derive(Debug)]
         )*
     };
 }
-// FIXME Accept something like the following in the macro call instead
-// diagnostics![
-// pub struct BreakOutsideOfLoop {
-//     pub expr: InFile<AstPtr<ast::Expr>>,
-//     pub is_break: bool,
-//     pub bad_value_break: bool,
-// }, ...
-// or more concisely
-// BreakOutsideOfLoop {
-//     expr: InFile<AstPtr<ast::Expr>>,
-//     is_break: bool,
-//     bad_value_break: bool,
-// }, ...
-// ]
 
+// FIXME Accept something like the following in the macro call instead
+
+// diagnostics![
+
+// pub struct BreakOutsideOfLoop {
+
+//     pub expr: InFile<AstPtr<ast::Expr>>,
+
+//     pub is_break: bool,
+
+//     pub bad_value_break: bool,
+
+// }, ...
+
+// or more concisely
+
+// BreakOutsideOfLoop {
+
+//     expr: InFile<AstPtr<ast::Expr>>,
+
+//     is_break: bool,
+
+//     bad_value_break: bool,
+
+// }, ...
+
+// ]
 diagnostics![AnyDiagnostic<'db> ->
     AwaitOutsideOfAsync,
     BreakOutsideOfLoop,
     pub path: ModPath,
     pub is_bang: bool,
 }
+
 #[derive(Debug, Clone, Eq, PartialEq)]
 pub struct UnreachableLabel {
     pub node: InFile<AstPtr<ast::Lifetime>>,
     pub impl_: AstPtr<ast::Impl>,
 }
 
-// FIXME: Split this off into the corresponding 4 rustc errors
 #[derive(Debug, PartialEq, Eq)]
 pub struct TraitImplIncorrectSafety {
     pub file_id: HirFileId,
             }
             InferenceDiagnostic::ExpectedFunction { call_expr, found } => {
                 let call_expr = expr_syntax(*call_expr)?;
-                ExpectedFunction { call: call_expr, found: Type::new(db, def, *found) }.into()
+                ExpectedFunction {
+                    call: call_expr,
+                    found: Type::new(db, def, *found),
+                }.into(
+                )
             }
             InferenceDiagnostic::UnresolvedField {
                 expr,
         Some(match *diag {
             PathLoweringDiagnostic::GenericArgsProhibited { segment, reason } => {
                 let segment = hir_segment_to_ast_segment(&path.value, segment)?;
-
                 if let Some(rtn) = segment.return_type_syntax() {
                     // RTN errors are emitted as `GenericArgsProhibited` or `ParenthesizedGenericArgsWithoutFnTrait`.
                     return Some(BadRtn { rtn: path.with_value(AstPtr::new(&rtn)) }.into());
                 }
-
                 let args = if let Some(generics) = segment.generic_arg_list() {
                     AstPtr::new(&generics).wrap_left()
                 } else {
             }
             PathLoweringDiagnostic::ParenthesizedGenericArgsWithoutFnTrait { segment } => {
                 let segment = hir_segment_to_ast_segment(&path.value, segment)?;
-
                 if let Some(rtn) = segment.return_type_syntax() {
                     // RTN errors are emitted as `GenericArgsProhibited` or `ParenthesizedGenericArgsWithoutFnTrait`.
                     return Some(BadRtn { rtn: path.with_value(AstPtr::new(&rtn)) }.into());
                 }
-
                 let args = AstPtr::new(&segment.parenthesized_arg_list()?);
                 let args = path.with_value(args);
                 ParenthesizedGenericArgsWithoutFnTrait { args }.into()
     Some(match generics_source {
         PathGenericsSource::Segment(segment) => {
             let segment = hir_segment_to_ast_segment(path, segment)?;
-            segment
-                .generic_arg_list()
-                .map(Either::Left)
-                .or_else(|| segment.name_ref().map(Either::Right))?
+            segment.generic_arg_list().map(Either::Left).or_else(
+                || segment.name_ref().map(Either::Right),
+            )?
         }
         PathGenericsSource::AssocType { segment, assoc_type } => {
             let segment = hir_segment_to_ast_segment(path, segment)?;
             let segment_args = segment.generic_arg_list()?;
             let assoc = hir_assoc_type_binding_to_ast(&segment_args, assoc_type)?;
-            assoc
-                .generic_arg_list()
-                .map(Either::Left)
-                .or_else(|| assoc.name_ref().map(Either::Right))?
+            assoc.generic_arg_list().map(Either::Left).or_else(
+                || assoc.name_ref().map(Either::Right),
+            )?
         }
     })
 }