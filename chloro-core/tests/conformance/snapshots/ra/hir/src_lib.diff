COMPARISON DIFF
============================================================

Original size: 227843 bytes
Chloro size:   234232 bytes
Rustfmt size:  227843 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 #![recursion_limit = "512"]
 
-extern crate ra_ap_rustc_type_ir as rustc_type_ir;
 
 mod attrs;
 mod from_id;
 mod has_source;
 mod semantics;
 mod source_analyzer;
-
 pub mod db;
 pub mod diagnostics;
 pub mod symbols;
 pub mod term_search;
-
 mod display;
 
-#[doc(hidden)]
-pub use hir_def::ModuleId;
-
 use std::{
     fmt,
     mem::discriminant,
 use arrayvec::ArrayVec;
 use base_db::{CrateDisplayName, CrateOrigin, LangCrateOrigin};
 use either::Either;
+pub use hir_def::ModuleId;
 use hir_def::{
     AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
     CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
     AstId, MacroCallKind, RenderedExpandError, ValueResult, attrs::collect_attrs,
     proc_macro::ProcMacroKind,
 };
+pub use hir_ty::next_solver;
+pub use hir_ty::setup_tracing;
 use hir_ty::{
     TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId, all_super_traits, autoderef,
     check_orphan_rules,
     format_smolstr,
 };
 use triomphe::{Arc, ThinArc};
-
-use crate::db::{DefDatabase, HirDatabase};
-
-pub use crate::{
-    attrs::{HasAttrs, resolve_doc_path_on},
-    diagnostics::*,
-    has_source::HasSource,
-    semantics::{
-        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
-        VisibleTraits,
-    },
-};
-
-// Be careful with these re-exports.
-//
-// `hir` is the boundary between the compiler and the IDE. It should try hard to
-// isolate the compiler from the ide, to allow the two to be refactored
-// independently. Re-exporting something from the compiler is the sure way to
-// breach the boundary.
-//
-// Generally, a refactoring which *removes* a name from this list is a good
-// idea!
 pub use {
     cfg::{CfgAtom, CfgExpr, CfgOptions},
     hir_def::{
     },
     intern::{Symbol, sym},
 };
-
-// These are negative re-exports: pub using these names is forbidden, they
-// should remain private to hir internals.
-#[allow(unused)]
 use {
     hir_def::expr_store::path::Path,
     hir_expand::{
     },
 };
 
+use crate::db::{DefDatabase, HirDatabase};
+pub use crate::{
+    attrs::{HasAttrs, resolve_doc_path_on},
+    diagnostics::*,
+    has_source::HasSource,
+    semantics::{
+        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
+        VisibleTraits,
+    },
+};
+
 /// hir::Crate describes a single crate. It's the main interface with which
 /// a crate's dependencies interact. Mostly, it should be just a proxy for the
 /// root module.
         self.id
     }
 
-    pub fn origin(self, db: &dyn HirDatabase) -> CrateOrigin {
+    pub fn origin(
+        self,
+        db: &dyn HirDatabase,
+    ) -> CrateOrigin {
         self.id.data(db).origin.clone()
     }
 
-    pub fn is_builtin(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_builtin(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         matches!(self.origin(db), CrateOrigin::Lang(_))
     }
 
-    pub fn dependencies(self, db: &dyn HirDatabase) -> Vec<CrateDependency> {
+    pub fn dependencies(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<CrateDependency> {
         self.id
             .data(db)
             .dependencies
             .collect()
     }
 
-    pub fn reverse_dependencies(self, db: &dyn HirDatabase) -> Vec<Crate> {
+    pub fn reverse_dependencies(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Crate> {
         let all_crates = db.all_crates();
         all_crates
             .iter()
         Module { id: CrateRootModuleId::from(self.id).into() }
     }
 
-    pub fn modules(self, db: &dyn HirDatabase) -> Vec<Module> {
+    pub fn modules(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Module> {
         let def_map = crate_def_map(db, self.id);
         def_map.modules().map(|(id, _)| def_map.module_id(id).into()).collect()
     }
 
-    pub fn root_file(self, db: &dyn HirDatabase) -> FileId {
+    pub fn root_file(
+        self,
+        db: &dyn HirDatabase,
+    ) -> FileId {
         self.id.data(db).root_file_id
     }
 
-    pub fn edition(self, db: &dyn HirDatabase) -> Edition {
+    pub fn edition(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Edition {
         self.id.data(db).edition
     }
 
-    pub fn version(self, db: &dyn HirDatabase) -> Option<String> {
+    pub fn version(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<String> {
         self.id.extra_data(db).version.clone()
     }
 
-    pub fn display_name(self, db: &dyn HirDatabase) -> Option<CrateDisplayName> {
+    pub fn display_name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<CrateDisplayName> {
         self.id.extra_data(db).display_name.clone()
     }
 
     }
 
     /// Try to get the root URL of the documentation of a crate.
-    pub fn get_html_root_url(self: &Crate, db: &dyn HirDatabase) -> Option<String> {
+    pub fn get_html_root_url(
+        self: &Crate,
+        db: &dyn HirDatabase,
+    ) -> Option<String> {
         // Look for #![doc(html_root_url = "...")]
         let attrs = db.attrs(AttrDefId::ModuleId(self.root_module().into()));
         let doc_url = attrs.by_key(sym::doc).find_string_value_in_tt(sym::html_root_url);
         doc_url.map(|s| s.trim_matches('"').trim_end_matches('/').to_owned() + "/")
     }
 
-    pub fn cfg<'db>(&self, db: &'db dyn HirDatabase) -> &'db CfgOptions {
+    pub fn cfg<'db>(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> &'db CfgOptions {
         self.id.cfg_options(db)
     }
 
-    pub fn potential_cfg<'db>(&self, db: &'db dyn HirDatabase) -> &'db CfgOptions {
+    pub fn potential_cfg<'db>(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> &'db CfgOptions {
         let data = self.id.extra_data(db);
         data.potential_cfg_options.as_ref().unwrap_or_else(|| self.id.cfg_options(db))
     }
 
-    pub fn to_display_target(self, db: &dyn HirDatabase) -> DisplayTarget {
+    pub fn to_display_target(
+        self,
+        db: &dyn HirDatabase,
+    ) -> DisplayTarget {
         DisplayTarget::from_crate(db, self.id)
     }
 
     Module(Module),
     Function(Function),
     Adt(Adt),
-    // Can't be directly declared, but can be imported.
-    // FIXME: Rename to `EnumVariant`
     Variant(Variant),
     Const(Const),
     Static(Static),
     BuiltinType(BuiltinType),
     Macro(Macro),
 }
-impl_from!(
-    Module,
-    Function,
-    Adt(Struct, Enum, Union),
-    Variant,
-    Const,
-    Static,
-    Trait,
-    TypeAlias,
-    BuiltinType,
-    Macro
-    for ModuleDef
-);
-
 impl From<VariantDef> for ModuleDef {
     fn from(var: VariantDef) -> Self {
         match var {
 }
 
 impl ModuleDef {
-    pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Module> {
         match self {
             ModuleDef::Module(it) => it.parent(db),
             ModuleDef::Function(it) => Some(it.module(db)),
         }
     }
 
-    pub fn canonical_path(&self, db: &dyn HirDatabase, edition: Edition) -> Option<String> {
+    pub fn canonical_path(
+        &self,
+        db: &dyn HirDatabase,
+        edition: Edition,
+    ) -> Option<String> {
         let mut segments = vec![self.name(db)?];
         for m in self.module(db)?.path_to_root(db) {
             segments.extend(m.name(db))
         self.module(db).map(|it| it.path_to_root(db).into_iter().rev())
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Name> {
         let name = match self {
             ModuleDef::Module(it) => it.name(db)?,
             ModuleDef::Const(it) => it.name(db)?,
             ModuleDef::Variant(it) => it.id.into(),
             ModuleDef::BuiltinType(_) | ModuleDef::Macro(_) => return Vec::new(),
         };
-
         let mut acc = Vec::new();
-
         match self.as_def_with_body() {
             Some(def) => {
                 def.diagnostics(db, &mut acc, style_lints);
                 }
             }
         }
-
         if let Some(def) = self.as_self_generic_def() {
             def.diagnostics(db, &mut acc);
         }
-
         acc
     }
 
         }
     }
 
-    pub fn attrs(&self, db: &dyn HirDatabase) -> Option<AttrsWithOwner> {
+    pub fn attrs(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<AttrsWithOwner> {
         Some(match self {
             ModuleDef::Module(it) => it.attrs(db),
             ModuleDef::Function(it) => it.attrs(db),
 }
 
 impl HasCrate for ModuleDef {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         match self.module(db) {
             Some(module) => module.krate(),
             None => Crate::core(db).unwrap_or_else(|| db.all_crates()[0].into()),
 }
 
 impl HasVisibility for ModuleDef {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         match *self {
             ModuleDef::Module(it) => it.visibility(db),
             ModuleDef::Function(it) => it.visibility(db),
 
 impl Module {
     /// Name of this module.
-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Name> {
         self.id.name(db)
     }
 
     /// Topmost parent of this module. Every module has a `crate_root`, but some
     /// might be missing `krate`. This can happen if a module's file is not included
     /// in the module tree of any target in `Cargo.toml`.
-    pub fn crate_root(self, db: &dyn HirDatabase) -> Module {
+    pub fn crate_root(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         let def_map = crate_def_map(db, self.id.krate());
         Module { id: def_map.crate_root().into() }
     }
     }
 
     /// Iterates over all child modules.
-    pub fn children(self, db: &dyn HirDatabase) -> impl Iterator<Item = Module> {
+    pub fn children(
+        self,
+        db: &dyn HirDatabase,
+    ) -> impl Iterator<Item = Module> {
         let def_map = self.id.def_map(db);
         let children = def_map[self.id.local_id]
             .children
     }
 
     /// Finds a parent module.
-    pub fn parent(self, db: &dyn HirDatabase) -> Option<Module> {
+    pub fn parent(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Module> {
         let def_map = self.id.def_map(db);
         let parent_id = def_map.containing_module(self.id.local_id)?;
         Some(Module { id: parent_id })
     }
 
     /// Finds nearest non-block ancestor `Module` (`self` included).
-    pub fn nearest_non_block_module(self, db: &dyn HirDatabase) -> Module {
+    pub fn nearest_non_block_module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         let mut id = self.id;
         while id.is_block_module() {
             id = id.containing_module(db).expect("block without parent module");
         Module { id }
     }
 
-    pub fn path_to_root(self, db: &dyn HirDatabase) -> Vec<Module> {
+    pub fn path_to_root(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Module> {
         let mut res = vec![self];
         let mut curr = self;
         while let Some(next) = curr.parent(db) {
             }
             emit_def_diagnostic(db, acc, diag, edition);
         }
-
         if !self.id.is_block_module() {
             // These are reported by the body of block modules
             let scope = &def_map[self.id.local_id].scope;
             scope.all_macro_calls().for_each(|it| macro_call_diagnostics(db, it, acc));
         }
-
         for def in self.declarations(db) {
             match def {
                 ModuleDef::Module(m) => {
             }
         }
         self.legacy_macros(db).into_iter().for_each(|m| emit_macro_def_diagnostics(db, acc, m));
-
         let inherent_impls = db.inherent_impls_in_crate(self.id.krate());
-
         let interner = DbInterner::new_with(db, Some(self.id.krate()), self.id.containing_block());
         let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
-
         let mut impl_assoc_items_scratch = vec![];
         for impl_def in self.impl_defs(db) {
             GenericDef::Impl(impl_def).diagnostics(db, acc);
         }
     }
 
-    pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {
+    pub fn declarations(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<ModuleDef> {
         let def_map = self.id.def_map(db);
         let scope = &def_map[self.id.local_id].scope;
         scope
             .collect()
     }
 
-    pub fn legacy_macros(self, db: &dyn HirDatabase) -> Vec<Macro> {
+    pub fn legacy_macros(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Macro> {
         let def_map = self.id.def_map(db);
         let scope = &def_map[self.id.local_id].scope;
         scope.legacy_macros().flat_map(|(_, it)| it).map(|&it| it.into()).collect()
     }
 
-    pub fn impl_defs(self, db: &dyn HirDatabase) -> Vec<Impl> {
+    pub fn impl_defs(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Impl> {
         let def_map = self.id.def_map(db);
         def_map[self.id.local_id].scope.impls().map(Impl::from).collect()
     }
         };
         acc.push(MacroError { node, precise_location, message, error, kind }.into());
     }
-
     if !parse_errors.is_empty() {
         let loc = db.lookup_intern_macro_call(macro_call_id);
         let (node, precise_location) = precise_macro_call_location(&loc.kind, db);
 }
 
 impl HasVisibility for Module {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         let def_map = self.id.def_map(db);
         let module_data = &def_map[self.id.local_id];
         module_data.visibility
 
 impl<'db> InstantiatedField<'db> {
     /// Returns the type as in the signature of the struct.
-    pub fn ty(&self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
+    pub fn ty(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let var_id = self.inner.parent.into();
         let field = db.field_types(var_id)[self.inner.id];
         let ty = field.instantiate(interner, self.args);
         Name::new_tuple_field(self.index as usize)
     }
 
-    pub fn ty<'db>(&self, db: &'db dyn HirDatabase) -> Type<'db> {
+    pub fn ty<'db>(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Type<'db> {
         let interner = DbInterner::new_with(db, None, None);
         let ty = db
             .infer(self.owner)
 impl AstNode for FieldSource {
     fn can_cast(kind: syntax::SyntaxKind) -> bool
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         ast::RecordField::can_cast(kind) || ast::TupleField::can_cast(kind)
     }
 
     fn cast(syntax: SyntaxNode) -> Option<Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         if ast::RecordField::can_cast(syntax.kind()) {
             <ast::RecordField as AstNode>::cast(syntax).map(FieldSource::Named)
         } else if ast::TupleField::can_cast(syntax.kind()) {
 }
 
 impl Field {
-    pub fn name(&self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         VariantId::from(self.parent).fields(db).fields()[self.id].name.clone()
     }
 
 
     /// Returns the type as in the signature of the struct. Only use this in the
     /// context of the field definition.
-    pub fn ty<'db>(&self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
+    pub fn ty<'db>(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> TypeNs<'db> {
         let var_id = self.parent.into();
         let ty = db.field_types(var_id)[self.id].skip_binder();
         TypeNs::new(db, var_id, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
         Type::new(db, var_id, ty)
     }
 
-    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {
+    pub fn layout(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Result<Layout, LayoutError> {
         db.layout_of_ty(
             self.ty(db).ty,
             db.trait_environment(match hir_def::VariantId::from(self.parent) {
         .map(|layout| Layout(layout, db.target_data_layout(self.krate(db).into()).unwrap()))
     }
 
-    pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {
+    pub fn parent_def(
+        &self,
+        _db: &dyn HirDatabase,
+    ) -> VariantDef {
         self.parent
     }
 }
 
 impl HasVisibility for Field {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         let variant_data = VariantId::from(self.parent).fields(db);
         let visibility = &variant_data.fields()[self.id].visibility;
         let parent_id: hir_def::VariantId = self.parent.into();
 }
 
 impl Struct {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.lookup(db).container }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         db.struct_signature(self.id).name.clone()
     }
 
-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
+    pub fn fields(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Field> {
         self.id
             .fields(db)
             .fields()
             .collect()
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_def(db, self.id)
     }
 
-    pub fn ty_params(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_def_params(db, self.id)
     }
 
-    pub fn constructor_ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn constructor_ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_value_def(db, self.id)
     }
 
-    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprOptions> {
+    pub fn repr(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ReprOptions> {
         db.struct_signature(self.id).repr
     }
 
-    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {
+    pub fn kind(
+        self,
+        db: &dyn HirDatabase,
+    ) -> StructKind {
         match self.variant_fields(db).shape {
             hir_def::item_tree::FieldsShape::Record => StructKind::Record,
             hir_def::item_tree::FieldsShape::Tuple => StructKind::Tuple,
         }
     }
 
-    fn variant_fields(self, db: &dyn HirDatabase) -> &VariantFields {
+    fn variant_fields(
+        self,
+        db: &dyn HirDatabase,
+    ) -> &VariantFields {
         self.id.fields(db)
     }
 
-    pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_unstable(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
 
-    pub fn instantiate_infer<'db>(self, infer_ctxt: &InferCtxt<'db>) -> InstantiatedStruct<'db> {
+    pub fn instantiate_infer<'db>(
+        self,
+        infer_ctxt: &InferCtxt<'db>,
+    ) -> InstantiatedStruct<'db> {
         let args = infer_ctxt.fresh_args_for_item(self.id.into());
         InstantiatedStruct { inner: self, args }
     }
 }
 
 impl HasVisibility for Struct {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         let loc = self.id.lookup(db);
         let source = loc.source(db);
         visibility_from_ast(db, self.id, source.map(|src| src.visibility()))
 }
 
 impl<'db> InstantiatedStruct<'db> {
-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<InstantiatedField<'db>> {
+    pub fn fields(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<InstantiatedField<'db>> {
         self.inner
             .id
             .fields(db)
             .collect()
     }
 
-    pub fn ty(self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
+    pub fn ty(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let ty = db.ty(self.inner.id.into());
         TypeNs::new(db, self.inner.id, ty.instantiate(interner, self.args))
     }
 }
 
 impl Union {
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         db.union_signature(self.id).name.clone()
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.lookup(db).container }
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_def(db, self.id)
     }
 
-    pub fn ty_params(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_def_params(db, self.id)
     }
 
-    pub fn constructor_ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn constructor_ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_value_def(db, self.id)
     }
 
-    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {
+    pub fn kind(
+        self,
+        db: &dyn HirDatabase,
+    ) -> StructKind {
         match self.id.fields(db).shape {
             hir_def::item_tree::FieldsShape::Record => StructKind::Record,
             hir_def::item_tree::FieldsShape::Tuple => StructKind::Tuple,
         }
     }
 
-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
+    pub fn fields(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Field> {
         self.id
             .fields(db)
             .fields()
             .map(|(id, _)| Field { parent: self.into(), id })
             .collect()
     }
-    pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
+
+    pub fn is_unstable(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
 }
 
 impl HasVisibility for Union {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         let loc = self.id.lookup(db);
         let source = loc.source(db);
         visibility_from_ast(db, self.id, source.map(|src| src.visibility()))
 }
 
 impl Enum {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.lookup(db).container }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         db.enum_signature(self.id).name.clone()
     }
 
-    pub fn variants(self, db: &dyn HirDatabase) -> Vec<Variant> {
+    pub fn variants(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Variant> {
         self.id.enum_variants(db).variants.iter().map(|&(id, _, _)| Variant { id }).collect()
     }
 
-    pub fn num_variants(self, db: &dyn HirDatabase) -> usize {
+    pub fn num_variants(
+        self,
+        db: &dyn HirDatabase,
+    ) -> usize {
         self.id.enum_variants(db).variants.len()
     }
 
-    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprOptions> {
+    pub fn repr(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ReprOptions> {
         db.enum_signature(self.id).repr
     }
 
-    pub fn ty<'db>(self, db: &'db dyn HirDatabase) -> Type<'db> {
+    pub fn ty<'db>(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Type<'db> {
         Type::from_def(db, self.id)
     }
 
-    pub fn ty_params<'db>(self, db: &'db dyn HirDatabase) -> Type<'db> {
+    pub fn ty_params<'db>(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Type<'db> {
         Type::from_def_params(db, self.id)
     }
 
     /// The type of the enum variant bodies.
-    pub fn variant_body_ty<'db>(self, db: &'db dyn HirDatabase) -> Type<'db> {
+    pub fn variant_body_ty<'db>(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Type<'db> {
         let interner = DbInterner::new_with(db, None, None);
         Type::new_for_crate(
             self.id.lookup(db).container.krate(),
     }
 
     /// Returns true if at least one variant of this enum is a non-unit variant.
-    pub fn is_data_carrying(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_data_carrying(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         self.variants(db).iter().any(|v| !matches!(v.kind(db), StructKind::Unit))
     }
 
-    pub fn layout(self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {
+    pub fn layout(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Result<Layout, LayoutError> {
         Adt::from(self).layout(db)
     }
 
-    pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_unstable(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
 }
 
 impl HasVisibility for Enum {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         let loc = self.id.lookup(db);
         let source = loc.source(db);
         visibility_from_ast(db, self.id, source.map(|src| src.visibility()))
 }
 
 impl<'db> InstantiatedEnum<'db> {
-    pub fn ty(self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
+    pub fn ty(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let ty = db.ty(self.inner.id.into());
         TypeNs::new(db, self.inner.id, ty.instantiate(interner, self.args))
     }
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Variant {
     pub(crate) id: EnumVariantId,
 }
 
 impl Variant {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.module(db) }
     }
 
-    pub fn parent_enum(self, db: &dyn HirDatabase) -> Enum {
+    pub fn parent_enum(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Enum {
         self.id.lookup(db).parent.into()
     }
 
-    pub fn constructor_ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn constructor_ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_value_def(db, self.id)
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         let lookup = self.id.lookup(db);
         let enum_ = lookup.parent;
         enum_.enum_variants(db).variants[lookup.index as usize].1.clone()
     }
 
-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
+    pub fn fields(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Field> {
         self.id
             .fields(db)
             .fields()
             .collect()
     }
 
-    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {
+    pub fn kind(
+        self,
+        db: &dyn HirDatabase,
+    ) -> StructKind {
         match self.id.fields(db).shape {
             hir_def::item_tree::FieldsShape::Record => StructKind::Record,
             hir_def::item_tree::FieldsShape::Tuple => StructKind::Tuple,
         }
     }
 
-    pub fn value(self, db: &dyn HirDatabase) -> Option<ast::Expr> {
+    pub fn value(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ast::Expr> {
         self.source(db)?.value.expr()
     }
 
-    pub fn eval(self, db: &dyn HirDatabase) -> Result<i128, ConstEvalError<'_>> {
+    pub fn eval(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Result<i128, ConstEvalError<'_>> {
         db.const_eval_discriminant(self.into())
     }
 
-    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {
+    pub fn layout(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Result<Layout, LayoutError> {
         let parent_enum = self.parent_enum(db);
         let parent_layout = parent_enum.layout(db)?;
         Ok(match &parent_layout.0.variants {
         })
     }
 
-    pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_unstable(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
 
-    pub fn instantiate_infer<'db>(self, infer_ctxt: &InferCtxt<'db>) -> InstantiatedVariant<'db> {
+    pub fn instantiate_infer<'db>(
+        self,
+        infer_ctxt: &InferCtxt<'db>,
+    ) -> InstantiatedVariant<'db> {
         let args =
             infer_ctxt.fresh_args_for_item(self.parent_enum(infer_ctxt.interner.db()).id.into());
         InstantiatedVariant { inner: self, args }
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct InstantiatedVariant<'db> {
     pub(crate) inner: Variant,
 }
 
 impl<'db> InstantiatedVariant<'db> {
-    pub fn parent_enum(self, db: &dyn HirDatabase) -> InstantiatedEnum<'db> {
+    pub fn parent_enum(
+        self,
+        db: &dyn HirDatabase,
+    ) -> InstantiatedEnum<'db> {
         InstantiatedEnum { inner: self.inner.id.lookup(db).parent.into(), args: self.args }
     }
 
-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<InstantiatedField<'db>> {
+    pub fn fields(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<InstantiatedField<'db>> {
         self.inner
             .id
             .fields(db)
 
 /// Variants inherit visibility from the parent enum.
 impl HasVisibility for Variant {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         self.parent_enum(db).visibility(db)
     }
 }
     Union(Union),
     Enum(Enum),
 }
-impl_from!(Struct, Union, Enum for Adt);
-
 impl Adt {
-    pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {
+    pub fn has_non_default_type_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         has_non_default_type_params(db, self.into())
     }
 
-    pub fn layout(self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {
+    pub fn layout(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Result<Layout, LayoutError> {
         let env = db.trait_environment(self.into());
         let interner = DbInterner::new_with(db, Some(env.krate), env.block);
         let adt_id = AdtId::from(self);
     /// Turns this ADT into a type. Any type parameters of the ADT will be
     /// turned into unknown types, which is good for e.g. finding the most
     /// general set of completions, but will not look very nice when printed.
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         let id = AdtId::from(self);
         Type::from_def(db, id)
     }
         Type::new(db, id, ty)
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         match self {
             Adt::Struct(s) => s.module(db),
             Adt::Union(s) => s.module(db),
         }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         match self {
             Adt::Struct(s) => s.name(db),
             Adt::Union(u) => u.name(db),
     }
 
     /// Returns the lifetime of the DataType
-    pub fn lifetime(&self, db: &dyn HirDatabase) -> Option<LifetimeParamData> {
+    pub fn lifetime(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<LifetimeParamData> {
         let resolver = match self {
             Adt::Struct(s) => s.id.resolver(db),
             Adt::Union(u) => u.id.resolver(db),
 }
 
 impl HasVisibility for Adt {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         match self {
             Adt::Struct(it) => it.visibility(db),
             Adt::Union(it) => it.visibility(db),
     Union(Union),
     Variant(Variant),
 }
-impl_from!(Struct, Union, Variant for VariantDef);
-
 impl VariantDef {
-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
+    pub fn fields(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Field> {
         match self {
             VariantDef::Struct(it) => it.fields(db),
             VariantDef::Union(it) => it.fields(db),
         }
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         match self {
             VariantDef::Struct(it) => it.module(db),
             VariantDef::Union(it) => it.module(db),
         }
     }
 
-    pub fn name(&self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         match self {
             VariantDef::Struct(s) => s.name(db),
             VariantDef::Union(u) => u.name(db),
     Const(Const),
     Variant(Variant),
 }
-impl_from!(Function, Const, Static, Variant for DefWithBody);
-
 impl DefWithBody {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         match self {
             DefWithBody::Const(c) => c.module(db),
             DefWithBody::Function(f) => f.module(db),
         }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Name> {
         match self {
             DefWithBody::Function(f) => Some(f.name(db)),
             DefWithBody::Static(s) => Some(s.name(db)),
     }
 
     /// Returns the type this def's body has to evaluate to.
-    pub fn body_type(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn body_type(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         match self {
             DefWithBody::Function(it) => it.ret_type(db),
             DefWithBody::Static(it) => it.ty(db),
     }
 
     /// A textual representation of the HIR of this def's body for debugging purposes.
-    pub fn debug_hir(self, db: &dyn HirDatabase) -> String {
+    pub fn debug_hir(
+        self,
+        db: &dyn HirDatabase,
+    ) -> String {
         let body = db.body(self.id());
         body.pretty_print(db, self.id(), Edition::CURRENT)
     }
 
     /// A textual representation of the MIR of this def's body for debugging purposes.
-    pub fn debug_mir(self, db: &dyn HirDatabase) -> String {
+    pub fn debug_mir(
+        self,
+        db: &dyn HirDatabase,
+    ) -> String {
         let body = db.mir_body(self.id());
         match body {
             Ok(body) => body.pretty_print(db, self.module(db).krate().to_display_target(db)),
         style_lints: bool,
     ) {
         let krate = self.module(db).id.krate();
-
         let (body, source_map) = db.body_with_source_map(self.into());
         let sig_source_map = match self {
             DefWithBody::Function(id) => db.function_signature_with_source_map(id.into()).1,
                 db.enum_signature_with_source_map(enum_id).1
             }
         };
-
         for (_, def_map) in body.blocks(db) {
             Module { id: def_map.module_id(DefMap::ROOT) }.diagnostics(db, acc, style_lints);
         }
-
         expr_store_diagnostics(db, acc, &source_map);
-
         let infer = db.infer(self.into());
         for d in infer.diagnostics() {
             acc.extend(AnyDiagnostic::inference_diagnostic(
                 &sig_source_map,
             ));
         }
-
         for (pat_or_expr, mismatch) in infer.type_mismatches() {
             let expr_or_pat = match pat_or_expr {
                 ExprOrPatId::ExprId(expr) => source_map.expr_syntax(expr).map(Either::Left),
                 .into(),
             );
         }
-
         let missing_unsafe = hir_ty::diagnostics::missing_unsafe(db, self.into());
         for (node, reason) in missing_unsafe.unsafe_exprs {
             match source_map.expr_or_pat_syntax(node) {
                 Err(SyntheticSyntax) => never!("synthetic DeprecatedSafe2024"),
             }
         }
-
         if let Ok(borrowck_results) = db.borrowck(self.into()) {
             for borrowck_result in borrowck_results.iter() {
                 let mir_body = &borrowck_result.mir_body;
                 }
             }
         }
-
         for diagnostic in BodyValidationDiagnostic::collect(db, self.into(), style_lints) {
             acc.extend(AnyDiagnostic::body_validation_diagnostic(db, diagnostic, &source_map));
         }
-
         let def: ModuleDef = match self {
             DefWithBody::Function(it) => it.into(),
             DefWithBody::Static(it) => it.into(),
             }
         });
     }
-
     source_map
         .macro_calls()
         .for_each(|(_ast_id, call_id)| macro_call_diagnostics(db, call_id, acc));
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Function {
     pub(crate) id: FunctionId,
 }
 
 impl Function {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.id.module(db).into()
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         db.function_signature(self.id).name.clone()
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_value_def(db, self.id)
     }
 
-    pub fn fn_ptr_type(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn fn_ptr_type(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         let resolver = self.id.resolver(db);
         let interner = DbInterner::new_with(db, None, None);
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
         let ty = Ty::new_fn_ptr(interner, callable_sig);
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
-
     // FIXME: Find a better API to express all combinations here, perhaps we should have `PreInstantiationType`?
 
     /// Get this function's return type
-    pub fn ret_type(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ret_type(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         let resolver = self.id.resolver(db);
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
         let ty = db
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ret_type_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
         let resolver = self.id.resolver(db);
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(interner, self.id.into(), generics.map(|ty| ty.ty));
-
         let interner = DbInterner::new_with(db, None, None);
         let ty = db
             .callable_item_signature(self.id.into())
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
 
-    pub fn async_ret_type<'db>(self, db: &'db dyn HirDatabase) -> Option<Type<'db>> {
+    pub fn async_ret_type<'db>(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<Type<'db>> {
         if !self.is_async(db) {
             return None;
         }
         None
     }
 
-    pub fn has_self_param(self, db: &dyn HirDatabase) -> bool {
+    pub fn has_self_param(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.function_signature(self.id).has_self_param()
     }
 
-    pub fn self_param(self, db: &dyn HirDatabase) -> Option<SelfParam> {
+    pub fn self_param(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<SelfParam> {
         self.has_self_param(db).then_some(SelfParam { func: self.id })
     }
 
-    pub fn assoc_fn_params(self, db: &dyn HirDatabase) -> Vec<Param<'_>> {
+    pub fn assoc_fn_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Param<'_>> {
         let environment = db.trait_environment(self.id.into());
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
         let callable_sig =
             .collect()
     }
 
-    pub fn num_params(self, db: &dyn HirDatabase) -> usize {
+    pub fn num_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> usize {
         db.function_signature(self.id).params.len()
     }
 
-    pub fn method_params(self, db: &dyn HirDatabase) -> Option<Vec<Param<'_>>> {
+    pub fn method_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Vec<Param<'_>>> {
         self.self_param(db)?;
         Some(self.params_without_self(db))
     }
 
-    pub fn params_without_self(self, db: &dyn HirDatabase) -> Vec<Param<'_>> {
+    pub fn params_without_self(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Param<'_>> {
         let environment = db.trait_environment(self.id.into());
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
         let callable_sig =
             .collect()
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn params_without_self_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
             .collect()
     }
 
-    pub fn is_const(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_const(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.function_signature(self.id).is_const()
     }
 
-    pub fn is_async(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_async(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.function_signature(self.id).is_async()
     }
 
-    pub fn is_varargs(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_varargs(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.function_signature(self.id).is_varargs()
     }
 
-    pub fn extern_block(self, db: &dyn HirDatabase) -> Option<ExternBlock> {
+    pub fn extern_block(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ExternBlock> {
         match self.id.lookup(db).container {
             ItemContainerId::ExternBlockId(id) => Some(ExternBlock { id }),
             _ => None,
         }
     }
 
-    pub fn returns_impl_future(self, db: &dyn HirDatabase) -> bool {
+    pub fn returns_impl_future(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         if self.is_async(db) {
             return true;
         }
-
         let ret_type = self.ret_type(db);
         let Some(impl_traits) = ret_type.as_impl_traits(db) else { return false };
         let Some(future_trait_id) = LangItem::Future.resolve_trait(db, self.ty(db).env.krate)
         let Some(sized_trait_id) = LangItem::Sized.resolve_trait(db, self.ty(db).env.krate) else {
             return false;
         };
-
         let mut has_impl_future = false;
         impl_traits
             .filter(|t| {
     }
 
     /// Does this function have `#[test]` attribute?
-    pub fn is_test(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_test(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).is_test()
     }
 
     /// is this a `fn main` or a function with an `export_name` of `main`?
-    pub fn is_main(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_main(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).export_name() == Some(&sym::main)
             || self.module(db).is_crate_root() && db.function_signature(self.id).name == sym::main
     }
 
     /// Is this a function with an `export_name` of `main`?
-    pub fn exported_main(self, db: &dyn HirDatabase) -> bool {
+    pub fn exported_main(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).export_name() == Some(&sym::main)
     }
 
     /// Does this function have the ignore attribute?
-    pub fn is_ignore(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_ignore(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).is_ignore()
     }
 
     /// Does this function have `#[bench]` attribute?
-    pub fn is_bench(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_bench(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).is_bench()
     }
 
     /// Is this function marked as unstable with `#[feature]` attribute?
-    pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_unstable(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
 
     /// Whether this function declaration has a definition.
     ///
     /// This is false in the case of required (not provided) trait methods.
-    pub fn has_body(self, db: &dyn HirDatabase) -> bool {
+    pub fn has_body(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.function_signature(self.id).has_body()
     }
 
-    pub fn as_proc_macro(self, db: &dyn HirDatabase) -> Option<Macro> {
+    pub fn as_proc_macro(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Macro> {
         let attrs = db.attrs(self.id.into());
         // FIXME: Store this in FunctionData flags?
         if !(attrs.is_proc_macro()
     }
 }
 
-// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum Access {
     Shared,
             _ => None,
         }
     }
-
     // pub fn parent_closure(&self) -> Option<Closure> {
     //     self.func.as_ref().right().cloned()
     // }
         &self.ty
     }
 
-    pub fn name(&self, db: &dyn HirDatabase) -> Option<Name> {
+    pub fn name(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<Name> {
         Some(self.as_local(db)?.name(db))
     }
 
-    pub fn as_local(&self, db: &dyn HirDatabase) -> Option<Local> {
+    pub fn as_local(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<Local> {
         match self.func {
             Callee::Def(CallableDefId::FunctionId(it)) => {
                 let parent = DefWithBodyId::FunctionId(it);
         }
     }
 
-    pub fn pattern_source(self, db: &dyn HirDatabase) -> Option<ast::Pat> {
+    pub fn pattern_source(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ast::Pat> {
         self.source(db).and_then(|p| p.value.right()?.pat())
     }
 }
 }
 
 impl SelfParam {
-    pub fn access(self, db: &dyn HirDatabase) -> Access {
+    pub fn access(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Access {
         let func_data = db.function_signature(self.func);
         func_data
             .params
         Function::from(self.func)
     }
 
-    pub fn ty<'db>(&self, db: &'db dyn HirDatabase) -> Type<'db> {
+    pub fn ty<'db>(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Type<'db> {
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
         let callable_sig =
             db.callable_item_signature(self.func.into()).instantiate_identity().skip_binder();
         Type { env: environment, ty }
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
 }
 
 impl HasVisibility for Function {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         db.assoc_visibility(self.id.into())
     }
 }
 }
 
 impl ExternCrateDecl {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.id.module(db).into()
     }
 
-    pub fn resolved_crate(self, db: &dyn HirDatabase) -> Option<Crate> {
+    pub fn resolved_crate(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Crate> {
         let loc = self.id.lookup(db);
         let krate = loc.container.krate();
         let name = self.name(db);
         }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         let loc = self.id.lookup(db);
         let source = loc.source(db);
         as_name_opt(source.value.name_ref())
     }
 
-    pub fn alias(self, db: &dyn HirDatabase) -> Option<ImportAlias> {
+    pub fn alias(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ImportAlias> {
         let loc = self.id.lookup(db);
         let source = loc.source(db);
         let rename = source.value.rename()?;
     }
 
     /// Returns the name under which this crate is made accessible, taking `_` into account.
-    pub fn alias_or_name(self, db: &dyn HirDatabase) -> Option<Name> {
+    pub fn alias_or_name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Name> {
         match self.alias(db) {
             Some(ImportAlias::Underscore) => None,
             Some(ImportAlias::Alias(alias)) => Some(alias),
 }
 
 impl HasVisibility for ExternCrateDecl {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         let loc = self.id.lookup(db);
         let source = loc.source(db);
         visibility_from_ast(db, self.id, source.map(|src| src.visibility()))
 }
 
 impl Const {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.module(db) }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Name> {
         db.const_signature(self.id).name.clone()
     }
 
-    pub fn value(self, db: &dyn HirDatabase) -> Option<ast::Expr> {
+    pub fn value(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ast::Expr> {
         self.source(db)?.value.body()
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_value_def(db, self.id)
     }
 
     /// Evaluate the constant.
-    pub fn eval(self, db: &dyn HirDatabase) -> Result<EvaluatedConst<'_>, ConstEvalError<'_>> {
+    pub fn eval(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Result<EvaluatedConst<'_>, ConstEvalError<'_>> {
         let interner = DbInterner::new_with(db, None, None);
         let ty = db.value_ty(self.id.into()).unwrap().instantiate_identity();
         db.const_eval(self.id.into(), GenericArgs::new_from_iter(interner, []), None)
 }
 
 impl HasVisibility for Const {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         db.assoc_visibility(self.id.into())
     }
 }
 }
 
 impl<'db> EvaluatedConst<'db> {
-    pub fn render(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
+    pub fn render(
+        &self,
+        db: &dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
         format!("{}", self.const_.display(db, display_target))
     }
 
-    pub fn render_debug(&self, db: &'db dyn HirDatabase) -> Result<String, MirEvalError<'db>> {
+    pub fn render_debug(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Result<String, MirEvalError<'db>> {
         let kind = self.const_.kind();
         if let ConstKind::Value(c) = kind
             && let ty = c.ty.kind()
 }
 
 impl Static {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.module(db) }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         db.static_signature(self.id).name.clone()
     }
 
-    pub fn is_mut(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_mut(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.static_signature(self.id).flags.contains(StaticFlags::MUTABLE)
     }
 
-    pub fn value(self, db: &dyn HirDatabase) -> Option<ast::Expr> {
+    pub fn value(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ast::Expr> {
         self.source(db)?.value.body()
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_value_def(db, self.id)
     }
 
-    pub fn extern_block(self, db: &dyn HirDatabase) -> Option<ExternBlock> {
+    pub fn extern_block(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ExternBlock> {
         match self.id.lookup(db).container {
             ItemContainerId::ExternBlockId(id) => Some(ExternBlock { id }),
             _ => None,
     }
 
     /// Evaluate the static initializer.
-    pub fn eval(self, db: &dyn HirDatabase) -> Result<EvaluatedConst<'_>, ConstEvalError<'_>> {
+    pub fn eval(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Result<EvaluatedConst<'_>, ConstEvalError<'_>> {
         let interner = DbInterner::new_with(db, None, None);
         let ty = db.value_ty(self.id.into()).unwrap().instantiate_identity();
         db.const_eval(self.id.into(), GenericArgs::new_from_iter(interner, []), None)
 }
 
 impl HasVisibility for Static {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         let loc = self.id.lookup(db);
         let source = loc.source(db);
         visibility_from_ast(db, self.id, source.map(|src| src.visibility()))
 }
 
 impl Trait {
-    pub fn lang(db: &dyn HirDatabase, krate: Crate, name: &Name) -> Option<Trait> {
+    pub fn lang(
+        db: &dyn HirDatabase,
+        krate: Crate,
+        name: &Name,
+    ) -> Option<Trait> {
         LangItem::from_name(name)?.resolve_trait(db, krate.into()).map(Into::into)
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.lookup(db).container }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         db.trait_signature(self.id).name.clone()
     }
 
-    pub fn direct_supertraits(self, db: &dyn HirDatabase) -> Vec<Trait> {
+    pub fn direct_supertraits(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Trait> {
         let traits = direct_super_traits(db, self.into());
         traits.iter().map(|tr| Trait::from(*tr)).collect()
     }
 
-    pub fn all_supertraits(self, db: &dyn HirDatabase) -> Vec<Trait> {
+    pub fn all_supertraits(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Trait> {
         let traits = all_super_traits(db, self.into());
         traits.iter().map(|tr| Trait::from(*tr)).collect()
     }
 
-    pub fn function(self, db: &dyn HirDatabase, name: impl PartialEq<Name>) -> Option<Function> {
+    pub fn function(
+        self,
+        db: &dyn HirDatabase,
+        name: impl PartialEq<Name>,
+    ) -> Option<Function> {
         self.id.trait_items(db).items.iter().find(|(n, _)| name == *n).and_then(|&(_, it)| match it
         {
             AssocItemId::FunctionId(id) => Some(Function { id }),
         })
     }
 
-    pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {
+    pub fn items(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<AssocItem> {
         self.id.trait_items(db).items.iter().map(|(_name, it)| (*it).into()).collect()
     }
 
-    pub fn items_with_supertraits(self, db: &dyn HirDatabase) -> Vec<AssocItem> {
+    pub fn items_with_supertraits(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<AssocItem> {
         self.all_supertraits(db).into_iter().flat_map(|tr| tr.items(db)).collect()
     }
 
-    pub fn is_auto(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_auto(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.trait_signature(self.id).flags.contains(TraitFlags::AUTO)
     }
 
-    pub fn is_unsafe(&self, db: &dyn HirDatabase) -> bool {
+    pub fn is_unsafe(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.trait_signature(self.id).flags.contains(TraitFlags::UNSAFE)
     }
 
             .count()
     }
 
-    pub fn dyn_compatibility(&self, db: &dyn HirDatabase) -> Option<DynCompatibilityViolation> {
+    pub fn dyn_compatibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<DynCompatibilityViolation> {
         hir_ty::dyn_compatibility::dyn_compatibility(db, self.id)
     }
 
         violations.is_empty().not().then_some(violations)
     }
 
-    fn all_macro_calls(&self, db: &dyn HirDatabase) -> Box<[(AstId<ast::Item>, MacroCallId)]> {
+    fn all_macro_calls(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Box<[(AstId<ast::Item>, MacroCallId)]> {
         self.id.trait_items(db).macro_calls.to_vec().into_boxed_slice()
     }
 
     /// `#[rust_analyzer::completions(...)]` mode.
-    pub fn complete(self, db: &dyn HirDatabase) -> Complete {
+    pub fn complete(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Complete {
         Complete::extract(true, &self.attrs(db))
     }
 }
 
 impl HasVisibility for Trait {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         let loc = self.id.lookup(db);
         let source = loc.source(db);
         visibility_from_ast(db, self.id, source.map(|src| src.visibility()))
 }
 
 impl TypeAlias {
-    pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {
+    pub fn has_non_default_type_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         has_non_default_type_params(db, self.id.into())
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.module(db) }
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_def(db, self.id)
     }
 
-    pub fn ty_params(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::from_def_params(db, self.id)
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         db.type_alias_signature(self.id).name.clone()
     }
 }
 
 impl HasVisibility for TypeAlias {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         db.assoc_visibility(self.id.into())
     }
 }
 }
 
 impl ExternBlock {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.module(db) }
     }
 }
 }
 
 impl BuiltinType {
-    // Constructors are added on demand, feel free to add more.
     pub fn str() -> BuiltinType {
         BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }
     }
         }
     }
 
-    pub fn ty<'db>(self, db: &'db dyn HirDatabase) -> Type<'db> {
+    pub fn ty<'db>(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Type<'db> {
         let core = Crate::core(db).map(|core| core.id).unwrap_or_else(|| db.all_crates()[0]);
         let interner = DbInterner::new_with(db, None, None);
         Type::new_for_crate(core, Ty::from_builtin_type(interner, self.inner))
 }
 
 impl Macro {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         Module { id: self.id.module(db) }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         match self.id {
             MacroId::Macro2Id(id) => {
                 let loc = id.lookup(db);
         }
     }
 
-    pub fn is_macro_export(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_macro_export(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         matches!(self.id, MacroId::MacroRulesId(_) if db.attrs(self.id.into()).by_key(sym::macro_export).exists())
     }
 
         matches!(self.id, MacroId::ProcMacroId(_))
     }
 
-    pub fn kind(&self, db: &dyn HirDatabase) -> MacroKind {
+    pub fn kind(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> MacroKind {
         match self.id {
             MacroId::Macro2Id(it) => match it.lookup(db).expander {
                 MacroExpander::Declarative => MacroKind::Declarative,
         }
     }
 
-    pub fn is_fn_like(&self, db: &dyn HirDatabase) -> bool {
+    pub fn is_fn_like(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         matches!(
             self.kind(db),
             MacroKind::Declarative | MacroKind::DeclarativeBuiltIn | MacroKind::ProcMacro
         )
     }
 
-    pub fn is_builtin_derive(&self, db: &dyn HirDatabase) -> bool {
+    pub fn is_builtin_derive(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         match self.id {
             MacroId::Macro2Id(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltInDerive(_))
         }
     }
 
-    pub fn is_env_or_option_env(&self, db: &dyn HirDatabase) -> bool {
+    pub fn is_env_or_option_env(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         match self.id {
             MacroId::Macro2Id(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltInEager(eager) if eager.is_env_or_option_env())
     }
 
     /// Is this `asm!()`, or a variant of it (e.g. `global_asm!()`)?
-    pub fn is_asm_like(&self, db: &dyn HirDatabase) -> bool {
+    pub fn is_asm_like(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         match self.id {
             MacroId::Macro2Id(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltIn(m) if m.is_asm())
         }
     }
 
-    pub fn is_attr(&self, db: &dyn HirDatabase) -> bool {
+    pub fn is_attr(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         matches!(self.kind(db), MacroKind::Attr | MacroKind::AttrBuiltIn)
     }
 
-    pub fn is_derive(&self, db: &dyn HirDatabase) -> bool {
+    pub fn is_derive(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         matches!(self.kind(db), MacroKind::Derive | MacroKind::DeriveBuiltIn)
     }
 }
 
 impl HasVisibility for Macro {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         match self.id {
             MacroId::Macro2Id(id) => {
                 let loc = id.lookup(db);
     }
 
     /// Returns the crate defining this item (or `None` if `self` is built-in).
-    pub fn krate(&self, db: &dyn HirDatabase) -> Option<Crate> {
+    pub fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<Crate> {
         match self {
             ItemInNs::Types(did) | ItemInNs::Values(did) => did.module(db).map(|m| m.krate()),
             ItemInNs::Macros(id) => Some(id.module(db).krate()),
         }
     }
 
-    pub fn attrs(&self, db: &dyn HirDatabase) -> Option<AttrsWithOwner> {
+    pub fn attrs(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<AttrsWithOwner> {
         match self {
             ItemInNs::Types(it) | ItemInNs::Values(it) => it.attrs(db),
             ItemInNs::Macros(it) => Some(it.attrs(db)),
 }
 
 pub trait AsExternAssocItem {
-    fn as_extern_assoc_item(self, db: &dyn HirDatabase) -> Option<ExternAssocItem>;
+    fn as_extern_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ExternAssocItem>;
 }
 
 impl AsExternAssocItem for Function {
-    fn as_extern_assoc_item(self, db: &dyn HirDatabase) -> Option<ExternAssocItem> {
+    fn as_extern_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ExternAssocItem> {
         as_extern_assoc_item(db, ExternAssocItem::Function, self.id)
     }
 }
 
 impl AsExternAssocItem for Static {
-    fn as_extern_assoc_item(self, db: &dyn HirDatabase) -> Option<ExternAssocItem> {
+    fn as_extern_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ExternAssocItem> {
         as_extern_assoc_item(db, ExternAssocItem::Static, self.id)
     }
 }
 
 impl AsExternAssocItem for TypeAlias {
-    fn as_extern_assoc_item(self, db: &dyn HirDatabase) -> Option<ExternAssocItem> {
+    fn as_extern_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ExternAssocItem> {
         as_extern_assoc_item(db, ExternAssocItem::TypeAlias, self.id)
     }
 }
 }
 
 pub trait AsAssocItem {
-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem>;
+    fn as_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<AssocItem>;
 }
 
 impl AsAssocItem for Function {
-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {
+    fn as_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<AssocItem> {
         as_assoc_item(db, AssocItem::Function, self.id)
     }
 }
 
 impl AsAssocItem for Const {
-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {
+    fn as_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<AssocItem> {
         as_assoc_item(db, AssocItem::Const, self.id)
     }
 }
 
 impl AsAssocItem for TypeAlias {
-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {
+    fn as_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<AssocItem> {
         as_assoc_item(db, AssocItem::TypeAlias, self.id)
     }
 }
 
 impl AsAssocItem for ModuleDef {
-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {
+    fn as_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<AssocItem> {
         match self {
             ModuleDef::Function(it) => it.as_assoc_item(db),
             ModuleDef::Const(it) => it.as_assoc_item(db),
 }
 
 impl AsAssocItem for DefWithBody {
-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {
+    fn as_assoc_item(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<AssocItem> {
         match self {
             DefWithBody::Function(it) => it.as_assoc_item(db),
             DefWithBody::Const(it) => it.as_assoc_item(db),
 where
     ID: Lookup<Database = dyn DefDatabase, Data = AssocItemLoc<LOC>>,
     DEF: From<ID>,
-    LOC: AstIdNode,
-{
+    LOC: AstIdNode, {
     match id.lookup(db).container {
         ItemContainerId::TraitId(_) | ItemContainerId::ImplId(_) => Some(ctor(DEF::from(id))),
         ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => None,
 where
     ID: Lookup<Database = dyn DefDatabase, Data = AssocItemLoc<LOC>>,
     DEF: From<ID>,
-    LOC: AstIdNode,
-{
+    LOC: AstIdNode, {
     match id.lookup(db).container {
         ItemContainerId::ExternBlockId(_) => Some(ctor(DEF::from(id))),
         ItemContainerId::TraitId(_) | ItemContainerId::ImplId(_) | ItemContainerId::ModuleId(_) => {
 }
 
 impl ExternAssocItem {
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         match self {
             Self::Function(it) => it.name(db),
             Self::Static(it) => it.name(db),
         }
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         match self {
             Self::Function(f) => f.module(db),
             Self::Static(c) => c.module(db),
 }
 
 impl AssocItem {
-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Name> {
         match self {
             AssocItem::Function(it) => Some(it.name(db)),
             AssocItem::Const(it) => it.name(db),
         }
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         match self {
             AssocItem::Function(f) => f.module(db),
             AssocItem::Const(c) => c.module(db),
         }
     }
 
-    pub fn container(self, db: &dyn HirDatabase) -> AssocItemContainer {
+    pub fn container(
+        self,
+        db: &dyn HirDatabase,
+    ) -> AssocItemContainer {
         let container = match self {
             AssocItem::Function(it) => it.id.lookup(db).container,
             AssocItem::Const(it) => it.id.lookup(db).container,
         }
     }
 
-    pub fn container_trait(self, db: &dyn HirDatabase) -> Option<Trait> {
+    pub fn container_trait(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Trait> {
         match self.container(db) {
             AssocItemContainer::Trait(t) => Some(t),
             _ => None,
         }
     }
 
-    pub fn implemented_trait(self, db: &dyn HirDatabase) -> Option<Trait> {
+    pub fn implemented_trait(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Trait> {
         match self.container(db) {
             AssocItemContainer::Impl(i) => i.trait_(db),
             _ => None,
         }
     }
 
-    pub fn container_or_implemented_trait(self, db: &dyn HirDatabase) -> Option<Trait> {
+    pub fn container_or_implemented_trait(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Trait> {
         match self.container(db) {
             AssocItemContainer::Trait(t) => Some(t),
             AssocItemContainer::Impl(i) => i.trait_(db),
         }
     }
 
-    pub fn implementing_ty(self, db: &dyn HirDatabase) -> Option<Type<'_>> {
+    pub fn implementing_ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Type<'_>> {
         match self.container(db) {
             AssocItemContainer::Impl(i) => Some(i.self_ty(db)),
             _ => None,
 }
 
 impl HasVisibility for AssocItem {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility {
         match self {
             AssocItem::Function(f) => f.visibility(db),
             AssocItem::Const(c) => c.visibility(db),
     Trait(Trait),
     TypeAlias(TypeAlias),
     Impl(Impl),
-    // consts can have type parameters from their parents (i.e. associated consts of traits)
     Const(Const),
     Static(Static),
 }
-impl_from!(
-    Function,
-    Adt(Struct, Enum, Union),
-    Trait,
-    TypeAlias,
-    Impl,
-    Const,
-    Static
-    for GenericDef
-);
-
 impl GenericDef {
-    pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {
+    pub fn params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<GenericParam> {
         let generics = db.generic_params(self.into());
         let ty_params = generics.iter_type_or_consts().map(|(local_id, _)| {
             let toc = TypeOrConstParam { id: TypeOrConstParamId { parent: self.into(), local_id } };
             .collect()
     }
 
-    pub fn lifetime_params(self, db: &dyn HirDatabase) -> Vec<LifetimeParam> {
+    pub fn lifetime_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<LifetimeParam> {
         let generics = db.generic_params(self.into());
         generics
             .iter_lt()
             .collect()
     }
 
-    pub fn type_or_const_params(self, db: &dyn HirDatabase) -> Vec<TypeOrConstParam> {
+    pub fn type_or_const_params(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<TypeOrConstParam> {
         let generics = db.generic_params(self.into());
         generics
             .iter_type_or_consts()
         }
     }
 
-    pub fn diagnostics<'db>(self, db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>) {
+    pub fn diagnostics<'db>(
+        self,
+        db: &'db dyn HirDatabase,
+        acc: &mut Vec<AnyDiagnostic<'db>>,
+    ) {
         let def = self.id();
-
         let generics = db.generic_params(def);
-
         if generics.is_empty() && generics.has_no_predicates() {
             return;
         }
-
         let source_map = match def {
             GenericDefId::AdtId(AdtId::EnumId(it)) => db.enum_signature_with_source_map(it).1,
             GenericDefId::AdtId(AdtId::StructId(it)) => db.struct_signature_with_source_map(it).1,
             GenericDefId::TraitId(it) => db.trait_signature_with_source_map(it).1,
             GenericDefId::TypeAliasId(it) => db.type_alias_signature_with_source_map(it).1,
         };
-
         expr_store_diagnostics(db, acc, &source_map);
         push_ty_diagnostics(db, acc, db.generic_defaults_with_diagnostics(def).1, &source_map);
         push_ty_diagnostics(
     }
 }
 
-// We cannot call this `Substitution` unfortunately...
 #[derive(Debug)]
 pub struct GenericSubstitution<'db> {
     def: GenericDefId,
 }
 
 impl<'db> GenericSubstitution<'db> {
-    fn new(def: GenericDefId, subst: GenericArgs<'db>, env: Arc<TraitEnvironment<'db>>) -> Self {
+    fn new(
+        def: GenericDefId,
+        subst: GenericArgs<'db>,
+        env: Arc<TraitEnvironment<'db>>,
+    ) -> Self {
         Self { def, subst, env }
     }
 
-    pub fn types(&self, db: &'db dyn HirDatabase) -> Vec<(Symbol, Type<'db>)> {
+    pub fn types(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Vec<(Symbol, Type<'db>)> {
         let container = match self.def {
             GenericDefId::ConstId(id) => Some(id.lookup(db).container),
             GenericDefId::FunctionId(id) => Some(id.lookup(db).container),
         }
     }
 
-    pub fn original_file(&self, db: &dyn HirDatabase) -> EditionedFileId {
+    pub fn original_file(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> EditionedFileId {
         self.source.file_id.original_file(db)
     }
 
 }
 
 impl Local {
-    pub fn is_param(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_param(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         // FIXME: This parses!
         let src = self.primary_source(db);
         match src.source.value {
         }
     }
 
-    pub fn as_self_param(self, db: &dyn HirDatabase) -> Option<SelfParam> {
+    pub fn as_self_param(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<SelfParam> {
         match self.parent {
             DefWithBodyId::FunctionId(func) if self.is_self(db) => Some(SelfParam { func }),
             _ => None,
         }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         let body = db.body(self.parent);
         body[self.binding_id].name.clone()
     }
 
-    pub fn is_self(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_self(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         self.name(db) == sym::self_
     }
 
-    pub fn is_mut(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_mut(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         let body = db.body(self.parent);
         body[self.binding_id].mode == BindingAnnotation::Mutable
     }
 
-    pub fn is_ref(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_ref(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         let body = db.body(self.parent);
         matches!(body[self.binding_id].mode, BindingAnnotation::Ref | BindingAnnotation::RefMut)
     }
 
-    pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {
+    pub fn parent(
+        self,
+        _db: &dyn HirDatabase,
+    ) -> DefWithBody {
         self.parent.into()
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.parent(db).module(db)
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         let def = self.parent;
         let infer = db.infer(def);
         let ty = infer[self.binding_id];
     }
 
     /// All definitions for this local. Example: `let (a$0, _) | (_, a$0) = it;`
-    pub fn sources(self, db: &dyn HirDatabase) -> Vec<LocalSource> {
+    pub fn sources(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<LocalSource> {
         let (body, source_map) = db.body_with_source_map(self.parent);
         match body.self_param.zip(source_map.self_param_syntax()) {
             Some((param, source)) if param == self.binding_id => {
     }
 
     /// The leftmost definition for this local. Example: `let (a$0, _) | (_, a) = it;`
-    pub fn primary_source(self, db: &dyn HirDatabase) -> LocalSource {
+    pub fn primary_source(
+        self,
+        db: &dyn HirDatabase,
+    ) -> LocalSource {
         let (body, source_map) = db.body_with_source_map(self.parent);
         match body.self_param.zip(source_map.self_param_syntax()) {
             Some((param, source)) if param == self.binding_id => {
 }
 
 impl PartialOrd for Local {
-    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
+    fn partial_cmp(
+        &self,
+        other: &Self,
+    ) -> Option<std::cmp::Ordering> {
         Some(self.cmp(other))
     }
 }
 
 impl Ord for Local {
-    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
+    fn cmp(
+        &self,
+        other: &Self,
+    ) -> std::cmp::Ordering {
         self.binding_id.cmp(&other.binding_id)
     }
 }
         Macro { id: self.derive }
     }
 
-    pub fn name(&self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         match self.derive {
             makro @ MacroId::Macro2Id(_) => db
                 .attrs(makro.into())
 }
 
 impl ToolModule {
-    pub(crate) fn by_name(db: &dyn HirDatabase, krate: Crate, name: &str) -> Option<Self> {
+    pub(crate) fn by_name(
+        db: &dyn HirDatabase,
+        krate: Crate,
+        name: &str,
+    ) -> Option<Self> {
         let krate = krate.id;
         let idx =
             crate_def_map(db, krate).registered_tools().iter().position(|it| it.as_str() == name)?
         Some(ToolModule { krate, idx })
     }
 
-    pub fn name(&self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         Name::new_symbol_root(
             crate_def_map(db, self.krate).registered_tools()[self.idx as usize].clone(),
         )
 }
 
 impl Label {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.parent(db).module(db)
     }
 
-    pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {
+    pub fn parent(
+        self,
+        _db: &dyn HirDatabase,
+    ) -> DefWithBody {
         self.parent.into()
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         let body = db.body(self.parent);
         body[self.label_id].name.clone()
     }
     ConstParam(ConstParam),
     LifetimeParam(LifetimeParam),
 }
-impl_from!(TypeParam, ConstParam, LifetimeParam for GenericParam);
-
 impl GenericParam {
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         match self {
             GenericParam::TypeParam(it) => it.module(db),
             GenericParam::ConstParam(it) => it.module(db),
         }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         match self {
             GenericParam::TypeParam(it) => it.name(db),
             GenericParam::ConstParam(it) => it.name(db),
         }
     }
 
-    pub fn variance(self, db: &dyn HirDatabase) -> Option<Variance> {
+    pub fn variance(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Variance> {
         let parent = match self {
             GenericParam::TypeParam(it) => it.id.parent(),
             // const parameters are always invariant
 }
 
 impl fmt::Display for Variance {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         let description = match self {
             Variance::Bivariant => "bivariant",
             Variance::Covariant => "covariant",
         TypeOrConstParam { id: self.id.into() }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         self.merge().name(db)
     }
 
-    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {
+    pub fn parent(
+        self,
+        _db: &dyn HirDatabase,
+    ) -> GenericDef {
         self.id.parent().into()
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.id.parent().module(db).into()
     }
 
     /// Is this type parameter implicitly introduced (eg. `Self` in a trait or an `impl Trait`
     /// argument)?
-    pub fn is_implicit(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_implicit(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         let params = db.generic_params(self.id.parent());
         let data = &params[self.id.local_id()];
         match data.type_param().unwrap().provenance {
         }
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         let resolver = self.id.parent().resolver(db);
         let interner = DbInterner::new_with(db, None, None);
         let index = hir_ty::param_idx(db, self.id.into()).unwrap();
     /// FIXME: this only lists trait bounds from the item defining the type
     /// parameter, not additional bounds that might be added e.g. by a method if
     /// the parameter comes from an impl!
-    pub fn trait_bounds(self, db: &dyn HirDatabase) -> Vec<Trait> {
+    pub fn trait_bounds(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<Trait> {
         db.generic_predicates_for_param(self.id.parent(), self.id.into(), None)
             .iter()
             .filter_map(|pred| match &pred.kind().skip_binder() {
             .collect()
     }
 
-    pub fn default(self, db: &dyn HirDatabase) -> Option<Type<'_>> {
+    pub fn default(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Type<'_>> {
         let ty = generic_arg_from_param(db, self.id.into())?;
         let resolver = self.id.parent().resolver(db);
         match ty {
         }
     }
 
-    pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_unstable(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.attrs(GenericParamId::from(self.id).into()).is_unstable()
     }
 }
 }
 
 impl LifetimeParam {
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         let params = db.generic_params(self.id.parent);
         params[self.id.local_id].name.clone()
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.id.parent.module(db).into()
     }
 
-    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {
+    pub fn parent(
+        self,
+        _db: &dyn HirDatabase,
+    ) -> GenericDef {
         self.id.parent.into()
     }
 }
         TypeOrConstParam { id: self.id.into() }
     }
 
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         let params = db.generic_params(self.id.parent());
         match params[self.id.local_id()].name() {
             Some(it) => it.clone(),
         }
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.id.parent().module(db).into()
     }
 
-    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {
+    pub fn parent(
+        self,
+        _db: &dyn HirDatabase,
+    ) -> GenericDef {
         self.id.parent().into()
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         Type::new(db, self.id.parent(), db.const_param_ty_ns(self.id))
     }
 
     }
 }
 
-fn generic_arg_from_param(db: &dyn HirDatabase, id: TypeOrConstParamId) -> Option<GenericArg<'_>> {
+fn generic_arg_from_param(
+    db: &dyn HirDatabase,
+    id: TypeOrConstParamId,
+) -> Option<GenericArg<'_>> {
     let local_idx = hir_ty::param_idx(db, id)?;
     let defaults = db.generic_defaults(id.parent);
     let ty = defaults.get(local_idx)?;
 }
 
 impl TypeOrConstParam {
-    pub fn name(self, db: &dyn HirDatabase) -> Name {
+    pub fn name(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Name {
         let params = db.generic_params(self.id.parent);
         match params[self.id.local_id].name() {
             Some(n) => n.clone(),
         }
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.id.parent.module(db).into()
     }
 
-    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {
+    pub fn parent(
+        self,
+        _db: &dyn HirDatabase,
+    ) -> GenericDef {
         self.id.parent.into()
     }
 
-    pub fn split(self, db: &dyn HirDatabase) -> Either<ConstParam, TypeParam> {
+    pub fn split(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Either<ConstParam, TypeParam> {
         let params = db.generic_params(self.id.parent);
         match &params[self.id.local_id] {
             TypeOrConstParamData::TypeParamData(_) => {
         }
     }
 
-    pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         match self.split(db) {
             Either::Left(it) => it.ty(db),
             Either::Right(it) => it.ty(db),
         }
     }
 
-    pub fn as_type_param(self, db: &dyn HirDatabase) -> Option<TypeParam> {
+    pub fn as_type_param(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<TypeParam> {
         let params = db.generic_params(self.id.parent);
         match &params[self.id.local_id] {
             TypeOrConstParamData::TypeParamData(_) => {
         }
     }
 
-    pub fn as_const_param(self, db: &dyn HirDatabase) -> Option<ConstParam> {
+    pub fn as_const_param(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<ConstParam> {
         let params = db.generic_params(self.id.parent);
         match &params[self.id.local_id] {
             TypeOrConstParamData::TypeParamData(_) => None,
 }
 
 impl Impl {
-    pub fn all_in_crate(db: &dyn HirDatabase, krate: Crate) -> Vec<Impl> {
+    pub fn all_in_crate(
+        db: &dyn HirDatabase,
+        krate: Crate,
+    ) -> Vec<Impl> {
         let inherent = db.inherent_impls_in_crate(krate.id);
         let trait_ = db.trait_impls_in_crate(krate.id);
-
         inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()
     }
 
-    pub fn all_in_module(db: &dyn HirDatabase, module: Module) -> Vec<Impl> {
+    pub fn all_in_module(
+        db: &dyn HirDatabase,
+        module: Module,
+    ) -> Vec<Impl> {
         module.id.def_map(db)[module.id.local_id].scope.impls().map(Into::into).collect()
     }
 
-    pub fn all_for_type<'db>(db: &'db dyn HirDatabase, Type { ty, env }: Type<'db>) -> Vec<Impl> {
+    pub fn all_for_type<'db>(
+        db: &'db dyn HirDatabase,
+        Type { ty, env }: Type<'db>,
+    ) -> Vec<Impl> {
         let def_crates = match method_resolution::def_crates(db, ty, env.krate) {
             Some(def_crates) => def_crates,
             None => return Vec::new(),
         };
-
         let filter = |impl_def: &Impl| {
             let self_ty = impl_def.self_ty(db);
             let rref = self_ty.remove_ref();
             ty.equals_ctor(rref.as_ref().map_or(self_ty.ty, |it| it.ty))
         };
-
         let fp = TyFingerprint::for_inherent_impl(ty);
         let fp = match fp {
             Some(fp) => fp,
             None => return Vec::new(),
         };
-
         let mut all = Vec::new();
         def_crates.iter().for_each(|&id| {
             all.extend(
                     .filter(filter),
             )
         });
-
         for id in def_crates
             .iter()
             .flat_map(|&id| Crate { id }.transitive_reverse_dependencies(db))
                     .filter(filter),
             );
         }
-
         if let Some(block) = ty.as_adt().and_then(|(def, _)| def.module(db).containing_block()) {
             if let Some(inherent_impls) = db.inherent_impls_in_block(block) {
                 all.extend(
                 );
             }
         }
-
         all
     }
 
-    pub fn all_for_trait(db: &dyn HirDatabase, trait_: Trait) -> Vec<Impl> {
+    pub fn all_for_trait(
+        db: &dyn HirDatabase,
+        trait_: Trait,
+    ) -> Vec<Impl> {
         let module = trait_.module(db);
         let krate = module.krate();
         let mut all = Vec::new();
         all
     }
 
-    pub fn trait_(self, db: &dyn HirDatabase) -> Option<Trait> {
+    pub fn trait_(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<Trait> {
         let trait_ref = db.impl_trait(self.id)?;
         let id = trait_ref.skip_binder().def_id;
         Some(Trait { id: id.0 })
     }
 
-    pub fn trait_ref(self, db: &dyn HirDatabase) -> Option<TraitRef<'_>> {
+    pub fn trait_ref(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<TraitRef<'_>> {
         let trait_ref = db.impl_trait(self.id)?.instantiate_identity();
         let resolver = self.id.resolver(db);
         Some(TraitRef::new_with_resolver(db, &resolver, trait_ref))
     }
 
-    pub fn self_ty(self, db: &dyn HirDatabase) -> Type<'_> {
+    pub fn self_ty(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Type<'_> {
         let resolver = self.id.resolver(db);
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
         let ty = db.impl_self_ty(self.id).instantiate_identity();
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
 
-    pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {
+    pub fn items(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Vec<AssocItem> {
         self.id.impl_items(db).items.iter().map(|&(_, it)| it.into()).collect()
     }
 
-    pub fn is_negative(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_negative(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.impl_signature(self.id).flags.contains(ImplFlags::NEGATIVE)
     }
 
-    pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {
+    pub fn is_unsafe(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         db.impl_signature(self.id).flags.contains(ImplFlags::UNSAFE)
     }
 
-    pub fn module(self, db: &dyn HirDatabase) -> Module {
+    pub fn module(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Module {
         self.id.lookup(db).container.into()
     }
 
-    pub fn as_builtin_derive_path(self, db: &dyn HirDatabase) -> Option<InMacroFile<ast::Path>> {
+    pub fn as_builtin_derive_path(
+        self,
+        db: &dyn HirDatabase,
+    ) -> Option<InMacroFile<ast::Path>> {
         let src = self.source(db)?;
-
         let macro_file = src.file_id.macro_file()?;
         let loc = macro_file.lookup(db);
         let (derive_attr, derive_index) = match loc.kind {
         Some(InMacroFile { file_id: derive_attr, value: path })
     }
 
-    pub fn check_orphan_rules(self, db: &dyn HirDatabase) -> bool {
+    pub fn check_orphan_rules(
+        self,
+        db: &dyn HirDatabase,
+    ) -> bool {
         check_orphan_rules(db, self.id)
     }
 
-    fn all_macro_calls(&self, db: &dyn HirDatabase) -> Box<[(AstId<ast::Item>, MacroCallId)]> {
+    fn all_macro_calls(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Box<[(AstId<ast::Item>, MacroCallId)]> {
         self.id.impl_items(db).macro_calls.to_vec().into_boxed_slice()
     }
 }
 
     /// Returns `idx`-th argument of this trait reference if it is a type argument. Note that the
     /// first argument is the `Self` type.
-    pub fn get_type_argument(&self, idx: usize) -> Option<TypeNs<'db>> {
+    pub fn get_type_argument(
+        &self,
+        idx: usize,
+    ) -> Option<TypeNs<'db>> {
         self.trait_ref
             .args
             .as_slice()
 }
 
 impl<'db> Closure<'db> {
-    fn as_ty(&self, db: &'db dyn HirDatabase) -> Ty<'db> {
+    fn as_ty(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Ty<'db> {
         let interner = DbInterner::new_with(db, None, None);
         match self.id {
             AnyClosureId::ClosureId(id) => Ty::new_closure(interner, id.into(), self.subst),
         }
     }
 
-    pub fn display_with_id(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
+    pub fn display_with_id(
+        &self,
+        db: &dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
         self.as_ty(db)
             .display(db, display_target)
             .with_closure_style(ClosureStyle::ClosureWithId)
             .to_string()
     }
 
-    pub fn display_with_impl(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
+    pub fn display_with_impl(
+        &self,
+        db: &dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
         self.as_ty(db)
             .display(db, display_target)
             .with_closure_style(ClosureStyle::ImplFn)
             .to_string()
     }
 
-    pub fn captured_items(&self, db: &'db dyn HirDatabase) -> Vec<ClosureCapture<'db>> {
+    pub fn captured_items(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Vec<ClosureCapture<'db>> {
         let AnyClosureId::ClosureId(id) = self.id else {
             // FIXME: Infer coroutine closures' captures.
             return Vec::new();
             .collect()
     }
 
-    pub fn capture_types(&self, db: &'db dyn HirDatabase) -> Vec<Type<'db>> {
+    pub fn capture_types(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Vec<Type<'db>> {
         let AnyClosureId::ClosureId(id) = self.id else {
             // FIXME: Infer coroutine closures' captures.
             return Vec::new();
             .collect()
     }
 
-    pub fn fn_trait(&self, db: &dyn HirDatabase) -> FnTrait {
+    pub fn fn_trait(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> FnTrait {
         match self.id {
             AnyClosureId::ClosureId(id) => {
                 let owner = db.lookup_intern_closure(id).0;
     }
 
     /// Converts the place to a name that can be inserted into source code.
-    pub fn place_to_name(&self, db: &dyn HirDatabase) -> String {
+    pub fn place_to_name(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> String {
         self.capture.place_to_name(self.owner, db)
     }
 
-    pub fn display_place_source_code(&self, db: &dyn HirDatabase) -> String {
+    pub fn display_place_source_code(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> String {
         self.capture.display_place_source_code(self.owner, db)
     }
 
-    pub fn display_place(&self, db: &dyn HirDatabase) -> String {
+    pub fn display_place(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> String {
         self.capture.display_place(self.owner, db)
     }
 }
 }
 
 impl CaptureUsages {
-    pub fn sources(&self, db: &dyn HirDatabase) -> Vec<CaptureUsageSource> {
+    pub fn sources(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Vec<CaptureUsageSource> {
         let (body, source_map) = db.body_with_source_map(self.parent);
-
         let mut result = Vec::with_capacity(self.spans.len());
         for &span in self.spans.iter() {
             let is_ref = span.is_ref_span(&body);
         Type { env: environment, ty }
     }
 
-    pub(crate) fn new_for_crate(krate: base_db::Crate, ty: Ty<'db>) -> Self {
+    pub(crate) fn new_for_crate(
+        krate: base_db::Crate,
+        ty: Ty<'db>,
+    ) -> Self {
         Type { env: TraitEnvironment::empty(krate), ty }
     }
 
-    fn new(db: &'db dyn HirDatabase, lexical_env: impl HasResolver, ty: Ty<'db>) -> Self {
+    fn new(
+        db: &'db dyn HirDatabase,
+        lexical_env: impl HasResolver,
+        ty: Ty<'db>,
+    ) -> Self {
         let resolver = lexical_env.resolver(db);
         let environment = resolver
             .generic_def()
         Type { env: environment, ty }
     }
 
-    fn from_def(db: &'db dyn HirDatabase, def: impl Into<TyDefId> + HasResolver) -> Self {
+    fn from_def(
+        db: &'db dyn HirDatabase,
+        def: impl Into<TyDefId> + HasResolver,
+    ) -> Self {
         let interner = DbInterner::new_with(db, None, None);
         let ty = db.ty(def.into());
         let def = match def.into() {
         Type::new(db, def, ty.instantiate(interner, args))
     }
 
-    // FIXME: We shouldn't leak `TyKind::Param`s.
-    fn from_def_params(db: &'db dyn HirDatabase, def: impl Into<TyDefId> + HasResolver) -> Self {
+    fn from_def_params(
+        db: &'db dyn HirDatabase,
+        def: impl Into<TyDefId> + HasResolver,
+    ) -> Self {
         let ty = db.ty(def.into());
         Type::new(db, def, ty.instantiate_identity())
     }
         Type { env: ty.env, ty: Ty::new_slice(interner, ty.ty) }
     }
 
-    pub fn new_tuple(krate: base_db::Crate, tys: &[Self]) -> Self {
+    pub fn new_tuple(
+        krate: base_db::Crate,
+        tys: &[Self],
+    ) -> Self {
         let tys = tys.iter().map(|it| it.ty);
         let interner = DbInterner::conjure();
         Type { env: TraitEnvironment::empty(krate), ty: Ty::new_tup_from_iter(interner, tys) }
         matches!(self.ty.kind(), TyKind::Ref(..))
     }
 
-    pub fn contains_reference(&self, db: &'db dyn HirDatabase) -> bool {
+    pub fn contains_reference(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         return self.ty.visit_with(&mut Visitor { interner }).is_break();
-
         fn is_phantom_data(db: &dyn HirDatabase, adt_id: AdtId) -> bool {
             match adt_id {
                 AdtId::StructId(s) => {
                 AdtId::UnionId(_) | AdtId::EnumId(_) => false,
             }
         }
-
         struct Visitor<'db> {
             interner: DbInterner<'db>,
         }
-
         impl<'db> TypeVisitor<DbInterner<'db>> for Visitor<'db> {
             type Result = ControlFlow<()>;
 
         Some((self.derived(ty), m))
     }
 
-    pub fn add_reference(&self, mutability: Mutability) -> Self {
+    pub fn add_reference(
+        &self,
+        mutability: Mutability,
+    ) -> Self {
         let interner = DbInterner::conjure();
         let ty_mutability = match mutability {
             Mutability::Shared => hir_ty::next_solver::Mutability::Not,
         self.derived(self.ty.strip_references())
     }
 
-    // FIXME: This is the same as `remove_ref()`, remove one of these methods.
     pub fn strip_reference(&self) -> Self {
         self.derived(self.ty.strip_reference())
     }
     /// Checks that particular type `ty` implements `std::future::IntoFuture` or
     /// `std::future::Future` and returns the `Output` associated type.
     /// This function is used in `.await` syntax completion.
-    pub fn into_future_output(&self, db: &'db dyn HirDatabase) -> Option<Type<'db>> {
+    pub fn into_future_output(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<Type<'db>> {
         let trait_ = LangItem::IntoFutureIntoFuture
             .resolve_function(db, self.env.krate)
             .and_then(|into_future_fn| {
                 Some(into_future_trait.id)
             })
             .or_else(|| LangItem::Future.resolve_trait(db, self.env.krate))?;
-
         if !traits::implements_trait_unique(self.ty, db, self.env.clone(), trait_) {
             return None;
         }
-
         let output_assoc_type =
             trait_.trait_items(db).associated_type_by_name(&Name::new_symbol_root(sym::Output))?;
         self.normalize_trait_assoc_type(db, &[], output_assoc_type.into())
     }
 
     /// This does **not** resolve `IntoFuture`, only `Future`.
-    pub fn future_output(self, db: &'db dyn HirDatabase) -> Option<Type<'db>> {
+    pub fn future_output(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<Type<'db>> {
         let future_output = LangItem::FutureOutput.resolve_type_alias(db, self.env.krate)?;
         self.normalize_trait_assoc_type(db, &[], future_output.into())
     }
 
     /// This does **not** resolve `IntoIterator`, only `Iterator`.
-    pub fn iterator_item(self, db: &'db dyn HirDatabase) -> Option<Type<'db>> {
+    pub fn iterator_item(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<Type<'db>> {
         let iterator_trait = LangItem::Iterator.resolve_trait(db, self.env.krate)?;
         let iterator_item = iterator_trait
             .trait_items(db)
         self.normalize_trait_assoc_type(db, &[], iterator_item.into())
     }
 
-    pub fn impls_iterator(self, db: &'db dyn HirDatabase) -> bool {
+    pub fn impls_iterator(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> bool {
         let Some(iterator_trait) = LangItem::Iterator.resolve_trait(db, self.env.krate) else {
             return false;
         };
     }
 
     /// Resolves the projection `<Self as IntoIterator>::IntoIter` and returns the resulting type
-    pub fn into_iterator_iter(self, db: &'db dyn HirDatabase) -> Option<Type<'db>> {
+    pub fn into_iterator_iter(
+        self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<Type<'db>> {
         let trait_ = LangItem::IntoIterIntoIter.resolve_function(db, self.env.krate).and_then(
             |into_iter_fn| {
                 let assoc_item = as_assoc_item(db, AssocItem::Function, into_iter_fn)?;
                 Some(into_iter_trait.id)
             },
         )?;
-
         if !traits::implements_trait_unique(self.ty, db, self.env.clone(), trait_) {
             return None;
         }
-
         let into_iter_assoc_type = trait_
             .trait_items(db)
             .associated_type_by_name(&Name::new_symbol_root(sym::IntoIter))?;
     ///
     /// This function can be used to check if a particular type is callable, since FnOnce is a
     /// supertrait of Fn and FnMut, so all callable types implements at least FnOnce.
-    pub fn impls_fnonce(&self, db: &'db dyn HirDatabase) -> bool {
+    pub fn impls_fnonce(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> bool {
         let fnonce_trait = match FnTrait::FnOnce.get_id(db, self.env.krate) {
             Some(it) => it,
             None => return false,
         };
-
         traits::implements_trait_unique(self.ty, db, self.env.clone(), fnonce_trait)
     }
 
-    // FIXME: Find better API that also handles const generics
-    pub fn impls_trait(&self, db: &'db dyn HirDatabase, trait_: Trait, args: &[Type<'db>]) -> bool {
+    pub fn impls_trait(
+        &self,
+        db: &'db dyn HirDatabase,
+        trait_: Trait,
+        args: &[Type<'db>],
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(
             interner,
             AliasTyKind::Projection,
             AliasTy::new(interner, alias.id.into(), args),
         );
-
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
         let ty = structurally_normalize_ty(&infcx, projection, self.env.clone());
         if ty.is_ty_error() { None } else { Some(self.derived(ty)) }
     }
 
-    pub fn is_copy(&self, db: &'db dyn HirDatabase) -> bool {
+    pub fn is_copy(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> bool {
         let Some(copy_trait) = LangItem::Copy.resolve_trait(db, self.env.krate) else {
             return false;
         };
         self.impls_trait(db, copy_trait.into(), &[])
     }
 
-    pub fn as_callable(&self, db: &'db dyn HirDatabase) -> Option<Callable<'db>> {
+    pub fn as_callable(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<Callable<'db>> {
         let interner = DbInterner::new_with(db, None, None);
         let callee = match self.ty.kind() {
             TyKind::Closure(id, subst) => Callee::Closure(id.0, subst),
                 });
             }
         };
-
         let sig = self.ty.callable_sig(interner)?;
         Some(Callable { ty: self.clone(), sig, callee, is_bound_method: false })
     }
         matches!(self.ty.kind(), TyKind::Array(..))
     }
 
-    pub fn is_packed(&self, db: &'db dyn HirDatabase) -> bool {
+    pub fn is_packed(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> bool {
         let adt_id = match self.ty.kind() {
             TyKind::Adt(adt_def, ..) => adt_def.def_id().0,
             _ => return false,
         };
-
         let adt = adt_id.into();
         match adt {
             Adt::Struct(s) => s.repr(db).unwrap_or_default().pack.is_some(),
         self.ty.references_non_lt_error()
     }
 
-    pub fn fields(&self, db: &'db dyn HirDatabase) -> Vec<(Field, Self)> {
+    pub fn fields(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Vec<(Field, Self)> {
         let interner = DbInterner::new_with(db, None, None);
         let (variant_id, substs) = match self.ty.kind() {
             TyKind::Adt(adt_def, substs) => {
             }
             _ => return Vec::new(),
         };
-
         db.field_types(variant_id)
             .iter()
             .map(|(local_id, ty)| {
             .collect()
     }
 
-    pub fn tuple_fields(&self, _db: &'db dyn HirDatabase) -> Vec<Self> {
+    pub fn tuple_fields(
+        &self,
+        _db: &'db dyn HirDatabase,
+    ) -> Vec<Self> {
         if let TyKind::Tuple(substs) = self.ty.kind() {
             substs.iter().map(|ty| self.derived(ty)).collect()
         } else {
         }
     }
 
-    pub fn as_array(&self, db: &'db dyn HirDatabase) -> Option<(Self, usize)> {
+    pub fn as_array(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<(Self, usize)> {
         if let TyKind::Array(ty, len) = self.ty.kind() {
             try_const_usize(db, len).map(|it| (self.derived(ty), it as usize))
         } else {
         TyFingerprint::for_trait_impl(self.ty)
     }
 
-    pub(crate) fn canonical(&self, db: &'db dyn HirDatabase) -> Canonical<'db, Ty<'db>> {
+    pub(crate) fn canonical(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Canonical<'db, Ty<'db>> {
         let interner = DbInterner::new_with(db, None, None);
         hir_ty::replace_errors_with_variables(interner, &self.ty)
     }
         self.autoderef_(db).map(move |ty| self.derived(ty))
     }
 
-    fn autoderef_(&self, db: &'db dyn HirDatabase) -> impl Iterator<Item = Ty<'db>> {
+    fn autoderef_(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> impl Iterator<Item = Ty<'db>> {
         let interner = DbInterner::new_with(db, None, None);
         // There should be no inference vars in types passed here
         let canonical = hir_ty::replace_errors_with_variables(interner, &self.ty);
         autoderef(db, self.env.clone(), canonical)
     }
 
-    // This would be nicer if it just returned an iterator, but that runs into
-    // lifetime problems, because we need to borrow temp `CrateImplDefs`.
     pub fn iterate_assoc_items<T>(
         &self,
         db: &'db dyn HirDatabase,
         callback: impl MethodCandidateCallback,
     ) {
         struct Callback<T>(T);
-
         impl<T: MethodCandidateCallback> method_resolution::MethodCandidateCallback for Callback<T> {
             fn on_inherent_method(
                 &mut self,
                 }
             }
         }
-
         let _p = tracing::info_span!(
             "iterate_method_candidates_dyn",
             with_local_impls = traits_in_scope.len(),
         let interner = DbInterner::new_with(db, None, None);
         // There should be no inference vars in types passed here
         let canonical = hir_ty::replace_errors_with_variables(interner, &self.ty);
-
         let krate = scope.krate();
         let environment = scope
             .resolver()
             .generic_def()
             .map_or_else(|| TraitEnvironment::empty(krate.id), |d| db.trait_environment(d));
-
         _ = method_resolution::iterate_method_candidates_dyn(
             &canonical,
             db,
     ) -> Option<T> {
         let _p = tracing::info_span!("iterate_path_candidates").entered();
         let mut slot = None;
-
         self.iterate_path_candidates_split_inherent(
             db,
             scope,
         callback: impl PathCandidateCallback,
     ) {
         struct Callback<T>(T);
-
         impl<T: PathCandidateCallback> method_resolution::MethodCandidateCallback for Callback<T> {
             fn on_inherent_method(
                 &mut self,
                 self.0.on_trait_item(item.into())
             }
         }
-
         let interner = DbInterner::new_with(db, None, None);
         let canonical = hir_ty::replace_errors_with_variables(interner, &self.ty);
-
         let krate = scope.krate();
         let environment = scope
             .resolver()
             .generic_def()
             .map_or_else(|| TraitEnvironment::empty(krate.id), |d| db.trait_environment(d));
-
         _ = method_resolution::iterate_path_candidates(
             &canonical,
             db,
             .map(Trait::from)
     }
 
-    pub fn env_traits(&self, db: &'db dyn HirDatabase) -> impl Iterator<Item = Trait> {
+    pub fn env_traits(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> impl Iterator<Item = Trait> {
         let _p = tracing::info_span!("env_traits").entered();
         self.autoderef_(db)
             .filter(|ty| matches!(ty.kind(), TyKind::Param(_)))
             .map(Trait::from)
     }
 
-    pub fn as_impl_traits(&self, db: &'db dyn HirDatabase) -> Option<impl Iterator<Item = Trait>> {
+    pub fn as_impl_traits(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<impl Iterator<Item = Trait>> {
         self.ty.impl_trait_bounds(db).map(|it| {
             it.into_iter().filter_map(|pred| match pred.kind().skip_binder() {
                 ClauseKind::Trait(trait_ref) => Some(Trait::from(trait_ref.def_id().0)),
         })
     }
 
-    pub fn as_associated_type_parent_trait(&self, db: &'db dyn HirDatabase) -> Option<Trait> {
+    pub fn as_associated_type_parent_trait(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<Trait> {
         let TyKind::Alias(AliasTyKind::Projection, alias) = self.ty.kind() else { return None };
         match alias.def_id.expect_type_alias().loc(db).container {
             ItemContainerId::TraitId(id) => Some(Trait { id }),
         }
     }
 
-    fn derived(&self, ty: Ty<'db>) -> Self {
+    fn derived(
+        &self,
+        ty: Ty<'db>,
+    ) -> Self {
         Type { env: self.env.clone(), ty }
     }
 
     /// Visits every type, including generic arguments, in this type. `callback` is called with type
     /// itself first, and then with its generic arguments.
-    pub fn walk(&self, db: &'db dyn HirDatabase, callback: impl FnMut(Type<'db>)) {
+    pub fn walk(
+        &self,
+        db: &'db dyn HirDatabase,
+        callback: impl FnMut(Type<'db>),
+    ) {
         struct Visitor<'db, F> {
             db: &'db dyn HirDatabase,
             env: Arc<TraitEnvironment<'db>>,
                 ty.super_visit_with(self);
             }
         }
-
         let mut visitor =
             Visitor { db, env: self.env.clone(), callback, visited: FxHashSet::default() };
         self.ty.visit_with(&mut visitor);
     }
+
     /// Check if type unifies with another type.
     ///
     /// Note that we consider placeholder types to unify with everything.
     /// For example `Option<T>` and `Option<U>` unify although there is unresolved goal `T = U`.
-    pub fn could_unify_with(&self, db: &'db dyn HirDatabase, other: &Type<'db>) -> bool {
+    pub fn could_unify_with(
+        &self,
+        db: &'db dyn HirDatabase,
+        other: &Type<'db>,
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let tys = hir_ty::replace_errors_with_variables(interner, &(self.ty, other.ty));
         hir_ty::could_unify(db, self.env.clone(), &tys)
     ///
     /// This means that placeholder types are not considered to unify if there are any bounds set on
     /// them. For example `Option<T>` and `Option<U>` do not unify as we cannot show that `T = U`
-    pub fn could_unify_with_deeply(&self, db: &'db dyn HirDatabase, other: &Type<'db>) -> bool {
+    pub fn could_unify_with_deeply(
+        &self,
+        db: &'db dyn HirDatabase,
+        other: &Type<'db>,
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let tys = hir_ty::replace_errors_with_variables(interner, &(self.ty, other.ty));
         hir_ty::could_unify_deeply(db, self.env.clone(), &tys)
     }
 
-    pub fn could_coerce_to(&self, db: &'db dyn HirDatabase, to: &Type<'db>) -> bool {
+    pub fn could_coerce_to(
+        &self,
+        db: &'db dyn HirDatabase,
+        to: &Type<'db>,
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let tys = hir_ty::replace_errors_with_variables(interner, &(self.ty, to.ty));
         hir_ty::could_coerce(db, self.env.clone(), &tys)
     }
 
-    pub fn as_type_param(&self, _db: &'db dyn HirDatabase) -> Option<TypeParam> {
+    pub fn as_type_param(
+        &self,
+        _db: &'db dyn HirDatabase,
+    ) -> Option<TypeParam> {
         match self.ty.kind() {
             TyKind::Param(param) => Some(TypeParam { id: param.id }),
             _ => None,
     }
 
     /// Returns unique `GenericParam`s contained in this type.
-    pub fn generic_params(&self, db: &'db dyn HirDatabase) -> FxHashSet<GenericParam> {
+    pub fn generic_params(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> FxHashSet<GenericParam> {
         hir_ty::collect_params(&self.ty)
             .into_iter()
             .map(|id| TypeOrConstParam { id }.split(db).either_into())
             .collect()
     }
 
-    pub fn layout(&self, db: &'db dyn HirDatabase) -> Result<Layout, LayoutError> {
+    pub fn layout(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Result<Layout, LayoutError> {
         db.layout_of_ty(self.ty, self.env.clone())
             .map(|layout| Layout(layout, db.target_data_layout(self.env.krate).unwrap()))
     }
 
-    pub fn drop_glue(&self, db: &'db dyn HirDatabase) -> DropGlue {
+    pub fn drop_glue(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> DropGlue {
         let interner = DbInterner::new_with(db, Some(self.env.krate), self.env.block);
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
         hir_ty::drop::has_drop_glue(&infcx, self.ty, self.env.clone())
 }
 
 impl<'db> TypeNs<'db> {
-    fn new(db: &'db dyn HirDatabase, lexical_env: impl HasResolver, ty: Ty<'db>) -> Self {
+    fn new(
+        db: &'db dyn HirDatabase,
+        lexical_env: impl HasResolver,
+        ty: Ty<'db>,
+    ) -> Self {
         let resolver = lexical_env.resolver(db);
         let environment = resolver
             .generic_def()
         TypeNs { env: environment, ty }
     }
 
-    pub fn to_type(&self, _db: &'db dyn HirDatabase) -> Type<'db> {
+    pub fn to_type(
+        &self,
+        _db: &'db dyn HirDatabase,
+    ) -> Type<'db> {
         Type { env: self.env.clone(), ty: self.ty }
     }
 
-    // FIXME: Find better API that also handles const generics
-    pub fn impls_trait(&self, infcx: InferCtxt<'db>, trait_: Trait, args: &[TypeNs<'db>]) -> bool {
+    pub fn impls_trait(
+        &self,
+        infcx: InferCtxt<'db>,
+        trait_: Trait,
+        args: &[TypeNs<'db>],
+    ) -> bool {
         let args = GenericArgs::new_from_iter(
             infcx.interner,
             [self.ty].into_iter().chain(args.iter().map(|t| t.ty)).map(|t| t.into()),
         );
         let trait_ref = hir_ty::next_solver::TraitRef::new(infcx.interner, trait_.id.into(), args);
-
         let pred_kind = rustc_type_ir::Binder::dummy(rustc_type_ir::PredicateKind::Clause(
             rustc_type_ir::ClauseKind::Trait(rustc_type_ir::TraitPredicate {
                 trait_ref,
 }
 
 impl InlineAsmOperand {
-    pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {
+    pub fn parent(
+        self,
+        _db: &dyn HirDatabase,
+    ) -> DefWithBody {
         self.owner.into()
     }
 
-    pub fn name(&self, db: &dyn HirDatabase) -> Option<Name> {
+    pub fn name(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<Name> {
         match &db.body(self.owner)[self.expr] {
             hir_def::hir::Expr::InlineAsm(e) => e.operands.get(self.index)?.0.clone(),
             _ => None,
     }
 }
 
-// FIXME: Document this
 #[derive(Debug)]
 pub struct Callable<'db> {
     ty: Type<'db>,
             Callee::FnImpl(fn_) => CallableKind::FnImpl(fn_),
         }
     }
-    pub fn receiver_param(&self, db: &'db dyn HirDatabase) -> Option<(SelfParam, Type<'db>)> {
+
+    pub fn receiver_param(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Option<(SelfParam, Type<'db>)> {
         let func = match self.callee {
             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,
             _ => return None,
             self.ty.derived(self.sig.skip_binder().inputs_and_output.inputs()[0]),
         ))
     }
+
     pub fn n_params(&self) -> usize {
         self.sig.skip_binder().inputs_and_output.inputs().len()
             - if self.is_bound_method { 1 } else { 0 }
     }
+
     pub fn params(&self) -> Vec<Param<'db>> {
         self.sig
             .skip_binder()
             .map(|(idx, ty)| Param { func: self.callee.clone(), idx, ty })
             .collect()
     }
+
     pub fn return_type(&self) -> Type<'db> {
         self.ty.derived(self.sig.skip_binder().output())
     }
+
     pub fn sig(&self) -> impl Eq {
         &self.sig
     }
         Some(self.0.largest_niche?.available(&*self.1))
     }
 
-    pub fn field_offset(&self, field: Field) -> Option<u64> {
+    pub fn field_offset(
+        &self,
+        field: Field,
+    ) -> Option<u64> {
         match self.0.fields {
             layout::FieldsShape::Primitive => None,
             layout::FieldsShape::Union(_) => Some(0),
         }
     }
 
-    pub fn tuple_field_offset(&self, field: usize) -> Option<u64> {
+    pub fn tuple_field_offset(
+        &self,
+        field: usize,
+    ) -> Option<u64> {
         match self.0.fields {
             layout::FieldsShape::Primitive => None,
             layout::FieldsShape::Union(_) => Some(0),
         }
     }
 
-    pub fn tail_padding(&self, field_size: &mut impl FnMut(usize) -> Option<u64>) -> Option<u64> {
+    pub fn tail_padding(
+        &self,
+        field_size: &mut impl FnMut(usize) -> Option<u64>,
+    ) -> Option<u64> {
         match self.0.fields {
             layout::FieldsShape::Primitive => None,
             layout::FieldsShape::Union(_) => None,
 impl ScopeDef {
     pub fn all_items(def: PerNs) -> ArrayVec<Self, 3> {
         let mut items = ArrayVec::new();
-
         match (def.take_types(), def.take_values()) {
             (Some(m1), None) => items.push(ScopeDef::ModuleDef(m1.into())),
             (None, Some(m2)) => items.push(ScopeDef::ModuleDef(m2.into())),
             }
             (None, None) => {}
         };
-
         if let Some(macro_def_id) = def.take_macros() {
             items.push(ScopeDef::ModuleDef(ModuleDef::Macro(macro_def_id.into())));
         }
-
         if items.is_empty() {
             items.push(ScopeDef::Unknown);
         }
-
         items
     }
 
-    pub fn attrs(&self, db: &dyn HirDatabase) -> Option<AttrsWithOwner> {
+    pub fn attrs(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<AttrsWithOwner> {
         match self {
             ScopeDef::ModuleDef(it) => it.attrs(db),
             ScopeDef::GenericParam(it) => Some(it.attrs(db)),
         }
     }
 
-    pub fn krate(&self, db: &dyn HirDatabase) -> Option<Crate> {
+    pub fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Option<Crate> {
         match self {
             ScopeDef::ModuleDef(it) => it.module(db).map(|m| m.krate()),
             ScopeDef::GenericParam(it) => Some(it.module(db).krate()),
 pub struct OverloadedDeref(pub Mutability);
 
 pub trait HasVisibility {
-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility;
-    fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {
+    fn visibility(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Visibility;
+
+    fn is_visible_from(
+        &self,
+        db: &dyn HirDatabase,
+        module: Module,
+    ) -> bool {
         let vis = self.visibility(db);
         vis.is_visible_from(db, module.id)
     }
 
 /// Trait for obtaining the defining crate of an item.
 pub trait HasCrate {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate;
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate;
 }
 
 impl<T: hir_def::HasModule> HasCrate for T {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate().into()
     }
 }
 
 impl HasCrate for AssocItem {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Struct {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Union {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Enum {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Field {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.parent_def(db).module(db).krate()
     }
 }
 
 impl HasCrate for Variant {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Function {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Const {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for TypeAlias {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Type<'_> {
-    fn krate(&self, _db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        _db: &dyn HirDatabase,
+    ) -> Crate {
         self.env.krate.into()
     }
 }
 
 impl HasCrate for Macro {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Trait {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Static {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Adt {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Impl {
-    fn krate(&self, db: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> Crate {
         self.module(db).krate()
     }
 }
 
 impl HasCrate for Module {
-    fn krate(&self, _: &dyn HirDatabase) -> Crate {
+    fn krate(
+        &self,
+        _: &dyn HirDatabase,
+    ) -> Crate {
         Module::krate(*self)
     }
 }
 
 pub trait HasContainer {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer;
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer;
 }
 
 impl HasContainer for ExternCrateDecl {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         container_id_to_hir(self.id.lookup(db).container.into())
     }
 }
 
 impl HasContainer for Module {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         // FIXME: handle block expressions as modules (their parent is in a different DefMap)
         let def_map = self.id.def_map(db);
         match def_map[self.id.local_id].parent {
 }
 
 impl HasContainer for Function {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         container_id_to_hir(self.id.lookup(db).container)
     }
 }
 
 impl HasContainer for Struct {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         ItemContainer::Module(Module { id: self.id.lookup(db).container })
     }
 }
 
 impl HasContainer for Union {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         ItemContainer::Module(Module { id: self.id.lookup(db).container })
     }
 }
 
 impl HasContainer for Enum {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         ItemContainer::Module(Module { id: self.id.lookup(db).container })
     }
 }
 
 impl HasContainer for TypeAlias {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         container_id_to_hir(self.id.lookup(db).container)
     }
 }
 
 impl HasContainer for Const {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         container_id_to_hir(self.id.lookup(db).container)
     }
 }
 
 impl HasContainer for Static {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         container_id_to_hir(self.id.lookup(db).container)
     }
 }
 
 impl HasContainer for Trait {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         ItemContainer::Module(Module { id: self.id.lookup(db).container })
     }
 }
 
 impl HasContainer for ExternBlock {
-    fn container(&self, db: &dyn HirDatabase) -> ItemContainer {
+    fn container(
+        &self,
+        db: &dyn HirDatabase,
+    ) -> ItemContainer {
         ItemContainer::Module(Module { id: self.id.lookup(db).container })
     }
 }
 }
 
 pub trait MethodCandidateCallback {
-    fn on_inherent_method(&mut self, f: Function) -> ControlFlow<()>;
+    fn on_inherent_method(
+        &mut self,
+        f: Function,
+    ) -> ControlFlow<()>;
 
-    fn on_trait_method(&mut self, f: Function) -> ControlFlow<()>;
+    fn on_trait_method(
+        &mut self,
+        f: Function,
+    ) -> ControlFlow<()>;
 }
 
 impl<F> MethodCandidateCallback for F
 where
-    F: FnMut(Function) -> ControlFlow<()>,
-{
-    fn on_inherent_method(&mut self, f: Function) -> ControlFlow<()> {
+    F: FnMut(Function) -> ControlFlow<()>, {
+    fn on_inherent_method(
+        &mut self,
+        f: Function,
+    ) -> ControlFlow<()> {
         self(f)
     }
 
-    fn on_trait_method(&mut self, f: Function) -> ControlFlow<()> {
+    fn on_trait_method(
+        &mut self,
+        f: Function,
+    ) -> ControlFlow<()> {
         self(f)
     }
 }
 
 pub trait PathCandidateCallback {
-    fn on_inherent_item(&mut self, item: AssocItem) -> ControlFlow<()>;
+    fn on_inherent_item(
+        &mut self,
+        item: AssocItem,
+    ) -> ControlFlow<()>;
 
-    fn on_trait_item(&mut self, item: AssocItem) -> ControlFlow<()>;
+    fn on_trait_item(
+        &mut self,
+        item: AssocItem,
+    ) -> ControlFlow<()>;
 }
 
 impl<F> PathCandidateCallback for F
 where
-    F: FnMut(AssocItem) -> ControlFlow<()>,
-{
-    fn on_inherent_item(&mut self, item: AssocItem) -> ControlFlow<()> {
+    F: FnMut(AssocItem) -> ControlFlow<()>, {
+    fn on_inherent_item(
+        &mut self,
+        item: AssocItem,
+    ) -> ControlFlow<()> {
         self(item)
     }
 
-    fn on_trait_item(&mut self, item: AssocItem) -> ControlFlow<()> {
+    fn on_trait_item(
+        &mut self,
+        item: AssocItem,
+    ) -> ControlFlow<()> {
         self(item)
     }
 }
     })
 }
 
-fn has_non_default_type_params(db: &dyn HirDatabase, generic_def: GenericDefId) -> bool {
+fn has_non_default_type_params(
+    db: &dyn HirDatabase,
+    generic_def: GenericDefId,
+) -> bool {
     let params = db.generic_params(generic_def);
     let defaults = db.generic_defaults(generic_def);
     params
             defaults.get(param).is_none()
         })
 }
-
-pub use hir_ty::next_solver;
-pub use hir_ty::setup_tracing;