COMPARISON DIFF
============================================================

Original size: 227843 bytes
Chloro size:   223745 bytes
Rustfmt size:  227843 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 #![recursion_limit = "512"]
 
-extern crate ra_ap_rustc_type_ir as rustc_type_ir;
 
 mod attrs;
 mod from_id;
 mod has_source;
 mod semantics;
 mod source_analyzer;
-
 pub mod db;
 pub mod diagnostics;
 pub mod symbols;
 pub mod term_search;
-
 mod display;
 
-#[doc(hidden)]
-pub use hir_def::ModuleId;
-
 use std::{
     fmt,
     mem::discriminant,
 use arrayvec::ArrayVec;
 use base_db::{CrateDisplayName, CrateOrigin, LangCrateOrigin};
 use either::Either;
+pub use hir_def::ModuleId;
 use hir_def::{
-    AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
-    CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
-    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
-    LocalFieldId, Lookup, MacroExpander, MacroId, StaticId, StructId, SyntheticSyntax, TupleId,
-    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,
     expr_store::{ExpressionStoreDiagnostics, ExpressionStoreSourceMap},
     hir::{
-        BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, LabelId, Pat,
         generics::{LifetimeParamData, TypeOrConstParamData, TypeParamProvenance},
+        BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, LabelId, Pat,
     },
     item_tree::ImportAlias,
     layout::{self, ReprOptions, TargetDataLayout},
-    nameres::{
-        assoc::TraitItems,
-        diagnostics::{DefDiagnostic, DefDiagnosticKind},
-    },
+    nameres::{assoc::TraitItems, diagnostics::{DefDiagnostic, DefDiagnosticKind}},
     per_ns::PerNs,
     resolver::{HasResolver, Resolver},
     signatures::{ImplFlags, StaticFlags, StructFlags, TraitFlags, VariantFields},
     src::HasSource as _,
     visibility::visibility_from_ast,
+    AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
+    CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
+    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
+    LocalFieldId, Lookup, MacroExpander, MacroId, StaticId, StructId, SyntheticSyntax, TupleId,
+    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,
 };
 use hir_expand::{
-    AstId, MacroCallKind, RenderedExpandError, ValueResult, attrs::collect_attrs,
-    proc_macro::ProcMacroKind,
+    attrs::collect_attrs, proc_macro::ProcMacroKind, AstId, MacroCallKind, RenderedExpandError,
+    ValueResult,
 };
+pub use hir_ty::next_solver;
+pub use hir_ty::setup_tracing;
 use hir_ty::{
-    TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId, all_super_traits, autoderef,
-    check_orphan_rules,
+    all_super_traits, autoderef, check_orphan_rules,
     consteval::try_const_usize,
     db::{InternedClosureId, InternedCoroutineId},
     diagnostics::BodyValidationDiagnostic,
     direct_super_traits, known_const_to_ast,
     layout::{Layout as TyLayout, RustcEnumVariantIdx, RustcFieldIdx, TagEncoding},
     method_resolution,
-    mir::{MutBorrowKind, interpret_mir},
+    mir::{interpret_mir, MutBorrowKind},
     next_solver::{
-        AliasTy, Canonical, ClauseKind, ConstKind, DbInterner, ErrorGuaranteed, GenericArg,
-        GenericArgs, PolyFnSig, Region, SolverDefId, Ty, TyKind, TypingMode,
-        infer::{DbInternerInferExt, InferCtxt},
+        infer::{DbInternerInferExt, InferCtxt}, AliasTy, Canonical, ClauseKind, ConstKind,
+        DbInterner, ErrorGuaranteed, GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Ty,
+        TyKind, TypingMode,
     },
-    traits::{self, FnTrait, structurally_normalize_ty},
+    traits::{self, structurally_normalize_ty, FnTrait},
+    TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId,
 };
 use itertools::Itertools;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
-    AliasTyKind, TypeSuperVisitable, TypeVisitable, TypeVisitor,
     inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _},
+    AliasTyKind, TypeSuperVisitable, TypeVisitable, TypeVisitor,
 };
 use smallvec::SmallVec;
 use span::{AstIdNode, Edition, FileId};
 use stdx::{format_to, impl_from, never};
 use syntax::{
-    AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, T, TextRange, ToSmolStr,
     ast::{self, HasAttrs as _, HasName, HasVisibility as _},
-    format_smolstr,
+    format_smolstr, AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, TextRange, ToSmolStr, T,
 };
 use triomphe::{Arc, ThinArc};
-
-use crate::db::{DefDatabase, HirDatabase};
-
-pub use crate::{
-    attrs::{HasAttrs, resolve_doc_path_on},
-    diagnostics::*,
-    has_source::HasSource,
-    semantics::{
-        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
-        VisibleTraits,
-    },
-};
-
-// Be careful with these re-exports.
-//
-// `hir` is the boundary between the compiler and the IDE. It should try hard to
-// isolate the compiler from the ide, to allow the two to be refactored
-// independently. Re-exporting something from the compiler is the sure way to
-// breach the boundary.
-//
-// Generally, a refactoring which *removes* a name from this list is a good
-// idea!
 pub use {
     cfg::{CfgAtom, CfgExpr, CfgOptions},
     hir_def::{
-        Complete,
-        FindPathConfig,
-        attr::{AttrSourceMap, Attrs, AttrsWithOwner},
-        find_path::PrefixKind,
-        import_map,
-        lang_item::LangItem,
-        nameres::{DefMap, ModuleSource, crate_def_map},
-        per_ns::Namespace,
-        type_ref::{Mutability, TypeRef},
-        visibility::Visibility,
+        attr::{AttrSourceMap, Attrs, AttrsWithOwner}, find_path::PrefixKind, import_map,
+        lang_item::LangItem, nameres::{DefMap, ModuleSource, crate_def_map}, per_ns::Namespace,
+        type_ref::{Mutability, TypeRef}, visibility::Visibility,
         // FIXME: This is here since some queries take it as input that are used
         // outside of hir.
         {ModuleDefId, TraitId},
+        Complete, FindPathConfig,
     },
     hir_expand::{
-        EditionedFileId, ExpandResult, HirFileId, MacroCallId, MacroKind,
-        attrs::{Attr, AttrId},
-        change::ChangeWithProcMacros,
+        attrs::{Attr, AttrId}, change::ChangeWithProcMacros,
         files::{
             FilePosition, FilePositionWrapper, FileRange, FileRangeWrapper, HirFilePosition,
             HirFileRange, InFile, InFileWrapper, InMacroFile, InRealFile, MacroFilePosition,
             MacroFileRange,
         },
-        inert_attr_macro::AttributeTemplate,
-        mod_path::{ModPath, PathKind, tool_path},
-        name::Name,
-        prettify_macro_expansion,
-        proc_macro::{ProcMacros, ProcMacrosBuilder},
-        tt,
+        inert_attr_macro::AttributeTemplate, mod_path::{ModPath, PathKind, tool_path}, name::Name,
+        prettify_macro_expansion, proc_macro::{ProcMacros, ProcMacrosBuilder}, tt,
+        EditionedFileId, ExpandResult, HirFileId, MacroCallId, MacroKind,
     },
+    hir_ty::{
+        attach_db, attach_db_allow_change, consteval::ConstEvalError, diagnostics::UnsafetyReason,
+        display::{ClosureStyle, DisplayTarget, HirDisplay, HirDisplayError, HirWrite},
+        drop::DropGlue, dyn_compatibility::{DynCompatibilityViolation, MethodViolationCode},
+        layout::LayoutError, method_resolution::TyFingerprint, mir::{MirEvalError, MirLowerError},
+        next_solver::abi::Safety, next_solver::clear_tls_solver_cache, CastError, FnAbi,
+        PointerCast,
+    },
+    intern::{sym, Symbol},
     // FIXME: Properly encapsulate mir
     hir_ty::mir,
-    hir_ty::{
-        CastError, FnAbi, PointerCast, attach_db, attach_db_allow_change,
-        consteval::ConstEvalError,
-        diagnostics::UnsafetyReason,
-        display::{ClosureStyle, DisplayTarget, HirDisplay, HirDisplayError, HirWrite},
-        drop::DropGlue,
-        dyn_compatibility::{DynCompatibilityViolation, MethodViolationCode},
-        layout::LayoutError,
-        method_resolution::TyFingerprint,
-        mir::{MirEvalError, MirLowerError},
-        next_solver::abi::Safety,
-        next_solver::clear_tls_solver_cache,
-    },
-    intern::{Symbol, sym},
 };
-
-// These are negative re-exports: pub using these names is forbidden, they
-// should remain private to hir internals.
-#[allow(unused)]
 use {
     hir_def::expr_store::path::Path,
-    hir_expand::{
-        name::AsName,
-        span_map::{ExpansionSpanMap, RealSpanMap, SpanMap, SpanMapRef},
+    hir_expand::{name::AsName, span_map::{ExpansionSpanMap, RealSpanMap, SpanMap, SpanMapRef}},
+};
+
+use crate::db::{DefDatabase, HirDatabase};
+pub use crate::{
+    attrs::{resolve_doc_path_on, HasAttrs},
+    diagnostics::*,
+    has_source::HasSource,
+    semantics::{
+        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
+        VisibleTraits,
     },
 };
 
     }
 
     pub fn dependencies(self, db: &dyn HirDatabase) -> Vec<CrateDependency> {
-        self.id
-            .data(db)
-            .dependencies
-            .iter()
-            .map(|dep| {
-                let krate = Crate { id: dep.crate_id };
-                let name = dep.as_name();
-                CrateDependency { krate, name }
-            })
-            .collect()
+        self.id.data(db).dependencies.iter().map(|dep| {
+            let krate = Crate { id: dep.crate_id };
+            let name = dep.as_name();
+            CrateDependency { krate, name }
+        }).collect(
+        )
     }
 
     pub fn reverse_dependencies(self, db: &dyn HirDatabase) -> Vec<Crate> {
         let all_crates = db.all_crates();
-        all_crates
-            .iter()
-            .copied()
-            .filter(|&krate| krate.data(db).dependencies.iter().any(|it| it.crate_id == self.id))
-            .map(|id| Crate { id })
-            .collect()
+        all_crates.iter().copied().filter(
+            |&krate| krate.data(db).dependencies.iter().any(|it| it.crate_id == self.id),
+        ).map(
+            |id| Crate { id },
+        ).collect(
+        )
     }
 
     pub fn transitive_reverse_dependencies(
         query: import_map::Query,
     ) -> impl Iterator<Item = (Either<ModuleDef, Macro>, Complete)> {
         let _p = tracing::info_span!("query_external_importables").entered();
-        import_map::search_dependencies(db, self.into(), &query).into_iter().map(
-            |(item, do_not_complete)| {
-                let item = match ItemInNs::from(item) {
+        import_map::search_dependencies(db, self.into(), &query).into_iter().map(|(item, do_not_complete)| {
+            let item = match ItemInNs::from(item) {
                     ItemInNs::Types(mod_id) | ItemInNs::Values(mod_id) => Either::Left(mod_id),
                     ItemInNs::Macros(mac_id) => Either::Right(mac_id),
                 };
-                (item, do_not_complete)
-            },
-        )
+            (item, do_not_complete)
+        })
     }
 
     pub fn all(db: &dyn HirDatabase) -> Vec<Crate> {
     }
 
     fn core(db: &dyn HirDatabase) -> Option<Crate> {
-        db.all_crates()
-            .iter()
-            .copied()
-            .find(|&krate| {
-                matches!(krate.data(db).origin, CrateOrigin::Lang(LangCrateOrigin::Core))
-            })
-            .map(Crate::from)
+        db.all_crates().iter().copied().find(|&krate| {
+            matches!(krate.data(db).origin, CrateOrigin::Lang(LangCrateOrigin::Core))
+        }).map(
+            Crate::from,
+        )
     }
 }
 
     BuiltinType(BuiltinType),
     Macro(Macro),
 }
+
 impl_from!(
     Module,
     Function,
             ModuleDef::Const(it) => Some(it.into()),
             ModuleDef::Static(it) => Some(it.into()),
             ModuleDef::Variant(it) => Some(it.into()),
-
             ModuleDef::Module(_)
             | ModuleDef::Adt(_)
             | ModuleDef::Trait(_)
         db: &dyn HirDatabase,
         visible_from: Option<Module>,
     ) -> Vec<(Name, ScopeDef)> {
-        self.id.def_map(db)[self.id.local_id]
-            .scope
-            .entries()
-            .filter_map(|(name, def)| {
-                if let Some(m) = visible_from {
-                    let filtered = def.filter_visibility(|vis| vis.is_visible_from(db, m.id));
-                    if filtered.is_none() && !def.is_none() { None } else { Some((name, filtered)) }
+        self.id.def_map(db)[self.id.local_id].scope.entries().filter_map(|(name, def)| {
+            if let Some(m) = visible_from {
+                let filtered = def.filter_visibility(|vis| vis.is_visible_from(db, m.id));
+                if filtered.is_none() && !def.is_none() {
+                    None
                 } else {
-                    Some((name, def))
+                    Some((name, filtered))
                 }
-            })
-            .flat_map(|(name, def)| {
-                ScopeDef::all_items(def).into_iter().map(move |item| (name.clone(), item))
-            })
-            .collect()
+            } else {
+                Some((name, def))
+            }
+        }).flat_map(|(name, def)| {
+            ScopeDef::all_items(def).into_iter().map(move |item| (name.clone(), item))
+        }).collect(
+        )
     }
 
     pub fn resolve_mod_path(
         let mut impl_assoc_items_scratch = vec![];
         for impl_def in self.impl_defs(db) {
             GenericDef::Impl(impl_def).diagnostics(db, acc);
-
             let loc = impl_def.id.lookup(db);
             let (impl_signature, source_map) = db.impl_signature_with_source_map(impl_def.id);
             expr_store_diagnostics(db, acc, &source_map);
-
             let file_id = loc.id.file_id;
             if file_id.macro_file().is_some_and(|it| it.kind(db) == MacroKind::DeriveBuiltIn) {
                 // these expansion come from us, diagnosing them is a waste of resources
                 .all_macro_calls(db)
                 .iter()
                 .for_each(|&(_ast, call_id)| macro_call_diagnostics(db, call_id, acc));
-
             let ast_id_map = db.ast_id_map(file_id);
-
             for diag in impl_def.id.impl_items_with_diagnostics(db).1.iter() {
                 emit_def_diagnostic(db, acc, diag, edition);
             }
-
             if inherent_impls.invalid_impls().contains(&impl_def.id) {
                 acc.push(IncoherentImpl { impl_: ast_id_map.get(loc.id.value), file_id }.into())
             }
-
             if !impl_def.check_orphan_rules(db) {
                 acc.push(TraitImplOrphan { impl_: ast_id_map.get(loc.id.value), file_id }.into())
             }
-
             let trait_ = impl_def.trait_(db);
             let mut trait_is_unsafe = trait_.is_some_and(|t| t.is_unsafe(db));
             let impl_is_negative = impl_def.is_negative(db);
             let impl_is_unsafe = impl_def.is_unsafe(db);
-
             let trait_is_unresolved = trait_.is_none() && impl_signature.target_trait.is_some();
             if trait_is_unresolved {
                 // Ignore trait safety errors when the trait is unresolved, as otherwise we'll treat it as safe,
                 // which may not be correct.
                 trait_is_unsafe = impl_is_unsafe;
             }
-
             let drop_maybe_dangle = (|| {
                 // FIXME: This can be simplified a lot by exposing hir-ty's utils.rs::Generics helper
                 let trait_ = trait_?;
                 Some(res)
             })()
             .unwrap_or(false);
-
             match (impl_is_unsafe, trait_is_unsafe, impl_is_negative, drop_maybe_dangle) {
                 // unsafe negative impl
                 (true, _, true, _) |
                 (false, false, _, true) => acc.push(TraitImplIncorrectSafety { impl_: ast_id_map.get(loc.id.value), file_id, should_be_safe: false }.into()),
                 _ => (),
             };
-
-            // Negative impls can't have items, don't emit missing items diagnostic for them
             if let (false, Some(trait_)) = (impl_is_negative, trait_) {
                 let items = &trait_.id.trait_items(db).items;
                 let required_items = items.iter().filter(|&(_, assoc)| match *assoc {
                 }
                 impl_assoc_items_scratch.clear();
             }
-
             push_ty_diagnostics(
                 db,
                 acc,
                 db.impl_trait_with_diagnostics(impl_def.id).and_then(|it| it.1),
                 &source_map,
             );
-
             for &(_, item) in impl_def.id.impl_items(db).items.iter() {
                 AssocItem::from(item).diagnostics(db, acc, style_lints);
             }
     pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {
         let def_map = self.id.def_map(db);
         let scope = &def_map[self.id.local_id].scope;
-        scope
-            .declarations()
-            .map(ModuleDef::from)
-            .chain(scope.unnamed_consts().map(|id| ModuleDef::Const(Const::from(id))))
-            .collect()
+        scope.declarations().map(ModuleDef::from).chain(
+            scope.unnamed_consts().map(|id| ModuleDef::Const(Const::from(id))),
+        ).collect(
+        )
     }
 
     pub fn legacy_macros(self, db: &dyn HirDatabase) -> Vec<Macro> {
     m: Macro,
 ) {
     let id = db.macro_def(m.id);
-    if let hir_expand::db::TokenExpander::DeclarativeMacro(expander) = db.macro_expander(id)
-        && let Some(e) = expander.mac.err()
-    {
+    if let hir_expand::db::TokenExpander::DeclarativeMacro(expander) = db.macro_expander(id) && let Some(e) = expander.mac.err() {
         let Some(ast) = id.ast_id().left() else {
             never!("declarative expander for non decl-macro: {:?}", e);
             return;
     match diag {
         DefDiagnosticKind::UnresolvedModule { ast: declaration, candidates } => {
             let decl = declaration.to_ptr(db);
-            acc.push(
-                UnresolvedModule {
-                    decl: InFile::new(declaration.file_id, decl),
-                    candidates: candidates.clone(),
-                }
-                .into(),
-            )
-        }
+            acc.push(UnresolvedModule {
+                decl: InFile::new(declaration.file_id, decl),
+                candidates: candidates.clone(),
+            }.into(
+            ))
+        },
         DefDiagnosticKind::UnresolvedExternCrate { ast } => {
             let item = ast.to_ptr(db);
             acc.push(UnresolvedExternCrate { decl: InFile::new(ast.file_id, item) }.into());
-        }
-
+        },
         DefDiagnosticKind::MacroError { ast, path, err } => {
             let item = ast.to_ptr(db);
             let RenderedExpandError { message, error, kind } = err.render_to_string(db);
                 }
                 .into(),
             )
-        }
+        },
         DefDiagnosticKind::UnresolvedImport { id, index } => {
             let file_id = id.file_id;
-
             let use_tree = hir_def::src::use_tree_to_ast(db, *id, *index);
             acc.push(
                 UnresolvedImport { decl: InFile::new(file_id, AstPtr::new(&use_tree)) }.into(),
             );
-        }
-
+        },
         DefDiagnosticKind::UnconfiguredCode { ast_id, cfg, opts } => {
             let ast_id_map = db.ast_id_map(ast_id.file_id);
             let ptr = ast_id_map.get_erased(ast_id.value);
                 }
                 .into(),
             );
-        }
+        },
         DefDiagnosticKind::UnresolvedMacroCall { ast, path } => {
             let (node, precise_location) = precise_macro_call_location(ast, db);
             acc.push(
                 }
                 .into(),
             );
-        }
+        },
         DefDiagnosticKind::UnimplementedBuiltinMacro { ast } => {
             let node = ast.to_node(db);
-            // Must have a name, otherwise we wouldn't emit it.
             let name = node.name().expect("unimplemented builtin macro with no name");
             acc.push(
                 UnimplementedBuiltinMacro {
                 }
                 .into(),
             );
-        }
+        },
         DefDiagnosticKind::InvalidDeriveTarget { ast, id } => {
             let node = ast.to_node(db);
             let derive = node.attrs().nth(*id);
                         }
                         .into(),
                     );
-                }
+                },
                 None => stdx::never!("derive diagnostic on item without derive attribute"),
             }
-        }
+        },
         DefDiagnosticKind::MalformedDerive { ast, id } => {
             let node = ast.to_node(db);
             let derive = node.attrs().nth(*id);
                         }
                         .into(),
                     );
-                }
+                },
                 None => stdx::never!("derive diagnostic on item without derive attribute"),
             }
-        }
+        },
         DefDiagnosticKind::MacroDefError { ast, message } => {
             let node = ast.to_node(db);
             acc.push(
                 }
                 .into(),
             );
-        }
+        },
     }
 }
 
             let node = ast_id.to_node(db);
             (
                 ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),
-                node.path()
-                    .and_then(|it| it.segment())
-                    .and_then(|it| it.name_ref())
-                    .map(|it| it.syntax().text_range()),
+                node.path().and_then(|it| it.segment()).and_then(|it| it.name_ref()).map(
+                |it| it.syntax().text_range(),
+            ),
             )
-        }
+        },
         MacroCallKind::Derive { ast_id, derive_attr_index, derive_index, .. } => {
             let node = ast_id.to_node(db);
-            // Compute the precise location of the macro name's token in the derive
-            // list.
             let token = (|| {
                 let derive_attr = collect_attrs(&node)
                     .nth(derive_attr_index.ast_index())
                 ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),
                 token.as_ref().map(|tok| tok.text_range()),
             )
-        }
+        },
         MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {
             let node = ast_id.to_node(db);
             let attr = collect_attrs(&node)
                 .unwrap_or_else(|| {
                     panic!("cannot find attribute #{}", invoc_attr_index.ast_index())
                 });
-
             (
                 ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),
                 Some(attr.syntax().text_range()),
             )
-        }
+        },
     }
 }
 
         TypeNs::new(db, var_id, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
         db.layout_of_ty(
             self.ty(db).ty,
             db.trait_environment(match hir_def::VariantId::from(self.parent) {
-                hir_def::VariantId::EnumVariantId(id) => {
-                    GenericDefId::AdtId(id.lookup(db).parent.into())
-                }
-                hir_def::VariantId::StructId(id) => GenericDefId::AdtId(id.into()),
-                hir_def::VariantId::UnionId(id) => GenericDefId::AdtId(id.into()),
-            }),
+            hir_def::VariantId::EnumVariantId(id) => {
+                GenericDefId::AdtId(id.lookup(db).parent.into())
+            },
+            hir_def::VariantId::StructId(id) => GenericDefId::AdtId(id.into()),
+            hir_def::VariantId::UnionId(id) => GenericDefId::AdtId(id.into()),
+        }),
+        ).map(
+            |layout| Layout(layout, db.target_data_layout(self.krate(db).into()).unwrap()),
         )
-        .map(|layout| Layout(layout, db.target_data_layout(self.krate(db).into()).unwrap()))
     }
 
     pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {
     }
 
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
-        self.id
-            .fields(db)
-            .fields()
-            .iter()
-            .map(|(id, _)| Field { parent: self.into(), id })
-            .collect()
+        self.id.fields(db).fields().iter().map(|(id, _)| Field { parent: self.into(), id }).collect(
+        )
     }
 
     pub fn ty(self, db: &dyn HirDatabase) -> Type<'_> {
 
 impl<'db> InstantiatedStruct<'db> {
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<InstantiatedField<'db>> {
-        self.inner
-            .id
-            .fields(db)
-            .fields()
-            .iter()
-            .map(|(id, _)| InstantiatedField {
-                inner: Field { parent: self.inner.into(), id },
-                args: self.args,
-            })
-            .collect()
+        self.inner.id.fields(db).fields().iter().map(|(id, _)| InstantiatedField {
+            inner: Field { parent: self.inner.into(), id },
+            args: self.args,
+        }).collect(
+        )
     }
 
     pub fn ty(self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
     }
 
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
-        self.id
-            .fields(db)
-            .fields()
-            .iter()
-            .map(|(id, _)| Field { parent: self.into(), id })
-            .collect()
+        self.id.fields(db).fields().iter().map(|(id, _)| Field { parent: self.into(), id }).collect(
+        )
     }
+
     pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
         Type::new_for_crate(
             self.id.lookup(db).container.krate(),
             match db.enum_signature(self.id).variant_body_type() {
-                layout::IntegerType::Pointer(sign) => match sign {
-                    true => Ty::new_int(interner, rustc_type_ir::IntTy::Isize),
-                    false => Ty::new_uint(interner, rustc_type_ir::UintTy::Usize),
-                },
-                layout::IntegerType::Fixed(i, sign) => match sign {
-                    true => Ty::new_int(
-                        interner,
-                        match i {
-                            layout::Integer::I8 => rustc_type_ir::IntTy::I8,
-                            layout::Integer::I16 => rustc_type_ir::IntTy::I16,
-                            layout::Integer::I32 => rustc_type_ir::IntTy::I32,
-                            layout::Integer::I64 => rustc_type_ir::IntTy::I64,
-                            layout::Integer::I128 => rustc_type_ir::IntTy::I128,
-                        },
-                    ),
-                    false => Ty::new_uint(
-                        interner,
-                        match i {
-                            layout::Integer::I8 => rustc_type_ir::UintTy::U8,
-                            layout::Integer::I16 => rustc_type_ir::UintTy::U16,
-                            layout::Integer::I32 => rustc_type_ir::UintTy::U32,
-                            layout::Integer::I64 => rustc_type_ir::UintTy::U64,
-                            layout::Integer::I128 => rustc_type_ir::UintTy::U128,
-                        },
-                    ),
-                },
+            layout::IntegerType::Pointer(sign) => match sign {
+                true => Ty::new_int(interner, rustc_type_ir::IntTy::Isize),
+                false => Ty::new_uint(interner, rustc_type_ir::UintTy::Usize),
             },
+            layout::IntegerType::Fixed(i, sign) => match sign {
+                true => Ty::new_int(
+                    interner,
+                    match i {
+                    layout::Integer::I8 => rustc_type_ir::IntTy::I8,
+                    layout::Integer::I16 => rustc_type_ir::IntTy::I16,
+                    layout::Integer::I32 => rustc_type_ir::IntTy::I32,
+                    layout::Integer::I64 => rustc_type_ir::IntTy::I64,
+                    layout::Integer::I128 => rustc_type_ir::IntTy::I128,
+                },
+                ),
+                false => Ty::new_uint(
+                    interner,
+                    match i {
+                    layout::Integer::I8 => rustc_type_ir::UintTy::U8,
+                    layout::Integer::I16 => rustc_type_ir::UintTy::U16,
+                    layout::Integer::I32 => rustc_type_ir::UintTy::U32,
+                    layout::Integer::I64 => rustc_type_ir::UintTy::U64,
+                    layout::Integer::I128 => rustc_type_ir::UintTy::U128,
+                },
+                ),
+            },
+        },
         )
     }
 
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Variant {
     pub(crate) id: EnumVariantId,
     }
 
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
-        self.id
-            .fields(db)
-            .fields()
-            .iter()
-            .map(|(id, _)| Field { parent: self.into(), id })
-            .collect()
+        self.id.fields(db).fields().iter().map(|(id, _)| Field { parent: self.into(), id }).collect(
+        )
     }
 
     pub fn kind(self, db: &dyn HirDatabase) -> StructKind {
         Ok(match &parent_layout.0.variants {
             layout::Variants::Multiple { variants, .. } => Layout(
                 {
-                    let lookup = self.id.lookup(db);
-                    let rustc_enum_variant_idx = RustcEnumVariantIdx(lookup.index as usize);
-                    Arc::new(variants[rustc_enum_variant_idx].clone())
-                },
+                let lookup = self.id.lookup(db);
+                let rustc_enum_variant_idx = RustcEnumVariantIdx(lookup.index as usize);
+                Arc::new(variants[rustc_enum_variant_idx].clone())
+            },
                 db.target_data_layout(parent_enum.krate(db).into()).unwrap(),
             ),
             _ => parent_layout,
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct InstantiatedVariant<'db> {
     pub(crate) inner: Variant,
 
 impl<'db> InstantiatedVariant<'db> {
     pub fn parent_enum(self, db: &dyn HirDatabase) -> InstantiatedEnum<'db> {
-        InstantiatedEnum { inner: self.inner.id.lookup(db).parent.into(), args: self.args }
+        InstantiatedEnum {
+            inner: self.inner.id.lookup(db).parent.into(),
+            args: self.args,
+        }
     }
 
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<InstantiatedField<'db>> {
-        self.inner
-            .id
-            .fields(db)
-            .fields()
-            .iter()
-            .map(|(id, _)| InstantiatedField {
-                inner: Field { parent: self.inner.into(), id },
-                args: self.args,
-            })
-            .collect()
+        self.inner.id.fields(db).fields().iter().map(|(id, _)| InstantiatedField {
+            inner: Field { parent: self.inner.into(), id },
+            args: self.args,
+        }).collect(
+        )
     }
 }
 
     Union(Union),
     Enum(Enum),
 }
+
 impl_from!(Struct, Union, Enum for Adt);
 
 impl Adt {
         let args = GenericArgs::for_item_with_defaults(interner, adt_id.into(), |_, id, _| {
             GenericArg::error_from_id(interner, id)
         });
-        db.layout_of_adt(adt_id, args, env)
-            .map(|layout| Layout(layout, db.target_data_layout(self.krate(db).id).unwrap()))
+        db.layout_of_adt(adt_id, args, env).map(
+            |layout| Layout(layout, db.target_data_layout(self.krate(db).id).unwrap()),
+        )
     }
 
     /// Turns this ADT into a type. Any type parameters of the ADT will be
             Adt::Union(u) => u.id.resolver(db),
             Adt::Enum(e) => e.id.resolver(db),
         };
-        resolver
-            .generic_params()
-            .and_then(|gp| {
-                gp.iter_lt()
-                    // there should only be a single lifetime
-                    // but `Arena` requires to use an iterator
-                    .nth(0)
-            })
-            .map(|arena| arena.1.clone())
+        resolver.generic_params().and_then(|gp| {
+            gp.iter_lt().nth(0)
+        }).map(
+            |arena| arena.1.clone(),
+        )
     }
 
     pub fn as_struct(&self) -> Option<Struct> {
-        if let Self::Struct(v) = self { Some(*v) } else { None }
+        if let Self::Struct(v) = self {
+            Some(*v)
+        } else {
+            None
+        }
     }
 
     pub fn as_enum(&self) -> Option<Enum> {
-        if let Self::Enum(v) = self { Some(*v) } else { None }
+        if let Self::Enum(v) = self {
+            Some(*v)
+        } else {
+            None
+        }
     }
 }
 
     Union(Union),
     Variant(Variant),
 }
+
 impl_from!(Struct, Union, Variant for VariantDef);
 
 impl VariantDef {
     Const(Const),
     Variant(Variant),
 }
+
 impl_from!(Function, Const, Static, Variant for DefWithBody);
 
 impl DefWithBody {
         .macro_calls()
         .for_each(|(_ast_id, call_id)| macro_call_diagnostics(db, call_id, acc));
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Function {
     pub(crate) id: FunctionId,
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ret_type_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
         let callable_sig =
             db.callable_item_signature(self.id.into()).instantiate_identity().skip_binder();
-        callable_sig
-            .inputs()
-            .iter()
-            .enumerate()
-            .map(|(idx, ty)| {
-                let ty = Type { env: environment.clone(), ty };
-                Param { func: Callee::Def(CallableDefId::FunctionId(self.id)), ty, idx }
-            })
-            .collect()
+        callable_sig.inputs().iter().enumerate().map(|(idx, ty)| {
+            let ty = Type { env: environment.clone(), ty };
+            Param { func: Callee::Def(CallableDefId::FunctionId(self.id)), ty, idx }
+        }).collect(
+        )
     }
 
     pub fn num_params(self, db: &dyn HirDatabase) -> usize {
         let callable_sig =
             db.callable_item_signature(self.id.into()).instantiate_identity().skip_binder();
         let skip = if db.function_signature(self.id).has_self_param() { 1 } else { 0 };
-        callable_sig
-            .inputs()
-            .iter()
-            .enumerate()
-            .skip(skip)
-            .map(|(idx, ty)| {
-                let ty = Type { env: environment.clone(), ty };
-                Param { func: Callee::Def(CallableDefId::FunctionId(self.id)), ty, idx }
-            })
-            .collect()
+        callable_sig.inputs().iter().enumerate().skip(skip).map(|(idx, ty)| {
+            let ty = Type { env: environment.clone(), ty };
+            Param { func: Callee::Def(CallableDefId::FunctionId(self.id)), ty, idx }
+        }).collect(
+        )
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn params_without_self_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
         let callable_sig =
             db.callable_item_signature(self.id.into()).instantiate(interner, args).skip_binder();
         let skip = if db.function_signature(self.id).has_self_param() { 1 } else { 0 };
-        callable_sig
-            .inputs()
-            .iter()
-            .enumerate()
-            .skip(skip)
-            .map(|(idx, ty)| {
-                let ty = Type { env: environment.clone(), ty };
-                Param { func: Callee::Def(CallableDefId::FunctionId(self.id)), ty, idx }
-            })
-            .collect()
+        callable_sig.inputs().iter().enumerate().skip(skip).map(|(idx, ty)| {
+            let ty = Type { env: environment.clone(), ty };
+            Param { func: Callee::Def(CallableDefId::FunctionId(self.id)), ty, idx }
+        }).collect(
+        )
     }
 
     pub fn is_const(self, db: &dyn HirDatabase) -> bool {
         };
 
         let mut has_impl_future = false;
-        impl_traits
-            .filter(|t| {
-                let fut = t.id == future_trait_id;
-                has_impl_future |= fut;
-                !fut && t.id != sized_trait_id
-            })
-            // all traits but the future trait must be auto traits
-            .all(|t| t.is_auto(db))
-            && has_impl_future
+        impl_traits.filter(|t| {
+            let fut = t.id == future_trait_id;
+            has_impl_future |= fut;
+            !fut && t.id != sized_trait_id
+        }).all(
+            |t| t.is_auto(db),
+        ) && has_impl_future
     }
 
     /// Does this function have `#[test]` attribute?
 
     /// is this a `fn main` or a function with an `export_name` of `main`?
     pub fn is_main(self, db: &dyn HirDatabase) -> bool {
-        db.attrs(self.id.into()).export_name() == Some(&sym::main)
-            || self.module(db).is_crate_root() && db.function_signature(self.id).name == sym::main
+        db.attrs(self.id.into()).export_name() == Some(&sym::main) || self.module(db).is_crate_root() && db.function_signature(self.id).name == sym::main
     }
 
     /// Is this a function with an `export_name` of `main`?
     }
 }
 
-// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum Access {
     Shared,
     }
 
     // pub fn parent_closure(&self) -> Option<Closure> {
+
     //     self.func.as_ref().right().cloned()
+
     // }
 
     pub fn index(&self) -> usize {
                 let body = db.body(parent);
                 if let Some(self_param) = body.self_param.filter(|_| self.idx == 0) {
                     Some(Local { parent, binding_id: self_param })
-                } else if let Pat::Bind { id, .. } =
-                    &body[body.params[self.idx - body.self_param.is_some() as usize]]
-                {
+                } else if let Pat::Bind { id, .. } = &body[body.params[self.idx - body.self_param.is_some() as usize]] {
                     Some(Local { parent, binding_id: *id })
                 } else {
                     None
                 }
-            }
+            },
             Callee::Closure(closure, _) => {
                 let c = db.lookup_intern_closure(closure);
                 let body = db.body(c.0);
                     return Some(Local { parent: c.0, binding_id: *id });
                 }
                 None
-            }
+            },
             _ => None,
         }
     }
 impl SelfParam {
     pub fn access(self, db: &dyn HirDatabase) -> Access {
         let func_data = db.function_signature(self.func);
-        func_data
-            .params
-            .first()
-            .map(|&param| match &func_data.store[param] {
-                TypeRef::Reference(ref_) => match ref_.mutability {
-                    hir_def::type_ref::Mutability::Shared => Access::Shared,
-                    hir_def::type_ref::Mutability::Mut => Access::Exclusive,
-                },
-                _ => Access::Owned,
-            })
-            .unwrap_or(Access::Owned)
+        func_data.params.first().map(|&param| match &func_data.store[param] {
+            TypeRef::Reference(ref_) => match ref_.mutability {
+                hir_def::type_ref::Mutability::Shared => Access::Shared,
+                hir_def::type_ref::Mutability::Mut => Access::Exclusive,
+            },
+            _ => Access::Owned,
+        }).unwrap_or(
+            Access::Owned,
+        )
     }
 
     pub fn parent_fn(&self) -> Function {
         Type { env: environment, ty }
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
             Some(krate.into())
         } else {
             krate.data(db).dependencies.iter().find_map(|dep| {
-                if dep.name.symbol() == name.symbol() { Some(dep.crate_id.into()) } else { None }
+                if dep.name.symbol() == name.symbol() {
+                    Some(dep.crate_id.into())
+                } else {
+                    None
+                }
             })
         }
     }
     pub fn eval(self, db: &dyn HirDatabase) -> Result<EvaluatedConst<'_>, ConstEvalError<'_>> {
         let interner = DbInterner::new_with(db, None, None);
         let ty = db.value_ty(self.id.into()).unwrap().instantiate_identity();
-        db.const_eval(self.id.into(), GenericArgs::new_from_iter(interner, []), None)
-            .map(|it| EvaluatedConst { const_: it, def: self.id.into(), ty })
+        db.const_eval(self.id.into(), GenericArgs::new_from_iter(interner, []), None).map(
+            |it| EvaluatedConst { const_: it, def: self.id.into(), ty },
+        )
     }
 }
 
     pub fn eval(self, db: &dyn HirDatabase) -> Result<EvaluatedConst<'_>, ConstEvalError<'_>> {
         let interner = DbInterner::new_with(db, None, None);
         let ty = db.value_ty(self.id.into()).unwrap().instantiate_identity();
-        db.const_eval(self.id.into(), GenericArgs::new_from_iter(interner, []), None)
-            .map(|it| EvaluatedConst { const_: it, def: self.id.into(), ty })
+        db.const_eval(self.id.into(), GenericArgs::new_from_iter(interner, []), None).map(
+            |it| EvaluatedConst { const_: it, def: self.id.into(), ty },
+        )
     }
 }
 
     }
 
     pub fn function(self, db: &dyn HirDatabase, name: impl PartialEq<Name>) -> Option<Function> {
-        self.id.trait_items(db).items.iter().find(|(n, _)| name == *n).and_then(|&(_, it)| match it
-        {
+        self.id.trait_items(db).items.iter().find(|(n, _)| name == *n).and_then(|&(_, it)| match it {
             AssocItemId::FunctionId(id) => Some(Function { id }),
             _ => None,
         })
         db: &dyn HirDatabase,
         count_required_only: bool,
     ) -> usize {
-        db.generic_params(self.id.into())
-            .iter_type_or_consts()
-            .filter(|(_, ty)| !matches!(ty, TypeOrConstParamData::TypeParamData(ty) if ty.provenance != TypeParamProvenance::TypeParamList))
-            .filter(|(_, ty)| !count_required_only || !ty.has_default())
-            .count()
+        db.generic_params(self.id.into()).iter_type_or_consts().filter(
+            |(_, ty)| !matches!(ty, TypeOrConstParamData::TypeParamData(ty) if ty.provenance != TypeParamProvenance::TypeParamList),
+        ).filter(
+            |(_, ty)| !count_required_only || !ty.has_default(),
+        ).count(
+        )
     }
 
     pub fn dyn_compatibility(&self, db: &dyn HirDatabase) -> Option<DynCompatibilityViolation> {
 }
 
 impl BuiltinType {
-    // Constructors are added on demand, feel free to add more.
     pub fn str() -> BuiltinType {
         BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }
     }
                 let loc = id.lookup(db);
                 let source = loc.source(db);
                 as_name_opt(source.value.name())
-            }
+            },
             MacroId::MacroRulesId(id) => {
                 let loc = id.lookup(db);
                 let source = loc.source(db);
                 as_name_opt(source.value.name())
-            }
+            },
             MacroId::ProcMacroId(id) => {
                 let loc = id.lookup(db);
                 let source = loc.source(db);
                 match loc.kind {
-                    ProcMacroKind::CustomDerive => db
-                        .attrs(id.into())
-                        .parse_proc_macro_derive()
-                        .map_or_else(|| as_name_opt(source.value.name()), |(it, _)| it),
+                    ProcMacroKind::CustomDerive => db.attrs(id.into()).parse_proc_macro_derive().map_or_else(
+                        || as_name_opt(source.value.name()),
+                        |(it, _)| it,
+                    ),
                     ProcMacroKind::Bang | ProcMacroKind::Attr => as_name_opt(source.value.name()),
                 }
-            }
+            },
         }
     }
 
                 MacroExpander::Declarative => MacroKind::Declarative,
                 MacroExpander::BuiltIn(_) | MacroExpander::BuiltInEager(_) => {
                     MacroKind::DeclarativeBuiltIn
-                }
+                },
                 MacroExpander::BuiltInAttr(_) => MacroKind::AttrBuiltIn,
                 MacroExpander::BuiltInDerive(_) => MacroKind::DeriveBuiltIn,
             },
                 MacroExpander::Declarative => MacroKind::Declarative,
                 MacroExpander::BuiltIn(_) | MacroExpander::BuiltInEager(_) => {
                     MacroKind::DeclarativeBuiltIn
-                }
+                },
                 MacroExpander::BuiltInAttr(_) => MacroKind::AttrBuiltIn,
                 MacroExpander::BuiltInDerive(_) => MacroKind::DeriveBuiltIn,
             },
         match self.id {
             MacroId::Macro2Id(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltInDerive(_))
-            }
+            },
             MacroId::MacroRulesId(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltInDerive(_))
-            }
+            },
             MacroId::ProcMacroId(_) => false,
         }
     }
         match self.id {
             MacroId::Macro2Id(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltInEager(eager) if eager.is_env_or_option_env())
-            }
+            },
             MacroId::MacroRulesId(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltInEager(eager) if eager.is_env_or_option_env())
-            }
+            },
             MacroId::ProcMacroId(_) => false,
         }
     }
         match self.id {
             MacroId::Macro2Id(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltIn(m) if m.is_asm())
-            }
+            },
             MacroId::MacroRulesId(it) => {
                 matches!(it.lookup(db).expander, MacroExpander::BuiltIn(m) if m.is_asm())
-            }
+            },
             MacroId::ProcMacroId(_) => false,
         }
     }
                 let loc = id.lookup(db);
                 let source = loc.source(db);
                 visibility_from_ast(db, id, source.map(|src| src.visibility()))
-            }
+            },
             MacroId::MacroRulesId(_) => Visibility::Public,
             MacroId::ProcMacroId(_) => Visibility::Public,
         }
         match module_def {
             ModuleDef::Static(_) | ModuleDef::Const(_) | ModuleDef::Function(_) => {
                 ItemInNs::Values(module_def)
-            }
+            },
             ModuleDef::Macro(it) => ItemInNs::Macros(it),
             _ => ItemInNs::Types(module_def),
         }
         ItemContainerId::ExternBlockId(_) => Some(ctor(DEF::from(id))),
         ItemContainerId::TraitId(_) | ItemContainerId::ImplId(_) | ItemContainerId::ModuleId(_) => {
             None
-        }
+        },
     }
 }
 
             ItemContainerId::ImplId(id) => AssocItemContainer::Impl(id.into()),
             ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {
                 panic!("invalid AssocItem")
-            }
+            },
         }
     }
 
             AssocItem::Function(func) => {
                 GenericDef::Function(func).diagnostics(db, acc);
                 DefWithBody::from(func).diagnostics(db, acc, style_lints);
-            }
+            },
             AssocItem::Const(const_) => {
                 GenericDef::Const(const_).diagnostics(db, acc);
                 DefWithBody::from(const_).diagnostics(db, acc, style_lints);
-            }
+            },
             AssocItem::TypeAlias(type_alias) => {
                 GenericDef::TypeAlias(type_alias).diagnostics(db, acc);
                 push_ty_diagnostics(
                 for diag in hir_ty::diagnostics::incorrect_case(db, type_alias.id.into()) {
                     acc.push(diag.into());
                 }
-            }
+            },
         }
     }
 }
     Const(Const),
     Static(Static),
 }
+
 impl_from!(
     Function,
     Adt(Struct, Enum, Union),
                 Either::Right(it) => GenericParam::TypeParam(it),
             }
         });
-        self.lifetime_params(db)
-            .into_iter()
-            .map(GenericParam::LifetimeParam)
-            .chain(ty_params)
-            .collect()
+        self.lifetime_params(db).into_iter().map(GenericParam::LifetimeParam).chain(ty_params).collect(
+        )
     }
 
     pub fn lifetime_params(self, db: &dyn HirDatabase) -> Vec<LifetimeParam> {
         let generics = db.generic_params(self.into());
-        generics
-            .iter_lt()
-            .map(|(local_id, _)| LifetimeParam {
+        generics.iter_lt().map(|(local_id, _)| LifetimeParam {
                 id: LifetimeParamId { parent: self.into(), local_id },
-            })
-            .collect()
+            }).collect(
+        )
     }
 
     pub fn type_or_const_params(self, db: &dyn HirDatabase) -> Vec<TypeOrConstParam> {
         let generics = db.generic_params(self.into());
-        generics
-            .iter_type_or_consts()
-            .map(|(local_id, _)| TypeOrConstParam {
+        generics.iter_type_or_consts().map(|(local_id, _)| TypeOrConstParam {
                 id: TypeOrConstParamId { parent: self.into(), local_id },
-            })
-            .collect()
+            }).collect(
+        )
     }
 
     fn id(self) -> GenericDefId {
     }
 }
 
-// We cannot call this `Substitution` unfortunately...
 #[derive(Debug)]
 pub struct GenericSubstitution<'db> {
     def: GenericDefId,
             .iter()
             .filter_map(|param| param.ty())
             .zip(type_params);
-        container_params
-            .chain(self_params)
-            .filter_map(|(ty, name)| {
-                Some((name?.symbol().clone(), Type { ty, env: self.env.clone() }))
-            })
-            .collect()
+        container_params.chain(self_params).filter_map(|(ty, name)| {
+            Some((name?.symbol().clone(), Type { ty, env: self.env.clone() }))
+        }).collect(
+        )
     }
 }
 
         // FIXME: This parses!
         let src = self.primary_source(db);
         match src.source.value {
-            Either::Left(pat) => pat
-                .syntax()
-                .ancestors()
-                .map(|it| it.kind())
-                .take_while(|&kind| ast::Pat::can_cast(kind) || ast::Param::can_cast(kind))
-                .any(ast::Param::can_cast),
+            Either::Left(pat) => pat.syntax().ancestors().map(|it| it.kind()).take_while(
+                |&kind| ast::Pat::can_cast(kind) || ast::Param::can_cast(kind),
+            ).any(
+                ast::Param::can_cast,
+            ),
             Either::Right(_) => true,
         }
     }
                     local: self,
                     source: source.map(|ast| Either::Right(ast.to_node(&root))),
                 }]
-            }
-            _ => source_map
-                .patterns_for_binding(self.binding_id)
-                .iter()
-                .map(|&definition| {
-                    let src = source_map.pat_syntax(definition).unwrap(); // Hmm...
-                    let root = src.file_syntax(db);
-                    LocalSource {
-                        local: self,
-                        source: src.map(|ast| match ast.to_node(&root) {
-                            Either::Right(ast::Pat::IdentPat(it)) => Either::Left(it),
-                            _ => unreachable!("local with non ident-pattern"),
-                        }),
-                    }
-                })
-                .collect(),
+            },
+            _ => source_map.patterns_for_binding(self.binding_id).iter().map(|&definition| {
+                let src = source_map.pat_syntax(definition).unwrap();
+                let root = src.file_syntax(db);
+                LocalSource {
+                    local: self,
+                    source: src.map(|ast| match ast.to_node(&root) {
+                        Either::Right(ast::Pat::IdentPat(it)) => Either::Left(it),
+                        _ => unreachable!("local with non ident-pattern"),
+                    }),
+                }
+            }).collect(
+            ),
         }
     }
 
                     local: self,
                     source: source.map(|ast| Either::Right(ast.to_node(&root))),
                 }
-            }
-            _ => source_map
-                .patterns_for_binding(self.binding_id)
-                .first()
-                .map(|&definition| {
-                    let src = source_map.pat_syntax(definition).unwrap(); // Hmm...
-                    let root = src.file_syntax(db);
-                    LocalSource {
-                        local: self,
-                        source: src.map(|ast| match ast.to_node(&root) {
-                            Either::Right(ast::Pat::IdentPat(it)) => Either::Left(it),
-                            _ => unreachable!("local with non ident-pattern"),
-                        }),
-                    }
-                })
-                .unwrap(),
+            },
+            _ => source_map.patterns_for_binding(self.binding_id).first().map(|&definition| {
+                let src = source_map.pat_syntax(definition).unwrap();
+                let root = src.file_syntax(db);
+                LocalSource {
+                    local: self,
+                    source: src.map(|ast| match ast.to_node(&root) {
+                        Either::Right(ast::Pat::IdentPat(it)) => Either::Left(it),
+                        _ => unreachable!("local with non ident-pattern"),
+                    }),
+                }
+            }).unwrap(
+            ),
         }
     }
 }
 
     pub fn name(&self, db: &dyn HirDatabase) -> Name {
         match self.derive {
-            makro @ MacroId::Macro2Id(_) => db
-                .attrs(makro.into())
-                .parse_rustc_builtin_macro()
-                .and_then(|(_, helpers)| helpers.get(self.idx as usize).cloned()),
+            makro @ MacroId::Macro2Id(_) => db.attrs(makro.into()).parse_rustc_builtin_macro().and_then(
+                |(_, helpers)| helpers.get(self.idx as usize).cloned(),
+            ),
             MacroId::MacroRulesId(_) => None,
-            makro @ MacroId::ProcMacroId(_) => db
-                .attrs(makro.into())
-                .parse_proc_macro_derive()
-                .and_then(|(_, helpers)| helpers.get(self.idx as usize).cloned()),
-        }
-        .unwrap_or_else(Name::missing)
+            makro @ MacroId::ProcMacroId(_) => db.attrs(makro.into()).parse_proc_macro_derive().and_then(
+                |(_, helpers)| helpers.get(self.idx as usize).cloned(),
+            ),
+        }.unwrap_or_else(
+            Name::missing,
+        )
     }
 }
 
 
 impl BuiltinAttr {
     fn builtin(name: &str) -> Option<Self> {
-        hir_expand::inert_attr_macro::find_builtin_attr_idx(&Symbol::intern(name))
-            .map(|idx| BuiltinAttr { idx: idx as u32 })
+        hir_expand::inert_attr_macro::find_builtin_attr_idx(&Symbol::intern(name)).map(
+            |idx| BuiltinAttr { idx: idx as u32 },
+        )
     }
 
     pub fn name(&self) -> Name {
-        Name::new_symbol_root(Symbol::intern(
-            hir_expand::inert_attr_macro::INERT_ATTRIBUTES[self.idx as usize].name,
-        ))
+        Name::new_symbol_root(
+            Symbol::intern(hir_expand::inert_attr_macro::INERT_ATTRIBUTES[self.idx as usize].name),
+        )
     }
 
     pub fn template(&self) -> Option<AttributeTemplate> {
     ConstParam(ConstParam),
     LifetimeParam(LifetimeParam),
 }
+
 impl_from!(TypeParam, ConstParam, LifetimeParam for GenericParam);
 
 impl GenericParam {
     /// parameter, not additional bounds that might be added e.g. by a method if
     /// the parameter comes from an impl!
     pub fn trait_bounds(self, db: &dyn HirDatabase) -> Vec<Trait> {
-        db.generic_predicates_for_param(self.id.parent(), self.id.into(), None)
-            .iter()
-            .filter_map(|pred| match &pred.kind().skip_binder() {
-                ClauseKind::Trait(trait_ref) => Some(Trait::from(trait_ref.def_id().0)),
-                _ => None,
-            })
-            .collect()
+        db.generic_predicates_for_param(self.id.parent(), self.id.into(), None).iter().filter_map(|pred| match &pred.kind().skip_binder() {
+            ClauseKind::Trait(trait_ref) => Some(Trait::from(trait_ref.def_id().0)),
+            _ => None,
+        }).collect(
+        )
     }
 
     pub fn default(self, db: &dyn HirDatabase) -> Option<Type<'_>> {
         match ty {
             GenericArg::Ty(it) if !it.is_ty_error() => {
                 Some(Type::new_with_resolver_inner(db, &resolver, it))
-            }
+            },
             _ => None,
         }
     }
             None => {
                 never!();
                 Name::missing()
-            }
+            },
         }
     }
 
         match &params[self.id.local_id] {
             TypeOrConstParamData::TypeParamData(_) => {
                 Either::Right(TypeParam { id: TypeParamId::from_unchecked(self.id) })
-            }
+            },
             TypeOrConstParamData::ConstParamData(_) => {
                 Either::Left(ConstParam { id: ConstParamId::from_unchecked(self.id) })
-            }
+            },
         }
     }
 
         match &params[self.id.local_id] {
             TypeOrConstParamData::TypeParamData(_) => {
                 Some(TypeParam { id: TypeParamId::from_unchecked(self.id) })
-            }
+            },
             TypeOrConstParamData::ConstParamData(_) => None,
         }
     }
             TypeOrConstParamData::TypeParamData(_) => None,
             TypeOrConstParamData::ConstParamData(_) => {
                 Some(ConstParam { id: ConstParamId::from_unchecked(self.id) })
-            }
+            },
         }
     }
 }
             .nth(derive_index as usize)
             .and_then(<ast::Attr as AstNode>::cast)
             .and_then(|it| it.path())?;
-        Some(InMacroFile { file_id: derive_attr, value: path })
+        Some(InMacroFile {
+            file_id: derive_attr,
+            value: path,
+        })
     }
 
     pub fn check_orphan_rules(self, db: &dyn HirDatabase) -> bool {
     /// Returns `idx`-th argument of this trait reference if it is a type argument. Note that the
     /// first argument is the `Self` type.
     pub fn get_type_argument(&self, idx: usize) -> Option<TypeNs<'db>> {
-        self.trait_ref
-            .args
-            .as_slice()
-            .get(idx)
-            .and_then(|arg| arg.ty())
-            .map(|ty| TypeNs { env: self.env.clone(), ty })
+        self.trait_ref.args.as_slice().get(idx).and_then(|arg| arg.ty()).map(
+            |ty| TypeNs { env: self.env.clone(), ty },
+        )
     }
 }
 
             AnyClosureId::ClosureId(id) => Ty::new_closure(interner, id.into(), self.subst),
             AnyClosureId::CoroutineClosureId(id) => {
                 Ty::new_coroutine_closure(interner, id.into(), self.subst)
-            }
+            },
         }
     }
 
     pub fn display_with_id(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
-        self.as_ty(db)
-            .display(db, display_target)
-            .with_closure_style(ClosureStyle::ClosureWithId)
-            .to_string()
+        self.as_ty(db).display(db, display_target).with_closure_style(ClosureStyle::ClosureWithId).to_string(
+        )
     }
 
-    pub fn display_with_impl(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
-        self.as_ty(db)
-            .display(db, display_target)
-            .with_closure_style(ClosureStyle::ImplFn)
-            .to_string()
+    pub fn display_with_impl(
+        &self,
+        db: &dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
+        self.as_ty(db).display(db, display_target).with_closure_style(ClosureStyle::ImplFn).to_string(
+        )
     }
 
     pub fn captured_items(&self, db: &'db dyn HirDatabase) -> Vec<ClosureCapture<'db>> {
         let owner = db.lookup_intern_closure(id).0;
         let infer = db.infer(owner);
         let info = infer.closure_info(id);
-        info.0
-            .iter()
-            .cloned()
-            .map(|capture| ClosureCapture { owner, closure: id, capture })
-            .collect()
+        info.0.iter().cloned().map(|capture| ClosureCapture { owner, closure: id, capture }).collect(
+        )
     }
 
     pub fn capture_types(&self, db: &'db dyn HirDatabase) -> Vec<Type<'db>> {
         let infer = db.infer(owner);
         let (captures, _) = infer.closure_info(id);
         let env = db.trait_environment_for_body(owner);
-        captures
-            .iter()
-            .map(|capture| Type { env: env.clone(), ty: capture.ty(db, self.subst) })
-            .collect()
+        captures.iter().map(|capture| Type {
+            env: env.clone(),
+            ty: capture.ty(db, self.subst),
+        }).collect(
+        )
     }
 
     pub fn fn_trait(&self, db: &dyn HirDatabase) -> FnTrait {
                 let infer = db.infer(owner);
                 let info = infer.closure_info(id);
                 info.1
-            }
+            },
             AnyClosureId::CoroutineClosureId(_id) => {
-                // FIXME: Infer kind for coroutine closures.
                 match self.subst.as_coroutine_closure().kind() {
                     rustc_type_ir::ClosureKind::Fn => FnTrait::AsyncFn,
                     rustc_type_ir::ClosureKind::FnMut => FnTrait::AsyncFnMut,
                     rustc_type_ir::ClosureKind::FnOnce => FnTrait::AsyncFnOnce,
                 }
-            }
+            },
         }
     }
 }
 
 impl<'db> ClosureCapture<'db> {
     pub fn local(&self) -> Local {
-        Local { parent: self.owner, binding_id: self.capture.local() }
+        Local {
+            parent: self.owner,
+            binding_id: self.capture.local(),
+        }
     }
 
     /// Returns whether this place has any field (aka. non-deref) projections.
     }
 
     pub fn usages(&self) -> CaptureUsages {
-        CaptureUsages { parent: self.owner, spans: self.capture.spans() }
+        CaptureUsages {
+            parent: self.owner,
+            spans: self.capture.spans(),
+        }
     }
 
     pub fn kind(&self) -> CaptureKind {
         Type::new(db, def, ty.instantiate(interner, args))
     }
 
-    // FIXME: We shouldn't leak `TyKind::Param`s.
     fn from_def_params(db: &'db dyn HirDatabase, def: impl Into<TyDefId> + HasResolver) -> Self {
         let ty = db.ty(def.into());
         Type::new(db, def, ty.instantiate_identity())
 
     pub fn new_slice(ty: Self) -> Self {
         let interner = DbInterner::conjure();
-        Type { env: ty.env, ty: Ty::new_slice(interner, ty.ty) }
+        Type {
+            env: ty.env,
+            ty: Ty::new_slice(interner, ty.ty),
+        }
     }
 
     pub fn new_tuple(krate: base_db::Crate, tys: &[Self]) -> Self {
         let tys = tys.iter().map(|it| it.ty);
         let interner = DbInterner::conjure();
-        Type { env: TraitEnvironment::empty(krate), ty: Ty::new_tup_from_iter(interner, tys) }
+        Type {
+            env: TraitEnvironment::empty(krate),
+            ty: Ty::new_tup_from_iter(interner, tys),
+        }
     }
 
     pub fn is_unit(&self) -> bool {
         self.derived(self.ty.strip_references())
     }
 
-    // FIXME: This is the same as `remove_ref()`, remove one of these methods.
     pub fn strip_reference(&self) -> Self {
         self.derived(self.ty.strip_reference())
     }
         traits::implements_trait_unique(self.ty, db, self.env.clone(), fnonce_trait)
     }
 
-    // FIXME: Find better API that also handles const generics
-    pub fn impls_trait(&self, db: &'db dyn HirDatabase, trait_: Trait, args: &[Type<'db>]) -> bool {
+    pub fn impls_trait(
+        &self,
+        db: &'db dyn HirDatabase,
+        trait_: Trait,
+        args: &[Type<'db>],
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(
             interner,
 
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
         let ty = structurally_normalize_ty(&infcx, projection, self.env.clone());
-        if ty.is_ty_error() { None } else { Some(self.derived(ty)) }
+        if ty.is_ty_error() {
+            None
+        } else {
+            Some(self.derived(ty))
+        }
     }
 
     pub fn is_copy(&self, db: &'db dyn HirDatabase) -> bool {
         match self.ty.kind() {
             TyKind::Closure(id, subst) => {
                 Some(Closure { id: AnyClosureId::ClosureId(id.0), subst })
-            }
+            },
             TyKind::CoroutineClosure(id, subst) => {
                 Some(Closure { id: AnyClosureId::CoroutineClosureId(id.0), subst })
-            }
+            },
             _ => None,
         }
     }
     }
 
     pub fn remove_raw_ptr(&self) -> Option<Type<'db>> {
-        if let TyKind::RawPtr(ty, _) = self.ty.kind() { Some(self.derived(ty)) } else { None }
+        if let TyKind::RawPtr(ty, _) = self.ty.kind() {
+            Some(self.derived(ty))
+        } else {
+            None
+        }
     }
 
     pub fn contains_unknown(&self) -> bool {
             _ => return Vec::new(),
         };
 
-        db.field_types(variant_id)
-            .iter()
-            .map(|(local_id, ty)| {
-                let def = Field { parent: variant_id.into(), id: local_id };
-                let ty = ty.instantiate(interner, substs);
-                (def, self.derived(ty))
-            })
-            .collect()
+        db.field_types(variant_id).iter().map(|(local_id, ty)| {
+            let def = Field { parent: variant_id.into(), id: local_id };
+            let ty = ty.instantiate(interner, substs);
+            (def, self.derived(ty))
+        }).collect(
+        )
     }
 
     pub fn tuple_fields(&self, _db: &'db dyn HirDatabase) -> Vec<Self> {
         autoderef(db, self.env.clone(), canonical)
     }
 
-    // This would be nicer if it just returned an iterator, but that runs into
-    // lifetime problems, because we need to borrow temp `CrateImplDefs`.
     pub fn iterate_assoc_items<T>(
         &self,
         db: &'db dyn HirDatabase,
         };
         for krate in def_crates {
             let impls = db.inherent_impls_in_crate(krate);
-
             for impl_def in impls.for_self_ty(ty_ns) {
                 for &(_, item) in impl_def.impl_items(db).items.iter() {
                     if callback(item) {
             TyKind::Adt(_, substs) => Either::Left(substs.types().map(move |ty| self.derived(ty))),
             TyKind::Tuple(substs) => {
                 Either::Right(Either::Left(substs.iter().map(move |ty| self.derived(ty))))
-            }
+            },
             _ => Either::Right(Either::Right(std::iter::empty())),
         }
     }
         db: &'a dyn HirDatabase,
         display_target: DisplayTarget,
     ) -> impl Iterator<Item = SmolStr> + 'a {
-        self.ty
-            .strip_references()
-            .as_adt()
-            .into_iter()
-            .flat_map(|(_, substs)| substs.iter())
-            .filter_map(move |arg| match arg {
-                GenericArg::Ty(ty) => Some(format_smolstr!("{}", ty.display(db, display_target))),
-                GenericArg::Const(const_) => {
-                    Some(format_smolstr!("{}", const_.display(db, display_target)))
-                }
-                GenericArg::Lifetime(_) => None,
-            })
+        self.ty.strip_references().as_adt().into_iter().flat_map(|(_, substs)| substs.iter()).filter_map(move |arg| match arg {
+            GenericArg::Ty(ty) => Some(format_smolstr!("{}", ty.display(db, display_target))),
+            GenericArg::Const(const_) => {
+                Some(format_smolstr!("{}", const_.display(db, display_target)))
+            },
+            GenericArg::Lifetime(_) => None,
+        })
     }
 
     /// Combines lifetime indicators, type and constant parameters into a single `Iterator`
         display_target: DisplayTarget,
     ) -> impl Iterator<Item = SmolStr> + 'a {
         // iterate the lifetime
-        self.as_adt()
-            .and_then(|a| {
-                // Lifetimes do not need edition-specific handling as they cannot be escaped.
-                a.lifetime(db).map(|lt| lt.name.display_no_db(Edition::Edition2015).to_smolstr())
-            })
-            .into_iter()
-            // add the type and const parameters
-            .chain(self.type_and_const_arguments(db, display_target))
+        self.as_adt().and_then(|a| {
+            a.lifetime(db).map(|lt| lt.name.display_no_db(Edition::Edition2015).to_smolstr())
+        }).into_iter(
+        ).chain(
+            self.type_and_const_arguments(db, display_target),
+        )
     }
 
     pub fn iterate_method_candidates_with_traits<T>(
         db: &'db dyn HirDatabase,
     ) -> impl Iterator<Item = Trait> {
         let _p = tracing::info_span!("applicable_inherent_traits").entered();
-        self.autoderef_(db)
-            .filter_map(|ty| ty.dyn_trait())
-            .flat_map(move |dyn_trait_id| hir_ty::all_super_traits(db, dyn_trait_id))
-            .map(Trait::from)
+        self.autoderef_(db).filter_map(|ty| ty.dyn_trait()).flat_map(
+            move |dyn_trait_id| hir_ty::all_super_traits(db, dyn_trait_id),
+        ).map(
+            Trait::from,
+        )
     }
 
     pub fn env_traits(&self, db: &'db dyn HirDatabase) -> impl Iterator<Item = Trait> {
         let _p = tracing::info_span!("env_traits").entered();
-        self.autoderef_(db)
-            .filter(|ty| matches!(ty.kind(), TyKind::Param(_)))
-            .flat_map(|ty| {
-                self.env
-                    .traits_in_scope_from_clauses(ty)
-                    .flat_map(|t| hir_ty::all_super_traits(db, t))
-            })
-            .map(Trait::from)
+        self.autoderef_(db).filter(|ty| matches!(ty.kind(), TyKind::Param(_))).flat_map(|ty| {
+            self.env.traits_in_scope_from_clauses(ty).flat_map(|t| hir_ty::all_super_traits(db, t))
+        }).map(
+            Trait::from,
+        )
     }
 
     pub fn as_impl_traits(&self, db: &'db dyn HirDatabase) -> Option<impl Iterator<Item = Trait>> {
             Visitor { db, env: self.env.clone(), callback, visited: FxHashSet::default() };
         self.ty.visit_with(&mut visitor);
     }
+
     /// Check if type unifies with another type.
     ///
     /// Note that we consider placeholder types to unify with everything.
 
     /// Returns unique `GenericParam`s contained in this type.
     pub fn generic_params(&self, db: &'db dyn HirDatabase) -> FxHashSet<GenericParam> {
-        hir_ty::collect_params(&self.ty)
-            .into_iter()
-            .map(|id| TypeOrConstParam { id }.split(db).either_into())
-            .collect()
+        hir_ty::collect_params(&self.ty).into_iter().map(
+            |id| TypeOrConstParam { id }.split(db).either_into(),
+        ).collect(
+        )
     }
 
     pub fn layout(&self, db: &'db dyn HirDatabase) -> Result<Layout, LayoutError> {
-        db.layout_of_ty(self.ty, self.env.clone())
-            .map(|layout| Layout(layout, db.target_data_layout(self.env.krate).unwrap()))
+        db.layout_of_ty(self.ty, self.env.clone()).map(
+            |layout| Layout(layout, db.target_data_layout(self.env.krate).unwrap()),
+        )
     }
 
     pub fn drop_glue(&self, db: &'db dyn HirDatabase) -> DropGlue {
     }
 
     pub fn to_type(&self, _db: &'db dyn HirDatabase) -> Type<'db> {
-        Type { env: self.env.clone(), ty: self.ty }
+        Type {
+            env: self.env.clone(),
+            ty: self.ty,
+        }
     }
 
-    // FIXME: Find better API that also handles const generics
     pub fn impls_trait(&self, infcx: InferCtxt<'db>, trait_: Trait, args: &[TypeNs<'db>]) -> bool {
         let args = GenericArgs::new_from_iter(
             infcx.interner,
     }
 }
 
-// FIXME: Document this
 #[derive(Debug)]
 pub struct Callable<'db> {
     ty: Type<'db>,
             Callee::Def(CallableDefId::StructId(it)) => CallableKind::TupleStruct(it.into()),
             Callee::Def(CallableDefId::EnumVariantId(it)) => {
                 CallableKind::TupleEnumVariant(it.into())
-            }
+            },
             Callee::Closure(id, subst) => {
                 CallableKind::Closure(Closure { id: AnyClosureId::ClosureId(id), subst })
-            }
+            },
             Callee::CoroutineClosure(id, subst) => {
                 CallableKind::Closure(Closure { id: AnyClosureId::CoroutineClosureId(id), subst })
-            }
+            },
             Callee::FnPtr => CallableKind::FnPtr,
             Callee::FnImpl(fn_) => CallableKind::FnImpl(fn_),
         }
     }
+
     pub fn receiver_param(&self, db: &'db dyn HirDatabase) -> Option<(SelfParam, Type<'db>)> {
         let func = match self.callee {
             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,
             self.ty.derived(self.sig.skip_binder().inputs_and_output.inputs()[0]),
         ))
     }
+
     pub fn n_params(&self) -> usize {
-        self.sig.skip_binder().inputs_and_output.inputs().len()
-            - if self.is_bound_method { 1 } else { 0 }
+        self.sig.skip_binder().inputs_and_output.inputs().len() - if self.is_bound_method {
+            1
+        } else {
+            0
+        }
     }
+
     pub fn params(&self) -> Vec<Param<'db>> {
-        self.sig
-            .skip_binder()
-            .inputs_and_output
-            .inputs()
-            .iter()
-            .enumerate()
-            .skip(if self.is_bound_method { 1 } else { 0 })
-            .map(|(idx, ty)| (idx, self.ty.derived(*ty)))
-            .map(|(idx, ty)| Param { func: self.callee.clone(), idx, ty })
-            .collect()
+        self.sig.skip_binder().inputs_and_output.inputs().iter().enumerate().skip(if self.is_bound_method {
+            1
+        } else {
+            0
+        }).map(
+            |(idx, ty)| (idx, self.ty.derived(*ty)),
+        ).map(
+            |(idx, ty)| Param { func: self.callee.clone(), idx, ty },
+        ).collect(
+        )
     }
+
     pub fn return_type(&self) -> Type<'db> {
         self.ty.derived(self.sig.skip_binder().output())
     }
+
     pub fn sig(&self) -> impl Eq {
         &self.sig
     }
             layout::FieldsShape::Array { stride, count } => {
                 let i = u64::try_from(field.index()).ok()?;
                 (i < count).then_some((stride * i).bytes())
-            }
+            },
             layout::FieldsShape::Arbitrary { ref offsets, .. } => {
                 Some(offsets.get(RustcFieldIdx(field.id))?.bytes())
-            }
+            },
         }
     }
 
             layout::FieldsShape::Array { stride, count } => {
                 let i = u64::try_from(field).ok()?;
                 (i < count).then_some((stride * i).bytes())
-            }
+            },
             layout::FieldsShape::Arbitrary { ref offsets, .. } => {
                 Some(offsets.get(RustcFieldIdx::new(field))?.bytes())
-            }
+            },
         }
     }
 
                 let tail_field_size = field_size(tail.0.into_raw().into_u32() as usize)?;
                 let offset = offsets.get(tail)?.bytes();
                 self.0.size.bytes().checked_sub(offset)?.checked_sub(tail_field_size)
-            }
+            },
         }
     }
 
             layout::FieldsShape::Array { stride, .. } => {
                 let size = field_size(0)?;
                 stride.bytes().checked_sub(size)
-            }
+            },
             layout::FieldsShape::Arbitrary { ref offsets, ref memory_index } => {
                 let mut reverse_index = vec![None; memory_index.len()];
                 for (src, (mem, offset)) in memory_index.iter().zip(offsets.iter()).enumerate() {
                     stdx::never!();
                     return None;
                 }
-                reverse_index
-                    .into_iter()
-                    .flatten()
-                    .chain(std::iter::once((0, self.0.size.bytes())))
-                    .tuple_windows()
-                    .filter_map(|((i, start), (_, end))| {
-                        let size = field_size(i)?;
-                        end.checked_sub(start)?.checked_sub(size)
-                    })
-                    .max()
-            }
+                reverse_index.into_iter().flatten().chain(std::iter::once((0, self.0.size.bytes()))).tuple_windows(
+                ).filter_map(|((i, start), (_, end))| {
+                    let size = field_size(i)?;
+                    end.checked_sub(start)?.checked_sub(size)
+                }).max(
+                )
+            },
         }
     }
 
 
 pub trait HasVisibility {
     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;
+
     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {
         let vis = self.visibility(db);
         vis.is_visible_from(db, module.id)
     db: &'a dyn HirDatabase,
     mut segments: I,
 ) -> impl Iterator<Item = ItemInNs> + use<'a, I> {
-    segments
-        .next()
-        .into_iter()
-        .flat_map(move |crate_name| {
-            db.all_crates()
-                .iter()
-                .filter(|&krate| {
-                    krate
-                        .extra_data(db)
-                        .display_name
-                        .as_ref()
-                        .is_some_and(|name| *name.crate_name().symbol() == crate_name)
-                })
-                .filter_map(|&krate| {
-                    let segments = segments.clone();
-                    let mut def_map = crate_def_map(db, krate);
-                    let mut module = &def_map[DefMap::ROOT];
-                    let mut segments = segments.with_position().peekable();
-                    while let Some((_, segment)) = segments.next_if(|&(position, _)| {
+    segments.next().into_iter().flat_map(move |crate_name| {
+        db.all_crates().iter().filter(|&krate| {
+            krate.extra_data(db).display_name.as_ref().is_some_and(
+                |name| *name.crate_name().symbol() == crate_name,
+            )
+        }).filter_map(|&krate| {
+            let segments = segments.clone();
+            let mut def_map = crate_def_map(db, krate);
+            let mut module = &def_map[DefMap::ROOT];
+            let mut segments = segments.with_position().peekable();
+            while let Some((_, segment)) = segments.next_if(|&(position, _)| {
                         !matches!(position, itertools::Position::Last | itertools::Position::Only)
                     }) {
                         let res = module
                         def_map = res.def_map(db);
                         module = &def_map[res.local_id];
                     }
-                    let (_, item_name) = segments.next()?;
-                    let res = module.scope.get(&Name::new_symbol_root(item_name));
-                    Some(res.iter_items().map(|(item, _)| item.into()))
-                })
-                .collect::<Vec<_>>()
-        })
-        .flatten()
+            let (_, item_name) = segments.next()?;
+            let res = module.scope.get(&Name::new_symbol_root(item_name));
+            Some(res.iter_items().map(|(item, _)| item.into()))
+        }).collect::<Vec<_>>(
+        )
+    }).flatten(
+    )
 }
 
 fn as_name_opt(name: Option<impl AsName>) -> Name {
     args: impl IntoIterator<Item = Ty<'db>>,
 ) -> GenericArgs<'db> {
     let mut args = args.into_iter();
-    GenericArgs::for_item(interner, def_id, |_, id, _| {
-        if matches!(id, GenericParamId::TypeParamId(_))
-            && let Some(arg) = args.next()
-        {
+    GenericArgs::for_item(
+        interner,
+        def_id,
+        |_, id, _| {
+        if matches!(id, GenericParamId::TypeParamId(_)) && let Some(arg) = args.next() {
             arg.into()
         } else {
             next_solver::GenericArg::error_from_id(interner, id)
         }
-    })
+    },
+    )
 }
 
 fn has_non_default_type_params(db: &dyn HirDatabase, generic_def: GenericDefId) -> bool {
     let params = db.generic_params(generic_def);
     let defaults = db.generic_defaults(generic_def);
-    params
-        .iter_type_or_consts()
-        .filter(|(_, param)| matches!(param, TypeOrConstParamData::TypeParamData(_)))
-        .map(|(local_id, _)| TypeOrConstParamId { parent: generic_def, local_id })
-        .any(|param| {
-            let Some(param) = hir_ty::param_idx(db, param) else {
+    params.iter_type_or_consts().filter(
+        |(_, param)| matches!(param, TypeOrConstParamData::TypeParamData(_)),
+    ).map(
+        |(local_id, _)| TypeOrConstParamId { parent: generic_def, local_id },
+    ).any(|param| {
+        let Some(param) = hir_ty::param_idx(db, param) else {
                 return false;
             };
-            defaults.get(param).is_none()
-        })
+        defaults.get(param).is_none()
+    })
 }
-
-pub use hir_ty::next_solver;
-pub use hir_ty::setup_tracing;