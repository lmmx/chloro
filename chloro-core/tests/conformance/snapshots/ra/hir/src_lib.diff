COMPARISON DIFF
============================================================

Original size: 227843 bytes
Chloro size:   226249 bytes
Rustfmt size:  227843 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 #![recursion_limit = "512"]
 
-extern crate ra_ap_rustc_type_ir as rustc_type_ir;
 
 mod attrs;
 mod from_id;
 mod has_source;
 mod semantics;
 mod source_analyzer;
-
 pub mod db;
 pub mod diagnostics;
 pub mod symbols;
 pub mod term_search;
-
 mod display;
 
-#[doc(hidden)]
-pub use hir_def::ModuleId;
-
 use std::{
     fmt,
     mem::discriminant,
 use arrayvec::ArrayVec;
 use base_db::{CrateDisplayName, CrateOrigin, LangCrateOrigin};
 use either::Either;
+pub use hir_def::ModuleId;
 use hir_def::{
-    AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
-    CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
-    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
-    LocalFieldId, Lookup, MacroExpander, MacroId, StaticId, StructId, SyntheticSyntax, TupleId,
-    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,
     expr_store::{ExpressionStoreDiagnostics, ExpressionStoreSourceMap},
     hir::{
-        BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, LabelId, Pat,
         generics::{LifetimeParamData, TypeOrConstParamData, TypeParamProvenance},
+        BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, LabelId, Pat,
     },
     item_tree::ImportAlias,
     layout::{self, ReprOptions, TargetDataLayout},
-    nameres::{
-        assoc::TraitItems,
-        diagnostics::{DefDiagnostic, DefDiagnosticKind},
-    },
+    nameres::{assoc::TraitItems, diagnostics::{DefDiagnostic, DefDiagnosticKind}},
     per_ns::PerNs,
     resolver::{HasResolver, Resolver},
     signatures::{ImplFlags, StaticFlags, StructFlags, TraitFlags, VariantFields},
     src::HasSource as _,
     visibility::visibility_from_ast,
+    AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
+    CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
+    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
+    LocalFieldId, Lookup, MacroExpander, MacroId, StaticId, StructId, SyntheticSyntax, TupleId,
+    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,
 };
 use hir_expand::{
-    AstId, MacroCallKind, RenderedExpandError, ValueResult, attrs::collect_attrs,
-    proc_macro::ProcMacroKind,
+    attrs::collect_attrs, proc_macro::ProcMacroKind, AstId, MacroCallKind, RenderedExpandError,
+    ValueResult,
 };
+pub use hir_ty::next_solver;
+pub use hir_ty::setup_tracing;
 use hir_ty::{
-    TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId, all_super_traits, autoderef,
-    check_orphan_rules,
+    all_super_traits, autoderef, check_orphan_rules,
     consteval::try_const_usize,
     db::{InternedClosureId, InternedCoroutineId},
     diagnostics::BodyValidationDiagnostic,
     direct_super_traits, known_const_to_ast,
     layout::{Layout as TyLayout, RustcEnumVariantIdx, RustcFieldIdx, TagEncoding},
     method_resolution,
-    mir::{MutBorrowKind, interpret_mir},
+    mir::{interpret_mir, MutBorrowKind},
     next_solver::{
-        AliasTy, Canonical, ClauseKind, ConstKind, DbInterner, ErrorGuaranteed, GenericArg,
-        GenericArgs, PolyFnSig, Region, SolverDefId, Ty, TyKind, TypingMode,
-        infer::{DbInternerInferExt, InferCtxt},
+        infer::{DbInternerInferExt, InferCtxt}, AliasTy, Canonical, ClauseKind, ConstKind,
+        DbInterner, ErrorGuaranteed, GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Ty,
+        TyKind, TypingMode,
     },
-    traits::{self, FnTrait, structurally_normalize_ty},
+    traits::{self, structurally_normalize_ty, FnTrait},
+    TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId,
 };
 use itertools::Itertools;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
-    AliasTyKind, TypeSuperVisitable, TypeVisitable, TypeVisitor,
     inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _},
+    AliasTyKind, TypeSuperVisitable, TypeVisitable, TypeVisitor,
 };
 use smallvec::SmallVec;
 use span::{AstIdNode, Edition, FileId};
 use stdx::{format_to, impl_from, never};
 use syntax::{
-    AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, T, TextRange, ToSmolStr,
     ast::{self, HasAttrs as _, HasName, HasVisibility as _},
-    format_smolstr,
+    format_smolstr, AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, TextRange, ToSmolStr, T,
 };
 use triomphe::{Arc, ThinArc};
-
-use crate::db::{DefDatabase, HirDatabase};
-
-pub use crate::{
-    attrs::{HasAttrs, resolve_doc_path_on},
-    diagnostics::*,
-    has_source::HasSource,
-    semantics::{
-        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
-        VisibleTraits,
-    },
-};
-
-// Be careful with these re-exports.
-//
-// `hir` is the boundary between the compiler and the IDE. It should try hard to
-// isolate the compiler from the ide, to allow the two to be refactored
-// independently. Re-exporting something from the compiler is the sure way to
-// breach the boundary.
-//
-// Generally, a refactoring which *removes* a name from this list is a good
-// idea!
 pub use {
     cfg::{CfgAtom, CfgExpr, CfgOptions},
     hir_def::{
-        Complete,
-        FindPathConfig,
-        attr::{AttrSourceMap, Attrs, AttrsWithOwner},
-        find_path::PrefixKind,
-        import_map,
-        lang_item::LangItem,
-        nameres::{DefMap, ModuleSource, crate_def_map},
-        per_ns::Namespace,
-        type_ref::{Mutability, TypeRef},
-        visibility::Visibility,
+        attr::{AttrSourceMap, Attrs, AttrsWithOwner}, find_path::PrefixKind, import_map,
+        lang_item::LangItem, nameres::{DefMap, ModuleSource, crate_def_map}, per_ns::Namespace,
+        type_ref::{Mutability, TypeRef}, visibility::Visibility,
         // FIXME: This is here since some queries take it as input that are used
         // outside of hir.
         {ModuleDefId, TraitId},
+        Complete, FindPathConfig,
     },
     hir_expand::{
-        EditionedFileId, ExpandResult, HirFileId, MacroCallId, MacroKind,
-        attrs::{Attr, AttrId},
-        change::ChangeWithProcMacros,
+        attrs::{Attr, AttrId}, change::ChangeWithProcMacros,
         files::{
             FilePosition, FilePositionWrapper, FileRange, FileRangeWrapper, HirFilePosition,
             HirFileRange, InFile, InFileWrapper, InMacroFile, InRealFile, MacroFilePosition,
             MacroFileRange,
         },
-        inert_attr_macro::AttributeTemplate,
-        mod_path::{ModPath, PathKind, tool_path},
-        name::Name,
-        prettify_macro_expansion,
-        proc_macro::{ProcMacros, ProcMacrosBuilder},
-        tt,
+        inert_attr_macro::AttributeTemplate, mod_path::{ModPath, PathKind, tool_path}, name::Name,
+        prettify_macro_expansion, proc_macro::{ProcMacros, ProcMacrosBuilder}, tt,
+        EditionedFileId, ExpandResult, HirFileId, MacroCallId, MacroKind,
     },
+    hir_ty::{
+        attach_db, attach_db_allow_change, consteval::ConstEvalError, diagnostics::UnsafetyReason,
+        display::{ClosureStyle, DisplayTarget, HirDisplay, HirDisplayError, HirWrite},
+        drop::DropGlue, dyn_compatibility::{DynCompatibilityViolation, MethodViolationCode},
+        layout::LayoutError, method_resolution::TyFingerprint, mir::{MirEvalError, MirLowerError},
+        next_solver::abi::Safety, next_solver::clear_tls_solver_cache, CastError, FnAbi,
+        PointerCast,
+    },
+    intern::{sym, Symbol},
     // FIXME: Properly encapsulate mir
     hir_ty::mir,
-    hir_ty::{
-        CastError, FnAbi, PointerCast, attach_db, attach_db_allow_change,
-        consteval::ConstEvalError,
-        diagnostics::UnsafetyReason,
-        display::{ClosureStyle, DisplayTarget, HirDisplay, HirDisplayError, HirWrite},
-        drop::DropGlue,
-        dyn_compatibility::{DynCompatibilityViolation, MethodViolationCode},
-        layout::LayoutError,
-        method_resolution::TyFingerprint,
-        mir::{MirEvalError, MirLowerError},
-        next_solver::abi::Safety,
-        next_solver::clear_tls_solver_cache,
-    },
-    intern::{Symbol, sym},
 };
-
-// These are negative re-exports: pub using these names is forbidden, they
-// should remain private to hir internals.
-#[allow(unused)]
 use {
     hir_def::expr_store::path::Path,
-    hir_expand::{
-        name::AsName,
-        span_map::{ExpansionSpanMap, RealSpanMap, SpanMap, SpanMapRef},
+    hir_expand::{name::AsName, span_map::{ExpansionSpanMap, RealSpanMap, SpanMap, SpanMapRef}},
+};
+
+use crate::db::{DefDatabase, HirDatabase};
+pub use crate::{
+    attrs::{resolve_doc_path_on, HasAttrs},
+    diagnostics::*,
+    has_source::HasSource,
+    semantics::{
+        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
+        VisibleTraits,
     },
 };
 
     BuiltinType(BuiltinType),
     Macro(Macro),
 }
+
 impl_from!(
     Module,
     Function,
             .children
             .values()
             .map(|module_id| Module { id: def_map.module_id(*module_id) })
-            .collect::<Vec<_>>();
+            .collect();
         children.into_iter()
     }
 
         TypeNs::new(db, var_id, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
             .map(|(id, _)| Field { parent: self.into(), id })
             .collect()
     }
+
     pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Variant {
     pub(crate) id: EnumVariantId,
     }
 
     pub fn instantiate_infer<'db>(self, infer_ctxt: &InferCtxt<'db>) -> InstantiatedVariant<'db> {
-        let args =
-            infer_ctxt.fresh_args_for_item(self.parent_enum(infer_ctxt.interner.db()).id.into());
+        let args = infer_ctxt.fresh_args_for_item(self.parent_enum(infer_ctxt.interner.db()).id.into());
         InstantiatedVariant { inner: self, args }
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct InstantiatedVariant<'db> {
     pub(crate) inner: Variant,
 
 impl<'db> InstantiatedVariant<'db> {
     pub fn parent_enum(self, db: &dyn HirDatabase) -> InstantiatedEnum<'db> {
-        InstantiatedEnum { inner: self.inner.id.lookup(db).parent.into(), args: self.args }
+        InstantiatedEnum {
+            inner: self.inner.id.lookup(db).parent.into(),
+            args: self.args,
+        }
     }
 
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<InstantiatedField<'db>> {
     Union(Union),
     Enum(Enum),
 }
+
 impl_from!(Struct, Union, Enum for Adt);
 
 impl Adt {
     Union(Union),
     Variant(Variant),
 }
+
 impl_from!(Struct, Union, Variant for VariantDef);
 
 impl VariantDef {
     Const(Const),
     Variant(Variant),
 }
+
 impl_from!(Function, Const, Static, Variant for DefWithBody);
 
 impl DefWithBody {
         });
     }
 
-    source_map
-        .macro_calls()
-        .for_each(|(_ast_id, call_id)| macro_call_diagnostics(db, call_id, acc));
+    source_map.macro_calls().for_each(|(_ast_id, call_id)| macro_call_diagnostics(db, call_id, acc));
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Function {
     pub(crate) id: FunctionId,
     pub fn ret_type(self, db: &dyn HirDatabase) -> Type<'_> {
         let resolver = self.id.resolver(db);
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
-        let ty = db
-            .callable_item_signature(self.id.into())
-            .instantiate_identity()
-            .skip_binder()
-            .output();
+        let ty = db.callable_item_signature(self.id.into()).instantiate_identity().skip_binder().output();
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ret_type_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
         }
         let resolver = self.id.resolver(db);
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
-        let ret_ty = db
-            .callable_item_signature(self.id.into())
-            .instantiate_identity()
-            .skip_binder()
-            .output();
+        let ret_ty = db.callable_item_signature(self.id.into()).instantiate_identity().skip_binder().output();
         for pred in ret_ty.impl_trait_bounds(db).into_iter().flatten() {
             if let ClauseKind::Projection(projection) = pred.kind().skip_binder()
                 && let Some(output_ty) = projection.term.as_type()
     pub fn assoc_fn_params(self, db: &dyn HirDatabase) -> Vec<Param<'_>> {
         let environment = db.trait_environment(self.id.into());
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
-        let callable_sig =
-            db.callable_item_signature(self.id.into()).instantiate_identity().skip_binder();
+        let callable_sig = db.callable_item_signature(self.id.into()).instantiate_identity().skip_binder();
         callable_sig
             .inputs()
             .iter()
     pub fn params_without_self(self, db: &dyn HirDatabase) -> Vec<Param<'_>> {
         let environment = db.trait_environment(self.id.into());
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
-        let callable_sig =
-            db.callable_item_signature(self.id.into()).instantiate_identity().skip_binder();
+        let callable_sig = db.callable_item_signature(self.id.into()).instantiate_identity().skip_binder();
         let skip = if db.function_signature(self.id).has_self_param() { 1 } else { 0 };
         callable_sig
             .inputs()
             .collect()
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn params_without_self_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
         let environment = db.trait_environment(self.id.into());
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(interner, self.id.into(), generics.map(|ty| ty.ty));
-        let callable_sig =
-            db.callable_item_signature(self.id.into()).instantiate(interner, args).skip_binder();
+        let callable_sig = db.callable_item_signature(self.id.into()).instantiate(interner, args).skip_binder();
         let skip = if db.function_signature(self.id).has_self_param() { 1 } else { 0 };
         callable_sig
             .inputs()
     }
 }
 
-// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum Access {
     Shared,
     }
 
     // pub fn parent_closure(&self) -> Option<Closure> {
+
     //     self.func.as_ref().right().cloned()
+
     // }
 
     pub fn index(&self) -> usize {
 
     pub fn ty<'db>(&self, db: &'db dyn HirDatabase) -> Type<'db> {
         // FIXME: This shouldn't be `instantiate_identity()`, we shouldn't leak `TyKind::Param`s.
-        let callable_sig =
-            db.callable_item_signature(self.func.into()).instantiate_identity().skip_binder();
+        let callable_sig = db.callable_item_signature(self.func.into()).instantiate_identity().skip_binder();
         let environment = db.trait_environment(self.func.into());
         let ty = callable_sig.inputs().as_slice()[0];
         Type { env: environment, ty }
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
     ) -> Type<'db> {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(interner, self.func.into(), generics.map(|ty| ty.ty));
-        let callable_sig =
-            db.callable_item_signature(self.func.into()).instantiate(interner, args).skip_binder();
+        let callable_sig = db.callable_item_signature(self.func.into()).instantiate(interner, args).skip_binder();
         let environment = db.trait_environment(self.func.into());
         let ty = callable_sig.inputs().as_slice()[0];
         Type { env: environment, ty }
 }
 
 impl BuiltinType {
-    // Constructors are added on demand, feel free to add more.
     pub fn str() -> BuiltinType {
         BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }
     }
     Const(Const),
     Static(Static),
 }
+
 impl_from!(
     Function,
     Adt(Struct, Enum, Union),
 impl GenericDef {
     pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {
         let generics = db.generic_params(self.into());
-        let ty_params = generics.iter_type_or_consts().map(|(local_id, _)| {
+        let ty_params = generics
+            .iter_type_or_consts()
+            .map(|(local_id, _)| {
             let toc = TypeOrConstParam { id: TypeOrConstParamId { parent: self.into(), local_id } };
             match toc.split(db) {
                 Either::Left(it) => GenericParam::ConstParam(it),
     }
 }
 
-// We cannot call this `Substitution` unfortunately...
 #[derive(Debug)]
 pub struct GenericSubstitution<'db> {
     def: GenericDefId,
                     .collect::<Vec<_>>()
             });
         let generics = db.generic_params(self.def);
-        let type_params = generics.iter_type_or_consts().filter_map(|param| match param.1 {
+        let type_params = generics
+            .iter_type_or_consts()
+            .filter_map(|param| match param.1 {
             TypeOrConstParamData::TypeParamData(param) => Some(param.name.clone()),
             TypeOrConstParamData::ConstParamData(_) => None,
         });
             .iter()
             .filter_map(|param| param.ty())
             .zip(container_type_params.into_iter().flatten());
-        let self_params = self.subst.as_slice()[parent_len..]
-            .iter()
-            .filter_map(|param| param.ty())
-            .zip(type_params);
+        let self_params = self.subst.as_slice()[parent_len..].iter().filter_map(|param| param.ty()).zip(type_params);
         container_params
             .chain(self_params)
             .filter_map(|(ty, name)| {
 impl ToolModule {
     pub(crate) fn by_name(db: &dyn HirDatabase, krate: Crate, name: &str) -> Option<Self> {
         let krate = krate.id;
-        let idx =
-            crate_def_map(db, krate).registered_tools().iter().position(|it| it.as_str() == name)?
+        let idx = crate_def_map(db, krate).registered_tools().iter().position(|it| it.as_str() == name)?
                 as u32;
         Some(ToolModule { krate, idx })
     }
     ConstParam(ConstParam),
     LifetimeParam(LifetimeParam),
 }
+
 impl_from!(TypeParam, ConstParam, LifetimeParam for GenericParam);
 
 impl GenericParam {
         };
 
         let mut all = Vec::new();
-        def_crates.iter().for_each(|&id| {
+        def_crates
+            .iter()
+            .for_each(|&id| {
             all.extend(
                 db.inherent_impls_in_crate(id)
                     .for_self_ty(ty)
             .to_string()
     }
 
-    pub fn display_with_impl(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
+    pub fn display_with_impl(
+        &self,
+        db: &dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
         self.as_ty(db)
             .display(db, display_target)
             .with_closure_style(ClosureStyle::ImplFn)
 
 impl<'db> ClosureCapture<'db> {
     pub fn local(&self) -> Local {
-        Local { parent: self.owner, binding_id: self.capture.local() }
+        Local {
+            parent: self.owner,
+            binding_id: self.capture.local(),
+        }
     }
 
     /// Returns whether this place has any field (aka. non-deref) projections.
     }
 
     pub fn usages(&self) -> CaptureUsages {
-        CaptureUsages { parent: self.owner, spans: self.capture.spans() }
+        CaptureUsages {
+            parent: self.owner,
+            spans: self.capture.spans(),
+        }
     }
 
     pub fn kind(&self) -> CaptureKind {
         Type::new(db, def, ty.instantiate(interner, args))
     }
 
-    // FIXME: We shouldn't leak `TyKind::Param`s.
     fn from_def_params(db: &'db dyn HirDatabase, def: impl Into<TyDefId> + HasResolver) -> Self {
         let ty = db.ty(def.into());
         Type::new(db, def, ty.instantiate_identity())
 
     pub fn new_slice(ty: Self) -> Self {
         let interner = DbInterner::conjure();
-        Type { env: ty.env, ty: Ty::new_slice(interner, ty.ty) }
+        Type {
+            env: ty.env,
+            ty: Ty::new_slice(interner, ty.ty),
+        }
     }
 
     pub fn new_tuple(krate: base_db::Crate, tys: &[Self]) -> Self {
         let tys = tys.iter().map(|it| it.ty);
         let interner = DbInterner::conjure();
-        Type { env: TraitEnvironment::empty(krate), ty: Ty::new_tup_from_iter(interner, tys) }
+        Type {
+            env: TraitEnvironment::empty(krate),
+            ty: Ty::new_tup_from_iter(interner, tys),
+        }
     }
 
     pub fn is_unit(&self) -> bool {
         self.derived(self.ty.strip_references())
     }
 
-    // FIXME: This is the same as `remove_ref()`, remove one of these methods.
     pub fn strip_reference(&self) -> Self {
         self.derived(self.ty.strip_reference())
     }
             return None;
         }
 
-        let output_assoc_type =
-            trait_.trait_items(db).associated_type_by_name(&Name::new_symbol_root(sym::Output))?;
+        let output_assoc_type = trait_.trait_items(db).associated_type_by_name(&Name::new_symbol_root(sym::Output))?;
         self.normalize_trait_assoc_type(db, &[], output_assoc_type.into())
     }
 
         traits::implements_trait_unique(self.ty, db, self.env.clone(), fnonce_trait)
     }
 
-    // FIXME: Find better API that also handles const generics
-    pub fn impls_trait(&self, db: &'db dyn HirDatabase, trait_: Trait, args: &[Type<'db>]) -> bool {
+    pub fn impls_trait(
+        &self,
+        db: &'db dyn HirDatabase,
+        trait_: Trait,
+        args: &[Type<'db>],
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(
             interner,
         autoderef(db, self.env.clone(), canonical)
     }
 
-    // This would be nicer if it just returned an iterator, but that runs into
-    // lifetime problems, because we need to borrow temp `CrateImplDefs`.
     pub fn iterate_assoc_items<T>(
         &self,
         db: &'db dyn HirDatabase,
         mut callback: impl FnMut(AssocItem) -> Option<T>,
     ) -> Option<T> {
         let mut slot = None;
-        self.iterate_assoc_items_dyn(db, krate, &mut |assoc_item_id| {
+        self
+            .iterate_assoc_items_dyn(db, krate, &mut |assoc_item_id| {
             slot = callback(assoc_item_id.into());
             slot.is_some()
         });
     ) -> Option<T> {
         let _p = tracing::info_span!("iterate_method_candidates_with_traits").entered();
         let mut slot = None;
-        self.iterate_method_candidates_split_inherent(
+        self
+            .iterate_method_candidates_split_inherent(
             db,
             scope,
             traits_in_scope,
             traits_in_scope = traits_in_scope.len(),
             ?name,
         )
-        .entered();
+            .entered();
         let interner = DbInterner::new_with(db, None, None);
         // There should be no inference vars in types passed here
         let canonical = hir_ty::replace_errors_with_variables(interner, &self.ty);
         let _p = tracing::info_span!("iterate_path_candidates").entered();
         let mut slot = None;
 
-        self.iterate_path_candidates_split_inherent(
+        self
+            .iterate_path_candidates_split_inherent(
             db,
             scope,
             traits_in_scope,
             }
         }
 
-        let mut visitor =
-            Visitor { db, env: self.env.clone(), callback, visited: FxHashSet::default() };
+        let mut visitor = Visitor { db, env: self.env.clone(), callback, visited: FxHashSet::default() };
         self.ty.visit_with(&mut visitor);
     }
+
     /// Check if type unifies with another type.
     ///
     /// Note that we consider placeholder types to unify with everything.
     }
 
     pub fn to_type(&self, _db: &'db dyn HirDatabase) -> Type<'db> {
-        Type { env: self.env.clone(), ty: self.ty }
+        Type {
+            env: self.env.clone(),
+            ty: self.ty,
+        }
     }
 
-    // FIXME: Find better API that also handles const generics
     pub fn impls_trait(&self, infcx: InferCtxt<'db>, trait_: Trait, args: &[TypeNs<'db>]) -> bool {
         let args = GenericArgs::new_from_iter(
             infcx.interner,
     }
 }
 
-// FIXME: Document this
 #[derive(Debug)]
 pub struct Callable<'db> {
     ty: Type<'db>,
             Callee::FnImpl(fn_) => CallableKind::FnImpl(fn_),
         }
     }
+
     pub fn receiver_param(&self, db: &'db dyn HirDatabase) -> Option<(SelfParam, Type<'db>)> {
         let func = match self.callee {
             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,
             self.ty.derived(self.sig.skip_binder().inputs_and_output.inputs()[0]),
         ))
     }
+
     pub fn n_params(&self) -> usize {
         self.sig.skip_binder().inputs_and_output.inputs().len()
             - if self.is_bound_method { 1 } else { 0 }
     }
+
     pub fn params(&self) -> Vec<Param<'db>> {
         self.sig
             .skip_binder()
             .map(|(idx, ty)| Param { func: self.callee.clone(), idx, ty })
             .collect()
     }
+
     pub fn return_type(&self) -> Type<'db> {
         self.ty.derived(self.sig.skip_binder().output())
     }
+
     pub fn sig(&self) -> impl Eq {
         &self.sig
     }
     }
 
     pub fn enum_tag_size(&self) -> Option<usize> {
-        let tag_size =
-            if let layout::Variants::Multiple { tag, tag_encoding, .. } = &self.0.variants {
+        let tag_size = if let layout::Variants::Multiple { tag, tag_encoding, .. } = &self.0.variants {
                 match tag_encoding {
                     TagEncoding::Direct => tag.size(&*self.1).bytes_usize(),
                     TagEncoding::Niche { .. } => 0,
 
 pub trait HasVisibility {
     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;
+
     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {
         let vis = self.visibility(db);
         vis.is_visible_from(db, module.id)
             defaults.get(param).is_none()
         })
 }
-
-pub use hir_ty::next_solver;
-pub use hir_ty::setup_tracing;