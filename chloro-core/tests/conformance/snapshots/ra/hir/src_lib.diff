COMPARISON DIFF
============================================================

Original size: 227843 bytes
Chloro size:   226519 bytes
Rustfmt size:  227843 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 #![recursion_limit = "512"]
 
-extern crate ra_ap_rustc_type_ir as rustc_type_ir;
 
 mod attrs;
 mod from_id;
 mod has_source;
 mod semantics;
 mod source_analyzer;
-
 pub mod db;
 pub mod diagnostics;
 pub mod symbols;
 pub mod term_search;
-
 mod display;
 
-#[doc(hidden)]
-pub use hir_def::ModuleId;
-
 use std::{
     fmt,
     mem::discriminant,
 use arrayvec::ArrayVec;
 use base_db::{CrateDisplayName, CrateOrigin, LangCrateOrigin};
 use either::Either;
+pub use hir_def::ModuleId;
 use hir_def::{
-    AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
-    CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
-    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
-    LocalFieldId, Lookup, MacroExpander, MacroId, StaticId, StructId, SyntheticSyntax, TupleId,
-    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,
     expr_store::{ExpressionStoreDiagnostics, ExpressionStoreSourceMap},
     hir::{
-        BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, LabelId, Pat,
         generics::{LifetimeParamData, TypeOrConstParamData, TypeParamProvenance},
+        BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, LabelId, Pat,
     },
     item_tree::ImportAlias,
     layout::{self, ReprOptions, TargetDataLayout},
-    nameres::{
-        assoc::TraitItems,
-        diagnostics::{DefDiagnostic, DefDiagnosticKind},
-    },
+    nameres::{assoc::TraitItems, diagnostics::{DefDiagnostic, DefDiagnosticKind}},
     per_ns::PerNs,
     resolver::{HasResolver, Resolver},
     signatures::{ImplFlags, StaticFlags, StructFlags, TraitFlags, VariantFields},
     src::HasSource as _,
     visibility::visibility_from_ast,
+    AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
+    CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
+    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
+    LocalFieldId, Lookup, MacroExpander, MacroId, StaticId, StructId, SyntheticSyntax, TupleId,
+    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,
 };
 use hir_expand::{
-    AstId, MacroCallKind, RenderedExpandError, ValueResult, attrs::collect_attrs,
-    proc_macro::ProcMacroKind,
+    attrs::collect_attrs, proc_macro::ProcMacroKind, AstId, MacroCallKind, RenderedExpandError,
+    ValueResult,
 };
+pub use hir_ty::next_solver;
+pub use hir_ty::setup_tracing;
 use hir_ty::{
-    TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId, all_super_traits, autoderef,
-    check_orphan_rules,
+    all_super_traits, autoderef, check_orphan_rules,
     consteval::try_const_usize,
     db::{InternedClosureId, InternedCoroutineId},
     diagnostics::BodyValidationDiagnostic,
     direct_super_traits, known_const_to_ast,
     layout::{Layout as TyLayout, RustcEnumVariantIdx, RustcFieldIdx, TagEncoding},
     method_resolution,
-    mir::{MutBorrowKind, interpret_mir},
+    mir::{interpret_mir, MutBorrowKind},
     next_solver::{
-        AliasTy, Canonical, ClauseKind, ConstKind, DbInterner, ErrorGuaranteed, GenericArg,
-        GenericArgs, PolyFnSig, Region, SolverDefId, Ty, TyKind, TypingMode,
-        infer::{DbInternerInferExt, InferCtxt},
+        infer::{DbInternerInferExt, InferCtxt}, AliasTy, Canonical, ClauseKind, ConstKind,
+        DbInterner, ErrorGuaranteed, GenericArg, GenericArgs, PolyFnSig, Region, SolverDefId, Ty,
+        TyKind, TypingMode,
     },
-    traits::{self, FnTrait, structurally_normalize_ty},
+    traits::{self, structurally_normalize_ty, FnTrait},
+    TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId,
 };
 use itertools::Itertools;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
-    AliasTyKind, TypeSuperVisitable, TypeVisitable, TypeVisitor,
     inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _},
+    AliasTyKind, TypeSuperVisitable, TypeVisitable, TypeVisitor,
 };
 use smallvec::SmallVec;
 use span::{AstIdNode, Edition, FileId};
 use stdx::{format_to, impl_from, never};
 use syntax::{
-    AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, T, TextRange, ToSmolStr,
     ast::{self, HasAttrs as _, HasName, HasVisibility as _},
-    format_smolstr,
+    format_smolstr, AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, TextRange, ToSmolStr, T,
 };
 use triomphe::{Arc, ThinArc};
-
-use crate::db::{DefDatabase, HirDatabase};
-
-pub use crate::{
-    attrs::{HasAttrs, resolve_doc_path_on},
-    diagnostics::*,
-    has_source::HasSource,
-    semantics::{
-        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
-        VisibleTraits,
-    },
-};
-
-// Be careful with these re-exports.
-//
-// `hir` is the boundary between the compiler and the IDE. It should try hard to
-// isolate the compiler from the ide, to allow the two to be refactored
-// independently. Re-exporting something from the compiler is the sure way to
-// breach the boundary.
-//
-// Generally, a refactoring which *removes* a name from this list is a good
-// idea!
 pub use {
     cfg::{CfgAtom, CfgExpr, CfgOptions},
     hir_def::{
-        Complete,
-        FindPathConfig,
-        attr::{AttrSourceMap, Attrs, AttrsWithOwner},
-        find_path::PrefixKind,
-        import_map,
-        lang_item::LangItem,
-        nameres::{DefMap, ModuleSource, crate_def_map},
-        per_ns::Namespace,
-        type_ref::{Mutability, TypeRef},
-        visibility::Visibility,
+        attr::{AttrSourceMap, Attrs, AttrsWithOwner}, find_path::PrefixKind, import_map,
+        lang_item::LangItem, nameres::{DefMap, ModuleSource, crate_def_map}, per_ns::Namespace,
+        type_ref::{Mutability, TypeRef}, visibility::Visibility,
         // FIXME: This is here since some queries take it as input that are used
         // outside of hir.
         {ModuleDefId, TraitId},
+        Complete, FindPathConfig,
     },
     hir_expand::{
-        EditionedFileId, ExpandResult, HirFileId, MacroCallId, MacroKind,
-        attrs::{Attr, AttrId},
-        change::ChangeWithProcMacros,
+        attrs::{Attr, AttrId}, change::ChangeWithProcMacros,
         files::{
             FilePosition, FilePositionWrapper, FileRange, FileRangeWrapper, HirFilePosition,
             HirFileRange, InFile, InFileWrapper, InMacroFile, InRealFile, MacroFilePosition,
             MacroFileRange,
         },
-        inert_attr_macro::AttributeTemplate,
-        mod_path::{ModPath, PathKind, tool_path},
-        name::Name,
-        prettify_macro_expansion,
-        proc_macro::{ProcMacros, ProcMacrosBuilder},
-        tt,
+        inert_attr_macro::AttributeTemplate, mod_path::{ModPath, PathKind, tool_path}, name::Name,
+        prettify_macro_expansion, proc_macro::{ProcMacros, ProcMacrosBuilder}, tt,
+        EditionedFileId, ExpandResult, HirFileId, MacroCallId, MacroKind,
     },
+    hir_ty::{
+        attach_db, attach_db_allow_change, consteval::ConstEvalError, diagnostics::UnsafetyReason,
+        display::{ClosureStyle, DisplayTarget, HirDisplay, HirDisplayError, HirWrite},
+        drop::DropGlue, dyn_compatibility::{DynCompatibilityViolation, MethodViolationCode},
+        layout::LayoutError, method_resolution::TyFingerprint, mir::{MirEvalError, MirLowerError},
+        next_solver::abi::Safety, next_solver::clear_tls_solver_cache, CastError, FnAbi,
+        PointerCast,
+    },
+    intern::{sym, Symbol},
     // FIXME: Properly encapsulate mir
     hir_ty::mir,
-    hir_ty::{
-        CastError, FnAbi, PointerCast, attach_db, attach_db_allow_change,
-        consteval::ConstEvalError,
-        diagnostics::UnsafetyReason,
-        display::{ClosureStyle, DisplayTarget, HirDisplay, HirDisplayError, HirWrite},
-        drop::DropGlue,
-        dyn_compatibility::{DynCompatibilityViolation, MethodViolationCode},
-        layout::LayoutError,
-        method_resolution::TyFingerprint,
-        mir::{MirEvalError, MirLowerError},
-        next_solver::abi::Safety,
-        next_solver::clear_tls_solver_cache,
-    },
-    intern::{Symbol, sym},
 };
-
-// These are negative re-exports: pub using these names is forbidden, they
-// should remain private to hir internals.
-#[allow(unused)]
 use {
     hir_def::expr_store::path::Path,
-    hir_expand::{
-        name::AsName,
-        span_map::{ExpansionSpanMap, RealSpanMap, SpanMap, SpanMapRef},
+    hir_expand::{name::AsName, span_map::{ExpansionSpanMap, RealSpanMap, SpanMap, SpanMapRef}},
+};
+
+use crate::db::{DefDatabase, HirDatabase};
+pub use crate::{
+    attrs::{resolve_doc_path_on, HasAttrs},
+    diagnostics::*,
+    has_source::HasSource,
+    semantics::{
+        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
+        VisibleTraits,
     },
 };
 
     BuiltinType(BuiltinType),
     Macro(Macro),
 }
+
 impl_from!(
     Module,
     Function,
     }
 
     pub fn attrs(&self, db: &dyn HirDatabase) -> Option<AttrsWithOwner> {
-        Some(match self {
+        Some(
+            match self {
             ModuleDef::Module(it) => it.attrs(db),
             ModuleDef::Function(it) => it.attrs(db),
             ModuleDef::Adt(it) => it.attrs(db),
             ModuleDef::TypeAlias(it) => it.attrs(db),
             ModuleDef::Macro(it) => it.attrs(db),
             ModuleDef::BuiltinType(_) => return None,
-        })
+        },
+        )
     }
 }
 
         TypeNs::new(db, var_id, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
             .map(|(id, _)| Field { parent: self.into(), id })
             .collect()
     }
+
     pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Variant {
     pub(crate) id: EnumVariantId,
     pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {
         let parent_enum = self.parent_enum(db);
         let parent_layout = parent_enum.layout(db)?;
-        Ok(match &parent_layout.0.variants {
+        Ok(
+            match &parent_layout.0.variants {
             layout::Variants::Multiple { variants, .. } => Layout(
                 {
                     let lookup = self.id.lookup(db);
                 db.target_data_layout(parent_enum.krate(db).into()).unwrap(),
             ),
             _ => parent_layout,
-        })
+        },
+        )
     }
 
     pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct InstantiatedVariant<'db> {
     pub(crate) inner: Variant,
 
 impl<'db> InstantiatedVariant<'db> {
     pub fn parent_enum(self, db: &dyn HirDatabase) -> InstantiatedEnum<'db> {
-        InstantiatedEnum { inner: self.inner.id.lookup(db).parent.into(), args: self.args }
+        InstantiatedEnum {
+            inner: self.inner.id.lookup(db).parent.into(),
+            args: self.args,
+        }
     }
 
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<InstantiatedField<'db>> {
     Union(Union),
     Enum(Enum),
 }
+
 impl_from!(Struct, Union, Enum for Adt);
 
 impl Adt {
     Union(Union),
     Variant(Variant),
 }
+
 impl_from!(Struct, Union, Variant for VariantDef);
 
 impl VariantDef {
     Const(Const),
     Variant(Variant),
 }
+
 impl_from!(Function, Const, Static, Variant for DefWithBody);
 
 impl DefWithBody {
         .macro_calls()
         .for_each(|(_ast_id, call_id)| macro_call_diagnostics(db, call_id, acc));
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Function {
     pub(crate) id: FunctionId,
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ret_type_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
             .collect()
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn params_without_self_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
     }
 }
 
-// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum Access {
     Shared,
     }
 
     // pub fn parent_closure(&self) -> Option<Closure> {
+
     //     self.func.as_ref().right().cloned()
+
     // }
 
     pub fn index(&self) -> usize {
         Type { env: environment, ty }
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
 }
 
 impl BuiltinType {
-    // Constructors are added on demand, feel free to add more.
     pub fn str() -> BuiltinType {
         BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }
     }
     Const(Const),
     Static(Static),
 }
+
 impl_from!(
     Function,
     Adt(Struct, Enum, Union),
     }
 }
 
-// We cannot call this `Substitution` unfortunately...
 #[derive(Debug)]
 pub struct GenericSubstitution<'db> {
     def: GenericDefId,
     }
 
     pub fn name(&self) -> Name {
-        Name::new_symbol_root(Symbol::intern(
-            hir_expand::inert_attr_macro::INERT_ATTRIBUTES[self.idx as usize].name,
-        ))
+        Name::new_symbol_root(
+            Symbol::intern(hir_expand::inert_attr_macro::INERT_ATTRIBUTES[self.idx as usize].name),
+        )
     }
 
     pub fn template(&self) -> Option<AttributeTemplate> {
     ConstParam(ConstParam),
     LifetimeParam(LifetimeParam),
 }
+
 impl_from!(TypeParam, ConstParam, LifetimeParam for GenericParam);
 
 impl GenericParam {
             .to_string()
     }
 
-    pub fn display_with_impl(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
+    pub fn display_with_impl(
+        &self,
+        db: &dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
         self.as_ty(db)
             .display(db, display_target)
             .with_closure_style(ClosureStyle::ImplFn)
 
 impl<'db> ClosureCapture<'db> {
     pub fn local(&self) -> Local {
-        Local { parent: self.owner, binding_id: self.capture.local() }
+        Local {
+            parent: self.owner,
+            binding_id: self.capture.local(),
+        }
     }
 
     /// Returns whether this place has any field (aka. non-deref) projections.
     }
 
     pub fn usages(&self) -> CaptureUsages {
-        CaptureUsages { parent: self.owner, spans: self.capture.spans() }
+        CaptureUsages {
+            parent: self.owner,
+            spans: self.capture.spans(),
+        }
     }
 
     pub fn kind(&self) -> CaptureKind {
         Type::new(db, def, ty.instantiate(interner, args))
     }
 
-    // FIXME: We shouldn't leak `TyKind::Param`s.
     fn from_def_params(db: &'db dyn HirDatabase, def: impl Into<TyDefId> + HasResolver) -> Self {
         let ty = db.ty(def.into());
         Type::new(db, def, ty.instantiate_identity())
 
     pub fn new_slice(ty: Self) -> Self {
         let interner = DbInterner::conjure();
-        Type { env: ty.env, ty: Ty::new_slice(interner, ty.ty) }
+        Type {
+            env: ty.env,
+            ty: Ty::new_slice(interner, ty.ty),
+        }
     }
 
     pub fn new_tuple(krate: base_db::Crate, tys: &[Self]) -> Self {
         let tys = tys.iter().map(|it| it.ty);
         let interner = DbInterner::conjure();
-        Type { env: TraitEnvironment::empty(krate), ty: Ty::new_tup_from_iter(interner, tys) }
+        Type {
+            env: TraitEnvironment::empty(krate),
+            ty: Ty::new_tup_from_iter(interner, tys),
+        }
     }
 
     pub fn is_unit(&self) -> bool {
         self.derived(self.ty.strip_references())
     }
 
-    // FIXME: This is the same as `remove_ref()`, remove one of these methods.
     pub fn strip_reference(&self) -> Self {
         self.derived(self.ty.strip_reference())
     }
         traits::implements_trait_unique(self.ty, db, self.env.clone(), fnonce_trait)
     }
 
-    // FIXME: Find better API that also handles const generics
-    pub fn impls_trait(&self, db: &'db dyn HirDatabase, trait_: Trait, args: &[Type<'db>]) -> bool {
+    pub fn impls_trait(
+        &self,
+        db: &'db dyn HirDatabase,
+        trait_: Trait,
+        args: &[Type<'db>],
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(
             interner,
         autoderef(db, self.env.clone(), canonical)
     }
 
-    // This would be nicer if it just returned an iterator, but that runs into
-    // lifetime problems, because we need to borrow temp `CrateImplDefs`.
     pub fn iterate_assoc_items<T>(
         &self,
         db: &'db dyn HirDatabase,
             Visitor { db, env: self.env.clone(), callback, visited: FxHashSet::default() };
         self.ty.visit_with(&mut visitor);
     }
+
     /// Check if type unifies with another type.
     ///
     /// Note that we consider placeholder types to unify with everything.
     }
 
     pub fn to_type(&self, _db: &'db dyn HirDatabase) -> Type<'db> {
-        Type { env: self.env.clone(), ty: self.ty }
+        Type {
+            env: self.env.clone(),
+            ty: self.ty,
+        }
     }
 
-    // FIXME: Find better API that also handles const generics
     pub fn impls_trait(&self, infcx: InferCtxt<'db>, trait_: Trait, args: &[TypeNs<'db>]) -> bool {
         let args = GenericArgs::new_from_iter(
             infcx.interner,
     }
 }
 
-// FIXME: Document this
 #[derive(Debug)]
 pub struct Callable<'db> {
     ty: Type<'db>,
             Callee::FnImpl(fn_) => CallableKind::FnImpl(fn_),
         }
     }
+
     pub fn receiver_param(&self, db: &'db dyn HirDatabase) -> Option<(SelfParam, Type<'db>)> {
         let func = match self.callee {
             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,
             _ => return None,
         };
         let func = Function { id: func };
-        Some((
+        Some(
+            (
             func.self_param(db)?,
             self.ty.derived(self.sig.skip_binder().inputs_and_output.inputs()[0]),
-        ))
+        ),
+        )
     }
+
     pub fn n_params(&self) -> usize {
         self.sig.skip_binder().inputs_and_output.inputs().len()
             - if self.is_bound_method { 1 } else { 0 }
     }
+
     pub fn params(&self) -> Vec<Param<'db>> {
         self.sig
             .skip_binder()
             .map(|(idx, ty)| Param { func: self.callee.clone(), idx, ty })
             .collect()
     }
+
     pub fn return_type(&self) -> Type<'db> {
         self.ty.derived(self.sig.skip_binder().output())
     }
+
     pub fn sig(&self) -> impl Eq {
         &self.sig
     }
 
 pub trait HasVisibility {
     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;
+
     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {
         let vis = self.visibility(db);
         vis.is_visible_from(db, module.id)
     args: impl IntoIterator<Item = Ty<'db>>,
 ) -> GenericArgs<'db> {
     let mut args = args.into_iter();
-    GenericArgs::for_item(interner, def_id, |_, id, _| {
+    GenericArgs::for_item(
+        interner,
+        def_id,
+        |_, id, _| {
         if matches!(id, GenericParamId::TypeParamId(_))
             && let Some(arg) = args.next()
         {
         } else {
             next_solver::GenericArg::error_from_id(interner, id)
         }
-    })
+    },
+    )
 }
 
 fn has_non_default_type_params(db: &dyn HirDatabase, generic_def: GenericDefId) -> bool {
             defaults.get(param).is_none()
         })
 }
-
-pub use hir_ty::next_solver;
-pub use hir_ty::setup_tracing;