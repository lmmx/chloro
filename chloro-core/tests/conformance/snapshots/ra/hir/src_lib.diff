COMPARISON DIFF
============================================================

Original size: 227843 bytes
Chloro size:   225785 bytes
Rustfmt size:  227843 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 #![recursion_limit = "512"]
 
-extern crate ra_ap_rustc_type_ir as rustc_type_ir;
 
 mod attrs;
 mod from_id;
 mod has_source;
 mod semantics;
 mod source_analyzer;
-
 pub mod db;
 pub mod diagnostics;
 pub mod symbols;
 pub mod term_search;
-
 mod display;
 
-#[doc(hidden)]
-pub use hir_def::ModuleId;
-
 use std::{
     fmt,
     mem::discriminant,
 use arrayvec::ArrayVec;
 use base_db::{CrateDisplayName, CrateOrigin, LangCrateOrigin};
 use either::Either;
+pub use hir_def::ModuleId;
 use hir_def::{
-    AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
-    CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
-    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
-    LocalFieldId, Lookup, MacroExpander, MacroId, StaticId, StructId, SyntheticSyntax, TupleId,
-    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,
     expr_store::{ExpressionStoreDiagnostics, ExpressionStoreSourceMap},
     hir::{
         BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, LabelId, Pat,
     signatures::{ImplFlags, StaticFlags, StructFlags, TraitFlags, VariantFields},
     src::HasSource as _,
     visibility::visibility_from_ast,
+    AdtId, AssocItemId, AssocItemLoc, AttrDefId, CallableDefId, ConstId, ConstParamId,
+    CrateRootModuleId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId, ExternCrateId,
+    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,
+    LocalFieldId, Lookup, MacroExpander, MacroId, StaticId, StructId, SyntheticSyntax, TupleId,
+    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,
 };
 use hir_expand::{
-    AstId, MacroCallKind, RenderedExpandError, ValueResult, attrs::collect_attrs,
+    attrs::collect_attrs,
     proc_macro::ProcMacroKind,
+    AstId, MacroCallKind, RenderedExpandError, ValueResult,
 };
+pub use hir_ty::next_solver;
+pub use hir_ty::setup_tracing;
 use hir_ty::{
-    TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId, all_super_traits, autoderef,
-    check_orphan_rules,
+    all_super_traits, autoderef, check_orphan_rules,
     consteval::try_const_usize,
     db::{InternedClosureId, InternedCoroutineId},
     diagnostics::BodyValidationDiagnostic,
         infer::{DbInternerInferExt, InferCtxt},
     },
     traits::{self, FnTrait, structurally_normalize_ty},
+    TraitEnvironment, TyDefId, TyLoweringDiagnostic, ValueTyDefId,
 };
 use itertools::Itertools;
 use rustc_hash::FxHashSet;
 use rustc_type_ir::{
-    AliasTyKind, TypeSuperVisitable, TypeVisitable, TypeVisitor,
     inherent::{AdtDef, GenericArgs as _, IntoKind, SliceLike, Term as _, Ty as _},
+    AliasTyKind, TypeSuperVisitable, TypeVisitable, TypeVisitor,
 };
 use smallvec::SmallVec;
 use span::{AstIdNode, Edition, FileId};
 use stdx::{format_to, impl_from, never};
 use syntax::{
-    AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, T, TextRange, ToSmolStr,
     ast::{self, HasAttrs as _, HasName, HasVisibility as _},
-    format_smolstr,
+    format_smolstr, AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, TextRange, ToSmolStr, T,
 };
 use triomphe::{Arc, ThinArc};
-
-use crate::db::{DefDatabase, HirDatabase};
-
-pub use crate::{
-    attrs::{HasAttrs, resolve_doc_path_on},
-    diagnostics::*,
-    has_source::HasSource,
-    semantics::{
-        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
-        VisibleTraits,
-    },
-};
-
-// Be careful with these re-exports.
-//
-// `hir` is the boundary between the compiler and the IDE. It should try hard to
-// isolate the compiler from the ide, to allow the two to be refactored
-// independently. Re-exporting something from the compiler is the sure way to
-// breach the boundary.
-//
-// Generally, a refactoring which *removes* a name from this list is a good
-// idea!
 pub use {
     cfg::{CfgAtom, CfgExpr, CfgOptions},
     hir_def::{
         proc_macro::{ProcMacros, ProcMacrosBuilder},
         tt,
     },
-    // FIXME: Properly encapsulate mir
-    hir_ty::mir,
     hir_ty::{
         CastError, FnAbi, PointerCast, attach_db, attach_db_allow_change,
         consteval::ConstEvalError,
         next_solver::clear_tls_solver_cache,
     },
     intern::{Symbol, sym},
+    // FIXME: Properly encapsulate mir
+    hir_ty::mir,
 };
-
-// These are negative re-exports: pub using these names is forbidden, they
-// should remain private to hir internals.
-#[allow(unused)]
 use {
     hir_def::expr_store::path::Path,
     hir_expand::{
     },
 };
 
+use crate::db::{DefDatabase, HirDatabase};
+pub use crate::{
+    attrs::{HasAttrs, resolve_doc_path_on},
+    diagnostics::*,
+    has_source::HasSource,
+    semantics::{
+        PathResolution, PathResolutionPerNs, Semantics, SemanticsImpl, SemanticsScope, TypeInfo,
+        VisibleTraits,
+    },
+};
+
 /// hir::Crate describes a single crate. It's the main interface with which
 /// a crate's dependencies interact. Mostly, it should be just a proxy for the
 /// root module.
     Module(Module),
     Function(Function),
     Adt(Adt),
-    // Can't be directly declared, but can be imported.
-    // FIXME: Rename to `EnumVariant`
     Variant(Variant),
     Const(Const),
     Static(Static),
     BuiltinType(BuiltinType),
     Macro(Macro),
 }
-impl_from!(
-    Module,
-    Function,
-    Adt(Struct, Enum, Union),
-    Variant,
-    Const,
-    Static,
-    Trait,
-    TypeAlias,
-    BuiltinType,
-    Macro
-    for ModuleDef
-);
-
 impl From<VariantDef> for ModuleDef {
     fn from(var: VariantDef) -> Self {
         match var {
             ModuleDef::Variant(it) => it.id.into(),
             ModuleDef::BuiltinType(_) | ModuleDef::Macro(_) => return Vec::new(),
         };
-
         let mut acc = Vec::new();
-
         match self.as_def_with_body() {
             Some(def) => {
                 def.diagnostics(db, &mut acc, style_lints);
                 }
             }
         }
-
         if let Some(def) = self.as_self_generic_def() {
             def.diagnostics(db, &mut acc);
         }
-
         acc
     }
 
             }
             emit_def_diagnostic(db, acc, diag, edition);
         }
-
         if !self.id.is_block_module() {
             // These are reported by the body of block modules
             let scope = &def_map[self.id.local_id].scope;
             scope.all_macro_calls().for_each(|it| macro_call_diagnostics(db, it, acc));
         }
-
         for def in self.declarations(db) {
             match def {
                 ModuleDef::Module(m) => {
             }
         }
         self.legacy_macros(db).into_iter().for_each(|m| emit_macro_def_diagnostics(db, acc, m));
-
         let inherent_impls = db.inherent_impls_in_crate(self.id.krate());
-
         let interner = DbInterner::new_with(db, Some(self.id.krate()), self.id.containing_block());
         let infcx = interner.infer_ctxt().build(TypingMode::non_body_analysis());
-
         let mut impl_assoc_items_scratch = vec![];
         for impl_def in self.impl_defs(db) {
             GenericDef::Impl(impl_def).diagnostics(db, acc);
         };
         acc.push(MacroError { node, precise_location, message, error, kind }.into());
     }
-
     if !parse_errors.is_empty() {
         let loc = db.lookup_intern_macro_call(macro_call_id);
         let (node, precise_location) = precise_macro_call_location(&loc.kind, db);
     pub fn ty(&self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let var_id = self.inner.parent.into();
         let field = db.field_types(var_id)[self.inner.id];
         let ty = field.instantiate(interner, self.args);
 impl AstNode for FieldSource {
     fn can_cast(kind: syntax::SyntaxKind) -> bool
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         ast::RecordField::can_cast(kind) || ast::TupleField::can_cast(kind)
     }
 
     fn cast(syntax: SyntaxNode) -> Option<Self>
     where
-        Self: Sized,
-    {
+        Self: Sized, {
         if ast::RecordField::can_cast(syntax.kind()) {
             <ast::RecordField as AstNode>::cast(syntax).map(FieldSource::Named)
         } else if ast::TupleField::can_cast(syntax.kind()) {
         TypeNs::new(db, var_id, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
     pub fn ty(self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let ty = db.ty(self.inner.id.into());
         TypeNs::new(db, self.inner.id, ty.instantiate(interner, self.args))
     }
             .map(|(id, _)| Field { parent: self.into(), id })
             .collect()
     }
+
     pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
     pub fn ty(self, db: &'db dyn HirDatabase) -> TypeNs<'db> {
         let krate = self.inner.krate(db);
         let interner = DbInterner::new_with(db, Some(krate.base()), None);
-
         let ty = db.ty(self.inner.id.into());
         TypeNs::new(db, self.inner.id, ty.instantiate(interner, self.args))
     }
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Variant {
     pub(crate) id: EnumVariantId,
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct InstantiatedVariant<'db> {
     pub(crate) inner: Variant,
 
 impl<'db> InstantiatedVariant<'db> {
     pub fn parent_enum(self, db: &dyn HirDatabase) -> InstantiatedEnum<'db> {
-        InstantiatedEnum { inner: self.inner.id.lookup(db).parent.into(), args: self.args }
+        InstantiatedEnum {
+            inner: self.inner.id.lookup(db).parent.into(),
+            args: self.args,
+        }
     }
 
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<InstantiatedField<'db>> {
     Union(Union),
     Enum(Enum),
 }
-impl_from!(Struct, Union, Enum for Adt);
-
 impl Adt {
     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {
         has_non_default_type_params(db, self.into())
     Union(Union),
     Variant(Variant),
 }
-impl_from!(Struct, Union, Variant for VariantDef);
-
 impl VariantDef {
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {
         match self {
     Const(Const),
     Variant(Variant),
 }
-impl_from!(Function, Const, Static, Variant for DefWithBody);
-
 impl DefWithBody {
     pub fn module(self, db: &dyn HirDatabase) -> Module {
         match self {
         style_lints: bool,
     ) {
         let krate = self.module(db).id.krate();
-
         let (body, source_map) = db.body_with_source_map(self.into());
         let sig_source_map = match self {
             DefWithBody::Function(id) => db.function_signature_with_source_map(id.into()).1,
                 db.enum_signature_with_source_map(enum_id).1
             }
         };
-
         for (_, def_map) in body.blocks(db) {
             Module { id: def_map.module_id(DefMap::ROOT) }.diagnostics(db, acc, style_lints);
         }
-
         expr_store_diagnostics(db, acc, &source_map);
-
         let infer = db.infer(self.into());
         for d in infer.diagnostics() {
             acc.extend(AnyDiagnostic::inference_diagnostic(
                 &sig_source_map,
             ));
         }
-
         for (pat_or_expr, mismatch) in infer.type_mismatches() {
             let expr_or_pat = match pat_or_expr {
                 ExprOrPatId::ExprId(expr) => source_map.expr_syntax(expr).map(Either::Left),
                 .into(),
             );
         }
-
         let missing_unsafe = hir_ty::diagnostics::missing_unsafe(db, self.into());
         for (node, reason) in missing_unsafe.unsafe_exprs {
             match source_map.expr_or_pat_syntax(node) {
                 Err(SyntheticSyntax) => never!("synthetic DeprecatedSafe2024"),
             }
         }
-
         if let Ok(borrowck_results) = db.borrowck(self.into()) {
             for borrowck_result in borrowck_results.iter() {
                 let mir_body = &borrowck_result.mir_body;
                 }
             }
         }
-
         for diagnostic in BodyValidationDiagnostic::collect(db, self.into(), style_lints) {
             acc.extend(AnyDiagnostic::body_validation_diagnostic(db, diagnostic, &source_map));
         }
-
         let def: ModuleDef = match self {
             DefWithBody::Function(it) => it.into(),
             DefWithBody::Static(it) => it.into(),
             }
         });
     }
-
     source_map
         .macro_calls()
         .for_each(|(_ast_id, call_id)| macro_call_diagnostics(db, call_id, acc));
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Function {
     pub(crate) id: FunctionId,
         let ty = Ty::new_fn_ptr(interner, callable_sig);
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
-
     // FIXME: Find a better API to express all combinations here, perhaps we should have `PreInstantiationType`?
 
     /// Get this function's return type
         Type::new_with_resolver_inner(db, &resolver, ty)
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ret_type_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
         let resolver = self.id.resolver(db);
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(interner, self.id.into(), generics.map(|ty| ty.ty));
-
         let interner = DbInterner::new_with(db, None, None);
         let ty = db
             .callable_item_signature(self.id.into())
             .collect()
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn params_without_self_with_args<'db>(
         self,
         db: &'db dyn HirDatabase,
         if self.is_async(db) {
             return true;
         }
-
         let ret_type = self.ret_type(db);
         let Some(impl_traits) = ret_type.as_impl_traits(db) else { return false };
         let Some(future_trait_id) = LangItem::Future.resolve_trait(db, self.ty(db).env.krate)
         let Some(sized_trait_id) = LangItem::Sized.resolve_trait(db, self.ty(db).env.krate) else {
             return false;
         };
-
         let mut has_impl_future = false;
         impl_traits
             .filter(|t| {
     }
 }
 
-// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum Access {
     Shared,
             _ => None,
         }
     }
-
     // pub fn parent_closure(&self) -> Option<Closure> {
     //     self.func.as_ref().right().cloned()
     // }
         Type { env: environment, ty }
     }
 
-    // FIXME: Find better API to also handle const generics
     pub fn ty_with_args<'db>(
         &self,
         db: &'db dyn HirDatabase,
 }
 
 impl BuiltinType {
-    // Constructors are added on demand, feel free to add more.
     pub fn str() -> BuiltinType {
         BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }
     }
 where
     ID: Lookup<Database = dyn DefDatabase, Data = AssocItemLoc<LOC>>,
     DEF: From<ID>,
-    LOC: AstIdNode,
-{
+    LOC: AstIdNode, {
     match id.lookup(db).container {
         ItemContainerId::TraitId(_) | ItemContainerId::ImplId(_) => Some(ctor(DEF::from(id))),
         ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => None,
 where
     ID: Lookup<Database = dyn DefDatabase, Data = AssocItemLoc<LOC>>,
     DEF: From<ID>,
-    LOC: AstIdNode,
-{
+    LOC: AstIdNode, {
     match id.lookup(db).container {
         ItemContainerId::ExternBlockId(_) => Some(ctor(DEF::from(id))),
         ItemContainerId::TraitId(_) | ItemContainerId::ImplId(_) | ItemContainerId::ModuleId(_) => {
     Trait(Trait),
     TypeAlias(TypeAlias),
     Impl(Impl),
-    // consts can have type parameters from their parents (i.e. associated consts of traits)
     Const(Const),
     Static(Static),
 }
-impl_from!(
-    Function,
-    Adt(Struct, Enum, Union),
-    Trait,
-    TypeAlias,
-    Impl,
-    Const,
-    Static
-    for GenericDef
-);
-
 impl GenericDef {
     pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {
         let generics = db.generic_params(self.into());
 
     pub fn diagnostics<'db>(self, db: &'db dyn HirDatabase, acc: &mut Vec<AnyDiagnostic<'db>>) {
         let def = self.id();
-
         let generics = db.generic_params(def);
-
         if generics.is_empty() && generics.has_no_predicates() {
             return;
         }
-
         let source_map = match def {
             GenericDefId::AdtId(AdtId::EnumId(it)) => db.enum_signature_with_source_map(it).1,
             GenericDefId::AdtId(AdtId::StructId(it)) => db.struct_signature_with_source_map(it).1,
             GenericDefId::TraitId(it) => db.trait_signature_with_source_map(it).1,
             GenericDefId::TypeAliasId(it) => db.type_alias_signature_with_source_map(it).1,
         };
-
         expr_store_diagnostics(db, acc, &source_map);
         push_ty_diagnostics(db, acc, db.generic_defaults_with_diagnostics(def).1, &source_map);
         push_ty_diagnostics(
     }
 }
 
-// We cannot call this `Substitution` unfortunately...
 #[derive(Debug)]
 pub struct GenericSubstitution<'db> {
     def: GenericDefId,
     ConstParam(ConstParam),
     LifetimeParam(LifetimeParam),
 }
-impl_from!(TypeParam, ConstParam, LifetimeParam for GenericParam);
-
 impl GenericParam {
     pub fn module(self, db: &dyn HirDatabase) -> Module {
         match self {
     pub fn all_in_crate(db: &dyn HirDatabase, krate: Crate) -> Vec<Impl> {
         let inherent = db.inherent_impls_in_crate(krate.id);
         let trait_ = db.trait_impls_in_crate(krate.id);
-
         inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()
     }
 
             Some(def_crates) => def_crates,
             None => return Vec::new(),
         };
-
         let filter = |impl_def: &Impl| {
             let self_ty = impl_def.self_ty(db);
             let rref = self_ty.remove_ref();
             ty.equals_ctor(rref.as_ref().map_or(self_ty.ty, |it| it.ty))
         };
-
         let fp = TyFingerprint::for_inherent_impl(ty);
         let fp = match fp {
             Some(fp) => fp,
             None => return Vec::new(),
         };
-
         let mut all = Vec::new();
         def_crates.iter().for_each(|&id| {
             all.extend(
                     .filter(filter),
             )
         });
-
         for id in def_crates
             .iter()
             .flat_map(|&id| Crate { id }.transitive_reverse_dependencies(db))
                     .filter(filter),
             );
         }
-
         if let Some(block) = ty.as_adt().and_then(|(def, _)| def.module(db).containing_block()) {
             if let Some(inherent_impls) = db.inherent_impls_in_block(block) {
                 all.extend(
                 );
             }
         }
-
         all
     }
 
 
     pub fn as_builtin_derive_path(self, db: &dyn HirDatabase) -> Option<InMacroFile<ast::Path>> {
         let src = self.source(db)?;
-
         let macro_file = src.file_id.macro_file()?;
         let loc = macro_file.lookup(db);
         let (derive_attr, derive_index) = match loc.kind {
             .to_string()
     }
 
-    pub fn display_with_impl(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
+    pub fn display_with_impl(
+        &self,
+        db: &dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
         self.as_ty(db)
             .display(db, display_target)
             .with_closure_style(ClosureStyle::ImplFn)
 
 impl<'db> ClosureCapture<'db> {
     pub fn local(&self) -> Local {
-        Local { parent: self.owner, binding_id: self.capture.local() }
+        Local {
+            parent: self.owner,
+            binding_id: self.capture.local(),
+        }
     }
 
     /// Returns whether this place has any field (aka. non-deref) projections.
     }
 
     pub fn usages(&self) -> CaptureUsages {
-        CaptureUsages { parent: self.owner, spans: self.capture.spans() }
+        CaptureUsages {
+            parent: self.owner,
+            spans: self.capture.spans(),
+        }
     }
 
     pub fn kind(&self) -> CaptureKind {
 impl CaptureUsages {
     pub fn sources(&self, db: &dyn HirDatabase) -> Vec<CaptureUsageSource> {
         let (body, source_map) = db.body_with_source_map(self.parent);
-
         let mut result = Vec::with_capacity(self.spans.len());
         for &span in self.spans.iter() {
             let is_ref = span.is_ref_span(&body);
         Type::new(db, def, ty.instantiate(interner, args))
     }
 
-    // FIXME: We shouldn't leak `TyKind::Param`s.
     fn from_def_params(db: &'db dyn HirDatabase, def: impl Into<TyDefId> + HasResolver) -> Self {
         let ty = db.ty(def.into());
         Type::new(db, def, ty.instantiate_identity())
 
     pub fn new_slice(ty: Self) -> Self {
         let interner = DbInterner::conjure();
-        Type { env: ty.env, ty: Ty::new_slice(interner, ty.ty) }
+        Type {
+            env: ty.env,
+            ty: Ty::new_slice(interner, ty.ty),
+        }
     }
 
     pub fn new_tuple(krate: base_db::Crate, tys: &[Self]) -> Self {
         let tys = tys.iter().map(|it| it.ty);
         let interner = DbInterner::conjure();
-        Type { env: TraitEnvironment::empty(krate), ty: Ty::new_tup_from_iter(interner, tys) }
+        Type {
+            env: TraitEnvironment::empty(krate),
+            ty: Ty::new_tup_from_iter(interner, tys),
+        }
     }
 
     pub fn is_unit(&self) -> bool {
     pub fn contains_reference(&self, db: &'db dyn HirDatabase) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         return self.ty.visit_with(&mut Visitor { interner }).is_break();
-
         fn is_phantom_data(db: &dyn HirDatabase, adt_id: AdtId) -> bool {
             match adt_id {
                 AdtId::StructId(s) => {
                 AdtId::UnionId(_) | AdtId::EnumId(_) => false,
             }
         }
-
         struct Visitor<'db> {
             interner: DbInterner<'db>,
         }
-
         impl<'db> TypeVisitor<DbInterner<'db>> for Visitor<'db> {
             type Result = ControlFlow<()>;
 
         self.derived(self.ty.strip_references())
     }
 
-    // FIXME: This is the same as `remove_ref()`, remove one of these methods.
     pub fn strip_reference(&self) -> Self {
         self.derived(self.ty.strip_reference())
     }
                 Some(into_future_trait.id)
             })
             .or_else(|| LangItem::Future.resolve_trait(db, self.env.krate))?;
-
         if !traits::implements_trait_unique(self.ty, db, self.env.clone(), trait_) {
             return None;
         }
-
         let output_assoc_type =
             trait_.trait_items(db).associated_type_by_name(&Name::new_symbol_root(sym::Output))?;
         self.normalize_trait_assoc_type(db, &[], output_assoc_type.into())
                 Some(into_iter_trait.id)
             },
         )?;
-
         if !traits::implements_trait_unique(self.ty, db, self.env.clone(), trait_) {
             return None;
         }
-
         let into_iter_assoc_type = trait_
             .trait_items(db)
             .associated_type_by_name(&Name::new_symbol_root(sym::IntoIter))?;
             Some(it) => it,
             None => return false,
         };
-
         traits::implements_trait_unique(self.ty, db, self.env.clone(), fnonce_trait)
     }
 
-    // FIXME: Find better API that also handles const generics
-    pub fn impls_trait(&self, db: &'db dyn HirDatabase, trait_: Trait, args: &[Type<'db>]) -> bool {
+    pub fn impls_trait(
+        &self,
+        db: &'db dyn HirDatabase,
+        trait_: Trait,
+        args: &[Type<'db>],
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(
             interner,
             AliasTyKind::Projection,
             AliasTy::new(interner, alias.id.into(), args),
         );
-
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
         let ty = structurally_normalize_ty(&infcx, projection, self.env.clone());
         if ty.is_ty_error() { None } else { Some(self.derived(ty)) }
                 });
             }
         };
-
         let sig = self.ty.callable_sig(interner)?;
         Some(Callable { ty: self.clone(), sig, callee, is_bound_method: false })
     }
             TyKind::Adt(adt_def, ..) => adt_def.def_id().0,
             _ => return false,
         };
-
         let adt = adt_id.into();
         match adt {
             Adt::Struct(s) => s.repr(db).unwrap_or_default().pack.is_some(),
             }
             _ => return Vec::new(),
         };
-
         db.field_types(variant_id)
             .iter()
             .map(|(local_id, ty)| {
         autoderef(db, self.env.clone(), canonical)
     }
 
-    // This would be nicer if it just returned an iterator, but that runs into
-    // lifetime problems, because we need to borrow temp `CrateImplDefs`.
     pub fn iterate_assoc_items<T>(
         &self,
         db: &'db dyn HirDatabase,
         callback: impl MethodCandidateCallback,
     ) {
         struct Callback<T>(T);
-
         impl<T: MethodCandidateCallback> method_resolution::MethodCandidateCallback for Callback<T> {
             fn on_inherent_method(
                 &mut self,
                 }
             }
         }
-
         let _p = tracing::info_span!(
             "iterate_method_candidates_dyn",
             with_local_impls = traits_in_scope.len(),
         let interner = DbInterner::new_with(db, None, None);
         // There should be no inference vars in types passed here
         let canonical = hir_ty::replace_errors_with_variables(interner, &self.ty);
-
         let krate = scope.krate();
         let environment = scope
             .resolver()
             .generic_def()
             .map_or_else(|| TraitEnvironment::empty(krate.id), |d| db.trait_environment(d));
-
         _ = method_resolution::iterate_method_candidates_dyn(
             &canonical,
             db,
     ) -> Option<T> {
         let _p = tracing::info_span!("iterate_path_candidates").entered();
         let mut slot = None;
-
         self.iterate_path_candidates_split_inherent(
             db,
             scope,
         callback: impl PathCandidateCallback,
     ) {
         struct Callback<T>(T);
-
         impl<T: PathCandidateCallback> method_resolution::MethodCandidateCallback for Callback<T> {
             fn on_inherent_method(
                 &mut self,
                 self.0.on_trait_item(item.into())
             }
         }
-
         let interner = DbInterner::new_with(db, None, None);
         let canonical = hir_ty::replace_errors_with_variables(interner, &self.ty);
-
         let krate = scope.krate();
         let environment = scope
             .resolver()
             .generic_def()
             .map_or_else(|| TraitEnvironment::empty(krate.id), |d| db.trait_environment(d));
-
         _ = method_resolution::iterate_path_candidates(
             &canonical,
             db,
                 ty.super_visit_with(self);
             }
         }
-
         let mut visitor =
             Visitor { db, env: self.env.clone(), callback, visited: FxHashSet::default() };
         self.ty.visit_with(&mut visitor);
     }
+
     /// Check if type unifies with another type.
     ///
     /// Note that we consider placeholder types to unify with everything.
     }
 
     pub fn to_type(&self, _db: &'db dyn HirDatabase) -> Type<'db> {
-        Type { env: self.env.clone(), ty: self.ty }
+        Type {
+            env: self.env.clone(),
+            ty: self.ty,
+        }
     }
 
-    // FIXME: Find better API that also handles const generics
     pub fn impls_trait(&self, infcx: InferCtxt<'db>, trait_: Trait, args: &[TypeNs<'db>]) -> bool {
         let args = GenericArgs::new_from_iter(
             infcx.interner,
             [self.ty].into_iter().chain(args.iter().map(|t| t.ty)).map(|t| t.into()),
         );
         let trait_ref = hir_ty::next_solver::TraitRef::new(infcx.interner, trait_.id.into(), args);
-
         let pred_kind = rustc_type_ir::Binder::dummy(rustc_type_ir::PredicateKind::Clause(
             rustc_type_ir::ClauseKind::Trait(rustc_type_ir::TraitPredicate {
                 trait_ref,
     }
 }
 
-// FIXME: Document this
 #[derive(Debug)]
 pub struct Callable<'db> {
     ty: Type<'db>,
             Callee::FnImpl(fn_) => CallableKind::FnImpl(fn_),
         }
     }
+
     pub fn receiver_param(&self, db: &'db dyn HirDatabase) -> Option<(SelfParam, Type<'db>)> {
         let func = match self.callee {
             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,
             self.ty.derived(self.sig.skip_binder().inputs_and_output.inputs()[0]),
         ))
     }
+
     pub fn n_params(&self) -> usize {
         self.sig.skip_binder().inputs_and_output.inputs().len()
             - if self.is_bound_method { 1 } else { 0 }
     }
+
     pub fn params(&self) -> Vec<Param<'db>> {
         self.sig
             .skip_binder()
             .map(|(idx, ty)| Param { func: self.callee.clone(), idx, ty })
             .collect()
     }
+
     pub fn return_type(&self) -> Type<'db> {
         self.ty.derived(self.sig.skip_binder().output())
     }
+
     pub fn sig(&self) -> impl Eq {
         &self.sig
     }
 impl ScopeDef {
     pub fn all_items(def: PerNs) -> ArrayVec<Self, 3> {
         let mut items = ArrayVec::new();
-
         match (def.take_types(), def.take_values()) {
             (Some(m1), None) => items.push(ScopeDef::ModuleDef(m1.into())),
             (None, Some(m2)) => items.push(ScopeDef::ModuleDef(m2.into())),
             }
             (None, None) => {}
         };
-
         if let Some(macro_def_id) = def.take_macros() {
             items.push(ScopeDef::ModuleDef(ModuleDef::Macro(macro_def_id.into())));
         }
-
         if items.is_empty() {
             items.push(ScopeDef::Unknown);
         }
-
         items
     }
 
 
 pub trait HasVisibility {
     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;
+
     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {
         let vis = self.visibility(db);
         vis.is_visible_from(db, module.id)
 
 impl<F> MethodCandidateCallback for F
 where
-    F: FnMut(Function) -> ControlFlow<()>,
-{
+    F: FnMut(Function) -> ControlFlow<()>, {
     fn on_inherent_method(&mut self, f: Function) -> ControlFlow<()> {
         self(f)
     }
 
 impl<F> PathCandidateCallback for F
 where
-    F: FnMut(AssocItem) -> ControlFlow<()>,
-{
+    F: FnMut(AssocItem) -> ControlFlow<()>, {
     fn on_inherent_item(&mut self, item: AssocItem) -> ControlFlow<()> {
         self(item)
     }
             defaults.get(param).is_none()
         })
 }
-
-pub use hir_ty::next_solver;
-pub use hir_ty::setup_tracing;