COMPARISON DIFF
============================================================

Original size: 227843 bytes
Chloro size:   227326 bytes
Rustfmt size:  227843 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 #![recursion_limit = "512"]
 
-extern crate ra_ap_rustc_type_ir as rustc_type_ir;
 
 mod attrs;
 mod from_id;
     },
     item_tree::ImportAlias,
     layout::{self, ReprOptions, TargetDataLayout},
-    nameres::{
-        assoc::TraitItems,
-        diagnostics::{DefDiagnostic, DefDiagnosticKind},
-    },
+    nameres::{assoc::TraitItems, diagnostics::{DefDiagnostic, DefDiagnosticKind}},
     per_ns::PerNs,
     resolver::{HasResolver, Resolver},
     signatures::{ImplFlags, StaticFlags, StructFlags, TraitFlags, VariantFields},
     },
 };
 
-// Be careful with these re-exports.
-//
-// `hir` is the boundary between the compiler and the IDE. It should try hard to
-// isolate the compiler from the ide, to allow the two to be refactored
-// independently. Re-exporting something from the compiler is the sure way to
-// breach the boundary.
-//
-// Generally, a refactoring which *removes* a name from this list is a good
-// idea!
 pub use {
     cfg::{CfgAtom, CfgExpr, CfgOptions},
     hir_def::{
-        Complete,
-        FindPathConfig,
-        attr::{AttrSourceMap, Attrs, AttrsWithOwner},
-        find_path::PrefixKind,
-        import_map,
-        lang_item::LangItem,
-        nameres::{DefMap, ModuleSource, crate_def_map},
-        per_ns::Namespace,
-        type_ref::{Mutability, TypeRef},
-        visibility::Visibility,
+        Complete, FindPathConfig, attr::{AttrSourceMap, Attrs, AttrsWithOwner},
+        find_path::PrefixKind, import_map, lang_item::LangItem,
+        nameres::{DefMap, ModuleSource, crate_def_map}, per_ns::Namespace,
+        type_ref::{Mutability, TypeRef}, visibility::Visibility,
         // FIXME: This is here since some queries take it as input that are used
         // outside of hir.
         {ModuleDefId, TraitId},
     },
     hir_expand::{
-        EditionedFileId, ExpandResult, HirFileId, MacroCallId, MacroKind,
-        attrs::{Attr, AttrId},
+        EditionedFileId, ExpandResult, HirFileId, MacroCallId, MacroKind, attrs::{Attr, AttrId},
         change::ChangeWithProcMacros,
         files::{
             FilePosition, FilePositionWrapper, FileRange, FileRangeWrapper, HirFilePosition,
             HirFileRange, InFile, InFileWrapper, InMacroFile, InRealFile, MacroFilePosition,
             MacroFileRange,
         },
-        inert_attr_macro::AttributeTemplate,
-        mod_path::{ModPath, PathKind, tool_path},
-        name::Name,
-        prettify_macro_expansion,
-        proc_macro::{ProcMacros, ProcMacrosBuilder},
-        tt,
+        inert_attr_macro::AttributeTemplate, mod_path::{ModPath, PathKind, tool_path}, name::Name,
+        prettify_macro_expansion, proc_macro::{ProcMacros, ProcMacrosBuilder}, tt,
     },
-    // FIXME: Properly encapsulate mir
-    hir_ty::mir,
     hir_ty::{
         CastError, FnAbi, PointerCast, attach_db, attach_db_allow_change,
-        consteval::ConstEvalError,
-        diagnostics::UnsafetyReason,
+        consteval::ConstEvalError, diagnostics::UnsafetyReason,
         display::{ClosureStyle, DisplayTarget, HirDisplay, HirDisplayError, HirWrite},
-        drop::DropGlue,
-        dyn_compatibility::{DynCompatibilityViolation, MethodViolationCode},
-        layout::LayoutError,
-        method_resolution::TyFingerprint,
-        mir::{MirEvalError, MirLowerError},
-        next_solver::abi::Safety,
-        next_solver::clear_tls_solver_cache,
+        drop::DropGlue, dyn_compatibility::{DynCompatibilityViolation, MethodViolationCode},
+        layout::LayoutError, method_resolution::TyFingerprint, mir::{MirEvalError, MirLowerError},
+        next_solver::abi::Safety, next_solver::clear_tls_solver_cache,
     },
     intern::{Symbol, sym},
+    // FIXME: Properly encapsulate mir
+    hir_ty::mir,
 };
 
-// These are negative re-exports: pub using these names is forbidden, they
-// should remain private to hir internals.
 #[allow(unused)]
 use {
     hir_def::expr_store::path::Path,
-    hir_expand::{
-        name::AsName,
-        span_map::{ExpansionSpanMap, RealSpanMap, SpanMap, SpanMapRef},
-    },
+    hir_expand::{name::AsName, span_map::{ExpansionSpanMap, RealSpanMap, SpanMap, SpanMapRef}},
 };
 
 /// hir::Crate describes a single crate. It's the main interface with which
     BuiltinType(BuiltinType),
     Macro(Macro),
 }
+
 impl_from!(
     Module,
     Function,
 
         let mut impl_assoc_items_scratch = vec![];
         for impl_def in self.impl_defs(db) {
+            // Negative impls can't have items, don't emit missing items diagnostic for them
             GenericDef::Impl(impl_def).diagnostics(db, acc);
-
             let loc = impl_def.id.lookup(db);
             let (impl_signature, source_map) = db.impl_signature_with_source_map(impl_def.id);
             expr_store_diagnostics(db, acc, &source_map);
-
             let file_id = loc.id.file_id;
             if file_id.macro_file().is_some_and(|it| it.kind(db) == MacroKind::DeriveBuiltIn) {
                 // these expansion come from us, diagnosing them is a waste of resources
                 .all_macro_calls(db)
                 .iter()
                 .for_each(|&(_ast, call_id)| macro_call_diagnostics(db, call_id, acc));
-
             let ast_id_map = db.ast_id_map(file_id);
-
             for diag in impl_def.id.impl_items_with_diagnostics(db).1.iter() {
                 emit_def_diagnostic(db, acc, diag, edition);
             }
-
             if inherent_impls.invalid_impls().contains(&impl_def.id) {
                 acc.push(IncoherentImpl { impl_: ast_id_map.get(loc.id.value), file_id }.into())
             }
-
             if !impl_def.check_orphan_rules(db) {
                 acc.push(TraitImplOrphan { impl_: ast_id_map.get(loc.id.value), file_id }.into())
             }
-
             let trait_ = impl_def.trait_(db);
             let mut trait_is_unsafe = trait_.is_some_and(|t| t.is_unsafe(db));
             let impl_is_negative = impl_def.is_negative(db);
             let impl_is_unsafe = impl_def.is_unsafe(db);
-
             let trait_is_unresolved = trait_.is_none() && impl_signature.target_trait.is_some();
             if trait_is_unresolved {
                 // Ignore trait safety errors when the trait is unresolved, as otherwise we'll treat it as safe,
                 // which may not be correct.
                 trait_is_unsafe = impl_is_unsafe;
             }
-
             let drop_maybe_dangle = (|| {
                 // FIXME: This can be simplified a lot by exposing hir-ty's utils.rs::Generics helper
                 let trait_ = trait_?;
                 Some(res)
             })()
             .unwrap_or(false);
-
             match (impl_is_unsafe, trait_is_unsafe, impl_is_negative, drop_maybe_dangle) {
                 // unsafe negative impl
                 (true, _, true, _) |
                 (false, false, _, true) => acc.push(TraitImplIncorrectSafety { impl_: ast_id_map.get(loc.id.value), file_id, should_be_safe: false }.into()),
                 _ => (),
             };
-
-            // Negative impls can't have items, don't emit missing items diagnostic for them
             if let (false, Some(trait_)) = (impl_is_negative, trait_) {
                 let items = &trait_.id.trait_items(db).items;
                 let required_items = items.iter().filter(|&(_, assoc)| match *assoc {
                 }
                 impl_assoc_items_scratch.clear();
             }
-
             push_ty_diagnostics(
                 db,
                 acc,
                 db.impl_trait_with_diagnostics(impl_def.id).and_then(|it| it.1),
                 &source_map,
             );
-
             for &(_, item) in impl_def.id.impl_items(db).items.iter() {
                 AssocItem::from(item).diagnostics(db, acc, style_lints);
             }
 ) {
     let id = db.macro_def(m.id);
     if let hir_expand::db::TokenExpander::DeclarativeMacro(expander) = db.macro_expander(id)
-        && let Some(e) = expander.mac.err()
-    {
+        && let Some(e) = expander.mac.err() {
         let Some(ast) = id.ast_id().left() else {
             never!("declarative expander for non decl-macro: {:?}", e);
             return;
     match diag {
         DefDiagnosticKind::UnresolvedModule { ast: declaration, candidates } => {
             let decl = declaration.to_ptr(db);
-            acc.push(
-                UnresolvedModule {
-                    decl: InFile::new(declaration.file_id, decl),
-                    candidates: candidates.clone(),
-                }
-                .into(),
-            )
+            acc.push(UnresolvedModule {
+                decl: InFile::new(declaration.file_id, decl),
+                candidates: candidates.clone(),
+            }.into())
         }
         DefDiagnosticKind::UnresolvedExternCrate { ast } => {
             let item = ast.to_ptr(db);
         }
         DefDiagnosticKind::UnresolvedImport { id, index } => {
             let file_id = id.file_id;
-
             let use_tree = hir_def::src::use_tree_to_ast(db, *id, *index);
             acc.push(
                 UnresolvedImport { decl: InFile::new(file_id, AstPtr::new(&use_tree)) }.into(),
             );
         }
         DefDiagnosticKind::UnimplementedBuiltinMacro { ast } => {
-            let node = ast.to_node(db);
             // Must have a name, otherwise we wouldn't emit it.
+            let node = ast.to_node(db);
             let name = node.name().expect("unimplemented builtin macro with no name");
             acc.push(
                 UnimplementedBuiltinMacro {
             )
         }
         MacroCallKind::Derive { ast_id, derive_attr_index, derive_index, .. } => {
-            let node = ast_id.to_node(db);
             // Compute the precise location of the macro name's token in the derive
             // list.
+            let node = ast_id.to_node(db);
             let token = (|| {
                 let derive_attr = collect_attrs(&node)
                     .nth(derive_attr_index.ast_index())
                 .unwrap_or_else(|| {
                     panic!("cannot find attribute #{}", invoc_attr_index.ast_index())
                 });
-
             (
                 ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),
                 Some(attr.syntax().text_range()),
             .map(|(id, _)| Field { parent: self.into(), id })
             .collect()
     }
+
     pub fn is_unstable(self, db: &dyn HirDatabase) -> bool {
         db.attrs(self.id.into()).is_unstable()
     }
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Variant {
     pub(crate) id: EnumVariantId,
     }
 }
 
-// FIXME: Rename to `EnumVariant`
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct InstantiatedVariant<'db> {
     pub(crate) inner: Variant,
 
 impl<'db> InstantiatedVariant<'db> {
     pub fn parent_enum(self, db: &dyn HirDatabase) -> InstantiatedEnum<'db> {
-        InstantiatedEnum { inner: self.inner.id.lookup(db).parent.into(), args: self.args }
+        InstantiatedEnum {
+            inner: self.inner.id.lookup(db).parent.into(),
+            args: self.args,
+        }
     }
 
     pub fn fields(self, db: &dyn HirDatabase) -> Vec<InstantiatedField<'db>> {
     Union(Union),
     Enum(Enum),
 }
+
 impl_from!(Struct, Union, Enum for Adt);
 
 impl Adt {
     }
 
     pub fn as_struct(&self) -> Option<Struct> {
-        if let Self::Struct(v) = self { Some(*v) } else { None }
+        if let Self::Struct(v) = self {
+            Some(*v)
+        } else {
+            None
+        }
     }
 
     pub fn as_enum(&self) -> Option<Enum> {
-        if let Self::Enum(v) = self { Some(*v) } else { None }
+        if let Self::Enum(v) = self {
+            Some(*v)
+        } else {
+            None
+        }
     }
 }
 
     Union(Union),
     Variant(Variant),
 }
+
 impl_from!(Struct, Union, Variant for VariantDef);
 
 impl VariantDef {
     Const(Const),
     Variant(Variant),
 }
+
 impl_from!(Function, Const, Static, Variant for DefWithBody);
 
 impl DefWithBody {
         .macro_calls()
         .for_each(|(_ast_id, call_id)| macro_call_diagnostics(db, call_id, acc));
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Function {
     pub(crate) id: FunctionId,
     }
 }
 
-// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.
 #[derive(Clone, Copy, PartialEq, Eq)]
 pub enum Access {
     Shared,
     }
 
     // pub fn parent_closure(&self) -> Option<Closure> {
+
     //     self.func.as_ref().right().cloned()
+
     // }
 
     pub fn index(&self) -> usize {
                 if let Some(self_param) = body.self_param.filter(|_| self.idx == 0) {
                     Some(Local { parent, binding_id: self_param })
                 } else if let Pat::Bind { id, .. } =
-                    &body[body.params[self.idx - body.self_param.is_some() as usize]]
-                {
+                    &body[body.params[self.idx - body.self_param.is_some() as usize]] {
                     Some(Local { parent, binding_id: *id })
                 } else {
                     None
     Const(Const),
     Static(Static),
 }
+
 impl_from!(
     Function,
     Adt(Struct, Enum, Union),
     }
 }
 
-// We cannot call this `Substitution` unfortunately...
 #[derive(Debug)]
 pub struct GenericSubstitution<'db> {
     def: GenericDefId,
                 .attrs(makro.into())
                 .parse_proc_macro_derive()
                 .and_then(|(_, helpers)| helpers.get(self.idx as usize).cloned()),
-        }
-        .unwrap_or_else(Name::missing)
+        }.unwrap_or_else(
+            Name::missing,
+        )
     }
 }
 
 
 impl BuiltinAttr {
     fn builtin(name: &str) -> Option<Self> {
-        hir_expand::inert_attr_macro::find_builtin_attr_idx(&Symbol::intern(name))
-            .map(|idx| BuiltinAttr { idx: idx as u32 })
+        hir_expand::inert_attr_macro::find_builtin_attr_idx(&Symbol::intern(name)).map(
+            |idx| BuiltinAttr { idx: idx as u32 },
+        )
     }
 
     pub fn name(&self) -> Name {
-        Name::new_symbol_root(Symbol::intern(
-            hir_expand::inert_attr_macro::INERT_ATTRIBUTES[self.idx as usize].name,
-        ))
+        Name::new_symbol_root(
+            Symbol::intern(hir_expand::inert_attr_macro::INERT_ATTRIBUTES[self.idx as usize].name),
+        )
     }
 
     pub fn template(&self) -> Option<AttributeTemplate> {
     ConstParam(ConstParam),
     LifetimeParam(LifetimeParam),
 }
+
 impl_from!(TypeParam, ConstParam, LifetimeParam for GenericParam);
 
 impl GenericParam {
             .nth(derive_index as usize)
             .and_then(<ast::Attr as AstNode>::cast)
             .and_then(|it| it.path())?;
-        Some(InMacroFile { file_id: derive_attr, value: path })
+        Some(InMacroFile {
+            file_id: derive_attr,
+            value: path,
+        })
     }
 
     pub fn check_orphan_rules(self, db: &dyn HirDatabase) -> bool {
             .to_string()
     }
 
-    pub fn display_with_impl(&self, db: &dyn HirDatabase, display_target: DisplayTarget) -> String {
+    pub fn display_with_impl(
+        &self,
+        db: &dyn HirDatabase,
+        display_target: DisplayTarget,
+    ) -> String {
         self.as_ty(db)
             .display(db, display_target)
             .with_closure_style(ClosureStyle::ImplFn)
 
 impl<'db> ClosureCapture<'db> {
     pub fn local(&self) -> Local {
-        Local { parent: self.owner, binding_id: self.capture.local() }
+        Local {
+            parent: self.owner,
+            binding_id: self.capture.local(),
+        }
     }
 
     /// Returns whether this place has any field (aka. non-deref) projections.
     }
 
     pub fn usages(&self) -> CaptureUsages {
-        CaptureUsages { parent: self.owner, spans: self.capture.spans() }
+        CaptureUsages {
+            parent: self.owner,
+            spans: self.capture.spans(),
+        }
     }
 
     pub fn kind(&self) -> CaptureKind {
 
     pub fn new_slice(ty: Self) -> Self {
         let interner = DbInterner::conjure();
-        Type { env: ty.env, ty: Ty::new_slice(interner, ty.ty) }
+        Type {
+            env: ty.env,
+            ty: Ty::new_slice(interner, ty.ty),
+        }
     }
 
     pub fn new_tuple(krate: base_db::Crate, tys: &[Self]) -> Self {
         let tys = tys.iter().map(|it| it.ty);
         let interner = DbInterner::conjure();
-        Type { env: TraitEnvironment::empty(krate), ty: Ty::new_tup_from_iter(interner, tys) }
+        Type {
+            env: TraitEnvironment::empty(krate),
+            ty: Ty::new_tup_from_iter(interner, tys),
+        }
     }
 
     pub fn is_unit(&self) -> bool {
     }
 
     // FIXME: Find better API that also handles const generics
-    pub fn impls_trait(&self, db: &'db dyn HirDatabase, trait_: Trait, args: &[Type<'db>]) -> bool {
+    pub fn impls_trait(
+        &self,
+        db: &'db dyn HirDatabase,
+        trait_: Trait,
+        args: &[Type<'db>],
+    ) -> bool {
         let interner = DbInterner::new_with(db, None, None);
         let args = generic_args_from_tys(
             interner,
 
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
         let ty = structurally_normalize_ty(&infcx, projection, self.env.clone());
-        if ty.is_ty_error() { None } else { Some(self.derived(ty)) }
+        if ty.is_ty_error() {
+            None
+        } else {
+            Some(self.derived(ty))
+        }
     }
 
     pub fn is_copy(&self, db: &'db dyn HirDatabase) -> bool {
     }
 
     pub fn remove_raw_ptr(&self) -> Option<Type<'db>> {
-        if let TyKind::RawPtr(ty, _) = self.ty.kind() { Some(self.derived(ty)) } else { None }
+        if let TyKind::RawPtr(ty, _) = self.ty.kind() {
+            Some(self.derived(ty))
+        } else {
+            None
+        }
     }
 
     pub fn contains_unknown(&self) -> bool {
         };
         for krate in def_crates {
             let impls = db.inherent_impls_in_crate(krate);
-
             for impl_def in impls.for_self_ty(ty_ns) {
                 for &(_, item) in impl_def.impl_items(db).items.iter() {
                     if callback(item) {
             Visitor { db, env: self.env.clone(), callback, visited: FxHashSet::default() };
         self.ty.visit_with(&mut visitor);
     }
+
     /// Check if type unifies with another type.
     ///
     /// Note that we consider placeholder types to unify with everything.
     }
 
     pub fn to_type(&self, _db: &'db dyn HirDatabase) -> Type<'db> {
-        Type { env: self.env.clone(), ty: self.ty }
+        Type {
+            env: self.env.clone(),
+            ty: self.ty,
+        }
     }
 
     // FIXME: Find better API that also handles const generics
     }
 }
 
-// FIXME: Document this
 #[derive(Debug)]
 pub struct Callable<'db> {
     ty: Type<'db>,
             Callee::FnImpl(fn_) => CallableKind::FnImpl(fn_),
         }
     }
+
     pub fn receiver_param(&self, db: &'db dyn HirDatabase) -> Option<(SelfParam, Type<'db>)> {
         let func = match self.callee {
             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,
             self.ty.derived(self.sig.skip_binder().inputs_and_output.inputs()[0]),
         ))
     }
+
     pub fn n_params(&self) -> usize {
         self.sig.skip_binder().inputs_and_output.inputs().len()
             - if self.is_bound_method { 1 } else { 0 }
     }
+
     pub fn params(&self) -> Vec<Param<'db>> {
         self.sig
             .skip_binder()
             .map(|(idx, ty)| Param { func: self.callee.clone(), idx, ty })
             .collect()
     }
+
     pub fn return_type(&self) -> Type<'db> {
         self.ty.derived(self.sig.skip_binder().output())
     }
+
     pub fn sig(&self) -> impl Eq {
         &self.sig
     }
 
 pub trait HasVisibility {
     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;
+
     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {
         let vis = self.visibility(db);
         vis.is_visible_from(db, module.id)
     args: impl IntoIterator<Item = Ty<'db>>,
 ) -> GenericArgs<'db> {
     let mut args = args.into_iter();
-    GenericArgs::for_item(interner, def_id, |_, id, _| {
+    GenericArgs::for_item(
+        interner,
+        def_id,
+        |_, id, _| {
         if matches!(id, GenericParamId::TypeParamId(_))
             && let Some(arg) = args.next()
         {
         } else {
             next_solver::GenericArg::error_from_id(interner, id)
         }
-    })
+    },
+    )
 }
 
 fn has_non_default_type_params(db: &dyn HirDatabase, generic_def: GenericDefId) -> bool {