COMPARISON DIFF
============================================================

Original size: 11436 bytes
Chloro size:   11400 bytes
Rustfmt size:  11695 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 pub trait HasSource {
     type Ast;
+
     /// Fetches the definition's source node.
     /// Using [`crate::Semantics::source`] is preferred when working with [`crate::Semantics`],
     /// as that caches the parsed file in the semantics' cache.
         match def_map[self.id.local_id].origin {
             ModuleOrigin::File { definition, .. } | ModuleOrigin::CrateRoot { definition, .. } => {
                 Some(definition)
-            }
+            },
             _ => None,
         }
     }
 
 impl HasSource for Field {
     type Ast = FieldSource;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         let var = VariantId::from(self.parent);
         let src = var.child_source(db);
         Some(field_source)
     }
 }
+
 impl HasSource for Adt {
     type Ast = ast::Adt;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         match self {
             Adt::Struct(s) => Some(s.source(db)?.map(ast::Adt::Struct)),
         }
     }
 }
+
 impl HasSource for VariantDef {
     type Ast = ast::VariantDef;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         match self {
             VariantDef::Struct(s) => Some(s.source(db)?.map(ast::VariantDef::Struct)),
         }
     }
 }
+
 impl HasSource for Struct {
     type Ast = ast::Struct;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for Union {
     type Ast = ast::Union;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for Enum {
     type Ast = ast::Enum;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for Variant {
     type Ast = ast::Variant;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<ast::Variant>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for Function {
     type Ast = ast::Fn;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for Const {
     type Ast = ast::Const;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for Static {
     type Ast = ast::Static;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for Trait {
     type Ast = ast::Trait;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for TypeAlias {
     type Ast = ast::TypeAlias;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 }
+
 impl HasSource for Macro {
     type Ast = Either<ast::Macro, ast::Fn>;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         match self.id {
-            MacroId::Macro2Id(it) => Some(
-                it.lookup(db)
-                    .source(db)
-                    .map(ast::Macro::MacroDef)
-                    .map(Either::Left),
-            ),
-            MacroId::MacroRulesId(it) => Some(
-                it.lookup(db)
-                    .source(db)
-                    .map(ast::Macro::MacroRules)
-                    .map(Either::Left),
-            ),
+            MacroId::Macro2Id(it) => {
+                Some(it.lookup(db).source(db).map(ast::Macro::MacroDef).map(Either::Left))
+            },
+            MacroId::MacroRulesId(it) => {
+                Some(it.lookup(db).source(db).map(ast::Macro::MacroRules).map(Either::Left))
+            },
             MacroId::ProcMacroId(it) => Some(it.lookup(db).source(db).map(Either::Right)),
         }
     }
 }
+
 impl HasSource for Impl {
     type Ast = ast::Impl;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         Some(self.id.lookup(db).source(db))
     }
 
 impl HasSource for TypeOrConstParam {
     type Ast = Either<ast::TypeOrConstParam, ast::Trait>;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         let child_source = self.id.parent.child_source(db);
-        child_source
-            .map(|it| it.get(self.id.local_id).cloned())
-            .transpose()
+        child_source.map(|it| it.get(self.id.local_id).cloned()).transpose()
     }
 }
 
 impl HasSource for LifetimeParam {
     type Ast = ast::LifetimeParam;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         let child_source = self.id.parent.child_source(db);
-        child_source
-            .map(|it| it.get(self.id.local_id).cloned())
-            .transpose()
+        child_source.map(|it| it.get(self.id.local_id).cloned()).transpose()
     }
 }
 
                     }
                 } else {
                     params.params().nth(self.idx).map(Either::Right)
-                }
-                .map(|value| InFile { file_id, value })
-            }
+                }.map(
+                    |value| InFile { file_id, value },
+                )
+            },
             Callee::Closure(closure, _) => {
                 let InternedClosure(owner, expr_id) = db.lookup_intern_closure(closure);
                 let (_, source_map) = db.body_with_source_map(owner);
                 let ast @ InFile { file_id, value } = source_map.expr_syntax(expr_id).ok()?;
                 let root = db.parse_or_expand(file_id);
                 match value.to_node(&root) {
-                    Either::Left(ast::Expr::ClosureExpr(it)) => it
-                        .param_list()?
-                        .params()
-                        .nth(self.idx)
-                        .map(Either::Right)
-                        .map(|value| InFile {
-                            file_id: ast.file_id,
-                            value,
-                        }),
+                    Either::Left(ast::Expr::ClosureExpr(it)) => it.param_list()?.params().nth(self.idx).map(Either::Right).map(
+                        |value| InFile { file_id: ast.file_id, value },
+                    ),
                     _ => None,
                 }
-            }
+            },
             _ => None,
         }
     }
 
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         let InFile { file_id, value } = Function::from(self.func).source(db)?;
-        value
-            .param_list()
-            .and_then(|params| params.self_param())
-            .map(|value| InFile { file_id, value })
+        value.param_list().and_then(|params| params.self_param()).map(
+            |value| InFile { file_id, value },
+        )
     }
 }
 
 
 impl HasSource for InlineAsmOperand {
     type Ast = ast::AsmOperandNamed;
+
     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {
         let source_map = db.body_with_source_map(self.owner).1;
         if let Ok(src) = source_map.expr_syntax(self.expr) {