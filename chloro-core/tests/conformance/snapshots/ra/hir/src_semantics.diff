COMPARISON DIFF
============================================================

Original size: 101650 bytes
Chloro size:   101230 bytes
Rustfmt size:  101650 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     ) -> Self {
         PathResolutionPerNs { type_ns, value_ns, macro_ns }
     }
+
     pub fn any(&self) -> Option<PathResolution> {
         self.type_ns.or(self.value_ns).or(self.macro_ns)
     }
     }
 }
 
-// Note: while this variant of `Semantics<'_, _>` might seem unused, as it does not
-// find actual use within the rust-analyzer project itself, it exists to enable the use
-// within e.g. tracked salsa functions in third-party crates that build upon `ra_ap_hir`.
 impl Semantics<'_, dyn HirDatabase> {
     /// Creates an instance that's weakly coupled to its underlying database type.
     pub fn new_dyn(db: &'_ dyn HirDatabase) -> Semantics<'_, dyn HirDatabase> {
     }
 }
 
-// Note: We take `DB` as `?Sized` here in order to support type-erased
-// use of `Semantics` via `Semantics<'_, dyn HirDatabase>`:
 impl<DB: HirDatabase + ?Sized> Semantics<'_, DB> {
     pub fn hir_file_for(&self, syntax_node: &SyntaxNode) -> HirFileId {
         self.imp.find_file(syntax_node).file_id
         self.imp.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)
     }
 
+    // FIXME: Rethink this API
     /// Find an AstNode by offset inside SyntaxNode, if it is inside *MacroCall*,
     /// descend it and find again
-    // FIXME: Rethink this API
     pub fn find_node_at_offset_with_descend<N: AstNode>(
         &self,
         node: &SyntaxNode,
         self.imp.descend_node_at_offset(node, offset).flatten().find_map(N::cast)
     }
 
+    // FIXME: Rethink this API
     /// Find an AstNode by offset inside SyntaxNode, if it is inside an attribute macro call,
     /// descend it and find again
-    // FIXME: Rethink this API
     pub fn find_nodes_at_offset_with_descend<'slf, N: AstNode + 'slf>(
         &'slf self,
         node: &SyntaxNode,
     ) -> Option<Vec<(TextRange, Option<Either<PathResolution, InlineAsmOperand>>)>> {
         let string_start = string.syntax().text_range().start();
         let token = self.wrap_token_infile(string.syntax().clone());
-        self.descend_into_macros_breakable(token, |token, _| {
+        self.descend_into_macros_breakable(
+            token,
+            |token, _| {
             (|| {
                 let token = token.value;
                 let string = ast::String::cast(token)?;
                 }
             })()
             .map_or(ControlFlow::Continue(()), ControlFlow::Break)
-        })
+        },
+        )
     }
 
+    // FIXME: Type the return type
+    // FIXME: Remove this in favor of `check_for_format_args_template_with_file`
     /// Retrieves the formatting part of the format_args! template string at the given offset.
     ///
-    // FIXME: Type the return type
     /// Returns the range (pre-expansion) in the string literal corresponding to the resolution,
     /// absolute file range (post-expansion)
     /// of the part in the format string, the corresponding string token and the resolution if it
     /// exists.
-    // FIXME: Remove this in favor of `check_for_format_args_template_with_file`
     pub fn check_for_format_args_template(
         &self,
         original_token: SyntaxToken,
         self.check_for_format_args_template_with_file(original_token, offset)
     }
 
+    // FIXME: Type the return type
     /// Retrieves the formatting part of the format_args! template string at the given offset.
     ///
-    // FIXME: Type the return type
     /// Returns the range (pre-expansion) in the string literal corresponding to the resolution,
     /// absolute file range (post-expansion)
     /// of the part in the format string, the corresponding string token and the resolution if it
     ///
     /// Note that if this token itself is within the context of a macro expansion does not matter.
     /// That is, we strictly check if it lies inside the input of a macro call.
-    pub fn is_inside_macro_call(&self, token @ InFile { value, .. }: InFile<&SyntaxToken>) -> bool {
+    pub fn is_inside_macro_call(
+        &self,
+        token @ InFile { value, .. }: InFile<&SyntaxToken>,
+    ) -> bool {
         value.parent_ancestors().any(|ancestor| {
             if ast::MacroCall::can_cast(ancestor.kind()) {
                 return true;
         token.parent().into_iter().flat_map(move |parent| self.ancestors_with_macros(parent))
     }
 
-    /// Iterates the ancestors of the given node, climbing up macro expansions while doing so.
     // FIXME: Replace with `ancestors_with_macros_file` when all usages are updated.
+    /// Iterates the ancestors of the given node, climbing up macro expansions while doing so.
     pub fn ancestors_with_macros(
         &self,
         node: SyntaxNode,
         &self,
         node: InFile<SyntaxNode>,
     ) -> impl Iterator<Item = InFile<SyntaxNode>> + Clone + '_ {
-        iter::successors(Some(node), move |&InFile { file_id, ref value }| match value.parent() {
+        iter::successors(
+            Some(node),
+            move |&InFile { file_id, ref value }| match value.parent() {
             Some(parent) => Some(InFile::new(file_id, parent)),
             None => {
                 let macro_file = file_id.macro_file()?;
                     expansion_info.arg().map(|node| node?.parent()).transpose()
                 })
             }
-        })
+        },
+        )
     }
 
     pub fn ancestors_at_offset_with_macros(
         self.analyze(call.syntax())?.resolve_method_call_fallback(self.db, call)
     }
 
-    /// Env is used to derive the trait environment
     // FIXME: better api for the trait environment
+    /// Env is used to derive the trait environment
     pub fn resolve_trait_impl_method(
         &self,
         env: Type<'db>,
     pub fn resolve_field_fallback(
         &self,
         field: &ast::FieldExpr,
-    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)>
-    {
+    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)> {
         self.analyze(field.syntax())?.resolve_field_fallback(self.db, field)
     }
 
         &self,
         node: InFile<&SyntaxNode>,
         offset: Option<TextSize>,
-        // replace this, just make the inference result a `LazyCell`
         infer_body: bool,
     ) -> Option<SourceAnalyzer<'db>> {
         let _p = tracing::info_span!("SemanticsImpl::analyze_impl").entered();
     }
 }
 
-pub trait ToDef: AstNode + Clone {
+pub trait ToDef {
     type Def;
+
     fn to_def(sema: &SemanticsImpl<'_>, src: InFile<&Self>) -> Option<Self::Def>;
 }
 
 
 impl RenameConflictsVisitor<'_> {
     fn resolve_path(&mut self, node: ExprOrPatId, path: &Path) {
-        if let Path::BarePath(path) = path
-            && let Some(name) = path.as_ident()
-        {
+        if let Path::BarePath(path) = path && let Some(name) = path.as_ident() {
             if *name.symbol() == self.new_name {
                 if let Some(conflicting) = self.resolver.rename_will_conflict_with_renamed(
                     self.db,
                     self.body.expr_or_pat_path_hygiene(node),
                     &self.new_name,
                     self.to_be_renamed,
-                )
-            {
+                ) {
                 self.conflicts.insert(conflicting);
             }
         }