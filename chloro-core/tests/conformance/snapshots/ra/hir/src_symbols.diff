COMPARISON DIFF
============================================================

Original size: 18922 bytes
Chloro size:   18926 bytes
Rustfmt size:  19198 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! File symbol extraction.
 
 use base_db::FxIndexSet;
 use either::Either;
 use hir_def::{
+    AdtId, AssocItemId, Complete, DefWithBodyId, ExternCrateId, HasModule, ImplId, Lookup, MacroId,
+    ModuleDefId, ModuleId, TraitId,
     db::DefDatabase,
     item_scope::{ImportId, ImportOrExternCrate, ImportOrGlob},
     per_ns::Item,
     src::{HasChildSource, HasSource},
     visibility::{Visibility, VisibilityExplicitness},
-    AdtId, AssocItemId, Complete, DefWithBodyId, ExternCrateId, HasModule, ImplId, Lookup, MacroId,
-    ModuleDefId, ModuleId, TraitId,
 };
-use hir_expand::{name::Name, HirFileId};
+use hir_expand::{HirFileId, name::Name};
 use hir_ty::{
     db::HirDatabase,
-    display::{hir_display_with_store, HirDisplay},
+    display::{HirDisplay, hir_display_with_store},
 };
 use intern::Symbol;
 use rustc_hash::FxHashMap;
-use syntax::{ast::HasName, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, ToSmolStr};
+use syntax::{AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, ToSmolStr, ast::HasName};
 
 use crate::{HasCrate, Module, ModuleDef, Semantics};
 
         tracing::info!(?module, "SymbolCollector::collect");
 
         // The initial work is the root module we're collecting, additional work will
+
         // be populated as we traverse the module's definitions.
-        self.work.push(SymbolCollectorWork {
-            module_id: module.into(),
-            parent: None,
-        });
+
+        self.work.push(SymbolCollectorWork { module_id: module.into(), parent: None });
 
         while let Some(work) = self.work.pop() {
             self.do_work(work);
         };
 
         // Nested trees are very common, so a cache here will hit a lot.
+
         let import_child_source_cache = &mut FxHashMap::default();
 
         let is_explicit_import = |vis| match vis {
             let source = import_child_source_cache
                 .entry(i.use_)
                 .or_insert_with(|| i.use_.child_source(this.db));
-            let Some(use_tree_src) = source.value.get(i.idx) else {
-                return;
-            };
+            let Some(use_tree_src) = source.value.get(i.idx) else { return };
             let rename = use_tree_src.rename().and_then(|rename| rename.name());
             let name_syntax = match rename {
                 Some(name) => Some(Either::Left(name)),
-                None if is_explicit_import(vis) => (|| {
-                    use_tree_src
-                        .path()?
-                        .segment()?
-                        .name_ref()
-                        .map(Either::Right)
-                })(),
+                None if is_explicit_import(vis) => {
+                    (|| use_tree_src.path()?.segment()?.name_ref().map(Either::Right))()
+                }
                 None => None,
             };
             let Some(name_syntax) = name_syntax else {
         let body = self.db.body(body_id);
 
         // Descend into the blocks and enqueue collection of all modules within.
+
         for (_, def_map) in body.blocks(self.db) {
             for (id, _) in def_map.modules() {
                 self.work.push(SymbolCollectorWork {
             hir_display_with_store(impl_data.self_ty, &impl_data.store)
                 .display(
                     self.db,
-                    crate::Impl::from(impl_id)
-                        .krate(self.db)
-                        .to_display_target(self.db),
+                    crate::Impl::from(impl_id).krate(self.db).to_display_target(self.db),
                 )
                 .to_smolstr(),
         );
     {
         let loc = id.lookup(self.db);
         let source = loc.source(self.db);
-        let Some(name_node) = source.value.name() else {
-            return Complete::Yes;
-        };
+        let Some(name_node) = source.value.name() else { return Complete::Yes };
         let def = ModuleDef::from(id.into());
         let dec_loc = DeclarationLocation {
             hir_file_id: source.file_id,
     fn push_module(&mut self, module_id: ModuleId, name: &Name) {
         let def_map = module_id.def_map(self.db);
         let module_data = &def_map[module_id.local_id];
-        let Some(declaration) = module_data.origin.declaration() else {
-            return;
-        };
+        let Some(declaration) = module_data.origin.declaration() else { return };
         let module = declaration.to_node(self.db);
-        let Some(name_node) = module.name() else {
-            return;
-        };
+        let Some(name_node) = module.name() else { return };
         let dec_loc = DeclarationLocation {
             hir_file_id: declaration.file_id,
             ptr: SyntaxNodePtr::new(module.syntax()),