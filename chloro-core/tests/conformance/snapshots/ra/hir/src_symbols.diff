COMPARISON DIFF
============================================================

Original size: 18922 bytes
Chloro size:   19198 bytes
Rustfmt size:  19198 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     per_ns::Item,
     src::{HasChildSource, HasSource},
     visibility::{Visibility, VisibilityExplicitness},
-    AdtId, AssocItemId, Complete, DefWithBodyId, ExternCrateId, HasModule, ImplId, Lookup, MacroId,
-    ModuleDefId, ModuleId, TraitId,
+    AdtId,
+    AssocItemId,
+    Complete,
+    DefWithBodyId,
+    ExternCrateId,
+    HasModule,
+    ImplId,
+    Lookup,
+    MacroId,
+    ModuleDefId,
+    ModuleId,
+    TraitId,
 };
-use hir_expand::{name::Name, HirFileId};
+use hir_expand::{HirFileId, name::Name};
 use hir_ty::{
     db::HirDatabase,
-    display::{hir_display_with_store, HirDisplay},
+    display::{HirDisplay, hir_display_with_store},
 };
 use intern::Symbol;
 use rustc_hash::FxHashMap;
-use syntax::{ast::HasName, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, ToSmolStr};
+use syntax::{AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, ToSmolStr, ast::HasName};
 
 use crate::{HasCrate, Module, ModuleDef, Semantics};
 
 }
 
 impl DeclarationLocation {
-    pub fn syntax<DB: HirDatabase>(&self, sema: &Semantics<'_, DB>) -> SyntaxNode {
+    pub fn syntax<DB: HirDatabase>(
+        &self,
+        sema: &Semantics<'_, DB>,
+    ) -> SyntaxNode {
         let root = sema.parse_or_expand(self.hir_file_id);
         self.ptr.to_node(&root)
     }
 /// Given a [`ModuleId`] and a [`HirDatabase`], use the DefMap for the module's crate to collect
 /// all symbols that should be indexed for the given module.
 impl<'a> SymbolCollector<'a> {
-    pub fn new(db: &'a dyn HirDatabase, collect_pub_only: bool) -> Self {
+    pub fn new(
+        db: &'a dyn HirDatabase,
+        collect_pub_only: bool,
+    ) -> Self {
         SymbolCollector {
             db,
             symbols: Default::default(),
         symbol_collector.finish()
     }
 
-    pub fn collect(&mut self, module: Module) {
+    pub fn collect(
+        &mut self,
+        module: Module,
+    ) {
         let _p = tracing::info_span!("SymbolCollector::collect", ?module).entered();
         tracing::info!(?module, "SymbolCollector::collect");
-
         // The initial work is the root module we're collecting, additional work will
         // be populated as we traverse the module's definitions.
-        self.work.push(SymbolCollectorWork {
-            module_id: module.into(),
-            parent: None,
-        });
-
+        self.work.push(SymbolCollectorWork { module_id: module.into(), parent: None });
         while let Some(work) = self.work.pop() {
             self.do_work(work);
         }
         self.symbols.into_iter().collect()
     }
 
-    fn do_work(&mut self, work: SymbolCollectorWork) {
+    fn do_work(
+        &mut self,
+        work: SymbolCollectorWork,
+    ) {
         let _p = tracing::info_span!("SymbolCollector::do_work", ?work).entered();
         tracing::info!(?work, "SymbolCollector::do_work");
         self.db.unwind_if_revision_cancelled();
-
         let parent_name = work.parent.map(|name| Symbol::intern(name.as_str()));
         self.with_container_name(parent_name, |s| s.collect_from_module(work.module_id));
     }
 
-    fn collect_from_module(&mut self, module_id: ModuleId) {
+    fn collect_from_module(
+        &mut self,
+        module_id: ModuleId,
+    ) {
         let collect_pub_only = self.collect_pub_only;
         let push_decl = |this: &mut Self, def: ModuleDefId, name, vis| {
             if collect_pub_only && vis != Visibility::Public {
                 ModuleDefId::EnumVariantId(_) => {}
             }
         };
-
         // Nested trees are very common, so a cache here will hit a lot.
         let import_child_source_cache = &mut FxHashMap::default();
-
         let is_explicit_import = |vis| match vis {
             Visibility::Public => true,
             Visibility::PubCrate(_) => true,
             Visibility::Module(_, VisibilityExplicitness::Explicit) => true,
             Visibility::Module(_, VisibilityExplicitness::Implicit) => false,
         };
-
         let mut push_import = |this: &mut Self, i: ImportId, name: &Name, def: ModuleDefId, vis| {
             if collect_pub_only && vis != Visibility::Public {
                 return;
             let source = import_child_source_cache
                 .entry(i.use_)
                 .or_insert_with(|| i.use_.child_source(this.db));
-            let Some(use_tree_src) = source.value.get(i.idx) else {
-                return;
-            };
+            let Some(use_tree_src) = source.value.get(i.idx) else { return };
             let rename = use_tree_src.rename().and_then(|rename| rename.name());
             let name_syntax = match rename {
                 Some(name) => Some(Either::Left(name)),
-                None if is_explicit_import(vis) => (|| {
-                    use_tree_src
-                        .path()?
-                        .segment()?
-                        .name_ref()
-                        .map(Either::Right)
-                })(),
+                None if is_explicit_import(vis) => {
+                    (|| use_tree_src.path()?.segment()?.name_ref().map(Either::Right))()
+                }
                 None => None,
             };
             let Some(name_syntax) = name_syntax else {
                 do_not_complete: Complete::Yes,
             });
         };
-
         let push_extern_crate =
             |this: &mut Self, i: ExternCrateId, name: &Name, def: ModuleDefId, vis| {
                 if collect_pub_only && vis != Visibility::Public {
                     do_not_complete: Complete::Yes,
                 });
             };
-
         let def_map = module_id.def_map(self.db);
         let scope = &def_map[module_id.local_id].scope;
-
         for impl_id in scope.impls() {
             self.collect_from_impl(impl_id);
         }
-
         for (name, Item { def, vis, import }) in scope.types() {
             if let Some(i) = import {
                 match i {
             // self is a declaration
             push_decl(self, def, name, vis)
         }
-
         for (name, Item { def, vis, import }) in scope.macros() {
             if let Some(i) = import {
                 match i {
             // self is a declaration
             push_decl(self, ModuleDefId::MacroId(def), name, vis)
         }
-
         for (name, Item { def, vis, import }) in scope.values() {
             if let Some(i) = import {
                 match i {
             // self is a declaration
             push_decl(self, def, name, vis)
         }
-
         for const_id in scope.unnamed_consts() {
             self.collect_from_body(const_id, None);
         }
-
         for (name, id) in scope.legacy_macros() {
             for &id in id {
                 if id.module(self.db) == module_id {
         }
     }
 
-    fn collect_from_body(&mut self, body_id: impl Into<DefWithBodyId>, name: Option<Name>) {
+    fn collect_from_body(
+        &mut self,
+        body_id: impl Into<DefWithBodyId>,
+        name: Option<Name>,
+    ) {
         if self.collect_pub_only {
             return;
         }
         let body_id = body_id.into();
         let body = self.db.body(body_id);
-
         // Descend into the blocks and enqueue collection of all modules within.
         for (_, def_map) in body.blocks(self.db) {
             for (id, _) in def_map.modules() {
         }
     }
 
-    fn collect_from_impl(&mut self, impl_id: ImplId) {
+    fn collect_from_impl(
+        &mut self,
+        impl_id: ImplId,
+    ) {
         let impl_data = self.db.impl_signature(impl_id);
         let impl_name = Some(
             hir_display_with_store(impl_data.self_ty, &impl_data.store)
                 .display(
                     self.db,
-                    crate::Impl::from(impl_id)
-                        .krate(self.db)
-                        .to_display_target(self.db),
+                    crate::Impl::from(impl_id).krate(self.db).to_display_target(self.db),
                 )
                 .to_smolstr(),
         );
         })
     }
 
-    fn collect_from_trait(&mut self, trait_id: TraitId, trait_do_not_complete: Complete) {
+    fn collect_from_trait(
+        &mut self,
+        trait_id: TraitId,
+        trait_do_not_complete: Complete,
+    ) {
         let trait_data = self.db.trait_signature(trait_id);
         self.with_container_name(Some(Symbol::intern(trait_data.name.as_str())), |s| {
             for &(ref name, assoc_item_id) in &trait_id.trait_items(self.db).items {
         });
     }
 
-    fn with_container_name(&mut self, container_name: Option<Symbol>, f: impl FnOnce(&mut Self)) {
+    fn with_container_name(
+        &mut self,
+        container_name: Option<Symbol>,
+        f: impl FnOnce(&mut Self),
+    ) {
         if let Some(container_name) = container_name {
             let prev = self.current_container_name.replace(container_name);
             f(self);
     where
         L: Lookup<Database = dyn DefDatabase> + Into<ModuleDefId>,
         <L as Lookup>::Data: HasSource,
-        <<L as Lookup>::Data as HasSource>::Value: HasName,
-    {
+        <<L as Lookup>::Data as HasSource>::Value: HasName, {
         let loc = id.lookup(self.db);
         let source = loc.source(self.db);
-        let Some(name_node) = source.value.name() else {
-            return Complete::Yes;
-        };
+        let Some(name_node) = source.value.name() else { return Complete::Yes };
         let def = ModuleDef::from(id.into());
         let dec_loc = DeclarationLocation {
             hir_file_id: source.file_id,
             ptr: SyntaxNodePtr::new(source.value.syntax()),
             name_ptr: AstPtr::new(&name_node).wrap_left(),
         };
-
         let mut do_not_complete = Complete::Yes;
-
         if let Some(attrs) = def.attrs(self.db) {
             do_not_complete = Complete::extract(matches!(def, ModuleDef::Trait(_)), &attrs);
             if let Some(trait_do_not_complete) = trait_do_not_complete {
                 });
             }
         }
-
         self.symbols.insert(FileSymbol {
             name: name.symbol().clone(),
             def,
             is_import: false,
             do_not_complete,
         });
-
         do_not_complete
     }
 
-    fn push_module(&mut self, module_id: ModuleId, name: &Name) {
+    fn push_module(
+        &mut self,
+        module_id: ModuleId,
+        name: &Name,
+    ) {
         let def_map = module_id.def_map(self.db);
         let module_data = &def_map[module_id.local_id];
-        let Some(declaration) = module_data.origin.declaration() else {
-            return;
-        };
+        let Some(declaration) = module_data.origin.declaration() else { return };
         let module = declaration.to_node(self.db);
-        let Some(name_node) = module.name() else {
-            return;
-        };
+        let Some(name_node) = module.name() else { return };
         let dec_loc = DeclarationLocation {
             hir_file_id: declaration.file_id,
             ptr: SyntaxNodePtr::new(module.syntax()),
             name_ptr: AstPtr::new(&name_node).wrap_left(),
         };
-
         let def = ModuleDef::Module(module_id.into());
-
         let mut do_not_complete = Complete::Yes;
         if let Some(attrs) = def.attrs(self.db) {
             do_not_complete = Complete::extract(matches!(def, ModuleDef::Trait(_)), &attrs);
                 });
             }
         }
-
         self.symbols.insert(FileSymbol {
             name: name.symbol().clone(),
             def: ModuleDef::Module(module_id.into()),