COMPARISON DIFF
============================================================

Original size: 18922 bytes
Chloro size:   18957 bytes
Rustfmt size:  19198 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         tracing::info!(?module, "SymbolCollector::collect");
 
         // The initial work is the root module we're collecting, additional work will
+
         // be populated as we traverse the module's definitions.
-        self.work.push(SymbolCollectorWork {
-            module_id: module.into(),
-            parent: None,
-        });
+        self.work.push(SymbolCollectorWork { module_id: module.into(), parent: None });
 
         while let Some(work) = self.work.pop() {
             self.do_work(work);
             let source = import_child_source_cache
                 .entry(i.use_)
                 .or_insert_with(|| i.use_.child_source(this.db));
-            let Some(use_tree_src) = source.value.get(i.idx) else {
-                return;
-            };
+            let Some(use_tree_src) = source.value.get(i.idx) else { return };
             let rename = use_tree_src.rename().and_then(|rename| rename.name());
             let name_syntax = match rename {
                 Some(name) => Some(Either::Left(name)),
-                None if is_explicit_import(vis) => (|| {
-                    use_tree_src
-                        .path()?
-                        .segment()?
-                        .name_ref()
-                        .map(Either::Right)
-                })(),
+                None if is_explicit_import(vis) => {
+                    (|| use_tree_src.path()?.segment()?.name_ref().map(Either::Right))()
+                }
                 None => None,
             };
             let Some(name_syntax) = name_syntax else {
             hir_display_with_store(impl_data.self_ty, &impl_data.store)
                 .display(
                     self.db,
-                    crate::Impl::from(impl_id)
-                        .krate(self.db)
-                        .to_display_target(self.db),
+                    crate::Impl::from(impl_id).krate(self.db).to_display_target(self.db),
                 )
                 .to_smolstr(),
         );
-        self.with_container_name(impl_name.as_deref().map(Symbol::intern), |s| {
+        self.with_container_name(
+            impl_name.as_deref().map(Symbol::intern),
+            |s| {
             for &(ref name, assoc_item_id) in &impl_id.impl_items(self.db).items {
                 if s.collect_pub_only && s.db.assoc_visibility(assoc_item_id) != Visibility::Public
                 {
                     continue;
                 }
-
                 s.push_assoc_item(assoc_item_id, name, None)
             }
-        })
+        },
+        )
     }
 
     fn collect_from_trait(&mut self, trait_id: TraitId, trait_do_not_complete: Complete) {
     {
         let loc = id.lookup(self.db);
         let source = loc.source(self.db);
-        let Some(name_node) = source.value.name() else {
-            return Complete::Yes;
-        };
+        let Some(name_node) = source.value.name() else { return Complete::Yes };
         let def = ModuleDef::from(id.into());
         let dec_loc = DeclarationLocation {
             hir_file_id: source.file_id,
     fn push_module(&mut self, module_id: ModuleId, name: &Name) {
         let def_map = module_id.def_map(self.db);
         let module_data = &def_map[module_id.local_id];
-        let Some(declaration) = module_data.origin.declaration() else {
-            return;
-        };
+        let Some(declaration) = module_data.origin.declaration() else { return };
         let module = declaration.to_node(self.db);
-        let Some(name_node) = module.name() else {
-            return;
-        };
+        let Some(name_node) = module.name() else { return };
         let dec_loc = DeclarationLocation {
             hir_file_id: declaration.file_id,
             ptr: SyntaxNodePtr::new(module.syntax()),