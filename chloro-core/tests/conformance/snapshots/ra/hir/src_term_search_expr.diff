COMPARISON DIFF
============================================================

Original size: 16513 bytes
Chloro size:   16656 bytes
Rustfmt size:  16513 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     /// Constant generic parameter
     ConstParam(ConstParam),
     /// Well known type (such as `true` for bool)
-    FamousType { ty: Type<'db>, value: &'static str },
+    FamousType {
+        ty: Type<'db>,
+        value: &'static str,
+    },
     /// Function call (does not take self param)
-    Function { func: Function, generics: Vec<Type<'db>>, params: Vec<Expr<'db>> },
+    Function {
+        func: Function,
+        generics: Vec<Type<'db>>,
+        params: Vec<Expr<'db>>,
+    },
     /// Method call (has self param)
     Method {
         func: Function,
         params: Vec<Expr<'db>>,
     },
     /// Enum variant construction
-    Variant { variant: Variant, generics: Vec<Type<'db>>, params: Vec<Expr<'db>> },
+    Variant {
+        variant: Variant,
+        generics: Vec<Type<'db>>,
+        params: Vec<Expr<'db>>,
+    },
     /// Struct construction
-    Struct { strukt: Struct, generics: Vec<Type<'db>>, params: Vec<Expr<'db>> },
+    Struct {
+        strukt: Struct,
+        generics: Vec<Type<'db>>,
+        params: Vec<Expr<'db>>,
+    },
     /// Tuple construction
-    Tuple { ty: Type<'db>, params: Vec<Expr<'db>> },
+    Tuple {
+        ty: Type<'db>,
+        params: Vec<Expr<'db>>,
+    },
     /// Struct field access
-    Field { expr: Box<Expr<'db>>, field: Field },
+    Field {
+        expr: Box<Expr<'db>>,
+        field: Field,
+    },
     /// Passing type as reference (with `&`)
     Reference(Box<Expr<'db>>),
     /// Indicates possibility of many different options that all evaluate to `ty`
                     .collect::<Result<Vec<String>, DisplaySourceCodeError>>()?
                     .into_iter()
                     .join(", ");
-
                 match func.as_assoc_item(db).map(|it| it.container(db)) {
                     Some(container) => {
                         let container_name =
                 if self.contains_many_in_illegal_pos(db) {
                     return Ok(many_formatter(&target.ty(db)));
                 }
-
                 let func_name = func.name(db).display(db, edition).to_string();
                 let self_param = func.self_param(db).unwrap();
                 let target_str =
                     .collect::<Result<Vec<String>, DisplaySourceCodeError>>()?
                     .into_iter()
                     .join(", ");
-
                 match func.as_assoc_item(db).and_then(|it| it.container_or_implemented_trait(db)) {
                     Some(trait_) => {
                         let trait_name = mod_item_path_str(sema_scope, &ModuleDef::Trait(trait_))?;
                     }
                     StructKind::Unit => String::new(),
                 };
-
                 let prefix = mod_item_path_str(sema_scope, &ModuleDef::Variant(*variant))?;
                 Ok(format!("{prefix}{inner}"))
             }
                     }
                     StructKind::Unit => String::new(),
                 };
-
                 let prefix = mod_item_path_str(sema_scope, &ModuleDef::Adt(Adt::Struct(*strukt)))?;
                 Ok(format!("{prefix}{inner}"))
             }
                 if expr.contains_many_in_illegal_pos(db) {
                     return Ok(many_formatter(&expr.ty(db)));
                 }
-
                 let strukt =
                     expr.gen_source_code(sema_scope, many_formatter, cfg, display_target)?;
                 let field = field.name(db).display(db, edition).to_string();
                 if expr.contains_many_in_illegal_pos(db) {
                     return Ok(many_formatter(&expr.ty(db)));
                 }
-
                 let inner =
                     expr.gen_source_code(sema_scope, many_formatter, cfg, display_target)?;
                 Ok(format!("&{inner}"))