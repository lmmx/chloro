COMPARISON DIFF
============================================================

Original size: 16513 bytes
Chloro size:   16677 bytes
Rustfmt size:  16513 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     edition: Edition,
 ) -> Result<String, DisplaySourceCodeError> {
     let path = mod_item_path(sema_scope, def, cfg);
-    path.map(|it| it.display(sema_scope.db, edition).to_string())
-        .ok_or(DisplaySourceCodeError::PathNotFound)
+    path.map(|it| it.display(sema_scope.db, edition).to_string()).ok_or(
+        DisplaySourceCodeError::PathNotFound,
+    )
 }
 
 /// Type tree shows how can we get from set of types to some type.
     /// Constant generic parameter
     ConstParam(ConstParam),
     /// Well known type (such as `true` for bool)
-    FamousType { ty: Type<'db>, value: &'static str },
+    FamousType {
+        ty: Type<'db>,
+        value: &'static str,
+    },
     /// Function call (does not take self param)
-    Function { func: Function, generics: Vec<Type<'db>>, params: Vec<Expr<'db>> },
+    Function {
+        func: Function,
+        generics: Vec<Type<'db>>,
+        params: Vec<Expr<'db>>,
+    },
     /// Method call (has self param)
     Method {
         func: Function,
         params: Vec<Expr<'db>>,
     },
     /// Enum variant construction
-    Variant { variant: Variant, generics: Vec<Type<'db>>, params: Vec<Expr<'db>> },
+    Variant {
+        variant: Variant,
+        generics: Vec<Type<'db>>,
+        params: Vec<Expr<'db>>,
+    },
     /// Struct construction
-    Struct { strukt: Struct, generics: Vec<Type<'db>>, params: Vec<Expr<'db>> },
+    Struct {
+        strukt: Struct,
+        generics: Vec<Type<'db>>,
+        params: Vec<Expr<'db>>,
+    },
     /// Tuple construction
-    Tuple { ty: Type<'db>, params: Vec<Expr<'db>> },
+    Tuple {
+        ty: Type<'db>,
+        params: Vec<Expr<'db>>,
+    },
     /// Struct field access
-    Field { expr: Box<Expr<'db>>, field: Field },
+    Field {
+        expr: Box<Expr<'db>>,
+        field: Field,
+    },
     /// Passing type as reference (with `&`)
     Reference(Box<Expr<'db>>),
     /// Indicates possibility of many different options that all evaluate to `ty`
                         .map(|c| c.display(db, edition).to_string())
                         .unwrap_or(String::new());
                     Ok(format!("{container_name}::{const_name}"))
-                }
+                },
                 None => mod_item_path_str(sema_scope, &ModuleDef::Const(*it)),
             },
             Expr::Static(it) => mod_item_path_str(sema_scope, &ModuleDef::Static(*it)),
                     .collect::<Result<Vec<String>, DisplaySourceCodeError>>()?
                     .into_iter()
                     .join(", ");
-
                 match func.as_assoc_item(db).map(|it| it.container(db)) {
                     Some(container) => {
                         let container_name =
                             container_name(container, sema_scope, cfg, edition, display_target)?;
                         let fn_name = func.name(db).display(db, edition).to_string();
                         Ok(format!("{container_name}::{fn_name}({args})"))
-                    }
+                    },
                     None => {
                         let fn_name = mod_item_path_str(sema_scope, &ModuleDef::Function(*func))?;
                         Ok(format!("{fn_name}({args})"))
-                    }
+                    },
                 }
-            }
+            },
             Expr::Method { func, target, params, .. } => {
                 if self.contains_many_in_illegal_pos(db) {
                     return Ok(many_formatter(&target.ty(db)));
                 }
-
                 let func_name = func.name(db).display(db, edition).to_string();
                 let self_param = func.self_param(db).unwrap();
                 let target_str =
                     .collect::<Result<Vec<String>, DisplaySourceCodeError>>()?
                     .into_iter()
                     .join(", ");
-
                 match func.as_assoc_item(db).and_then(|it| it.container_or_implemented_trait(db)) {
                     Some(trait_) => {
                         let trait_name = mod_item_path_str(sema_scope, &ModuleDef::Trait(trait_))?;
                             false => format!("{trait_name}::{func_name}({target}, {args})",),
                         };
                         Ok(res)
-                    }
+                    },
                     None => Ok(format!("{target_str}.{func_name}({args})")),
                 }
-            }
+            },
             Expr::Variant { variant, params, .. } => {
                 let inner = match variant.kind(db) {
                     StructKind::Tuple => {
                     }
                     StructKind::Unit => String::new(),
                 };
-
                 let prefix = mod_item_path_str(sema_scope, &ModuleDef::Variant(*variant))?;
                 Ok(format!("{prefix}{inner}"))
-            }
+            },
             Expr::Struct { strukt, params, .. } => {
                 let inner = match strukt.kind(db) {
                     StructKind::Tuple => {
                     }
                     StructKind::Unit => String::new(),
                 };
-
                 let prefix = mod_item_path_str(sema_scope, &ModuleDef::Adt(Adt::Struct(*strukt)))?;
                 Ok(format!("{prefix}{inner}"))
-            }
+            },
             Expr::Tuple { params, .. } => {
                 let args = params
                     .iter()
                     .join(", ");
                 let res = format!("({args})");
                 Ok(res)
-            }
+            },
             Expr::Field { expr, field } => {
                 if expr.contains_many_in_illegal_pos(db) {
                     return Ok(many_formatter(&expr.ty(db)));
                 }
-
                 let strukt =
                     expr.gen_source_code(sema_scope, many_formatter, cfg, display_target)?;
                 let field = field.name(db).display(db, edition).to_string();
                 Ok(format!("{strukt}.{field}"))
-            }
+            },
             Expr::Reference(expr) => {
                 if expr.contains_many_in_illegal_pos(db) {
                     return Ok(many_formatter(&expr.ty(db)));
                 }
-
                 let inner =
                     expr.gen_source_code(sema_scope, many_formatter, cfg, display_target)?;
                 Ok(format!("&{inner}"))
-            }
+            },
             Expr::Many(ty) => Ok(many_formatter(ty)),
         }
     }
             Expr::FamousType { ty, .. } => ty.clone(),
             Expr::Function { func, generics, .. } => {
                 func.ret_type_with_args(db, generics.iter().cloned())
-            }
+            },
             Expr::Method { func, generics, target, .. } => func.ret_type_with_args(
                 db,
                 target.ty(db).type_arguments().chain(generics.iter().cloned()),
             ),
             Expr::Variant { variant, generics, .. } => {
                 Adt::from(variant.parent_enum(db)).ty_with_args(db, generics.iter().cloned())
-            }
+            },
             Expr::Struct { strukt, generics, .. } => {
                 Adt::from(*strukt).ty_with_args(db, generics.iter().cloned())
-            }
+            },
             Expr::Tuple { ty, .. } => ty.clone(),
             Expr::Field { expr, field } => field.ty_with_args(db, expr.ty(db).type_arguments()),
             Expr::Reference(it) => it.ty(db),
                     Some(_) => false,
                     None => target.is_many(),
                 }
-            }
+            },
             Expr::Field { expr, .. } => expr.contains_many_in_illegal_pos(db),
             Expr::Reference(target) => target.is_many(),
             Expr::Many(_) => true,