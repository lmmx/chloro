COMPARISON DIFF
============================================================

Original size: 72179 bytes
Chloro size:   71930 bytes
Rustfmt size:  72179 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! So, this modules should not be used during hir construction, it exists
 //! purely for "IDE needs".
+
 use std::iter::{self, once};
 
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, CallableDefId, ConstId, DefWithBodyId, FieldId, FunctionId, GenericDefId,
-    LocalFieldId, ModuleDefId, StructId, TraitId, VariantId,
     expr_store::{
-        Body, BodySourceMap, ExpressionStore, ExpressionStoreSourceMap, HygieneId,
-        lower::ExprCollector,
-        path::Path,
-        scope::{ExprScopes, ScopeId},
+        lower::ExprCollector, path::Path, scope::{ExprScopes, ScopeId}, Body, BodySourceMap,
+        ExpressionStore, ExpressionStoreSourceMap, HygieneId,
     },
     hir::{BindingId, Expr, ExprId, ExprOrPatId, Pat},
     lang_item::LangItem,
     nameres::MacroSubNs,
-    resolver::{HasResolver, Resolver, TypeNs, ValueNs, resolver_for_scope},
+    resolver::{resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},
     type_ref::{Mutability, TypeRefId},
+    AdtId, AssocItemId, CallableDefId, ConstId, DefWithBodyId, FieldId, FunctionId, GenericDefId,
+    LocalFieldId, ModuleDefId, StructId, TraitId, VariantId,
 };
 use hir_expand::{
-    HirFileId, InFile,
-    mod_path::{ModPath, PathKind, path},
+    mod_path::{path, ModPath, PathKind},
     name::{AsName, Name},
+    HirFileId, InFile,
 };
 use hir_ty::{
-    Adjustment, InferenceResult, LifetimeElisionKind, TraitEnvironment, TyLoweringContext,
     diagnostics::{
-        InsideUnsafeBlock, record_literal_missing_fields, record_pattern_missing_fields,
-        unsafe_operations,
+        record_literal_missing_fields, record_pattern_missing_fields, unsafe_operations,
+        InsideUnsafeBlock,
     },
     lang_items::lang_items_for_bin_op,
     method_resolution,
     next_solver::{
-        DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind, TypingMode, infer::DbInternerInferExt,
+        infer::DbInternerInferExt, DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind,
+        TypingMode,
     },
     traits::structurally_normalize_ty,
+    Adjustment, InferenceResult, LifetimeElisionKind, TraitEnvironment, TyLoweringContext,
 };
 use intern::sym;
 use itertools::Itertools;
 use rustc_type_ir::{
-    AliasTyKind,
     inherent::{AdtDef, IntoKind, Ty as _},
+    AliasTyKind,
 };
 use smallvec::SmallVec;
 use stdx::never;
 use syntax::{
-    SyntaxKind, SyntaxNode, TextRange, TextSize,
     ast::{self, AstNode, RangeItem, RangeOp},
+    SyntaxKind, SyntaxNode, TextRange, TextSize,
 };
 use triomphe::Arc;
 
 use crate::{
+    db::HirDatabase,
+    semantics::{PathResolution, PathResolutionPerNs},
     Adt, AssocItem, BindingMode, BuiltinAttr, BuiltinType, Callable, Const, DeriveHelper, Field,
     Function, GenericSubstitution, Local, Macro, ModuleDef, Static, Struct, ToolModule, Trait,
     TupleField, Type, TypeAlias, Variant,
-    db::HirDatabase,
-    semantics::{PathResolution, PathResolutionPerNs},
 };
 
 /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of
         def: GenericDefId,
         store: Arc<ExpressionStore>,
         source_map: Arc<ExpressionStoreSourceMap>,
-        // infer: Option<Arc<InferenceResult>>,
     },
 }
 
         SourceAnalyzer { resolver, body_or_sig: None, file_id: node.file_id }
     }
 
-    // FIXME: Remove this
     fn body_(
         &self,
     ) -> Option<(DefWithBodyId, &Body, &BodySourceMap, Option<&InferenceResult<'db>>)> {
             // small problem).
             LifetimeElisionKind::Infer,
         )
-        .lower_ty(type_ref);
+            .lower_ty(type_ref);
         Some(Type::new_with_resolver(db, &self.resolver, ty))
     }
 
             }
         })
     }
+
     pub(crate) fn pattern_adjustments(
         &self,
         db: &'db dyn HirDatabase,
         &self,
         db: &'db dyn HirDatabase,
         field: &ast::FieldExpr,
-    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)>
-    {
+    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)> {
         let (def, ..) = self.body_()?;
         let expr_id = self.expr_id(field.clone().into())?.as_expr()?;
         let inference_result = self.infer()?;
         let base_ty = self.ty_of_expr(index_expr.base()?)?;
         let index_ty = self.ty_of_expr(index_expr.index()?)?;
 
-        let (_index_trait, index_fn) =
-            self.lang_trait_fn(db, LangItem::Index, &Name::new_symbol_root(sym::index))?;
+        let (_index_trait, index_fn) = self.lang_trait_fn(db, LangItem::Index, &Name::new_symbol_root(sym::index))?;
         let op_fn = self
             .infer()
             .and_then(|infer| {
 
         // FIXME: collectiong here shouldnt be necessary?
         let mut collector = ExprCollector::new(db, self.resolver.module(), self.file_id);
-        let hir_path =
-            collector.lower_path(path.clone(), &mut ExprCollector::impl_trait_error_allocator)?;
+        let hir_path = collector.lower_path(path.clone(), &mut ExprCollector::impl_trait_error_allocator)?;
         let parent_hir_path = path
             .parent_path()
             .and_then(|p| collector.lower_path(p, &mut ExprCollector::impl_trait_error_allocator));
         let (store, _) = collector.store.finish();
 
         // Case where path is a qualifier of a use tree, e.g. foo::bar::{Baz, Qux} where we are
+
         // trying to resolve foo::bar.
         if let Some(use_tree) = parent().and_then(ast::UseTree::cast)
             && use_tree.coloncolon_token().is_some()
             .and_then(ast::Meta::cast);
 
         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we are
+
         // trying to resolve foo::bar.
         if let Some(parent_hir_path) = parent_hir_path {
             return match resolve_hir_path_qualifier(db, &self.resolver, &hir_path, &store) {
         path: &ast::Path,
     ) -> Option<PathResolutionPerNs> {
         let mut collector = ExprCollector::new(db, self.resolver.module(), self.file_id);
-        let hir_path =
-            collector.lower_path(path.clone(), &mut ExprCollector::impl_trait_error_allocator)?;
+        let hir_path = collector.lower_path(path.clone(), &mut ExprCollector::impl_trait_error_allocator)?;
         let (store, _) = collector.store.finish();
         Some(resolve_hir_path_(
             db,
         let pat_id = self.pat_id(&pattern.clone().into())?.as_pat()?;
         let substs = infer[pat_id].as_adt()?.1;
 
-        let (variant, missing_fields, _exhaustive) =
-            record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;
+        let (variant, missing_fields, _exhaustive) = record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;
         let res = self.missing_fields(db, substs, variant, missing_fields);
         Some(res)
     }
         })
 }
 
-// XXX: during completion, cursor might be outside of any particular
-// expression. Try to figure out the correct scope...
 fn adjust(
     db: &dyn HirDatabase,
     scopes: &ExprScopes,