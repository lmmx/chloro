COMPARISON DIFF
============================================================

Original size: 72179 bytes
Chloro size:   72043 bytes
Rustfmt size:  72179 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! So, this modules should not be used during hir construction, it exists
 //! purely for "IDE needs".
+
 use std::iter::{self, once};
 
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, CallableDefId, ConstId, DefWithBodyId, FieldId, FunctionId, GenericDefId,
-    LocalFieldId, ModuleDefId, StructId, TraitId, VariantId,
     expr_store::{
-        Body, BodySourceMap, ExpressionStore, ExpressionStoreSourceMap, HygieneId,
-        lower::ExprCollector,
-        path::Path,
-        scope::{ExprScopes, ScopeId},
+        lower::ExprCollector, path::Path, scope::{ExprScopes, ScopeId}, Body, BodySourceMap,
+        ExpressionStore, ExpressionStoreSourceMap, HygieneId,
     },
     hir::{BindingId, Expr, ExprId, ExprOrPatId, Pat},
     lang_item::LangItem,
     nameres::MacroSubNs,
-    resolver::{HasResolver, Resolver, TypeNs, ValueNs, resolver_for_scope},
+    resolver::{resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},
     type_ref::{Mutability, TypeRefId},
+    AdtId, AssocItemId, CallableDefId, ConstId, DefWithBodyId, FieldId, FunctionId, GenericDefId,
+    LocalFieldId, ModuleDefId, StructId, TraitId, VariantId,
 };
 use hir_expand::{
-    HirFileId, InFile,
-    mod_path::{ModPath, PathKind, path},
+    mod_path::{path, ModPath, PathKind},
     name::{AsName, Name},
+    HirFileId, InFile,
 };
 use hir_ty::{
-    Adjustment, InferenceResult, LifetimeElisionKind, TraitEnvironment, TyLoweringContext,
     diagnostics::{
-        InsideUnsafeBlock, record_literal_missing_fields, record_pattern_missing_fields,
-        unsafe_operations,
+        record_literal_missing_fields, record_pattern_missing_fields, unsafe_operations,
+        InsideUnsafeBlock,
     },
     lang_items::lang_items_for_bin_op,
     method_resolution,
     next_solver::{
-        DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind, TypingMode, infer::DbInternerInferExt,
+        infer::DbInternerInferExt, DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind,
+        TypingMode,
     },
     traits::structurally_normalize_ty,
+    Adjustment, InferenceResult, LifetimeElisionKind, TraitEnvironment, TyLoweringContext,
 };
 use intern::sym;
 use itertools::Itertools;
 use rustc_type_ir::{
-    AliasTyKind,
     inherent::{AdtDef, IntoKind, Ty as _},
+    AliasTyKind,
 };
 use smallvec::SmallVec;
 use stdx::never;
 use syntax::{
-    SyntaxKind, SyntaxNode, TextRange, TextSize,
     ast::{self, AstNode, RangeItem, RangeOp},
+    SyntaxKind, SyntaxNode, TextRange, TextSize,
 };
 use triomphe::Arc;
 
 use crate::{
+    db::HirDatabase,
+    semantics::{PathResolution, PathResolutionPerNs},
     Adt, AssocItem, BindingMode, BuiltinAttr, BuiltinType, Callable, Const, DeriveHelper, Field,
     Function, GenericSubstitution, Local, Macro, ModuleDef, Static, Struct, ToolModule, Trait,
     TupleField, Type, TypeAlias, Variant,
-    db::HirDatabase,
-    semantics::{PathResolution, PathResolutionPerNs},
 };
 
 /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of
         def: GenericDefId,
         store: Arc<ExpressionStore>,
         source_map: Arc<ExpressionStoreSourceMap>,
-        // infer: Option<Arc<InferenceResult>>,
     },
 }
 
         SourceAnalyzer { resolver, body_or_sig: None, file_id: node.file_id }
     }
 
-    // FIXME: Remove this
     fn body_(
         &self,
     ) -> Option<(DefWithBodyId, &Body, &BodySourceMap, Option<&InferenceResult<'db>>)> {
             }
         })
     }
+
     pub(crate) fn pattern_adjustments(
         &self,
         db: &'db dyn HirDatabase,
         &self,
         db: &'db dyn HirDatabase,
         field: &ast::FieldExpr,
-    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)>
-    {
+    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)> {
         let (def, ..) = self.body_()?;
         let expr_id = self.expr_id(field.clone().into())?.as_expr()?;
         let inference_result = self.infer()?;
         let variant_data = variant.fields(db);
         let field = FieldId { parent: variant, local_id: variant_data.field(&local_name)? };
         let field_ty = (*db.field_types(variant).get(field.local_id)?).instantiate(interner, subst);
-        Some((
+        Some(
+            (
             field.into(),
             local,
             Type::new_with_resolver(db, &self.resolver, field_ty),
             GenericSubstitution::new(adt.into(), subst, self.trait_environment(db)),
-        ))
+        ),
+        )
     }
 
     pub(crate) fn resolve_record_pat_field(
         let field = FieldId { parent: variant, local_id: variant_data.field(&field_name)? };
         let (adt, subst) = self.infer()?[pat_id.as_pat()?].as_adt()?;
         let field_ty = (*db.field_types(variant).get(field.local_id)?).instantiate(interner, subst);
-        Some((
+        Some(
+            (
             field.into(),
             Type::new_with_resolver(db, &self.resolver, field_ty),
             GenericSubstitution::new(adt.into(), subst, self.trait_environment(db)),
-        ))
+        ),
+        )
     }
 
     pub(crate) fn resolve_bind_pat_to_const(
         let (store, _) = collector.store.finish();
 
         // Case where path is a qualifier of a use tree, e.g. foo::bar::{Baz, Qux} where we are
+
         // trying to resolve foo::bar.
         if let Some(use_tree) = parent().and_then(ast::UseTree::cast)
             && use_tree.coloncolon_token().is_some()
             .and_then(ast::Meta::cast);
 
         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we are
+
         // trying to resolve foo::bar.
         if let Some(parent_hir_path) = parent_hir_path {
             return match resolve_hir_path_qualifier(db, &self.resolver, &hir_path, &store) {
         let hir_path =
             collector.lower_path(path.clone(), &mut ExprCollector::impl_trait_error_allocator)?;
         let (store, _) = collector.store.finish();
-        Some(resolve_hir_path_(
+        Some(
+            resolve_hir_path_(
             db,
             &self.resolver,
             &hir_path,
             name_hygiene(db, InFile::new(self.file_id, path.syntax())),
             Some(&store),
             true,
-        ))
+        ),
+        )
     }
 
     pub(crate) fn record_literal_missing_fields(
         })
 }
 
-// XXX: during completion, cursor might be outside of any particular
-// expression. Try to figure out the correct scope...
 fn adjust(
     db: &dyn HirDatabase,
     scopes: &ExprScopes,