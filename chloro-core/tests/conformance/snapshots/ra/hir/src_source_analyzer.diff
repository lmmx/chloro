COMPARISON DIFF
============================================================

Original size: 72179 bytes
Chloro size:   71228 bytes
Rustfmt size:  72179 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! So, this modules should not be used during hir construction, it exists
 //! purely for "IDE needs".
+
 use std::iter::{self, once};
 
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, CallableDefId, ConstId, DefWithBodyId, FieldId, FunctionId, GenericDefId,
-    LocalFieldId, ModuleDefId, StructId, TraitId, VariantId,
     expr_store::{
-        Body, BodySourceMap, ExpressionStore, ExpressionStoreSourceMap, HygieneId,
-        lower::ExprCollector,
-        path::Path,
-        scope::{ExprScopes, ScopeId},
+        lower::ExprCollector, path::Path, scope::{ExprScopes, ScopeId}, Body, BodySourceMap,
+        ExpressionStore, ExpressionStoreSourceMap, HygieneId,
     },
     hir::{BindingId, Expr, ExprId, ExprOrPatId, Pat},
     lang_item::LangItem,
     nameres::MacroSubNs,
-    resolver::{HasResolver, Resolver, TypeNs, ValueNs, resolver_for_scope},
+    resolver::{resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},
     type_ref::{Mutability, TypeRefId},
+    AdtId, AssocItemId, CallableDefId, ConstId, DefWithBodyId, FieldId, FunctionId, GenericDefId,
+    LocalFieldId, ModuleDefId, StructId, TraitId, VariantId,
 };
 use hir_expand::{
-    HirFileId, InFile,
-    mod_path::{ModPath, PathKind, path},
+    mod_path::{path, ModPath, PathKind},
     name::{AsName, Name},
+    HirFileId, InFile,
 };
 use hir_ty::{
-    Adjustment, InferenceResult, LifetimeElisionKind, TraitEnvironment, TyLoweringContext,
     diagnostics::{
-        InsideUnsafeBlock, record_literal_missing_fields, record_pattern_missing_fields,
-        unsafe_operations,
+        record_literal_missing_fields, record_pattern_missing_fields, unsafe_operations,
+        InsideUnsafeBlock,
     },
     lang_items::lang_items_for_bin_op,
     method_resolution,
     next_solver::{
-        DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind, TypingMode, infer::DbInternerInferExt,
+        infer::DbInternerInferExt, DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind,
+        TypingMode,
     },
     traits::structurally_normalize_ty,
+    Adjustment, InferenceResult, LifetimeElisionKind, TraitEnvironment, TyLoweringContext,
 };
 use intern::sym;
 use itertools::Itertools;
 use rustc_type_ir::{
-    AliasTyKind,
     inherent::{AdtDef, IntoKind, Ty as _},
+    AliasTyKind,
 };
 use smallvec::SmallVec;
 use stdx::never;
 use syntax::{
-    SyntaxKind, SyntaxNode, TextRange, TextSize,
     ast::{self, AstNode, RangeItem, RangeOp},
+    SyntaxKind, SyntaxNode, TextRange, TextSize,
 };
 use triomphe::Arc;
 
 use crate::{
+    db::HirDatabase,
+    semantics::{PathResolution, PathResolutionPerNs},
     Adt, AssocItem, BindingMode, BuiltinAttr, BuiltinType, Callable, Const, DeriveHelper, Field,
     Function, GenericSubstitution, Local, Macro, ModuleDef, Static, Struct, ToolModule, Trait,
     TupleField, Type, TypeAlias, Variant,
-    db::HirDatabase,
-    semantics::{PathResolution, PathResolutionPerNs},
 };
 
 /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of
         def: GenericDefId,
         store: Arc<ExpressionStore>,
         source_map: Arc<ExpressionStoreSourceMap>,
-        // infer: Option<Arc<InferenceResult>>,
     },
 }
 
         SourceAnalyzer { resolver, body_or_sig: None, file_id: node.file_id }
     }
 
-    // FIXME: Remove this
     fn body_(
         &self,
     ) -> Option<(DefWithBodyId, &Body, &BodySourceMap, Option<&InferenceResult<'db>>)> {
         self.body_or_sig.as_ref().and_then(|it| match it {
             BodyOrSig::Body { def, body, source_map, infer } => {
                 Some((*def, &**body, &**source_map, infer.as_deref()))
-            }
+            },
             _ => None,
         })
     }
 
     fn binding_id_of_pat(&self, pat: &ast::IdentPat) -> Option<BindingId> {
         let pat_id = self.pat_id(&pat.clone().into())?;
-        if let Pat::Bind { id, .. } = self.store()?[pat_id.as_pat()?] { Some(id) } else { None }
+        if let Pat::Bind { id, .. } = self.store()?[pat_id.as_pat()?] {
+            Some(id)
+        } else {
+            None
+        }
     }
 
     pub(crate) fn expr_adjustments(&self, expr: &ast::Expr) -> Option<&[Adjustment<'db>]> {
             hir_ty::BindingMode::Move => BindingMode::Move,
             hir_ty::BindingMode::Ref(hir_ty::next_solver::Mutability::Mut) => {
                 BindingMode::Ref(Mutability::Mut)
-            }
+            },
             hir_ty::BindingMode::Ref(hir_ty::next_solver::Mutability::Not) => {
                 BindingMode::Ref(Mutability::Shared)
-            }
+            },
         })
     }
+
     pub(crate) fn pattern_adjustments(
         &self,
         db: &'db dyn HirDatabase,
     ) -> Option<SmallVec<[Type<'db>; 1]>> {
         let pat_id = self.pat_id(pat)?;
         let infer = self.infer()?;
-        Some(
-            infer
-                .pat_adjustment(pat_id.as_pat()?)?
-                .iter()
-                .map(|ty| Type::new_with_resolver(db, &self.resolver, *ty))
-                .collect(),
-        )
+        Some(infer.pat_adjustment(pat_id.as_pat()?)?.iter().map(
+            |ty| Type::new_with_resolver(db, &self.resolver, *ty),
+        ).collect(
+        ))
     }
 
     pub(crate) fn resolve_method_call_as_callable(
                     Either::Left(fn_.into()),
                     Some(GenericSubstitution::new(fn_.into(), subst, self.trait_environment(db))),
                 ))
-            }
+            },
             None => {
                 inference_result.field_resolution(expr_id).and_then(Either::left).map(|field| {
                     (Either::Right(field.into()), self.field_subst(expr_id, inference_result, db))
                 })
-            }
+            },
         }
     }
 
         let (def, ..) = self.body_()?;
         let expr_id = self.expr_id(field.clone().into())?.as_expr()?;
         self.infer()?.field_resolution(expr_id).map(|it| {
-            it.map_either(Into::into, |f| TupleField { owner: def, tuple: f.tuple, index: f.index })
+            it.map_either(
+                Into::into,
+                |f| TupleField {
+                owner: def,
+                tuple: f.tuple,
+                index: f.index,
+            },
+            )
         })
     }
 
         &self,
         db: &'db dyn HirDatabase,
         field: &ast::FieldExpr,
-    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)>
-    {
+    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)> {
         let (def, ..) = self.body_()?;
         let expr_id = self.expr_id(field.clone().into())?.as_expr()?;
         let inference_result = self.infer()?;
                 )),
                 Either::Right(field) => Some((
                     Either::Left(Either::Right(TupleField {
-                        owner: def,
-                        tuple: field.tuple,
-                        index: field.index,
-                    })),
+                    owner: def,
+                    tuple: field.tuple,
+                    index: field.index,
+                })),
                     None,
                 )),
             },
 
     pub(crate) fn resolve_use_type_arg(&self, name: &ast::NameRef) -> Option<crate::TypeParam> {
         let name = name.as_name();
-        self.resolver
-            .all_generic_params()
-            .find_map(|(params, parent)| params.find_type_by_name(&name, *parent))
-            .map(crate::TypeParam::from)
+        self.resolver.all_generic_params().find_map(
+            |(params, parent)| params.find_type_by_name(&name, *parent),
+        ).map(
+            crate::TypeParam::from,
+        )
     }
 
     pub(crate) fn resolve_offset_of_field(
         let (store, _) = collector.store.finish();
 
         // Case where path is a qualifier of a use tree, e.g. foo::bar::{Baz, Qux} where we are
+
         // trying to resolve foo::bar.
         if let Some(use_tree) = parent().and_then(ast::UseTree::cast)
             && use_tree.coloncolon_token().is_some()
             .and_then(ast::Meta::cast);
 
         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we are
+
         // trying to resolve foo::bar.
         if let Some(parent_hir_path) = parent_hir_path {
             return match resolve_hir_path_qualifier(db, &self.resolver, &hir_path, &store) {
             };
         }
         if parent().is_some_and(|it| ast::Visibility::can_cast(it.kind())) {
-            // No substitution because only modules can be inside visibilities, and those have no generics.
             resolve_hir_path_qualifier(db, &self.resolver, &hir_path, &store).map(|it| (it, None))
         } else {
-            // Probably a type, no need to show substitutions for those.
             let res = resolve_hir_path_(
                 db,
                 &self.resolver,
         let interner = DbInterner::new_with(db, None, None);
         let field_types = db.field_types(variant);
 
-        missing_fields
-            .into_iter()
-            .map(|local_id| {
-                let field = FieldId { parent: variant, local_id };
-                let ty = field_types[local_id].instantiate(interner, substs);
-                (field.into(), Type::new_with_resolver_inner(db, &self.resolver, ty))
-            })
-            .collect()
+        missing_fields.into_iter().map(|local_id| {
+            let field = FieldId { parent: variant, local_id };
+            let ty = field_types[local_id].instantiate(interner, substs);
+            (field.into(), Type::new_with_resolver_inner(db, &self.resolver, ty))
+        }).collect(
+        )
     }
 
     pub(crate) fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantId> {
             (
                 *range,
                 resolve_hir_value_path(
-                    db,
-                    &self.resolver,
-                    self.resolver.body_owner(),
-                    &Path::from_known_path_with_no_generic(ModPath::from_segments(
-                        PathKind::Plain,
-                        Some(name.clone()),
-                    )),
-                    hygiene,
-                ),
+                db,
+                &self.resolver,
+                self.resolver.body_owner(),
+                &Path::from_known_path_with_no_generic(
+                ModPath::from_segments(PathKind::Plain, Some(name.clone())),
+            ),
+                hygiene,
+            ),
             )
         })
     }
     ) -> Option<(DefWithBodyId, (ExprId, TextRange, usize))> {
         let (def, _, body_source_map, _) = self.body_()?;
         let (expr, args) = body_source_map.asm_template_args(asm)?;
-        Some(def).zip(
-            args.get(line)?
-                .iter()
-                .find(|(range, _)| range.contains_inclusive(offset))
-                .map(|(range, idx)| (expr, *range, *idx)),
-        )
+        Some(def).zip(args.get(line)?.iter().find(|(range, _)| range.contains_inclusive(offset)).map(
+            |(range, idx)| (expr, *range, *idx),
+        ))
     }
 
     pub(crate) fn as_format_args_parts<'a>(
             (
                 *range,
                 resolve_hir_value_path(
-                    db,
-                    &self.resolver,
-                    self.resolver.body_owner(),
-                    &Path::from_known_path_with_no_generic(ModPath::from_segments(
-                        PathKind::Plain,
-                        Some(name.clone()),
-                    )),
-                    hygiene,
-                ),
+                db,
+                &self.resolver,
+                self.resolver.body_owner(),
+                &Path::from_known_path_with_no_generic(
+                ModPath::from_segments(PathKind::Plain, Some(name.clone())),
+            ),
+                hygiene,
+            ),
             )
         }))
     }
     source_map: &BodySourceMap,
     node: InFile<&SyntaxNode>,
 ) -> Option<ScopeId> {
-    node.ancestors_with_macros(db)
-        .take_while(|it| {
-            let kind = it.kind();
-            !ast::Item::can_cast(kind)
-                || ast::MacroCall::can_cast(kind)
-                || ast::Use::can_cast(kind)
-                || ast::AsmExpr::can_cast(kind)
-        })
-        .filter_map(|it| it.map(ast::Expr::cast).transpose())
-        .filter_map(|it| source_map.node_expr(it.as_ref())?.as_expr())
-        .find_map(|it| scopes.scope_for(it))
+    node.ancestors_with_macros(db).take_while(|it| {
+        let kind = it.kind();
+        !ast::Item::can_cast(kind) || ast::MacroCall::can_cast(kind) || ast::Use::can_cast(kind) || ast::AsmExpr::can_cast(kind)
+    }).filter_map(
+        |it| it.map(ast::Expr::cast).transpose(),
+    ).filter_map(
+        |it| source_map.node_expr(it.as_ref())?.as_expr(),
+    ).find_map(
+        |it| scopes.scope_for(it),
+    )
 }
 
 fn scope_for_offset(
     from_file: HirFileId,
     offset: TextSize,
 ) -> Option<ScopeId> {
-    scopes
-        .scope_by_expr()
-        .iter()
-        .filter_map(|(id, scope)| {
-            let InFile { file_id, value } = source_map.expr_syntax(id).ok()?;
-            if from_file == file_id {
+    scopes.scope_by_expr().iter().filter_map(|(id, scope)| {
+        let InFile { file_id, value } = source_map.expr_syntax(id).ok()?;
+        if from_file == file_id {
                 return Some((value.text_range(), scope));
             }
-
-            // FIXME handle attribute expansion
-            let source = iter::successors(file_id.macro_file().map(|it| it.call_node(db)), |it| {
+        let source = iter::successors(file_id.macro_file().map(|it| it.call_node(db)), |it| {
                 Some(it.file_id.macro_file()?.call_node(db))
             })
             .find(|it| it.file_id == from_file)
             .filter(|it| it.kind() == SyntaxKind::MACRO_CALL)?;
-            Some((source.text_range(), scope))
-        })
-        .filter(|(expr_range, _scope)| expr_range.start() <= offset && offset <= expr_range.end())
-        // find containing scope
-        .min_by_key(|(expr_range, _scope)| expr_range.len())
-        .map(|(expr_range, scope)| {
-            adjust(db, scopes, source_map, expr_range, from_file, offset).unwrap_or(*scope)
-        })
+        Some((source.text_range(), scope))
+    }).filter(
+        |(expr_range, _scope)| expr_range.start() <= offset && offset <= expr_range.end(),
+    ).min_by_key(
+        |(expr_range, _scope)| expr_range.len(),
+    ).map(|(expr_range, scope)| {
+        adjust(db, scopes, source_map, expr_range, from_file, offset).unwrap_or(*scope)
+    })
 }
 
-// XXX: during completion, cursor might be outside of any particular
-// expression. Try to figure out the correct scope...
 fn adjust(
     db: &dyn HirDatabase,
     scopes: &ExprScopes,
             range.start() <= offset && expr_range.contains_range(range) && range != expr_range
         });
 
-    child_scopes
-        .max_by(|&(r1, _), &(r2, _)| {
-            if r1.contains_range(r2) {
-                std::cmp::Ordering::Greater
-            } else if r2.contains_range(r1) {
-                std::cmp::Ordering::Less
-            } else {
-                r1.start().cmp(&r2.start())
-            }
-        })
-        .map(|(_ptr, scope)| *scope)
+    child_scopes.max_by(|&(r1, _), &(r2, _)| {
+        if r1.contains_range(r2) {
+            std::cmp::Ordering::Greater
+        } else if r2.contains_range(r1) {
+            std::cmp::Ordering::Less
+        } else {
+            r1.start().cmp(&r2.start())
+        }
+    }).map(
+        |(_ptr, scope)| *scope,
+    )
 }
 
 #[inline]
     resolver: &Resolver<'_>,
     path: &Path,
 ) -> Option<Macro> {
-    resolver
-        .resolve_path_as_macro(db, path.mod_path()?, Some(MacroSubNs::Attr))
-        .map(|(it, _)| it)
-        .map(Into::into)
+    resolver.resolve_path_as_macro(db, path.mod_path()?, Some(MacroSubNs::Attr)).map(|(it, _)| it).map(
+        Into::into,
+    )
 }
 
 fn resolve_hir_path_(
                 .map(|type_ns| PathResolutionPerNs::new(Some(type_ns), None, None))
                 .unwrap_or_else(|| PathResolutionPerNs::new(None, values(), None))
         };
-
         if res.any().is_some() {
             res
         } else if let Some(type_ns) = items() {
                 }
             }
         }?;
-
-        // If we are in a TypeNs for a Trait, and we have an unresolved name, try to resolve it as a type
-        // within the trait's associated types.
         if let (Some(unresolved), &TypeNs::TraitId(trait_id)) = (&unresolved, &ty)
             && let Some(type_alias_id) =
                 trait_id.trait_items(db).associated_type_by_name(unresolved.name)
         {
             return Some(PathResolution::Def(ModuleDefId::from(type_alias_id).into()));
         }
-
         let res = match ty {
             TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),
             TypeNs::GenericParam(id) => PathResolution::TypeParam(id.into()),
             TypeNs::ModuleId(it) => PathResolution::Def(ModuleDef::Module(it.into())),
         };
         match unresolved {
-            Some(unresolved) => resolver
-                .generic_def()
-                .and_then(|def| {
-                    hir_ty::associated_type_shorthand_candidates(
-                        db,
-                        def,
-                        res.in_type_ns()?,
-                        |name, _| name == unresolved.name,
-                    )
-                })
-                .map(TypeAlias::from)
-                .map(Into::into)
-                .map(PathResolution::Def),
+            Some(unresolved) => resolver.generic_def().and_then(|def| {
+                hir_ty::associated_type_shorthand_candidates(
+                    db,
+                    def,
+                    res.in_type_ns()?,
+                    |name, _| name == unresolved.name,
+                )
+            }).map(
+                TypeAlias::from,
+            ).map(
+                Into::into,
+            ).map(
+                PathResolution::Def,
+            ),
             None => Some(res),
         }
-    })()
-    .or_else(|| {
-        resolver
-            .resolve_module_path_in_items(db, path.mod_path()?)
-            .take_types()
-            .map(|it| PathResolution::Def(it.into()))
+    })(
+    ).or_else(|| {
+        resolver.resolve_module_path_in_items(db, path.mod_path()?).take_types().map(
+            |it| PathResolution::Def(it.into()),
+        )
     })
 }
 