COMPARISON DIFF
============================================================

Original size: 72179 bytes
Chloro size:   72141 bytes
Rustfmt size:  72179 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! So, this modules should not be used during hir construction, it exists
 //! purely for "IDE needs".
+
 use std::iter::{self, once};
 
 use either::Either;
     LocalFieldId, ModuleDefId, StructId, TraitId, VariantId,
     expr_store::{
         Body, BodySourceMap, ExpressionStore, ExpressionStoreSourceMap, HygieneId,
-        lower::ExprCollector,
-        path::Path,
-        scope::{ExprScopes, ScopeId},
+        lower::ExprCollector, path::Path, scope::{ExprScopes, ScopeId},
     },
     hir::{BindingId, Expr, ExprId, ExprOrPatId, Pat},
     lang_item::LangItem,
     lang_items::lang_items_for_bin_op,
     method_resolution,
     next_solver::{
-        DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind, TypingMode, infer::DbInternerInferExt,
+        DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind, TypingMode,
+        infer::DbInternerInferExt,
     },
     traits::structurally_normalize_ty,
 };
         def: GenericDefId,
         store: Arc<ExpressionStore>,
         source_map: Arc<ExpressionStoreSourceMap>,
-        // infer: Option<Arc<InferenceResult>>,
     },
 }
 
 
     fn binding_id_of_pat(&self, pat: &ast::IdentPat) -> Option<BindingId> {
         let pat_id = self.pat_id(&pat.clone().into())?;
-        if let Pat::Bind { id, .. } = self.store()?[pat_id.as_pat()?] { Some(id) } else { None }
+        if let Pat::Bind { id, .. } = self.store()?[pat_id.as_pat()?] {
+            Some(id)
+        } else {
+            None
+        }
     }
 
     pub(crate) fn expr_adjustments(&self, expr: &ast::Expr) -> Option<&[Adjustment<'db>]> {
             }
         })
     }
+
     pub(crate) fn pattern_adjustments(
         &self,
         db: &'db dyn HirDatabase,
         &self,
         db: &'db dyn HirDatabase,
         field: &ast::FieldExpr,
-    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)>
-    {
+    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)> {
         let (def, ..) = self.body_()?;
         let expr_id = self.expr_id(field.clone().into())?.as_expr()?;
         let inference_result = self.infer()?;
                 )),
                 Either::Right(field) => Some((
                     Either::Left(Either::Right(TupleField {
-                        owner: def,
-                        tuple: field.tuple,
-                        index: field.index,
-                    })),
+                    owner: def,
+                    tuple: field.tuple,
+                    index: field.index,
+                })),
                     None,
                 )),
             },
         let (store, _) = collector.store.finish();
 
         // Case where path is a qualifier of a use tree, e.g. foo::bar::{Baz, Qux} where we are
+
         // trying to resolve foo::bar.
         if let Some(use_tree) = parent().and_then(ast::UseTree::cast)
             && use_tree.coloncolon_token().is_some()
             .and_then(ast::Meta::cast);
 
         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we are
+
         // trying to resolve foo::bar.
         if let Some(parent_hir_path) = parent_hir_path {
             return match resolve_hir_path_qualifier(db, &self.resolver, &hir_path, &store) {
                 .map(|type_ns| PathResolutionPerNs::new(Some(type_ns), None, None))
                 .unwrap_or_else(|| PathResolutionPerNs::new(None, values(), None))
         };
-
         if res.any().is_some() {
             res
         } else if let Some(type_ns) = items() {
                 .map(PathResolution::Def),
             None => Some(res),
         }
-    })()
-    .or_else(|| {
+    })().or_else(|| {
         resolver
             .resolve_module_path_in_items(db, path.mod_path()?)
             .take_types()