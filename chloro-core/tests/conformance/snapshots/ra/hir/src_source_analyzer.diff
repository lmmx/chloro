COMPARISON DIFF
============================================================

Original size: 72179 bytes
Chloro size:   72107 bytes
Rustfmt size:  72179 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! So, this modules should not be used during hir construction, it exists
 //! purely for "IDE needs".
+
 use std::iter::{self, once};
 
 use either::Either;
 use hir_def::{
-    AdtId, AssocItemId, CallableDefId, ConstId, DefWithBodyId, FieldId, FunctionId, GenericDefId,
-    LocalFieldId, ModuleDefId, StructId, TraitId, VariantId,
     expr_store::{
-        Body, BodySourceMap, ExpressionStore, ExpressionStoreSourceMap, HygieneId,
-        lower::ExprCollector,
-        path::Path,
-        scope::{ExprScopes, ScopeId},
-    },
-    hir::{BindingId, Expr, ExprId, ExprOrPatId, Pat},
+        Body,
+
+    hir::{BindingId,
+
     lang_item::LangItem,
+
+    lower::ExprCollector,
+
     nameres::MacroSubNs,
-    resolver::{HasResolver, Resolver, TypeNs, ValueNs, resolver_for_scope},
-    type_ref::{Mutability, TypeRefId},
+
+    path::Path,
+
+    resolver::{HasResolver,
+
+    resolver_for_scope},
+
+    scope::{ExprScopes,
+
+    type_ref::{Mutability,
+
+    AdtId, AssocItemId, BodySourceMap, CallableDefId, ConstId, DefWithBodyId, Expr, ExprId,
+    ExprOrPatId, ExpressionStore, ExpressionStoreSourceMap, FieldId, FunctionId, GenericDefId,
+    HygieneId, LocalFieldId, ModuleDefId, Pat}, Resolver, ScopeId}, StructId, TraitId, TypeNs,
+    TypeRefId}, ValueNs, VariantId, },
 };
 use hir_expand::{
-    HirFileId, InFile,
-    mod_path::{ModPath, PathKind, path},
-    name::{AsName, Name},
+    mod_path::{ModPath,
+
+    name::{AsName,
+
+    path}, HirFileId, InFile, Name}, PathKind,
 };
 use hir_ty::{
-    Adjustment, InferenceResult, LifetimeElisionKind, TraitEnvironment, TyLoweringContext,
     diagnostics::{
-        InsideUnsafeBlock, record_literal_missing_fields, record_pattern_missing_fields,
-        unsafe_operations,
-    },
+        InsideUnsafeBlock,
+
+    infer::DbInternerInferExt,
+
     lang_items::lang_items_for_bin_op,
+
     method_resolution,
+
     next_solver::{
-        DbInterner, ErrorGuaranteed, GenericArgs, Ty, TyKind, TypingMode, infer::DbInternerInferExt,
-    },
+        DbInterner,
+
+    record_literal_missing_fields, record_pattern_missing_fields,
+
     traits::structurally_normalize_ty,
+
+    unsafe_operations, Adjustment, ErrorGuaranteed, GenericArgs, InferenceResult,
+    LifetimeElisionKind, TraitEnvironment, Ty, TyKind, TyLoweringContext, TypingMode, }, },
 };
 use intern::sym;
 use itertools::Itertools;
 use smallvec::SmallVec;
 use stdx::never;
 use syntax::{
-    SyntaxKind, SyntaxNode, TextRange, TextSize,
-    ast::{self, AstNode, RangeItem, RangeOp},
+    ast::{self,
+
+    AstNode, RangeItem, RangeOp}, SyntaxKind, SyntaxNode, TextRange, TextSize,
 };
 use triomphe::Arc;
 
 use crate::{
-    Adt, AssocItem, BindingMode, BuiltinAttr, BuiltinType, Callable, Const, DeriveHelper, Field,
-    Function, GenericSubstitution, Local, Macro, ModuleDef, Static, Struct, ToolModule, Trait,
-    TupleField, Type, TypeAlias, Variant,
     db::HirDatabase,
-    semantics::{PathResolution, PathResolutionPerNs},
+
+    semantics::{PathResolution,
+
+    Adt, AssocItem, BindingMode, BuiltinAttr, BuiltinType, Callable, Const, DeriveHelper, Field,
+    Function, GenericSubstitution, Local, Macro, ModuleDef, PathResolutionPerNs}, Static, Struct,
+    ToolModule, Trait, TupleField, Type, TypeAlias, Variant,
 };
 
 /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of
         source_map: Arc<BodySourceMap>,
         infer: Option<Arc<InferenceResult<'db>>>,
     },
-    // To be folded into body once it is considered one
     VariantFields {
         def: VariantId,
         store: Arc<ExpressionStore>,
         def: GenericDefId,
         store: Arc<ExpressionStore>,
         source_map: Arc<ExpressionStoreSourceMap>,
-        // infer: Option<Arc<InferenceResult>>,
     },
 }
 
         SourceAnalyzer { resolver, body_or_sig: None, file_id: node.file_id }
     }
 
-    // FIXME: Remove this
-    fn body_(
-        &self,
-    ) -> Option<(DefWithBodyId, &Body, &BodySourceMap, Option<&InferenceResult<'db>>)> {
+    fn body_(&self) -> Option<(DefWithBodyId, &Body, &BodySourceMap, Option<&InferenceResult<'db>>)> {
         self.body_or_sig.as_ref().and_then(|it| match it {
             BodyOrSig::Body { def, body, source_map, infer } => {
                 Some((*def, &**body, &**source_map, infer.as_deref()))
         })
     }
 
-    fn trait_environment(&self, db: &'db dyn HirDatabase) -> Arc<TraitEnvironment<'db>> {
+    fn trait_environment(
+        &self,
+        db: &'db dyn HirDatabase,
+    ) -> Arc<TraitEnvironment<'db>> {
         self.body_().map(|(def, ..)| def).map_or_else(
             || TraitEnvironment::empty(self.resolver.krate()),
             |def| db.trait_environment_for_body(def),
         )
     }
 
-    fn expr_id(&self, expr: ast::Expr) -> Option<ExprOrPatId> {
+    fn expr_id(
+        &self,
+        expr: ast::Expr,
+    ) -> Option<ExprOrPatId> {
         let src = InFile { file_id: self.file_id, value: expr };
         self.store_sm()?.node_expr(src.as_ref())
     }
 
-    fn pat_id(&self, pat: &ast::Pat) -> Option<ExprOrPatId> {
+    fn pat_id(
+        &self,
+        pat: &ast::Pat,
+    ) -> Option<ExprOrPatId> {
         let src = InFile { file_id: self.file_id, value: pat };
         self.store_sm()?.node_pat(src)
     }
 
-    fn type_id(&self, pat: &ast::Type) -> Option<TypeRefId> {
+    fn type_id(
+        &self,
+        pat: &ast::Type,
+    ) -> Option<TypeRefId> {
         let src = InFile { file_id: self.file_id, value: pat };
         self.store_sm()?.node_type(src)
     }
 
-    fn binding_id_of_pat(&self, pat: &ast::IdentPat) -> Option<BindingId> {
+    fn binding_id_of_pat(
+        &self,
+        pat: &ast::IdentPat,
+    ) -> Option<BindingId> {
         let pat_id = self.pat_id(&pat.clone().into())?;
         if let Pat::Bind { id, .. } = self.store()?[pat_id.as_pat()?] { Some(id) } else { None }
     }
 
-    pub(crate) fn expr_adjustments(&self, expr: &ast::Expr) -> Option<&[Adjustment<'db>]> {
+    pub(crate) fn expr_adjustments(
+        &self,
+        expr: &ast::Expr,
+    ) -> Option<&[Adjustment<'db>]> {
         // It is safe to omit destructuring assignments here because they have no adjustments (neither
         // expressions nor patterns).
         let expr_id = self.expr_id(expr.clone())?.as_expr()?;
                 infer.pat_adjustment(idx).and_then(|adjusts| adjusts.last().cloned())
             }
         };
-
         let ty = infer[expr_or_pat_id];
         let mk_ty = |ty: Ty<'db>| Type::new_with_resolver(db, &self.resolver, ty);
         Some((mk_ty(ty), coerced.map(mk_ty)))
             }
         })
     }
+
     pub(crate) fn pattern_adjustments(
         &self,
         db: &'db dyn HirDatabase,
     ) -> Option<Function> {
         let expr_id = self.expr_id(call.clone().into())?.as_expr()?;
         let (f_in_trait, substs) = self.infer()?.method_resolution(expr_id)?;
-
         Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, substs).into())
     }
 
         &self,
         db: &'db dyn HirDatabase,
         field: &ast::FieldExpr,
-    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)>
-    {
+    ) -> Option<(Either<Either<Field, TupleField>, Function>, Option<GenericSubstitution<'db>>)> {
         let (def, ..) = self.body_()?;
         let expr_id = self.expr_id(field.clone().into())?.as_expr()?;
         let inference_result = self.infer()?;
         await_expr: &ast::AwaitExpr,
     ) -> Option<FunctionId> {
         let mut ty = self.ty_of_expr(await_expr.expr()?)?;
-
         let into_future_trait = self
             .resolver
             .resolve_known_trait(db, &path![core::future::IntoFuture])
             .map(Trait::from);
-
         if let Some(into_future_trait) = into_future_trait {
             let type_ = Type::new_with_resolver(db, &self.resolver, ty);
             if type_.impls_trait(db, into_future_trait, &[]) {
                 ty = future_trait.ty;
             }
         }
-
         let poll_fn = LangItem::FuturePoll.resolve_function(db, self.resolver.krate())?;
         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself
         // doesn't have any generic parameters, so we skip building another subst for `poll()`.
                 self.lang_trait_fn(db, LangItem::Neg, &Name::new_symbol_root(sym::neg))?
             }
         };
-
         let ty = self.ty_of_expr(prefix_expr.expr()?)?;
-
         let interner = DbInterner::new_with(db, None, None);
         // HACK: subst for all methods coincides with that for their trait because the methods
         // don't have any generic parameters, so we skip building another subst for the methods.
         let substs = GenericArgs::new_from_iter(interner, [ty.into()]);
-
         Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))
     }
 
     ) -> Option<FunctionId> {
         let base_ty = self.ty_of_expr(index_expr.base()?)?;
         let index_ty = self.ty_of_expr(index_expr.index()?)?;
-
         let (_index_trait, index_fn) =
             self.lang_trait_fn(db, LangItem::Index, &Name::new_symbol_root(sym::index))?;
         let op_fn = self
         let op = binop_expr.op_kind()?;
         let lhs = self.ty_of_expr(binop_expr.lhs()?)?;
         let rhs = self.ty_of_expr(binop_expr.rhs()?)?;
-
         let (_op_trait, op_fn) = lang_items_for_bin_op(op)
             .and_then(|(name, lang_item)| self.lang_trait_fn(db, lang_item, &name))?;
         // HACK: subst for `index()` coincides with that for `Index` because `index()` itself
         // doesn't have any generic parameters, so we skip building another subst for `index()`.
         let interner = DbInterner::new_with(db, None, None);
         let substs = GenericArgs::new_from_iter(interner, [lhs.into(), rhs.into()]);
-
         Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))
     }
 
         try_expr: &ast::TryExpr,
     ) -> Option<FunctionId> {
         let ty = self.ty_of_expr(try_expr.expr()?)?;
-
         let op_fn = LangItem::TryTraitBranch.resolve_function(db, self.resolver.krate())?;
         // HACK: subst for `branch()` coincides with that for `Try` because `branch()` itself
         // doesn't have any generic parameters, so we skip building another subst for `branch()`.
         let interner = DbInterner::new_with(db, None, None);
         let substs = GenericArgs::new_from_iter(interner, [ty.into()]);
-
         Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))
     }
 
         let expr = ast::Expr::from(record_expr);
         let expr_id = self.store_sm()?.node_expr(InFile::new(self.file_id, &expr))?;
         let interner = DbInterner::new_with(db, None, None);
-
         let ast_name = field.field_name()?;
         let local_name = ast_name.as_name();
         let local = if field.name_ref().is_some() {
     ) -> Option<ModuleDef> {
         let expr_or_pat_id = self.pat_id(&pat.clone().into())?;
         let store = self.store()?;
-
         let path = match expr_or_pat_id {
             ExprOrPatId::ExprId(idx) => match &store[idx] {
                 Expr::Path(path) => path,
                 _ => return None,
             },
         };
-
         let body_owner = self.resolver.body_owner();
         let res = resolve_hir_value_path(db, &self.resolver, body_owner, path, HygieneId::ROOT)?;
         match res {
         }
     }
 
-    pub(crate) fn resolve_use_type_arg(&self, name: &ast::NameRef) -> Option<crate::TypeParam> {
+    pub(crate) fn resolve_use_type_arg(
+        &self,
+        name: &ast::NameRef,
+    ) -> Option<crate::TypeParam> {
         let name = name.as_name();
         self.resolver
             .all_generic_params()
         let offset_of_expr = ast::OffsetOfExpr::cast(name_ref.syntax().parent()?)?;
         let container = offset_of_expr.ty()?;
         let container = self.type_of_type(db, &container)?;
-
         let trait_env = container.env;
-
         let interner = DbInterner::new_with(db, Some(trait_env.krate), trait_env.block);
         let infcx = interner.infer_ctxt().build(TypingMode::PostAnalysis);
-
         let mut container = Either::Right(container.ty);
         for field_name in offset_of_expr.fields() {
             if let Either::Right(container) = &mut container {
     ) -> Option<(PathResolution, Option<GenericSubstitution<'db>>)> {
         let parent = path.syntax().parent();
         let parent = || parent.clone();
-
         let mut prefer_value_ns = false;
         let resolved = (|| {
             let infer = self.infer()?;
         if resolved.is_some() {
             return resolved;
         }
-
         // FIXME: collectiong here shouldnt be necessary?
         let mut collector = ExprCollector::new(db, self.resolver.module(), self.file_id);
         let hir_path =
             .parent_path()
             .and_then(|p| collector.lower_path(p, &mut ExprCollector::impl_trait_error_allocator));
         let (store, _) = collector.store.finish();
-
         // Case where path is a qualifier of a use tree, e.g. foo::bar::{Baz, Qux} where we are
         // trying to resolve foo::bar.
         if let Some(use_tree) = parent().and_then(ast::UseTree::cast)
             return resolve_hir_path_qualifier(db, &self.resolver, &hir_path, &store)
                 .map(|it| (it, None));
         }
-
         let meta_path = path
             .syntax()
             .ancestors()
             })
             .last()
             .and_then(ast::Meta::cast);
-
         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we are
         // trying to resolve foo::bar.
         if let Some(parent_hir_path) = parent_hir_path {
     ) -> Option<Vec<(Field, Type<'db>)>> {
         let body = self.store()?;
         let infer = self.infer()?;
-
         let expr_id = self.expr_id(literal.clone().into())?;
         let substs = infer[expr_id].as_adt()?.1;
-
         let (variant, missing_fields, _exhaustive) = match expr_id {
             ExprOrPatId::ExprId(expr_id) => {
                 record_literal_missing_fields(db, infer, expr_id, &body[expr_id])?
     ) -> Option<Vec<(Field, Type<'db>)>> {
         let body = self.store()?;
         let infer = self.infer()?;
-
         let pat_id = self.pat_id(&pattern.clone().into())?.as_pat()?;
         let substs = infer[pat_id].as_adt()?.1;
-
         let (variant, missing_fields, _exhaustive) =
             record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;
         let res = self.missing_fields(db, substs, variant, missing_fields);
     ) -> Vec<(Field, Type<'db>)> {
         let interner = DbInterner::new_with(db, None, None);
         let field_types = db.field_types(variant);
-
         missing_fields
             .into_iter()
             .map(|local_id| {
             .collect()
     }
 
-    pub(crate) fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantId> {
+    pub(crate) fn resolve_variant(
+        &self,
+        record_lit: ast::RecordExpr,
+    ) -> Option<VariantId> {
         let infer = self.infer()?;
         let expr_id = self.expr_id(record_lit.into())?;
         infer.variant_resolution_for_expr_or_pat(expr_id)
         Some((trait_id, fn_id))
     }
 
-    fn ty_of_expr(&self, expr: ast::Expr) -> Option<Ty<'db>> {
+    fn ty_of_expr(
+        &self,
+        expr: ast::Expr,
+    ) -> Option<Ty<'db>> {
         self.infer()?.type_of_expr_or_pat(self.expr_id(expr)?)
     }
 }
         })
 }
 
-// XXX: during completion, cursor might be outside of any particular
-// expression. Try to figure out the correct scope...
 fn adjust(
     db: &dyn HirDatabase,
     scopes: &ExprScopes,
         .filter(|&(range, _)| {
             range.start() <= offset && expr_range.contains_range(range) && range != expr_range
         });
-
     child_scopes
         .max_by(|&(r1, _), &(r2, _)| {
             if r1.contains_range(r2) {
             None => Some(res),
         }
     };
-
     let body_owner = resolver.body_owner();
     let values = || resolve_hir_value_path(db, resolver, body_owner, path, hygiene);
-
     let items = || {
         resolver
             .resolve_module_path_in_items(db, path.mod_path()?)
             .take_types()
             .map(|it| PathResolution::Def(it.into()))
     };
-
     let macros = || {
         resolver
             .resolve_path_as_macro(db, path.mod_path()?, None)
             .map(|(def, _)| PathResolution::Def(ModuleDef::Macro(def.into())))
     };
-
     if resolve_per_ns {
         PathResolutionPerNs {
             type_ns: types().or_else(items),
     })
 }
 
-pub(crate) fn name_hygiene(db: &dyn HirDatabase, name: InFile<&SyntaxNode>) -> HygieneId {
+pub(crate) fn name_hygiene(
+    db: &dyn HirDatabase,
+    name: InFile<&SyntaxNode>,
+) -> HygieneId {
     let Some(macro_file) = name.file_id.macro_file() else {
         return HygieneId::ROOT;
     };