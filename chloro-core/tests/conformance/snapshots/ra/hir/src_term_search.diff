COMPARISON DIFF
============================================================

Original size: 11162 bytes
Chloro size:   11237 bytes
Rustfmt size:  11162 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Term search
 
+mod expr;
+mod tactics;
+
+pub use expr::Expr;
 use hir_def::type_ref::Mutability;
 use hir_ty::db::HirDatabase;
 use itertools::Itertools;
 
 use crate::{ModuleDef, ScopeDef, Semantics, SemanticsScope, Type};
 
-mod expr;
-pub use expr::Expr;
-
-mod tactics;
-
 /// Key for lookup table to query new types reached.
 #[derive(Debug, Hash, PartialEq, Eq)]
 enum NewTypesKey {
         if res.is_none() {
             self.types_wishlist.insert(ty.clone());
         }
-
         // Collapse suggestions if there are many
+
         if let Some(res) = &res
             && res.len() > self.many_threshold
         {
     ///
     /// For example if we have type `i32` in data and we query for `&i32` it map all the type
     /// trees we have for `i32` with `Expr::Reference` and returns them.
-    fn find_autoref(&mut self, db: &'db dyn HirDatabase, ty: &Type<'db>) -> Option<Vec<Expr<'db>>> {
+    fn find_autoref(
+        &mut self,
+        db: &'db dyn HirDatabase,
+        ty: &Type<'db>,
+    ) -> Option<Vec<Expr<'db>>> {
         let res = self
             .data
             .iter()
         if res.is_none() {
             self.types_wishlist.insert(ty.clone());
         }
-
         // Collapse suggestions if there are many
+
         if let Some(res) = &res
             && res.len() > self.many_threshold
         {
 
 impl Default for TermSearchConfig {
     fn default() -> Self {
-        Self { enable_borrowcheck: true, many_alternatives_threshold: 1, fuel: 1200 }
+        Self {
+            enable_borrowcheck: true,
+            many_alternatives_threshold: 1,
+            fuel: 1200,
+        }
     }
 }
 
         }
         remaining > 0
     };
-
     // Try trivial tactic first, also populates lookup table
+
     let mut solutions: Vec<Expr<'db>> = tactics::trivial(ctx, &defs, &mut lookup).collect();
     // Use well known types tactic before iterations as it does not depend on other tactics
     solutions.extend(tactics::famous_types(ctx, &defs, &mut lookup));