COMPARISON DIFF
============================================================

Original size: 32133 bytes
Chloro size:   32009 bytes
Rustfmt size:  33070 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use either::Either;
 use hir_def::{
-    dyn_map::{
-        keys::{self, Key},
-        DynMap,
-    },
+    dyn_map::{keys::{self, Key}, DynMap},
     hir::{BindingId, Expr, LabelId},
     nameres::{block_def_map, crate_def_map},
     AdtId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId,
         }
         self.included_file_cache.insert(file, None);
         for &crate_id in db.relevant_crates(file.file_id(db)).iter() {
-            db.include_macro_invoc(crate_id)
-                .iter()
-                .for_each(|&(macro_call_id, file_id)| {
-                    self.included_file_cache
-                        .insert(file_id, Some(macro_call_id));
-                });
+            db.include_macro_invoc(crate_id).iter().for_each(|&(macro_call_id, file_id)| {
+                self.included_file_cache.insert(file_id, Some(macro_call_id));
+            });
         }
         self.included_file_cache.get(&file).copied().flatten()
     }
         db: &dyn HirDatabase,
         macro_file: MacroCallId,
     ) -> &ExpansionInfo {
-        self.expansion_info_cache
-            .entry(macro_file)
-            .or_insert_with(|| {
-                let exp_info = macro_file.expansion_info(db);
+        self.expansion_info_cache.entry(macro_file).or_insert_with(|| {
+            let exp_info = macro_file.expansion_info(db);
 
-                let InMacroFile { file_id, value } = exp_info.expanded();
-                Self::cache(&mut self.root_to_file_cache, value, file_id.into());
+            let InMacroFile { file_id, value } = exp_info.expanded();
+            Self::cache(&mut self.root_to_file_cache, value, file_id.into());
 
-                exp_info
-            })
+            exp_info
+        })
     }
 }
 
                             .iter()
                             .filter(|&&(_, file_id)| file_id.file_id(self.db) == file)
                             .flat_map(|&(macro_call_id, file_id)| {
-                                self.cache
-                                    .included_file_cache
-                                    .insert(file_id, Some(macro_call_id));
+                                self.cache.included_file_cache.insert(file_id, Some(macro_call_id));
                                 modules(
                                     macro_call_id
                                         .lookup(self.db)
         let _p = tracing::info_span!("module_to_def").entered();
         let parent_declaration = self
             .parent_ancestors_with_macros(src.syntax_ref(), |_, ancestor, _| {
-                ancestor
-                    .map(Either::<ast::Module, ast::BlockExpr>::cast)
-                    .transpose()
+                ancestor.map(Either::<ast::Module, ast::BlockExpr>::cast).transpose()
             })
             .map(|it| it.transpose());
 
         Some(def_map.module_id(child_id))
     }
 
-    pub(super) fn source_file_to_def(&mut self, src: InFile<&ast::SourceFile>) -> Option<ModuleId> {
+    pub(super) fn source_file_to_def(
+        &mut self,
+        src: InFile<&ast::SourceFile>,
+    ) -> Option<ModuleId> {
         let _p = tracing::info_span!("source_file_to_def").entered();
         let file_id = src.file_id.original_file(self.db);
         self.file_to_def(file_id.file_id(self.db)).first().copied()
     pub(super) fn trait_to_def(&mut self, src: InFile<&ast::Trait>) -> Option<TraitId> {
         self.to_def(src, keys::TRAIT)
     }
+
     pub(super) fn impl_to_def(&mut self, src: InFile<&ast::Impl>) -> Option<ImplId> {
         self.to_def(src, keys::IMPL)
     }
+
     pub(super) fn fn_to_def(&mut self, src: InFile<&ast::Fn>) -> Option<FunctionId> {
         self.to_def(src, keys::FUNCTION)
     }
+
     pub(super) fn struct_to_def(&mut self, src: InFile<&ast::Struct>) -> Option<StructId> {
         self.to_def(src, keys::STRUCT)
     }
+
     pub(super) fn enum_to_def(&mut self, src: InFile<&ast::Enum>) -> Option<EnumId> {
         self.to_def(src, keys::ENUM)
     }
+
     pub(super) fn union_to_def(&mut self, src: InFile<&ast::Union>) -> Option<UnionId> {
         self.to_def(src, keys::UNION)
     }
+
     pub(super) fn static_to_def(&mut self, src: InFile<&ast::Static>) -> Option<StaticId> {
         self.to_def(src, keys::STATIC)
     }
+
     pub(super) fn const_to_def(&mut self, src: InFile<&ast::Const>) -> Option<ConstId> {
         self.to_def(src, keys::CONST)
     }
+
     pub(super) fn type_alias_to_def(
         &mut self,
         src: InFile<&ast::TypeAlias>,
     ) -> Option<TypeAliasId> {
         self.to_def(src, keys::TYPE_ALIAS)
     }
+
     pub(super) fn record_field_to_def(
         &mut self,
         src: InFile<&ast::RecordField>,
     ) -> Option<FieldId> {
         self.to_def(src, keys::RECORD_FIELD)
     }
+
     pub(super) fn tuple_field_to_def(&mut self, src: InFile<&ast::TupleField>) -> Option<FieldId> {
         self.to_def(src, keys::TUPLE_FIELD)
     }
+
     pub(super) fn block_to_def(&mut self, src: InFile<&ast::BlockExpr>) -> Option<BlockId> {
         self.to_def(src, keys::BLOCK)
     }
+
     pub(super) fn enum_variant_to_def(
         &mut self,
         src: InFile<&ast::Variant>,
     ) -> Option<EnumVariantId> {
         self.to_def(src, keys::ENUM_VARIANT)
     }
+
     pub(super) fn extern_crate_to_def(
         &mut self,
         src: InFile<&ast::ExternCrate>,
     ) -> Option<ExternCrateId> {
         self.to_def(src, keys::EXTERN_CRATE)
     }
+
     pub(super) fn extern_block_to_def(
         &mut self,
         src: InFile<&ast::ExternBlock>,
     ) -> Option<ExternBlockId> {
         self.to_def(src, keys::EXTERN_BLOCK)
     }
+
     #[allow(dead_code)]
     pub(super) fn use_to_def(&mut self, src: InFile<&ast::Use>) -> Option<UseId> {
         self.to_def(src, keys::USE)
     }
+
     pub(super) fn adt_to_def(
         &mut self,
         InFile { file_id, value }: InFile<&ast::Adt>,
     ) -> Option<AdtId> {
         match value {
-            ast::Adt::Enum(it) => self
-                .enum_to_def(InFile::new(file_id, it))
-                .map(AdtId::EnumId),
-            ast::Adt::Struct(it) => self
-                .struct_to_def(InFile::new(file_id, it))
-                .map(AdtId::StructId),
-            ast::Adt::Union(it) => self
-                .union_to_def(InFile::new(file_id, it))
-                .map(AdtId::UnionId),
+            ast::Adt::Enum(it) => self.enum_to_def(InFile::new(file_id, it)).map(AdtId::EnumId),
+            ast::Adt::Struct(it) => {
+                self.struct_to_def(InFile::new(file_id, it)).map(AdtId::StructId)
+            }
+            ast::Adt::Union(it) => self.union_to_def(InFile::new(file_id, it)).map(AdtId::UnionId),
         }
     }
 
             .position(|it| it == *src.value)?;
         let container = self.find_pat_or_label_container(src.syntax_ref())?;
         let source_map = self.db.body_with_source_map(container).1;
-        let expr = source_map
-            .node_expr(src.with_value(&ast::Expr::AsmExpr(asm)))?
-            .as_expr()?;
-        Some(InlineAsmOperand {
-            owner: container,
-            expr,
-            index,
-        })
+        let expr = source_map.node_expr(src.with_value(&ast::Expr::AsmExpr(asm)))?.as_expr()?;
+        Some(InlineAsmOperand { owner: container, expr, index })
     }
 
     pub(super) fn bind_pat_to_def(
             None
         }
     }
+
     pub(super) fn self_param_to_def(
         &mut self,
         src: InFile<&ast::SelfParam>,
         let body = self.db.body(container);
         Some((container, body.self_param?))
     }
+
     pub(super) fn label_to_def(
         &mut self,
         src: InFile<&ast::Label>,
         let break_or_continue = ast::Expr::cast(src.value.syntax().parent()?)?;
         let container = self.find_pat_or_label_container(src.syntax_ref())?;
         let (body, source_map) = self.db.body_with_source_map(container);
-        let break_or_continue = source_map
-            .node_expr(src.with_value(&break_or_continue))?
-            .as_expr()?;
+        let break_or_continue = source_map.node_expr(src.with_value(&break_or_continue))?.as_expr()?;
         let (Expr::Break { label, .. } | Expr::Continue { label }) = body[break_or_continue] else {
             return None;
         };
             .map(|&(attr_id, call_id, ref ids)| (attr_id, call_id, &**ids))
     }
 
-    // FIXME: Make this more fine grained! This should be a `adt_has_derives`!
     pub(super) fn file_of_adt_has_derives(&mut self, adt: InFile<&ast::Adt>) -> bool {
-        self.dyn_map(adt)
-            .as_ref()
-            .is_some_and(|map| !map[keys::DERIVE_MACRO_CALL].is_empty())
+        self.dyn_map(adt).as_ref().is_some_and(|map| !map[keys::DERIVE_MACRO_CALL].is_empty())
     }
 
     pub(super) fn derive_macro_calls<'slf>(
         &'slf mut self,
         adt: InFile<&ast::Adt>,
-    ) -> Option<impl Iterator<Item = (AttrId, MacroCallId, &'slf [Option<MacroCallId>])> + use<'slf>>
-    {
+    ) -> Option<impl Iterator<Item = (AttrId, MacroCallId, &'slf [Option<MacroCallId>])> + use<'slf>> {
         self.dyn_map(adt).as_ref().map(|&map| {
             let dyn_map = &map[keys::DERIVE_MACRO_CALL];
             adt.value
         src: InFile<&Ast>,
         key: Key<Ast, ID>,
     ) -> Option<ID> {
-        self.dyn_map(src)?[key]
-            .get(&AstPtr::new(src.value))
-            .copied()
+        self.dyn_map(src)?[key].get(&AstPtr::new(src.value)).copied()
     }
 
     fn dyn_map<Ast: AstNode + 'static>(&mut self, src: InFile<&Ast>) -> Option<&DynMap> {
     ) -> Option<LifetimeParamId> {
         let container: ChildContainer = self.find_generic_param_container(src.syntax_ref())?.into();
         let dyn_map = self.cache_for(container, src.file_id);
-        dyn_map[keys::LIFETIME_PARAM]
-            .get(&AstPtr::new(src.value))
-            .copied()
+        dyn_map[keys::LIFETIME_PARAM].get(&AstPtr::new(src.value)).copied()
     }
 
     pub(super) fn const_param_to_def(
         InFile { file_id, value }: InFile<&ast::GenericParam>,
     ) -> Option<GenericParamId> {
         match value {
-            ast::GenericParam::ConstParam(it) => self
-                .const_param_to_def(InFile::new(file_id, it))
-                .map(GenericParamId::ConstParamId),
+            ast::GenericParam::ConstParam(it) => {
+                self.const_param_to_def(InFile::new(file_id, it)).map(GenericParamId::ConstParamId)
+            }
             ast::GenericParam::LifetimeParam(it) => self
                 .lifetime_param_to_def(InFile::new(file_id, it))
                 .map(GenericParamId::LifetimeParamId),
-            ast::GenericParam::TypeParam(it) => self
-                .type_param_to_def(InFile::new(file_id, it))
-                .map(GenericParamId::TypeParamId),
+            ast::GenericParam::TypeParam(it) => {
+                self.type_param_to_def(InFile::new(file_id, it)).map(GenericParamId::TypeParamId)
+            }
         }
     }
 
     pub(super) fn macro_to_def(&mut self, src: InFile<&ast::Macro>) -> Option<MacroId> {
         self.dyn_map(src).and_then(|it| match src.value {
-            ast::Macro::MacroRules(value) => it[keys::MACRO_RULES]
-                .get(&AstPtr::new(value))
-                .copied()
-                .map(MacroId::from),
-            ast::Macro::MacroDef(value) => it[keys::MACRO2]
-                .get(&AstPtr::new(value))
-                .copied()
-                .map(MacroId::from),
+            ast::Macro::MacroRules(value) => {
+                it[keys::MACRO_RULES].get(&AstPtr::new(value)).copied().map(MacroId::from)
+            }
+            ast::Macro::MacroDef(value) => {
+                it[keys::MACRO2].get(&AstPtr::new(value)).copied().map(MacroId::from)
+            }
         })
     }
 
     pub(super) fn proc_macro_to_def(&mut self, src: InFile<&ast::Fn>) -> Option<MacroId> {
         self.dyn_map(src).and_then(|it| {
-            it[keys::PROC_MACRO]
-                .get(&AstPtr::new(src.value))
-                .copied()
-                .map(MacroId::from)
+            it[keys::PROC_MACRO].get(&AstPtr::new(src.value)).copied().map(MacroId::from)
         })
     }
 
     pub(super) fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {
         let _p = tracing::info_span!("find_container").entered();
-        let def = self.parent_ancestors_with_macros(src, |this, container, child| {
+        let def = self
+            .parent_ancestors_with_macros(src, |this, container, child| {
             this.container_to_def(container, child)
         });
         if let Some(def) = def {
                 }
                 ast::Item::Enum(it) => this.enum_to_def(InFile::new(file_id, it)).map(Into::into),
                 ast::Item::Trait(it) => this.trait_to_def(InFile::new(file_id, it)).map(Into::into),
-                ast::Item::TypeAlias(it) => this
-                    .type_alias_to_def(InFile::new(file_id, it))
-                    .map(Into::into),
+                ast::Item::TypeAlias(it) => {
+                    this.type_alias_to_def(InFile::new(file_id, it)).map(Into::into)
+                }
                 ast::Item::Impl(it) => this.impl_to_def(InFile::new(file_id, it)).map(Into::into),
                 _ => None,
             }
         })
     }
 
-    // FIXME: Remove this when we do inference in signatures
     fn find_pat_or_label_container(&mut self, src: InFile<&SyntaxNode>) -> Option<DefWithBodyId> {
         self.parent_ancestors_with_macros(src, |this, InFile { file_id, value }, _| {
             let item = match ast::Item::cast(value.clone()) {
                 ast::Item::Struct(it) => {
                     let def = self.struct_to_def(container.with_value(it))?;
                     let is_in_body = it.field_list().is_some_and(|it| {
-                        it.syntax()
-                            .text_range()
-                            .contains(child.text_range().start())
+                        it.syntax().text_range().contains(child.text_range().start())
                     });
                     if is_in_body {
                         VariantId::from(def).into()
                 ast::Item::Union(it) => {
                     let def = self.union_to_def(container.with_value(it))?;
                     let is_in_body = it.record_field_list().is_some_and(|it| {
-                        it.syntax()
-                            .text_range()
-                            .contains(child.text_range().start())
+                        it.syntax().text_range().contains(child.text_range().start())
                     });
                     if is_in_body {
                         VariantId::from(def).into()
                 ast::Item::Fn(it) => {
                     let def = self.fn_to_def(container.with_value(it))?;
                     let child_offset = child.text_range().start();
-                    let is_in_body = it
-                        .body()
-                        .is_some_and(|it| it.syntax().text_range().contains(child_offset));
+                    let is_in_body =
+                        it.body().is_some_and(|it| it.syntax().text_range().contains(child_offset));
                     let in_param_pat = || {
                         it.param_list().is_some_and(|it| {
                             it.self_param()
                 ast::Item::Static(it) => {
                     let def = self.static_to_def(container.with_value(it))?;
                     let is_in_body = it.body().is_some_and(|it| {
-                        it.syntax()
-                            .text_range()
-                            .contains(child.text_range().start())
+                        it.syntax().text_range().contains(child.text_range().start())
                     });
                     if is_in_body {
                         DefWithBodyId::from(def).into()
                 ast::Item::Const(it) => {
                     let def = self.const_to_def(container.with_value(it))?;
                     let is_in_body = it.body().is_some_and(|it| {
-                        it.syntax()
-                            .text_range()
-                            .contains(child.text_range().start())
+                        it.syntax().text_range().contains(child.text_range().start())
                     });
                     if is_in_body {
                         DefWithBodyId::from(def).into()
             }
         } else if let Some(it) = ast::Variant::cast(container.value.clone()) {
             let def = self.enum_variant_to_def(InFile::new(container.file_id, &it))?;
-            let is_in_body = it
-                .eq_token()
-                .is_some_and(|it| it.text_range().end() < child.text_range().start());
-            if is_in_body {
-                DefWithBodyId::from(def).into()
-            } else {
-                VariantId::from(def).into()
-            }
+            let is_in_body =
+                it.eq_token().is_some_and(|it| it.text_range().end() < child.text_range().start());
+            if is_in_body { DefWithBodyId::from(def).into() } else { VariantId::from(def).into() }
         } else {
             let it = match Either::<ast::Pat, ast::Name>::cast(container.value)? {
                 Either::Left(it) => ast::Param::cast(it.syntax().parent()?)?.syntax().parent(),
-                Either::Right(it) => ast::SelfParam::cast(it.syntax().parent()?)?
-                    .syntax()
-                    .parent(),
+                Either::Right(it) => ast::SelfParam::cast(it.syntax().parent()?)?.syntax().parent(),
             }
             .and_then(ast::ParamList::cast)?
             .syntax()
     /// here the children are generic parameters, and not, eg enum variants.
     GenericDefId(GenericDefId),
 }
+
 impl_from! {
     DefWithBodyId,
     ModuleId,