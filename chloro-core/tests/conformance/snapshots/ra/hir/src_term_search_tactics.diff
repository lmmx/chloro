COMPARISON DIFF
============================================================

Original size: 30934 bytes
Chloro size:   27777 bytes
Rustfmt size:  32147 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     term_search::Expr, Adt, AssocItem, GenericDef, GenericParam, HasAttrs, HasVisibility, Impl,
     ModuleDef, ScopeDef, Type, TypeParam,
 };
-
 use super::{LookupTable, NewTypesKey, TermSearchCtx};
 
 /// # Trivial tactic
             }
             _ => None,
         }?;
-
         let ty = expr.ty(db);
         lookup.insert(ty.clone(), std::iter::once(expr.clone()));
-
-        // Don't suggest local references as they are not valid for return
         if matches!(expr, Expr::Local(_))
             && ty.contains_reference(db)
             && ctx.config.enable_borrowcheck
         {
             return None;
         }
-
         ty.could_unify_with_deeply(db, &ctx.goal).then_some(expr)
     })
 }
     let db = ctx.sema.db;
     let module = ctx.scope.module();
 
-    defs.iter()
-        .filter_map(|def| match def {
-            ScopeDef::ModuleDef(ModuleDef::Adt(it)) => Some(it),
-            _ => None,
-        })
-        .flat_map(|it| Impl::all_for_type(db, it.ty(db)))
-        .filter(|it| !it.is_unsafe(db))
-        .flat_map(|it| it.items(db))
-        .filter(move |it| it.is_visible_from(db, module))
-        .filter_map(AssocItem::as_const)
-        .filter_map(|it| {
-            if it.attrs(db).is_unstable() {
+    defs.iter().filter_map(|def| match def {
+        ScopeDef::ModuleDef(ModuleDef::Adt(it)) => Some(it),
+        _ => None,
+    }).flat_map(
+        |it| Impl::all_for_type(db, it.ty(db)),
+    ).filter(
+        |it| !it.is_unsafe(db),
+    ).flat_map(
+        |it| it.items(db),
+    ).filter(
+        move |it| it.is_visible_from(db, module),
+    ).filter_map(
+        AssocItem::as_const,
+    ).filter_map(|it| {
+        if it.attrs(db).is_unstable() {
                 return None;
             }
-
-            let expr = Expr::Const(it);
-            let ty = it.ty(db);
-
-            if ty.contains_unknown() {
+        let expr = Expr::Const(it);
+        let ty = it.ty(db);
+        if ty.contains_unknown() {
                 return None;
             }
-
-            lookup.insert(ty.clone(), std::iter::once(expr.clone()));
-
-            ty.could_unify_with_deeply(db, &ctx.goal).then_some(expr)
-        })
+        lookup.insert(ty.clone(), std::iter::once(expr.clone()));
+        ty.could_unify_with_deeply(db, &ctx.goal).then_some(expr)
+    })
 }
 
 /// # Data constructor tactic
 ) -> impl Iterator<Item = Expr<'db>> + use<'a, 'db, 'lt, DB> {
     let db = ctx.sema.db;
     let module = ctx.scope.module();
-    lookup
-        .types_wishlist()
-        .clone()
-        .into_iter()
-        .chain(iter::once(ctx.goal.clone()))
-        .filter_map(|ty| ty.as_adt().map(|adt| (adt, ty)))
-        .filter(|_| should_continue())
-        .filter_map(move |(adt, ty)| match adt {
-            Adt::Struct(strukt) => {
-                // Ignore unstable or not visible
-                if strukt.is_unstable(db) || !strukt.is_visible_from(db, module) {
+    lookup.types_wishlist().clone().into_iter().chain(iter::once(ctx.goal.clone())).filter_map(
+        |ty| ty.as_adt().map(|adt| (adt, ty)),
+    ).filter(
+        |_| should_continue(),
+    ).filter_map(move |(adt, ty)| match adt {
+        Adt::Struct(strukt) => {
+            if strukt.is_unstable(db) || !strukt.is_visible_from(db, module) {
                     return None;
                 }
-
-                let generics = GenericDef::from(strukt);
-
-                // We currently do not check lifetime bounds so ignore all types that have something to do
-                // with them
-                if !generics.lifetime_params(db).is_empty() {
+            let generics = GenericDef::from(strukt);
+            if !generics.lifetime_params(db).is_empty() {
                     return None;
                 }
-
-                if ty.contains_unknown() {
+            if ty.contains_unknown() {
                     return None;
                 }
-
-                // Ignore types that have something to do with lifetimes
-                if ctx.config.enable_borrowcheck && ty.contains_reference(db) {
+            if ctx.config.enable_borrowcheck && ty.contains_reference(db) {
                     return None;
                 }
-                let fields = strukt.fields(db);
-                // Check if all fields are visible, otherwise we cannot fill them
-                if fields.iter().any(|it| !it.is_visible_from(db, module)) {
+            let fields = strukt.fields(db);
+            if fields.iter().any(|it| !it.is_visible_from(db, module)) {
                     return None;
                 }
-
-                let generics: Vec<_> = ty.type_arguments().collect();
-
-                // Early exit if some param cannot be filled from lookup
-                let param_exprs: Vec<Vec<Expr<'_>>> = fields
+            let generics: Vec<_> = ty.type_arguments().collect();
+            let param_exprs: Vec<Vec<Expr<'_>>> = fields
                     .into_iter()
                     .map(|field| lookup.find(db, &field.ty_with_args(db, generics.iter().cloned())))
                     .collect::<Option<_>>()?;
-
-                // Note that we need special case for 0 param constructors because of multi cartesian
-                // product
-                let exprs: Vec<Expr<'_>> = if param_exprs.is_empty() {
-                    vec![Expr::Struct {
-                        strukt,
-                        generics,
-                        params: Vec::new(),
-                    }]
+            let exprs: Vec<Expr<'_>> = if param_exprs.is_empty() {
+                    vec![Expr::Struct { strukt, generics, params: Vec::new() }]
                 } else {
                     param_exprs
                         .into_iter()
                         .multi_cartesian_product()
-                        .map(|params| Expr::Struct {
-                            strukt,
-                            generics: generics.clone(),
-                            params,
-                        })
+                        .map(|params| Expr::Struct { strukt, generics: generics.clone(), params })
                         .collect()
                 };
-
-                lookup.insert(ty.clone(), exprs.iter().cloned());
-                Some((ty, exprs))
-            }
-            Adt::Enum(enum_) => {
-                // Ignore unstable or not visible
-                if enum_.is_unstable(db) || !enum_.is_visible_from(db, module) {
+            lookup.insert(ty.clone(), exprs.iter().cloned());
+            Some((ty, exprs))
+        },
+        Adt::Enum(enum_) => {
+            if enum_.is_unstable(db) || !enum_.is_visible_from(db, module) {
                     return None;
                 }
-
-                let generics = GenericDef::from(enum_);
-                // We currently do not check lifetime bounds so ignore all types that have something to do
-                // with them
-                if !generics.lifetime_params(db).is_empty() {
+            let generics = GenericDef::from(enum_);
+            if !generics.lifetime_params(db).is_empty() {
                     return None;
                 }
-
-                if ty.contains_unknown() {
+            if ty.contains_unknown() {
                     return None;
                 }
-
-                // Ignore types that have something to do with lifetimes
-                if ctx.config.enable_borrowcheck && ty.contains_reference(db) {
+            if ctx.config.enable_borrowcheck && ty.contains_reference(db) {
                     return None;
                 }
-
-                let generics: Vec<_> = ty.type_arguments().collect();
-                let exprs = enum_
+            let generics: Vec<_> = ty.type_arguments().collect();
+            let exprs = enum_
                     .variants(db)
                     .into_iter()
                     .filter_map(|variant| {
                     })
                     .flatten()
                     .collect();
-
-                Some((ty, exprs))
-            }
-            Adt::Union(_) => None,
-        })
-        .filter_map(|(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs))
-        .flatten()
+            Some((ty, exprs))
+        },
+        Adt::Union(_) => None,
+    }).filter_map(
+        |(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs),
+    ).flatten(
+    )
 }
 
 /// # Free function tactic
 ) -> impl Iterator<Item = Expr<'db>> + use<'a, 'db, 'lt, DB> {
     let db = ctx.sema.db;
     let module = ctx.scope.module();
-    defs.iter()
-        .filter_map(move |def| match def {
-            ScopeDef::ModuleDef(ModuleDef::Function(it)) => {
-                let generics = GenericDef::from(*it);
-
-                // Ignore const params for now
-                let type_params = generics
+    defs.iter().filter_map(move |def| match def {
+        ScopeDef::ModuleDef(ModuleDef::Function(it)) => {
+            let generics = GenericDef::from(*it);
+            let type_params = generics
                     .type_or_const_params(db)
                     .into_iter()
                     .map(|it| it.as_type_param(db))
                     .collect::<Option<Vec<TypeParam>>>()?;
-
-                // Ignore lifetimes as we do not check them
-                if !generics.lifetime_params(db).is_empty() {
+            if !generics.lifetime_params(db).is_empty() {
                     return None;
                 }
-
-                // Only account for stable type parameters for now, unstable params can be default
-                // tho, for example in `Box<T, #[unstable] A: Allocator>`
-                if type_params
-                    .iter()
-                    .any(|it| it.is_unstable(db) && it.default(db).is_none())
-                {
+            if type_params.iter().any(|it| it.is_unstable(db) && it.default(db).is_none()) {
                     return None;
                 }
-
-                let non_default_type_params_len = type_params
-                    .iter()
-                    .filter(|it| it.default(db).is_none())
-                    .count();
-
-                // Ignore bigger number of generics for now as they kill the performance
-                if non_default_type_params_len > 0 {
+            let non_default_type_params_len =
+                    type_params.iter().filter(|it| it.default(db).is_none()).count();
+            if non_default_type_params_len > 0 {
                     return None;
                 }
-
-                let generic_params = lookup
+            let generic_params = lookup
                     .iter_types()
                     .collect::<Vec<_>>() // Force take ownership
                     .into_iter()
                     .permutations(non_default_type_params_len);
-
-                let exprs: Vec<_> = generic_params
+            let exprs: Vec<_> = generic_params
                     .filter(|_| should_continue())
                     .filter_map(|generics| {
                         // Insert default type params
                         // Note that we need special case for 0 param constructors because of multi cartesian
                         // product
                         let fn_exprs: Vec<Expr<'_>> = if param_exprs.is_empty() {
-                            vec![Expr::Function {
-                                func: *it,
-                                generics,
-                                params: Vec::new(),
-                            }]
+                            vec![Expr::Function { func: *it, generics, params: Vec::new() }]
                         } else {
                             param_exprs
                                 .into_iter()
                         Some((ret_ty, fn_exprs))
                     })
                     .collect();
-                Some(exprs)
-            }
-            _ => None,
-        })
-        .flatten()
-        .filter_map(|(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs))
-        .flatten()
+            Some(exprs)
+        },
+        _ => None,
+    }).flatten(
+    ).filter_map(
+        |(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs),
+    ).flatten(
+    )
 }
 
 /// # Impl method tactic
 ) -> impl Iterator<Item = Expr<'db>> + use<'a, 'db, 'lt, DB> {
     let db = ctx.sema.db;
     let module = ctx.scope.module();
-    lookup
-        .new_types(NewTypesKey::ImplMethod)
-        .into_iter()
-        .filter(|ty| !ty.type_arguments().any(|it| it.contains_unknown()))
-        .filter(|_| should_continue())
-        .flat_map(|ty| {
-            Impl::all_for_type(db, ty.clone())
-                .into_iter()
-                .map(move |imp| (ty.clone(), imp))
-        })
-        .flat_map(|(ty, imp)| {
-            imp.items(db)
-                .into_iter()
-                .map(move |item| (imp, ty.clone(), item))
-        })
-        .filter_map(|(imp, ty, it)| match it {
-            AssocItem::Function(f) => Some((imp, ty, f)),
-            _ => None,
-        })
-        .filter(|_| should_continue())
-        .filter_map(move |(imp, ty, it)| {
-            let fn_generics = GenericDef::from(it);
-            let imp_generics = GenericDef::from(imp);
-
-            // Ignore all functions that have something to do with lifetimes as we don't check them
-            if !fn_generics.lifetime_params(db).is_empty()
+    lookup.new_types(NewTypesKey::ImplMethod).into_iter().filter(
+        |ty| !ty.type_arguments().any(|it| it.contains_unknown()),
+    ).filter(
+        |_| should_continue(),
+    ).flat_map(|ty| {
+        Impl::all_for_type(db, ty.clone()).into_iter().map(move |imp| (ty.clone(), imp))
+    }).flat_map(
+        |(ty, imp)| imp.items(db).into_iter().map(move |item| (imp, ty.clone(), item)),
+    ).filter_map(|(imp, ty, it)| match it {
+        AssocItem::Function(f) => Some((imp, ty, f)),
+        _ => None,
+    }).filter(
+        |_| should_continue(),
+    ).filter_map(move |(imp, ty, it)| {
+        let fn_generics = GenericDef::from(it);
+        let imp_generics = GenericDef::from(imp);
+        if !fn_generics.lifetime_params(db).is_empty()
                 || !imp_generics.lifetime_params(db).is_empty()
             {
                 return None;
             }
-
-            // Ignore functions without self param
-            if !it.has_self_param(db) {
+        if !it.has_self_param(db) {
                 return None;
             }
-
-            // Filter out private and unsafe functions
-            if !it.is_visible_from(db, module)
+        if !it.is_visible_from(db, module)
                 || it.is_unsafe_to_call(db, None, Edition::CURRENT_FIXME)
                 || it.is_unstable(db)
             {
                 return None;
             }
-
-            // Ignore functions with generics for now as they kill the performance
-            // Also checking bounds for generics is problematic
-            if !fn_generics.type_or_const_params(db).is_empty() {
+        if !fn_generics.type_or_const_params(db).is_empty() {
                 return None;
             }
-
-            let ret_ty = it.ret_type_with_args(db, ty.type_arguments());
-            // Filter out functions that return references
-            if ctx.config.enable_borrowcheck && ret_ty.contains_reference(db) || ret_ty.is_raw_ptr()
+        let ret_ty = it.ret_type_with_args(db, ty.type_arguments());
+        if ctx.config.enable_borrowcheck && ret_ty.contains_reference(db) || ret_ty.is_raw_ptr()
             {
                 return None;
             }
-
-            // Ignore functions that do not change the type
-            if ty.could_unify_with_deeply(db, &ret_ty) {
+        if ty.could_unify_with_deeply(db, &ret_ty) {
                 return None;
             }
-
-            let self_ty = it
-                .self_param(db)
-                .expect("No self param")
-                .ty_with_args(db, ty.type_arguments());
-
-            // Ignore functions that have different self type
-            if !self_ty.autoderef(db).any(|s_ty| ty == s_ty) {
+        let self_ty =
+                it.self_param(db).expect("No self param").ty_with_args(db, ty.type_arguments());
+        if !self_ty.autoderef(db).any(|s_ty| ty == s_ty) {
                 return None;
             }
-
-            let target_type_exprs = lookup.find(db, &ty).expect("Type not in lookup");
-
-            // Early exit if some param cannot be filled from lookup
-            let param_exprs: Vec<Vec<Expr<'_>>> = it
+        let target_type_exprs = lookup.find(db, &ty).expect("Type not in lookup");
+        let param_exprs: Vec<Vec<Expr<'_>>> = it
                 .params_without_self_with_args(db, ty.type_arguments())
                 .into_iter()
                 .map(|field| lookup.find_autoref(db, field.ty()))
                 .collect::<Option<_>>()?;
-
-            let generics: Vec<_> = ty.type_arguments().collect();
-            let fn_exprs: Vec<Expr<'_>> = std::iter::once(target_type_exprs)
+        let generics: Vec<_> = ty.type_arguments().collect();
+        let fn_exprs: Vec<Expr<'_>> = std::iter::once(target_type_exprs)
                 .chain(param_exprs)
                 .multi_cartesian_product()
                 .map(|params| {
                     }
                 })
                 .collect();
-
-            Some((ret_ty, fn_exprs))
-        })
-        .filter_map(|(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs))
-        .flatten()
+        Some((ret_ty, fn_exprs))
+    }).filter_map(
+        |(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs),
+    ).flatten(
+    )
 }
 
 /// # Struct projection tactic
 ) -> impl Iterator<Item = Expr<'db>> + use<'a, 'db, 'lt, DB> {
     let db = ctx.sema.db;
     let module = ctx.scope.module();
-    lookup
-        .new_types(NewTypesKey::StructProjection)
-        .into_iter()
-        .map(|ty| {
-            (
-                ty.clone(),
-                lookup.find(db, &ty).expect("Expr not in lookup"),
-            )
+    lookup.new_types(NewTypesKey::StructProjection).into_iter().map(
+        |ty| (ty.clone(), lookup.find(db, &ty).expect("Expr not in lookup")),
+    ).filter(
+        |_| should_continue(),
+    ).flat_map(move |(ty, targets)| {
+        ty.fields(db).into_iter().filter_map(move |(field, filed_ty)| {
+            if !field.is_visible_from(db, module) {
+                    return None;
+                }
+            let exprs = targets
+                    .clone()
+                    .into_iter()
+                    .map(move |target| Expr::Field { field, expr: Box::new(target) });
+            Some((filed_ty, exprs))
         })
-        .filter(|_| should_continue())
-        .flat_map(move |(ty, targets)| {
-            ty.fields(db)
-                .into_iter()
-                .filter_map(move |(field, filed_ty)| {
-                    if !field.is_visible_from(db, module) {
-                        return None;
-                    }
-                    let exprs = targets.clone().into_iter().map(move |target| Expr::Field {
-                        field,
-                        expr: Box::new(target),
-                    });
-                    Some((filed_ty, exprs))
-                })
-        })
-        .filter_map(|(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs))
-        .flatten()
+    }).filter_map(
+        |(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs),
+    ).flatten(
+    )
 }
 
 /// # Famous types tactic
     let unit_ty = Ty::new_unit(interner);
     [
         Expr::FamousType {
-            ty: Type::new(db, module.id, bool_ty),
-            value: "true",
-        },
+        ty: Type::new(db, module.id, bool_ty),
+        value: "true",
+    },
         Expr::FamousType {
-            ty: Type::new(db, module.id, bool_ty),
-            value: "false",
-        },
+        ty: Type::new(db, module.id, bool_ty),
+        value: "false",
+    },
         Expr::FamousType {
-            ty: Type::new(db, module.id, unit_ty),
-            value: "()",
-        },
-    ]
-    .into_iter()
-    .inspect(|exprs| {
+        ty: Type::new(db, module.id, unit_ty),
+        value: "()",
+    },
+    ].into_iter(
+    ).inspect(|exprs| {
         lookup.insert(exprs.ty(db), std::iter::once(exprs.clone()));
-    })
-    .filter(|expr| expr.ty(db).could_unify_with_deeply(db, &ctx.goal))
+    }).filter(
+        |expr| expr.ty(db).could_unify_with_deeply(db, &ctx.goal),
+    )
 }
 
 /// # Impl static method (without self type) tactic
 ) -> impl Iterator<Item = Expr<'db>> + use<'a, 'db, 'lt, DB> {
     let db = ctx.sema.db;
     let module = ctx.scope.module();
-    lookup
-        .types_wishlist()
-        .clone()
-        .into_iter()
-        .chain(iter::once(ctx.goal.clone()))
-        .filter(|ty| !ty.type_arguments().any(|it| it.contains_unknown()))
-        .filter(|_| should_continue())
-        .flat_map(|ty| {
-            Impl::all_for_type(db, ty.clone())
-                .into_iter()
-                .map(move |imp| (ty.clone(), imp))
-        })
-        .filter(|(_, imp)| !imp.is_unsafe(db))
-        .flat_map(|(ty, imp)| {
-            imp.items(db)
-                .into_iter()
-                .map(move |item| (imp, ty.clone(), item))
-        })
-        .filter_map(|(imp, ty, it)| match it {
-            AssocItem::Function(f) => Some((imp, ty, f)),
-            _ => None,
-        })
-        .filter(|_| should_continue())
-        .filter_map(move |(imp, ty, it)| {
-            let fn_generics = GenericDef::from(it);
-            let imp_generics = GenericDef::from(imp);
-
-            // Ignore all functions that have something to do with lifetimes as we don't check them
-            if !fn_generics.lifetime_params(db).is_empty()
+    lookup.types_wishlist().clone().into_iter().chain(iter::once(ctx.goal.clone())).filter(
+        |ty| !ty.type_arguments().any(|it| it.contains_unknown()),
+    ).filter(
+        |_| should_continue(),
+    ).flat_map(|ty| {
+        Impl::all_for_type(db, ty.clone()).into_iter().map(move |imp| (ty.clone(), imp))
+    }).filter(
+        |(_, imp)| !imp.is_unsafe(db),
+    ).flat_map(
+        |(ty, imp)| imp.items(db).into_iter().map(move |item| (imp, ty.clone(), item)),
+    ).filter_map(|(imp, ty, it)| match it {
+        AssocItem::Function(f) => Some((imp, ty, f)),
+        _ => None,
+    }).filter(
+        |_| should_continue(),
+    ).filter_map(move |(imp, ty, it)| {
+        let fn_generics = GenericDef::from(it);
+        let imp_generics = GenericDef::from(imp);
+        if !fn_generics.lifetime_params(db).is_empty()
                 || !imp_generics.lifetime_params(db).is_empty()
             {
                 return None;
             }
-
-            // Ignore functions with self param
-            if it.has_self_param(db) {
+        if it.has_self_param(db) {
                 return None;
             }
-
-            // Filter out private and unsafe functions
-            if !it.is_visible_from(db, module)
+        if !it.is_visible_from(db, module)
                 || it.is_unsafe_to_call(db, None, Edition::CURRENT_FIXME)
                 || it.is_unstable(db)
             {
                 return None;
             }
-
-            // Ignore functions with generics for now as they kill the performance
-            // Also checking bounds for generics is problematic
-            if !fn_generics.type_or_const_params(db).is_empty() {
+        if !fn_generics.type_or_const_params(db).is_empty() {
                 return None;
             }
-
-            let ret_ty = it.ret_type_with_args(db, ty.type_arguments());
-            // Filter out functions that return references
-            if ctx.config.enable_borrowcheck && ret_ty.contains_reference(db) || ret_ty.is_raw_ptr()
+        let ret_ty = it.ret_type_with_args(db, ty.type_arguments());
+        if ctx.config.enable_borrowcheck && ret_ty.contains_reference(db) || ret_ty.is_raw_ptr()
             {
                 return None;
             }
-
-            // Early exit if some param cannot be filled from lookup
-            let param_exprs: Vec<Vec<Expr<'_>>> = it
+        let param_exprs: Vec<Vec<Expr<'_>>> = it
                 .params_without_self_with_args(db, ty.type_arguments())
                 .into_iter()
                 .map(|field| lookup.find_autoref(db, field.ty()))
                 .collect::<Option<_>>()?;
-
-            // Note that we need special case for 0 param constructors because of multi cartesian
-            // product
-            let generics = ty.type_arguments().collect();
-            let fn_exprs: Vec<Expr<'_>> = if param_exprs.is_empty() {
-                vec![Expr::Function {
-                    func: it,
-                    generics,
-                    params: Vec::new(),
-                }]
+        let generics = ty.type_arguments().collect();
+        let fn_exprs: Vec<Expr<'_>> = if param_exprs.is_empty() {
+                vec![Expr::Function { func: it, generics, params: Vec::new() }]
             } else {
                 param_exprs
                     .into_iter()
                     .multi_cartesian_product()
-                    .map(|params| Expr::Function {
-                        func: it,
-                        generics: generics.clone(),
-                        params,
-                    })
+                    .map(|params| Expr::Function { func: it, generics: generics.clone(), params })
                     .collect()
             };
-
-            lookup.insert(ret_ty.clone(), fn_exprs.iter().cloned());
-
-            Some((ret_ty, fn_exprs))
-        })
-        .filter_map(|(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs))
-        .flatten()
+        lookup.insert(ret_ty.clone(), fn_exprs.iter().cloned());
+        Some((ret_ty, fn_exprs))
+    }).filter_map(
+        |(ty, exprs)| ty.could_unify_with_deeply(db, &ctx.goal).then_some(exprs),
+    ).flatten(
+    )
 }
 
 /// # Make tuple tactic
     let db = ctx.sema.db;
     let module = ctx.scope.module();
 
-    lookup
-        .types_wishlist()
-        .clone()
-        .into_iter()
-        .filter(|_| should_continue())
-        .filter(|ty| ty.is_tuple())
-        .filter_map(move |ty| {
-            // Double check to not contain unknown
-            if ty.contains_unknown() {
+    lookup.types_wishlist().clone().into_iter().filter(|_| should_continue()).filter(
+        |ty| ty.is_tuple(),
+    ).filter_map(move |ty| {
+        if ty.contains_unknown() {
                 return None;
             }
-
-            // Ignore types that have something to do with lifetimes
-            if ctx.config.enable_borrowcheck && ty.contains_reference(db) {
+        if ctx.config.enable_borrowcheck && ty.contains_reference(db) {
                 return None;
             }
-
-            // Early exit if some param cannot be filled from lookup
-            let param_exprs: Vec<Vec<Expr<'db>>> = ty
-                .type_arguments()
-                .map(|field| lookup.find(db, &field))
-                .collect::<Option<_>>()?;
-
-            let exprs: Vec<Expr<'db>> = param_exprs
+        let param_exprs: Vec<Vec<Expr<'db>>> =
+                ty.type_arguments().map(|field| lookup.find(db, &field)).collect::<Option<_>>()?;
+        let exprs: Vec<Expr<'db>> = param_exprs
                 .into_iter()
                 .multi_cartesian_product()
                 .filter(|_| should_continue())
                     let tys: Vec<Type<'_>> = params.iter().map(|it| it.ty(db)).collect();
                     let tuple_ty = Type::new_tuple(module.krate().into(), &tys);
 
-                    let expr = Expr::Tuple {
-                        ty: tuple_ty.clone(),
-                        params,
-                    };
+                    let expr = Expr::Tuple { ty: tuple_ty.clone(), params };
                     lookup.insert(tuple_ty, iter::once(expr.clone()));
                     expr
                 })
                 .collect();
-
-            Some(exprs)
-        })
-        .flatten()
-        .filter_map(|expr| {
-            expr.ty(db)
-                .could_unify_with_deeply(db, &ctx.goal)
-                .then_some(expr)
-        })
+        Some(exprs)
+    }).flatten(
+    ).filter_map(
+        |expr| expr.ty(db).could_unify_with_deeply(db, &ctx.goal).then_some(expr),
+    )
 }