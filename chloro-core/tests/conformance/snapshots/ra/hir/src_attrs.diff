COMPARISON DIFF
============================================================

Original size: 11937 bytes
Chloro size:   11452 bytes
Rustfmt size:  12307 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 pub trait HasAttrs {
     fn attrs(self, db: &dyn HirDatabase) -> AttrsWithOwner;
+
     #[doc(hidden)]
     fn attr_id(self) -> AttrDefId;
 }
         }
     )*};
 }
-
-impl_has_attrs![
-    (Field, FieldId),
-    (Variant, EnumVariantId),
-    (Static, StaticId),
-    (Const, ConstId),
-    (Trait, TraitId),
-    (TypeAlias, TypeAliasId),
-    (Macro, MacroId),
-    (Function, FunctionId),
-    (Adt, AdtId),
-    (Module, ModuleId),
-    (GenericParam, GenericParamId),
-    (Impl, ImplId),
-    (ExternCrateDecl, ExternCrateId),
-];
-
 macro_rules! impl_has_attrs_enum {
     ($($variant:ident),* for $enum:ident) => {$(
         impl HasAttrs for $variant {
         }
     )*};
 }
-
-impl_has_attrs_enum![Struct, Union, Enum for Adt];
-impl_has_attrs_enum![TypeParam, ConstParam, LifetimeParam for GenericParam];
-
 impl HasAttrs for AssocItem {
     fn attrs(self, db: &dyn HirDatabase) -> AttrsWithOwner {
         match self {
             AssocItem::TypeAlias(it) => it.attrs(db),
         }
     }
+
     fn attr_id(self) -> AttrDefId {
         match self {
             AssocItem::Function(it) => it.attr_id(),
         let def = AttrDefId::ModuleId(self.root_module().id);
         AttrsWithOwner::new(db, def)
     }
+
     fn attr_id(self) -> AttrDefId {
         AttrDefId::ModuleId(self.root_module().id)
     }
     // trait itself.
     let base_def = resolver.resolve_path_in_type_ns_fully(db, &path)?;
 
-    let ty =
-        match base_def {
-            TypeNs::SelfType(id) => Impl::from(id).self_ty(db),
-            TypeNs::GenericParam(_) => {
-                // Even if this generic parameter has some trait bounds, rustdoc doesn't
-                // resolve `name` to trait items.
+    let ty = match base_def {
+        TypeNs::SelfType(id) => Impl::from(id).self_ty(db),
+        TypeNs::GenericParam(_) => {
+            // Even if this generic parameter has some trait bounds, rustdoc doesn't
+            // resolve `name` to trait items.
+            return None;
+        }
+        TypeNs::AdtId(id) | TypeNs::AdtSelfType(id) => Adt::from(id).ty(db),
+        TypeNs::EnumVariantId(id) => {
+            // Enum variants don't have path candidates.
+            let variant = Variant::from(id);
+            return resolve_field(db, variant.into(), name, ns);
+        }
+        TypeNs::TypeAliasId(id) => {
+            let alias = TypeAlias::from(id);
+            if alias.as_assoc_item(db).is_some() {
+                // We don't normalize associated type aliases, so we have nothing to
+                // resolve `name` to.
                 return None;
             }
-            TypeNs::AdtId(id) | TypeNs::AdtSelfType(id) => Adt::from(id).ty(db),
-            TypeNs::EnumVariantId(id) => {
-                // Enum variants don't have path candidates.
-                let variant = Variant::from(id);
-                return resolve_field(db, variant.into(), name, ns);
-            }
-            TypeNs::TypeAliasId(id) => {
-                let alias = TypeAlias::from(id);
-                if alias.as_assoc_item(db).is_some() {
-                    // We don't normalize associated type aliases, so we have nothing to
-                    // resolve `name` to.
-                    return None;
-                }
-                alias.ty(db)
-            }
-            TypeNs::BuiltinType(id) => BuiltinType::from(id).ty(db),
-            TypeNs::TraitId(id) => {
-                // Doc paths in this context may only resolve to an item of this trait
-                // (i.e. no items of its supertraits), so we need to handle them here
-                // independently of others.
-                return id.trait_items(db).items.iter().find(|it| it.0 == name).map(
-                    |(_, assoc_id)| {
-                        let def = match *assoc_id {
-                            AssocItemId::FunctionId(it) => ModuleDef::Function(it.into()),
-                            AssocItemId::ConstId(it) => ModuleDef::Const(it.into()),
-                            AssocItemId::TypeAliasId(it) => ModuleDef::TypeAlias(it.into()),
-                        };
-                        DocLinkDef::ModuleDef(def)
-                    },
-                );
-            }
-            TypeNs::ModuleId(_) => {
-                return None;
-            }
-        };
-
+            alias.ty(db)
+        }
+        TypeNs::BuiltinType(id) => BuiltinType::from(id).ty(db),
+        TypeNs::TraitId(id) => {
+            // Doc paths in this context may only resolve to an item of this trait
+            // (i.e. no items of its supertraits), so we need to handle them here
+            // independently of others.
+            return id.trait_items(db).items.iter().find(|it| it.0 == name).map(|(_, assoc_id)| {
+                let def = match *assoc_id {
+                    AssocItemId::FunctionId(it) => ModuleDef::Function(it.into()),
+                    AssocItemId::ConstId(it) => ModuleDef::Const(it.into()),
+                    AssocItemId::TypeAliasId(it) => ModuleDef::TypeAlias(it.into()),
+                };
+                DocLinkDef::ModuleDef(def)
+            });
+        }
+        TypeNs::ModuleId(_) => {
+            return None;
+        }
+    };
     // Resolve inherent items first, then trait items, then fields.
+
     if let Some(assoc_item_def) = resolve_assoc_item(db, &ty, &name, ns) {
         return Some(assoc_item_def);
     }
 ) -> Option<DocLinkDef> {
     let canonical = ty.canonical(db);
     let krate = ty.krate(db);
-    let environment = resolver.generic_def().map_or_else(
-        || crate::TraitEnvironment::empty(krate.id),
-        |d| db.trait_environment(d),
-    );
+    let environment = resolver
+        .generic_def()
+        .map_or_else(|| crate::TraitEnvironment::empty(krate.id), |d| db.trait_environment(d));
     let traits_in_scope = resolver.traits_in_scope(db);
 
     let mut result = None;
-
     // `ty.iterate_path_candidates()` require a scope, which is not available when resolving
     // attributes here. Use path resolution directly instead.
     //
     // FIXME: resolve type aliases (which are not yielded by iterate_path_candidates)
+
     _ = method_resolution::iterate_path_candidates(
         &canonical,
         db,
             // disambiguation) so we just pick the first one we find as well.
             result = as_module_def_if_namespace_matches(assoc_item_id.into(), ns);
 
-            if result.is_some() {
-                ControlFlow::Break(())
-            } else {
-                ControlFlow::Continue(())
-            }
+            if result.is_some() { ControlFlow::Break(()) } else { ControlFlow::Continue(()) }
         },
     );
 
     if let Some(Namespace::Types | Namespace::Macros) = ns {
         return None;
     }
-    def.fields(db)
-        .into_iter()
-        .find(|f| f.name(db) == name)
-        .map(DocLinkDef::Field)
+    def.fields(db).into_iter().find(|f| f.name(db) == name).map(DocLinkDef::Field)
 }
 
 fn as_module_def_if_namespace_matches(
                 PathKind::Plain
             }
         };
-        let parts = first_segment
-            .into_iter()
-            .chain(parts)
-            .map(|segment| match segment.parse() {
-                Ok(idx) => Name::new_tuple_field(idx),
-                Err(_) => Name::new_root(segment.split_once('<').map_or(segment, |it| it.0)),
-            });
+        let parts = first_segment.into_iter().chain(parts).map(|segment| match segment.parse() {
+            Ok(idx) => Name::new_tuple_field(idx),
+            Err(_) => Name::new_root(segment.split_once('<').map_or(segment, |it| it.0)),
+        });
         Some(ModPath::from_segments(kind, parts))
     };
     try_get_modpath(link)