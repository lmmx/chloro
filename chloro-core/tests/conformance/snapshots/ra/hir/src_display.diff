COMPARISON DIFF
============================================================

Original size: 30737 bytes
Chloro size:   30736 bytes
Rustfmt size:  31432 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         let data = db.function_signature(self.id);
         let container = self.as_assoc_item(db).map(|it| it.container(db));
         let mut module = self.module(db);
-
         // Write container (trait or impl)
+
         let container_params = match container {
             Some(AssocItemContainer::Trait(trait_)) => {
                 let (params, params_store) = f.db.generic_params_and_store(trait_.id.into());
             }
             None => None,
         };
-
         // Write signature of the function
-
         // Block-local impls are "hoisted" to the nearest (non-block) module.
+
         if let Some(AssocItemContainer::Impl(_)) = container {
             module = module.nearest_non_block_module(db);
         }
             first = false;
             skip_self = 1;
         }
-
         // FIXME: Use resolved `param.ty` once we no longer discard lifetimes
+
         let body = db.body(self.id.into());
-        for (type_ref, param) in data
-            .params
-            .iter()
-            .zip(self.assoc_fn_params(db))
-            .skip(skip_self)
-        {
+        for (type_ref, param) in data.params.iter().zip(self.assoc_fn_params(db)).skip(skip_self) {
             if !first {
                 f.write_str(", ")?;
             } else {
         }
 
         f.write_char(')')?;
-
         // `FunctionData::ret_type` will be `::core::future::Future<Output = ...>` for async fns.
         // Use ugly pattern match to strip the Future trait.
         // Better way?
+
         let ret_type = if !data.is_async() {
             data.ret_type
         } else if let Some(ret_type) = data.ret_type {
                 }
             }
         }
-
         // Write where clauses
+
         let has_written_where = write_where_clause(GenericDefId::FunctionId(self.id), f)?;
         if let Some((container_params, container_params_store)) = container_params {
             if !has_written_where {
                 let mut it = variant_data.fields().iter().peekable();
 
                 while let Some((id, _)) = it.next() {
-                    let field = Field {
-                        parent: (*self).into(),
-                        id,
-                    };
+                    let field = Field { parent: (*self).into(), id };
                     write_visibility(module_id, field.visibility(f.db), f)?;
                     field.ty(f.db).hir_fmt(f)?;
                     if it.peek().is_some() {
     let (indent, separator) = if in_line { ("", ' ') } else { ("    ", '\n') };
     f.write_char(if !has_where_clause { ' ' } else { separator })?;
     if count == 0 {
-        f.write_str(if fields.is_empty() {
-            "{}"
-        } else {
-            "{ /* … */ }"
-        })?;
+        f.write_str(if fields.is_empty() { "{}" } else { "{ /* … */ }" })?;
     } else {
         f.write_char('{')?;
 
     let count = variants.len().min(limit);
     f.write_char(if !has_where_clause { ' ' } else { '\n' })?;
     if count == 0 {
-        let variants = if variants.is_empty() {
-            "{}"
-        } else {
-            "{ /* … */ }"
-        };
+        let variants = if variants.is_empty() { "{}" } else { "{ /* … */ }" };
         f.write_str(variants)?;
     } else {
         f.write_str("{\n")?;
             write!(f, "    {}", variant.name(f.db).display(f.db, f.edition()))?;
             match variant.kind(f.db) {
                 StructKind::Tuple => {
-                    let fields_str = if variant.fields(f.db).is_empty() {
-                        "()"
-                    } else {
-                        "( /* … */ )"
-                    };
+                    let fields_str =
+                        if variant.fields(f.db).is_empty() { "()" } else { "( /* … */ )" };
                     f.write_str(fields_str)?;
                 }
                 StructKind::Record => {
-                    let fields_str = if variant.fields(f.db).is_empty() {
-                        " {}"
-                    } else {
-                        " { /* … */ }"
-                    };
+                    let fields_str =
+                        if variant.fields(f.db).is_empty() { " {}" } else { " { /* … */ }" };
                     f.write_str(fields_str)?;
                 }
                 StructKind::Unit => {}
 
         let sized_trait = LangItem::Sized.resolve_trait(f.db, krate);
         let has_only_sized_bound =
-            predicates
-                .iter()
-                .all(move |pred| match pred.kind().skip_binder() {
-                    ClauseKind::Trait(it) => Some(it.def_id().0) == sized_trait,
-                    _ => false,
-                });
+            predicates.iter().all(move |pred| match pred.kind().skip_binder() {
+                ClauseKind::Trait(it) => Some(it.def_id().0) == sized_trait,
+                _ => false,
+            });
         let has_only_not_sized_bound = predicates.is_empty();
         if !has_only_sized_bound || has_only_not_sized_bound {
             let default_sized = SizedByDefault::Sized { anchor: krate };
 ) -> Result<(), HirDisplayError> {
     let (params, store) = f.db.generic_params_and_store(def);
     if params.iter_lt().next().is_none()
-        && params
-            .iter_type_or_consts()
-            .all(|it| it.1.const_param().is_none())
+        && params.iter_type_or_consts().all(|it| it.1.const_param().is_none())
         && params
             .iter_type_or_consts()
             .filter_map(|it| it.1.type_param())
     f: &mut HirFormatter<'_, 'db>,
 ) -> Result<(), HirDisplayError> {
     use WherePredicate::*;
-
     // unnamed type targets are displayed inline with the argument itself, e.g. `f: impl Y`.
+
     let is_unnamed_type_target = |target: TypeRefId| {
         matches!(store[target],
             TypeRef::TypeParam(id) if f.db.generic_params(id.parent())[id.local_id()].name().is_none()
         (TypeBound { target: t1, .. }, TypeBound { target: t2, .. }) => t1 == t2,
         (Lifetime { target: t1, .. }, Lifetime { target: t2, .. }) => t1 == t2,
         (
-            ForLifetime {
-                lifetimes: l1,
-                target: t1,
-                ..
-            },
-            ForLifetime {
-                lifetimes: l2,
-                target: t2,
-                ..
-            },
+            ForLifetime { lifetimes: l1, target: t1, .. },
+            ForLifetime { lifetimes: l2, target: t2, .. },
         ) => l1 == l2 && t1 == t2,
         _ => false,
     };
                 write!(f, ": ")?;
                 bound.hir_fmt(f, store)?;
             }
-            ForLifetime {
-                lifetimes,
-                target,
-                bound,
-            } => {
-                let lifetimes = lifetimes
-                    .iter()
-                    .map(|it| it.display(f.db, f.edition()))
-                    .join(", ");
+            ForLifetime { lifetimes, target, bound } => {
+                let lifetimes = lifetimes.iter().map(|it| it.display(f.db, f.edition())).join(", ");
                 write!(f, "for<{lifetimes}> ")?;
                 target.hir_fmt(f, store)?;
                 f.write_str(": ")?;
         if !data.bounds.is_empty() {
             f.write_str(": ")?;
             f.write_joined(
-                data.bounds
-                    .iter()
-                    .map(|bound| hir_display_with_store(bound, &data.store)),
+                data.bounds.iter().map(|bound| hir_display_with_store(bound, &data.store)),
                 " + ",
             )?;
         }