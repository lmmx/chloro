COMPARISON DIFF
============================================================

Original size: 9578 bytes
Chloro size:   9575 bytes
Rustfmt size:  9883 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
                     // if the expression consists of a single number, like "0" or "12", it can refer to
                     // format args in the order they are specified.
                     // see: https://doc.rust-lang.org/std/fmt/#positional-parameters
-                    if trimmed
-                        .chars()
-                        .fold(true, |only_num, c| c.is_ascii_digit() && only_num)
-                    {
+                    if trimmed.chars().fold(true, |only_num, c| c.is_ascii_digit() && only_num) {
                         output.push_str(trimmed);
                     } else if matches!(state, State::Expr) {
                         extracted_expressions.push(Arg::Expr(trimmed.into()));
 #[cfg(test)]
 mod tests {
     use super::*;
-    use expect_test::{expect, Expect};
-
+    use expect_test::{Expect, expect};
     fn check(input: &str, expect: &Expect) {
         let (output, exprs) = parse_format_exprs(input).unwrap_or(("-".to_owned(), vec![]));
         let outcome_repr = if !exprs.is_empty() {
 
         expect.assert_eq(&outcome_repr);
     }
-
     #[test]
     fn format_str_parser() {
         let test_vector = &[
             ("no expressions", expect![["no expressions"]]),
-            (
-                r"no expressions with \$0$1",
-                expect![r"no expressions with \$0$1"],
-            ),
+            (r"no expressions with \$0$1", expect![r"no expressions with \$0$1"]),
             ("{expr} is {2 + 2}", expect![["{expr} is {}; 2 + 2"]]),
             ("{expr:?}", expect![["{expr:?}"]]),
             ("{expr:1$}", expect![[r"{expr:1$}"]]),
             ("{correct}}}", expect![["{correct}}}"]]),
             ("{correct}}}}}", expect![["{correct}}}}}"]]),
             ("{incorrect}}", expect![["-"]]),
-            (
-                "placeholders {} {}",
-                expect![["placeholders {} {}; $1, $2"]],
-            ),
-            (
-                "mixed {} {2 + 2} {}",
-                expect![["mixed {} {} {}; $1, 2 + 2, $2"]],
-            ),
+            ("placeholders {} {}", expect![["placeholders {} {}; $1, $2"]]),
+            ("mixed {} {2 + 2} {}", expect![["mixed {} {} {}; $1, 2 + 2, $2"]]),
             (
                 "{SomeStruct { val_a: 0, val_b: 1 }}",
                 expect![["{}; SomeStruct { val_a: 0, val_b: 1 }"]],
             ),
-            (
-                "{expr:?} is {2.32f64:.5}",
-                expect![["{expr:?} is {:.5}; 2.32f64"]],
-            ),
+            ("{expr:?} is {2.32f64:.5}", expect![["{expr:?} is {:.5}; 2.32f64"]]),
             (
                 "{SomeStruct { val_a: 0, val_b: 1 }:?}",
                 expect![["{:?}; SomeStruct { val_a: 0, val_b: 1 }"]],
             ),
             ("{     2 + 2        }", expect![["{}; 2 + 2"]]),
-            (
-                "{strsim::jaro_winkle(a)}",
-                expect![["{}; strsim::jaro_winkle(a)"]],
-            ),
+            ("{strsim::jaro_winkle(a)}", expect![["{}; strsim::jaro_winkle(a)"]]),
             ("{foo::bar::baz()}", expect![["{}; foo::bar::baz()"]]),
             ("{foo::bar():?}", expect![["{:?}; foo::bar()"]]),
         ];
             check(input, output)
         }
     }
-
     #[test]
     fn arg_type() {
         assert_eq!(