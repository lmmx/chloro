COMPARISON DIFF
============================================================

Original size: 9578 bytes
Chloro size:   9502 bytes
Rustfmt size:  9883 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 /// ```
 pub fn with_placeholders(args: Vec<Arg>) -> Vec<String> {
     let mut placeholder_id = 1;
-    args.into_iter()
-        .map(move |a| match a {
+    args.into_iter().map(move |a| match a {
             Arg::Expr(s) | Arg::Ident(s) => s,
             Arg::Placeholder => {
                 let s = format!("${placeholder_id}");
                 placeholder_id += 1;
                 s
             }
-        })
-        .collect()
+        }).collect(
+    )
 }
 
-// FIXME Remove this, we have this information in the HIR now
 /// Parser for a format-like string. It is more allowing in terms of string contents,
 /// as we expect variable placeholders to be filled with expressions.
 ///
     let mut output = String::new();
 
     // Count of open braces inside of an expression.
+
     // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.
+
     // "{MyStruct { val_a: 0, val_b: 1 }}".
     let mut inexpr_open_count = 0;
 
                     // if the expression consists of a single number, like "0" or "12", it can refer to
                     // format args in the order they are specified.
                     // see: https://doc.rust-lang.org/std/fmt/#positional-parameters
-                    if trimmed
-                        .chars()
-                        .fold(true, |only_num, c| c.is_ascii_digit() && only_num)
-                    {
+                    if trimmed.chars().fold(true, |only_num, c| c.is_ascii_digit() && only_num) {
                         output.push_str(trimmed);
                     } else if matches!(state, State::Expr) {
                         extracted_expressions.push(Arg::Expr(trimmed.into()));
 mod tests {
     use super::*;
     use expect_test::{expect, Expect};
-
     fn check(input: &str, expect: &Expect) {
         let (output, exprs) = parse_format_exprs(input).unwrap_or(("-".to_owned(), vec![]));
         let outcome_repr = if !exprs.is_empty() {
 
         expect.assert_eq(&outcome_repr);
     }
-
     #[test]
     fn format_str_parser() {
         let test_vector = &[
             ("no expressions", expect![["no expressions"]]),
-            (
-                r"no expressions with \$0$1",
-                expect![r"no expressions with \$0$1"],
-            ),
+            (r"no expressions with \$0$1", expect![r"no expressions with \$0$1"]),
             ("{expr} is {2 + 2}", expect![["{expr} is {}; 2 + 2"]]),
             ("{expr:?}", expect![["{expr:?}"]]),
             ("{expr:1$}", expect![[r"{expr:1$}"]]),
             ("{correct}}}", expect![["{correct}}}"]]),
             ("{correct}}}}}", expect![["{correct}}}}}"]]),
             ("{incorrect}}", expect![["-"]]),
-            (
-                "placeholders {} {}",
-                expect![["placeholders {} {}; $1, $2"]],
-            ),
-            (
-                "mixed {} {2 + 2} {}",
-                expect![["mixed {} {} {}; $1, 2 + 2, $2"]],
-            ),
+            ("placeholders {} {}", expect![["placeholders {} {}; $1, $2"]]),
+            ("mixed {} {2 + 2} {}", expect![["mixed {} {} {}; $1, 2 + 2, $2"]]),
             (
                 "{SomeStruct { val_a: 0, val_b: 1 }}",
                 expect![["{}; SomeStruct { val_a: 0, val_b: 1 }"]],
             ),
-            (
-                "{expr:?} is {2.32f64:.5}",
-                expect![["{expr:?} is {:.5}; 2.32f64"]],
-            ),
+            ("{expr:?} is {2.32f64:.5}", expect![["{expr:?} is {:.5}; 2.32f64"]]),
             (
                 "{SomeStruct { val_a: 0, val_b: 1 }:?}",
                 expect![["{:?}; SomeStruct { val_a: 0, val_b: 1 }"]],
             ),
             ("{     2 + 2        }", expect![["{}; 2 + 2"]]),
-            (
-                "{strsim::jaro_winkle(a)}",
-                expect![["{}; strsim::jaro_winkle(a)"]],
-            ),
+            ("{strsim::jaro_winkle(a)}", expect![["{}; strsim::jaro_winkle(a)"]]),
             ("{foo::bar::baz()}", expect![["{}; foo::bar::baz()"]]),
             ("{foo::bar():?}", expect![["{:?}; foo::bar()"]]),
         ];
             check(input, output)
         }
     }
-
     #[test]
     fn arg_type() {
         assert_eq!(