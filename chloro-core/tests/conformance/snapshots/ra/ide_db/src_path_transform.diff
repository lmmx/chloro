COMPARISON DIFF
============================================================

Original size: 25826 bytes
Chloro size:   25788 bytes
Rustfmt size:  25826 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! See [`PathTransform`].
 
-use crate::helpers::mod_path_to_ast;
 use either::Either;
 use hir::{
     AsAssocItem, FindPathConfig, HirDisplay, HirFileId, ModuleDef, SemanticsScope,
     syntax_editor::{self, SyntaxEditor},
 };
 
+use crate::helpers::mod_path_to_ast;
+
 #[derive(Default, Debug)]
 struct AstSubsts {
     types_and_consts: Vec<TypeOrConst>,
 
 #[derive(Debug)]
 enum TypeOrConst {
-    Either(ast::TypeArg), // indistinguishable type or const param
+    Either(ast::TypeArg),
     Const(ast::ConstArg),
 }
 
 type LifetimeName = String;
+
 type DefaultedParam = Either<hir::TypeParam, hir::ConstParam>;
 
 /// `PathTransform` substitutes path in SyntaxNodes in bulk.
     }
 
     #[must_use]
-    pub fn apply(&self, syntax: &SyntaxNode) -> SyntaxNode {
+    pub fn apply(
+        &self,
+        syntax: &SyntaxNode,
+    ) -> SyntaxNode {
         self.build_ctx().apply(syntax)
     }
 
         nodes.into_iter().map(|node| ctx.apply(&node.clone())).collect()
     }
 
-    fn prettify_target_node(&self, node: SyntaxNode) -> SyntaxNode {
+    fn prettify_target_node(
+        &self,
+        node: SyntaxNode,
+    ) -> SyntaxNode {
         match self.target_scope.file_id() {
             HirFileId::FileId(_) => node,
             HirFileId::MacroFile(file_id) => {
         }
     }
 
-    fn prettify_target_ast<N: AstNode>(&self, node: N) -> N {
+    fn prettify_target_ast<N: AstNode>(
+        &self,
+        node: N,
+    ) -> N {
         N::cast(self.prettify_target_node(node.syntax().clone())).unwrap()
     }
 
 }
 
 impl Ctx<'_> {
-    fn apply(&self, item: &SyntaxNode) -> SyntaxNode {
+    fn apply(
+        &self,
+        item: &SyntaxNode,
+    ) -> SyntaxNode {
         // `transform_path` may update a node's parent and that would break the
         // tree traversal. Thus all paths in the tree are collected into a vec
         // so that such operation is safe.
                     .replace(lifetime.syntax(), subst.clone_subtree().clone_for_update().syntax());
             }
         });
-
         editor.finish().new_root().clone()
     }
 
-    fn transform_default_values(&mut self, defaulted_params: Vec<DefaultedParam>) {
+    fn transform_default_values(
+        &mut self,
+        defaulted_params: Vec<DefaultedParam>,
+    ) {
         // By now the default values are simply copied from where they are declared
         // and should be transformed. As any value is allowed to refer to previous
         // generic (both type and const) parameters, they should be all iterated left-to-right.
         }
     }
 
-    fn transform_path(&self, path: &SyntaxNode) -> SyntaxNode {
+    fn transform_path(
+        &self,
+        path: &SyntaxNode,
+    ) -> SyntaxNode {
         fn find_child_paths_and_ident_pats(
             root_path: &SyntaxNode,
         ) -> Vec<Either<ast::Path, ast::IdentPat>> {
             }
             result
         }
-
         let root_path = path.clone_subtree();
-
         let result = find_child_paths_and_ident_pats(&root_path);
         let mut editor = SyntaxEditor::new(root_path.clone());
         for sub_path in result {
             let new = self.transform_path(sub_path.syntax());
             editor.replace(sub_path.syntax(), new);
         }
-
         let update_sub_item = editor.finish().new_root().clone().clone_subtree();
         let item = find_child_paths_and_ident_pats(&update_sub_item);
         let mut editor = SyntaxEditor::new(update_sub_item);
         }
         editor.finish().new_root().clone()
     }
+
     fn transform_path_or_ident_pat(
         &self,
         editor: &mut SyntaxEditor,
         }
     }
 
-    fn transform_path_(&self, editor: &mut SyntaxEditor, path: &ast::Path) -> Option<()> {
+    fn transform_path_(
+        &self,
+        editor: &mut SyntaxEditor,
+        path: &ast::Path,
+    ) -> Option<()> {
         if path.qualifier().is_some() {
             return None;
         }
             return None;
         }
         let resolution = self.source_scope.speculative_resolve(path)?;
-
         match resolution {
             hir::PathResolution::TypeParam(tp) => {
                 if let Some(subst) = self.type_substs.get(&tp) {
         ident_pat: &ast::IdentPat,
     ) -> Option<()> {
         let name = ident_pat.name()?;
-
         let temp_path = make::path_from_text(&name.text());
-
         let resolution = self.source_scope.speculative_resolve(&temp_path)?;
-
         match resolution {
             hir::PathResolution::Def(def) if def.as_assoc_item(self.source_scope.db).is_none() => {
                 let cfg = FindPathConfig {
     }
 }
 
-// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the
-// trait ref, and then go from the types in the substs back to the syntax).
 fn get_syntactic_substs(impl_def: ast::Impl) -> Option<AstSubsts> {
     let target_trait = impl_def.trait_()?;
     let path_type = match target_trait {
         _ => return None,
     };
     let generic_arg_list = path_type.path()?.segment()?.generic_arg_list()?;
-
     get_type_args_from_arg_list(generic_arg_list)
 }
 
         ast::GenericArg::LifetimeArg(l_arg) => result.lifetimes.push(l_arg),
         _ => (),
     });
-
     Some(result)
 }
 
 ) -> Option<hir::Trait> {
     let db = scope.db;
     let trait_bounds = type_param.trait_bounds(db);
-
     let assoc_item_name = assoc_item.text();
-
     for trait_ in trait_bounds {
         let names = trait_.items(db).into_iter().filter_map(|item| match item {
             hir::AssocItem::TypeAlias(ta) => Some(ta.name(db)),
             }
         }
     }
-
     None
 }