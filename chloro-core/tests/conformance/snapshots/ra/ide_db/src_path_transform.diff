COMPARISON DIFF
============================================================

Original size: 25826 bytes
Chloro size:   25467 bytes
Rustfmt size:  25826 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! See [`PathTransform`].
 
-use crate::helpers::mod_path_to_ast;
 use either::Either;
 use hir::{
-    AsAssocItem, FindPathConfig, HirDisplay, HirFileId, ModuleDef, SemanticsScope,
-    prettify_macro_expansion,
+    prettify_macro_expansion, AsAssocItem, FindPathConfig, HirDisplay, HirFileId, ModuleDef,
+    SemanticsScope,
 };
 use itertools::Itertools;
 use rustc_hash::FxHashMap;
 use span::Edition;
 use syntax::{
-    NodeOrToken, SyntaxNode,
-    ast::{self, AstNode, HasGenericArgs, HasName, make},
+    ast::{self, make, AstNode, HasGenericArgs, HasName},
     syntax_editor::{self, SyntaxEditor},
+    NodeOrToken, SyntaxNode,
 };
 
+use crate::helpers::mod_path_to_ast;
+
 #[derive(Default, Debug)]
 struct AstSubsts {
     types_and_consts: Vec<TypeOrConst>,
 
 #[derive(Debug)]
 enum TypeOrConst {
-    Either(ast::TypeArg), // indistinguishable type or const param
+    Either(ast::TypeArg),
+    // indistinguishable type or const param
     Const(ast::ConstArg),
 }
 
 type LifetimeName = String;
+
 type DefaultedParam = Either<hir::TypeParam, hir::ConstParam>;
 
 /// `PathTransform` substitutes path in SyntaxNodes in bulk.
                     &db.expansion_span_map(file_id),
                     self.target_scope.module().krate().into(),
                 )
-            }
+            },
         }
     }
 
                 Either::Left(k) => self.type_substs.get(k).unwrap().syntax(),
                 Either::Right(k) => self.const_substs.get(k).unwrap(),
             };
-            // `transform_path` may update a node's parent and that would break the
-            // tree traversal. Thus all paths in the tree are collected into a vec
-            // so that such operation is safe.
             let new_value = self.transform_path(value);
             match param {
                 Either::Left(k) => {
                     self.type_substs.insert(k, ast::Type::cast(new_value.clone()).unwrap());
-                }
+                },
                 Either::Right(k) => {
                     self.const_substs.insert(k, new_value.clone());
-                }
+                },
             }
         }
     }
         }
         editor.finish().new_root().clone()
     }
+
     fn transform_path_or_ident_pat(
         &self,
         editor: &mut SyntaxEditor,
                 let res = mod_path_to_ast(&found_path, self.target_edition).clone_for_update();
                 editor.replace(ident_pat.syntax(), res.syntax());
                 Some(())
-            }
+            },
             _ => None,
         }
     }
 }
 
-// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the
-// trait ref, and then go from the types in the substs back to the syntax).
 fn get_syntactic_substs(impl_def: ast::Impl) -> Option<AstSubsts> {
     let target_trait = impl_def.trait_()?;
     let path_type = match target_trait {