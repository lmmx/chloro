COMPARISON DIFF
============================================================

Original size: 25826 bytes
Chloro size:   25828 bytes
Rustfmt size:  26563 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 }
 
 type LifetimeName = String;
+
 type DefaultedParam = Either<hir::TypeParam, hir::ConstParam>;
 
 /// `PathTransform` substitutes path in SyntaxNodes in bulk.
         nodes: impl IntoIterator<Item = &'b SyntaxNode>,
     ) -> Vec<SyntaxNode> {
         let ctx = self.build_ctx();
-        nodes
-            .into_iter()
-            .map(|node| ctx.apply(&node.clone()))
-            .collect()
+        nodes.into_iter().map(|node| ctx.apply(&node.clone())).collect()
     }
 
     fn prettify_target_node(&self, node: SyntaxNode) -> SyntaxNode {
             // can still hit those trailing values and check if they actually have
             // a default type. If they do, go for that type from `hir` to `ast` so
             // the resulting change can be applied correctly.
-            .zip(
-                self.substs
-                    .types_and_consts
-                    .iter()
-                    .map(Some)
-                    .chain(std::iter::repeat(None)),
-            )
+            .zip(self.substs.types_and_consts.iter().map(Some).chain(std::iter::repeat(None)))
             .for_each(|(k, v)| match (k.split(db), v) {
                 (Either::Right(k), Some(TypeOrConst::Either(v))) => {
                     if let Some(ty) = v.ty() {
                 }
                 (Either::Right(k), None) => {
                     if let Some(default) = k.default(db)
-                        && let Some(default) = &default
-                            .display_source_code(db, source_module.into(), false)
-                            .ok()
+                        && let Some(default) =
+                            &default.display_source_code(db, source_module.into(), false).ok()
                     {
                         type_substs.insert(k, make::ty(default).clone_for_update());
                         defaulted_params.push(Either::Left(k));
             .flat_map(|it| it.lifetime_params(db))
             .zip(self.substs.lifetimes.clone())
             .filter_map(|(k, v)| {
-                Some((
-                    k.name(db).display(db, target_edition).to_string(),
-                    v.lifetime()?,
-                ))
+                Some((k.name(db).display(db, target_edition).to_string(), v.lifetime()?))
             })
             .collect();
         let mut ctx = Ctx {
         // so that such operation is safe.
         let item = self.transform_path(item).clone_subtree();
         let mut editor = SyntaxEditor::new(item.clone());
-        preorder_rev(&item)
-            .filter_map(ast::Lifetime::cast)
-            .for_each(|lifetime| {
-                if let Some(subst) = self
-                    .lifetime_substs
-                    .get(&lifetime.syntax().text().to_string())
-                {
-                    editor.replace(
-                        lifetime.syntax(),
-                        subst.clone_subtree().clone_for_update().syntax(),
-                    );
-                }
-            });
+        preorder_rev(&item).filter_map(ast::Lifetime::cast).for_each(|lifetime| {
+            if let Some(subst) = self.lifetime_substs.get(&lifetime.syntax().text().to_string()) {
+                editor
+                    .replace(lifetime.syntax(), subst.clone_subtree().clone_for_update().syntax());
+            }
+        });
 
         editor.finish().new_root().clone()
     }
             let new_value = self.transform_path(value);
             match param {
                 Either::Left(k) => {
-                    self.type_substs
-                        .insert(k, ast::Type::cast(new_value.clone()).unwrap());
+                    self.type_substs.insert(k, ast::Type::cast(new_value.clone()).unwrap());
                 }
                 Either::Right(k) => {
                     self.const_substs.insert(k, new_value.clone());
         }
         editor.finish().new_root().clone()
     }
+
     fn transform_path_or_ident_pat(
         &self,
         editor: &mut SyntaxEditor,
                             let end = path_ty.syntax().last_child().map(NodeOrToken::Node)?;
                             editor.replace_all(
                                 start..=end,
-                                new.syntax()
-                                    .children()
-                                    .map(NodeOrToken::Node)
-                                    .collect::<Vec<_>>(),
+                                new.syntax().children().map(NodeOrToken::Node).collect::<Vec<_>>(),
                             );
                         }
                     } else {
                     prefer_absolute: false,
                     allow_unstable: true,
                 };
-                let found_path = self
-                    .target_module
-                    .find_path(self.source_scope.db, def, cfg)?;
+                let found_path = self.target_module.find_path(self.source_scope.db, def, cfg)?;
                 let res = mod_path_to_ast(&found_path, self.target_edition).clone_for_update();
                 let mut res_editor = SyntaxEditor::new(res.syntax().clone_subtree());
                 if let Some(args) = path.segment().and_then(|it| it.generic_arg_list())
                     && let Some(segment) = res.segment()
                 {
                     if let Some(old) = segment.generic_arg_list() {
-                        res_editor.replace(
-                            old.syntax(),
-                            args.clone_subtree().syntax().clone_for_update(),
-                        )
+                        res_editor
+                            .replace(old.syntax(), args.clone_subtree().syntax().clone_for_update())
                     } else {
                         res_editor.insert(
                             syntax_editor::Position::last_child_of(segment.syntax()),
                     prefer_absolute: false,
                     allow_unstable: true,
                 };
-                let found_path = self
-                    .target_module
-                    .find_path(self.source_scope.db, def, cfg)?;
+                let found_path = self.target_module.find_path(self.source_scope.db, def, cfg)?;
                 let res = mod_path_to_ast(&found_path, self.target_edition).clone_for_update();
                 editor.replace(ident_pat.syntax(), res.syntax());
                 Some(())
 
 fn get_type_args_from_arg_list(generic_arg_list: ast::GenericArgList) -> Option<AstSubsts> {
     let mut result = AstSubsts::default();
-    generic_arg_list
-        .generic_args()
-        .for_each(|generic_arg| match generic_arg {
-            // Const params are marked as consts on definition only,
-            // being passed to the trait they are indistguishable from type params;
-            // anyway, we don't really need to distinguish them here.
-            ast::GenericArg::TypeArg(type_arg) => {
-                result.types_and_consts.push(TypeOrConst::Either(type_arg))
-            }
-            // Some const values are recognized correctly.
-            ast::GenericArg::ConstArg(const_arg) => {
-                result.types_and_consts.push(TypeOrConst::Const(const_arg));
-            }
-            ast::GenericArg::LifetimeArg(l_arg) => result.lifetimes.push(l_arg),
-            _ => (),
-        });
+    generic_arg_list.generic_args().for_each(|generic_arg| match generic_arg {
+        // Const params are marked as consts on definition only,
+        // being passed to the trait they are indistguishable from type params;
+        // anyway, we don't really need to distinguish them here.
+        ast::GenericArg::TypeArg(type_arg) => {
+            result.types_and_consts.push(TypeOrConst::Either(type_arg))
+        }
+        // Some const values are recognized correctly.
+        ast::GenericArg::ConstArg(const_arg) => {
+            result.types_and_consts.push(TypeOrConst::Const(const_arg));
+        }
+        ast::GenericArg::LifetimeArg(l_arg) => result.lifetimes.push(l_arg),
+        _ => (),
+    });
 
     Some(result)
 }