COMPARISON DIFF
============================================================

Original size: 25826 bytes
Chloro size:   25248 bytes
Rustfmt size:  25826 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! See [`PathTransform`].
 
-use crate::helpers::mod_path_to_ast;
 use either::Either;
 use hir::{
-    AsAssocItem, FindPathConfig, HirDisplay, HirFileId, ModuleDef, SemanticsScope,
-    prettify_macro_expansion,
+    prettify_macro_expansion, AsAssocItem, FindPathConfig, HirDisplay, HirFileId, ModuleDef,
+    SemanticsScope,
 };
 use itertools::Itertools;
 use rustc_hash::FxHashMap;
 use span::Edition;
 use syntax::{
-    NodeOrToken, SyntaxNode,
-    ast::{self, AstNode, HasGenericArgs, HasName, make},
+    ast::{self, make, AstNode, HasGenericArgs, HasName},
     syntax_editor::{self, SyntaxEditor},
+    NodeOrToken, SyntaxNode,
 };
 
+use crate::helpers::mod_path_to_ast;
+
 #[derive(Default, Debug)]
 struct AstSubsts {
     types_and_consts: Vec<TypeOrConst>,
 
 #[derive(Debug)]
 enum TypeOrConst {
-    Either(ast::TypeArg), // indistinguishable type or const param
+    Either(ast::TypeArg),
+    // indistinguishable type or const param
     Const(ast::ConstArg),
 }
 
 type LifetimeName = String;
+
 type DefaultedParam = Either<hir::TypeParam, hir::ConstParam>;
 
 /// `PathTransform` substitutes path in SyntaxNodes in bulk.
             .into_iter()
             .flat_map(|it| it.type_or_const_params(db))
             .skip(skip)
-            // The actual list of trait type parameters may be longer than the one
-            // used in the `impl` block due to trailing default type parameters.
-            // For that case we extend the `substs` with an empty iterator so we
-            // can still hit those trailing values and check if they actually have
-            // a default type. If they do, go for that type from `hir` to `ast` so
-            // the resulting change can be applied correctly.
             .zip(self.substs.types_and_consts.iter().map(Some).chain(std::iter::repeat(None)))
             .for_each(|(k, v)| match (k.split(db), v) {
                 (Either::Right(k), Some(TypeOrConst::Either(v))) => {
         // so that such operation is safe.
         let item = self.transform_path(item).clone_subtree();
         let mut editor = SyntaxEditor::new(item.clone());
-        preorder_rev(&item).filter_map(ast::Lifetime::cast).for_each(|lifetime| {
+        preorder_rev(&item)
+            .filter_map(ast::Lifetime::cast)
+            .for_each(|lifetime| {
             if let Some(subst) = self.lifetime_substs.get(&lifetime.syntax().text().to_string()) {
                 editor
                     .replace(lifetime.syntax(), subst.clone_subtree().clone_for_update().syntax());
         }
         editor.finish().new_root().clone()
     }
+
     fn transform_path_or_ident_pat(
         &self,
         editor: &mut SyntaxEditor,
     }
 }
 
-// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the
-// trait ref, and then go from the types in the substs back to the syntax).
 fn get_syntactic_substs(impl_def: ast::Impl) -> Option<AstSubsts> {
     let target_trait = impl_def.trait_()?;
     let path_type = match target_trait {
 
 fn get_type_args_from_arg_list(generic_arg_list: ast::GenericArgList) -> Option<AstSubsts> {
     let mut result = AstSubsts::default();
-    generic_arg_list.generic_args().for_each(|generic_arg| match generic_arg {
+    generic_arg_list
+        .generic_args()
+        .for_each(|generic_arg| match generic_arg {
         // Const params are marked as consts on definition only,
         // being passed to the trait they are indistguishable from type params;
         // anyway, we don't really need to distinguish them here.