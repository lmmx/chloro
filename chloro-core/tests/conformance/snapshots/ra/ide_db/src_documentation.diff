COMPARISON DIFF
============================================================

Original size: 11810 bytes
Chloro size:   11711 bytes
Rustfmt size:  12398 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Documentation attribute related utilities.
+
 use either::Either;
 use hir::{
     db::{DefDatabase, HirDatabase},
     }
 }
 
-pub trait HasDocs: HasAttrs {
+pub trait HasDocs {
     fn docs(self, db: &dyn HirDatabase) -> Option<Documentation>;
+
     fn docs_with_rangemap(self, db: &dyn HirDatabase) -> Option<(Documentation, DocsRangeMap)>;
+
     fn resolve_doc_path(
         self,
         db: &dyn HirDatabase,
         is_inner_doc: bool,
     ) -> Option<hir::DocLinkDef>;
 }
+
 /// A struct to map text ranges from [`Documentation`] back to TextRanges in the syntax tree.
 #[derive(Debug)]
 pub struct DocsRangeMap {
 impl DocsRangeMap {
     /// Maps a [`TextRange`] relative to the documentation string back to its AST range
     pub fn map(&self, range: TextRange) -> Option<(InFile<TextRange>, AttrId)> {
-        let found = self
-            .mapping
-            .binary_search_by(|(probe, ..)| probe.ordering(range))
-            .ok()?;
+        let found = self.mapping.binary_search_by(|(probe, ..)| probe.ordering(range)).ok()?;
         let (line_docs_range, idx, original_line_src_range) = self.mapping[found];
         if !line_docs_range.contains_range(range) {
             return None;
 
         let relative_range = range - line_docs_range.start();
 
-        let InFile {
-            file_id,
-            value: source,
-        } = self.source_map.source_of_id(idx);
+        let InFile { file_id, value: source } = self.source_map.source_of_id(idx);
         match source {
             Either::Left(attr) => {
                 let string = get_doc_string_in_attr(attr)?;
                     text_range.end() + original_line_src_range.start() + relative_range.start(),
                     string.syntax().text_range().len().min(range.len()),
                 );
-                Some((
-                    InFile {
-                        file_id,
-                        value: range,
-                    },
-                    idx,
-                ))
-            }
+                Some((InFile { file_id, value: range }, idx))
+            },
             Either::Right(comment) => {
                 let text_range = comment.syntax().text_range();
                 let range = TextRange::at(
                         + relative_range.start(),
                     text_range.len().min(range.len()),
                 );
-                Some((
-                    InFile {
-                        file_id,
-                        value: range,
-                    },
-                    idx,
-                ))
-            }
+                Some((InFile { file_id, value: range }, idx))
+            },
         }
     }
 
                 (buf_offset, id, base_offset)
             })
             .collect_vec();
-        DocsRangeMap {
-            source_map: self.source_map,
-            mapping,
-        }
+        DocsRangeMap { source_map: self.source_map, mapping }
     }
 }
 
     if buf.is_empty() {
         None
     } else {
-        Some((
-            Documentation(buf),
-            DocsRangeMap {
-                mapping,
-                source_map: attrs.source_map(db),
-            },
-        ))
+        Some((Documentation(buf), DocsRangeMap { mapping, source_map: attrs.source_map(db) }))
     }
 }
 
 pub fn docs_from_attrs(attrs: &hir::Attrs) -> Option<String> {
-    let docs = attrs
-        .by_key(sym::doc)
-        .attrs()
-        .filter_map(|attr| attr.string_value_unescape());
+    let docs = attrs.by_key(sym::doc).attrs().filter_map(|attr| attr.string_value_unescape());
     let indent = doc_indent(attrs);
     let mut buf = String::new();
     for doc in docs {
             // We don't trim trailing whitespace from doc comments as multiple trailing spaces
             // indicates a hard line break in Markdown.
             let lines = doc.lines().map(|line| {
-                line.char_indices()
-                    .nth(indent)
-                    .map_or(line, |(offset, _)| &line[offset..])
+                line.char_indices().nth(indent).map_or(line, |(offset, _)| &line[offset..])
             });
 
             buf.extend(Itertools::intersperse(lines, "\n"));
                 decl_docs.push('\n');
                 decl_docs += &crate_docs;
                 Some(decl_docs)
-            }
-        }
-        .map(Documentation::new)
+            },
+        }.map(
+            Documentation::new,
+        )
     }
 
     fn docs_with_rangemap(self, db: &dyn HirDatabase) -> Option<(Documentation, DocsRangeMap)> {
                 let crate_range_map = crate_range_map.shift_docstring_line_range(offset);
                 decl_range_map.mapping.extend(crate_range_map.mapping);
                 Some((Documentation(decl_docs), decl_range_map))
-            }
+            },
         }
     }
+
     fn resolve_doc_path(
         self,
         db: &dyn HirDatabase,
 
 fn get_doc_string_in_attr(it: &ast::Attr) -> Option<ast::String> {
     match it.expr() {
-        // #[doc = lit]
         Some(ast::Expr::Literal(lit)) => match lit.kind() {
             ast::LiteralKind::String(it) => Some(it),
             _ => None,
         },
-        // #[cfg_attr(..., doc = "", ...)]
         None => {
-            // FIXME: See highlight injection for what to do here
             None
-        }
+        },
         _ => None,
     }
 }
 
 fn doc_indent(attrs: &hir::Attrs) -> usize {
     let mut min = !0;
-    for val in attrs
-        .by_key(sym::doc)
-        .attrs()
-        .filter_map(|attr| attr.string_value_unescape())
-    {
-        if let Some(m) = val
-            .lines()
-            .filter_map(|line| line.chars().position(|c| !c.is_whitespace()))
-            .min()
+    for val in attrs.by_key(sym::doc).attrs().filter_map(|attr| attr.string_value_unescape()) {
+        if let Some(m) =
+            val.lines().filter_map(|line| line.chars().position(|c| !c.is_whitespace())).min()
         {
             min = min.min(m);
         }