COMPARISON DIFF
============================================================

Original size: 11810 bytes
Chloro size:   11424 bytes
Rustfmt size:  12398 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Documentation attribute related utilities.
+
 use either::Either;
 use hir::{
     db::{DefDatabase, HirDatabase},
     }
 }
 
-pub trait HasDocs: HasAttrs {
+pub trait HasDocs {
     fn docs(self, db: &dyn HirDatabase) -> Option<Documentation>;
+
     fn docs_with_rangemap(self, db: &dyn HirDatabase) -> Option<(Documentation, DocsRangeMap)>;
+
     fn resolve_doc_path(
         self,
         db: &dyn HirDatabase,
         is_inner_doc: bool,
     ) -> Option<hir::DocLinkDef>;
 }
+
 /// A struct to map text ranges from [`Documentation`] back to TextRanges in the syntax tree.
 #[derive(Debug)]
 pub struct DocsRangeMap {
     source_map: AttrSourceMap,
-    // (docstring-line-range, attr_index, attr-string-range)
-    // a mapping from the text range of a line of the [`Documentation`] to the attribute index and
-    // the original (untrimmed) syntax doc line
     mapping: Vec<(TextRange, AttrId, TextRange)>,
 }
 
 impl DocsRangeMap {
     /// Maps a [`TextRange`] relative to the documentation string back to its AST range
     pub fn map(&self, range: TextRange) -> Option<(InFile<TextRange>, AttrId)> {
-        let found = self
-            .mapping
-            .binary_search_by(|(probe, ..)| probe.ordering(range))
-            .ok()?;
+        let found = self.mapping.binary_search_by(|(probe, ..)| probe.ordering(range)).ok()?;
         let (line_docs_range, idx, original_line_src_range) = self.mapping[found];
         if !line_docs_range.contains_range(range) {
             return None;
 
         let relative_range = range - line_docs_range.start();
 
-        let InFile {
-            file_id,
-            value: source,
-        } = self.source_map.source_of_id(idx);
+        let InFile { file_id, value: source } = self.source_map.source_of_id(idx);
         match source {
             Either::Left(attr) => {
                 let string = get_doc_string_in_attr(attr)?;
                     text_range.end() + original_line_src_range.start() + relative_range.start(),
                     string.syntax().text_range().len().min(range.len()),
                 );
-                Some((
-                    InFile {
-                        file_id,
-                        value: range,
-                    },
-                    idx,
-                ))
+                Some((InFile { file_id, value: range }, idx))
             }
             Either::Right(comment) => {
                 let text_range = comment.syntax().text_range();
                         + relative_range.start(),
                     text_range.len().min(range.len()),
                 );
-                Some((
-                    InFile {
-                        file_id,
-                        value: range,
-                    },
-                    idx,
-                ))
+                Some((InFile { file_id, value: range }, idx))
             }
         }
     }
                 (buf_offset, id, base_offset)
             })
             .collect_vec();
-        DocsRangeMap {
-            source_map: self.source_map,
-            mapping,
-        }
+        DocsRangeMap { source_map: self.source_map, mapping }
     }
 }
 
     if buf.is_empty() {
         None
     } else {
-        Some((
-            Documentation(buf),
-            DocsRangeMap {
-                mapping,
-                source_map: attrs.source_map(db),
-            },
-        ))
+        Some((Documentation(buf), DocsRangeMap { mapping, source_map: attrs.source_map(db) }))
     }
 }
 
 pub fn docs_from_attrs(attrs: &hir::Attrs) -> Option<String> {
-    let docs = attrs
-        .by_key(sym::doc)
-        .attrs()
-        .filter_map(|attr| attr.string_value_unescape());
+    let docs = attrs.by_key(sym::doc).attrs().filter_map(|attr| attr.string_value_unescape());
     let indent = doc_indent(attrs);
     let mut buf = String::new();
     for doc in docs {
             // We don't trim trailing whitespace from doc comments as multiple trailing spaces
             // indicates a hard line break in Markdown.
             let lines = doc.lines().map(|line| {
-                line.char_indices()
-                    .nth(indent)
-                    .map_or(line, |(offset, _)| &line[offset..])
+                line.char_indices().nth(indent).map_or(line, |(offset, _)| &line[offset..])
             });
 
             buf.extend(Itertools::intersperse(lines, "\n"));
         buf.push('\n');
     }
     buf.pop();
-    if buf.is_empty() {
-        None
-    } else {
-        Some(buf)
-    }
+    if buf.is_empty() { None } else { Some(buf) }
 }
 
 macro_rules! impl_has_docs {
         }
     )*};
 }
-
-impl_has_docs![
-    Variant, Field, Static, Const, Trait, TypeAlias, Macro, Function, Adt, Module, Impl, Crate,
-];
-
 macro_rules! impl_has_docs_enum {
     ($($variant:ident),* for $enum:ident) => {$(
         impl HasDocs for hir::$variant {
         }
     )*};
 }
-
-impl_has_docs_enum![Struct, Union, Enum for Adt];
-
 impl HasDocs for hir::AssocItem {
     fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {
         match self {
             }
         }
     }
+
     fn resolve_doc_path(
         self,
         db: &dyn HirDatabase,
 
 fn doc_indent(attrs: &hir::Attrs) -> usize {
     let mut min = !0;
-    for val in attrs
-        .by_key(sym::doc)
-        .attrs()
-        .filter_map(|attr| attr.string_value_unescape())
-    {
-        if let Some(m) = val
-            .lines()
-            .filter_map(|line| line.chars().position(|c| !c.is_whitespace()))
-            .min()
+    for val in attrs.by_key(sym::doc).attrs().filter_map(|attr| attr.string_value_unescape()) {
+        if let Some(m) =
+            val.lines().filter_map(|line| line.chars().position(|c| !c.is_whitespace())).min()
         {
             min = min.min(m);
         }