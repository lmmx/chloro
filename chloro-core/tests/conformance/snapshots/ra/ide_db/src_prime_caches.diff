COMPARISON DIFF
============================================================

Original size: 12112 bytes
Chloro size:   12099 bytes
Rustfmt size:  12243 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! rust-analyzer is lazy and doesn't compute anything unless asked. This
 //! sometimes is counter productive when, for example, the first goto definition
 //! request takes longer to compute. This module implements prepopulation of
 //! various caches, it's not really advanced at the moment.
+
 use std::panic::AssertUnwindSafe;
 
-use hir::{db::DefDatabase, Symbol};
+use hir::{Symbol, db::DefDatabase};
 use rustc_hash::FxHashMap;
 use salsa::{Cancelled, Database};
 
 use crate::{
+    FxIndexMap, RootDatabase,
     base_db::{Crate, RootQueryDb},
     symbol_index::SymbolIndex,
-    FxIndexMap, RootDatabase,
 };
 
 /// We're indexing many crates.
     }
 
     // The setup here is a bit complicated. We try to make best use of compute resources.
+
     // The idea is that if we have a def map available to compute, we should do that first.
+
     // This is because def map is a dependency of both import map and symbols. So if we have
+
     // e.g. a def map and a symbols, if we compute the def map we can, after it completes,
+
     // compute the def maps of dependencies, the existing symbols and the symbols of the
+
     // new crate, all in parallel. But if we compute the symbols, after that we will only
+
     // have the def map to compute, and the rest of the CPU cores will rest, which is not
+
     // good.
+
     // However, it's better to compute symbols/import map than to compute a def map that
+
     // isn't ready yet, because one of its dependencies hasn't yet completed its def map.
+
     // Such def map will just block on the dependency, which is just wasted time. So better
+
     // to compute the symbols/import map of an already computed def map in that time.
 
     let (reverse_deps, mut to_be_done_deps) = {
             .iter()
             .map(|&krate| (krate, krate.data(db).dependencies.len() as u32))
             .collect::<FxHashMap<_, _>>();
-        let mut reverse_deps = all_crates
-            .iter()
-            .map(|&krate| (krate, Vec::new()))
-            .collect::<FxHashMap<_, _>>();
+        let mut reverse_deps =
+            all_crates.iter().map(|&krate| (krate, Vec::new())).collect::<FxHashMap<_, _>>();
         for &krate in &*all_crates {
             for dep in &krate.data(db).dependencies {
                 reverse_deps.get_mut(&dep.crate_id).unwrap().push(krate);
             .expect("failed to spawn thread");
         }
 
-        (
-            def_map_work_sender,
-            import_map_work_sender,
-            symbols_work_sender,
-            progress_receiver,
-        )
+        (def_map_work_sender, import_map_work_sender, symbols_work_sender, progress_receiver)
     };
 
     let crate_def_maps_total = db.all_crates().len();
     let (mut module_symbols_total, mut module_symbols_done) = (0usize, 0usize);
 
     // an index map is used to preserve ordering so we can sort the progress report in order of
+
     // "longest crate to index" first
+
     let mut crates_currently_indexing =
         FxIndexMap::with_capacity_and_hasher(num_worker_threads, Default::default());
 
         def_map_work_sender.send((krate, name)).ok();
     }
 
-    while crate_def_maps_done < crate_def_maps_total
-        || crate_import_maps_done < crate_import_maps_total
-        || module_symbols_done < module_symbols_total
-    {
+    while crate_def_maps_done < crate_def_maps_total || crate_import_maps_done < crate_import_maps_total || module_symbols_done < module_symbols_total {
+        // Biased to prefer progress updates (and because it's faster).
         db.unwind_if_revision_cancelled();
-
         let progress = ParallelPrimeCachesProgress {
             crates_currently_indexing: crates_currently_indexing.values().cloned().collect(),
             crates_done: crate_def_maps_done,
             crates_total: crate_def_maps_total,
             work_type: "Indexing",
         };
-
         cb(progress);
-
-        // Biased to prefer progress updates (and because it's faster).
         let progress = match progress_receiver.recv() {
             Ok(p) => p,
             Err(crossbeam_channel::RecvError) => {
                 return;
             }
         };
-
         match progress {
-            ParallelPrimeCacheWorkerProgress::BeginCrateDefMap {
-                crate_id,
-                crate_name,
-            } => {
+            ParallelPrimeCacheWorkerProgress::BeginCrateDefMap { crate_id, crate_name } => {
                 crates_currently_indexing.insert(crate_id, crate_name);
             }
             ParallelPrimeCacheWorkerProgress::EndCrateDefMap { crate_id } => {
+                // Fire ready dependencies.
                 crates_currently_indexing.swap_remove(&crate_id);
                 crate_def_maps_done += 1;
-
-                // Fire ready dependencies.
                 for &dep in &reverse_deps[&crate_id] {
                     let to_be_done = to_be_done_deps.get_mut(&dep).unwrap();
                     *to_be_done -= 1;
                         def_map_work_sender.send((dep, dep_name)).ok();
                     }
                 }
-
                 if crate_def_maps_done == crate_def_maps_total {
                     cb(ParallelPrimeCachesProgress {
                         crates_currently_indexing: vec![],
                         work_type: "Collecting Symbols",
                     });
                 }
-
                 let origin = &crate_id.data(db).origin;
                 if origin.is_lang() {
                     crate_import_maps_total += 1;