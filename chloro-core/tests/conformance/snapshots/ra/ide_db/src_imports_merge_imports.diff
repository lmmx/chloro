COMPARISON DIFF
============================================================

Original size: 35928 bytes
Chloro size:   35453 bytes
Rustfmt size:  36357 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Handle syntactic aspects of merging UseTrees.
+
 use std::cmp::Ordering;
 
 use itertools::{EitherOrBoth, Itertools};
     fn is_tree_allowed(&self, tree: &ast::UseTree) -> bool {
         match self {
             MergeBehavior::Crate | MergeBehavior::One => true,
-            // only simple single segment paths are allowed
             MergeBehavior::Module => {
                 tree.use_tree_list().is_none() && tree.path().map(path_len) <= Some(1)
             }
     Some(lhs)
 }
 
-fn try_merge_trees_mut(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior) -> Option<()> {
+fn try_merge_trees_mut(
+    lhs: &ast::UseTree,
+    rhs: &ast::UseTree,
+    merge: MergeBehavior,
+) -> Option<()> {
     if merge == MergeBehavior::One {
         lhs.wrap_in_tree_list();
         rhs.wrap_in_tree_list();
     // Sorts the use trees similar to rustfmt's algorithm for ordering imports
     // (see `use_tree_cmp` doc).
     use_trees.sort_unstable_by(use_tree_cmp);
-    for rhs_t in rhs
-        .use_tree_list()
-        .into_iter()
-        .flat_map(|list| list.use_trees())
-    {
+    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {
         if !merge.is_tree_allowed(&rhs_t) {
             return None;
         }
                     inner_use_tree_list.syntax(),
                 );
             } else if single_subtree.star_token().is_some() {
-                ted::insert_raw(
-                    Position::last_child_of(use_tree.syntax()),
-                    make::token(T![*]),
-                );
+                ted::insert_raw(Position::last_child_of(use_tree.syntax()), make::token(T![*]));
             } else if let Some(rename) = single_subtree.rename() {
                 ted::insert_raw(
                     Position::last_child_of(use_tree.syntax()),
             _ => break res,
         }
         res = Some((lhs_curr.clone(), rhs_curr.clone()));
-
         match lhs_curr.parent_path().zip(rhs_curr.parent_path()) {
             Some((lhs, rhs)) => {
                 lhs_curr = lhs;
         (None, Some(_)) if !a_is_simple_path => Ordering::Greater,
         (None, Some(_)) => Ordering::Less,
         (Some(a_path), Some(b_path)) => {
-            // cmp_by would be useful for us here but that is currently unstable
-            // cmp doesn't work due the lifetimes on text's return type
-            a_path
-                .segments()
-                .zip_longest(b_path.segments())
-                .find_map(|zipped| match zipped {
+            a_path.segments().zip_longest(b_path.segments()).find_map(|zipped| match zipped {
                     EitherOrBoth::Both(a_segment, b_segment) => {
                         match path_segment_cmp(&a_segment, &b_segment) {
                             Ordering::Equal => None,
                     EitherOrBoth::Left(_) => Some(Ordering::Less),
                     EitherOrBoth::Right(_) if a_is_simple_path => Some(Ordering::Less),
                     EitherOrBoth::Right(_) => Some(Ordering::Greater),
-                })
-                .unwrap_or_else(|| use_tree_cmp_by_tree_list_glob_or_alias(a, b, true))
+                }).unwrap_or_else(
+                || use_tree_cmp_by_tree_list_glob_or_alias(a, b, true),
+            )
         }
     }
 }
         (None, None) => Ordering::Equal,
         (Some(_), None) => Ordering::Greater,
         (None, Some(_)) => Ordering::Less,
-        // self
         (Some(PathSegmentKind::SelfKw), Some(PathSegmentKind::SelfKw)) => Ordering::Equal,
         (Some(PathSegmentKind::SelfKw), _) => Ordering::Less,
         (_, Some(PathSegmentKind::SelfKw)) => Ordering::Greater,
-        // super
         (Some(PathSegmentKind::SuperKw), Some(PathSegmentKind::SuperKw)) => Ordering::Equal,
         (Some(PathSegmentKind::SuperKw), _) => Ordering::Less,
         (_, Some(PathSegmentKind::SuperKw)) => Ordering::Greater,
-        // crate
         (Some(PathSegmentKind::CrateKw), Some(PathSegmentKind::CrateKw)) => Ordering::Equal,
         (Some(PathSegmentKind::CrateKw), _) => Ordering::Less,
         (_, Some(PathSegmentKind::CrateKw)) => Ordering::Greater,
-        // identifiers (everything else is treated as an identifier).
         _ => {
             match (
                 a.name_ref().as_ref().map(ast::NameRef::text),
     match (a.use_tree_list(), b.use_tree_list()) {
         (Some(_), None) => Ordering::Greater,
         (None, Some(_)) => Ordering::Less,
-        (Some(a_list), Some(b_list)) if strict => a_list
-            .use_trees()
-            .zip_longest(b_list.use_trees())
-            .find_map(|zipped| match zipped {
+        (Some(a_list), Some(b_list)) if strict => a_list.use_trees().zip_longest(b_list.use_trees()).find_map(|zipped| match zipped {
                 EitherOrBoth::Both(a_tree, b_tree) => match use_tree_cmp(&a_tree, &b_tree) {
                     Ordering::Equal => None,
                     ord => Some(ord),
                 },
                 EitherOrBoth::Left(_) => Some(Ordering::Greater),
                 EitherOrBoth::Right(_) => Some(Ordering::Less),
-            })
-            .unwrap_or_else(cmp_by_glob_or_alias),
+            }).unwrap_or_else(
+            cmp_by_glob_or_alias,
+        ),
         _ => cmp_by_glob_or_alias(),
     }
 }
 }
 
 fn get_single_subtree(use_tree: &ast::UseTree) -> Option<ast::UseTree> {
-    use_tree
-        .use_tree_list()
-        .and_then(|tree_list| tree_list.use_trees().collect_tuple())
-        .map(|(single_subtree,)| single_subtree)
+    use_tree.use_tree_list().and_then(|tree_list| tree_list.use_trees().collect_tuple()).map(
+        |(single_subtree,)| single_subtree,
+    )
 }
 
 fn remove_subtree_if_only_self(use_tree: &ast::UseTree) {
-    let Some(single_subtree) = get_single_subtree(use_tree) else {
-        return;
-    };
+    let Some(single_subtree) = get_single_subtree(use_tree) else { return };
     match (use_tree.path(), single_subtree.path()) {
         (Some(_), Some(inner)) if path_is_self(&inner) => {
             ted::remove_all_iter(single_subtree.syntax().children_with_tokens());
     }
 }
 
-// Taken from rustfmt
-// https://github.com/rust-lang/rustfmt/blob/0332da01486508710f2a542111e40513bfb215aa/src/sort.rs
 mod version_sort {
     // Original rustfmt code contains some clippy lints.
     // Suppress them to minimize changes from upstream.
     #![allow(clippy::all)]
-
     use std::cmp::Ordering;
-
     use itertools::{EitherOrBoth, Itertools};
-
     struct VersionChunkIter<'a> {
         ident: &'a str,
         start: usize,
     }
-
     impl<'a> VersionChunkIter<'a> {
         pub(crate) fn new(ident: &'a str) -> Self {
             Self { ident, start: 0 }
             let zeros = source.chars().take_while(|c| *c == '0').count();
             let value = source.parse::<usize>().ok()?;
 
-            Some(VersionChunk::Number {
-                value,
-                zeros,
-                source,
-            })
+            Some(VersionChunk::Number { value, zeros, source })
         }
 
         fn parse_str_chunk(
             Some(VersionChunk::Str(source))
         }
     }
-
     impl<'a> Iterator for VersionChunkIter<'a> {
         type Item = VersionChunk<'a>;
 
             self.parse_str_chunk(chars)
         }
     }
-
     /// Represents a chunk in the version-sort algorithm
     #[derive(Debug, PartialEq, Eq)]
     enum VersionChunk<'a> {
             source: &'a str,
         },
     }
-
     /// Determine which side of the version-sort comparison had more leading zeros.
     #[derive(Debug, PartialEq, Eq)]
     enum MoreLeadingZeros {
         Right,
         Equal,
     }
-
     pub(super) fn version_sort(a: &str, b: &str) -> Ordering {
         let iter_a = VersionChunkIter::new(a);
         let iter_b = VersionChunkIter::new(b);
                         }
                     }
                     (
-                        VersionChunk::Number {
-                            value: va,
-                            zeros: lza,
-                            ..
-                        },
-                        VersionChunk::Number {
-                            value: vb,
-                            zeros: lzb,
-                            ..
-                        },
+                        VersionChunk::Number { value: va, zeros: lza, .. },
+                        VersionChunk::Number { value: vb, zeros: lzb, .. },
                     ) => match va.cmp(&vb) {
                         std::cmp::Ordering::Equal => {
                             if lza == lzb {