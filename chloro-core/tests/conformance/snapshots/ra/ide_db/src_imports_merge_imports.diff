COMPARISON DIFF
============================================================

Original size: 35928 bytes
Chloro size:   35989 bytes
Rustfmt size:  36357 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Handle syntactic aspects of merging UseTrees.
+
 use std::cmp::Ordering;
 
 use itertools::{EitherOrBoth, Itertools};
 use syntax::{
     algo,
     ast::{
-        self, edit_in_place::Removable, make, AstNode, HasAttrs, HasName, HasVisibility,
-        PathSegmentKind,
+        self, AstNode, HasAttrs, HasName, HasVisibility, PathSegmentKind, edit_in_place::Removable,
+        make,
     },
     ted::{self, Position},
-    Direction, SyntaxElement,
+    Direction,
+    SyntaxElement,
 };
 
 use crate::syntax_helpers::node_ext::vis_eq;
 }
 
 impl MergeBehavior {
-    fn is_tree_allowed(&self, tree: &ast::UseTree) -> bool {
+    fn is_tree_allowed(
+        &self,
+        tree: &ast::UseTree,
+    ) -> bool {
         match self {
             MergeBehavior::Crate | MergeBehavior::One => true,
             // only simple single segment paths are allowed
     if !eq_attrs(lhs.attrs(), rhs.attrs()) {
         return None;
     }
-
     let lhs = lhs.clone_subtree().clone_for_update();
     let rhs = rhs.clone_subtree().clone_for_update();
     let lhs_tree = lhs.use_tree()?;
     let rhs_tree = rhs.use_tree()?;
     try_merge_trees_mut(&lhs_tree, &rhs_tree, merge_behavior)?;
-
     // Ignore `None` result because normalization should not affect the merge result.
     try_normalize_use_tree_mut(&lhs_tree, merge_behavior.into());
-
     Some(lhs)
 }
 
     let lhs = lhs.clone_subtree().clone_for_update();
     let rhs = rhs.clone_subtree().clone_for_update();
     try_merge_trees_mut(&lhs, &rhs, merge)?;
-
     // Ignore `None` result because normalization should not affect the merge result.
     try_normalize_use_tree_mut(&lhs, merge.into());
-
     Some(lhs)
 }
 
-fn try_merge_trees_mut(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior) -> Option<()> {
+fn try_merge_trees_mut(
+    lhs: &ast::UseTree,
+    rhs: &ast::UseTree,
+    merge: MergeBehavior,
+) -> Option<()> {
     if merge == MergeBehavior::One {
         lhs.wrap_in_tree_list();
         rhs.wrap_in_tree_list();
 
 /// Recursively merges rhs to lhs
 #[must_use]
-fn recursive_merge(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior) -> Option<()> {
+fn recursive_merge(
+    lhs: &ast::UseTree,
+    rhs: &ast::UseTree,
+    merge: MergeBehavior,
+) -> Option<()> {
     let mut use_trees: Vec<ast::UseTree> = lhs
         .use_tree_list()
         .into_iter()
     // Sorts the use trees similar to rustfmt's algorithm for ordering imports
     // (see `use_tree_cmp` doc).
     use_trees.sort_unstable_by(use_tree_cmp);
-    for rhs_t in rhs
-        .use_tree_list()
-        .into_iter()
-        .flat_map(|list| list.use_trees())
-    {
+    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {
         if !merge.is_tree_allowed(&rhs_t) {
             return None;
         }
 /// - `foo::{bar::Qux, bar::{self}}` -> `{foo::bar::{self, Qux}}`
 /// - `foo::bar::{self}` -> `{foo::bar}`
 /// - `foo::bar` -> `{foo::bar}`
-pub fn try_normalize_import(use_item: &ast::Use, style: NormalizationStyle) -> Option<ast::Use> {
+pub fn try_normalize_import(
+    use_item: &ast::Use,
+    style: NormalizationStyle,
+) -> Option<ast::Use> {
     let use_item = use_item.clone_subtree().clone_for_update();
     try_normalize_use_tree_mut(&use_item.use_tree()?, style)?;
     Some(use_item)
 }
 
 /// Recursively normalizes a use tree and its subtrees (if any).
-fn recursive_normalize(use_tree: &ast::UseTree, style: NormalizationStyle) -> Option<()> {
+fn recursive_normalize(
+    use_tree: &ast::UseTree,
+    style: NormalizationStyle,
+) -> Option<()> {
     let use_tree_list = use_tree.use_tree_list()?;
     let merge_subtree_into_parent_tree = |single_subtree: &ast::UseTree| {
         let subtree_is_only_self = single_subtree.path().as_ref().is_some_and(path_is_self);
                     inner_use_tree_list.syntax(),
                 );
             } else if single_subtree.star_token().is_some() {
-                ted::insert_raw(
-                    Position::last_child_of(use_tree.syntax()),
-                    make::token(T![*]),
-                );
+                ted::insert_raw(Position::last_child_of(use_tree.syntax()), make::token(T![*]));
             } else if let Some(rename) = single_subtree.rename() {
                 ted::insert_raw(
                     Position::last_child_of(use_tree.syntax()),
 }
 
 /// Traverses both paths until they differ, returning the common prefix of both.
-pub fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Path)> {
+pub fn common_prefix(
+    lhs: &ast::Path,
+    rhs: &ast::Path,
+) -> Option<(ast::Path, ast::Path)> {
     let mut res = None;
     let mut lhs_curr = lhs.first_qualifier_or_self();
     let mut rhs_curr = rhs.first_qualifier_or_self();
 }
 
 /// Use tree comparison func for binary searching for merging.
-fn use_tree_cmp_bin_search(lhs: &ast::UseTree, rhs: &ast::UseTree) -> Ordering {
+fn use_tree_cmp_bin_search(
+    lhs: &ast::UseTree,
+    rhs: &ast::UseTree,
+) -> Ordering {
     let lhs_is_simple_path = lhs.is_simple_path() && lhs.rename().is_none();
     let rhs_is_simple_path = rhs.is_simple_path() && rhs.rename().is_none();
     match (
 /// Ref:
 ///   - <https://doc.rust-lang.org/style-guide/index.html#sorting>
 ///   - <https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt.html>
-pub(super) fn use_tree_cmp(a: &ast::UseTree, b: &ast::UseTree) -> Ordering {
+pub(super) fn use_tree_cmp(
+    a: &ast::UseTree,
+    b: &ast::UseTree,
+) -> Ordering {
     let a_is_simple_path = a.is_simple_path() && a.rename().is_none();
     let b_is_simple_path = b.is_simple_path() && b.rename().is_none();
     match (a.path(), b.path()) {
     }
 }
 
-fn path_segment_cmp(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {
+fn path_segment_cmp(
+    a: &ast::PathSegment,
+    b: &ast::PathSegment,
+) -> Ordering {
     match (a.kind(), b.kind()) {
         (None, None) => Ordering::Equal,
         (Some(_), None) => Ordering::Greater,
                 ),
         },
     };
-
     match (a.use_tree_list(), b.use_tree_list()) {
         (Some(_), None) => Ordering::Greater,
         (None, Some(_)) => Ordering::Less,
     }
 }
 
-pub fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {
+pub fn eq_visibility(
+    vis0: Option<ast::Visibility>,
+    vis1: Option<ast::Visibility>,
+) -> bool {
     match (vis0, vis1) {
         (None, None) => true,
         (Some(vis0), Some(vis1)) => vis_eq(&vis0, &vis1),
 }
 
 fn remove_subtree_if_only_self(use_tree: &ast::UseTree) {
-    let Some(single_subtree) = get_single_subtree(use_tree) else {
-        return;
-    };
+    let Some(single_subtree) = get_single_subtree(use_tree) else { return };
     match (use_tree.path(), single_subtree.path()) {
         (Some(_), Some(inner)) if path_is_self(&inner) => {
             ted::remove_all_iter(single_subtree.syntax().children_with_tokens());
     }
 }
 
-// Taken from rustfmt
-// https://github.com/rust-lang/rustfmt/blob/0332da01486508710f2a542111e40513bfb215aa/src/sort.rs
 mod version_sort {
     // Original rustfmt code contains some clippy lints.
     // Suppress them to minimize changes from upstream.
     #![allow(clippy::all)]
-
     use std::cmp::Ordering;
-
     use itertools::{EitherOrBoth, Itertools};
-
     struct VersionChunkIter<'a> {
         ident: &'a str,
         start: usize,
     }
-
     impl<'a> VersionChunkIter<'a> {
         pub(crate) fn new(ident: &'a str) -> Self {
             Self { ident, start: 0 }
         ) -> Option<VersionChunk<'a>> {
             let mut end = self.start;
             let mut is_end_of_chunk = false;
-
             while let Some((idx, c)) = chars.next() {
                 end = self.start + idx;
 
                 is_end_of_chunk = true;
                 break;
             }
-
             let source = if is_end_of_chunk {
                 let value = &self.ident[self.start..end];
                 self.start = end;
                 self.start = self.ident.len();
                 value
             };
-
             let zeros = source.chars().take_while(|c| *c == '0').count();
             let value = source.parse::<usize>().ok()?;
-
-            Some(VersionChunk::Number {
-                value,
-                zeros,
-                source,
-            })
+            Some(VersionChunk::Number { value, zeros, source })
         }
 
         fn parse_str_chunk(
         ) -> Option<VersionChunk<'a>> {
             let mut end = self.start;
             let mut is_end_of_chunk = false;
-
             while let Some((idx, c)) = chars.next() {
                 end = self.start + idx;
 
                 is_end_of_chunk = true;
                 break;
             }
-
             let source = if is_end_of_chunk {
                 let value = &self.ident[self.start..end];
                 self.start = end;
                 self.start = self.ident.len();
                 value
             };
-
             Some(VersionChunk::Str(source))
         }
     }
-
     impl<'a> Iterator for VersionChunkIter<'a> {
         type Item = VersionChunk<'a>;
 
         fn next(&mut self) -> Option<Self::Item> {
             let mut chars = self.ident[self.start..].char_indices();
             let (_, next) = chars.next()?;
-
             if next == '_' {
                 self.start = self.start + next.len_utf8();
                 return Some(VersionChunk::Underscore);
             }
-
             if next.is_ascii_digit() {
                 return self.parse_numeric_chunk(chars);
             }
-
             self.parse_str_chunk(chars)
         }
     }
-
     /// Represents a chunk in the version-sort algorithm
     #[derive(Debug, PartialEq, Eq)]
     enum VersionChunk<'a> {
             source: &'a str,
         },
     }
-
     /// Determine which side of the version-sort comparison had more leading zeros.
     #[derive(Debug, PartialEq, Eq)]
     enum MoreLeadingZeros {
         Right,
         Equal,
     }
-
-    pub(super) fn version_sort(a: &str, b: &str) -> Ordering {
+    pub(super) fn version_sort(
+        a: &str,
+        b: &str,
+    ) -> Ordering {
         let iter_a = VersionChunkIter::new(a);
         let iter_b = VersionChunkIter::new(b);
         let mut more_leading_zeros = MoreLeadingZeros::Equal;
-
         for either_or_both in iter_a.zip_longest(iter_b) {
             match either_or_both {
                 EitherOrBoth::Left(_) => return std::cmp::Ordering::Greater,
                         }
                     }
                     (
-                        VersionChunk::Number {
-                            value: va,
-                            zeros: lza,
-                            ..
-                        },
-                        VersionChunk::Number {
-                            value: vb,
-                            zeros: lzb,
-                            ..
-                        },
+                        VersionChunk::Number { value: va, zeros: lza, .. },
+                        VersionChunk::Number { value: vb, zeros: lzb, .. },
                     ) => match va.cmp(&vb) {
                         std::cmp::Ordering::Equal => {
                             if lza == lzb {
                 },
             }
         }
-
         match more_leading_zeros {
             MoreLeadingZeros::Equal => std::cmp::Ordering::Equal,
             MoreLeadingZeros::Left => std::cmp::Ordering::Less,