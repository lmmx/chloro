COMPARISON DIFF
============================================================

Original size: 35928 bytes
Chloro size:   35829 bytes
Rustfmt size:  36357 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Handle syntactic aspects of merging UseTrees.
+
 use std::cmp::Ordering;
 
 use itertools::{EitherOrBoth, Itertools};
     Some(lhs)
 }
 
-fn try_merge_trees_mut(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior) -> Option<()> {
+fn try_merge_trees_mut(
+    lhs: &ast::UseTree,
+    rhs: &ast::UseTree,
+    merge: MergeBehavior,
+) -> Option<()> {
     if merge == MergeBehavior::One {
         lhs.wrap_in_tree_list();
         rhs.wrap_in_tree_list();
     // Sorts the use trees similar to rustfmt's algorithm for ordering imports
     // (see `use_tree_cmp` doc).
     use_trees.sort_unstable_by(use_tree_cmp);
-    for rhs_t in rhs
-        .use_tree_list()
-        .into_iter()
-        .flat_map(|list| list.use_trees())
-    {
+    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {
         if !merge.is_tree_allowed(&rhs_t) {
             return None;
         }
                     inner_use_tree_list.syntax(),
                 );
             } else if single_subtree.star_token().is_some() {
-                ted::insert_raw(
-                    Position::last_child_of(use_tree.syntax()),
-                    make::token(T![*]),
-                );
+                ted::insert_raw(Position::last_child_of(use_tree.syntax()), make::token(T![*]));
             } else if let Some(rename) = single_subtree.rename() {
                 ted::insert_raw(
                     Position::last_child_of(use_tree.syntax()),
     attrs1: impl Iterator<Item = ast::Attr>,
 ) -> bool {
     // FIXME order of attributes should not matter
-    let attrs0 = attrs0
-        .flat_map(|attr| attr.syntax().descendants_with_tokens())
-        .flat_map(|it| it.into_token());
-    let attrs1 = attrs1
-        .flat_map(|attr| attr.syntax().descendants_with_tokens())
-        .flat_map(|it| it.into_token());
+    let attrs0 = attrs0.flat_map(|attr| attr.syntax().descendants_with_tokens()).flat_map(|it| it.into_token());
+    let attrs1 = attrs1.flat_map(|attr| attr.syntax().descendants_with_tokens()).flat_map(|it| it.into_token());
     stdx::iter_eq_by(attrs0, attrs1, |tok, tok2| tok.text() == tok2.text())
 }
 
 }
 
 fn remove_subtree_if_only_self(use_tree: &ast::UseTree) {
-    let Some(single_subtree) = get_single_subtree(use_tree) else {
-        return;
-    };
+    let Some(single_subtree) = get_single_subtree(use_tree) else { return };
     match (use_tree.path(), single_subtree.path()) {
         (Some(_), Some(inner)) if path_is_self(&inner) => {
             ted::remove_all_iter(single_subtree.syntax().children_with_tokens());
     }
 }
 
-// Taken from rustfmt
-// https://github.com/rust-lang/rustfmt/blob/0332da01486508710f2a542111e40513bfb215aa/src/sort.rs
 mod version_sort {
     // Original rustfmt code contains some clippy lints.
     // Suppress them to minimize changes from upstream.
     #![allow(clippy::all)]
-
     use std::cmp::Ordering;
-
     use itertools::{EitherOrBoth, Itertools};
-
     struct VersionChunkIter<'a> {
         ident: &'a str,
         start: usize,
     }
-
     impl<'a> VersionChunkIter<'a> {
         pub(crate) fn new(ident: &'a str) -> Self {
             Self { ident, start: 0 }
             let zeros = source.chars().take_while(|c| *c == '0').count();
             let value = source.parse::<usize>().ok()?;
 
-            Some(VersionChunk::Number {
-                value,
-                zeros,
-                source,
-            })
+            Some(VersionChunk::Number { value, zeros, source })
         }
 
         fn parse_str_chunk(
             Some(VersionChunk::Str(source))
         }
     }
-
     impl<'a> Iterator for VersionChunkIter<'a> {
         type Item = VersionChunk<'a>;
 
             self.parse_str_chunk(chars)
         }
     }
-
     /// Represents a chunk in the version-sort algorithm
     #[derive(Debug, PartialEq, Eq)]
     enum VersionChunk<'a> {
             source: &'a str,
         },
     }
-
     /// Determine which side of the version-sort comparison had more leading zeros.
     #[derive(Debug, PartialEq, Eq)]
     enum MoreLeadingZeros {
         Right,
         Equal,
     }
-
     pub(super) fn version_sort(a: &str, b: &str) -> Ordering {
         let iter_a = VersionChunkIter::new(a);
         let iter_b = VersionChunkIter::new(b);
                         }
                     }
                     (
-                        VersionChunk::Number {
-                            value: va,
-                            zeros: lza,
-                            ..
-                        },
-                        VersionChunk::Number {
-                            value: vb,
-                            zeros: lzb,
-                            ..
-                        },
+                        VersionChunk::Number { value: va, zeros: lza, .. },
+                        VersionChunk::Number { value: vb, zeros: lzb, .. },
                     ) => match va.cmp(&vb) {
                         std::cmp::Ordering::Equal => {
                             if lza == lzb {