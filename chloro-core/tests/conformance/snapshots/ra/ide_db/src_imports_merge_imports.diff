COMPARISON DIFF
============================================================

Original size: 35928 bytes
Chloro size:   35847 bytes
Rustfmt size:  36357 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Handle syntactic aspects of merging UseTrees.
+
 use std::cmp::Ordering;
 
 use itertools::{EitherOrBoth, Itertools};
 use syntax::{
     algo,
     ast::{
-        self, edit_in_place::Removable, make, AstNode, HasAttrs, HasName, HasVisibility,
+        edit_in_place::Removable, make, self, AstNode, HasAttrs, HasName, HasVisibility,
         PathSegmentKind,
     },
     ted::{self, Position},
     if !eq_attrs(lhs.attrs(), rhs.attrs()) {
         return None;
     }
-
     let lhs = lhs.clone_subtree().clone_for_update();
     let rhs = rhs.clone_subtree().clone_for_update();
     let lhs_tree = lhs.use_tree()?;
     let rhs_tree = rhs.use_tree()?;
     try_merge_trees_mut(&lhs_tree, &rhs_tree, merge_behavior)?;
-
     // Ignore `None` result because normalization should not affect the merge result.
     try_normalize_use_tree_mut(&lhs_tree, merge_behavior.into());
-
     Some(lhs)
 }
 
     let lhs = lhs.clone_subtree().clone_for_update();
     let rhs = rhs.clone_subtree().clone_for_update();
     try_merge_trees_mut(&lhs, &rhs, merge)?;
-
     // Ignore `None` result because normalization should not affect the merge result.
     try_normalize_use_tree_mut(&lhs, merge.into());
-
     Some(lhs)
 }
 
-fn try_merge_trees_mut(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior) -> Option<()> {
+fn try_merge_trees_mut(
+    lhs: &ast::UseTree,
+    rhs: &ast::UseTree,
+    merge: MergeBehavior,
+) -> Option<()> {
     if merge == MergeBehavior::One {
         lhs.wrap_in_tree_list();
         rhs.wrap_in_tree_list();
     // Sorts the use trees similar to rustfmt's algorithm for ordering imports
     // (see `use_tree_cmp` doc).
     use_trees.sort_unstable_by(use_tree_cmp);
-    for rhs_t in rhs
-        .use_tree_list()
-        .into_iter()
-        .flat_map(|list| list.use_trees())
-    {
+    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {
         if !merge.is_tree_allowed(&rhs_t) {
             return None;
         }
                     inner_use_tree_list.syntax(),
                 );
             } else if single_subtree.star_token().is_some() {
-                ted::insert_raw(
-                    Position::last_child_of(use_tree.syntax()),
-                    make::token(T![*]),
-                );
+                ted::insert_raw(Position::last_child_of(use_tree.syntax()), make::token(T![*]));
             } else if let Some(rename) = single_subtree.rename() {
                 ted::insert_raw(
                     Position::last_child_of(use_tree.syntax()),
                 ),
         },
     };
-
     match (a.use_tree_list(), b.use_tree_list()) {
         (Some(_), None) => Ordering::Greater,
         (None, Some(_)) => Ordering::Less,
 }
 
 fn remove_subtree_if_only_self(use_tree: &ast::UseTree) {
-    let Some(single_subtree) = get_single_subtree(use_tree) else {
-        return;
-    };
+    let Some(single_subtree) = get_single_subtree(use_tree) else { return };
     match (use_tree.path(), single_subtree.path()) {
         (Some(_), Some(inner)) if path_is_self(&inner) => {
             ted::remove_all_iter(single_subtree.syntax().children_with_tokens());
     }
 }
 
-// Taken from rustfmt
-// https://github.com/rust-lang/rustfmt/blob/0332da01486508710f2a542111e40513bfb215aa/src/sort.rs
 mod version_sort {
     // Original rustfmt code contains some clippy lints.
     // Suppress them to minimize changes from upstream.
     #![allow(clippy::all)]
-
     use std::cmp::Ordering;
-
     use itertools::{EitherOrBoth, Itertools};
-
     struct VersionChunkIter<'a> {
         ident: &'a str,
         start: usize,
     }
-
     impl<'a> VersionChunkIter<'a> {
         pub(crate) fn new(ident: &'a str) -> Self {
             Self { ident, start: 0 }
         ) -> Option<VersionChunk<'a>> {
             let mut end = self.start;
             let mut is_end_of_chunk = false;
-
             while let Some((idx, c)) = chars.next() {
                 end = self.start + idx;
 
                 is_end_of_chunk = true;
                 break;
             }
-
             let source = if is_end_of_chunk {
                 let value = &self.ident[self.start..end];
                 self.start = end;
                 self.start = self.ident.len();
                 value
             };
-
             let zeros = source.chars().take_while(|c| *c == '0').count();
             let value = source.parse::<usize>().ok()?;
-
-            Some(VersionChunk::Number {
-                value,
-                zeros,
-                source,
-            })
+            Some(VersionChunk::Number { value, zeros, source })
         }
 
         fn parse_str_chunk(
         ) -> Option<VersionChunk<'a>> {
             let mut end = self.start;
             let mut is_end_of_chunk = false;
-
             while let Some((idx, c)) = chars.next() {
                 end = self.start + idx;
 
                 is_end_of_chunk = true;
                 break;
             }
-
             let source = if is_end_of_chunk {
                 let value = &self.ident[self.start..end];
                 self.start = end;
                 self.start = self.ident.len();
                 value
             };
-
             Some(VersionChunk::Str(source))
         }
     }
-
     impl<'a> Iterator for VersionChunkIter<'a> {
         type Item = VersionChunk<'a>;
 
         fn next(&mut self) -> Option<Self::Item> {
             let mut chars = self.ident[self.start..].char_indices();
             let (_, next) = chars.next()?;
-
             if next == '_' {
                 self.start = self.start + next.len_utf8();
                 return Some(VersionChunk::Underscore);
             }
-
             if next.is_ascii_digit() {
                 return self.parse_numeric_chunk(chars);
             }
-
             self.parse_str_chunk(chars)
         }
     }
-
     /// Represents a chunk in the version-sort algorithm
     #[derive(Debug, PartialEq, Eq)]
     enum VersionChunk<'a> {
             source: &'a str,
         },
     }
-
     /// Determine which side of the version-sort comparison had more leading zeros.
     #[derive(Debug, PartialEq, Eq)]
     enum MoreLeadingZeros {
         Right,
         Equal,
     }
-
     pub(super) fn version_sort(a: &str, b: &str) -> Ordering {
         let iter_a = VersionChunkIter::new(a);
         let iter_b = VersionChunkIter::new(b);
         let mut more_leading_zeros = MoreLeadingZeros::Equal;
-
         for either_or_both in iter_a.zip_longest(iter_b) {
             match either_or_both {
                 EitherOrBoth::Left(_) => return std::cmp::Ordering::Greater,
                         }
                     }
                     (
-                        VersionChunk::Number {
-                            value: va,
-                            zeros: lza,
-                            ..
-                        },
-                        VersionChunk::Number {
-                            value: vb,
-                            zeros: lzb,
-                            ..
-                        },
+                        VersionChunk::Number { value: va, zeros: lza, .. },
+                        VersionChunk::Number { value: vb, zeros: lzb, .. },
                     ) => match va.cmp(&vb) {
                         std::cmp::Ordering::Equal => {
                             if lza == lzb {
                 },
             }
         }
-
         match more_leading_zeros {
             MoreLeadingZeros::Equal => std::cmp::Ordering::Equal,
             MoreLeadingZeros::Left => std::cmp::Ordering::Less,