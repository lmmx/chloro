COMPARISON DIFF
============================================================

Original size: 58275 bytes
Chloro size:   57729 bytes
Rustfmt size:  58275 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 impl IntoIterator for UsageSearchResult {
     type Item = (EditionedFileId, Vec<FileReference>);
+
     type IntoIter = <FxHashMap<EditionedFileId, Vec<FileReference>> as IntoIterator>::IntoIter;
 
     fn into_iter(self) -> Self::IntoIter {
             FileReferenceNode::FormatStringEntry(_, range) => *range,
         }
     }
+
     pub fn syntax(&self) -> SyntaxElement {
         match self {
             FileReferenceNode::Name(it) => it.syntax().clone().into(),
             FileReferenceNode::FormatStringEntry(it, _) => it.syntax().clone().into(),
         }
     }
+
     pub fn into_name_like(self) -> Option<ast::NameLike> {
         match self {
             FileReferenceNode::Name(it) => Some(ast::NameLike::Name(it)),
             FileReferenceNode::FormatStringEntry(_, _) => None,
         }
     }
+
     pub fn as_name_ref(&self) -> Option<&ast::NameRef> {
         match self {
             FileReferenceNode::NameRef(name_ref) => Some(name_ref),
             _ => None,
         }
     }
+
     pub fn as_lifetime(&self) -> Option<&ast::Lifetime> {
         match self {
             FileReferenceNode::Lifetime(lifetime) => Some(lifetime),
             _ => None,
         }
     }
+
     pub fn text(&self) -> syntax::TokenText<'_> {
         match self {
             FileReferenceNode::NameRef(name_ref) => name_ref.text(),
 
 impl IntoIterator for SearchScope {
     type Item = (EditionedFileId, Option<TextRange>);
+
     type IntoIter = std::collections::hash_map::IntoIter<EditionedFileId, Option<TextRange>>;
 
     fn into_iter(self) -> Self::IntoIter {
         self
     }
 
-    // FIXME: This is just a temporary fix for not handling import aliases like
-    // `use Foo as Bar`. We need to support them in a proper way.
-    // See issue #14079
     pub fn with_rename(mut self, rename: Option<&'a Rename>) -> Self {
         self.rename = rename;
         self
     /// that).
     ///
     /// Returns true if completed the search.
-    // FIXME: Extend this to other cases, such as associated types/consts/enum variants (note those can be `use`d).
     fn short_associated_function_fast_search(
         &self,
         sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
         cov_mark::hit!(short_associated_function_fast_search);
 
         // FIXME: If Rust ever gains the ability to `use Struct::method` we'll also need to account for free
+
         // functions.
         let finder = Finder::new(name.as_bytes());
         // The search for `Self` may return duplicate results with `ContainerName`, so deduplicate them.
                     ModuleSource::BlockExpr(b) => (file_id, Some(b.syntax().text_range())),
                     ModuleSource::SourceFile(_) => (file_id, None),
                 };
-
                 let search_range = if let Some(&range) = search_scope.entries.get(&file_id) {
                     match (range, search_range) {
                         (None, range) | (range, None) => range,
                 } else {
                     return;
                 };
-
                 let file_text = sema.db.file_text(file_id.file_id(self.sema.db));
                 let text = file_text.text(sema.db);
                 let search_range =
                     search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(&**text)));
-
                 let tree = LazyCell::new(|| sema.parse(file_id).syntax().clone());
                 let finder = &Finder::new("self");
-
                 for offset in Self::match_indices(text, finder, search_range) {
-                    for name_ref in Self::find_nodes(sema, "self", file_id, &tree, offset)
-                        .filter_map(ast::NameRef::cast)
-                    {
+                    for name_ref in Self::find_nodes(sema, "self", file_id, &tree, offset).filter_map(
+                        ast::NameRef::cast,
+                    ) {
                         if self.found_self_module_name_ref(&name_ref, sink) {
                             return;
                         }
                     }
                 }
             }
-            _ => {}
+            _ => {},
         }
     }
 
         };
 
         match NameRefClass::classify(self.sema, name_ref) {
-            Some(NameRefClass::Definition(Definition::SelfType(impl_), _))
-                if ty_eq(impl_.self_ty(self.sema.db)) =>
-            {
+            Some(NameRefClass::Definition(Definition::SelfType(impl_), _)) if ty_eq(impl_.self_ty(self.sema.db)) => {
                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());
                 let reference = FileReference {
                     range,
         sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
     ) -> bool {
         match NameRefClass::classify(self.sema, name_ref) {
-            Some(NameRefClass::Definition(def, _))
-                if self.def == def
-                    // is our def a trait assoc item? then we want to find all assoc items from trait impls of our trait
-                    || matches!(self.assoc_item_container, Some(hir::AssocItemContainer::Trait(_)))
-                        && convert_to_def_in_trait(self.sema.db, def) == self.def =>
-            {
+            Some(NameRefClass::Definition(def, _)) if self.def == def || matches!(self.assoc_item_container, Some(hir::AssocItemContainer::Trait(_))) && convert_to_def_in_trait(self.sema.db, def) == self.def => {
                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());
                 let reference = FileReference {
                     range,
             }
             // FIXME: special case type aliases, we can't filter between impl and trait defs here as we lack the substitutions
             // so we always resolve all assoc type aliases to both their trait def and impl defs
-            Some(NameRefClass::Definition(def, _))
-                if self.assoc_item_container.is_some()
+            Some(NameRefClass::Definition(def, _)) if self.assoc_item_container.is_some()
                     && matches!(self.def, Definition::TypeAlias(_))
                     && convert_to_def_in_trait(self.sema.db, def)
-                        == convert_to_def_in_trait(self.sema.db, self.def) =>
-            {
+                        == convert_to_def_in_trait(self.sema.db, self.def) => {
                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());
                 let reference = FileReference {
                     range,
                 adt_subst: _,
             }) => {
                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());
-
                 let field = Definition::Field(field);
                 let local = Definition::Local(local);
                 let access = match self.def {
         sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
     ) -> bool {
         match NameClass::classify(self.sema, name) {
-            Some(NameClass::PatFieldShorthand { local_def: _, field_ref, adt_subst: _ })
-                if matches!(
+            Some(NameClass::PatFieldShorthand { local_def: _, field_ref, adt_subst: _ }) if matches!(
                     self.def, Definition::Field(_) if Definition::Field(field_ref) == self.def
-                ) =>
-            {
+                ) => {
                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());
                 let reference = FileReference {
                     range,
     }
 }
 
-fn def_to_ty<'db>(sema: &Semantics<'db, RootDatabase>, def: &Definition) -> Option<hir::Type<'db>> {
+fn def_to_ty<'db>(
+    sema: &Semantics<'db, RootDatabase>,
+    def: &Definition,
+) -> Option<hir::Type<'db>> {
     match def {
         Definition::Adt(adt) => Some(adt.ty(sema.db)),
         Definition::TypeAlias(it) => Some(it.ty(sema.db)),