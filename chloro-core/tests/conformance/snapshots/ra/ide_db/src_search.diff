COMPARISON DIFF
============================================================

Original size: 58275 bytes
Chloro size:   57970 bytes
Rustfmt size:  58275 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::{RootQueryDb, SourceDatabase};
 use either::Either;
 use hir::{
-    Adt, AsAssocItem, DefWithBody, EditionedFileId, FileRange, FileRangeWrapper, HasAttrs,
+    sym, Adt, AsAssocItem, DefWithBody, EditionedFileId, FileRange, FileRangeWrapper, HasAttrs,
     HasContainer, HasSource, InFile, InFileWrapper, InRealFile, InlineAsmOperand, ItemContainer,
-    ModuleSource, PathResolution, Semantics, Visibility, sym,
+    ModuleSource, PathResolution, Semantics, Visibility,
 };
 use memchr::memmem::Finder;
 use parser::SyntaxKind;
 use rustc_hash::{FxHashMap, FxHashSet};
 use salsa::Database;
 use syntax::{
-    AstNode, AstToken, SmolStr, SyntaxElement, SyntaxNode, TextRange, TextSize, ToSmolStr,
     ast::{self, HasName, Rename},
     match_ast,
+    AstNode,
+    AstToken,
+    SmolStr,
+    SyntaxElement,
+    SyntaxNode,
+    TextRange,
+    TextSize,
+    ToSmolStr,
 };
 use triomphe::Arc;
 
 use crate::{
-    RootDatabase,
     defs::{Definition, NameClass, NameRefClass},
     traits::{as_trait_assoc_def, convert_to_def_in_trait},
+    RootDatabase,
 };
 
 #[derive(Debug, Default, Clone)]
 
 impl IntoIterator for UsageSearchResult {
     type Item = (EditionedFileId, Vec<FileReference>);
+
     type IntoIter = <FxHashMap<EditionedFileId, Vec<FileReference>> as IntoIterator>::IntoIter;
 
     fn into_iter(self) -> Self::IntoIter {
             FileReferenceNode::FormatStringEntry(_, range) => *range,
         }
     }
+
     pub fn syntax(&self) -> SyntaxElement {
         match self {
             FileReferenceNode::Name(it) => it.syntax().clone().into(),
             FileReferenceNode::FormatStringEntry(it, _) => it.syntax().clone().into(),
         }
     }
+
     pub fn into_name_like(self) -> Option<ast::NameLike> {
         match self {
             FileReferenceNode::Name(it) => Some(ast::NameLike::Name(it)),
             FileReferenceNode::FormatStringEntry(_, _) => None,
         }
     }
+
     pub fn as_name_ref(&self) -> Option<&ast::NameRef> {
         match self {
             FileReferenceNode::NameRef(name_ref) => Some(name_ref),
             _ => None,
         }
     }
+
     pub fn as_lifetime(&self) -> Option<&ast::Lifetime> {
         match self {
             FileReferenceNode::Lifetime(lifetime) => Some(lifetime),
             _ => None,
         }
     }
+
     pub fn text(&self) -> syntax::TokenText<'_> {
         match self {
             FileReferenceNode::NameRef(name_ref) => name_ref.text(),
         }
     }
 }
-
-bitflags::bitflags! {
-    #[derive(Copy, Clone, Default, PartialEq, Eq, Hash, Debug)]
-    pub struct ReferenceCategory: u8 {
-        // FIXME: Add this variant and delete the `retain_adt_literal_usages` function.
-        // const CREATE = 1 << 0;
-        const WRITE = 1 << 0;
-        const READ = 1 << 1;
-        const IMPORT = 1 << 2;
-        const TEST = 1 << 3;
-    }
-}
-
+// FIXME: Add this variant and delete the `retain_adt_literal_usages` function.
+// const CREATE = 1 << 0;
 /// Generally, `search_scope` returns files that might contain references for the element.
 /// For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.
 /// In some cases, the location of the references is known to within a `TextRange`,
     /// Build a search scope spanning the entire crate graph of files.
     fn crate_graph(db: &RootDatabase) -> SearchScope {
         let mut entries = FxHashMap::default();
-
         let all_crates = db.all_crates();
         for &krate in all_crates.iter() {
             let crate_data = krate.data(db);
     }
 
     /// Build a search scope spanning all the reverse dependencies of the given crate.
-    fn reverse_dependencies(db: &RootDatabase, of: hir::Crate) -> SearchScope {
+    fn reverse_dependencies(
+        db: &RootDatabase,
+        of: hir::Crate,
+    ) -> SearchScope {
         let mut entries = FxHashMap::default();
         for rev_dep in of.transitive_reverse_dependencies(db) {
             let root_file = rev_dep.root_file(db);
     }
 
     /// Build a search scope spanning the given crate.
-    fn krate(db: &RootDatabase, of: hir::Crate) -> SearchScope {
+    fn krate(
+        db: &RootDatabase,
+        of: hir::Crate,
+    ) -> SearchScope {
         let root_file = of.root_file(db);
-
         let source_root_id = db.file_source_root(root_file).source_root_id(db);
         let source_root = db.source_root(source_root_id).source_root(db);
         SearchScope {
     }
 
     /// Build a search scope spanning the given module and all its submodules.
-    pub fn module_and_children(db: &RootDatabase, module: hir::Module) -> SearchScope {
+    pub fn module_and_children(
+        db: &RootDatabase,
+        module: hir::Module,
+    ) -> SearchScope {
         let mut entries = FxHashMap::default();
-
         let (file_id, range) = {
             let InFile { file_id, value } = module.definition_source_range(db);
             if let Some(InRealFile { file_id, value: call_source }) = file_id.original_call_node(db)
             }
         };
         entries.entry(file_id).or_insert(range);
-
         let mut to_visit: Vec<_> = module.children(db).collect();
         while let Some(module) = to_visit.pop() {
             if let Some(file_id) = module.as_source_file_id(db) {
         SearchScope::new(files.iter().map(|f| (*f, None)).collect())
     }
 
-    pub fn intersection(&self, other: &SearchScope) -> SearchScope {
+    pub fn intersection(
+        &self,
+        other: &SearchScope,
+    ) -> SearchScope {
         let (mut small, mut large) = (&self.entries, &other.entries);
         if small.len() > large.len() {
             mem::swap(&mut small, &mut large)
         }
-
         let intersect_ranges =
             |r1: Option<TextRange>, r2: Option<TextRange>| -> Option<Option<TextRange>> {
                 match (r1, r2) {
                 Some((file_id, r))
             })
             .collect();
-
         SearchScope::new(res)
     }
 }
 
 impl IntoIterator for SearchScope {
     type Item = (EditionedFileId, Option<TextRange>);
+
     type IntoIter = std::collections::hash_map::IntoIter<EditionedFileId, Option<TextRange>>;
 
     fn into_iter(self) -> Self::IntoIter {
 }
 
 impl Definition {
-    fn search_scope(&self, db: &RootDatabase) -> SearchScope {
+    fn search_scope(
+        &self,
+        db: &RootDatabase,
+    ) -> SearchScope {
         let _p = tracing::info_span!("search_scope").entered();
-
         if let Definition::BuiltinType(_) = self {
             return SearchScope::crate_graph(db);
         }
-
         // def is crate root
         if let &Definition::Module(module) = self
             && module.is_crate_root()
         {
             return SearchScope::reverse_dependencies(db, module.krate());
         }
-
         let module = match self.module(db) {
             Some(it) => it,
             None => return SearchScope::empty(),
         };
         let InFile { file_id, value: module_source } = module.definition_source(db);
         let file_id = file_id.original_file(db);
-
         if let Definition::Local(var) = self {
             let def = match var.parent(db) {
                 DefWithBody::Function(f) => f.source(db).map(|src| src.syntax().cloned()),
                 None => SearchScope::single_file(file_id),
             };
         }
-
         if let Definition::InlineAsmOperand(op) = self {
             let def = match op.parent(db) {
                 DefWithBody::Function(f) => f.source(db).map(|src| src.syntax().cloned()),
                 None => SearchScope::single_file(file_id),
             };
         }
-
         if let Definition::SelfType(impl_) = self {
             return match impl_.source(db).map(|src| src.syntax().cloned()) {
                 Some(def) => SearchScope::file_range(
                 None => SearchScope::single_file(file_id),
             };
         }
-
         if let Definition::GenericParam(hir::GenericParam::LifetimeParam(param)) = self {
             let def = match param.parent(db) {
                 hir::GenericDef::Function(it) => it.source(db).map(|src| src.syntax().cloned()),
                 None => SearchScope::single_file(file_id),
             };
         }
-
         if let Definition::Macro(macro_def) = self {
             return match macro_def.kind(db) {
                 hir::MacroKind::Declarative => {
                 }
             };
         }
-
         if let Definition::DeriveHelper(_) = self {
             return SearchScope::reverse_dependencies(db, module.krate());
         }
-
         if let Some(vis) = self.visibility(db) {
             return match vis {
                 Visibility::Module(module, _) => {
                 Visibility::Public => SearchScope::reverse_dependencies(db, module.krate()),
             };
         }
-
         let range = match module_source {
             ModuleSource::Module(m) => Some(m.syntax().text_range()),
             ModuleSource::BlockExpr(b) => Some(b.syntax().text_range()),
         }
     }
 
-    pub fn usages<'a>(self, sema: &'a Semantics<'_, RootDatabase>) -> FindUsages<'a> {
+    pub fn usages<'a>(
+        self,
+        sema: &'a Semantics<'_, RootDatabase>,
+    ) -> FindUsages<'a> {
         FindUsages {
             def: self,
             rename: None,
     }
 
     /// Limit the search to a given [`SearchScope`].
-    pub fn in_scope(self, scope: &'a SearchScope) -> Self {
+    pub fn in_scope(
+        self,
+        scope: &'a SearchScope,
+    ) -> Self {
         self.set_scope(Some(scope))
     }
 
     /// Limit the search to a given [`SearchScope`].
-    pub fn set_scope(mut self, scope: Option<&'a SearchScope>) -> Self {
+    pub fn set_scope(
+        mut self,
+        scope: Option<&'a SearchScope>,
+    ) -> Self {
         assert!(self.scope.is_none());
         self.scope = scope;
         self
     }
 
-    // FIXME: This is just a temporary fix for not handling import aliases like
-    // `use Foo as Bar`. We need to support them in a proper way.
-    // See issue #14079
-    pub fn with_rename(mut self, rename: Option<&'a Rename>) -> Self {
+    pub fn with_rename(
+        mut self,
+        rename: Option<&'a Rename>,
+    ) -> Self {
         self.rename = rename;
         self
     }
     /// that).
     ///
     /// Returns true if completed the search.
-    // FIXME: Extend this to other cases, such as associated types/consts/enum variants (note those can be `use`d).
     fn short_associated_function_fast_search(
         &self,
         sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
         if self.scope.is_some() {
             return false;
         }
-
         let _p = tracing::info_span!("short_associated_function_fast_search").entered();
-
         let container = (|| {
             let Definition::Function(function) = self.def else {
                 return None;
         let Some(container) = container else {
             return false;
         };
-
         fn has_any_name(node: &SyntaxNode, mut predicate: impl FnMut(&str) -> bool) -> bool {
             node.descendants().any(|node| {
                 match_ast! {
                 }
             })
         }
-
         // This is a fixpoint algorithm with O(number of aliases), but most types have no or few aliases,
         // so this should stay fast.
         //
 
             Some((completed, is_possibly_self))
         }
-
         fn search(
             this: &FindUsages<'_>,
             finder: &Finder<'_>,
                 }
             }
         }
-
         let Some((container_possible_aliases, is_possibly_self)) =
             collect_possible_aliases(self.sema, container)
         else {
             return false;
         };
-
         cov_mark::hit!(short_associated_function_fast_search);
-
         // FIXME: If Rust ever gains the ability to `use Struct::method` we'll also need to account for free
         // functions.
         let finder = Finder::new(name.as_bytes());
                 sink,
             )
         });
-
         true
     }
 
-    pub fn search(&self, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool) {
+    pub fn search(
+        &self,
+        sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
+    ) {
         let _p = tracing::info_span!("FindUsages:search").entered();
         let sema = self.sema;
-
         let search_scope = {
             // FIXME: Is the trait scope needed for trait impl assoc items?
             let base =
                 Some(scope) => base.intersection(scope),
             }
         };
-
         let name = match (self.rename, self.def) {
             (Some(rename), _) => {
                 if rename.underscore_token().is_some() {
             Some(s) => s.as_str(),
             None => return,
         };
-
         // FIXME: This should probably depend on the number of the results (specifically, the number of false results).
         if name.len() <= 7 && self.short_associated_function_fast_search(sink, &search_scope, name)
         {
             return;
         }
-
         let finder = &Finder::new(name);
         let include_self_kw_refs =
             self.include_self_kw_refs.as_ref().map(|ty| (ty, Finder::new("Self")));
                 }
             }
         }
-
         // Search for `super` and `crate` resolving to our module
         if let Definition::Module(module) = self.def {
             let scope =
                 }
             }
         }
-
         // search for module `self` references in our module's definition source
         match self.def {
             Definition::Module(module) if self.search_self_mod => {
             (None, None) => ty == *self_ty,
             _ => false,
         };
-
         match NameRefClass::classify(self.sema, name_ref) {
             Some(NameRefClass::Definition(Definition::SelfType(impl_), _))
                 if ty_eq(impl_.self_ty(self.sema.db)) =>
     }
 }
 
-fn def_to_ty<'db>(sema: &Semantics<'db, RootDatabase>, def: &Definition) -> Option<hir::Type<'db>> {
+fn def_to_ty<'db>(
+    sema: &Semantics<'db, RootDatabase>,
+    def: &Definition,
+) -> Option<hir::Type<'db>> {
     match def {
         Definition::Adt(adt) => Some(adt.ty(sema.db)),
         Definition::TypeAlias(it) => Some(it.ty(sema.db)),
         if is_name_ref_in_test(sema, r) {
             result |= ReferenceCategory::TEST;
         }
-
         // Only Locals and Fields have accesses for now.
         if !matches!(def, Definition::Local(_) | Definition::Field(_)) {
             if is_name_ref_in_import(r) {
             }
             return result;
         }
-
         let mode = r.syntax().ancestors().find_map(|node| {
             match_ast! {
                 match node {
                 }
             }
         }).unwrap_or(ReferenceCategory::READ);
-
         result | mode
     }
 }
         .is_some_and(|it| it.kind() == SyntaxKind::USE_TREE)
 }
 
-fn is_name_ref_in_test(sema: &Semantics<'_, RootDatabase>, name_ref: &ast::NameRef) -> bool {
+fn is_name_ref_in_test(
+    sema: &Semantics<'_, RootDatabase>,
+    name_ref: &ast::NameRef,
+) -> bool {
     name_ref.syntax().ancestors().any(|node| match ast::Fn::cast(node) {
         Some(it) => sema.to_def(&it).is_some_and(|func| func.is_test(sema.db)),
         None => false,