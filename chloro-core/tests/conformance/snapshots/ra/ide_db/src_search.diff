COMPARISON DIFF
============================================================

Original size: 58275 bytes
Chloro size:   58075 bytes
Rustfmt size:  58275 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::{RootQueryDb, SourceDatabase};
 use either::Either;
 use hir::{
-    Adt, AsAssocItem, DefWithBody, EditionedFileId, FileRange, FileRangeWrapper, HasAttrs,
+    sym, Adt, AsAssocItem, DefWithBody, EditionedFileId, FileRange, FileRangeWrapper, HasAttrs,
     HasContainer, HasSource, InFile, InFileWrapper, InRealFile, InlineAsmOperand, ItemContainer,
-    ModuleSource, PathResolution, Semantics, Visibility, sym,
+    ModuleSource, PathResolution, Semantics, Visibility,
 };
 use memchr::memmem::Finder;
 use parser::SyntaxKind;
 use rustc_hash::{FxHashMap, FxHashSet};
 use salsa::Database;
 use syntax::{
-    AstNode, AstToken, SmolStr, SyntaxElement, SyntaxNode, TextRange, TextSize, ToSmolStr,
     ast::{self, HasName, Rename},
-    match_ast,
+    match_ast, AstNode, AstToken, SmolStr, SyntaxElement, SyntaxNode, TextRange, TextSize,
+    ToSmolStr,
 };
 use triomphe::Arc;
 
 use crate::{
-    RootDatabase,
     defs::{Definition, NameClass, NameRefClass},
     traits::{as_trait_assoc_def, convert_to_def_in_trait},
+    RootDatabase,
 };
 
 #[derive(Debug, Default, Clone)]
 
 impl IntoIterator for UsageSearchResult {
     type Item = (EditionedFileId, Vec<FileReference>);
+
     type IntoIter = <FxHashMap<EditionedFileId, Vec<FileReference>> as IntoIterator>::IntoIter;
 
     fn into_iter(self) -> Self::IntoIter {
             FileReferenceNode::FormatStringEntry(_, range) => *range,
         }
     }
+
     pub fn syntax(&self) -> SyntaxElement {
         match self {
             FileReferenceNode::Name(it) => it.syntax().clone().into(),
             FileReferenceNode::FormatStringEntry(it, _) => it.syntax().clone().into(),
         }
     }
+
     pub fn into_name_like(self) -> Option<ast::NameLike> {
         match self {
             FileReferenceNode::Name(it) => Some(ast::NameLike::Name(it)),
             FileReferenceNode::FormatStringEntry(_, _) => None,
         }
     }
+
     pub fn as_name_ref(&self) -> Option<&ast::NameRef> {
         match self {
             FileReferenceNode::NameRef(name_ref) => Some(name_ref),
             _ => None,
         }
     }
+
     pub fn as_lifetime(&self) -> Option<&ast::Lifetime> {
         match self {
             FileReferenceNode::Lifetime(lifetime) => Some(lifetime),
             _ => None,
         }
     }
+
     pub fn text(&self) -> syntax::TokenText<'_> {
         match self {
             FileReferenceNode::NameRef(name_ref) => name_ref.text(),
             mem::swap(&mut small, &mut large)
         }
 
-        let intersect_ranges =
-            |r1: Option<TextRange>, r2: Option<TextRange>| -> Option<Option<TextRange>> {
+        let intersect_ranges = |r1: Option<TextRange>, r2: Option<TextRange>| -> Option<Option<TextRange>> {
                 match (r1, r2) {
                     (None, r) | (r, None) => Some(r),
                     (Some(r1), Some(r2)) => r1.intersect(r2).map(Some),
 
 impl IntoIterator for SearchScope {
     type Item = (EditionedFileId, Option<TextRange>);
+
     type IntoIter = std::collections::hash_map::IntoIter<EditionedFileId, Option<TextRange>>;
 
     fn into_iter(self) -> Self::IntoIter {
         self
     }
 
-    // FIXME: This is just a temporary fix for not handling import aliases like
-    // `use Foo as Bar`. We need to support them in a proper way.
-    // See issue #14079
     pub fn with_rename(mut self, rename: Option<&'a Rename>) -> Self {
         self.rename = rename;
         self
 
     pub fn all(self) -> UsageSearchResult {
         let mut res = UsageSearchResult::default();
-        self.search(&mut |file_id, reference| {
+        self
+            .search(&mut |file_id, reference| {
             res.references.entry(file_id).or_default().push(reference);
             false
         });
     /// that).
     ///
     /// Returns true if completed the search.
-    // FIXME: Extend this to other cases, such as associated types/consts/enum variants (note those can be `use`d).
     fn short_associated_function_fast_search(
         &self,
         sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
         cov_mark::hit!(short_associated_function_fast_search);
 
         // FIXME: If Rust ever gains the ability to `use Struct::method` we'll also need to account for free
+
         // functions.
         let finder = Finder::new(name.as_bytes());
         // The search for `Self` may return duplicate results with `ContainerName`, so deduplicate them.
         let mut self_positions = FxHashSet::default();
-        tracing::info_span!("Self_search").in_scope(|| {
+        tracing::info_span!("Self_search")
+            .in_scope(|| {
             search(
                 self,
                 &finder,
                 sink,
             )
         });
-        tracing::info_span!("aliases_search").in_scope(|| {
+        tracing::info_span!("aliases_search")
+            .in_scope(|| {
             search(
                 self,
                 &finder,
         }
 
         let finder = &Finder::new(name);
-        let include_self_kw_refs =
-            self.include_self_kw_refs.as_ref().map(|ty| (ty, Finder::new("Self")));
+        let include_self_kw_refs = self.include_self_kw_refs.as_ref().map(|ty| (ty, Finder::new("Self")));
         for (text, file_id, search_range) in Self::scope_files(sema.db, &search_scope) {
             let tree = LazyCell::new(move || sema.parse(file_id).syntax().clone());
 
     }
 }
 
-fn def_to_ty<'db>(sema: &Semantics<'db, RootDatabase>, def: &Definition) -> Option<hir::Type<'db>> {
+fn def_to_ty<'db>(
+    sema: &Semantics<'db, RootDatabase>,
+    def: &Definition,
+) -> Option<hir::Type<'db>> {
     match def {
         Definition::Adt(adt) => Some(adt.ty(sema.db)),
         Definition::TypeAlias(it) => Some(it.ty(sema.db)),
             return result;
         }
 
-        let mode = r.syntax().ancestors().find_map(|node| {
+        let mode = r
+            .syntax()
+            .ancestors()
+            .find_map(|node| {
             match_ast! {
                 match node {
                     ast::BinExpr(expr) => {
                     _ => None,
                 }
             }
-        }).unwrap_or(ReferenceCategory::READ);
+        })
+            .unwrap_or(ReferenceCategory::READ);
 
         result | mode
     }