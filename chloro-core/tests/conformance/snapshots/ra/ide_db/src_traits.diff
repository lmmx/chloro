COMPARISON DIFF
============================================================

Original size: 8057 bytes
Chloro size:   8052 bytes
Rustfmt size:  8222 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Functionality for obtaining data related to traits from the DB.
 
-use crate::{defs::Definition, RootDatabase};
-use hir::{db::HirDatabase, AsAssocItem, Semantics};
+use hir::{AsAssocItem, Semantics, db::HirDatabase};
 use rustc_hash::FxHashSet;
-use syntax::{ast, AstNode};
+use syntax::{AstNode, ast};
+
+use crate::{RootDatabase, defs::Definition};
 
 /// Given the `impl` block, attempts to find the trait this `impl` corresponds to.
 pub fn resolve_target_trait(
     sema: &Semantics<'_, RootDatabase>,
     impl_def: &ast::Impl,
 ) -> Option<hir::Trait> {
-    let ast_path = impl_def
-        .trait_()
-        .map(|it| it.syntax().clone())
-        .and_then(ast::PathType::cast)?
-        .path()?;
+    let ast_path =
+        impl_def.trait_().map(|it| it.syntax().clone()).and_then(ast::PathType::cast)?.path()?;
 
     match sema.resolve_path(&ast_path) {
         Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def),
         Some(it) => it,
         None => return vec![],
     };
-
     // Names must be unique between constants and functions. However, type aliases
     // may share the same name as a function or constant.
+
     let mut impl_fns_consts = FxHashSet::default();
     let mut impl_type = FxHashSet::default();
     let edition = imp.module(sema.db).krate().edition(sema.db);
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{expect, Expect};
+    use expect_test::{Expect, expect};
     use hir::FilePosition;
     use hir::Semantics;
     use span::Edition;
     use syntax::ast::{self, AstNode};
     use test_fixture::ChangeFixture;
-
     use crate::RootDatabase;
-
     /// Creates analysis from a multi-file fixture, returns positions marked with $0.
     pub(crate) fn position(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let mut database = RootDatabase::default();
         let change_fixture = ChangeFixture::parse(&database, ra_fixture);
         database.apply_change(change_fixture.change);
-        let (file_id, range_or_offset) = change_fixture
-            .file_position
-            .expect("expected a marker ($0)");
+        let (file_id, range_or_offset) =
+            change_fixture.file_position.expect("expected a marker ($0)");
         let offset = range_or_offset.expect_offset();
         (database, FilePosition { file_id, offset })
     }
-
     fn check_trait(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (db, position) = position(ra_fixture);
         let sema = Semantics::new(&db);
 
         let file = sema.parse(position.file_id);
-        let impl_block: ast::Impl = sema
-            .find_node_at_offset_with_descend(file.syntax(), position.offset)
-            .unwrap();
+        let impl_block: ast::Impl =
+            sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();
         let trait_ = crate::traits::resolve_target_trait(&sema, &impl_block);
         let actual = match trait_ {
             Some(trait_) => trait_.name(&db).display(&db, Edition::CURRENT).to_string(),
         };
         expect.assert_eq(&actual);
     }
-
     fn check_missing_assoc(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (db, position) = position(ra_fixture);
         let sema = Semantics::new(&db);
 
         let file = sema.parse(position.file_id);
-        let impl_block: ast::Impl = sema
-            .find_node_at_offset_with_descend(file.syntax(), position.offset)
-            .unwrap();
+        let impl_block: ast::Impl =
+            sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();
         let items = crate::traits::get_missing_assoc_items(&sema, &impl_block);
         let actual = items
             .into_iter()
-            .map(|item| {
-                item.name(&db)
-                    .unwrap()
-                    .display(&db, Edition::CURRENT)
-                    .to_string()
-            })
+            .map(|item| item.name(&db).unwrap().display(&db, Edition::CURRENT).to_string())
             .collect::<Vec<_>>()
             .join("\n");
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn resolve_trait() {
         check_trait(
             expect![[""]],
         );
     }
-
     #[test]
     fn missing_assoc_items() {
         check_missing_assoc(