COMPARISON DIFF
============================================================

Original size: 17943 bytes
Chloro size:   16705 bytes
Rustfmt size:  17943 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     krate.modules(db).into_iter().map(|module| SymbolIndex::module_symbols(db, module)).collect()
 }
 
-// Feature: Workspace Symbol
-//
-// Uses fuzzy-search to find types, modules and functions by name across your
-// project and dependencies. This is **the** most useful feature, which improves code
-// navigation tremendously. It mostly works on top of the built-in LSP
-// functionality, however `#` and `*` symbols can be used to narrow down the
-// search. Specifically,
-//
-// - `Foo` searches for `Foo` type in the current workspace
-// - `foo#` searches for `foo` function in the current workspace
-// - `Foo*` searches for `Foo` type among dependencies, including `stdlib`
-// - `foo#*` searches for `foo` function among dependencies
-//
-// That is, `#` switches from "types" to all symbols, `*` switches from the current
-// workspace to dependencies.
-//
-// Note that filtering does not currently work in VSCode due to the editor never
-// sending the special symbols to the language server. Instead, you can configure
-// the filtering via the `rust-analyzer.workspace.symbol.search.scope` and
-// `rust-analyzer.workspace.symbol.search.kind` settings. Symbols prefixed
-// with `__` are hidden from the search results unless configured otherwise.
-//
-// | Editor  | Shortcut |
-// |---------|-----------|
-// | VS Code | <kbd>Ctrl+T</kbd>
 pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {
     let _p = tracing::info_span!("world_symbols", query = ?query.query).entered();
 
     }
 }
 
-impl Eq for SymbolIndex {}
+impl Eq for SymbolIndex {
+}
 
 impl Hash for SymbolIndex {
     fn hash<H: Hasher>(&self, hasher: &mut H) {
         match self.mode {
             SearchMode::Exact => {
                 let automaton = fst::automaton::Str::new(&self.lowercased);
-
                 for index in indices.iter() {
                     op = op.add(index.map.search(&automaton));
                 }
             }
             SearchMode::Fuzzy => {
                 let automaton = fst::automaton::Subsequence::new(&self.lowercased);
-
                 for index in indices.iter() {
                     op = op.add(index.map.search(&automaton));
                 }
             }
             SearchMode::Prefix => {
                 let automaton = fst::automaton::Str::new(&self.lowercased).starts_with();
-
                 for index in indices.iter() {
                     op = op.add(index.map.search(&automaton));
                 }
 
 #[cfg(test)]
 mod tests {
-
     use expect_test::expect_file;
     use salsa::Setter;
-    use test_fixture::{WORKSPACE, WithFixture};
-
+    use test_fixture::{WithFixture, WORKSPACE};
     use super::*;
-
     #[test]
     fn test_symbol_index_collection() {
         let (db, _) = RootDatabase::with_many_files(
 
         expect_file!["./test_data/test_symbol_index_collection.txt"].assert_debug_eq(&symbols);
     }
-
     #[test]
     fn test_doc_alias() {
         let (db, _) = RootDatabase::with_single_file(
 
         expect_file!["./test_data/test_doc_alias.txt"].assert_debug_eq(&symbols);
     }
-
     #[test]
     fn test_exclude_imports() {
         let (mut db, _) = RootDatabase::with_many_files(