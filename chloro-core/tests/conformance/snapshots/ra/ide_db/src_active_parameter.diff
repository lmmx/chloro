COMPARISON DIFF
============================================================

Original size: 6837 bytes
Chloro size:   6853 bytes
Rustfmt size:  6998 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use parser::T;
 use span::TextSize;
 use syntax::{
-    ast::{self, AstChildren, HasArgList, HasAttrs, HasName},
-    match_ast, AstNode, NodeOrToken, SyntaxToken,
+    ast::{self,
+
+    match_ast, AstChildren, AstNode, HasArgList, HasAttrs, HasName}, NodeOrToken, SyntaxToken,
 };
 
 use crate::RootDatabase;
 
 impl<'db> ActiveParameter<'db> {
     /// Returns information about the call argument this token is part of.
-    pub fn at_token(sema: &Semantics<'db, RootDatabase>, token: SyntaxToken) -> Option<Self> {
+    pub fn at_token(
+        sema: &Semantics<'db, RootDatabase>,
+        token: SyntaxToken,
+    ) -> Option<Self> {
         let (signature, active_parameter) = callable_for_token(sema, token)?;
         Self::from_signature_and_active_parameter(sema, signature, active_parameter)
     }
             return None;
         }
         let param = params.swap_remove(idx);
-        Some(ActiveParameter {
-            ty: param.ty().clone(),
-            src: sema.source(param),
-        })
+        Some(ActiveParameter { ty: param.ty().clone(), src: sema.source(param) })
     }
 
     pub fn ident(&self) -> Option<ast::Name> {
-        self.src
-            .as_ref()
-            .and_then(|param| match param.value.as_ref().right()?.pat()? {
-                ast::Pat::IdentPat(ident) => ident.name(),
-                _ => None,
-            })
+        self.src.as_ref().and_then(|param| match param.value.as_ref().right()?.pat()? {
+            ast::Pat::IdentPat(ident) => ident.name(),
+            _ => None,
+        })
     }
 
     pub fn attrs(&self) -> Option<AstChildren<ast::Attr>> {
-        self.src
-            .as_ref()
-            .and_then(|param| Some(param.value.as_ref().right()?.attrs()))
+        self.src.as_ref().and_then(|param| Some(param.value.as_ref().right()?.attrs()))
     }
 }
 
     let calling_node = parent
         .ancestors()
         .filter_map(ast::CallableExpr::cast)
-        .find(|it| {
-            it.arg_list()
-                .is_some_and(|it| it.syntax().text_range().contains(offset))
-        })?;
-
+        .find(|it| it.arg_list().is_some_and(|it| it.syntax().text_range().contains(offset)))?;
     callable_for_node(sema, &calling_node, offset)
 }
 
     at: TextSize,
 ) -> Option<(hir::Callable<'db>, Option<usize>)> {
     debug_assert!(arg_list.syntax().text_range().contains(at));
-    let callable = arg_list
-        .syntax()
-        .parent()
-        .and_then(ast::CallableExpr::cast)?;
+    let callable = arg_list.syntax().parent().and_then(ast::CallableExpr::cast)?;
     callable_for_node(sema, &callable, at)
 }
 
             _ => return None,
         }
     };
-
     let active_param = generic_arg_list
         .syntax()
         .children_with_tokens()
         .filter(|t| t.kind() == T![,])
         .take_while(|t| t.text_range().start() <= token.text_range().start())
         .count();
-
     let first_arg_is_non_lifetime = generic_arg_list
         .generic_args()
         .next()
         .is_some_and(|arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));
-
     Some((def, active_param, first_arg_is_non_lifetime, variant))
 }