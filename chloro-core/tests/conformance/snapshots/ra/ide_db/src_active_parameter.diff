COMPARISON DIFF
============================================================

Original size: 6837 bytes
Chloro size:   6851 bytes
Rustfmt size:  6998 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
             return None;
         }
         let param = params.swap_remove(idx);
-        Some(ActiveParameter {
-            ty: param.ty().clone(),
-            src: sema.source(param),
-        })
+        Some(ActiveParameter { ty: param.ty().clone(), src: sema.source(param) })
     }
 
     pub fn ident(&self) -> Option<ast::Name> {
-        self.src
-            .as_ref()
-            .and_then(|param| match param.value.as_ref().right()?.pat()? {
-                ast::Pat::IdentPat(ident) => ident.name(),
-                _ => None,
-            })
+        self.src.as_ref().and_then(|param| match param.value.as_ref().right()?.pat()? {
+            ast::Pat::IdentPat(ident) => ident.name(),
+            _ => None,
+        })
     }
 
     pub fn attrs(&self) -> Option<AstChildren<ast::Attr>> {
-        self.src
-            .as_ref()
-            .and_then(|param| Some(param.value.as_ref().right()?.attrs()))
+        self.src.as_ref().and_then(|param| Some(param.value.as_ref().right()?.attrs()))
     }
 }
 
     let calling_node = parent
         .ancestors()
         .filter_map(ast::CallableExpr::cast)
-        .find(|it| {
-            it.arg_list()
-                .is_some_and(|it| it.syntax().text_range().contains(offset))
-        })?;
+        .find(|it| it.arg_list().is_some_and(|it| it.syntax().text_range().contains(offset)))?;
 
     callable_for_node(sema, &calling_node, offset)
 }
     at: TextSize,
 ) -> Option<(hir::Callable<'db>, Option<usize>)> {
     debug_assert!(arg_list.syntax().text_range().contains(at));
-    let callable = arg_list
-        .syntax()
-        .parent()
-        .and_then(ast::CallableExpr::cast)?;
+    let callable = arg_list.syntax().parent().and_then(ast::CallableExpr::cast)?;
     callable_for_node(sema, &callable, at)
 }
 
         ast::CallableExpr::Call(call) => sema.resolve_expr_as_callable(&call.expr()?),
         ast::CallableExpr::MethodCall(call) => sema.resolve_method_call_as_callable(call),
     }?;
-    let active_param = calling_node.arg_list().map(|arg_list| {
+    let active_param = calling_node
+        .arg_list()
+        .map(|arg_list| {
         arg_list
             .syntax()
             .children_with_tokens()