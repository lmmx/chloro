COMPARISON DIFF
============================================================

Original size: 29385 bytes
Chloro size:   29393 bytes
Rustfmt size:  29385 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! The correct behavior in such cases is probably to show a dialog to the user.
 //! Our current behavior is ¯\_(ツ)_/¯.
+
 use std::fmt::{self, Display};
 
-use crate::{
-    source_change::ChangeAnnotation,
-    text_edit::{TextEdit, TextEditBuilder},
-};
 use base_db::AnchoredPathBuf;
 use either::Either;
-use hir::{FieldSource, FileRange, InFile, ModuleSource, Name, Semantics, sym};
+use hir::{sym, FieldSource, FileRange, InFile, ModuleSource, Name, Semantics};
 use span::{Edition, FileId, SyntaxContext};
-use stdx::{TupleExt, never};
+use stdx::{never, TupleExt};
 use syntax::{
-    AstNode, SyntaxKind, T, TextRange,
     ast::{self, HasName},
+    AstNode, SyntaxKind, TextRange, T,
 };
+pub use _bail as bail;
+pub use _format_err as format_err;
 
 use crate::{
-    RootDatabase,
     defs::Definition,
     search::{FileReference, FileReferenceNode},
     source_change::{FileSystemEdit, SourceChange},
     syntax_helpers::node_ext::expr_as_name_ref,
     traits::convert_to_def_in_trait,
+    RootDatabase,
+};
+use crate::{
+    source_change::ChangeAnnotation,
+    text_edit::{TextEdit, TextEditBuilder},
 };
 
 pub type Result<T, E = RenameError> = std::result::Result<T, E>;
     ($fmt:expr) => { RenameError(format!($fmt)) };
     ($fmt:expr, $($arg:tt)+) => { RenameError(format!($fmt, $($arg)+)) }
 }
-pub use _format_err as format_err;
 
 #[macro_export]
 macro_rules! _bail {
     ($($tokens:tt)*) => { return Err(format_err!($($tokens)*)) }
 }
-pub use _bail as bail;
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub enum RenameDefinition {
             Definition::Module(module) => rename_mod(sema, module, new_name),
             Definition::ToolModule(_) => {
                 bail!("Cannot rename a tool module")
-            }
+            },
             Definition::BuiltinType(_) => {
                 bail!("Cannot rename builtin type")
-            }
+            },
             Definition::BuiltinAttr(_) => {
                 bail!("Cannot rename a builtin attr.")
-            }
+            },
             Definition::SelfType(_) => bail!("Cannot rename `Self`"),
             Definition::Macro(mac) => {
                 rename_reference(sema, Definition::Macro(mac), new_name, rename_definition, edition)
-            }
+            },
             def => rename_reference(sema, def, new_name, rename_definition, edition),
         }
     }
                 (SyntaxKind::IDENT, _) => Ok((Name::new_root(new_name), IdentifierKind::Ident)),
                 (T![_], _) => {
                     Ok((Name::new_symbol_root(sym::underscore), IdentifierKind::Underscore))
-                }
+                },
                 (SyntaxKind::LIFETIME_IDENT, _) if new_name != "'static" && new_name != "'_" => {
                     Ok((Name::new_lifetime(new_name), IdentifierKind::Lifetime))
-                }
+                },
                 _ if SyntaxKind::from_keyword(new_name, edition).is_some() => match new_name {
                     "self" => Ok((Name::new_root(new_name), IdentifierKind::LowercaseSelf)),
                     "crate" | "super" | "Self" => {
                         bail!("Invalid name `{}`: cannot rename to a keyword", new_name)
-                    }
+                    },
                     _ => Ok((Name::new_root(new_name), IdentifierKind::Ident)),
                 },
                 (_, Some(syntax_error)) => bail!("Invalid name `{}`: {}", new_name, syntax_error),