COMPARISON DIFF
============================================================

Original size: 29385 bytes
Chloro size:   29430 bytes
Rustfmt size:  29385 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //!
 //! The correct behavior in such cases is probably to show a dialog to the user.
 //! Our current behavior is ¯\_(ツ)_/¯.
+
 use std::fmt::{self, Display};
 
-use crate::{
-    source_change::ChangeAnnotation,
-    text_edit::{TextEdit, TextEditBuilder},
-};
 use base_db::AnchoredPathBuf;
 use either::Either;
 use hir::{FieldSource, FileRange, InFile, ModuleSource, Name, Semantics, sym};
     AstNode, SyntaxKind, T, TextRange,
     ast::{self, HasName},
 };
+pub use _bail as bail;
+pub use _format_err as format_err;
 
 use crate::{
-    RootDatabase,
-    defs::Definition,
-    search::{FileReference, FileReferenceNode},
-    source_change::{FileSystemEdit, SourceChange},
-    syntax_helpers::node_ext::expr_as_name_ref,
-    traits::convert_to_def_in_trait,
+    defs::Definition, search::{FileReference, source_change::{FileSystemEdit,
+    syntax_helpers::node_ext::expr_as_name_ref, traits::convert_to_def_in_trait,
+    FileReferenceNode}, RootDatabase, SourceChange},
+};
+use crate::{
+    source_change::ChangeAnnotation,
+    text_edit::{TextEdit, TextEditBuilder},
 };
 
 pub type Result<T, E = RenameError> = std::result::Result<T, E>;
 pub struct RenameError(pub String);
 
 impl fmt::Display for RenameError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         fmt::Display::fmt(&self.0, f)
     }
 }
     ($fmt:expr) => { RenameError(format!($fmt)) };
     ($fmt:expr, $($arg:tt)+) => { RenameError(format!($fmt, $($arg)+)) }
 }
-pub use _format_err as format_err;
 
 #[macro_export]
 macro_rules! _bail {
     ($($tokens:tt)*) => { return Err(format_err!($($tokens)*)) }
 }
-pub use _bail as bail;
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub enum RenameDefinition {
         } else {
             Edition::LATEST
         };
-
         match *self {
             Definition::Module(module) => rename_mod(sema, module, new_name),
             Definition::ToolModule(_) => {
     /// `Definition`. Note that builtin types can't be
     /// renamed and extern crate names will report its range, though a rename will introduce
     /// an alias instead.
-    pub fn range_for_rename(self, sema: &Semantics<'_, RootDatabase>) -> Option<FileRange> {
+    pub fn range_for_rename(
+        self,
+        sema: &Semantics<'_, RootDatabase>,
+    ) -> Option<FileRange> {
         let syn_ctx_is_root = |(range, ctx): (_, SyntaxContext)| ctx.is_root().then_some(range);
         let res = match self {
             Definition::Macro(mac) => {
             Definition::DeriveHelper(_) => return None,
         };
         return res;
-
         fn name_range<D>(
             def: D,
             sema: &Semantics<'_, RootDatabase>,
     new_name: &str,
 ) -> Result<SourceChange> {
     let mut source_change = SourceChange::default();
-
     if module.is_crate_root() {
         return Ok(source_change);
     }
-
     let InFile { file_id, value: def_source } = module.definition_source(sema.db);
     let edition = file_id.edition(sema.db);
     let (new_name, kind) = IdentifierKind::classify(edition, new_name)?;
             })
         }
     }
-
     if let Some(src) = module.declaration_source(sema.db) {
         let file_id = src.file_id.original_file(sema.db);
         match src.value.name() {
             _ => never!("Module source node is missing a name"),
         }
     }
-
     let def = Definition::Module(module);
     let usages = def.usages(sema).all();
     let ref_edits = usages.iter().map(|(file_id, references)| {
         )
     });
     source_change.extend(ref_edits);
-
     Ok(source_change)
 }
 
     edition: Edition,
 ) -> Result<SourceChange> {
     let (mut new_name, ident_kind) = IdentifierKind::classify(edition, new_name)?;
-
     if matches!(
         def,
         Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)
             }
         }
     }
-
     let def = convert_to_def_in_trait(sema.db, def);
     let usages = def.usages(sema).all();
-
     if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {
         cov_mark::hit!(rename_underscore_multiple);
         bail!("Cannot rename reference to `_` as it is being referenced multiple times");
             edited_ranges.push(range.start());
         }
     }
-
     edit.finish()
 }
 
         edit.insert(ident_pat.syntax().text_range().start(), format!("{new_name}: "));
         return true;
     }
-
     false
 }
 
     if name_ref.super_token().is_some() {
         return true;
     }
-
     if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {
         let rcf_name_ref = record_field.name_ref();
         let rcf_expr = record_field.expr();
 }
 
 impl IdentifierKind {
-    pub fn classify(edition: Edition, new_name: &str) -> Result<(Name, IdentifierKind)> {
+    pub fn classify(
+        edition: Edition,
+        new_name: &str,
+    ) -> Result<(Name, IdentifierKind)> {
         match parser::LexedStr::single_token(edition, new_name) {
             Some(res) => match res {
                 (SyntaxKind::IDENT, _) => Ok((Name::new_root(new_name), IdentifierKind::Ident)),