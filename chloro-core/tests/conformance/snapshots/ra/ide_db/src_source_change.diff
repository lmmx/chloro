COMPARISON DIFF
============================================================

Original size: 21058 bytes
Chloro size:   22067 bytes
Rustfmt size:  21705 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use std::{collections::hash_map::Entry, fmt, iter, mem};
 
-use crate::imports::insert_use::{ImportScope, ImportScopeKind};
-use crate::text_edit::{TextEdit, TextEditBuilder};
-use crate::{assists::Command, syntax_helpers::tree_diff::diff, SnippetCap};
 use base_db::AnchoredPathBuf;
 use itertools::Itertools;
 use macros::UpmapFromRaFixture;
 use stdx::never;
 use syntax::{
     syntax_editor::{SyntaxAnnotation, SyntaxEditor},
-    AstNode, SyntaxElement, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextSize,
+    AstNode,
+    SyntaxElement,
+    SyntaxNode,
+    SyntaxNodePtr,
+    SyntaxToken,
+    TextRange,
+    TextSize,
 };
 
+use crate::imports::insert_use::{ImportScope, ImportScopeKind};
+use crate::text_edit::{TextEdit, TextEditBuilder};
+use crate::{SnippetCap, assists::Command, syntax_helpers::tree_diff::diff};
+
 /// An annotation ID associated with an indel, to describe changes.
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, UpmapFromRaFixture)]
 pub struct ChangeAnnotationId(u32);
 
 impl fmt::Display for ChangeAnnotationId {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         fmt::Display::fmt(&self.0, f)
     }
 }
 }
 
 impl SourceChange {
-    pub fn from_text_edit(file_id: impl Into<FileId>, edit: TextEdit) -> Self {
+    pub fn from_text_edit(
+        file_id: impl Into<FileId>,
+        edit: TextEdit,
+    ) -> Self {
         SourceChange {
             source_file_edits: iter::once((file_id.into(), (edit, None))).collect(),
             ..Default::default()
         }
     }
 
-    pub fn insert_annotation(&mut self, annotation: ChangeAnnotation) -> ChangeAnnotationId {
+    pub fn insert_annotation(
+        &mut self,
+        annotation: ChangeAnnotation,
+    ) -> ChangeAnnotationId {
         let id = ChangeAnnotationId(self.next_annotation_id);
         self.next_annotation_id += 1;
         self.annotations.insert(id, annotation);
 
     /// Inserts a [`TextEdit`] for the given [`FileId`]. This properly handles merging existing
     /// edits for a file if some already exist.
-    pub fn insert_source_edit(&mut self, file_id: impl Into<FileId>, edit: TextEdit) {
+    pub fn insert_source_edit(
+        &mut self,
+        file_id: impl Into<FileId>,
+        edit: TextEdit,
+    ) {
         self.insert_source_and_snippet_edit(file_id.into(), edit, None)
     }
 
         match self.source_file_edits.entry(file_id.into()) {
             Entry::Occupied(mut entry) => {
                 let value = entry.get_mut();
-                never!(
-                    value.0.union(edit).is_err(),
-                    "overlapping edits for same file"
-                );
+                never!(value.0.union(edit).is_err(), "overlapping edits for same file");
                 never!(
                     value.1.is_some() && snippet_edit.is_some(),
                     "overlapping snippet edits for same file"
         }
     }
 
-    pub fn push_file_system_edit(&mut self, edit: FileSystemEdit) {
+    pub fn push_file_system_edit(
+        &mut self,
+        edit: FileSystemEdit,
+    ) {
         self.file_system_edits.push(edit);
     }
 
         self.source_file_edits.get(&file_id)
     }
 
-    pub fn merge(mut self, other: SourceChange) -> SourceChange {
+    pub fn merge(
+        mut self,
+        other: SourceChange,
+    ) -> SourceChange {
         self.extend(other.source_file_edits);
         self.extend(other.file_system_edits);
         self.is_snippet |= other.is_snippet;
 }
 
 impl Extend<(FileId, TextEdit)> for SourceChange {
-    fn extend<T: IntoIterator<Item = (FileId, TextEdit)>>(&mut self, iter: T) {
-        self.extend(
-            iter.into_iter()
-                .map(|(file_id, edit)| (file_id, (edit, None))),
-        )
+    fn extend<T: IntoIterator<Item = (FileId, TextEdit)>>(
+        &mut self,
+        iter: T,
+    ) {
+        self.extend(iter.into_iter().map(|(file_id, edit)| (file_id, (edit, None))))
     }
 }
 
         &mut self,
         iter: T,
     ) {
-        iter.into_iter()
-            .for_each(|(file_id, (edit, snippet_edit))| {
-                self.insert_source_and_snippet_edit(file_id, edit, snippet_edit)
-            });
+        iter.into_iter().for_each(|(file_id, (edit, snippet_edit))| {
+            self.insert_source_and_snippet_edit(file_id, edit, snippet_edit)
+        });
     }
 }
 
 impl Extend<FileSystemEdit> for SourceChange {
-    fn extend<T: IntoIterator<Item = FileSystemEdit>>(&mut self, iter: T) {
-        iter.into_iter()
-            .for_each(|edit| self.push_file_system_edit(edit));
+    fn extend<T: IntoIterator<Item = FileSystemEdit>>(
+        &mut self,
+        iter: T,
+    ) {
+        iter.into_iter().for_each(|edit| self.push_file_system_edit(edit));
     }
 }
 
 impl From<IntMap<FileId, TextEdit>> for SourceChange {
     fn from(source_file_edits: IntMap<FileId, TextEdit>) -> SourceChange {
-        let source_file_edits = source_file_edits
-            .into_iter()
-            .map(|(file_id, edit)| (file_id, (edit, None)))
-            .collect();
+        let source_file_edits =
+            source_file_edits.into_iter().map(|(file_id, edit)| (file_id, (edit, None))).collect();
         SourceChange {
             source_file_edits,
             file_system_edits: Vec::new(),
                 }
             })
             .collect_vec();
-
         snippet_ranges.sort_by_key(|(_, range)| range.start());
-
         // Ensure that none of the ranges overlap
         let disjoint_ranges = snippet_ranges
             .iter()
             .zip(snippet_ranges.iter().skip(1))
             .all(|((_, left), (_, right))| left.end() <= right.start() || left == right);
         stdx::always!(disjoint_ranges);
-
         SnippetEdit(snippet_ranges)
     }
 
     /// Inserts all of the snippets into the given text.
-    pub fn apply(&self, text: &mut String) {
+    pub fn apply(
+        &self,
+        text: &mut String,
+    ) {
         // Start from the back so that we don't have to adjust ranges
         for (index, range) in self.0.iter().rev() {
             if range.is_empty() {
     pub file_id: FileId,
     pub source_change: SourceChange,
     pub command: Option<Command>,
-
     /// Keeps track of all edits performed on each file
     pub file_editors: FxHashMap<FileId, SyntaxEditor>,
     /// Keeps track of which annotations correspond to which snippets
     pub snippet_annotations: Vec<(AnnotationSnippet, SyntaxAnnotation)>,
-
     /// Maps the original, immutable `SyntaxNode` to a `clone_for_update` twin.
     pub mutated_tree: Option<TreeMutator>,
     /// Keeps track of where to place snippets
     pub fn new(immutable: &SyntaxNode) -> TreeMutator {
         let immutable = immutable.ancestors().last().unwrap();
         let mutable_clone = immutable.clone_for_update();
-        TreeMutator {
-            immutable,
-            mutable_clone,
-        }
+        TreeMutator { immutable, mutable_clone }
     }
 
-    pub fn make_mut<N: AstNode>(&self, node: &N) -> N {
+    pub fn make_mut<N: AstNode>(
+        &self,
+        node: &N,
+    ) -> N {
         N::cast(self.make_syntax_mut(node.syntax())).unwrap()
     }
 
-    pub fn make_syntax_mut(&self, node: &SyntaxNode) -> SyntaxNode {
+    pub fn make_syntax_mut(
+        &self,
+        node: &SyntaxNode,
+    ) -> SyntaxNode {
         let ptr = SyntaxNodePtr::new(node);
         ptr.to_node(&self.mutable_clone)
     }
         }
     }
 
-    pub fn edit_file(&mut self, file_id: impl Into<FileId>) {
+    pub fn edit_file(
+        &mut self,
+        file_id: impl Into<FileId>,
+    ) {
         self.commit();
         self.file_id = file_id.into();
     }
 
-    pub fn make_editor(&self, node: &SyntaxNode) -> SyntaxEditor {
+    pub fn make_editor(
+        &self,
+        node: &SyntaxNode,
+    ) -> SyntaxEditor {
         SyntaxEditor::new(node.ancestors().last().unwrap_or_else(|| node.clone()))
     }
 
-    pub fn add_file_edits(&mut self, file_id: impl Into<FileId>, edit: SyntaxEditor) {
+    pub fn add_file_edits(
+        &mut self,
+        file_id: impl Into<FileId>,
+        edit: SyntaxEditor,
+    ) {
         match self.file_editors.entry(file_id.into()) {
             Entry::Occupied(mut entry) => entry.get_mut().merge(edit),
             Entry::Vacant(entry) => {
         }
     }
 
-    pub fn make_placeholder_snippet(&mut self, _cap: SnippetCap) -> SyntaxAnnotation {
+    pub fn make_placeholder_snippet(
+        &mut self,
+        _cap: SnippetCap,
+    ) -> SyntaxAnnotation {
         self.add_snippet_annotation(AnnotationSnippet::Over)
     }
 
-    pub fn make_tabstop_before(&mut self, _cap: SnippetCap) -> SyntaxAnnotation {
+    pub fn make_tabstop_before(
+        &mut self,
+        _cap: SnippetCap,
+    ) -> SyntaxAnnotation {
         self.add_snippet_annotation(AnnotationSnippet::Before)
     }
 
-    pub fn make_tabstop_after(&mut self, _cap: SnippetCap) -> SyntaxAnnotation {
+    pub fn make_tabstop_after(
+        &mut self,
+        _cap: SnippetCap,
+    ) -> SyntaxAnnotation {
         self.add_snippet_annotation(AnnotationSnippet::After)
     }
 
             diff(edit_result.old_root(), edit_result.new_root()).into_text_edit(&mut edit);
             let edit = edit.finish();
 
-            let snippet_edit = if !snippet_edit.is_empty() {
-                Some(SnippetEdit::new(snippet_edit))
-            } else {
-                None
-            };
+            let snippet_edit =
+                if !snippet_edit.is_empty() { Some(SnippetEdit::new(snippet_edit)) } else { None };
 
             if !edit.is_empty() || snippet_edit.is_some() {
-                self.source_change
-                    .insert_source_and_snippet_edit(file_id, edit, snippet_edit);
+                self.source_change.insert_source_and_snippet_edit(file_id, edit, snippet_edit);
             }
         }
-
         // Apply mutable edits
         let snippet_edit = self.snippet_builder.take().map(|builder| {
             SnippetEdit::new(
-                builder
-                    .places
-                    .into_iter()
-                    .flat_map(PlaceSnippet::finalize_position)
-                    .collect(),
+                builder.places.into_iter().flat_map(PlaceSnippet::finalize_position).collect(),
             )
         });
-
         if let Some(tm) = self.mutated_tree.take() {
             diff(&tm.immutable, &tm.mutable_clone).into_text_edit(&mut self.edit);
         }
-
         let edit = mem::take(&mut self.edit).finish();
         if !edit.is_empty() || snippet_edit.is_some() {
-            self.source_change
-                .insert_source_and_snippet_edit(self.file_id, edit, snippet_edit);
+            self.source_change.insert_source_and_snippet_edit(self.file_id, edit, snippet_edit);
         }
     }
 
-    pub fn make_mut<N: AstNode>(&mut self, node: N) -> N {
-        self.mutated_tree
-            .get_or_insert_with(|| TreeMutator::new(node.syntax()))
-            .make_mut(&node)
+    pub fn make_mut<N: AstNode>(
+        &mut self,
+        node: N,
+    ) -> N {
+        self.mutated_tree.get_or_insert_with(|| TreeMutator::new(node.syntax())).make_mut(&node)
     }
 
-    pub fn make_import_scope_mut(&mut self, scope: ImportScope) -> ImportScope {
+    pub fn make_import_scope_mut(
+        &mut self,
+        scope: ImportScope,
+    ) -> ImportScope {
         ImportScope {
             kind: match scope.kind.clone() {
                 ImportScopeKind::File(it) => ImportScopeKind::File(self.make_mut(it)),
                 ImportScopeKind::Module(it) => ImportScopeKind::Module(self.make_mut(it)),
                 ImportScopeKind::Block(it) => ImportScopeKind::Block(self.make_mut(it)),
             },
-            required_cfgs: scope
-                .required_cfgs
-                .iter()
-                .map(|it| self.make_mut(it.clone()))
-                .collect(),
+            required_cfgs: scope.required_cfgs.iter().map(|it| self.make_mut(it.clone())).collect(),
         }
     }
+
     /// Returns a copy of the `node`, suitable for mutation.
     ///
     /// Syntax trees in rust-analyzer are typically immutable, and mutating
     /// The typical pattern for an assist is to find specific nodes in the read
     /// phase, and then get their mutable counterparts using `make_mut` in the
     /// mutable state.
-    pub fn make_syntax_mut(&mut self, node: SyntaxNode) -> SyntaxNode {
-        self.mutated_tree
-            .get_or_insert_with(|| TreeMutator::new(&node))
-            .make_syntax_mut(&node)
+    pub fn make_syntax_mut(
+        &mut self,
+        node: SyntaxNode,
+    ) -> SyntaxNode {
+        self.mutated_tree.get_or_insert_with(|| TreeMutator::new(&node)).make_syntax_mut(&node)
     }
 
     /// Remove specified `range` of text.
-    pub fn delete(&mut self, range: TextRange) {
+    pub fn delete(
+        &mut self,
+        range: TextRange,
+    ) {
         self.edit.delete(range)
     }
+
     /// Append specified `text` at the given `offset`
-    pub fn insert(&mut self, offset: TextSize, text: impl Into<String>) {
+    pub fn insert(
+        &mut self,
+        offset: TextSize,
+        text: impl Into<String>,
+    ) {
         self.edit.insert(offset, text.into())
     }
+
     /// Replaces specified `range` of text with a given string.
-    pub fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {
+    pub fn replace(
+        &mut self,
+        range: TextRange,
+        replace_with: impl Into<String>,
+    ) {
         self.edit.replace(range, replace_with.into())
     }
-    pub fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {
+
+    pub fn replace_ast<N: AstNode>(
+        &mut self,
+        old: N,
+        new: N,
+    ) {
         diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)
     }
-    pub fn create_file(&mut self, dst: AnchoredPathBuf, content: impl Into<String>) {
-        let file_system_edit = FileSystemEdit::CreateFile {
-            dst,
-            initial_contents: content.into(),
-        };
+
+    pub fn create_file(
+        &mut self,
+        dst: AnchoredPathBuf,
+        content: impl Into<String>,
+    ) {
+        let file_system_edit = FileSystemEdit::CreateFile { dst, initial_contents: content.into() };
         self.source_change.push_file_system_edit(file_system_edit);
     }
-    pub fn move_file(&mut self, src: impl Into<FileId>, dst: AnchoredPathBuf) {
-        let file_system_edit = FileSystemEdit::MoveFile {
-            src: src.into(),
-            dst,
-        };
+
+    pub fn move_file(
+        &mut self,
+        src: impl Into<FileId>,
+        dst: AnchoredPathBuf,
+    ) {
+        let file_system_edit = FileSystemEdit::MoveFile { src: src.into(), dst };
         self.source_change.push_file_system_edit(file_system_edit);
     }
 
     }
 
     /// Adds a tabstop snippet to place the cursor before `node`
-    pub fn add_tabstop_before(&mut self, _cap: SnippetCap, node: impl AstNode) {
+    pub fn add_tabstop_before(
+        &mut self,
+        _cap: SnippetCap,
+        node: impl AstNode,
+    ) {
         assert!(node.syntax().parent().is_some());
         self.add_snippet(PlaceSnippet::Before(node.syntax().clone().into()));
     }
 
     /// Adds a tabstop snippet to place the cursor after `node`
-    pub fn add_tabstop_after(&mut self, _cap: SnippetCap, node: impl AstNode) {
+    pub fn add_tabstop_after(
+        &mut self,
+        _cap: SnippetCap,
+        node: impl AstNode,
+    ) {
         assert!(node.syntax().parent().is_some());
         self.add_snippet(PlaceSnippet::After(node.syntax().clone().into()));
     }
 
     /// Adds a tabstop snippet to place the cursor before `token`
-    pub fn add_tabstop_before_token(&mut self, _cap: SnippetCap, token: SyntaxToken) {
+    pub fn add_tabstop_before_token(
+        &mut self,
+        _cap: SnippetCap,
+        token: SyntaxToken,
+    ) {
         assert!(token.parent().is_some());
         self.add_snippet(PlaceSnippet::Before(token.into()));
     }
 
     /// Adds a tabstop snippet to place the cursor after `token`
-    pub fn add_tabstop_after_token(&mut self, _cap: SnippetCap, token: SyntaxToken) {
+    pub fn add_tabstop_after_token(
+        &mut self,
+        _cap: SnippetCap,
+        token: SyntaxToken,
+    ) {
         assert!(token.parent().is_some());
         self.add_snippet(PlaceSnippet::After(token.into()));
     }
 
     /// Adds a snippet to move the cursor selected over `node`
-    pub fn add_placeholder_snippet(&mut self, _cap: SnippetCap, node: impl AstNode) {
+    pub fn add_placeholder_snippet(
+        &mut self,
+        _cap: SnippetCap,
+        node: impl AstNode,
+    ) {
         assert!(node.syntax().parent().is_some());
         self.add_snippet(PlaceSnippet::Over(node.syntax().clone().into()))
     }
 
     /// Adds a snippet to move the cursor selected over `token`
-    pub fn add_placeholder_snippet_token(&mut self, _cap: SnippetCap, token: SyntaxToken) {
+    pub fn add_placeholder_snippet_token(
+        &mut self,
+        _cap: SnippetCap,
+        token: SyntaxToken,
+    ) {
         assert!(token.parent().is_some());
         self.add_snippet(PlaceSnippet::Over(token.into()))
     }
     ///
     /// This allows for renaming newly generated items without having to go
     /// through a separate rename step.
-    pub fn add_placeholder_snippet_group(&mut self, _cap: SnippetCap, nodes: Vec<SyntaxNode>) {
+    pub fn add_placeholder_snippet_group(
+        &mut self,
+        _cap: SnippetCap,
+        nodes: Vec<SyntaxNode>,
+    ) {
         assert!(nodes.iter().all(|node| node.parent().is_some()));
         self.add_snippet(PlaceSnippet::OverGroup(
             nodes.into_iter().map(|node| node.into()).collect(),
         ))
     }
 
-    fn add_snippet(&mut self, snippet: PlaceSnippet) {
-        let snippet_builder = self
-            .snippet_builder
-            .get_or_insert(SnippetBuilder { places: vec![] });
+    fn add_snippet(
+        &mut self,
+        snippet: PlaceSnippet,
+    ) {
+        let snippet_builder = self.snippet_builder.get_or_insert(SnippetBuilder { places: vec![] });
         snippet_builder.places.push(snippet);
         self.source_change.is_snippet = true;
     }
 
-    fn add_snippet_annotation(&mut self, kind: AnnotationSnippet) -> SyntaxAnnotation {
+    fn add_snippet_annotation(
+        &mut self,
+        kind: AnnotationSnippet,
+    ) -> SyntaxAnnotation {
         let annotation = SyntaxAnnotation::default();
         self.snippet_annotations.push((kind, annotation));
         self.source_change.is_snippet = true;
 
     pub fn finish(mut self) -> SourceChange {
         self.commit();
-
         // Only one file can have snippet edits
-        stdx::never!(self
-            .source_change
-            .source_file_edits
-            .iter()
-            .filter(|(_, (_, snippet_edit))| snippet_edit.is_some())
-            .at_most_one()
-            .is_err());
-
+        stdx::never!(
+            self.source_change
+                .source_file_edits
+                .iter()
+                .filter(|(_, (_, snippet_edit))| snippet_edit.is_some())
+                .at_most_one()
+                .is_err()
+        );
         mem::take(&mut self.source_change)
     }
 }
             PlaceSnippet::After(it) => vec![Snippet::Tabstop(it.text_range().end())],
             PlaceSnippet::Over(it) => vec![Snippet::Placeholder(it.text_range())],
             PlaceSnippet::OverGroup(it) => {
-                vec![Snippet::PlaceholderGroup(
-                    it.into_iter().map(|it| it.text_range()).collect(),
-                )]
+                vec![Snippet::PlaceholderGroup(it.into_iter().map(|it| it.text_range()).collect())]
             }
         }
     }