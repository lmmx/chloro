COMPARISON DIFF
============================================================

Original size: 18749 bytes
Chloro size:   18791 bytes
Rustfmt size:  18749 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Various helper functions to work with SyntaxNodes.
+
 use std::ops::ControlFlow;
 
 use itertools::Itertools;
 use parser::T;
 use span::Edition;
 use syntax::{
-    AstNode, AstToken, Preorder, RustLanguage, WalkEvent,
-    ast::{self, HasLoopBody, MacroCall, PathSegmentKind, VisibilityKind},
+    ast::{self, HasLoopBody, MacroCall, PathSegmentKind, VisibilityKind}, AstNode, AstToken,
+    Preorder, RustLanguage, WalkEvent,
 };
 
 pub fn expr_as_name_ref(expr: &ast::Expr) -> Option<ast::NameRef> {
 
 pub fn full_path_of_name_ref(name_ref: &ast::NameRef) -> Option<ast::Path> {
     let mut ancestors = name_ref.syntax().ancestors();
-    let _ = ancestors.next()?; // skip self
-    let _ = ancestors.next().filter(|it| ast::PathSegment::can_cast(it.kind()))?; // skip self
+    let _ = ancestors.next()?;
+    // skip self
+    let _ = ancestors.next().filter(|it| ast::PathSegment::can_cast(it.kind()))?;
+    // skip self
     ancestors.take_while(|it| ast::Path::can_cast(it.kind())).last().and_then(ast::Path::cast)
 }
 
 }
 
 /// Preorder walk all the expression's child expressions.
-pub fn walk_expr(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Expr)) {
+pub fn walk_expr(
+    expr: &ast::Expr,
+    cb: &mut dyn FnMut(ast::Expr),
+) {
     preorder_expr(expr, &mut |ev| {
         if let WalkEvent::Enter(expr) = ev {
             cb(expr);
 /// Preorder walk all the expression's child expressions preserving events.
 /// If the callback returns true on an [`WalkEvent::Enter`], the subtree of the expression will be skipped.
 /// Note that the subtree may already be skipped due to the context analysis this function does.
-pub fn preorder_expr(start: &ast::Expr, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {
+pub fn preorder_expr(
+    start: &ast::Expr,
+    cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool,
+) {
     preorder_expr_with_ctx_checker(start, &is_closure_or_blk_with_modif, cb);
 }
 
 }
 
 /// Preorder walk all the expression's child patterns.
-pub fn walk_patterns_in_expr(start: &ast::Expr, cb: &mut dyn FnMut(ast::Pat)) {
+pub fn walk_patterns_in_expr(
+    start: &ast::Expr,
+    cb: &mut dyn FnMut(ast::Pat),
+) {
     let mut preorder = start.syntax().preorder();
     while let Some(event) = preorder.next() {
         let node = match event {
 }
 
 /// Preorder walk all the type's sub types.
-// FIXME: Make the control flow more proper
-pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type) -> bool) {
+pub fn walk_ty(
+    ty: &ast::Type,
+    cb: &mut dyn FnMut(ast::Type) -> bool,
+) {
     let mut preorder = ty.syntax().preorder();
     while let Some(event) = preorder.next() {
         let node = match event {
     }
 }
 
-pub fn vis_eq(this: &ast::Visibility, other: &ast::Visibility) -> bool {
+pub fn vis_eq(
+    this: &ast::Visibility,
+    other: &ast::Visibility,
+) -> bool {
     match (this.kind(), other.kind()) {
         (VisibilityKind::In(this), VisibilityKind::In(other)) => {
             stdx::iter_eq_by(this.segments(), other.segments(), |lhs, rhs| {
 /// Does not walk into `break` or `return` expressions.
 /// Note that modifying the tree while iterating it will cause undefined iteration which might
 /// potentially results in an out of bounds panic.
-pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {
+pub fn for_each_tail_expr(
+    expr: &ast::Expr,
+    cb: &mut dyn FnMut(&ast::Expr),
+) {
     let walk_loop = |cb: &mut dyn FnMut(&ast::Expr), label, body: Option<ast::BlockExpr>| {
         for_each_break_expr(label, body.and_then(|it| it.stmt_list()), &mut |b| {
             cb(&ast::Expr::BreakExpr(b))
     }
 }
 
-pub fn eq_label_lt(lt1: &Option<ast::Lifetime>, lt2: &Option<ast::Lifetime>) -> bool {
+pub fn eq_label_lt(
+    lt1: &Option<ast::Lifetime>,
+    lt2: &Option<ast::Lifetime>,
+) -> bool {
     lt1.as_ref().zip(lt2.as_ref()).is_some_and(|(lt, lbl)| lt.text() == lbl.text())
 }
 