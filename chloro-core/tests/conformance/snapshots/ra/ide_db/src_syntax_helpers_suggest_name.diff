COMPARISON DIFF
============================================================

Original size: 26548 bytes
Chloro size:   26484 bytes
Rustfmt size:  26702 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 /// Identifier names that won't be suggested, ever
 ///
 /// **NOTE**: they all must be snake lower case
-const USELESS_NAMES: &[&str] = &[
-    "new", "default", "option", "some", "none", "ok", "err", "str", "string", "from", "into",
-];
+const USELESS_NAMES: &[&str] = &["new", "default", "option", "some", "none", "ok", "err", "str", "string", "from", "into"];
 
 const USELESS_NAME_PREFIXES: &[&str] = &["from_", "with_", "into_"];
 
     /// # Examples
     /// `a1b2c3` -> `a1b2c`
     fn split_numeric_suffix(name: &str) -> (&str, Option<usize>) {
-        let pos = name
-            .rfind(|c: char| !c.is_numeric())
-            .expect("Name cannot be empty or all-numeric");
+        let pos =
+            name.rfind(|c: char| !c.is_numeric()).expect("Name cannot be empty or all-numeric");
         let (prefix, suffix) = name.split_at(pos + 1);
         (prefix, suffix.parse().ok())
     }
         return None;
     }
 
-    if USELESS_NAME_PREFIXES
-        .iter()
-        .any(|prefix| name.starts_with(prefix))
-    {
+    if USELESS_NAME_PREFIXES.iter().any(|prefix| name.starts_with(prefix)) {
         return None;
     }
 
 mod tests {
     use hir::FileRange;
     use test_fixture::WithFixture;
-
     use super::*;
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expected: &str) {
         let (db, file_id, range_or_offset) = RootDatabase::with_range_or_offset(ra_fixture);
-        let frange = FileRange {
-            file_id,
-            range: range_or_offset.into(),
-        };
+        let frange = FileRange { file_id, range: range_or_offset.into() };
         let sema = Semantics::new(&db);
 
         let source_file = sema.parse(frange.file_id);
 
         let element = source_file.syntax().covering_element(frange.range);
-        let expr = element
-            .ancestors()
-            .find_map(ast::Expr::cast)
-            .expect("selection is not an expression");
+        let expr =
+            element.ancestors().find_map(ast::Expr::cast).expect("selection is not an expression");
         assert_eq!(
             expr.syntax().text_range(),
             frange.range,
             "selection is not an expression(yet contained in one)"
         );
-        let name = hir::attach_db(sema.db, || {
-            NameGenerator::default().for_variable(&expr, &sema)
-        });
+        let name = hir::attach_db(sema.db, || NameGenerator::default().for_variable(&expr, &sema));
         assert_eq!(&name, expected);
     }
-
     #[test]
     fn no_args() {
         check(r#"fn foo() { $0bar()$0 }"#, "bar");
         check(r#"fn foo() { $0bar.frobnicate()$0 }"#, "frobnicate");
     }
-
     #[test]
     fn single_arg() {
         check(r#"fn foo() { $0bar(1)$0 }"#, "bar");
     }
-
     #[test]
     fn many_args() {
         check(r#"fn foo() { $0bar(1, 2, 3)$0 }"#, "bar");
     }
-
     #[test]
     fn path() {
         check(r#"fn foo() { $0i32::bar(1, 2, 3)$0 }"#, "bar");
     }
-
     #[test]
     fn generic_params() {
         check(r#"fn foo() { $0bar::<i32>(1, 2, 3)$0 }"#, "bar");
-        check(
-            r#"fn foo() { $0bar.frobnicate::<i32, u32>()$0 }"#,
-            "frobnicate",
-        );
+        check(r#"fn foo() { $0bar.frobnicate::<i32, u32>()$0 }"#, "frobnicate");
     }
-
     #[test]
     fn to_name() {
         check(
             "config",
         );
     }
-
     #[test]
     fn plain_func() {
         check(
             "n",
         );
     }
-
     #[test]
     fn mut_param() {
         check(
             "n",
         );
     }
-
     #[test]
     fn func_does_not_exist() {
         check(r#"fn foo() { bar($01$0, 2) }"#, "var_name");
     }
-
     #[test]
     fn unnamed_param() {
         check(
             "var_name",
         );
     }
-
     #[test]
     fn tuple_pat() {
         check(
             "var_name",
         );
     }
-
     #[test]
     fn ref_pat() {
         check(
             "n",
         );
     }
-
     #[test]
     fn box_pat() {
         check(
             "n",
         );
     }
-
     #[test]
     fn param_out_of_index() {
         check(
             "var_name",
         );
     }
-
     #[test]
     fn generic_param_resolved() {
         check(
             "n",
         );
     }
-
     #[test]
     fn generic_param_unresolved() {
         check(
             "n",
         );
     }
-
     #[test]
     fn method() {
         check(
             "n",
         );
     }
-
     #[test]
     fn method_on_impl_trait() {
         check(
             "n",
         );
     }
-
     #[test]
     fn method_ufcs() {
         check(
             "n",
         );
     }
-
     #[test]
     fn method_self() {
         check(
             "s",
         );
     }
-
     #[test]
     fn method_self_named() {
         check(
             "strukt",
         );
     }
-
     #[test]
     fn i32() {
         check(r#"fn foo() { let _: i32 = $01$0; }"#, "var_name");
     }
-
     #[test]
     fn u64() {
         check(r#"fn foo() { let _: u64 = $01$0; }"#, "var_name");
     }
-
     #[test]
     fn bool() {
         check(r#"fn foo() { let _: bool = $0true$0; }"#, "var_name");
     }
-
     #[test]
     fn struct_unit() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn struct_unit_to_snake() {
         check(
             "seed_state",
         );
     }
-
     #[test]
     fn struct_single_arg() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn struct_with_fields() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn enum_() {
         check(
             "kind",
         );
     }
-
     #[test]
     fn enum_generic_resolved() {
         check(
             "kind",
         );
     }
-
     #[test]
     fn enum_generic_unresolved() {
         check(
             "kind",
         );
     }
-
     #[test]
     fn dyn_trait() {
         check(
             "dyn_handler",
         );
     }
-
     #[test]
     fn impl_trait() {
         check(
             "static_handler",
         );
     }
-
     #[test]
     fn impl_trait_plus_clone() {
         check(
             "static_handler",
         );
     }
-
     #[test]
     fn impl_trait_plus_lifetime() {
         check(
             "static_handler",
         );
     }
-
     #[test]
     fn impl_trait_plus_trait() {
         check(
             "bar",
         );
     }
-
     #[test]
     fn ref_value() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn box_value() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn box_generic() {
         check(
             "bar",
         );
     }
-
     #[test]
     fn option_value() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn result_value() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn arc_value() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn rc_value() {
         check(
             "seed",
         );
     }
-
     #[test]
     fn vec_value() {
         check(
             "seeds",
         );
     }
-
     #[test]
     fn vec_value_ends_with_s() {
         check(
             "items",
         );
     }
-
     #[test]
     fn vecdeque_value() {
         check(
             "seeds",
         );
     }
-
     #[test]
     fn slice_value() {
         check(
             "seeds",
         );
     }
-
     #[test]
     fn ref_call() {
         check(
             "bar",
         );
     }
-
     #[test]
     fn name_to_string() {
         check(
             "name",
         );
     }
-
     #[test]
     fn nested_useless_method() {
         check(
             "name",
         );
     }
-
     #[test]
     fn struct_field_name() {
         check(
             "some_field",
         );
     }
-
     #[test]
     fn from_and_to_func() {
         check(
             "bar",
         );
     }
-
     #[test]
     fn useless_name_prefix() {
         check(
             "bar",
         );
     }
-
     #[test]
     fn conflicts_with_existing_names() {
         let mut generator = NameGenerator::default();