COMPARISON DIFF
============================================================

Original size: 18130 bytes
Chloro size:   18058 bytes
Rustfmt size:  18477 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use smallvec::SmallVec;
 use span::{TextRange, TextSize};
 use syntax::{
-    ast::{self, IsString},
     AstToken, SmolStr,
+    ast::{self, IsString},
 };
 
 use crate::{
-    active_parameter::ActiveParameter, documentation::Documentation, range_mapper::RangeMapper,
-    search::ReferenceCategory, MiniCore, RootDatabase, SymbolKind,
+    MiniCore, RootDatabase, SymbolKind, active_parameter::ActiveParameter,
+    documentation::Documentation, range_mapper::RangeMapper, search::ReferenceCategory,
 };
 
 pub use span::FileId;
                 .map(|(file_id, range)| (file_id.file_id(&db), range))
                 .collect();
             (db, files, fixture.sysroot_files)
-        })
-        .map_err(|error| {
+        }).map_err(|error| {
             tracing::error!(
                 "cannot crate the crate graph: {}\nCrate graph:\n{}\n",
                 if let Some(&s) = error.downcast_ref::<&'static str>() {
         let combined_offset = self.mapper.map_offset_down(inside_literal_range)?;
         // There is usually a small number of files, so a linear search is smaller and faster.
         let (_, &(file_id, file_line)) =
-            self.tmp_file_ids
-                .iter()
-                .enumerate()
-                .find(|&(idx, &(_, file_line))| {
-                    let file_start = self.line_offsets[file_line];
-                    let file_end = self
-                        .tmp_file_ids
-                        .get(idx + 1)
-                        .map(|&(_, next_file_line)| self.line_offsets[next_file_line])
-                        .unwrap_or_else(|| self.combined_len);
-                    TextRange::new(file_start, file_end).contains(combined_offset)
-                })?;
+            self.tmp_file_ids.iter().enumerate().find(|&(idx, &(_, file_line))| {
+                let file_start = self.line_offsets[file_line];
+                let file_end = self
+                    .tmp_file_ids
+                    .get(idx + 1)
+                    .map(|&(_, next_file_line)| self.line_offsets[next_file_line])
+                    .unwrap_or_else(|| self.combined_len);
+                TextRange::new(file_start, file_end).contains(combined_offset)
+            })?;
         let file_line_offset = self.line_offsets[file_line];
         let file_offset = combined_offset - file_line_offset;
         Some((file_id, file_offset))
     }
 
     pub fn map_offset_up(&self, virtual_file: FileId, offset: TextSize) -> Option<TextSize> {
-        self.map_range_up(virtual_file, TextRange::empty(offset))
-            .next()
-            .map(|range| range.start())
+        self.map_range_up(virtual_file, TextRange::empty(offset)).next().map(|range| range.start())
     }
 
     pub fn is_sysroot_file(&self, file_id: FileId) -> bool {
     }
 }
 
-pub trait UpmapFromRaFixture: Sized {
+pub trait UpmapFromRaFixture {
     fn upmap_from_ra_fixture(
         self,
         analysis: &RaFixtureAnalysis,
     }
     let result = collection
         .into_iter()
-        .filter_map(|item| {
-            item.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)
-                .ok()
-        })
+        .filter_map(|item| item.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id).ok())
         .collect::<Collection>();
     if result.is_empty() {
         // The collection was emptied by the upmapping - all items errored, therefore mark it as erroring as well.
 }
 
 #[allow(clippy::disallowed_types)]
-impl<K: UpmapFromRaFixture + Hash + Eq, V: UpmapFromRaFixture, S: BuildHasher + Default>
-    UpmapFromRaFixture for std::collections::HashMap<K, V, S>
-{
+impl<K: UpmapFromRaFixture + Hash + Eq, V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture for std::collections::HashMap<K, V, S> {
     fn upmap_from_ra_fixture(
         self,
         analysis: &RaFixtureAnalysis,
     }
 }
 
-// A map of `FileId`s is treated as associating the ranges in the values with the keys.
 #[allow(clippy::disallowed_types)]
-impl<V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture
-    for std::collections::HashMap<FileId, V, S>
-{
+impl<V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture for std::collections::HashMap<FileId, V, S> {
     fn upmap_from_ra_fixture(
         self,
         analysis: &RaFixtureAnalysis,
             .filter_map(|(virtual_file_id, value)| {
                 Some((
                     real_file_id,
-                    value
-                        .upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)
-                        .ok()?,
+                    value.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id).ok()?,
                 ))
             })
             .collect::<std::collections::HashMap<_, _, _>>();
         impl_tuple!( $($rest,)* );
     };
 }
+
 impl_tuple!(A, B, C, D, E,);
 
 impl UpmapFromRaFixture for TextSize {
         virtual_file_id: FileId,
         _real_file_id: FileId,
     ) -> Result<Self, ()> {
-        analysis
-            .map_range_up(virtual_file_id, self)
-            .next()
-            .ok_or(())
+        analysis.map_range_up(virtual_file_id, self).next().ok_or(())
     }
 }
 
 //         Ok(real_file_id)
 //     }
 // }
-
 impl UpmapFromRaFixture for FilePositionWrapper<FileId> {
     fn upmap_from_ra_fixture(
         self,
     ) -> Result<Self, ()> {
         Ok(FilePositionWrapper {
             file_id: real_file_id,
-            offset: self
-                .offset
-                .upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
+            offset: self.offset.upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
         })
     }
 }
     ) -> Result<Self, ()> {
         Ok(FileRangeWrapper {
             file_id: real_file_id,
-            range: self
-                .range
-                .upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
+            range: self.range.upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
         })
     }
 }