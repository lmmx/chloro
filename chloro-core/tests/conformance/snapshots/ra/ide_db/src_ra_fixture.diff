COMPARISON DIFF
============================================================

Original size: 18130 bytes
Chloro size:   17988 bytes
Rustfmt size:  18477 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Working with the fixtures in r-a tests, and providing IDE services for them.
 
 use std::hash::{BuildHasher, Hash};
 
 use hir::{CfgExpr, FilePositionWrapper, FileRangeWrapper, Semantics, Symbol};
 use smallvec::SmallVec;
+pub use span::FileId;
 use span::{TextRange, TextSize};
 use syntax::{
     ast::{self, IsString},
     search::ReferenceCategory, MiniCore, RootDatabase, SymbolKind,
 };
 
-pub use span::FileId;
-
 impl RootDatabase {
     fn from_ra_fixture(
         text: &str,
         }
 
         let active_parameter = ActiveParameter::at_token(sema, expanded.syntax().clone())?;
-        let has_rust_fixture_attr = active_parameter.attrs().is_some_and(|attrs| {
+        let has_rust_fixture_attr = active_parameter
+            .attrs()
+            .is_some_and(|attrs| {
             attrs.filter_map(|attr| attr.as_simple_path()).any(|path| {
                 path.segments()
                     .zip(["rust_analyzer", "rust_fixture"])
         let mut mapper = RangeMapper::default();
 
         // This is used for the `Injector`, to resolve precise location in the string literal,
+
         // which will then be used to resolve precise location in the enclosing file.
         let mut offset_with_indent = TextSize::new(0);
         // This is used to resolve the location relative to the virtual file into a location
 
         let combined = mapper.take_text();
         let combined_len = TextSize::of(&combined);
-        let (analysis, tmp_file_ids, sysroot_files) =
-            RootDatabase::from_ra_fixture(&combined, minicore).ok()?;
+        let (analysis, tmp_file_ids, sysroot_files) = RootDatabase::from_ra_fixture(&combined, minicore).ok()?;
 
         // We use a `Vec` because we know the `FileId`s will always be close.
         let mut virtual_file_id_to_line = Vec::new();
         let inside_literal_range = self.literal.map_offset_down(offset)?;
         let combined_offset = self.mapper.map_offset_down(inside_literal_range)?;
         // There is usually a small number of files, so a linear search is smaller and faster.
-        let (_, &(file_id, file_line)) =
-            self.tmp_file_ids
-                .iter()
-                .enumerate()
-                .find(|&(idx, &(_, file_line))| {
-                    let file_start = self.line_offsets[file_line];
-                    let file_end = self
-                        .tmp_file_ids
-                        .get(idx + 1)
-                        .map(|&(_, next_file_line)| self.line_offsets[next_file_line])
-                        .unwrap_or_else(|| self.combined_len);
-                    TextRange::new(file_start, file_end).contains(combined_offset)
-                })?;
+        let (_, &(file_id, file_line)) = self.tmp_file_ids.iter().enumerate().find(|&(idx, &(_, file_line))| {
+                let file_start = self.line_offsets[file_line];
+                let file_end = self
+                    .tmp_file_ids
+                    .get(idx + 1)
+                    .map(|&(_, next_file_line)| self.line_offsets[next_file_line])
+                    .unwrap_or_else(|| self.combined_len);
+                TextRange::new(file_start, file_end).contains(combined_offset)
+            })?;
         let file_line_offset = self.line_offsets[file_line];
         let file_offset = combined_offset - file_line_offset;
         Some((file_id, file_offset))
     }
 
     pub fn map_offset_up(&self, virtual_file: FileId, offset: TextSize) -> Option<TextSize> {
-        self.map_range_up(virtual_file, TextRange::empty(offset))
-            .next()
-            .map(|range| range.start())
+        self.map_range_up(virtual_file, TextRange::empty(offset)).next().map(|range| range.start())
     }
 
     pub fn is_sysroot_file(&self, file_id: FileId) -> bool {
     }
 }
 
-pub trait UpmapFromRaFixture: Sized {
+pub trait UpmapFromRaFixture {
     fn upmap_from_ra_fixture(
         self,
         analysis: &RaFixtureAnalysis,
     }
     let result = collection
         .into_iter()
-        .filter_map(|item| {
-            item.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)
-                .ok()
-        })
-        .collect::<Collection>();
+        .filter_map(|item| item.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id).ok())
+        .collect();
     if result.is_empty() {
         // The collection was emptied by the upmapping - all items errored, therefore mark it as erroring as well.
         Err(())
 }
 
 #[allow(clippy::disallowed_types)]
-impl<K: UpmapFromRaFixture + Hash + Eq, V: UpmapFromRaFixture, S: BuildHasher + Default>
-    UpmapFromRaFixture for std::collections::HashMap<K, V, S>
-{
+impl<K: UpmapFromRaFixture + Hash + Eq, V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture for std::collections::HashMap<K, V, S> {
     fn upmap_from_ra_fixture(
         self,
         analysis: &RaFixtureAnalysis,
     }
 }
 
-// A map of `FileId`s is treated as associating the ranges in the values with the keys.
 #[allow(clippy::disallowed_types)]
-impl<V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture
-    for std::collections::HashMap<FileId, V, S>
-{
+impl<V: UpmapFromRaFixture, S: BuildHasher + Default> UpmapFromRaFixture for std::collections::HashMap<FileId, V, S> {
     fn upmap_from_ra_fixture(
         self,
         analysis: &RaFixtureAnalysis,
             .filter_map(|(virtual_file_id, value)| {
                 Some((
                     real_file_id,
-                    value
-                        .upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id)
-                        .ok()?,
+                    value.upmap_from_ra_fixture(analysis, virtual_file_id, real_file_id).ok()?,
                 ))
             })
-            .collect::<std::collections::HashMap<_, _, _>>();
-        if result.is_empty() {
-            Err(())
-        } else {
-            Ok(result)
-        }
+            .collect();
+        if result.is_empty() { Err(()) } else { Ok(result) }
     }
 }
 
         impl_tuple!( $($rest,)* );
     };
 }
+
 impl_tuple!(A, B, C, D, E,);
 
 impl UpmapFromRaFixture for TextSize {
         virtual_file_id: FileId,
         _real_file_id: FileId,
     ) -> Result<Self, ()> {
-        analysis
-            .map_range_up(virtual_file_id, self)
-            .next()
-            .ok_or(())
+        analysis.map_range_up(virtual_file_id, self).next().ok_or(())
     }
 }
 
 // Deliberately do not implement that, as it's easy to get things misbehave and be treated with the wrong FileId:
-//
-// impl UpmapFromRaFixture for FileId {
-//     fn upmap_from_ra_fixture(
-//         self,
-//         _analysis: &RaFixtureAnalysis,
-//         _virtual_file_id: FileId,
-//         real_file_id: FileId,
-//     ) -> Result<Self, ()> {
-//         Ok(real_file_id)
-//     }
-// }
 
+//
+
+// impl UpmapFromRaFixture for FileId {
+
+//     fn upmap_from_ra_fixture(
+
+//         self,
+
+//         _analysis: &RaFixtureAnalysis,
+
+//         _virtual_file_id: FileId,
+
+//         real_file_id: FileId,
+
+//     ) -> Result<Self, ()> {
+
+//         Ok(real_file_id)
+
+//     }
+
+// }
 impl UpmapFromRaFixture for FilePositionWrapper<FileId> {
     fn upmap_from_ra_fixture(
         self,
     ) -> Result<Self, ()> {
         Ok(FilePositionWrapper {
             file_id: real_file_id,
-            offset: self
-                .offset
-                .upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
+            offset: self.offset.upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
         })
     }
 }
     ) -> Result<Self, ()> {
         Ok(FileRangeWrapper {
             file_id: real_file_id,
-            range: self
-                .range
-                .upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
+            range: self.range.upmap_from_ra_fixture(analysis, self.file_id, real_file_id)?,
         })
     }
 }