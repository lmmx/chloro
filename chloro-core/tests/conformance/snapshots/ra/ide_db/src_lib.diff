COMPARISON DIFF
============================================================

Original size: 12405 bytes
Chloro size:   12269 bytes
Rustfmt size:  12539 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This crate defines the core data structure representing IDE state -- `RootDatabase`.
 //!
 //! It is mainly a `HirDatabase` for semantic analysis, plus a `SymbolsDatabase`, for fuzzy search.
 
-extern crate self as ide_db;
 
 mod apply_change;
 
     pub use hir::prettify_macro_expansion;
     pub mod node_ext;
     pub mod suggest_name;
-
     pub use parser::LexedStr;
 }
 
     FilePositionWrapper, FileRangeWrapper,
 };
 use triomphe::Arc;
+pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};
 
 use crate::line_index::LineIndex;
-pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};
 
 pub use ::line_index;
 
-/// `base_db` is normally also needed in places where `ide_db` is used, so this re-export is for convenience.
 pub use base_db::{self, FxIndexMap, FxIndexSet};
 pub use span::{self, FileId};
 
 pub type FilePosition = FilePositionWrapper<FileId>;
+
 pub type FileRange = FileRangeWrapper<FileId>;
 
 #[salsa_macros::db]
     nonce: Nonce,
 }
 
-impl std::panic::RefUnwindSafe for RootDatabase {}
+impl std::panic::RefUnwindSafe for RootDatabase {
+}
 
 #[salsa_macros::db]
-impl salsa::Database for RootDatabase {}
+impl salsa::Database for RootDatabase {
+}
 
 impl Drop for RootDatabase {
     fn drop(&mut self) {
     }
 
     fn nonce_and_revision(&self) -> (Nonce, salsa::Revision) {
-        (
-            self.nonce,
-            salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision(),
-        )
+        (self.nonce, salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision())
     }
 }
 
         // use hir::db as hir_db;
 
         // base_db::FileTextQuery.in_db_mut(self).set_lru_capacity(DEFAULT_FILE_TEXT_LRU_CAP);
+
         // base_db::ParseQuery.in_db_mut(self).set_lru_capacity(
+
         //     lru_capacities
+
         //         .get(stringify!(ParseQuery))
+
         //         .copied()
+
         //         .unwrap_or(base_db::DEFAULT_PARSE_LRU_CAP),
+
         // );
+
         // hir_db::ParseMacroExpansionQuery.in_db_mut(self).set_lru_capacity(
+
         //     lru_capacities
+
         //         .get(stringify!(ParseMacroExpansionQuery))
+
         //         .copied()
+
         //         .unwrap_or(4 * base_db::DEFAULT_PARSE_LRU_CAP),
+
         // );
+
         // hir_db::BorrowckQuery.in_db_mut(self).set_lru_capacity(
+
         //     lru_capacities
+
         //         .get(stringify!(BorrowckQuery))
+
         //         .copied()
+
         //         .unwrap_or(base_db::DEFAULT_BORROWCK_LRU_CAP),
+
         // );
+
         // hir::db::BodyWithSourceMapQuery.in_db_mut(self).set_lru_capacity(2048);
     }
 }
 
 #[query_group::query_group]
-pub trait LineIndexDatabase: base_db::RootQueryDb {
+pub trait LineIndexDatabase {
     #[salsa::invoke_interned(line_index)]
     fn line_index(&self, file_id: FileId) -> Arc<LineIndex>;
 }
 
     pub fn from_token(token: &'a syntax::SyntaxToken) -> Self {
         let kind = token.kind();
-        Ranker {
-            kind,
-            text: token.text(),
-            ident_kind: kind.is_any_identifier(),
-        }
+        Ranker { kind, text: token.text(), ident_kind: kind.is_any_identifier() }
     }
 
     /// A utility function that ranks a token again a given kind and text, returning a number that
         let both_idents = exact_same_kind || (tok_kind.is_any_identifier() && self.ident_kind);
         let same_text = tok.text() == self.text;
         // anything that mapped into a token tree has likely no semantic information
-        let no_tt_parent = tok
-            .parent()
-            .is_some_and(|it| it.kind() != parser::SyntaxKind::TOKEN_TREE);
-        (both_idents as usize)
-            | ((exact_same_kind as usize) << 1)
-            | ((same_text as usize) << 2)
-            | ((no_tt_parent as usize) << 3)
+        let no_tt_parent =
+            tok.parent().is_some_and(|it| it.kind() != parser::SyntaxKind::TOKEN_TREE);
+        (both_idents as usize) | ((exact_same_kind as usize) << 1) | ((same_text as usize) << 2) | ((no_tt_parent as usize) << 3)
     }
 }
 