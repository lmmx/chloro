COMPARISON DIFF
============================================================

Original size: 12405 bytes
Chloro size:   12022 bytes
Rustfmt size:  12539 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This crate defines the core data structure representing IDE state -- `RootDatabase`.
 //!
 //! It is mainly a `HirDatabase` for semantic analysis, plus a `SymbolsDatabase`, for fuzzy search.
 
-extern crate self as ide_db;
+use std::{fmt, mem::ManuallyDrop};
+
+pub use ::line_index;
+use base_db::{
+    CrateGraphBuilder, CratesMap, FileSourceRootInput, FileText, Files, Nonce, RootQueryDb,
+    SourceDatabase, SourceRoot, SourceRootId, SourceRootInput, query_group,
+};
+pub use base_db::{self, FxIndexMap, FxIndexSet};
+use hir::{
+    FilePositionWrapper, FileRangeWrapper,
+    db::{DefDatabase, ExpandDatabase},
+};
+pub use hir::{ChangeWithProcMacros, EditionedFileId};
+pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};
+use salsa::Durability;
+pub use span::{self, FileId};
+use triomphe::Arc;
+
+use crate::line_index::LineIndex;
 
 mod apply_change;
 
 pub mod active_parameter;
+
 pub mod assists;
+
 pub mod defs;
+
 pub mod documentation;
+
 pub mod famous_defs;
+
 pub mod helpers;
+
 pub mod items_locator;
+
 pub mod label;
+
 pub mod path_transform;
+
 pub mod prime_caches;
+
 pub mod ra_fixture;
+
 pub mod range_mapper;
+
 pub mod rename;
+
 pub mod rust_doc;
+
 pub mod search;
+
 pub mod source_change;
+
 pub mod symbol_index;
+
 pub mod text_edit;
+
 pub mod traits;
+
 pub mod ty_filter;
+
 pub mod use_trivial_constructor;
 
 pub mod imports {
     pub use hir::prettify_macro_expansion;
     pub mod node_ext;
     pub mod suggest_name;
-
     pub use parser::LexedStr;
 }
 
-pub use hir::{ChangeWithProcMacros, EditionedFileId};
-use salsa::Durability;
-
-use std::{fmt, mem::ManuallyDrop};
-
-use base_db::{
-    query_group, CrateGraphBuilder, CratesMap, FileSourceRootInput, FileText, Files, Nonce,
-    RootQueryDb, SourceDatabase, SourceRoot, SourceRootId, SourceRootInput,
-};
-use hir::{
-    db::{DefDatabase, ExpandDatabase},
-    FilePositionWrapper, FileRangeWrapper,
-};
-use triomphe::Arc;
-
-use crate::line_index::LineIndex;
-pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};
-
-pub use ::line_index;
-
-/// `base_db` is normally also needed in places where `ide_db` is used, so this re-export is for convenience.
-pub use base_db::{self, FxIndexMap, FxIndexSet};
-pub use span::{self, FileId};
-
 pub type FilePosition = FilePositionWrapper<FileId>;
+
 pub type FileRange = FileRangeWrapper<FileId>;
 
 #[salsa_macros::db]
 pub struct RootDatabase {
-    // FIXME: Revisit this commit now that we migrated to the new salsa, given we store arcs in this
-    // db directly now
-    // We use `ManuallyDrop` here because every codegen unit that contains a
-    // `&RootDatabase -> &dyn OtherDatabase` cast will instantiate its drop glue in the vtable,
-    // which duplicates `Weak::drop` and `Arc::drop` tens of thousands of times, which makes
-    // compile times of all `ide_*` and downstream crates suffer greatly.
     storage: ManuallyDrop<salsa::Storage<Self>>,
     files: Arc<Files>,
     crates_map: Arc<CratesMap>,
     nonce: Nonce,
 }
 
-impl std::panic::RefUnwindSafe for RootDatabase {}
+impl std::panic::RefUnwindSafe for RootDatabase {
+}
 
 #[salsa_macros::db]
-impl salsa::Database for RootDatabase {}
+impl salsa::Database for RootDatabase {
+}
 
 impl Drop for RootDatabase {
     fn drop(&mut self) {
 }
 
 impl fmt::Debug for RootDatabase {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("RootDatabase").finish()
     }
 }
 
 #[salsa_macros::db]
 impl SourceDatabase for RootDatabase {
-    fn file_text(&self, file_id: vfs::FileId) -> FileText {
+    fn file_text(
+        &self,
+        file_id: vfs::FileId,
+    ) -> FileText {
         self.files.file_text(file_id)
     }
 
-    fn set_file_text(&mut self, file_id: vfs::FileId, text: &str) {
+    fn set_file_text(
+        &mut self,
+        file_id: vfs::FileId,
+        text: &str,
+    ) {
         let files = Arc::clone(&self.files);
         files.set_file_text(self, file_id, text);
     }
     }
 
     /// Source root of the file.
-    fn source_root(&self, source_root_id: SourceRootId) -> SourceRootInput {
+    fn source_root(
+        &self,
+        source_root_id: SourceRootId,
+    ) -> SourceRootInput {
         self.files.source_root(source_root_id)
     }
 
         files.set_source_root_with_durability(self, source_root_id, source_root, durability);
     }
 
-    fn file_source_root(&self, id: vfs::FileId) -> FileSourceRootInput {
+    fn file_source_root(
+        &self,
+        id: vfs::FileId,
+    ) -> FileSourceRootInput {
         self.files.file_source_root(id)
     }
 
     }
 
     fn nonce_and_revision(&self) -> (Nonce, salsa::Revision) {
-        (
-            self.nonce,
-            salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision(),
-        )
+        (self.nonce, salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision())
     }
 }
 
         self.set_expand_proc_attr_macros_with_durability(true, Durability::HIGH);
     }
 
-    pub fn update_base_query_lru_capacities(&mut self, _lru_capacity: Option<u16>) {
+    pub fn update_base_query_lru_capacities(
+        &mut self,
+        _lru_capacity: Option<u16>,
+    ) {
         // let lru_capacity = lru_capacity.unwrap_or(base_db::DEFAULT_PARSE_LRU_CAP);
         // base_db::FileTextQuery.in_db_mut(self).set_lru_capacity(DEFAULT_FILE_TEXT_LRU_CAP);
         // base_db::ParseQuery.in_db_mut(self).set_lru_capacity(lru_capacity);
         // hir::db::BodyWithSourceMapQuery.in_db_mut(self).set_lru_capacity(2048);
     }
 
-    pub fn update_lru_capacities(&mut self, _lru_capacities: &FxHashMap<Box<str>, u16>) {
+    pub fn update_lru_capacities(
+        &mut self,
+        _lru_capacities: &FxHashMap<Box<str>, u16>,
+    ) {
         // FIXME(salsa-transition): bring this back; allow changing LRU settings at runtime.
         // use hir::db as hir_db;
-
         // base_db::FileTextQuery.in_db_mut(self).set_lru_capacity(DEFAULT_FILE_TEXT_LRU_CAP);
         // base_db::ParseQuery.in_db_mut(self).set_lru_capacity(
         //     lru_capacities
 }
 
 #[query_group::query_group]
-pub trait LineIndexDatabase: base_db::RootQueryDb {
+pub trait LineIndexDatabase {
     #[salsa::invoke_interned(line_index)]
-    fn line_index(&self, file_id: FileId) -> Arc<LineIndex>;
+    fn line_index(
+        &self,
+        file_id: FileId,
+    ) -> Arc<LineIndex>;
 }
 
-fn line_index(db: &dyn LineIndexDatabase, file_id: FileId) -> Arc<LineIndex> {
+fn line_index(
+    db: &dyn LineIndexDatabase,
+    file_id: FileId,
+) -> Arc<LineIndex> {
     let text = db.file_text(file_id).text(db);
     Arc::new(LineIndex::new(text))
 }
 
 impl SnippetCap {
     pub const fn new(allow_snippets: bool) -> Option<SnippetCap> {
-        if allow_snippets {
-            Some(SnippetCap { _private: () })
-        } else {
-            None
-        }
+        if allow_snippets { Some(SnippetCap { _private: () }) } else { None }
     }
 }
 
 
     pub fn from_token(token: &'a syntax::SyntaxToken) -> Self {
         let kind = token.kind();
-        Ranker {
-            kind,
-            text: token.text(),
-            ident_kind: kind.is_any_identifier(),
-        }
+        Ranker { kind, text: token.text(), ident_kind: kind.is_any_identifier() }
     }
 
     /// A utility function that ranks a token again a given kind and text, returning a number that
     /// represents how close the token is to the given kind and text.
-    pub fn rank_token(&self, tok: &syntax::SyntaxToken) -> usize {
+    pub fn rank_token(
+        &self,
+        tok: &syntax::SyntaxToken,
+    ) -> usize {
         let tok_kind = tok.kind();
-
         let exact_same_kind = tok_kind == self.kind;
         let both_idents = exact_same_kind || (tok_kind.is_any_identifier() && self.ident_kind);
         let same_text = tok.text() == self.text;
         // anything that mapped into a token tree has likely no semantic information
-        let no_tt_parent = tok
-            .parent()
-            .is_some_and(|it| it.kind() != parser::SyntaxKind::TOKEN_TREE);
+        let no_tt_parent =
+            tok.parent().is_some_and(|it| it.kind() != parser::SyntaxKind::TOKEN_TREE);
         (both_idents as usize)
             | ((exact_same_kind as usize) << 1)
             | ((same_text as usize) << 2)