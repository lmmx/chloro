COMPARISON DIFF
============================================================

Original size: 12405 bytes
Chloro size:   12247 bytes
Rustfmt size:  12539 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This crate defines the core data structure representing IDE state -- `RootDatabase`.
 //!
 //! It is mainly a `HirDatabase` for semantic analysis, plus a `SymbolsDatabase`, for fuzzy search.
 
-extern crate self as ide_db;
 
 mod apply_change;
 
     pub use hir::prettify_macro_expansion;
     pub mod node_ext;
     pub mod suggest_name;
-
     pub use parser::LexedStr;
 }
 
 use std::{fmt, mem::ManuallyDrop};
 
 use base_db::{
-    query_group, CrateGraphBuilder, CratesMap, FileSourceRootInput, FileText, Files, Nonce,
-    RootQueryDb, SourceDatabase, SourceRoot, SourceRootId, SourceRootInput,
+    CrateGraphBuilder, CratesMap, FileSourceRootInput, FileText, Files, Nonce, RootQueryDb,
+    SourceDatabase, SourceRoot, SourceRootId, SourceRootInput, query_group,
 };
 use hir::{
-    db::{DefDatabase, ExpandDatabase},
     FilePositionWrapper, FileRangeWrapper,
+    db::{DefDatabase, ExpandDatabase},
 };
 use triomphe::Arc;
 
 
 pub use ::line_index;
 
-/// `base_db` is normally also needed in places where `ide_db` is used, so this re-export is for convenience.
 pub use base_db::{self, FxIndexMap, FxIndexSet};
 pub use span::{self, FileId};
 
 pub type FilePosition = FilePositionWrapper<FileId>;
+
 pub type FileRange = FileRangeWrapper<FileId>;
 
 #[salsa_macros::db]
     }
 
     fn nonce_and_revision(&self) -> (Nonce, salsa::Revision) {
-        (
-            self.nonce,
-            salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision(),
-        )
+        (self.nonce, salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision())
     }
 }
 
     pub fn update_lru_capacities(&mut self, _lru_capacities: &FxHashMap<Box<str>, u16>) {
         // FIXME(salsa-transition): bring this back; allow changing LRU settings at runtime.
         // use hir::db as hir_db;
-
         // base_db::FileTextQuery.in_db_mut(self).set_lru_capacity(DEFAULT_FILE_TEXT_LRU_CAP);
         // base_db::ParseQuery.in_db_mut(self).set_lru_capacity(
         //     lru_capacities
 }
 
 #[query_group::query_group]
-pub trait LineIndexDatabase: base_db::RootQueryDb {
+pub trait LineIndexDatabase {
     #[salsa::invoke_interned(line_index)]
     fn line_index(&self, file_id: FileId) -> Arc<LineIndex>;
 }
 
     pub fn from_token(token: &'a syntax::SyntaxToken) -> Self {
         let kind = token.kind();
-        Ranker {
-            kind,
-            text: token.text(),
-            ident_kind: kind.is_any_identifier(),
-        }
+        Ranker { kind, text: token.text(), ident_kind: kind.is_any_identifier() }
     }
 
     /// A utility function that ranks a token again a given kind and text, returning a number that
         let both_idents = exact_same_kind || (tok_kind.is_any_identifier() && self.ident_kind);
         let same_text = tok.text() == self.text;
         // anything that mapped into a token tree has likely no semantic information
-        let no_tt_parent = tok
-            .parent()
-            .is_some_and(|it| it.kind() != parser::SyntaxKind::TOKEN_TREE);
-        (both_idents as usize)
-            | ((exact_same_kind as usize) << 1)
-            | ((same_text as usize) << 2)
-            | ((no_tt_parent as usize) << 3)
+        let no_tt_parent =
+            tok.parent().is_some_and(|it| it.kind() != parser::SyntaxKind::TOKEN_TREE);
+        (both_idents as usize) | ((exact_same_kind as usize) << 1) | ((same_text as usize) << 2) | ((no_tt_parent as usize) << 3)
     }
 }
 