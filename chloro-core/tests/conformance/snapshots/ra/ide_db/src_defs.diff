COMPARISON DIFF
============================================================

Original size: 44130 bytes
Chloro size:   43747 bytes
Rustfmt size:  44130 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! `NameDefinition` keeps information about the element we want to search references for.
 //! The element is represented by `NameKind`. It's located inside some `container` and
 //! has a `visibility`, which defines a search scope.
 //! Note that the reference search is possible for not all of the classified items.
 
-// FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).
-
-use crate::RootDatabase;
-use crate::documentation::{DocsRangeMap, Documentation, HasDocs};
-use crate::famous_defs::FamousDefs;
 use arrayvec::ArrayVec;
 use either::Either;
 use hir::{
 use span::Edition;
 use stdx::{format_to, impl_from};
 use syntax::{
-    SyntaxKind, SyntaxNode, SyntaxToken, TextSize,
     ast::{self, AstNode},
-    match_ast,
+    match_ast, SyntaxKind, SyntaxNode, SyntaxToken, TextSize,
 };
 
-// FIXME: a more precise name would probably be `Symbol`?
+// FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).
+use crate::RootDatabase;
+use crate::documentation::{DocsRangeMap, Documentation, HasDocs};
+use crate::famous_defs::FamousDefs;
+
 #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]
 pub enum Definition {
     Macro(Macro),
 }
 
 impl Definition {
-    pub fn canonical_module_path(&self, db: &RootDatabase) -> Option<impl Iterator<Item = Module>> {
+    pub fn canonical_module_path(
+        &self,
+        db: &RootDatabase,
+    ) -> Option<impl Iterator<Item = Module>> {
         self.module(db).map(|it| it.path_to_root(db).into_iter().rev())
     }
 
         };
 
         docs.or_else(|| {
-            // docs are missing, for assoc items of trait impls try to fall back to the docs of the
-            // original item of the trait
             let assoc = self.as_assoc_item(db)?;
             let trait_ = assoc.implemented_trait(db)?;
             let name = Some(assoc.name(db)?);
             let item = trait_.items(db).into_iter().find(|it| it.name(db) == name)?;
             item.docs_with_rangemap(db)
-        })
-        .map(|(docs, range_map)| (docs, Some(range_map)))
+        }).map(
+            |(docs, range_map)| (docs, Some(range_map)),
+        )
     }
 
     pub fn label(&self, db: &RootDatabase, display_target: DisplayTarget) -> String {
             Definition::TypeAlias(it) => it.display(db, display_target).to_string(),
             Definition::BuiltinType(it) => {
                 it.name().display(db, display_target.edition).to_string()
-            }
+            },
             Definition::BuiltinLifetime(it) => {
                 it.name().display(db, display_target.edition).to_string()
-            }
+            },
             Definition::Local(it) => {
                 let ty = it.ty(db);
                 let ty_display = ty.display_truncated(db, None, display_target);
                         name.display(db, display_target.edition)
                     )
                 }
-            }
+            },
             Definition::SelfType(impl_def) => {
                 let self_ty = &impl_def.self_ty(db);
                 match self_ty.as_adt() {
                     Some(it) => it.display(db, display_target).to_string(),
                     None => self_ty.display(db, display_target).to_string(),
                 }
-            }
+            },
             Definition::GenericParam(it) => it.display(db, display_target).to_string(),
             Definition::Label(it) => it.name(db).display(db, display_target.edition).to_string(),
             Definition::ExternCrateDecl(it) => it.display(db, display_target).to_string(),
             Definition::BuiltinAttr(it) => {
                 format!("#[{}]", it.name().display(db, display_target.edition))
-            }
+            },
             Definition::ToolModule(it) => {
                 it.name(db).display(db, display_target.edition).to_string()
-            }
+            },
             Definition::DeriveHelper(it) => {
                 format!("derive_helper {}", it.name(db).display(db, display_target.edition))
-            }
-            // FIXME
+            },
             Definition::InlineAsmRegOrRegClass(_) => "inline_asm_reg_or_reg_class".to_owned(),
             Definition::InlineAsmOperand(_) => "inline_asm_reg_operand".to_owned(),
         }
     })
 }
 
-// FIXME: IdentClass as a name no longer fits
 #[derive(Debug)]
 pub enum IdentClass<'db> {
     NameClass(NameClass<'db>),
         sema: &Semantics<'db, RootDatabase>,
         lifetime: &ast::Lifetime,
     ) -> Option<IdentClass<'db>> {
-        NameRefClass::classify_lifetime(sema, lifetime)
-            .map(IdentClass::NameRefClass)
-            .or_else(|| NameClass::classify_lifetime(sema, lifetime).map(IdentClass::NameClass))
+        NameRefClass::classify_lifetime(sema, lifetime).map(IdentClass::NameRefClass).or_else(
+            || NameClass::classify_lifetime(sema, lifetime).map(IdentClass::NameClass),
+        )
     }
 
     pub fn definitions(self) -> ArrayVec<(Definition, Option<GenericSubstitution<'db>>), 2> {
             sema.to_def(&it).map(Definition::Label)
         } else {
             None
-        }
-        .map(NameClass::Definition)
+        }.map(
+            NameClass::Definition,
+        )
     }
 }
 
 }
 
 impl<'db> NameRefClass<'db> {
-    // Note: we don't have unit-tests for this rather important function.
-    // It is primarily exercised via goto definition tests in `ide`.
     pub fn classify(
         sema: &Semantics<'db, RootDatabase>,
         name_ref: &ast::NameRef,
         }
         let parent = lifetime.syntax().parent()?;
         match parent.kind() {
-            SyntaxKind::BREAK_EXPR | SyntaxKind::CONTINUE_EXPR => sema
-                .resolve_label(lifetime)
-                .map(Definition::Label)
-                .map(|it| NameRefClass::Definition(it, None)),
+            SyntaxKind::BREAK_EXPR | SyntaxKind::CONTINUE_EXPR => sema.resolve_label(lifetime).map(Definition::Label).map(
+                |it| NameRefClass::Definition(it, None),
+            ),
             SyntaxKind::LIFETIME_ARG
             | SyntaxKind::USE_BOUND_GENERIC_ARGS
             | SyntaxKind::SELF_PARAM
             | SyntaxKind::TYPE_BOUND
             | SyntaxKind::WHERE_PRED
-            | SyntaxKind::REF_TYPE => sema
-                .resolve_lifetime_param(lifetime)
-                .map(GenericParam::LifetimeParam)
-                .map(Definition::GenericParam)
-                .map(|it| NameRefClass::Definition(it, None)),
+            | SyntaxKind::REF_TYPE => sema.resolve_lifetime_param(lifetime).map(GenericParam::LifetimeParam).map(
+                Definition::GenericParam,
+            ).map(
+                |it| NameRefClass::Definition(it, None),
+            ),
             _ => None,
         }
     }
 
 impl TryFrom<DefWithBody> for Definition {
     type Error = ();
+
     fn try_from(def: DefWithBody) -> Result<Self, Self::Error> {
         match def {
             DefWithBody::Function(it) => Ok(it.into()),
 
 impl TryFrom<Definition> for GenericDef {
     type Error = ();
+
     fn try_from(def: Definition) -> Result<Self, Self::Error> {
         match def {
             Definition::Function(it) => Ok(it.into()),