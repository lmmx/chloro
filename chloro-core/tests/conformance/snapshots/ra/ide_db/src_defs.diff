COMPARISON DIFF
============================================================

Original size: 44130 bytes
Chloro size:   43724 bytes
Rustfmt size:  44130 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! `NameDefinition` keeps information about the element we want to search references for.
 //! The element is represented by `NameKind`. It's located inside some `container` and
 //! has a `visibility`, which defines a search scope.
 //! Note that the reference search is possible for not all of the classified items.
 
-// FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).
-
-use crate::RootDatabase;
-use crate::documentation::{DocsRangeMap, Documentation, HasDocs};
-use crate::famous_defs::FamousDefs;
 use arrayvec::ArrayVec;
 use either::Either;
 use hir::{
 use span::Edition;
 use stdx::{format_to, impl_from};
 use syntax::{
-    SyntaxKind, SyntaxNode, SyntaxToken, TextSize,
     ast::{self, AstNode},
-    match_ast,
+    match_ast, SyntaxKind, SyntaxNode, SyntaxToken, TextSize,
 };
 
-// FIXME: a more precise name would probably be `Symbol`?
+// FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).
+use crate::RootDatabase;
+use crate::documentation::{DocsRangeMap, Documentation, HasDocs};
+use crate::famous_defs::FamousDefs;
+
 #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]
 pub enum Definition {
     Macro(Macro),
 }
 
 impl Definition {
-    pub fn canonical_module_path(&self, db: &RootDatabase) -> Option<impl Iterator<Item = Module>> {
+    pub fn canonical_module_path(
+        &self,
+        db: &RootDatabase,
+    ) -> Option<impl Iterator<Item = Module>> {
         self.module(db).map(|it| it.path_to_root(db).into_iter().rev())
     }
 
     })
 }
 
-// FIXME: IdentClass as a name no longer fits
 #[derive(Debug)]
 pub enum IdentClass<'db> {
     NameClass(NameClass<'db>),
 }
 
 impl<'db> NameRefClass<'db> {
-    // Note: we don't have unit-tests for this rather important function.
-    // It is primarily exercised via goto definition tests in `ide`.
     pub fn classify(
         sema: &Semantics<'db, RootDatabase>,
         name_ref: &ast::NameRef,
         }
     }
 }
-
-impl_from!(
-    Field, Module, Function, Adt, Variant, Const, Static, Trait, TypeAlias, BuiltinType, Local,
-    GenericParam, Label, Macro, ExternCrateDecl
-    for Definition
-);
-
 impl From<Impl> for Definition {
     fn from(impl_: Impl) -> Self {
         Definition::SelfType(impl_)
 
 impl TryFrom<DefWithBody> for Definition {
     type Error = ();
+
     fn try_from(def: DefWithBody) -> Result<Self, Self::Error> {
         match def {
             DefWithBody::Function(it) => Ok(it.into()),
 
 impl TryFrom<Definition> for GenericDef {
     type Error = ();
+
     fn try_from(def: Definition) -> Result<Self, Self::Error> {
         match def {
             Definition::Function(it) => Ok(it.into()),