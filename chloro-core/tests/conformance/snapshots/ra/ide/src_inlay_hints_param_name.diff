COMPARISON DIFF
============================================================

Original size: 17010 bytes
Chloro size:   16958 bytes
Rustfmt size:  17010 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 }
 
 const INSIGNIFICANT_METHOD_NAMES: &[&str] = &["clone", "as_ref", "into"];
-const INSIGNIFICANT_PARAMETER_NAMES: &[&str] =
-    &["predicate", "value", "pat", "rhs", "other", "msg", "op"];
+
+const INSIGNIFICANT_PARAMETER_NAMES: &[&str] = &["predicate", "value", "pat", "rhs", "other", "msg", "op"];
 
 fn should_hide_param_name_hint(
     sema: &Semantics<'_, RootDatabase>,
     //   parameter is a prefix/suffix of argument with _ splitting it off
     // - param starts with `ra_fixture`
     // - param is a well known name in a unary function
-
     let param_name = param_name.trim_matches('_');
     if param_name.is_empty() {
         return true;
         ast::Expr::MacroExpr(macro_expr) => macro_expr.macro_call()?.path().map(Either::Right),
         ast::Expr::RecordExpr(record_expr) => record_expr.path().map(Either::Right),
         ast::Expr::PathExpr(path_expr) => {
-            let path = path_expr.path()?;
             // single segment paths are likely locals
+            let path = path_expr.path()?;
             Some(match path.as_single_name_ref() {
                 None => Either::Right(path),
                 Some(name_ref) => Either::Left(vec![name_ref]),
             }
         }
         _ => None,
-    })()
-    .unwrap_or(false)
+    })().unwrap_or(
+        false,
+    )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::{
         InlayHintsConfig,
-        inlay_hints::tests::{DISABLED_CONFIG, check_with_config},
+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},
     };
-
     #[track_caller]
     fn check_params(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(
             ra_fixture,
         );
     }
-
     #[test]
     fn param_hints_only() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn param_hints_on_closure() {
         check_params(
             "#,
         );
     }
-
     #[test]
     fn param_name_similar_to_fn_name_still_hints() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn param_name_similar_to_fn_name() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn param_name_same_as_fn_name() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn never_hide_param_when_multiple_params() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn param_hints_look_through_as_ref_and_clone() {
         check_params(
 "#,
         );
     }
-
     #[test]
     fn self_param_hints() {
-        check_params(
-            r#"
+        check_params(r#"
 struct Foo;
 
 impl Foo {
     Foo::bar(&Foo);
            //^^^^ self
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn param_name_hints_show_for_literals() {
-        check_params(
-            r#"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }
+        check_params(r#"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }
 fn main() {
     test(
         0xa_b,
         0xa_b,
       //^^^^^ b
     );
-}"#,
-        )
+}"#)
     }
-
     #[test]
     fn function_call_parameter_hint() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn parameter_hint_heuristics() {
         check_params(