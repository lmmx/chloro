COMPARISON DIFF
============================================================

Original size: 17010 bytes
Chloro size:   16748 bytes
Rustfmt size:  17010 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use either::Either;
 use hir::{EditionedFileId, Semantics};
-use ide_db::{RootDatabase, famous_defs::FamousDefs};
-
+use ide_db::{famous_defs::FamousDefs, RootDatabase};
 use stdx::to_lower_snake_case;
 use syntax::ast::{self, AstNode, HasArgList, HasName, UnaryOp};
 
 }
 
 const INSIGNIFICANT_METHOD_NAMES: &[&str] = &["clone", "as_ref", "into"];
-const INSIGNIFICANT_PARAMETER_NAMES: &[&str] =
-    &["predicate", "value", "pat", "rhs", "other", "msg", "op"];
+
+const INSIGNIFICANT_PARAMETER_NAMES: &[&str] = &["predicate", "value", "pat", "rhs", "other", "msg", "op"];
 
 fn should_hide_param_name_hint(
     sema: &Semantics<'_, RootDatabase>,
     //   parameter is a prefix/suffix of argument with _ splitting it off
     // - param starts with `ra_fixture`
     // - param is a well known name in a unary function
-
     let param_name = param_name.trim_matches('_');
     if param_name.is_empty() {
         return true;
 /// `fn strip_suffix(suffix)` will be hidden.
 /// `fn stripsuffix(suffix)` will not be hidden.
 fn is_param_name_suffix_of_fn_name(param_name: &str, fn_name: &str) -> bool {
-    fn_name == param_name
-        || fn_name
-            .len()
-            .checked_sub(param_name.len())
-            .and_then(|at| fn_name.is_char_boundary(at).then(|| fn_name.split_at(at)))
-            .is_some_and(|(prefix, suffix)| {
+    fn_name == param_name || fn_name.len().checked_sub(param_name.len()).and_then(
+        |at| fn_name.is_char_boundary(at).then(|| fn_name.split_at(at)),
+    ).is_some_and(|(prefix, suffix)| {
                 suffix.eq_ignore_ascii_case(param_name) && prefix.ends_with('_')
             })
 }
     match get_segment_representation(argument) {
         Some(Either::Left(argument)) => is_argument_similar_to_param_name(&argument, param_name),
         Some(Either::Right(path)) => {
-            path.segment()
-                .and_then(|it| it.name_ref())
-                .is_some_and(|name_ref| name_ref.text().eq_ignore_ascii_case(param_name))
-                || is_adt_constructor_similar_to_param_name(sema, &path, param_name)
+            path.segment().and_then(|it| it.name_ref()).is_some_and(
+                |name_ref| name_ref.text().eq_ignore_ascii_case(param_name),
+            ) || is_adt_constructor_similar_to_param_name(sema, &path, param_name)
         }
         None => false,
     }
             };
             Some(Either::Left(res))
         }
-        // paths
         ast::Expr::MacroExpr(macro_expr) => macro_expr.macro_call()?.path().map(Either::Right),
         ast::Expr::RecordExpr(record_expr) => record_expr.path().map(Either::Right),
         ast::Expr::PathExpr(path_expr) => {
             let path = path_expr.path()?;
-            // single segment paths are likely locals
             Some(match path.as_single_name_ref() {
                 None => Either::Right(path),
                 Some(name_ref) => Either::Left(vec![name_ref]),
             })
         }
         ast::Expr::PrefixExpr(prefix_expr) if prefix_expr.op_kind() == Some(UnaryOp::Not) => None,
-        // recurse
         ast::Expr::PrefixExpr(prefix_expr) => get_segment_representation(&prefix_expr.expr()?),
         ast::Expr::RefExpr(ref_expr) => get_segment_representation(&ref_expr.expr()?),
         ast::Expr::CastExpr(cast_expr) => get_segment_representation(&cast_expr.expr()?),
         ast::Expr::IndexExpr(index_expr) => get_segment_representation(&index_expr.base()?),
         ast::Expr::ParenExpr(paren_expr) => get_segment_representation(&paren_expr.expr()?),
         ast::Expr::TryExpr(try_expr) => get_segment_representation(&try_expr.expr()?),
-        // ast::Expr::ClosureExpr(closure_expr) => todo!(),
         _ => None,
     }
 }
             }
         }
         _ => None,
-    })()
-    .unwrap_or(false)
+    })(
+    ).unwrap_or(
+        false,
+    )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::{
+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},
         InlayHintsConfig,
-        inlay_hints::tests::{DISABLED_CONFIG, check_with_config},
     };
-
     #[track_caller]
     fn check_params(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(
             ra_fixture,
         );
     }
-
     #[test]
     fn param_hints_only() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn param_hints_on_closure() {
         check_params(
             "#,
         );
     }
-
     #[test]
     fn param_name_similar_to_fn_name_still_hints() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn param_name_similar_to_fn_name() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn param_name_same_as_fn_name() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn never_hide_param_when_multiple_params() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn param_hints_look_through_as_ref_and_clone() {
         check_params(
 "#,
         );
     }
-
     #[test]
     fn self_param_hints() {
-        check_params(
-            r#"
+        check_params(r#"
 struct Foo;
 
 impl Foo {
     Foo::bar(&Foo);
            //^^^^ self
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn param_name_hints_show_for_literals() {
-        check_params(
-            r#"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }
+        check_params(r#"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }
 fn main() {
     test(
         0xa_b,
         0xa_b,
       //^^^^^ b
     );
-}"#,
-        )
+}"#)
     }
-
     #[test]
     fn function_call_parameter_hint() {
         check_params(
 }"#,
         );
     }
-
     #[test]
     fn parameter_hint_heuristics() {
         check_params(