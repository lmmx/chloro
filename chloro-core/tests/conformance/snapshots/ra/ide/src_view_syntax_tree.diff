COMPARISON DIFF
============================================================

Original size: 29406 bytes
Chloro size:   29212 bytes
Rustfmt size:  29702 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::Semantics;
 use ide_db::{
-    line_index::{LineCol, LineIndex},
     FileId, LineIndexDatabase, RootDatabase,
+    line_index::{LineCol, LineIndex},
 };
 use span::{TextRange, TextSize};
 use stdx::format_to;
 use syntax::{
-    ast::{self, IsString},
     AstNode, AstToken, NodeOrToken, SourceFile, SyntaxNode, SyntaxToken, WalkEvent,
+    ast::{self, IsString},
 };
 use triomphe::Arc;
 
-// Feature: Show Syntax Tree
-//
-// Shows a tree view with the syntax tree of the current file
-//
-// | Editor  | Panel Name |
-// |---------|-------------|
-// | VS Code | **Rust Syntax Tree** |
 pub(crate) fn view_syntax_tree(db: &RootDatabase, file_id: FileId) -> String {
     let sema = Semantics::new(db);
     let line_index = db.line_index(file_id);
     let parse = sema.parse_guess_edition(file_id);
 
-    let ctx = SyntaxTreeCtx {
-        line_index,
-        in_string: None,
-    };
+    let ctx = SyntaxTreeCtx { line_index, in_string: None };
 
     syntax_node_to_json(parse.syntax(), &ctx)
 }
 
                         let true_range = TextRange::new(true_start.into(), true_end.into());
 
-                        (
-                            true_range,
-                            format!(r#","istart":{start_pos},"iend":{end_pos}"#,),
-                        )
+                        (true_range, format!(r#","istart":{start_pos},"iend":{end_pos}"#,))
                     }
                     None => (it.text_range(), "".to_owned()),
                 };
                         );
                     }
                     NodeOrToken::Token(token) => {
-                        let comma = if token.next_sibling_or_token().is_some() {
-                            ","
-                        } else {
-                            ""
-                        };
+                        let comma = if token.next_sibling_or_token().is_some() { "," } else { "" };
                         match parse_rust_string(token, ctx) {
                             Some(parsed) => {
                                 format_to!(
             }
             WalkEvent::Leave(it) => match it {
                 NodeOrToken::Node(node) => {
-                    let comma = if node.next_sibling_or_token().is_some() {
-                        ","
-                    } else {
-                        ""
-                    };
+                    let comma = if node.next_sibling_or_token().is_some() { "," } else { "" };
                     format_to!(result, "]}}{comma}")
                 }
                 NodeOrToken::Token(_) => (),
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::fixture;
-
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: expect_test::Expect) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let syn = analysis.view_syntax_tree(file_id).unwrap();
         expect.assert_eq(&syn)
     }
-
     #[test]
     fn view_syntax_tree() {
         // Basic syntax
             ]],
         )
     }
-
     #[test]
     fn view_syntax_tree_inside_string() {
         check(
         );
 
         // With a raw string
+
         check(
             r###"fn test() {
     assert!(r#"
         );
 
         // With a raw string
+
         check(
             r###"fn test() {
     assert!(r$0#"