COMPARISON DIFF
============================================================

Original size: 35956 bytes
Chloro size:   34854 bytes
Rustfmt size:  36650 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 mod on_enter;
 
-use either::Either;
-use hir::EditionedFileId;
-use ide_db::{base_db::RootQueryDb, FilePosition, RootDatabase};
-use span::Edition;
 use std::iter;
 
-use syntax::{
-    algo::{ancestors_at_offset, find_node_at_offset},
-    ast::{self, edit::IndentLevel, AstToken},
-    AstNode, Parse, SourceFile, SyntaxKind, TextRange, TextSize,
-};
-
+use either::Either;
+use hir::EditionedFileId;
 use ide_db::text_edit::TextEdit;
+use ide_db::{FilePosition, RootDatabase, base_db::RootQueryDb};
+pub(crate) use on_enter::on_enter;
+use span::Edition;
+use syntax::{
+    algo::{ancestors_at_offset, ast::{self, edit::IndentLevel}, find_node_at_offset}, AstNode,
+    AstToken, Parse, SourceFile, SyntaxKind, TextRange, TextSize,
+};
 
 use crate::SourceChange;
 
-pub(crate) use on_enter::on_enter;
-
-// Don't forget to add new trigger characters to `server_capabilities` in `caps.rs`.
 pub(crate) const TRIGGER_CHARS: &[char] = &['.', '=', '<', '>', '{', '(', '|', '+'];
 
 struct ExtendedTextEdit {
     is_snippet: bool,
 }
 
-// Feature: On Typing Assists
-//
-// Some features trigger on typing certain characters:
-//
-// - typing `let =` tries to smartly add `;` if `=` is followed by an existing expression
-// - typing `=` between two expressions adds `;` when in statement position
-// - typing `=` to turn an assignment into an equality comparison removes `;` when in expression position
-// - typing `.` in a chain method call auto-indents
-// - typing `{` or `(` in front of an expression inserts a closing `}` or `)` after the expression
-// - typing `{` in a use item adds a closing `}` in the right place
-// - typing `>` to complete a return type `->` will insert a whitespace after it
-//
-// #### VS Code
-//
-// Add the following to `settings.json`:
-// ```json
-// "editor.formatOnType": true,
-// ```
-//
-// ![On Typing Assists](https://user-images.githubusercontent.com/48062697/113166163-69758500-923a-11eb-81ee-eb33ec380399.gif)
-// ![On Typing Assists](https://user-images.githubusercontent.com/48062697/113171066-105c2000-923f-11eb-87ab-f4a263346567.gif)
 pub(crate) fn on_char_typed(
     db: &RootDatabase,
     position: FilePosition,
     if !stdx::always!(char_matches_position) {
         return None;
     }
-
     let edit = on_char_typed_(file, position.offset, char_typed, edition)?;
-
     let mut sc = SourceChange::from_text_edit(position.file_id, edit.edit);
     sc.is_snippet = edit.is_snippet;
     Some(sc)
 }
 
 fn conv(edit: TextEdit) -> ExtendedTextEdit {
-    ExtendedTextEdit {
-        edit,
-        is_snippet: false,
-    }
+    ExtendedTextEdit { edit, is_snippet: false }
 }
 
 /// Inserts a closing delimiter when the user types an opening bracket, wrapping an existing expression in a
 ) -> Option<TextEdit> {
     type FilterFn = fn(SyntaxKind) -> bool;
     let (closing_bracket, expected_ast_bracket, allowed_kinds) = match opening_bracket {
-        '{' => (
-            '}',
-            SyntaxKind::L_CURLY,
-            &[ast::Expr::can_cast as FilterFn] as &[FilterFn],
-        ),
+        '{' => ('}', SyntaxKind::L_CURLY, &[ast::Expr::can_cast as FilterFn] as &[FilterFn]),
         '(' => (
             ')',
             SyntaxKind::L_PAREN,
-            &[
-                ast::Expr::can_cast as FilterFn,
-                ast::Pat::can_cast,
-                ast::Type::can_cast,
-            ] as &[FilterFn],
-        ),
-        '<' => (
-            '>',
-            SyntaxKind::L_ANGLE,
-            &[ast::Type::can_cast as FilterFn] as &[FilterFn],
+            &[ast::Expr::can_cast as FilterFn, ast::Pat::can_cast, ast::Type::can_cast]
+                as &[FilterFn],
         ),
+        '<' => ('>', SyntaxKind::L_ANGLE, &[ast::Type::can_cast as FilterFn] as &[FilterFn]),
         _ => return None,
     };
-
-    let brace_token = file
-        .tree()
-        .syntax()
-        .token_at_offset(offset)
-        .right_biased()?;
+    let brace_token = file.tree().syntax().token_at_offset(offset).right_biased()?;
     if brace_token.kind() != expected_ast_bracket {
         return None;
     }
-
     // Remove the opening bracket to get a better parse tree, and reparse.
     let range = brace_token.text_range();
     if !stdx::always!(range.len() == TextSize::of(opening_bracket)) {
         return None;
     }
     let reparsed = file.reparse(range, "", edition).tree();
-
-    if let Some(edit) = on_delimited_node_typed(
-        &reparsed,
-        offset,
-        opening_bracket,
-        closing_bracket,
-        allowed_kinds,
-    ) {
+    if let Some(edit) =
+        on_delimited_node_typed(&reparsed, offset, opening_bracket, closing_bracket, allowed_kinds)
+    {
         return Some(edit);
     }
-
     match opening_bracket {
         '{' => on_left_brace_typed(&reparsed, offset),
         '<' => on_left_angle_typed(&file.tree(), &reparsed, offset),
     }
 }
 
-fn on_left_brace_typed(reparsed: &SourceFile, offset: TextSize) -> Option<TextEdit> {
+fn on_left_brace_typed(
+    reparsed: &SourceFile,
+    offset: TextSize,
+) -> Option<TextEdit> {
     let segment: ast::PathSegment = find_node_at_offset(reparsed.syntax(), offset)?;
     if segment.syntax().text_range().start() != offset {
         return None;
     }
-
     let tree: ast::UseTree = find_node_at_offset(reparsed.syntax(), offset)?;
-
-    Some(TextEdit::insert(
-        tree.syntax().text_range().end() + TextSize::of("{"),
-        "}".to_owned(),
-    ))
+    Some(TextEdit::insert(tree.syntax().text_range().end() + TextSize::of("{"), "}".to_owned()))
 }
 
 fn on_delimited_node_typed(
     let (filter, node) = t
         .parent_ancestors()
         .take_while(|n| n.text_range().start() == offset)
-        .find_map(|n| {
-            kinds
-                .iter()
-                .find(|&kind_filter| kind_filter(n.kind()))
-                .zip(Some(n))
-        })?;
+        .find_map(|n| kinds.iter().find(|&kind_filter| kind_filter(n.kind())).zip(Some(n)))?;
     let mut node = node
         .ancestors()
         .take_while(|n| n.text_range().start() == offset && filter(n.kind()))
         .last()?;
-
     if let Some(parent) = node.parent().filter(|it| filter(it.kind())) {
         let all_prev_sib_attr = {
             let mut node = node.clone();
             node = parent;
         }
     }
-
     // Insert the closing bracket right after the node.
     Some(TextEdit::insert(
         node.text_range().end() + TextSize::of(opening_bracket),
         closing_bracket.to_string(),
     ))
 }
+
 /// Returns an edit which should be applied after `=` was typed. Primarily,
 /// this works when adding `let =`.
-// FIXME: use a snippet completion instead of this hack here.
-fn on_eq_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
+fn on_eq_typed(
+    file: &SourceFile,
+    offset: TextSize,
+) -> Option<TextEdit> {
     let text = file.syntax().text();
     let has_newline = iter::successors(Some(offset), |&offset| Some(offset + TextSize::new(1)))
         .filter_map(|offset| text.char_at(offset))
     if has_newline {
         return None;
     }
-
     if let Some(edit) = let_stmt(file, offset) {
         return Some(edit);
     }
     if let Some(edit) = assign_to_eq(file, offset) {
         return Some(edit);
     }
-
     return None;
-
     fn assign_expr(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
         let binop: ast::BinExpr = find_node_at_offset(file.syntax(), offset)?;
-        if !matches!(
-            binop.op_kind(),
-            Some(ast::BinaryOp::Assignment { op: None })
-        ) {
+        if !matches!(binop.op_kind(), Some(ast::BinaryOp::Assignment { op: None })) {
             return None;
         }
 
         if expr_range.contains(offset) && offset != expr_range.start() {
             return None;
         }
-        if file
-            .syntax()
-            .text()
-            .slice(offset..expr_range.start())
-            .contains_char('\n')
-        {
+        if file.syntax().text().slice(offset..expr_range.start()).contains_char('\n') {
             return None;
         }
         let offset = expr.syntax().text_range().end();
         Some(TextEdit::insert(offset, ";".to_owned()))
     }
-
     /// `a =$0 b;` removes the semicolon if an expression is valid in this context.
     fn assign_to_eq(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
         let binop: ast::BinExpr = find_node_at_offset(file.syntax(), offset)?;
-        if !matches!(
-            binop.op_kind(),
-            Some(ast::BinaryOp::CmpOp(ast::CmpOp::Eq { negated: false }))
-        ) {
+        if !matches!(binop.op_kind(), Some(ast::BinaryOp::CmpOp(ast::CmpOp::Eq { negated: false })))
+        {
             return None;
         }
 
 
         Some(TextEdit::delete(semi.text_range()))
     }
-
     fn let_stmt(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
         let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;
         if let_stmt.semicolon_token().is_some() {
         if expr_range.contains(offset) && offset != expr_range.start() {
             return None;
         }
-        if file
-            .syntax()
-            .text()
-            .slice(offset..expr_range.start())
-            .contains_char('\n')
-        {
+        if file.syntax().text().slice(offset..expr_range.start()).contains_char('\n') {
             return None;
         }
         // Good indicator that we will insert into a bad spot, so bail out.
-        if expr
-            .syntax()
-            .descendants()
-            .any(|it| it.kind() == SyntaxKind::ERROR)
-        {
+        if expr.syntax().descendants().any(|it| it.kind() == SyntaxKind::ERROR) {
             return None;
         }
         let offset = let_stmt.syntax().text_range().end();
 }
 
 /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.
-fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
-    let whitespace = file
-        .syntax()
-        .token_at_offset(offset)
-        .left_biased()
-        .and_then(ast::Whitespace::cast)?;
-
+fn on_dot_typed(
+    file: &SourceFile,
+    offset: TextSize,
+) -> Option<TextEdit> {
+    let whitespace =
+        file.syntax().token_at_offset(offset).left_biased().and_then(ast::Whitespace::cast)?;
     // if prior is fn call over multiple lines dont indent
     // or if previous is method call over multiples lines keep that indent
     let current_indent = {
         suffix
     };
     let current_indent_len = TextSize::of(current_indent);
-
     let parent = whitespace.syntax().parent()?;
     // Make sure dot is a part of call chain
     let receiver = if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {
     } else {
         return None;
     };
-
     let receiver_is_multiline = receiver.syntax().text().find_char('\n').is_some();
     let target_indent = match (receiver, receiver_is_multiline) {
         // if receiver is multiline field or method call, just take the previous `.` indentation
         None => IndentLevel::from_node(&parent) + 1,
     }
     .to_string();
-
     if current_indent_len == TextSize::of(&target_indent) {
         return None;
     }
-
-    Some(TextEdit::replace(
-        TextRange::new(offset - current_indent_len, offset),
-        target_indent,
-    ))
+    Some(TextEdit::replace(TextRange::new(offset - current_indent_len, offset), target_indent))
 }
 
 /// Add closing `>` for generic arguments/parameters.
     offset: TextSize,
 ) -> Option<TextEdit> {
     let file_text = reparsed.syntax().text();
-
     // Find the next non-whitespace char in the line, check if its a `>`
     let mut next_offset = offset;
     while file_text.char_at(next_offset) == Some(' ') {
     if file_text.char_at(next_offset) == Some('>') {
         return None;
     }
-
     if ancestors_at_offset(file.syntax(), offset)
         .take_while(|n| !ast::Item::can_cast(n.kind()))
         .any(|n| {
         })
     {
         // Insert the closing bracket right after
-        Some(TextEdit::insert(
-            offset + TextSize::of('<'),
-            '>'.to_string(),
-        ))
+        Some(TextEdit::insert(offset + TextSize::of('<'), '>'.to_string()))
     } else {
         None
     }
 }
 
-fn on_pipe_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
+fn on_pipe_typed(
+    file: &SourceFile,
+    offset: TextSize,
+) -> Option<TextEdit> {
     let pipe_token = file.syntax().token_at_offset(offset).right_biased()?;
     if pipe_token.kind() != SyntaxKind::PIPE {
         return None;
     }
-    if pipe_token
-        .parent()
-        .and_then(ast::ParamList::cast)?
-        .r_paren_token()
-        .is_some()
-    {
+    if pipe_token.parent().and_then(ast::ParamList::cast)?.r_paren_token().is_some() {
         return None;
     }
     let after_lpipe = offset + TextSize::of('|');
     Some(TextEdit::insert(after_lpipe, "|".to_owned()))
 }
 
-fn on_plus_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
+fn on_plus_typed(
+    file: &SourceFile,
+    offset: TextSize,
+) -> Option<TextEdit> {
     let plus_token = file.syntax().token_at_offset(offset).right_biased()?;
     if plus_token.kind() != SyntaxKind::PLUS {
         return None;
     }
     let mut ancestors = plus_token.parent_ancestors();
     ancestors.next().and_then(ast::TypeBoundList::cast)?;
-    let trait_type = ancestors
-        .next()
-        .and_then(<Either<ast::DynTraitType, ast::ImplTraitType>>::cast)?;
+    let trait_type =
+        ancestors.next().and_then(<Either<ast::DynTraitType, ast::ImplTraitType>>::cast)?;
     let kind = ancestors.next()?.kind();
-
     if ast::RefType::can_cast(kind) || ast::PtrType::can_cast(kind) || ast::RetType::can_cast(kind)
     {
         let mut builder = TextEdit::builder();
 }
 
 /// Adds a space after an arrow when `fn foo() { ... }` is turned into `fn foo() -> { ... }`
-fn on_right_angle_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
+fn on_right_angle_typed(
+    file: &SourceFile,
+    offset: TextSize,
+) -> Option<TextEdit> {
     let file_text = file.syntax().text();
     let after_arrow = offset + TextSize::of('>');
     if file_text.char_at(after_arrow) != Some('{') {
         return None;
     }
     find_node_at_offset::<ast::RetType>(file.syntax(), offset)?;
-
     Some(TextEdit::insert(after_arrow, " ".to_owned()))
 }
 
 #[cfg(test)]
 mod tests {
     use test_utils::{assert_eq_text, extract_offset};
-
     use super::*;
-
     impl ExtendedTextEdit {
-        fn apply(&self, text: &mut String) {
+        fn apply(
+            &self,
+            text: &mut String,
+        ) {
             self.edit.apply(text);
         }
     }
-
-    fn do_type_char(char_typed: char, before: &str) -> Option<String> {
+    fn do_type_char(
+        char_typed: char,
+        before: &str,
+    ) -> Option<String> {
         let (offset, mut before) = extract_offset(before);
         let edit = TextEdit::insert(offset, char_typed.to_string());
         edit.apply(&mut before);
             before.to_string()
         })
     }
-
     fn type_char(
         char_typed: char,
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
     ) {
         let actual = do_type_char(char_typed, ra_fixture_before)
             .unwrap_or_else(|| panic!("typing `{char_typed}` did nothing"));
-
         assert_eq_text!(ra_fixture_after, &actual);
     }
-
-    fn type_char_noop(char_typed: char, #[rust_analyzer::rust_fixture] ra_fixture_before: &str) {
+    fn type_char_noop(
+        char_typed: char,
+        #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
+    ) {
         let file_change = do_type_char(char_typed, ra_fixture_before);
         assert_eq!(file_change, None)
     }
-
     #[test]
     fn test_semi_after_let() {
         type_char_noop(
 ",
         );
     }
-
     #[test]
     fn test_semi_after_assign() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn assign_to_eq() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn indents_new_chain_call() {
         type_char(
             "#,
         )
     }
-
     #[test]
     fn indents_new_chain_call_with_semi() {
         type_char(
             "#,
         )
     }
-
     #[test]
     fn indents_new_chain_call_with_let() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn indents_continued_chain_call() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn indents_middle_of_chain_call() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn dont_indent_freestanding_dot() {
         type_char_noop(
             "#,
         );
     }
-
     #[test]
     fn adds_space_after_return_type() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_closing_brace_for_expr() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn noop_in_string_literal() {
         // Regression test for #9351
             "##,
         );
     }
-
     #[test]
     fn noop_in_item_position_with_macro() {
         type_char_noop('{', r#"$0println!();"#);
 }"#,
         );
     }
-
     #[test]
     fn adds_closing_brace_for_use_tree() {
         type_char(
 use {Thing as _};
             "#,
         );
-
         type_char_noop(
             '{',
             r#"
             "#,
         );
     }
-
     #[test]
     fn adds_closing_parenthesis_for_expr() {
         type_char(
                     "#,
         );
     }
-
     #[test]
     fn preceding_whitespace_is_significant_for_closing_brackets() {
         type_char_noop(
 "#,
         );
     }
-
     #[test]
     fn adds_closing_parenthesis_for_pat() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_closing_parenthesis_for_ty() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_closing_angles_for_ty() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn parenthesis_noop_in_string_literal() {
         // Regression test for #9351
             "##,
         );
     }
-
     #[test]
     fn parenthesis_noop_in_item_position_with_macro() {
         type_char_noop('(', r#"$0println!();"#);
 }"#,
         );
     }
-
     #[test]
     fn parenthesis_noop_in_use_tree() {
         type_char_noop(
 use $0Thing as _;
             "#,
         );
-
         type_char_noop(
             '(',
             r#"
             "#,
         );
     }
-
     #[test]
     fn adds_closing_angle_bracket_for_generic_args() {
         type_char(
 }
             "#,
         );
-
         type_char(
             '<',
             r#"
             "#,
         );
     }
-
     #[test]
     fn adds_closing_angle_bracket_for_generic_params() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn dont_add_closing_angle_bracket_for_comparison() {
         type_char_noop(
             "#,
         );
     }
-
     #[test]
     fn dont_add_closing_angle_bracket_if_it_is_already_there() {
         type_char_noop(
             "#,
         );
     }
-
     #[test]
     fn regression_629() {
         type_char_noop(
 "#,
         );
     }
-
     #[test]
     fn completes_pipe_param_list() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_parentheses_around_trait_object_in_ref_type() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_parentheses_around_trait_object_in_ptr_type() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_parentheses_around_trait_object_in_return_type() {
         type_char(