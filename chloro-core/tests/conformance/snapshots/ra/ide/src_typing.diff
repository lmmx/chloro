COMPARISON DIFF
============================================================

Original size: 35956 bytes
Chloro size:   34685 bytes
Rustfmt size:  36650 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 mod on_enter;
 
-use either::Either;
-use hir::EditionedFileId;
-use ide_db::{base_db::RootQueryDb, FilePosition, RootDatabase};
-use span::Edition;
 use std::iter;
 
+use either::Either;
+use hir::EditionedFileId;
+use ide_db::text_edit::TextEdit;
+use ide_db::{base_db::RootQueryDb, FilePosition, RootDatabase};
+pub(crate) use on_enter::on_enter;
+use span::Edition;
 use syntax::{
     algo::{ancestors_at_offset, find_node_at_offset},
     ast::{self, edit::IndentLevel, AstToken},
     AstNode, Parse, SourceFile, SyntaxKind, TextRange, TextSize,
 };
 
-use ide_db::text_edit::TextEdit;
-
 use crate::SourceChange;
 
-pub(crate) use on_enter::on_enter;
-
-// Don't forget to add new trigger characters to `server_capabilities` in `caps.rs`.
 pub(crate) const TRIGGER_CHARS: &[char] = &['.', '=', '<', '>', '{', '(', '|', '+'];
 
 struct ExtendedTextEdit {
     is_snippet: bool,
 }
 
-// Feature: On Typing Assists
-//
-// Some features trigger on typing certain characters:
-//
-// - typing `let =` tries to smartly add `;` if `=` is followed by an existing expression
-// - typing `=` between two expressions adds `;` when in statement position
-// - typing `=` to turn an assignment into an equality comparison removes `;` when in expression position
-// - typing `.` in a chain method call auto-indents
-// - typing `{` or `(` in front of an expression inserts a closing `}` or `)` after the expression
-// - typing `{` in a use item adds a closing `}` in the right place
-// - typing `>` to complete a return type `->` will insert a whitespace after it
-//
-// #### VS Code
-//
-// Add the following to `settings.json`:
-// ```json
-// "editor.formatOnType": true,
-// ```
-//
-// ![On Typing Assists](https://user-images.githubusercontent.com/48062697/113166163-69758500-923a-11eb-81ee-eb33ec380399.gif)
-// ![On Typing Assists](https://user-images.githubusercontent.com/48062697/113171066-105c2000-923f-11eb-87ab-f4a263346567.gif)
 pub(crate) fn on_char_typed(
     db: &RootDatabase,
     position: FilePosition,
 }
 
 fn conv(edit: TextEdit) -> ExtendedTextEdit {
-    ExtendedTextEdit {
-        edit,
-        is_snippet: false,
-    }
+    ExtendedTextEdit { edit, is_snippet: false }
 }
 
 /// Inserts a closing delimiter when the user types an opening bracket, wrapping an existing expression in a
 ) -> Option<TextEdit> {
     type FilterFn = fn(SyntaxKind) -> bool;
     let (closing_bracket, expected_ast_bracket, allowed_kinds) = match opening_bracket {
-        '{' => (
-            '}',
-            SyntaxKind::L_CURLY,
-            &[ast::Expr::can_cast as FilterFn] as &[FilterFn],
-        ),
+        '{' => ('}', SyntaxKind::L_CURLY, &[ast::Expr::can_cast as FilterFn] as &[FilterFn]),
         '(' => (
             ')',
             SyntaxKind::L_PAREN,
-            &[
-                ast::Expr::can_cast as FilterFn,
-                ast::Pat::can_cast,
-                ast::Type::can_cast,
-            ] as &[FilterFn],
-        ),
-        '<' => (
-            '>',
-            SyntaxKind::L_ANGLE,
-            &[ast::Type::can_cast as FilterFn] as &[FilterFn],
+            &[ast::Expr::can_cast as FilterFn, ast::Pat::can_cast, ast::Type::can_cast]
+                as &[FilterFn],
         ),
+        '<' => ('>', SyntaxKind::L_ANGLE, &[ast::Type::can_cast as FilterFn] as &[FilterFn]),
         _ => return None,
     };
 
-    let brace_token = file
-        .tree()
-        .syntax()
-        .token_at_offset(offset)
-        .right_biased()?;
+    let brace_token = file.tree().syntax().token_at_offset(offset).right_biased()?;
     if brace_token.kind() != expected_ast_bracket {
         return None;
     }
     }
     let reparsed = file.reparse(range, "", edition).tree();
 
-    if let Some(edit) = on_delimited_node_typed(
-        &reparsed,
-        offset,
-        opening_bracket,
-        closing_bracket,
-        allowed_kinds,
-    ) {
+    if let Some(edit) =
+        on_delimited_node_typed(&reparsed, offset, opening_bracket, closing_bracket, allowed_kinds)
+    {
         return Some(edit);
     }
 
 
     let tree: ast::UseTree = find_node_at_offset(reparsed.syntax(), offset)?;
 
-    Some(TextEdit::insert(
-        tree.syntax().text_range().end() + TextSize::of("{"),
-        "}".to_owned(),
-    ))
+    Some(TextEdit::insert(tree.syntax().text_range().end() + TextSize::of("{"), "}".to_owned()))
 }
 
 fn on_delimited_node_typed(
     let (filter, node) = t
         .parent_ancestors()
         .take_while(|n| n.text_range().start() == offset)
-        .find_map(|n| {
-            kinds
-                .iter()
-                .find(|&kind_filter| kind_filter(n.kind()))
-                .zip(Some(n))
-        })?;
+        .find_map(|n| kinds.iter().find(|&kind_filter| kind_filter(n.kind())).zip(Some(n)))?;
     let mut node = node
         .ancestors()
         .take_while(|n| n.text_range().start() == offset && filter(n.kind()))
     }
 
     // Insert the closing bracket right after the node.
-    Some(TextEdit::insert(
+    Some(
+        TextEdit::insert(
         node.text_range().end() + TextSize::of(opening_bracket),
         closing_bracket.to_string(),
-    ))
+    ),
+    )
 }
+
 /// Returns an edit which should be applied after `=` was typed. Primarily,
 /// this works when adding `let =`.
-// FIXME: use a snippet completion instead of this hack here.
 fn on_eq_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
     let text = file.syntax().text();
     let has_newline = iter::successors(Some(offset), |&offset| Some(offset + TextSize::new(1)))
 
     fn assign_expr(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
         let binop: ast::BinExpr = find_node_at_offset(file.syntax(), offset)?;
-        if !matches!(
-            binop.op_kind(),
-            Some(ast::BinaryOp::Assignment { op: None })
-        ) {
+        if !matches!(binop.op_kind(), Some(ast::BinaryOp::Assignment { op: None })) {
             return None;
         }
 
         if expr_range.contains(offset) && offset != expr_range.start() {
             return None;
         }
-        if file
-            .syntax()
-            .text()
-            .slice(offset..expr_range.start())
-            .contains_char('\n')
-        {
+        if file.syntax().text().slice(offset..expr_range.start()).contains_char('\n') {
             return None;
         }
         let offset = expr.syntax().text_range().end();
     /// `a =$0 b;` removes the semicolon if an expression is valid in this context.
     fn assign_to_eq(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
         let binop: ast::BinExpr = find_node_at_offset(file.syntax(), offset)?;
-        if !matches!(
-            binop.op_kind(),
-            Some(ast::BinaryOp::CmpOp(ast::CmpOp::Eq { negated: false }))
-        ) {
+        if !matches!(binop.op_kind(), Some(ast::BinaryOp::CmpOp(ast::CmpOp::Eq { negated: false })))
+        {
             return None;
         }
 
         if expr_range.contains(offset) && offset != expr_range.start() {
             return None;
         }
-        if file
-            .syntax()
-            .text()
-            .slice(offset..expr_range.start())
-            .contains_char('\n')
-        {
+        if file.syntax().text().slice(offset..expr_range.start()).contains_char('\n') {
             return None;
         }
         // Good indicator that we will insert into a bad spot, so bail out.
-        if expr
-            .syntax()
-            .descendants()
-            .any(|it| it.kind() == SyntaxKind::ERROR)
-        {
+        if expr.syntax().descendants().any(|it| it.kind() == SyntaxKind::ERROR) {
             return None;
         }
         let offset = let_stmt.syntax().text_range().end();
 
 /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.
 fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {
-    let whitespace = file
-        .syntax()
-        .token_at_offset(offset)
-        .left_biased()
-        .and_then(ast::Whitespace::cast)?;
+    let whitespace =
+        file.syntax().token_at_offset(offset).left_biased().and_then(ast::Whitespace::cast)?;
 
     // if prior is fn call over multiple lines dont indent
+
     // or if previous is method call over multiples lines keep that indent
     let current_indent = {
         let text = whitespace.text();
         return None;
     }
 
-    Some(TextEdit::replace(
-        TextRange::new(offset - current_indent_len, offset),
-        target_indent,
-    ))
+    Some(TextEdit::replace(TextRange::new(offset - current_indent_len, offset), target_indent))
 }
 
 /// Add closing `>` for generic arguments/parameters.
         })
     {
         // Insert the closing bracket right after
-        Some(TextEdit::insert(
-            offset + TextSize::of('<'),
-            '>'.to_string(),
-        ))
+        Some(TextEdit::insert(offset + TextSize::of('<'), '>'.to_string()))
     } else {
         None
     }
     if pipe_token.kind() != SyntaxKind::PIPE {
         return None;
     }
-    if pipe_token
-        .parent()
-        .and_then(ast::ParamList::cast)?
-        .r_paren_token()
-        .is_some()
-    {
+    if pipe_token.parent().and_then(ast::ParamList::cast)?.r_paren_token().is_some() {
         return None;
     }
     let after_lpipe = offset + TextSize::of('|');
     }
     let mut ancestors = plus_token.parent_ancestors();
     ancestors.next().and_then(ast::TypeBoundList::cast)?;
-    let trait_type = ancestors
-        .next()
-        .and_then(<Either<ast::DynTraitType, ast::ImplTraitType>>::cast)?;
+    let trait_type =
+        ancestors.next().and_then(<Either<ast::DynTraitType, ast::ImplTraitType>>::cast)?;
     let kind = ancestors.next()?.kind();
 
     if ast::RefType::can_cast(kind) || ast::PtrType::can_cast(kind) || ast::RetType::can_cast(kind)
 #[cfg(test)]
 mod tests {
     use test_utils::{assert_eq_text, extract_offset};
-
     use super::*;
-
     impl ExtendedTextEdit {
         fn apply(&self, text: &mut String) {
             self.edit.apply(text);
         }
     }
-
     fn do_type_char(char_typed: char, before: &str) -> Option<String> {
         let (offset, mut before) = extract_offset(before);
         let edit = TextEdit::insert(offset, char_typed.to_string());
             before.to_string()
         })
     }
-
     fn type_char(
         char_typed: char,
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
 
         assert_eq_text!(ra_fixture_after, &actual);
     }
-
     fn type_char_noop(char_typed: char, #[rust_analyzer::rust_fixture] ra_fixture_before: &str) {
         let file_change = do_type_char(char_typed, ra_fixture_before);
         assert_eq!(file_change, None)
     }
-
     #[test]
     fn test_semi_after_let() {
         type_char_noop(
 ",
         );
     }
-
     #[test]
     fn test_semi_after_assign() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn assign_to_eq() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn indents_new_chain_call() {
         type_char(
 }
             "#,
         );
-        type_char_noop(
-            '.',
-            r#"
+        type_char_noop('.', r#"
 fn main() {
     xs.foo()
         $0
 }
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn indents_new_chain_call_with_semi() {
         type_char(
 }
             "#,
         );
-        type_char_noop(
-            '.',
-            r#"
+        type_char_noop('.', r#"
 fn main() {
     xs.foo()
         $0;
 }
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn indents_new_chain_call_with_let() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn indents_continued_chain_call() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn indents_middle_of_chain_call() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn dont_indent_freestanding_dot() {
         type_char_noop(
             "#,
         );
     }
-
     #[test]
     fn adds_space_after_return_type() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_closing_brace_for_expr() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn noop_in_string_literal() {
         // Regression test for #9351
             "##,
         );
     }
-
     #[test]
     fn noop_in_item_position_with_macro() {
         type_char_noop('{', r#"$0println!();"#);
 }"#,
         );
     }
-
     #[test]
     fn adds_closing_brace_for_use_tree() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn adds_closing_parenthesis_for_expr() {
         type_char(
                     "#,
         );
     }
-
     #[test]
     fn preceding_whitespace_is_significant_for_closing_brackets() {
         type_char_noop(
 "#,
         );
     }
-
     #[test]
     fn adds_closing_parenthesis_for_pat() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_closing_parenthesis_for_ty() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_closing_angles_for_ty() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn parenthesis_noop_in_string_literal() {
         // Regression test for #9351
             "##,
         );
     }
-
     #[test]
     fn parenthesis_noop_in_item_position_with_macro() {
         type_char_noop('(', r#"$0println!();"#);
 }"#,
         );
     }
-
     #[test]
     fn parenthesis_noop_in_use_tree() {
         type_char_noop(
             "#,
         );
     }
-
     #[test]
     fn adds_closing_angle_bracket_for_generic_args() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn adds_closing_angle_bracket_for_generic_params() {
         type_char(
             "#,
         );
     }
-
     #[test]
     fn dont_add_closing_angle_bracket_for_comparison() {
         type_char_noop(
             "#,
         );
     }
-
     #[test]
     fn dont_add_closing_angle_bracket_if_it_is_already_there() {
         type_char_noop(
             "#,
         );
     }
-
     #[test]
     fn regression_629() {
         type_char_noop(
 "#,
         );
     }
-
     #[test]
     fn completes_pipe_param_list() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_parentheses_around_trait_object_in_ref_type() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_parentheses_around_trait_object_in_ptr_type() {
         type_char(
 "#,
         );
     }
-
     #[test]
     fn adds_parentheses_around_trait_object_in_return_type() {
         type_char(