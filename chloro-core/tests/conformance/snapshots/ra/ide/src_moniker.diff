COMPARISON DIFF
============================================================

Original size: 20553 bytes
Chloro size:   20506 bytes
Rustfmt size:  21116 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use itertools::Itertools;
 use syntax::{AstNode, SyntaxKind::*, T};
 
-use crate::{doc_links::token_as_doc_comment, parent_module::crates_for, RangeInfo};
+use crate::{RangeInfo, doc_links::token_as_doc_comment, parent_module::crates_for};
 
 #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
 pub enum MonikerDescriptorKind {
     Meta,
 }
 
-// Subset of scip_types::SymbolInformation::Kind
 #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 pub enum SymbolInformationKind {
     AssociatedType,
 impl fmt::Display for MonikerIdentifier {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         f.write_str(&self.crate_name)?;
-        f.write_fmt(format_args!(
-            "::{}",
-            self.description.iter().map(|x| &x.name).join("::")
-        ))
+        f.write_fmt(format_args!("::{}", self.description.iter().map(|x| &x.name).join("::")))
     }
 }
 
     Moniker(Moniker),
     /// Specifies that the definition is a local, and so does not have a unique identifier. Provides
     /// a unique identifier for the container.
-    Local { enclosing_moniker: Option<Moniker> },
+    Local {
+        enclosing_moniker: Option<Moniker>,
+    },
 }
 
 impl MonikerResult {
         .descend_into_macros_exact(original_token.clone())
         .into_iter()
         .filter_map(|token| {
-            IdentClass::classify_token(sema, &token)
-                .map(IdentClass::definitions_no_ops)
-                .map(|it| {
-                    it.into_iter()
-                        .flat_map(|def| def_to_moniker(sema.db, def, current_crate))
-                })
+            IdentClass::classify_token(sema, &token).map(IdentClass::definitions_no_ops).map(|it| {
+                it.into_iter().flat_map(|def| def_to_moniker(sema.db, def, current_crate))
+            })
         })
         .flatten()
         .unique()
         Definition::Function(it) => {
             if it.as_assoc_item(db).is_some() {
                 if it.has_self_param(db) {
-                    if it.has_body(db) {
-                        Method
-                    } else {
-                        TraitMethod
-                    }
+                    if it.has_body(db) { Method } else { TraitMethod }
                 } else {
                     StaticMethod
                 }
         }
         _ => {}
     }
-    Some(MonikerResult::Moniker(def_to_non_local_moniker(
-        db, definition, from_crate,
-    )?))
+    Some(MonikerResult::Moniker(def_to_non_local_moniker(db, definition, from_crate)?))
 }
 
 fn enclosing_def_to_moniker(
             crate_name: krate.display_name(db)?.crate_name().to_string(),
             description,
         },
-        kind: if krate == from_crate {
-            MonikerKind::Export
-        } else {
-            MonikerKind::Import
-        },
+        kind: if krate == from_crate { MonikerKind::Export } else { MonikerKind::Import },
         package_information: {
             let (name, repo, version) = match krate.origin(db) {
                 CrateOrigin::Library { repo, name } => (name, repo, krate.version(db)),
                     }),
                 ),
             };
-            PackageInformation {
-                name: name.as_str().to_owned(),
-                repo,
-                version,
-            }
+            PackageInformation { name: name.as_str().to_owned(), repo, version }
         },
     })
 }
         Ok(result) => result,
         // Fallback on display variant that always succeeds
         Err(_) => {
-            let fallback_result = it
-                .display(db, module.krate().to_display_target(db))
-                .to_string();
+            let fallback_result = it.display(db, module.krate().to_display_target(db)).to_string();
             tracing::error!(
                 display = %fallback_result, "`display_source_code` failed; falling back to using display"
             );
 
 #[cfg(test)]
 mod tests {
-    use crate::{fixture, MonikerResult};
-
+    use crate::{MonikerResult, fixture};
     use super::MonikerKind;
-
     #[allow(dead_code)]
     #[track_caller]
     fn no_moniker(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         let (analysis, position) = fixture::position(ra_fixture);
         if let Some(x) = analysis.moniker(position).unwrap() {
-            assert_eq!(
-                x.info.len(),
-                0,
-                "Moniker found but no moniker expected: {x:?}"
-            );
+            assert_eq!(x.info.len(), 0, "Moniker found but no moniker expected: {x:?}");
         }
     }
-
     #[track_caller]
     fn check_local_moniker(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         kind: MonikerKind,
     ) {
         let (analysis, position) = fixture::position(ra_fixture);
-        let x = analysis
-            .moniker(position)
-            .unwrap()
-            .expect("no moniker found")
-            .info;
+        let x = analysis.moniker(position).unwrap().expect("no moniker found").info;
         assert_eq!(x.len(), 1);
         match x.into_iter().next().unwrap() {
-            MonikerResult::Local {
-                enclosing_moniker: Some(x),
-            } => {
+            MonikerResult::Local { enclosing_moniker: Some(x) } => {
                 assert_eq!(identifier, x.identifier.to_string());
                 assert_eq!(package, format!("{:?}", x.package_information));
                 assert_eq!(kind, x.kind);
             }
-            MonikerResult::Local {
-                enclosing_moniker: None,
-            } => {
+            MonikerResult::Local { enclosing_moniker: None } => {
                 panic!("Unexpected local with no enclosing moniker");
             }
             MonikerResult::Moniker(_) => {
             }
         }
     }
-
     #[track_caller]
     fn check_moniker(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         kind: MonikerKind,
     ) {
         let (analysis, position) = fixture::position(ra_fixture);
-        let x = analysis
-            .moniker(position)
-            .unwrap()
-            .expect("no moniker found")
-            .info;
+        let x = analysis.moniker(position).unwrap().expect("no moniker found").info;
         assert_eq!(x.len(), 1);
         match x.into_iter().next().unwrap() {
             MonikerResult::Local { enclosing_moniker } => {
             }
         }
     }
-
     #[test]
     fn basic() {
         check_moniker(
             MonikerKind::Export,
         );
     }
-
     #[test]
     fn moniker_for_trait() {
         check_moniker(
             MonikerKind::Export,
         );
     }
-
     #[test]
     fn moniker_for_trait_constant() {
         check_moniker(
             MonikerKind::Export,
         );
     }
-
     #[test]
     fn moniker_for_trait_type() {
         check_moniker(
             MonikerKind::Export,
         );
     }
-
     #[test]
     fn moniker_for_trait_impl_function() {
         check_moniker(
             MonikerKind::Export,
         );
     }
-
     #[test]
     fn moniker_for_field() {
         check_moniker(
             MonikerKind::Import,
         );
     }
-
     #[test]
     fn local() {
         check_local_moniker(