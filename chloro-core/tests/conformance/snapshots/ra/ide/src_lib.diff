COMPARISON DIFF
============================================================

Original size: 33665 bytes
Chloro size:   33986 bytes
Rustfmt size:  33868 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
+#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
+#![recursion_limit = "128"]
 //! ide crate provides "ide-centric" APIs for the rust-analyzer. That is,
 //! it generally operates with files and text ranges, and returns results as
 //! Strings, suitable for displaying to the human.
 //! However, IDE specific bits of the analysis (most notably completion) happen
 //! in this crate.
 
-// For proving that RootDatabase is RefUnwindSafe.
-
-#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
-#![recursion_limit = "128"]
-
 #[cfg(test)]
 mod fixture;
-
 mod markup;
 mod navigation_target;
-
 mod annotations;
 mod call_hierarchy;
 mod child_modules;
 
 use cfg::CfgOptions;
 use fetch_crates::CrateInfo;
-use hir::{crate_def_map, sym, ChangeWithProcMacros, EditionedFileId};
-use ide_db::{
-    base_db::{
-        salsa::Cancelled, CrateOrigin, CrateWorkspaceData, Env, FileSet, RootQueryDb,
-        SourceDatabase, VfsPath,
-    },
-    prime_caches, symbol_index, FxHashMap, FxIndexSet, LineIndexDatabase,
+pub use hir::Semantics;
+use hir::{ChangeWithProcMacros, EditionedFileId, crate_def_map, sym};
+pub use ide_assists::{
+    Assist, AssistConfig, AssistId, AssistKind, AssistResolveStrategy, SingleResolve,
 };
-use ide_db::{ra_fixture::RaFixtureAnalysis, MiniCore};
+pub use ide_completion::{
+    CallableSnippets, CompletionConfig, CompletionFieldsToResolve, CompletionItem,
+    CompletionItemKind, CompletionItemRefMode, CompletionRelevance, Snippet, SnippetScope,
+};
+pub use ide_db::{
+    FileId, FilePosition, FileRange, RootDatabase, Severity, SymbolKind,
+    assists::ExprFillDefaultMode,
+    base_db::{Crate, CrateGraphBuilder, FileChange, SourceRoot, SourceRootId},
+    documentation::Documentation,
+    label::Label,
+    line_index::{LineCol, LineIndex},
+    prime_caches::ParallelPrimeCachesProgress,
+    search::{ReferenceCategory, SearchScope},
+    source_change::{FileSystemEdit, SnippetEdit, SourceChange},
+    symbol_index::Query,
+    text_edit::{Indel, TextEdit},
+};
+use ide_db::{
+    FxHashMap, FxIndexSet, LineIndexDatabase,
+    base_db::{
+        CrateOrigin, CrateWorkspaceData, Env, FileSet, RootQueryDb, SourceDatabase, VfsPath,
+        salsa::Cancelled,
+    },
+    prime_caches, symbol_index,
+};
+use ide_db::{MiniCore, ra_fixture::RaFixtureAnalysis};
+pub use ide_diagnostics::{Diagnostic, DiagnosticCode, DiagnosticsConfig};
+pub use ide_ssr::SsrError;
 use macros::UpmapFromRaFixture;
-use syntax::{ast, SourceFile};
+pub use span::Edition;
+use syntax::{SourceFile, ast};
+pub use syntax::{TextRange, TextSize};
 use triomphe::Arc;
-use view_memory_layout::{view_memory_layout, RecursiveMemoryLayout};
+use view_memory_layout::{RecursiveMemoryLayout, view_memory_layout};
 
 use crate::navigation_target::ToNav;
-
 pub use crate::{
     annotations::{Annotation, AnnotationConfig, AnnotationKind, AnnotationLocation},
     call_hierarchy::{CallHierarchyConfig, CallItem},
         StaticIndex, StaticIndexedFile, TokenId, TokenStaticData, VendoredLibrariesConfig,
     },
     syntax_highlighting::{
-        tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},
         HighlightConfig, HlRange,
+        tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},
     },
     test_explorer::{TestItem, TestItemKind},
 };
-pub use hir::Semantics;
-pub use ide_assists::{
-    Assist, AssistConfig, AssistId, AssistKind, AssistResolveStrategy, SingleResolve,
-};
-pub use ide_completion::{
-    CallableSnippets, CompletionConfig, CompletionFieldsToResolve, CompletionItem,
-    CompletionItemKind, CompletionItemRefMode, CompletionRelevance, Snippet, SnippetScope,
-};
-pub use ide_db::{
-    assists::ExprFillDefaultMode,
-    base_db::{Crate, CrateGraphBuilder, FileChange, SourceRoot, SourceRootId},
-    documentation::Documentation,
-    label::Label,
-    line_index::{LineCol, LineIndex},
-    prime_caches::ParallelPrimeCachesProgress,
-    search::{ReferenceCategory, SearchScope},
-    source_change::{FileSystemEdit, SnippetEdit, SourceChange},
-    symbol_index::Query,
-    text_edit::{Indel, TextEdit},
-    FileId, FilePosition, FileRange, RootDatabase, Severity, SymbolKind,
-};
-pub use ide_diagnostics::{Diagnostic, DiagnosticCode, DiagnosticsConfig};
-pub use ide_ssr::SsrError;
-pub use span::Edition;
-pub use syntax::{TextRange, TextSize};
 
 pub type Cancellable<T> = Result<T, Cancelled>;
 
 }
 
 impl<T> RangeInfo<T> {
-    pub fn new(range: TextRange, info: T) -> RangeInfo<T> {
+    pub fn new(
+        range: TextRange,
+        info: T,
+    ) -> RangeInfo<T> {
         RangeInfo { range, info }
     }
 }
 
 impl AnalysisHost {
     pub fn new(lru_capacity: Option<u16>) -> AnalysisHost {
-        AnalysisHost {
-            db: RootDatabase::new(lru_capacity),
-        }
+        AnalysisHost { db: RootDatabase::new(lru_capacity) }
     }
 
     pub fn with_database(db: RootDatabase) -> AnalysisHost {
         AnalysisHost { db }
     }
 
-    pub fn update_lru_capacity(&mut self, lru_capacity: Option<u16>) {
+    pub fn update_lru_capacity(
+        &mut self,
+        lru_capacity: Option<u16>,
+    ) {
         self.db.update_base_query_lru_capacities(lru_capacity);
     }
 
-    pub fn update_lru_capacities(&mut self, lru_capacities: &FxHashMap<Box<str>, u16>) {
+    pub fn update_lru_capacities(
+        &mut self,
+        lru_capacities: &FxHashMap<Box<str>, u16>,
+    ) {
         self.db.update_lru_capacities(lru_capacities);
     }
 
     /// Returns a snapshot of the current state, which you can query for
     /// semantic information.
     pub fn analysis(&self) -> Analysis {
-        Analysis {
-            db: self.db.clone(),
-        }
+        Analysis { db: self.db.clone() }
     }
 
     /// Applies changes to the current state of the world. If there are
     /// outstanding snapshots, they will be canceled.
-    pub fn apply_change(&mut self, change: ChangeWithProcMacros) {
+    pub fn apply_change(
+        &mut self,
+        change: ChangeWithProcMacros,
+    ) {
         self.db.apply_change(change);
     }
 
     pub fn per_query_memory_usage(&mut self) -> Vec<(String, profile::Bytes, usize)> {
         self.db.per_query_memory_usage()
     }
+
     pub fn request_cancellation(&mut self) {
         self.db.request_cancellation();
     }
+
     pub fn raw_database(&self) -> &RootDatabase {
         &self.db
     }
+
     pub fn raw_database_mut(&mut self) -> &mut RootDatabase {
         &mut self.db
     }
     db: RootDatabase,
 }
 
-// As a general design guideline, `Analysis` API are intended to be independent
-// from the language server protocol. That is, when exposing some functionality
-// we should think in terms of "what API makes most sense" and not in terms of
-// "what types LSP uses". Although currently LSP is the only consumer of the
-// API, the API should in theory be usable as a library, or via a different
-// protocol.
 impl Analysis {
-    // Creates an analysis instance for a single file, without any external
-    // dependencies, stdlib support or ability to apply changes. See
-    // `AnalysisHost` for creating a fully-featured analysis.
     pub fn from_single_file(text: String) -> (Analysis, FileId) {
         let mut host = AnalysisHost::default();
         let file_id = FileId::from_raw(0);
         let mut file_set = FileSet::default();
         file_set.insert(file_id, VfsPath::new_virtual_path("/main.rs".to_owned()));
         let source_root = SourceRoot::new_local(file_set);
-
         let mut change = ChangeWithProcMacros::default();
         change.set_roots(vec![source_root]);
         let mut crate_graph = CrateGraphBuilder::default();
         // FIXME: cfg options
         // Default to enable test for single file.
         let mut cfg_options = CfgOptions::default();
-
         // FIXME: This is less than ideal
         let proc_macro_cwd = Arc::new(
             TryFrom::try_from(&*std::env::current_dir().unwrap().as_path().to_string_lossy())
             cfg_options,
             None,
             Env::default(),
-            CrateOrigin::Local {
-                repo: None,
-                name: None,
-            },
+            CrateOrigin::Local { repo: None, name: None },
             false,
             proc_macro_cwd,
             Arc::new(CrateWorkspaceData {
         );
         change.change_file(file_id, Some(text));
         change.set_crate_graph(crate_graph);
-
         host.apply_change(change);
         (host.analysis(), file_id)
     }
     ) -> Option<(Analysis, RaFixtureAnalysis)> {
         let analysis =
             RaFixtureAnalysis::analyze_ra_fixture(sema, literal, expanded, minicore, on_cursor)?;
-        Some((
-            Analysis {
-                db: analysis.db.clone(),
-            },
-            analysis,
-        ))
+        Some((Analysis { db: analysis.db.clone() }, analysis))
     }
 
     /// Debug info about the current state of the analysis.
-    pub fn status(&self, file_id: Option<FileId>) -> Cancellable<String> {
+    pub fn status(
+        &self,
+        file_id: Option<FileId>,
+    ) -> Cancellable<String> {
         self.with_db(|db| status::status(db, file_id))
     }
 
-    pub fn source_root_id(&self, file_id: FileId) -> Cancellable<SourceRootId> {
+    pub fn source_root_id(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<SourceRootId> {
         self.with_db(|db| db.file_source_root(file_id).source_root_id(db))
     }
 
-    pub fn is_local_source_root(&self, source_root_id: SourceRootId) -> Cancellable<bool> {
+    pub fn is_local_source_root(
+        &self,
+        source_root_id: SourceRootId,
+    ) -> Cancellable<bool> {
         self.with_db(|db| {
             let sr = db.source_root(source_root_id).source_root(db);
             !sr.is_library
         })
     }
 
-    pub fn parallel_prime_caches<F>(&self, num_worker_threads: usize, cb: F) -> Cancellable<()>
+    pub fn parallel_prime_caches<F>(
+        &self,
+        num_worker_threads: usize,
+        cb: F,
+    ) -> Cancellable<()>
     where
-        F: Fn(ParallelPrimeCachesProgress) + Sync + std::panic::UnwindSafe,
-    {
+        F: Fn(ParallelPrimeCachesProgress) + Sync + std::panic::UnwindSafe, {
         self.with_db(move |db| prime_caches::parallel_prime_caches(db, num_worker_threads, &cb))
     }
 
     /// Gets the text of the source file.
-    pub fn file_text(&self, file_id: FileId) -> Cancellable<Arc<str>> {
+    pub fn file_text(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<Arc<str>> {
         self.with_db(|db| SourceDatabase::file_text(db, file_id).text(db).clone())
     }
 
     /// Gets the syntax tree of the file.
-    pub fn parse(&self, file_id: FileId) -> Cancellable<SourceFile> {
+    pub fn parse(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<SourceFile> {
         // FIXME edition
         self.with_db(|db| {
             let editioned_file_id_wrapper = EditionedFileId::current_edition(&self.db, file_id);
     }
 
     /// Returns true if this file belongs to an immutable library.
-    pub fn is_library_file(&self, file_id: FileId) -> Cancellable<bool> {
+    pub fn is_library_file(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<bool> {
         self.with_db(|db| {
             let source_root = db.file_source_root(file_id).source_root_id(db);
             db.source_root(source_root).source_root(db).is_library
 
     /// Gets the file's `LineIndex`: data structure to convert between absolute
     /// offsets and line/column representation.
-    pub fn file_line_index(&self, file_id: FileId) -> Cancellable<Arc<LineIndex>> {
+    pub fn file_line_index(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<Arc<LineIndex>> {
         self.with_db(|db| db.line_index(file_id))
     }
 
     /// Selects the next syntactic nodes encompassing the range.
-    pub fn extend_selection(&self, frange: FileRange) -> Cancellable<TextRange> {
+    pub fn extend_selection(
+        &self,
+        frange: FileRange,
+    ) -> Cancellable<TextRange> {
         self.with_db(|db| extend_selection::extend_selection(db, frange))
     }
 
     /// Returns position of the matching brace (all types of braces are
     /// supported).
-    pub fn matching_brace(&self, position: FilePosition) -> Cancellable<Option<TextSize>> {
+    pub fn matching_brace(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<Option<TextSize>> {
         self.with_db(|db| {
             let file_id = EditionedFileId::current_edition(&self.db, position.file_id);
             let parse = db.parse(file_id);
         })
     }
 
-    pub fn view_syntax_tree(&self, file_id: FileId) -> Cancellable<String> {
+    pub fn view_syntax_tree(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<String> {
         self.with_db(|db| view_syntax_tree::view_syntax_tree(db, file_id))
     }
 
-    pub fn view_hir(&self, position: FilePosition) -> Cancellable<String> {
+    pub fn view_hir(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<String> {
         self.with_db(|db| view_hir::view_hir(db, position))
     }
 
-    pub fn view_mir(&self, position: FilePosition) -> Cancellable<String> {
+    pub fn view_mir(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<String> {
         self.with_db(|db| view_mir::view_mir(db, position))
     }
 
-    pub fn interpret_function(&self, position: FilePosition) -> Cancellable<String> {
+    pub fn interpret_function(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<String> {
         self.with_db(|db| interpret::interpret(db, position))
     }
 
-    pub fn view_item_tree(&self, file_id: FileId) -> Cancellable<String> {
+    pub fn view_item_tree(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<String> {
         self.with_db(|db| view_item_tree::view_item_tree(db, file_id))
     }
 
         self.with_db(test_explorer::discover_test_roots)
     }
 
-    pub fn discover_tests_in_crate_by_test_id(&self, crate_id: &str) -> Cancellable<Vec<TestItem>> {
+    pub fn discover_tests_in_crate_by_test_id(
+        &self,
+        crate_id: &str,
+    ) -> Cancellable<Vec<TestItem>> {
         self.with_db(|db| test_explorer::discover_tests_in_crate_by_test_id(db, crate_id))
     }
 
-    pub fn discover_tests_in_crate(&self, crate_id: Crate) -> Cancellable<Vec<TestItem>> {
+    pub fn discover_tests_in_crate(
+        &self,
+        crate_id: Crate,
+    ) -> Cancellable<Vec<TestItem>> {
         self.with_db(|db| test_explorer::discover_tests_in_crate(db, crate_id))
     }
 
-    pub fn discover_tests_in_file(&self, file_id: FileId) -> Cancellable<Vec<TestItem>> {
+    pub fn discover_tests_in_file(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<Vec<TestItem>> {
         self.with_db(|db| test_explorer::discover_tests_in_file(db, file_id))
     }
 
     /// Renders the crate graph to GraphViz "dot" syntax.
-    pub fn view_crate_graph(&self, full: bool) -> Cancellable<Result<String, String>> {
+    pub fn view_crate_graph(
+        &self,
+        full: bool,
+    ) -> Cancellable<Result<String, String>> {
         self.with_db(|db| view_crate_graph::view_crate_graph(db, full))
     }
 
         self.with_db(fetch_crates::fetch_crates)
     }
 
-    pub fn expand_macro(&self, position: FilePosition) -> Cancellable<Option<ExpandedMacro>> {
+    pub fn expand_macro(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<Option<ExpandedMacro>> {
         self.with_db(|db| expand_macro::expand_macro(db, position))
     }
 
     /// Returns an edit to remove all newlines in the range, cleaning up minor
     /// stuff like trailing commas.
-    pub fn join_lines(&self, config: &JoinLinesConfig, frange: FileRange) -> Cancellable<TextEdit> {
+    pub fn join_lines(
+        &self,
+        config: &JoinLinesConfig,
+        frange: FileRange,
+    ) -> Cancellable<TextEdit> {
         self.with_db(|db| {
             let editioned_file_id_wrapper =
                 EditionedFileId::current_edition(&self.db, frange.file_id);
     /// Returns an edit which should be applied when opening a new line, fixing
     /// up minor stuff like continuing the comment.
     /// The edit will be a snippet (with `$0`).
-    pub fn on_enter(&self, position: FilePosition) -> Cancellable<Option<TextEdit>> {
+    pub fn on_enter(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<Option<TextEdit>> {
         self.with_db(|db| typing::on_enter(db, position))
     }
 
         if !typing::TRIGGER_CHARS.contains(&char_typed) {
             return Ok(None);
         }
-
         self.with_db(|db| typing::on_char_typed(db, position, char_typed))
     }
 
     ) -> Cancellable<Vec<InlayHint>> {
         self.with_db(|db| inlay_hints::inlay_hints(db, file_id, range, config))
     }
+
     pub fn inlay_hints_resolve(
         &self,
         config: &InlayHintsConfig<'_>,
     }
 
     /// Returns the set of folding ranges.
-    pub fn folding_ranges(&self, file_id: FileId) -> Cancellable<Vec<Fold>> {
+    pub fn folding_ranges(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<Vec<Fold>> {
         self.with_db(|db| {
             let editioned_file_id_wrapper = EditionedFileId::current_edition(&self.db, file_id);
 
     }
 
     /// Fuzzy searches for a symbol.
-    pub fn symbol_search(&self, query: Query, limit: usize) -> Cancellable<Vec<NavigationTarget>> {
+    pub fn symbol_search(
+        &self,
+        query: Query,
+        limit: usize,
+    ) -> Cancellable<Vec<NavigationTarget>> {
         // `world_symbols` currently clones the database to run stuff in parallel, which will make any query panic
         // if we were to attach it here.
         Cancelled::catch(|| {
     }
 
     /// Computes parameter information at the given position.
-    pub fn signature_help(&self, position: FilePosition) -> Cancellable<Option<SignatureHelp>> {
+    pub fn signature_help(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<Option<SignatureHelp>> {
         self.with_db(|db| signature_help::signature_help(db, position))
     }
 
     }
 
     /// Returns a `mod name;` declaration which created the current module.
-    pub fn parent_module(&self, position: FilePosition) -> Cancellable<Vec<NavigationTarget>> {
+    pub fn parent_module(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<Vec<NavigationTarget>> {
         self.with_db(|db| parent_module::parent_module(db, position))
     }
 
     /// Returns vec of `mod name;` declaration which are created by the current module.
-    pub fn child_modules(&self, position: FilePosition) -> Cancellable<Vec<NavigationTarget>> {
+    pub fn child_modules(
+        &self,
+        position: FilePosition,
+    ) -> Cancellable<Vec<NavigationTarget>> {
         self.with_db(|db| child_modules::child_modules(db, position))
     }
 
     /// Returns crates that this file belongs to.
-    pub fn crates_for(&self, file_id: FileId) -> Cancellable<Vec<Crate>> {
+    pub fn crates_for(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<Vec<Crate>> {
         self.with_db(|db| parent_module::crates_for(db, file_id))
     }
 
     /// Returns crates that this file belongs to.
-    pub fn transitive_rev_deps(&self, crate_id: Crate) -> Cancellable<Vec<Crate>> {
+    pub fn transitive_rev_deps(
+        &self,
+        crate_id: Crate,
+    ) -> Cancellable<Vec<Crate>> {
         self.with_db(|db| Vec::from_iter(db.transitive_rev_deps(crate_id)))
     }
 
     /// Returns crates that this file *might* belong to.
-    pub fn relevant_crates_for(&self, file_id: FileId) -> Cancellable<Vec<Crate>> {
+    pub fn relevant_crates_for(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<Vec<Crate>> {
         self.with_db(|db| db.relevant_crates(file_id).iter().copied().collect())
     }
 
     /// Returns the edition of the given crate.
-    pub fn crate_edition(&self, crate_id: Crate) -> Cancellable<Edition> {
+    pub fn crate_edition(
+        &self,
+        crate_id: Crate,
+    ) -> Cancellable<Edition> {
         self.with_db(|db| crate_id.data(db).edition)
     }
 
     /// Returns whether the given crate is a proc macro.
-    pub fn is_proc_macro_crate(&self, crate_id: Crate) -> Cancellable<bool> {
+    pub fn is_proc_macro_crate(
+        &self,
+        crate_id: Crate,
+    ) -> Cancellable<bool> {
         self.with_db(|db| crate_id.data(db).is_proc_macro)
     }
 
     /// Returns true if this crate has `no_std` or `no_core` specified.
-    pub fn is_crate_no_std(&self, crate_id: Crate) -> Cancellable<bool> {
+    pub fn is_crate_no_std(
+        &self,
+        crate_id: Crate,
+    ) -> Cancellable<bool> {
         self.with_db(|db| crate_def_map(db, crate_id).is_no_std())
     }
 
     /// Returns the root file of the given crate.
-    pub fn crate_root(&self, crate_id: Crate) -> Cancellable<FileId> {
+    pub fn crate_root(
+        &self,
+        crate_id: Crate,
+    ) -> Cancellable<FileId> {
         self.with_db(|db| crate_id.data(db).root_file_id)
     }
 
     /// Returns the set of possible targets to run for the current file.
-    pub fn runnables(&self, file_id: FileId) -> Cancellable<Vec<Runnable>> {
+    pub fn runnables(
+        &self,
+        file_id: FileId,
+    ) -> Cancellable<Vec<Runnable>> {
         self.with_db(|db| runnables::runnables(db, file_id))
     }
 
     }
 
     /// Computes syntax highlighting for the given file.
-    pub fn highlight_as_html(&self, file_id: FileId, rainbow: bool) -> Cancellable<String> {
+    pub fn highlight_as_html(
+        &self,
+        file_id: FileId,
+        rainbow: bool,
+    ) -> Cancellable<String> {
         self.with_db(|db| syntax_highlighting::highlight_as_html(db, file_id, rainbow))
     }
 
             Some(it) => it.contains(&AssistKind::QuickFix),
             None => true,
         };
-
         self.with_db(|db| {
             let diagnostic_assists = if diagnostics_config.enabled && include_fixes {
                 ide_diagnostics::full_diagnostics(db, diagnostics_config, &resolve, frange.file_id)
             let mut match_finder =
                 ide_ssr::MatchFinder::in_context(db, resolve_context, selections)?;
             match_finder.add_rule(rule)?;
-            let edits = if parse_only {
-                Default::default()
-            } else {
-                match_finder.edits()
-            };
+            let edits = if parse_only { Default::default() } else { match_finder.edits() };
             Ok(SourceChange::from_iter(edits))
         })
     }
         self.with_db(|db| view_memory_layout(db, position))
     }
 
-    pub fn editioned_file_id_to_vfs(&self, file_id: hir::EditionedFileId) -> FileId {
+    pub fn editioned_file_id_to_vfs(
+        &self,
+        file_id: hir::EditionedFileId,
+    ) -> FileId {
         file_id.file_id(&self.db)
     }
 
     ///
     /// Salsa implements cancellation by unwinding with a special value and
     /// catching it on the API boundary.
-    fn with_db<F, T>(&self, f: F) -> Cancellable<T>
+    fn with_db<F, T>(
+        &self,
+        f: F,
+    ) -> Cancellable<T>
     where
-        F: FnOnce(&RootDatabase) -> T + std::panic::UnwindSafe,
-    {
+        F: FnOnce(&RootDatabase) -> T + std::panic::UnwindSafe, {
         // We use `attach_db_allow_change()` and not `attach_db()` because fixture injection can change the database.
         hir::attach_db_allow_change(&self.db, || Cancelled::catch(|| f(&self.db)))
     }