COMPARISON DIFF
============================================================

Original size: 33665 bytes
Chloro size:   33098 bytes
Rustfmt size:  33868 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! in this crate.
 
 // For proving that RootDatabase is RefUnwindSafe.
-
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 #![recursion_limit = "128"]
 
 #[cfg(test)]
 mod fixture;
-
 mod markup;
 mod navigation_target;
-
 mod annotations;
 mod call_hierarchy;
 mod child_modules;
 
 use cfg::CfgOptions;
 use fetch_crates::CrateInfo;
-use hir::{crate_def_map, sym, ChangeWithProcMacros, EditionedFileId};
+pub use hir::Semantics;
+use hir::{ChangeWithProcMacros, EditionedFileId, crate_def_map, sym};
+pub use ide_assists::{
+    Assist, AssistConfig, AssistId, AssistKind, AssistResolveStrategy, SingleResolve,
+};
+pub use ide_completion::{
+    CallableSnippets, CompletionConfig, CompletionFieldsToResolve, CompletionItem,
+    CompletionItemKind, CompletionItemRefMode, CompletionRelevance, Snippet, SnippetScope,
+};
+pub use ide_db::{
+    assists::ExprFillDefaultMode,
+    base_db::{Crate, CrateGraphBuilder, FileChange, SourceRoot, SourceRootId},
+    documentation::Documentation,
+    label::Label,
+    line_index::{LineCol, LineIndex},
+    prime_caches::ParallelPrimeCachesProgress,
+    search::{ReferenceCategory, SearchScope},
+    source_change::{FileSystemEdit, SnippetEdit, SourceChange},
+    symbol_index::Query,
+    text_edit::{Indel, TextEdit},
+    FileId, FilePosition, FileRange, RootDatabase, Severity, SymbolKind,
+};
 use ide_db::{
     base_db::{
-        salsa::Cancelled, CrateOrigin, CrateWorkspaceData, Env, FileSet, RootQueryDb,
-        SourceDatabase, VfsPath,
+        CrateOrigin, CrateWorkspaceData, Env, FileSet, RootQueryDb, SourceDatabase, VfsPath,
+        salsa::Cancelled,
     },
     prime_caches, symbol_index, FxHashMap, FxIndexSet, LineIndexDatabase,
 };
-use ide_db::{ra_fixture::RaFixtureAnalysis, MiniCore};
+use ide_db::{MiniCore, ra_fixture::RaFixtureAnalysis};
+pub use ide_diagnostics::{Diagnostic, DiagnosticCode, DiagnosticsConfig};
+pub use ide_ssr::SsrError;
 use macros::UpmapFromRaFixture;
-use syntax::{ast, SourceFile};
+pub use span::Edition;
+use syntax::{SourceFile, ast};
+pub use syntax::{TextRange, TextSize};
 use triomphe::Arc;
-use view_memory_layout::{view_memory_layout, RecursiveMemoryLayout};
+use view_memory_layout::{RecursiveMemoryLayout, view_memory_layout};
 
 use crate::navigation_target::ToNav;
-
 pub use crate::{
     annotations::{Annotation, AnnotationConfig, AnnotationKind, AnnotationLocation},
     call_hierarchy::{CallHierarchyConfig, CallItem},
         StaticIndex, StaticIndexedFile, TokenId, TokenStaticData, VendoredLibrariesConfig,
     },
     syntax_highlighting::{
-        tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},
         HighlightConfig, HlRange,
+        tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},
     },
     test_explorer::{TestItem, TestItemKind},
 };
-pub use hir::Semantics;
-pub use ide_assists::{
-    Assist, AssistConfig, AssistId, AssistKind, AssistResolveStrategy, SingleResolve,
-};
-pub use ide_completion::{
-    CallableSnippets, CompletionConfig, CompletionFieldsToResolve, CompletionItem,
-    CompletionItemKind, CompletionItemRefMode, CompletionRelevance, Snippet, SnippetScope,
-};
-pub use ide_db::{
-    assists::ExprFillDefaultMode,
-    base_db::{Crate, CrateGraphBuilder, FileChange, SourceRoot, SourceRootId},
-    documentation::Documentation,
-    label::Label,
-    line_index::{LineCol, LineIndex},
-    prime_caches::ParallelPrimeCachesProgress,
-    search::{ReferenceCategory, SearchScope},
-    source_change::{FileSystemEdit, SnippetEdit, SourceChange},
-    symbol_index::Query,
-    text_edit::{Indel, TextEdit},
-    FileId, FilePosition, FileRange, RootDatabase, Severity, SymbolKind,
-};
-pub use ide_diagnostics::{Diagnostic, DiagnosticCode, DiagnosticsConfig};
-pub use ide_ssr::SsrError;
-pub use span::Edition;
-pub use syntax::{TextRange, TextSize};
 
 pub type Cancellable<T> = Result<T, Cancelled>;
 
 
 impl AnalysisHost {
     pub fn new(lru_capacity: Option<u16>) -> AnalysisHost {
-        AnalysisHost {
-            db: RootDatabase::new(lru_capacity),
-        }
+        AnalysisHost { db: RootDatabase::new(lru_capacity) }
     }
 
     pub fn with_database(db: RootDatabase) -> AnalysisHost {
     /// Returns a snapshot of the current state, which you can query for
     /// semantic information.
     pub fn analysis(&self) -> Analysis {
-        Analysis {
-            db: self.db.clone(),
-        }
+        Analysis { db: self.db.clone() }
     }
 
     /// Applies changes to the current state of the world. If there are
     pub fn per_query_memory_usage(&mut self) -> Vec<(String, profile::Bytes, usize)> {
         self.db.per_query_memory_usage()
     }
+
     pub fn request_cancellation(&mut self) {
         self.db.request_cancellation();
     }
+
     pub fn raw_database(&self) -> &RootDatabase {
         &self.db
     }
+
     pub fn raw_database_mut(&mut self) -> &mut RootDatabase {
         &mut self.db
     }
     db: RootDatabase,
 }
 
-// As a general design guideline, `Analysis` API are intended to be independent
-// from the language server protocol. That is, when exposing some functionality
-// we should think in terms of "what API makes most sense" and not in terms of
-// "what types LSP uses". Although currently LSP is the only consumer of the
-// API, the API should in theory be usable as a library, or via a different
-// protocol.
 impl Analysis {
-    // Creates an analysis instance for a single file, without any external
-    // dependencies, stdlib support or ability to apply changes. See
-    // `AnalysisHost` for creating a fully-featured analysis.
     pub fn from_single_file(text: String) -> (Analysis, FileId) {
         let mut host = AnalysisHost::default();
         let file_id = FileId::from_raw(0);
         let mut file_set = FileSet::default();
         file_set.insert(file_id, VfsPath::new_virtual_path("/main.rs".to_owned()));
         let source_root = SourceRoot::new_local(file_set);
-
         let mut change = ChangeWithProcMacros::default();
         change.set_roots(vec![source_root]);
         let mut crate_graph = CrateGraphBuilder::default();
         // FIXME: cfg options
         // Default to enable test for single file.
         let mut cfg_options = CfgOptions::default();
-
         // FIXME: This is less than ideal
         let proc_macro_cwd = Arc::new(
             TryFrom::try_from(&*std::env::current_dir().unwrap().as_path().to_string_lossy())
             cfg_options,
             None,
             Env::default(),
-            CrateOrigin::Local {
-                repo: None,
-                name: None,
-            },
+            CrateOrigin::Local { repo: None, name: None },
             false,
             proc_macro_cwd,
             Arc::new(CrateWorkspaceData {
         );
         change.change_file(file_id, Some(text));
         change.set_crate_graph(crate_graph);
-
         host.apply_change(change);
         (host.analysis(), file_id)
     }
     ) -> Option<(Analysis, RaFixtureAnalysis)> {
         let analysis =
             RaFixtureAnalysis::analyze_ra_fixture(sema, literal, expanded, minicore, on_cursor)?;
-        Some((
-            Analysis {
-                db: analysis.db.clone(),
-            },
-            analysis,
-        ))
+        Some((Analysis { db: analysis.db.clone() }, analysis))
     }
 
     /// Debug info about the current state of the analysis.
         self.with_db(test_explorer::discover_test_roots)
     }
 
-    pub fn discover_tests_in_crate_by_test_id(&self, crate_id: &str) -> Cancellable<Vec<TestItem>> {
+    pub fn discover_tests_in_crate_by_test_id(
+        &self,
+        crate_id: &str,
+    ) -> Cancellable<Vec<TestItem>> {
         self.with_db(|db| test_explorer::discover_tests_in_crate_by_test_id(db, crate_id))
     }
 
 
     /// Returns an edit to remove all newlines in the range, cleaning up minor
     /// stuff like trailing commas.
-    pub fn join_lines(&self, config: &JoinLinesConfig, frange: FileRange) -> Cancellable<TextEdit> {
+    pub fn join_lines(
+        &self,
+        config: &JoinLinesConfig,
+        frange: FileRange,
+    ) -> Cancellable<TextEdit> {
         self.with_db(|db| {
             let editioned_file_id_wrapper =
                 EditionedFileId::current_edition(&self.db, frange.file_id);
         if !typing::TRIGGER_CHARS.contains(&char_typed) {
             return Ok(None);
         }
-
         self.with_db(|db| typing::on_char_typed(db, position, char_typed))
     }
 
     ) -> Cancellable<Vec<InlayHint>> {
         self.with_db(|db| inlay_hints::inlay_hints(db, file_id, range, config))
     }
+
     pub fn inlay_hints_resolve(
         &self,
         config: &InlayHintsConfig<'_>,
             Some(it) => it.contains(&AssistKind::QuickFix),
             None => true,
         };
-
         self.with_db(|db| {
             let diagnostic_assists = if diagnostics_config.enabled && include_fixes {
                 ide_diagnostics::full_diagnostics(db, diagnostics_config, &resolve, frange.file_id)
             let mut match_finder =
                 ide_ssr::MatchFinder::in_context(db, resolve_context, selections)?;
             match_finder.add_rule(rule)?;
-            let edits = if parse_only {
-                Default::default()
-            } else {
-                match_finder.edits()
-            };
+            let edits = if parse_only { Default::default() } else { match_finder.edits() };
             Ok(SourceChange::from_iter(edits))
         })
     }