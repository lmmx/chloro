COMPARISON DIFF
============================================================

Original size: 18809 bytes
Chloro size:   18543 bytes
Rustfmt size:  18809 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use ide_db::{FxHashSet, syntax_helpers::node_ext::vis_eq};
-use syntax::{
-    Direction, NodeOrToken, SourceFile,
-    SyntaxKind::{self, *},
-    SyntaxNode, TextRange, TextSize,
-    ast::{self, AstNode, AstToken},
-    match_ast,
-};
-
 use std::hash::Hash;
 
+use ide_db::{FxHashSet, syntax_helpers::node_ext::vis_eq};
+use syntax::{
+    ast::{self, AstNode, AstToken},
+    match_ast, Direction, NodeOrToken, SourceFile,
+    SyntaxKind::{self, *},
+    SyntaxNode, TextRange, TextSize,
+};
+
 const REGION_START: &str = "// region:";
+
 const REGION_END: &str = "// endregion";
 
 #[derive(Debug, PartialEq, Eq)]
     ReturnType,
     MatchArm,
     Function,
-    // region: item runs
     Modules,
     Consts,
     Statics,
     TypeAliases,
     ExternCrates,
-    // endregion: item runs
 }
 
 #[derive(Debug)]
     pub kind: FoldKind,
 }
 
-// Feature: Folding
-//
-// Defines folding regions for curly braced blocks, runs of consecutive use, mod, const or static
-// items, and `region` / `endregion` comment markers.
 pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {
     let mut res = vec![];
     let mut visited_comments = FxHashSet::default();
     let mut visited_nodes = FxHashSet::default();
-
     // regions can be nested, here is a LIFO buffer
     let mut region_starts: Vec<TextSize> = vec![];
-
     for element in file.syntax().descendants_with_tokens() {
         // Fold items that span multiple lines
         if let Some(kind) = fold_kind(element.kind()) {
             }
         }
     }
-
     res
 }
 
     if !visited.insert(first.syntax().clone()) {
         return None;
     }
-
     let (mut last, mut last_vis) = (first.clone(), first.visibility());
     for element in first.syntax().siblings_with_tokens(Direction::Next) {
         let node = match element {
         // Stop if we find an item of a different kind or with a different visibility.
         break;
     }
-
     if first != last {
         Some(TextRange::new(first.syntax().text_range().start(), last.syntax().text_range().end()))
     } else {
     visited: &mut FxHashSet<ast::Comment>,
 ) -> Option<TextRange> {
     visited.insert(first.clone());
-
     // Only fold comments of the same flavor
     let group_kind = first.kind();
     if !group_kind.shape.is_line() {
         return None;
     }
-
     let mut last = first.clone();
     for element in first.syntax().siblings_with_tokens(Direction::Next) {
         match element {
             NodeOrToken::Node(_) => break,
         };
     }
-
     if first != last {
         Some(TextRange::new(first.syntax().text_range().start(), last.syntax().text_range().end()))
     } else {
 #[cfg(test)]
 mod tests {
     use test_utils::extract_tags;
-
     use super::*;
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         let (ranges, text) = extract_tags(ra_fixture, "fold");
-
         let parse = SourceFile::parse(&text, span::Edition::CURRENT);
         let mut folds = folding_ranges(&parse.tree());
         folds.sort_by_key(|fold| (fold.range.start(), fold.range.end()));
-
         assert_eq!(
             folds.len(),
             ranges.len(),
             "The amount of folds is different than the expected amount"
         );
-
         for (fold, (range, attr)) in folds.iter().zip(ranges.into_iter()) {
             assert_eq!(fold.range.start(), range.start(), "mismatched start of folding ranges");
             assert_eq!(fold.range.end(), range.end(), "mismatched end of folding ranges");
             assert_eq!(kind, &attr.unwrap());
         }
     }
-
     #[test]
     fn test_fold_func_with_multiline_param_list() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_comments() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_imports() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_mods() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_import_groups() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_import_and_groups() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_folds_structs() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_folds_traits() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_folds_macros() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_match_arms() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_multiline_non_block_match_arm() {
         check(
             "#,
         )
     }
-
     #[test]
     fn fold_big_calls() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_record_literals() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_multiline_params() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_multiline_array() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_region() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_consecutive_const() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_consecutive_static() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_where_clause() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_return_type() {
         check(
 "#,
         )
     }
-
     #[test]
     fn fold_generics() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_fold_doc_comments_with_multiline_paramlist_function() {
         check(