COMPARISON DIFF
============================================================

Original size: 18809 bytes
Chloro size:   18505 bytes
Rustfmt size:  19141 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::hash::Hash;
 
 const REGION_START: &str = "// region:";
+
 const REGION_END: &str = "// endregion";
 
 #[derive(Debug, PartialEq, Eq)]
     Statics,
     TypeAliases,
     ExternCrates,
-    // endregion: item runs
 }
 
 #[derive(Debug)]
                         continue;
                     }
                 }
-                res.push(Fold {
-                    range: element.text_range(),
-                    kind,
-                });
+                res.push(Fold { range: element.text_range(), kind });
                 continue;
             }
         }
                     } else if let Some(range) =
                         contiguous_range_for_comment(comment, &mut visited_comments)
                     {
-                        res.push(Fold {
-                            range,
-                            kind: FoldKind::Comment,
-                        })
+                        res.push(Fold { range, kind: FoldKind::Comment })
                     }
                 }
             }
     }
 
     if first != last {
-        Some(TextRange::new(
-            first.syntax().text_range().start(),
-            last.syntax().text_range().end(),
-        ))
+        Some(TextRange::new(first.syntax().text_range().start(), last.syntax().text_range().end()))
     } else {
         // The group consists of only one element, therefore it cannot be folded
         None
     }
 
     if first != last {
-        Some(TextRange::new(
-            first.syntax().text_range().start(),
-            last.syntax().text_range().end(),
-        ))
+        Some(TextRange::new(first.syntax().text_range().start(), last.syntax().text_range().end()))
     } else {
         // The group consists of only one element, therefore it cannot be folded
         None
 #[cfg(test)]
 mod tests {
     use test_utils::extract_tags;
-
     use super::*;
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         let (ranges, text) = extract_tags(ra_fixture, "fold");
         );
 
         for (fold, (range, attr)) in folds.iter().zip(ranges.into_iter()) {
-            assert_eq!(
-                fold.range.start(),
-                range.start(),
-                "mismatched start of folding ranges"
-            );
-            assert_eq!(
-                fold.range.end(),
-                range.end(),
-                "mismatched end of folding ranges"
-            );
+            assert_eq!(fold.range.start(), range.start(), "mismatched start of folding ranges");
+            assert_eq!(fold.range.end(), range.end(), "mismatched end of folding ranges");
 
             let kind = match fold.kind {
                 FoldKind::Comment => "comment",
             assert_eq!(kind, &attr.unwrap());
         }
     }
-
     #[test]
     fn test_fold_func_with_multiline_param_list() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_comments() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_imports() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_mods() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_import_groups() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_import_and_groups() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_folds_structs() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_folds_traits() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_folds_macros() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_match_arms() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_fold_multiline_non_block_match_arm() {
-        check(
-            r#"
+        check(r#"
             fn main() <fold block>{
                 match foo <fold block>{
                     block => <fold block>{
                     }</fold></fold>,
                 }</fold>
             }</fold>
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn fold_big_calls() {
-        check(
-            r#"
+        check(r#"
 fn main() <fold block>{
     frobnicate<fold arglist>(
         1,
         3,
     )</fold>
 }</fold>
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_record_literals() {
-        check(
-            r#"
+        check(r#"
 const _: S = S <fold block>{
 
 }</fold>;
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_multiline_params() {
-        check(
-            r#"
+        check(r#"
 <fold function>fn foo<fold arglist>(
     x: i32,
     y: String,
 )</fold> {}</fold>
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_multiline_array() {
-        check(
-            r#"
+        check(r#"
 const FOO: [usize; 4] = <fold array>[
     1,
     2,
     3,
     4,
 ]</fold>;
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_region() {
-        check(
-            r#"
+        check(r#"
 // 1. some normal comment
 <fold region>// region: test
 // 2. some normal comment
 // endregion</fold>
 fn f2() {}
 // endregion: test</fold>
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_consecutive_const() {
-        check(
-            r#"
+        check(r#"
 <fold consts>const FIRST_CONST: &str = "first";
 const SECOND_CONST: &str = "second";</fold>
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_consecutive_static() {
-        check(
-            r#"
+        check(r#"
 <fold statics>static FIRST_STATIC: &str = "first";
 static SECOND_STATIC: &str = "second";</fold>
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_where_clause() {
-        check(
-            r#"
+        check(r#"
 fn foo()
 <fold whereclause>where
     A: Foo,
 fn bar()
 <fold whereclause>where
     A: Bar,</fold> {}
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_return_type() {
-        check(
-            r#"
+        check(r#"
 fn foo()<fold returntype>-> (
     bool,
     bool,
 )</fold> { (true, true) }
 
 fn bar() -> (bool, bool) { (true, true) }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn fold_generics() {
-        check(
-            r#"
+        check(r#"
 type Foo<T, U> = foo<fold arglist><
     T,
     U,
 ></fold>;
-"#,
-        )
+"#)
     }
-
     #[test]
     fn test_fold_doc_comments_with_multiline_paramlist_function() {
         check(