COMPARISON DIFF
============================================================

Original size: 18777 bytes
Chloro size:   18411 bytes
Rustfmt size:  18816 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::{iter::once, mem};
 
 use hir::Semantics;
 use ide_db::syntax_helpers::tree_diff::diff;
 use ide_db::text_edit::{TextEdit, TextEditBuilder};
-use ide_db::{helpers::pick_best_token, FileRange, RootDatabase};
+use ide_db::{FileRange, RootDatabase, helpers::pick_best_token};
 use itertools::Itertools;
-use syntax::{ast, match_ast, AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange};
+use syntax::{AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, ast, match_ast};
 
 #[derive(Copy, Clone, Debug)]
 pub enum Direction {
     Down,
 }
 
-// Feature: Move Item
-//
-// Move item under cursor or selection up and down.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Move item up**
-// | VS Code | **rust-analyzer: Move item down**
-//
-// ![Move Item](https://user-images.githubusercontent.com/48062697/113065576-04298180-91b1-11eb-91ce-4505e99ed598.gif)
 pub(crate) fn move_item(
     db: &RootDatabase,
     range: FileRange,
     find_ancestors(item, direction, range.range)
 }
 
-fn find_ancestors(item: SyntaxElement, direction: Direction, range: TextRange) -> Option<TextEdit> {
+fn find_ancestors(
+    item: SyntaxElement,
+    direction: Direction,
+    range: TextRange,
+) -> Option<TextEdit> {
     let root = match item {
         SyntaxElement::Node(node) => node,
         SyntaxElement::Token(token) => token.parent()?,
 #[cfg(test)]
 mod tests {
     use crate::fixture;
-    use expect_test::{expect, Expect};
-
+    use expect_test::{Expect, expect};
     use crate::Direction;
-
     fn check(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         expect: Expect,
         direction: Direction,
     ) {
         let (analysis, range) = fixture::range(ra_fixture);
-        let edit = analysis
-            .move_item(range, direction)
-            .unwrap()
-            .unwrap_or_default();
+        let edit = analysis.move_item(range, direction).unwrap().unwrap_or_default();
         let mut file = analysis.file_text(range.file_id).unwrap().to_string();
         edit.apply(&mut file);
         expect.assert_eq(&file);
     }
-
     #[test]
     fn test_moves_match_arm_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_match_arm_down() {
         check(
             Direction::Down,
         );
     }
-
     #[test]
     fn test_nowhere_to_move() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_let_stmt_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_expr_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_nowhere_to_move_stmt() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_move_item() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_move_impl_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_move_use_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_match_expr_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_param() {
         check(
             Direction::Down,
         );
     }
-
     #[test]
     fn test_moves_arg_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_arg_down() {
         check(
             Direction::Down,
         );
     }
-
     #[test]
     fn test_nowhere_to_move_arg() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_generic_param_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_generic_arg_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_variant_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_moves_type_bound_up() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_prioritizes_trait_items() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_weird_nesting() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_cursor_at_item_start() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn test_cursor_at_item_end() {
         check(
             Direction::Up,
         );
     }
-
     #[test]
     fn handles_empty_file() {
         check(r#"$0$0"#, expect![[r#""#]], Direction::Up);