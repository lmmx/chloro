COMPARISON DIFF
============================================================

Original size: 18328 bytes
Chloro size:   18329 bytes
Rustfmt size:  18564 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     search::FileReference,
     FileRange, FxIndexMap, MiniCore, RootDatabase,
 };
-use syntax::{ast, AstNode, SyntaxKind::IDENT};
+use syntax::{AstNode, SyntaxKind::IDENT, ast};
 
 use crate::{
     goto_definition, FilePosition, GotoDefinitionConfig, NavigationTarget, RangeInfo, TryToNav,
     goto_definition::goto_definition(
         db,
         position,
-        &GotoDefinitionConfig {
-            minicore: config.minicore,
-        },
+        &GotoDefinitionConfig { minicore: config.minicore },
     )
 }
 
     FilePosition { file_id, offset }: FilePosition,
 ) -> Option<Vec<CallItem>> {
     let sema = &Semantics::new(db);
-
     let file = sema.parse_guess_edition(file_id);
     let file = file.syntax();
     let mut calls = CallLocations::default();
-
     let references = sema
         .find_nodes_at_offset_with_descend(file, offset)
         .filter_map(move |node| match node {
             ast::NameLike::Lifetime(_) => None,
         })
         .flat_map(|func| func.usages(sema).all());
-
     for (_, references) in references {
-        let references = references
-            .iter()
-            .filter_map(|FileReference { name, .. }| name.as_name_ref());
+        let references =
+            references.iter().filter_map(|FileReference { name, .. }| name.as_name_ref());
         for name in references {
             // This target is the containing function
-            let def_nav = sema
-                .ancestors_with_macros(name.syntax().clone())
-                .find_map(|node| {
-                    let def = ast::Fn::cast(node).and_then(|fn_| sema.to_def(&fn_))?;
-                    // We should return def before check if it is a test, so that we
-                    // will not continue to search for outer fn in nested fns
-                    def.try_to_nav(sema).map(|nav| (def, nav))
-                });
+            let def_nav = sema.ancestors_with_macros(name.syntax().clone()).find_map(|node| {
+                let def = ast::Fn::cast(node).and_then(|fn_| sema.to_def(&fn_))?;
+                // We should return def before check if it is a test, so that we
+                // will not continue to search for outer fn in nested fns
+                def.try_to_nav(sema).map(|nav| (def, nav))
+            });
 
             if let Some((def, nav)) = def_nav {
                 if config.exclude_tests && def.is_test(db) {
             }
         }
     }
-
     Some(calls.into_items())
 }
 
         _ => 0,
     })?;
     let mut calls = CallLocations::default();
-
     sema.descend_into_macros_exact(token)
         .into_iter()
         .filter_map(|it| it.parent_ancestors().nth(1).and_then(ast::Item::cast))
         })
         .flatten()
         .for_each(|(nav, range)| calls.add(nav, range.into_file_id(db)));
-
     Some(calls.into_items())
 }
 
 }
 
 impl CallLocations {
-    fn add(&mut self, target: NavigationTarget, range: FileRange) {
+    fn add(
+        &mut self,
+        target: NavigationTarget,
+        range: FileRange,
+    ) {
         self.funcs.entry(target).or_default().push(range);
     }
 
     fn into_items(self) -> Vec<CallItem> {
-        self.funcs
-            .into_iter()
-            .map(|(target, ranges)| CallItem { target, ranges })
-            .collect()
+        self.funcs.into_iter().map(|(target, ranges)| CallItem { target, ranges }).collect()
     }
 }
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{expect, Expect};
+    use expect_test::{Expect, expect};
     use ide_db::{FilePosition, MiniCore};
     use itertools::Itertools;
-
     use crate::fixture;
-
     fn check_hierarchy(
         exclude_tests: bool,
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
             format!(
                 "{} : {}",
                 item.target.debug_render(),
-                item.ranges
-                    .iter()
-                    .format_with(", ", |range, f| f(&format_args!(
-                        "{:?}:{:?}",
-                        range.file_id, range.range
-                    )))
+                item.ranges.iter().format_with(", ", |range, f| f(&format_args!(
+                    "{:?}:{:?}",
+                    range.file_id, range.range
+                )))
             )
         }
-
-        let config = crate::CallHierarchyConfig {
-            exclude_tests,
-            minicore: MiniCore::default(),
-        };
+        let config = crate::CallHierarchyConfig { exclude_tests, minicore: MiniCore::default() };
         let (analysis, pos) = fixture::position(ra_fixture);
-
         let mut navs = analysis.call_hierarchy(pos, &config).unwrap().unwrap().info;
         assert_eq!(navs.len(), 1);
         let nav = navs.pop().unwrap();
         expected_nav.assert_eq(&nav.debug_render());
-
-        let item_pos = FilePosition {
-            file_id: nav.file_id,
-            offset: nav.focus_or_full_range().start(),
-        };
+        let item_pos =
+            FilePosition { file_id: nav.file_id, offset: nav.focus_or_full_range().start() };
         let incoming_calls = analysis.incoming_calls(&config, item_pos).unwrap().unwrap();
         expected_incoming.assert_eq(&incoming_calls.into_iter().map(debug_render).join("\n"));
-
         let outgoing_calls = analysis.outgoing_calls(&config, item_pos).unwrap().unwrap();
         expected_outgoing.assert_eq(&outgoing_calls.into_iter().map(debug_render).join("\n"));
     }
-
     #[test]
     fn test_call_hierarchy_on_ref() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_on_def() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_in_same_fn() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_in_different_fn() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_in_tests_mod() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_in_different_files() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_outgoing() {
         check_hierarchy(
             expect!["callee Function FileId(0) 0..14 3..9 : FileId(0):33..39, FileId(0):47..53"],
         );
     }
-
     #[test]
     fn test_call_hierarchy_outgoing_in_different_files() {
         check_hierarchy(
             expect!["callee Function FileId(1) 0..18 7..13 foo : FileId(0):45..51"],
         );
     }
-
     #[test]
     fn test_call_hierarchy_incoming_outgoing() {
         check_hierarchy(
             expect!["caller3 Function FileId(0) 66..83 69..76 : FileId(0):52..59"],
         );
     }
-
     #[test]
     fn test_call_hierarchy_issue_5103() {
         check_hierarchy(
             expect!["main Function FileId(0) 31..52 34..38 : FileId(0):47..48"],
             expect!["b Function FileId(0) 20..29 23..24 : FileId(0):13..14"],
         );
-
         check_hierarchy(
             false,
             r#"
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_in_macros_incoming() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_in_macros_outgoing() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_in_macros_incoming_different_files() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_in_macros_outgoing_different_files() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_trait_method_call_hierarchy() {
         check_hierarchy(
             expect![[]],
         );
     }
-
     #[test]
     fn test_call_hierarchy_excluding_tests() {
         check_hierarchy(
                 f2 Function FileId(0) 54..81 57..59 : FileId(0):39..41
                 f3 Function FileId(0) 83..118 94..96 : FileId(0):45..47"#]],
         );
-
         check_hierarchy(
             true,
             r#"