COMPARISON DIFF
============================================================

Original size: 23884 bytes
Chloro size:   23818 bytes
Rustfmt size:  23884 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Implementation of "adjustment" inlay hints:
 //! ```no_run
 //! let _: u32  = /* <never-to-any> */ loop {};
 //! let _: &u32 = /* &* */ &mut 0;
 //! ```
+
 use std::ops::Not;
 
 use either::Either;
     PointerCast, Safety,
 };
 use ide_db::famous_defs::FamousDefs;
-
 use ide_db::text_edit::TextEditBuilder;
 use syntax::ast::{self, AstNode, prec::ExprPrecedence};
 
     if config.adjustment_hints_hide_outside_unsafe && !sema.is_inside_unsafe(expr) {
         return None;
     }
-
     if config.adjustment_hints == AdjustmentHints::Never {
         return None;
     }
-
     // ParenExpr resolve to their contained expressions HIR so they will dupe these hints
     if let ast::Expr::ParenExpr(_) = expr {
         return None;
     {
         return None;
     }
-
     let descended = sema.descend_node_into_attributes(expr.clone()).pop();
     let desc_expr = descended.as_ref().unwrap_or(expr);
     let mut adjustments = sema.expr_adjustments(desc_expr).filter(|it| !it.is_empty())?;
-
     if config.adjustment_hints_disable_reborrows {
         // Remove consecutive deref-ref, i.e. reborrows.
         let mut i = 0;
             }
         }
     }
-
     if let ast::Expr::BlockExpr(_) | ast::Expr::IfExpr(_) | ast::Expr::MatchExpr(_) = desc_expr {
         // Don't show unnecessary reborrows for these, they will just repeat the inner ones again
         if matches!(
             return None;
         }
     }
-
     let (postfix, needs_outer_parens, needs_inner_parens) =
         mode_and_needs_parens_for_adjustment_hints(expr, config.adjustment_hints_mode);
-
     let range = expr.syntax().text_range();
     let mut pre = InlayHint {
         range,
         text_edit: None,
         resolve_parent: Some(range),
     };
-
     if needs_outer_parens || (postfix && needs_inner_parens) {
         pre.label.append_str("(");
     }
-
     if postfix && needs_inner_parens {
         post.label.append_str(")");
     }
-
     let mut iter = if postfix {
         Either::Left(adjustments.into_iter())
     } else {
         Either::Right(adjustments.into_iter().rev())
     };
     let iter: &mut dyn Iterator<Item = _> = iter.as_mut().either(|it| it as _, |it| it as _);
-
     let mut has_adjustments = false;
     let mut allow_edit = !postfix;
     for Adjustment { source, target, kind } in iter {
     if !has_adjustments {
         return None;
     }
-
     if !postfix && needs_inner_parens {
         pre.label.append_str("(");
     }
     if needs_outer_parens || (!postfix && needs_inner_parens) {
         post.label.append_str(")");
     }
-
     let mut pre = pre.label.parts.is_empty().not().then_some(pre);
     let mut post = post.label.parts.is_empty().not().then_some(post);
     if pre.is_none() && post.is_none() {
     mode: AdjustmentHintsMode,
 ) -> (bool, bool, bool) {
     use {AdjustmentHintsMode::*, std::cmp::Ordering::*};
-
     match mode {
         Prefix | Postfix => {
             let postfix = matches!(mode, Postfix);
 
 /// Returns whatever we need to add parentheses on the inside and/or outside of `expr`,
 /// if we are going to add (`postfix`) adjustments hints to it.
-fn needs_parens_for_adjustment_hints(expr: &ast::Expr, postfix: bool) -> (bool, bool) {
+fn needs_parens_for_adjustment_hints(
+    expr: &ast::Expr,
+    postfix: bool,
+) -> (bool, bool) {
     let prec = expr.precedence();
     if postfix {
         let needs_inner_parens = prec.needs_parentheses_in(ExprPrecedence::Postfix);
 #[cfg(test)]
 mod tests {
     use crate::{
-        AdjustmentHints, AdjustmentHintsMode, InlayHintsConfig,
-        inlay_hints::tests::{DISABLED_CONFIG, check_with_config},
-    };
+        check_with_config},
 
+        inlay_hints::tests::{DISABLED_CONFIG,
+
+        AdjustmentHints, AdjustmentHintsMode, InlayHintsConfig,
+    };
     #[test]
     fn adjustment_hints_prefix() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn adjustment_hints_postfix() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn adjustment_hints_prefer_prefix() {
         check_with_config(
             "#,
         )
     }
-
     #[test]
     fn adjustment_hints_prefer_postfix() {
         check_with_config(
             "#,
         )
     }
-
     #[test]
     fn never_to_never_is_never_shown() {
         cov_mark::check!(same_type_adjustment);
             "#,
         )
     }
-
     #[test]
     fn adjustment_hints_unsafe_only() {
         check_with_config(
             "#,
         )
     }
-
     #[test]
     fn adjustment_hints_unsafe_only_with_item() {
         check_with_config(
             "#,
         );
     }
-
     #[test]
     fn let_stmt_explicit_ty() {
         check_with_config(
             "#,
         )
     }
-
-    // regression test for a stackoverflow in hir display code
     #[test]
     fn adjustment_hints_method_call_on_impl_trait_self() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn disable_reborrows() {
         check_with_config(