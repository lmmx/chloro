COMPARISON DIFF
============================================================

Original size: 2643 bytes
Chloro size:   2709 bytes
Rustfmt size:  2800 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Collects a tree of highlighted ranges and flattens it.
+
 use std::iter;
 
 use stdx::equal_range_by;
 impl Highlights {
     pub(super) fn new(range: TextRange) -> Highlights {
         Highlights {
-            root: Node::new(HlRange {
-                range,
-                highlight: HlTag::None.into(),
-                binding_hash: None,
-            }),
+            root: Node::new(HlRange { range, highlight: HlTag::None.into(), binding_hash: None }),
         }
     }
 
-    pub(super) fn add(&mut self, hl_range: HlRange) {
+    pub(super) fn add(
+        &mut self,
+        hl_range: HlRange,
+    ) {
         self.root.add(hl_range);
     }
 
 
 impl Node {
     fn new(hl_range: HlRange) -> Node {
-        Node {
-            hl_range,
-            nested: Vec::new(),
-        }
+        Node { hl_range, nested: Vec::new() }
     }
 
-    fn add(&mut self, hl_range: HlRange) {
+    fn add(
+        &mut self,
+        hl_range: HlRange,
+    ) {
         assert!(self.hl_range.range.contains_range(hl_range.range));
-
         // Fast path
         if let Some(last) = self.nested.last_mut() {
             if last.hl_range.range.contains_range(hl_range.range) {
                 return self.nested.push(Node::new(hl_range));
             }
         }
-
-        let overlapping = equal_range_by(&self.nested, |n| {
-            TextRange::ordering(n.hl_range.range, hl_range.range)
-        });
-
+        let overlapping =
+            equal_range_by(&self.nested, |n| TextRange::ordering(n.hl_range.range, hl_range.range));
         if overlapping.len() == 1
-            && self.nested[overlapping.start]
-                .hl_range
-                .range
-                .contains_range(hl_range.range)
+            && self.nested[overlapping.start].hl_range.range.contains_range(hl_range.range)
         {
             return self.nested[overlapping.start].add(hl_range);
         }
-
         let nested = self
             .nested
             .splice(overlapping.clone(), iter::once(Node::new(hl_range)))
         self.nested[overlapping.start].nested = nested;
     }
 
-    fn flatten(&self, acc: &mut Vec<HlRange>) {
+    fn flatten(
+        &self,
+        acc: &mut Vec<HlRange>,
+    ) {
         let mut start = self.hl_range.range.start();
         let mut nested = self.nested.iter();
         loop {