COMPARISON DIFF
============================================================

Original size: 17157 bytes
Chloro size:   16989 bytes
Rustfmt size:  17157 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Implementation of "lifetime elision" inlay hints:
 //! ```no_run
 //! fn example/* <'0> */(a: &/* '0 */()) {}
 //! ```
+
 use std::iter;
 
-use ide_db::{FxHashMap, famous_defs::FamousDefs, syntax_helpers::node_ext::walk_ty};
+use ide_db::{famous_defs::FamousDefs, syntax_helpers::node_ext::walk_ty, FxHashMap};
 use itertools::Itertools;
-use syntax::{SmolStr, format_smolstr};
 use syntax::{
-    SyntaxKind, SyntaxToken,
     ast::{self, AstNode, HasGenericParams, HasName},
+    SyntaxKind, SyntaxToken,
 };
+use syntax::{format_smolstr, SmolStr};
 
 use crate::{
-    InlayHint, InlayHintPosition, InlayHintsConfig, InlayKind, LifetimeElisionHints,
-    inlay_hints::InlayHintCtx,
+    inlay_hints::InlayHintCtx, InlayHint, InlayHintPosition, InlayHintsConfig, InlayKind,
+    LifetimeElisionHints,
 };
 
 pub(super) fn fn_hints(
         fd,
         config,
         param_list.params().filter_map(|it| {
-            Some((
-                it.pat().and_then(|it| match it {
-                    ast::Pat::IdentPat(p) => p.name(),
-                    _ => None,
-                }),
-                it.ty()?,
-            ))
+        Some((
+            it.pat().and_then(|it| match it {
+            ast::Pat::IdentPat(p) => p.name(),
+            _ => None,
         }),
+            it.ty()?,
+        ))
+    }),
         generic_param_list,
         ret_type,
         self_param,
         |acc, allocated_lifetimes| {
-            acc.push(InlayHint {
-                range: gpl_append_range,
-                kind: InlayKind::GenericParamList,
-                label: format!("<{}>", allocated_lifetimes.iter().format(", "),).into(),
-                text_edit: None,
-                position: InlayHintPosition::After,
-                pad_left: false,
-                pad_right: false,
-                resolve_parent: None,
-            })
-        },
+        acc.push(InlayHint {
+            range: gpl_append_range,
+            kind: InlayKind::GenericParamList,
+            label: format!("<{}>", allocated_lifetimes.iter().format(", "),).into(),
+            text_edit: None,
+            position: InlayHintPosition::After,
+            pad_left: false,
+            pad_right: false,
+            resolve_parent: None,
+        })
+    },
         true,
     )
 }
         fd,
         config,
         param_list.params().filter_map(|it| {
-            Some((
-                it.pat().and_then(|it| match it {
-                    ast::Pat::IdentPat(p) => p.name(),
-                    _ => None,
-                }),
-                it.ty()?,
-            ))
+        Some((
+            it.pat().and_then(|it| match it {
+            ast::Pat::IdentPat(p) => p.name(),
+            _ => None,
         }),
+            it.ty()?,
+        ))
+    }),
         generic_param_list,
         ret_type,
         None,
         |acc, allocated_lifetimes| {
-            let has_for = for_kw.is_some();
-            let for_ = if has_for { "" } else { "for" };
-            acc.push(InlayHint {
+        let has_for = for_kw.is_some();
+        let for_ = if has_for { "" } else { "for" };
+        acc.push(InlayHint {
                 range: for_kw.map_or_else(
                     || func.syntax().first_token().unwrap().text_range(),
                     |it| it.text_range(),
                 pad_right: true,
                 resolve_parent: None,
             });
-        },
+    },
         false,
     )
 }
         ret_type,
         None,
         |acc, allocated_lifetimes| {
-            let has_for = for_kw.is_some();
-            let for_ = if has_for { "" } else { "for" };
-            acc.push(InlayHint {
+        let has_for = for_kw.is_some();
+        let for_ = if has_for { "" } else { "for" };
+        acc.push(InlayHint {
                 range: for_kw.map_or_else(
                     || func.syntax().first_token().unwrap().text_range(),
                     |it| it.text_range(),
                 pad_right: true,
                 resolve_parent: None,
             });
-        },
+    },
         false,
     )
 }
     }
 
     // apply hints
+
     // apply output if required
     if let (Some(output_lt), Some(r)) = (&output, ret_type)
         && let Some(ty) = r.ty()
 #[cfg(test)]
 mod tests {
     use crate::{
+        inlay_hints::tests::{check, check_with_config, TEST_CONFIG},
         InlayHintsConfig, LifetimeElisionHints,
-        inlay_hints::tests::{TEST_CONFIG, check, check_with_config},
     };
-
     #[test]
     fn hints_lifetimes() {
         check(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_named() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_trivial_skip() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn no_collide() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_fn_ptr() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_in_non_gen_defs() {
         check_with_config(