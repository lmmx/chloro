COMPARISON DIFF
============================================================

Original size: 17157 bytes
Chloro size:   17152 bytes
Rustfmt size:  17157 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Implementation of "lifetime elision" inlay hints:
 //! ```no_run
 //! fn example/* <'0> */(a: &/* '0 */()) {}
 //! ```
+
 use std::iter;
 
 use ide_db::{FxHashMap, famous_defs::FamousDefs, syntax_helpers::node_ext::walk_ty};
 use itertools::Itertools;
-use syntax::{SmolStr, format_smolstr};
 use syntax::{
-    SyntaxKind, SyntaxToken,
     ast::{self, AstNode, HasGenericParams, HasName},
+    SyntaxKind, SyntaxToken,
 };
+use syntax::{SmolStr, format_smolstr};
 
 use crate::{
-    InlayHint, InlayHintPosition, InlayHintsConfig, InlayKind, LifetimeElisionHints,
-    inlay_hints::InlayHintCtx,
+    inlay_hints::InlayHintCtx, InlayHint, InlayHintPosition, InlayHintsConfig, InlayKind,
+    LifetimeElisionHints,
 };
 
 pub(super) fn fn_hints(
     if config.lifetime_elision_hints == LifetimeElisionHints::Never {
         return None;
     }
-
     // FIXME: Support general path types
+
     let (param_list, ret_type) = func.path().as_ref().and_then(path_as_fn)?;
     let parent_for_binder = func
         .syntax()
             allocated_lifetimes.push(name);
         });
     }
-
     // fetch output lifetime if elision rule applies
+
     let output = match potential_lt_refs.as_slice() {
         [(_, _, lifetime, _), ..] if self_param.is_some() || potential_lt_refs.len() == 1 => {
             match lifetime {
     if allocated_lifetimes.is_empty() && output.is_none() {
         return None;
     }
-
     // apply hints
     // apply output if required
+
     if let (Some(output_lt), Some(r)) = (&output, ret_type)
         && let Some(ty) = r.ty()
     {
             acc.push(mk_lt_hint(t, lt.to_string()));
         }
     }
-
     // generate generic param list things
+
     match (generic_param_list, allocated_lifetimes.as_slice()) {
         (_, []) => (),
         (Some(gpl), allocated_lifetimes) => {
 #[cfg(test)]
 mod tests {
     use crate::{
+        inlay_hints::tests::{check, check_with_config, TEST_CONFIG},
         InlayHintsConfig, LifetimeElisionHints,
-        inlay_hints::tests::{TEST_CONFIG, check, check_with_config},
     };
-
     #[test]
     fn hints_lifetimes() {
         check(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_named() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_trivial_skip() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn no_collide() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_fn_ptr() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_in_non_gen_defs() {
         check_with_config(