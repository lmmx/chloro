COMPARISON DIFF
============================================================

Original size: 23725 bytes
Chloro size:   23704 bytes
Rustfmt size:  24122 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Implementation of "chaining" inlay hints.
+
 use hir::DisplayTarget;
 use ide_db::famous_defs::FamousDefs;
 use syntax::{
 mod tests {
     use expect_test::{Expect, expect};
     use ide_db::text_edit::{TextRange, TextSize};
-
     use crate::{
         InlayHintsConfig, fixture,
         inlay_hints::{
-            LazyProperty,
-            tests::{DISABLED_CONFIG, TEST_CONFIG, check_expect, check_with_config},
+            LazyProperty, tests::{DISABLED_CONFIG, TEST_CONFIG, check_expect, check_with_config},
         },
     };
-
     #[track_caller]
     fn check_chains(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
-        check_with_config(
-            InlayHintsConfig {
-                chaining_hints: true,
-                ..DISABLED_CONFIG
-            },
-            ra_fixture,
-        );
+        check_with_config(InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG }, ra_fixture);
     }
-
     #[track_caller]
     pub(super) fn check_expect_clear_loc(
         config: InlayHintsConfig<'_>,
     ) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let mut inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
-        inlay_hints
-            .iter_mut()
-            .flat_map(|hint| &mut hint.label.parts)
-            .for_each(|hint| {
-                if let Some(LazyProperty::Computed(loc)) = &mut hint.linked_location {
-                    loc.range = TextRange::empty(TextSize::from(0));
-                }
-            });
-        let filtered = inlay_hints
-            .into_iter()
-            .map(|hint| (hint.range, hint.label))
-            .collect::<Vec<_>>();
+        inlay_hints.iter_mut().flat_map(|hint| &mut hint.label.parts).for_each(|hint| {
+            if let Some(LazyProperty::Computed(loc)) = &mut hint.linked_location {
+                loc.range = TextRange::empty(TextSize::from(0));
+            }
+        });
+        let filtered =
+            inlay_hints.into_iter().map(|hint| (hint.range, hint.label)).collect::<Vec<_>>();
         expect.assert_debug_eq(&filtered)
     }
-
     #[test]
     fn chaining_hints_ignore_comments() {
         check_expect(
-            InlayHintsConfig {
-                type_hints: false,
-                chaining_hints: true,
-                ..DISABLED_CONFIG
-            },
+            InlayHintsConfig { type_hints: false, chaining_hints: true, ..DISABLED_CONFIG },
             r#"
 struct A(B);
 impl A { fn into_b(self) -> B { self.0 } }
             "#]],
         );
     }
-
     #[test]
     fn chaining_hints_without_newlines() {
         check_chains(
 }"#,
         );
     }
-
     #[test]
     fn disabled_location_links() {
         check_expect(
-            InlayHintsConfig {
-                chaining_hints: true,
-                ..DISABLED_CONFIG
-            },
+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },
             r#"
     struct A { pub b: B }
     struct B { pub c: C }
             "#]],
         );
     }
-
     #[test]
     fn struct_access_chaining_hints() {
         check_expect(
-            InlayHintsConfig {
-                chaining_hints: true,
-                ..DISABLED_CONFIG
-            },
+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },
             r#"
 struct A { pub b: B }
 struct B { pub c: C }
             "#]],
         );
     }
-
     #[test]
     fn generic_chaining_hints() {
         check_expect(
-            InlayHintsConfig {
-                chaining_hints: true,
-                ..DISABLED_CONFIG
-            },
+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },
             r#"
 struct A<T>(T);
 struct B<T>(T);
             "#]],
         );
     }
-
     #[test]
     fn shorten_iterator_chaining_hints() {
         check_expect_clear_loc(
-            InlayHintsConfig {
-                chaining_hints: true,
-                ..DISABLED_CONFIG
-            },
+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },
             r#"
 //- minicore: iterators
 use core::iter;
             "#]],
         );
     }
-
     #[test]
     fn hints_in_attr_call() {
         check_expect(