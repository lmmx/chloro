COMPARISON DIFF
============================================================

Original size: 23725 bytes
Chloro size:   23738 bytes
Rustfmt size:  23725 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Implementation of "chaining" inlay hints.
+
 use hir::DisplayTarget;
 use ide_db::famous_defs::FamousDefs;
 use syntax::{
-    Direction, NodeOrToken, SyntaxKind, T,
     ast::{self, AstNode},
+    Direction, NodeOrToken, SyntaxKind, T,
 };
 
 use crate::{InlayHint, InlayHintPosition, InlayHintsConfig, InlayKind};
-
 use super::label_of_ty;
 
 pub(super) fn hints(
         });
 
     // Chaining can be defined as an expression whose next sibling tokens are newline and dot
+
     // Ignoring extra whitespace and comments
     let next = tokens.next()?.kind();
     if next == SyntaxKind::WHITESPACE {
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{Expect, expect};
+    use expect_test::{expect, Expect};
     use ide_db::text_edit::{TextRange, TextSize};
-
     use crate::{
-        InlayHintsConfig, fixture,
+        fixture,
         inlay_hints::{
-            LazyProperty,
-            tests::{DISABLED_CONFIG, TEST_CONFIG, check_expect, check_with_config},
+            tests::{DISABLED_CONFIG, TEST_CONFIG, check_expect, check_with_config}, LazyProperty,
         },
+        InlayHintsConfig,
     };
-
     #[track_caller]
     fn check_chains(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG }, ra_fixture);
     }
-
     #[track_caller]
     pub(super) fn check_expect_clear_loc(
         config: InlayHintsConfig<'_>,
     ) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let mut inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
-        inlay_hints.iter_mut().flat_map(|hint| &mut hint.label.parts).for_each(|hint| {
+        inlay_hints.iter_mut()
+            .flat_map(|hint| &mut hint.label.parts)
+            .for_each(|hint| {
             if let Some(LazyProperty::Computed(loc)) = &mut hint.linked_location {
                 loc.range = TextRange::empty(TextSize::from(0));
             }
             inlay_hints.into_iter().map(|hint| (hint.range, hint.label)).collect::<Vec<_>>();
         expect.assert_debug_eq(&filtered)
     }
-
     #[test]
     fn chaining_hints_ignore_comments() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn chaining_hints_without_newlines() {
         check_chains(
 }"#,
         );
     }
-
     #[test]
     fn disabled_location_links() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn struct_access_chaining_hints() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn generic_chaining_hints() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn shorten_iterator_chaining_hints() {
         check_expect_clear_loc(
             "#]],
         );
     }
-
     #[test]
     fn hints_in_attr_call() {
         check_expect(