COMPARISON DIFF
============================================================

Original size: 31554 bytes
Chloro size:   30406 bytes
Rustfmt size:  31554 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Extracts, resolves and rewrites links and intra-doc links in markdown documentation.
 
 #[cfg(test)]
 mod tests;
-
 mod intra_doc_links;
 
 use std::ops::Range;
 
-use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};
-use pulldown_cmark_to_cmark::{Options as CMarkOptions, cmark_resume_with_options};
-use stdx::format_to;
-use url::Url;
-
 use hir::{
-    Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrsWithOwner, HasAttrs, db::HirDatabase, sym,
+    db::HirDatabase, sym, Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrsWithOwner,
+    HasAttrs,
 };
 use ide_db::{
-    RootDatabase,
     base_db::{CrateOrigin, LangCrateOrigin, ReleaseChannel, RootQueryDb},
     defs::{Definition, NameClass, NameRefClass},
-    documentation::{DocsRangeMap, Documentation, HasDocs, docs_with_rangemap},
+    documentation::{docs_with_rangemap, DocsRangeMap, Documentation, HasDocs},
     helpers::pick_best_token,
+    RootDatabase,
 };
+use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};
+use pulldown_cmark_to_cmark::{cmark_resume_with_options, Options as CMarkOptions};
+use stdx::format_to;
 use syntax::{
-    AstNode, AstToken,
-    SyntaxKind::*,
-    SyntaxNode, SyntaxToken, T, TextRange, TextSize,
     ast::{self, IsString},
-    match_ast,
+    match_ast, AstNode, AstToken,
+    SyntaxKind::*,
+    SyntaxNode, SyntaxToken, TextRange, TextSize, T,
 };
+use url::Url;
 
 use crate::{
-    FilePosition, Semantics,
     doc_links::intra_doc_links::{parse_intra_doc_link, strip_prefixes_suffixes},
+    FilePosition, Semantics,
 };
 
 /// Web and local links to an item's documentation.
     pub local_url: Option<String>,
 }
 
-const MARKDOWN_OPTIONS: Options =
-    Options::ENABLE_FOOTNOTES.union(Options::ENABLE_TABLES).union(Options::ENABLE_TASKLISTS);
+const MARKDOWN_OPTIONS: Options = Options::ENABLE_FOOTNOTES.union(Options::ENABLE_TABLES).union(Options::ENABLE_TASKLISTS);
 
 /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)
 pub(crate) fn rewrite_links(
     out
 }
 
-// Feature: Open Docs
-//
-// Retrieve a links to documentation for the given symbol.
-//
-// The simplest way to use this feature is via the context menu. Right-click on
-// the selected item. The context menu opens. Select **Open Docs**.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Open Docs** |
 pub(crate) fn external_docs(
     db: &RootDatabase,
     FilePosition { file_id, offset }: FilePosition,
         docs.as_str(),
         MARKDOWN_OPTIONS,
         Some(&mut broken_link_clone_cb),
-    )
-    .into_offset_iter()
-    .filter_map(|(event, range)| match event {
+    ).into_offset_iter(
+    ).filter_map(|(event, range)| match event {
         Event::Start(Tag::Link(_, target, _)) => {
             let (link, ns) = parse_intra_doc_link(&target);
             Some((
                 link.to_owned(),
                 ns,
             ))
-        }
+        },
         _ => None,
-    })
-    .collect()
+    }).collect(
+    )
 }
 
 pub(crate) fn resolve_doc_path_for_def(
         | Definition::DeriveHelper(_)
         | Definition::InlineAsmRegOrRegClass(_)
         | Definition::InlineAsmOperand(_) => None,
-    }
-    .map(Definition::from)
+    }.map(
+        Definition::from,
+    )
 }
 
 pub(crate) fn doc_attributes(
             },
             _ => None,
         }
-    }).map(|prefix_len| DocCommentToken { prefix_len, doc_token: doc_token.clone() })
+    }).map(
+        |prefix_len| DocCommentToken { prefix_len, doc_token: doc_token.clone() },
+    )
 }
 
 impl DocCommentToken {
         self,
         sema: &Semantics<'_, RootDatabase>,
         offset: TextSize,
-        // Definition, CommentOwner, range of intra doc link in original file
         mut cb: impl FnMut(Definition, SyntaxNode, TextRange) -> Option<T>,
     ) -> Option<T> {
         let DocCommentToken { prefix_len, doc_token } = self;
                     let (mapped, idx) = doc_mapping.map(range)?;
                     (mapped.value.contains(abs_in_expansion_offset)).then_some((mapped.value, link, ns, idx.is_inner_attr()))
                 })?;
-            // get the relative range to the doc/attribute in the expansion
             let in_expansion_relative_range = in_expansion_range - descended_prefix_len - token_start;
-            // Apply relative range to the original input comment
             let absolute_range = in_expansion_relative_range + original_start + prefix_len;
             let def = resolve_doc_path_for_def(sema.db, def, &link, ns, is_inner)?;
             cb(def, node, absolute_range)
 }
 
 fn broken_link_clone_cb(link: BrokenLink<'_>) -> Option<(CowStr<'_>, CowStr<'_>)> {
-    Some((/*url*/ link.reference.clone(), /*title*/ link.reference))
+    Some((link.reference.clone(), link.reference))
 }
 
-// FIXME:
-// BUG: For Option::Some
-// Returns https://doc.rust-lang.org/nightly/core/prelude/v1/enum.Option.html#variant.Some
-// Instead of https://doc.rust-lang.org/nightly/core/option/enum.Option.html
-//
-// This should cease to be a problem if RFC2988 (Stable Rustdoc URLs) is implemented
-// https://github.com/rust-lang/rfcs/pull/2988
 fn get_doc_links(
     db: &RootDatabase,
     def: Definition,
     url.set_fragment(frag);
 
     // We want to strip the keyword prefix from the title, but only if the target is implicitly the same
+
     // as the title.
     let title = match link_type {
         LinkType::Email
             end_link_target = Some(target.clone());
             end_link_type = Some(link_type);
             evt
-        }
+        },
         Event::End(Tag::Link(link_type, target, _)) => {
             in_link = false;
             Event::End(Tag::Link(
                 end_link_target.take().unwrap_or(target),
                 CowStr::Borrowed(""),
             ))
-        }
+        },
         Event::Text(s) if in_link => {
             let (link_type, link_target_s, link_name) =
                 callback(&end_link_target.take().unwrap(), &s, range, end_link_type.unwrap());
                 end_link_type = link_type;
             }
             Event::Text(CowStr::Boxed(link_name.into()))
-        }
+        },
         Event::Code(s) if in_link => {
             let (link_type, link_target_s, link_name) =
                 callback(&end_link_target.take().unwrap(), &s, range, end_link_type.unwrap());
                 end_link_type = link_type;
             }
             Event::Code(CowStr::Boxed(link_name.into()))
-        }
+        },
         _ => evt,
     })
 }
         .as_str();
 
     // special case base url of `BuiltinType` to core
+
     // https://github.com/rust-lang/rust-analyzer/issues/12250
     if let Definition::BuiltinType(..) = def {
         let web_link = Url::parse(&format!("https://doc.rust-lang.org/{channel}/core/")).ok();
         AssocItem::Function(function) => {
             let is_trait_method =
                 function.as_assoc_item(db).and_then(|assoc| assoc.container_trait(db)).is_some();
-            // This distinction may get more complicated when specialization is available.
-            // Rustdoc makes this decision based on whether a method 'has defaultness'.
-            // Currently this is only the case for provided trait methods.
             if is_trait_method && !function.has_body(db) {
                 format!("tymethod.{}", function.name(db).as_str())
             } else {
                 format!("method.{}", function.name(db).as_str())
             }
-        }
+        },
         AssocItem::Const(constant) => {
             format!("associatedconstant.{}", constant.name(db)?.as_str())
-        }
+        },
         AssocItem::TypeAlias(ty) => {
             format!("associatedtype.{}", ty.name(db).as_str())
-        }
+        },
     })
 }