COMPARISON DIFF
============================================================

Original size: 31554 bytes
Chloro size:   30793 bytes
Rustfmt size:  31554 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Extracts, resolves and rewrites links and intra-doc links in markdown documentation.
 
-#[cfg(test)]
-mod tests;
-
-mod intra_doc_links;
-
 use std::ops::Range;
 
-use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};
-use pulldown_cmark_to_cmark::{Options as CMarkOptions, cmark_resume_with_options};
-use stdx::format_to;
-use url::Url;
-
 use hir::{
     Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrsWithOwner, HasAttrs, db::HirDatabase, sym,
 };
     documentation::{DocsRangeMap, Documentation, HasDocs, docs_with_rangemap},
     helpers::pick_best_token,
 };
+use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};
+use pulldown_cmark_to_cmark::{Options as CMarkOptions, cmark_resume_with_options};
+use stdx::format_to;
 use syntax::{
     AstNode, AstToken,
     SyntaxKind::*,
     ast::{self, IsString},
     match_ast,
 };
+use url::Url;
 
 use crate::{
     FilePosition, Semantics,
     doc_links::intra_doc_links::{parse_intra_doc_link, strip_prefixes_suffixes},
 };
 
+#[cfg(test)]
+mod tests;
+
+mod intra_doc_links;
+
 /// Web and local links to an item's documentation.
 #[derive(Default, Debug, Clone, PartialEq, Eq)]
 pub struct DocumentationLinks {
     pub local_url: Option<String>,
 }
 
-const MARKDOWN_OPTIONS: Options =
-    Options::ENABLE_FOOTNOTES.union(Options::ENABLE_TABLES).union(Options::ENABLE_TASKLISTS);
+const MARKDOWN_OPTIONS: Options = Options::ENABLE_FOOTNOTES.union(Options::ENABLE_TABLES).union(Options::ENABLE_TASKLISTS);
 
 /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)
 pub(crate) fn rewrite_links(
     let mut cb = broken_link_clone_cb;
     let doc = Parser::new_with_broken_link_callback(markdown, MARKDOWN_OPTIONS, Some(&mut cb))
         .into_offset_iter();
-
     let doc = map_links(doc, |target, title, range, link_type| {
         // This check is imperfect, there's some overlap between valid intra-doc links
         // and valid URLs so we choose to be too eager to try to resolve what might be
 /// Remove all links in markdown documentation.
 pub(crate) fn remove_links(markdown: &str) -> String {
     let mut drop_link = false;
-
     let mut cb = |_: BrokenLink<'_>| {
         let empty = InlineStr::try_from("").unwrap();
         Some((CowStr::Inlined(empty), CowStr::Inlined(empty)))
         }
         _ => Some(evt),
     });
-
     let mut out = String::new();
     cmark_resume_with_options(
         doc,
     out
 }
 
-// Feature: Open Docs
-//
-// Retrieve a links to documentation for the given symbol.
-//
-// The simplest way to use this feature is via the context menu. Right-click on
-// the selected item. The context menu opens. Select **Open Docs**.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Open Docs** |
 pub(crate) fn external_docs(
     db: &RootDatabase,
     FilePosition { file_id, offset }: FilePosition,
         _ => 1,
     })?;
     let token = sema.descend_into_macros_single_exact(token);
-
     let node = token.parent()?;
     let definition = match_ast! {
         match node {
             _ => return None
         }
     };
-
     Some(get_doc_links(db, definition, target_dir, sysroot))
 }
 
 /// Extracts all links from a given markdown text returning the definition text range, link-text
 /// and the namespace if known.
-pub(crate) fn extract_definitions_from_docs(
-    docs: &Documentation,
-) -> Vec<(TextRange, String, Option<hir::Namespace>)> {
+pub(crate) fn extract_definitions_from_docs(docs: &Documentation) -> Vec<(TextRange, String, Option<hir::Namespace>)> {
     Parser::new_with_broken_link_callback(
         docs.as_str(),
         MARKDOWN_OPTIONS,
         self,
         sema: &Semantics<'_, RootDatabase>,
         offset: TextSize,
-        // Definition, CommentOwner, range of intra doc link in original file
         mut cb: impl FnMut(Definition, SyntaxNode, TextRange) -> Option<T>,
     ) -> Option<T> {
         let DocCommentToken { prefix_len, doc_token } = self;
         // offset relative to the comments contents
         let original_start = doc_token.text_range().start();
         let relative_comment_offset = offset - original_start - prefix_len;
-
         sema.descend_into_macros(doc_token).into_iter().find_map(|t| {
             let (node, descended_prefix_len, is_inner) = match_ast!{
                 match t {
     Some((/*url*/ link.reference.clone(), /*title*/ link.reference))
 }
 
-// FIXME:
-// BUG: For Option::Some
-// Returns https://doc.rust-lang.org/nightly/core/prelude/v1/enum.Option.html#variant.Some
-// Instead of https://doc.rust-lang.org/nightly/core/option/enum.Option.html
-//
-// This should cease to be a problem if RFC2988 (Stable Rustdoc URLs) is implemented
-// https://github.com/rust-lang/rfcs/pull/2988
 fn get_doc_links(
     db: &RootDatabase,
     def: Definition,
     let join_url = |base_url: Option<Url>, path: &str| -> Option<Url> {
         base_url.and_then(|url| url.join(path).ok())
     };
-
     let Some((target, file, frag)) = filename_and_frag_for_def(db, def) else {
         return Default::default();
     };
-
     let (mut web_url, mut local_url) = get_doc_base_urls(db, target, target_dir, sysroot);
-
     let append_mod = !matches!(def, Definition::Macro(m) if m.is_macro_export(db));
     if append_mod && let Some(path) = mod_path_of_def(db, target) {
         web_url = join_url(web_url, &path);
         local_url = join_url(local_url, &path);
     }
-
     web_url = join_url(web_url, &file);
     local_url = join_url(local_url, &file);
-
     if let Some(url) = web_url.as_mut() {
         url.set_fragment(frag.as_deref())
     }
     if let Some(url) = local_url.as_mut() {
         url.set_fragment(frag.as_deref())
     }
-
     DocumentationLinks {
         web_url: web_url.map(|it| it.into()),
         local_url: local_url.map(|it| it.into()),
     link_type: LinkType,
 ) -> Option<(String, String)> {
     let (link, ns) = parse_intra_doc_link(target);
-
     let (link, anchor) = match link.split_once('#') {
         Some((new_link, anchor)) => (new_link, Some(anchor)),
         None => (link, None),
     };
-
     let resolved = resolve_doc_path_for_def(db, def, link, ns, is_inner_doc)?;
     let mut url = get_doc_base_urls(db, resolved, None, None).0?;
-
     let (_, file, frag) = filename_and_frag_for_def(db, resolved)?;
     if let Some(path) = mod_path_of_def(db, resolved) {
         url = url.join(&path).ok()?;
     }
-
     let frag = anchor.or(frag.as_deref());
-
     url = url.join(&file).ok()?;
     url.set_fragment(frag);
-
     // We want to strip the keyword prefix from the title, but only if the target is implicitly the same
     // as the title.
     let title = match link_type {
             strip_prefixes_suffixes(title).to_owned()
         }
     };
-
     Some((url.into(), title))
 }
 
 /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).
-fn rewrite_url_link(db: &RootDatabase, def: Definition, target: &str) -> Option<String> {
+fn rewrite_url_link(
+    db: &RootDatabase,
+    def: Definition,
+    target: &str,
+) -> Option<String> {
     if !(target.contains('#') || target.contains(".html")) {
         return None;
     }
-
     let mut url = get_doc_base_urls(db, def, None, None).0?;
     let (def, file, frag) = filename_and_frag_for_def(db, def)?;
-
     if let Some(path) = mod_path_of_def(db, def) {
         url = url.join(&path).ok()?;
     }
-
     url = url.join(&file).ok()?;
     url.set_fragment(frag.as_deref());
     url.join(target).ok().map(Into::into)
 }
 
-fn mod_path_of_def(db: &RootDatabase, def: Definition) -> Option<String> {
+fn mod_path_of_def(
+    db: &RootDatabase,
+    def: Definition,
+) -> Option<String> {
     def.canonical_module_path(db).map(|it| {
         let mut path = String::new();
         it.flat_map(|it| it.name(db)).for_each(|name| format_to!(path, "{}/", name.as_str()));
     // however in some cases we want to change the link type, for example,
     // `Shortcut` type parsed from Start/End tags doesn't make sense for url links
     let mut end_link_type: Option<LinkType> = None;
-
     events.map(move |(evt, range)| match evt {
         Event::Start(Tag::Link(link_type, ref target, _)) => {
             in_link = true;
         .and_then(|krate| db.toolchain_channel(krate.into()))
         .unwrap_or(ReleaseChannel::Nightly)
         .as_str();
-
     // special case base url of `BuiltinType` to core
     // https://github.com/rust-lang/rust-analyzer/issues/12250
     if let Definition::BuiltinType(..) = def {
         let system_link = system_doc.and_then(|it| it.join("core/").ok());
         return (web_link, system_link);
     };
-
     let Some(krate) = krate else { return Default::default() };
     let Some(display_name) = krate.display_name(db) else { return Default::default() };
     let (web_base, local_base) = match krate.origin(db) {
         .and_then(|it| Url::parse(&it).ok())
         .and_then(|it| it.join(&format!("{display_name}/")).ok());
     let local_base = local_base.and_then(|it| it.join(&format!("{display_name}/")).ok());
-
     (web_base, local_base)
 }
 
         let frag = get_assoc_item_fragment(db, assoc_item)?;
         return Some((def, file, Some(frag)));
     }
-
     let res = match def {
         Definition::Adt(adt) => match adt {
             Adt::Struct(s) => {
         | Definition::InlineAsmRegOrRegClass(_)
         | Definition::InlineAsmOperand(_) => return None,
     };
-
     Some((def, res, None))
 }
 
 /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next
 ///                                                       ^^^^^^^^^^^^^^
 /// ```
-fn get_assoc_item_fragment(db: &dyn HirDatabase, assoc_item: hir::AssocItem) -> Option<String> {
+fn get_assoc_item_fragment(
+    db: &dyn HirDatabase,
+    assoc_item: hir::AssocItem,
+) -> Option<String> {
     Some(match assoc_item {
         AssocItem::Function(function) => {
             let is_trait_method =