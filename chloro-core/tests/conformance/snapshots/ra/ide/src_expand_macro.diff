COMPARISON DIFF
============================================================

Original size: 21133 bytes
Chloro size:   20725 bytes
Rustfmt size:  21133 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 };
 use span::{SpanMap, SyntaxContext, TextRange, TextSize};
 use stdx::format_to;
-use syntax::{AstNode, NodeOrToken, SyntaxKind, SyntaxNode, T, ast, ted};
+use syntax::{AstNode, NodeOrToken, SyntaxKind, SyntaxNode, ast, ted, T};
 
 use crate::FilePosition;
 
     pub expansion: String,
 }
 
-// Feature: Expand Macro Recursively
-//
-// Shows the full macro expansion of the macro at the current caret position.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Expand macro recursively at caret** |
-//
-// ![Expand Macro Recursively](https://user-images.githubusercontent.com/48062697/113020648-b3973180-917a-11eb-84a9-ecb921293dc5.gif)
 pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<ExpandedMacro> {
     let sema = Semantics::new(db);
     let file_id = sema.attach_first_edition(position.file_id)?;
     })?;
 
     // due to how rust-analyzer works internally, we need to special case derive attributes,
+
     // otherwise they might not get found, e.g. here with the cursor at $0 `#[attr]` would expand:
-    // ```
-    // #[attr]
-    // #[derive($0Foo)]
-    // struct Bar;
+
     // ```
 
+    // #[attr]
+
+    // #[derive($0Foo)]
+
+    // struct Bar;
+
+    // ```
     let derive = sema.descend_into_macros_exact(tok.clone()).into_iter().find_map(|descended| {
         let macro_file = sema.hir_file_for(&descended.parent()?).macro_file()?;
         if !macro_file.is_derive_attr_pseudo_expansion(db) {
 #[cfg(test)]
 mod tests {
     use expect_test::{Expect, expect};
-
     use crate::fixture;
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, pos) = fixture::position(ra_fixture);
         let actual = format!("{}\n{}", expansion.name, expansion.expansion);
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn expand_allowed_builtin_macro() {
         check(
                 "test10btrue""#]],
         );
     }
-
     #[test]
     fn do_not_expand_disallowed_macro() {
         let (analysis, pos) = fixture::position(
         let expansion = analysis.expand_macro(pos).unwrap();
         assert!(expansion.is_none());
     }
-
     #[test]
     fn macro_expand_as_keyword() {
         check(
                 5i64 as _"#]],
         );
     }
-
     #[test]
     fn macro_expand_underscore() {
         check(
                 for _ in 0..42{}"#]],
         );
     }
-
     #[test]
     fn macro_expand_recursive_expansion() {
         check(
                 fn b(){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_multiple_lines() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_match_ast() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_match_ast_inside_let_statement() {
         check(
                 {}"#]],
         );
     }
-
     #[test]
     fn macro_expand_inner_macro_rules() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_inner_macro_fail_to_expand() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn macro_expand_with_dollar_crate() {
         check(
                 0"#]],
         );
     }
-
     #[test]
     fn macro_expand_with_dyn_absolute_path() {
         check(
                 fn f<T>(_: &dyn ::std::marker::Copy){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_item_expansion_in_expression_call() {
         check(
                 fn f<T>(){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive() {
         check(
                     }"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive2() {
         check(
                 impl <>core::marker::Copy for Foo< >where{}"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive_multi() {
         check(
                     }"#]],
         );
     }
-
     #[test]
     fn dollar_crate() {
         check(
 crate::Foo;"#]],
         );
     }
-
     #[test]
     fn semi_glueing() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn assoc_call() {
         check(
                 fn assoc(){}"#]],
         );
     }
-
     #[test]
     fn eager() {
         check(
                 "<>""#]],
         );
     }
-
     #[test]
     fn in_included() {
         check(
                 fn item(){}"#]],
         );
     }
-
     #[test]
     fn include() {
         check(
                 foo();"#]],
         );
     }
-
     #[test]
     fn works_in_sig() {
         check(
                 u32"#]],
         );
     }
-
     #[test]
     fn works_in_generics() {
         check(
                 Trait"#]],
         );
     }
-
     #[test]
     fn works_in_fields() {
         check(