COMPARISON DIFF
============================================================

Original size: 21133 bytes
Chloro size:   20704 bytes
Rustfmt size:  21133 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::db::ExpandDatabase;
 use hir::{ExpandResult, InFile, Semantics};
 use ide_db::{
-    FileId, RootDatabase, base_db::Crate, helpers::pick_best_token,
-    syntax_helpers::prettify_macro_expansion,
+    base_db::Crate, helpers::pick_best_token, syntax_helpers::prettify_macro_expansion, FileId,
+    RootDatabase,
 };
 use span::{SpanMap, SyntaxContext, TextRange, TextSize};
 use stdx::format_to;
-use syntax::{AstNode, NodeOrToken, SyntaxKind, SyntaxNode, T, ast, ted};
+use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, T};
 
 use crate::FilePosition;
 
     pub expansion: String,
 }
 
-// Feature: Expand Macro Recursively
-//
-// Shows the full macro expansion of the macro at the current caret position.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Expand macro recursively at caret** |
-//
-// ![Expand Macro Recursively](https://user-images.githubusercontent.com/48062697/113020648-b3973180-917a-11eb-84a9-ecb921293dc5.gif)
 pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<ExpandedMacro> {
     let sema = Semantics::new(db);
     let file_id = sema.attach_first_edition(position.file_id)?;
     })?;
 
     // due to how rust-analyzer works internally, we need to special case derive attributes,
+
     // otherwise they might not get found, e.g. here with the cursor at $0 `#[attr]` would expand:
-    // ```
-    // #[attr]
-    // #[derive($0Foo)]
-    // struct Bar;
+
     // ```
 
-    let derive = sema.descend_into_macros_exact(tok.clone()).into_iter().find_map(|descended| {
+    // #[attr]
+
+    // #[derive($0Foo)]
+
+    // struct Bar;
+
+    // ```
+    let derive = sema
+        .descend_into_macros_exact(tok.clone())
+        .into_iter()
+        .find_map(|descended| {
         let macro_file = sema.hir_file_for(&descended.parent()?).macro_file()?;
         if !macro_file.is_derive_attr_pseudo_expansion(db) {
             return None;
     if let Some(err) = err {
         format_to!(error, "\n{}", err.render_to_string(sema.db));
     }
-    let file_id =
-        sema.hir_file_for(&expanded).macro_file().expect("expansion must produce a macro file");
+    let file_id = sema.hir_file_for(&expanded).macro_file().expect("expansion must produce a macro file");
     let expansion_span_map = sema.db.expansion_span_map(file_id);
-    result_span_map.merge(
+    result_span_map
+        .merge(
         TextRange::at(offset_in_original_node, macro_call.syntax().text_range().len()),
         expanded.text_range().len(),
         &expansion_span_map,
     // hack until we get hygiene working (same character amount to preserve formatting as much as possible)
     const DOLLAR_CRATE_REPLACE: &str = "__r_a_";
     const BUILTIN_REPLACE: &str = "builtin__POUND";
-    let expansion =
-        expansion.replace("$crate", DOLLAR_CRATE_REPLACE).replace("builtin #", BUILTIN_REPLACE);
+    let expansion = expansion.replace("$crate", DOLLAR_CRATE_REPLACE).replace("builtin #", BUILTIN_REPLACE);
     let (prefix, suffix) = match kind {
         SyntaxKind::MACRO_PAT => ("fn __(", ": u32);"),
         SyntaxKind::MACRO_EXPR | SyntaxKind::MACRO_STMTS => ("fn __() {", "}"),
     let &crate_id = db.relevant_crates(file_id).iter().next()?;
     let edition = crate_id.data(db).edition;
 
-    #[allow(clippy::disallowed_methods)]
     let mut cmd = std::process::Command::new(toolchain::Tool::Rustfmt.path());
     cmd.arg("--edition");
     cmd.arg(edition.to_string());
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{Expect, expect};
-
+    use expect_test::{expect, Expect};
     use crate::fixture;
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, pos) = fixture::position(ra_fixture);
         let actual = format!("{}\n{}", expansion.name, expansion.expansion);
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn expand_allowed_builtin_macro() {
         check(
                 "test10btrue""#]],
         );
     }
-
     #[test]
     fn do_not_expand_disallowed_macro() {
         let (analysis, pos) = fixture::position(
         let expansion = analysis.expand_macro(pos).unwrap();
         assert!(expansion.is_none());
     }
-
     #[test]
     fn macro_expand_as_keyword() {
         check(
                 5i64 as _"#]],
         );
     }
-
     #[test]
     fn macro_expand_underscore() {
         check(
                 for _ in 0..42{}"#]],
         );
     }
-
     #[test]
     fn macro_expand_recursive_expansion() {
         check(
                 fn b(){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_multiple_lines() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_match_ast() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_match_ast_inside_let_statement() {
         check(
                 {}"#]],
         );
     }
-
     #[test]
     fn macro_expand_inner_macro_rules() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_inner_macro_fail_to_expand() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn macro_expand_with_dollar_crate() {
         check(
                 0"#]],
         );
     }
-
     #[test]
     fn macro_expand_with_dyn_absolute_path() {
         check(
                 fn f<T>(_: &dyn ::std::marker::Copy){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_item_expansion_in_expression_call() {
         check(
                 fn f<T>(){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive() {
         check(
                     }"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive2() {
         check(
                 impl <>core::marker::Copy for Foo< >where{}"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive_multi() {
         check(
                     }"#]],
         );
     }
-
     #[test]
     fn dollar_crate() {
         check(
 crate::Foo;"#]],
         );
     }
-
     #[test]
     fn semi_glueing() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn assoc_call() {
         check(
                 fn assoc(){}"#]],
         );
     }
-
     #[test]
     fn eager() {
         check(
                 "<>""#]],
         );
     }
-
     #[test]
     fn in_included() {
         check(
                 fn item(){}"#]],
         );
     }
-
     #[test]
     fn include() {
         check(
                 foo();"#]],
         );
     }
-
     #[test]
     fn works_in_sig() {
         check(
                 u32"#]],
         );
     }
-
     #[test]
     fn works_in_generics() {
         check(
                 Trait"#]],
         );
     }
-
     #[test]
     fn works_in_fields() {
         check(