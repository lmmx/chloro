COMPARISON DIFF
============================================================

Original size: 21133 bytes
Chloro size:   21105 bytes
Rustfmt size:  21832 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     let file = sema.parse(file_id);
     let krate = sema.file_to_module_def(file_id.file_id(db))?.krate().into();
 
-    let tok = pick_best_token(
-        file.syntax().token_at_offset(position.offset),
-        |kind| match kind {
-            SyntaxKind::IDENT => 1,
-            _ => 0,
-        },
-    )?;
+    let tok = pick_best_token(file.syntax().token_at_offset(position.offset), |kind| match kind {
+        SyntaxKind::IDENT => 1,
+        _ => 0,
+    })?;
 
     // due to how rust-analyzer works internally, we need to special case derive attributes,
     // otherwise they might not get found, e.g. here with the cursor at $0 `#[attr]` would expand:
     // #[derive($0Foo)]
     // struct Bar;
     // ```
+    let derive = sema.descend_into_macros_exact(tok.clone()).into_iter().find_map(|descended| {
+        let macro_file = sema.hir_file_for(&descended.parent()?).macro_file()?;
+        if !macro_file.is_derive_attr_pseudo_expansion(db) {
+            return None;
+        }
 
-    let derive = sema
-        .descend_into_macros_exact(tok.clone())
-        .into_iter()
-        .find_map(|descended| {
-            let macro_file = sema.hir_file_for(&descended.parent()?).macro_file()?;
-            if !macro_file.is_derive_attr_pseudo_expansion(db) {
-                return None;
-            }
-
-            let name = descended
-                .parent_ancestors()
-                .filter_map(ast::Path::cast)
-                .last()?
-                .to_string();
-            // up map out of the #[derive] expansion
-            let InFile {
-                file_id,
-                value: tokens,
-            } = hir::InMacroFile::new(macro_file, descended).upmap_once(db);
-            let token = sema
-                .parse_or_expand(file_id)
-                .covering_element(tokens[0])
-                .into_token()?;
-            let attr = token.parent_ancestors().find_map(ast::Attr::cast)?;
-            let expansions = sema.expand_derive_macro(&attr)?;
-            let idx = attr
-                .token_tree()?
-                .token_trees_and_tokens()
-                .filter_map(NodeOrToken::into_token)
-                .take_while(|it| it != &token)
-                .filter(|it| it.kind() == T![,])
-                .count();
-            let ExpandResult {
-                err,
-                value: expansion,
-            } = expansions.get(idx)?.clone();
-            let expansion_file_id = sema.hir_file_for(&expansion).macro_file()?;
-            let expansion_span_map = db.expansion_span_map(expansion_file_id);
-            let mut expansion = format(
-                db,
-                SyntaxKind::MACRO_ITEMS,
-                position.file_id,
-                expansion,
-                &expansion_span_map,
-                krate,
+        let name = descended.parent_ancestors().filter_map(ast::Path::cast).last()?.to_string();
+        // up map out of the #[derive] expansion
+        let InFile { file_id, value: tokens } =
+            hir::InMacroFile::new(macro_file, descended).upmap_once(db);
+        let token = sema.parse_or_expand(file_id).covering_element(tokens[0]).into_token()?;
+        let attr = token.parent_ancestors().find_map(ast::Attr::cast)?;
+        let expansions = sema.expand_derive_macro(&attr)?;
+        let idx = attr
+            .token_tree()?
+            .token_trees_and_tokens()
+            .filter_map(NodeOrToken::into_token)
+            .take_while(|it| it != &token)
+            .filter(|it| it.kind() == T![,])
+            .count();
+        let ExpandResult { err, value: expansion } = expansions.get(idx)?.clone();
+        let expansion_file_id = sema.hir_file_for(&expansion).macro_file()?;
+        let expansion_span_map = db.expansion_span_map(expansion_file_id);
+        let mut expansion = format(
+            db,
+            SyntaxKind::MACRO_ITEMS,
+            position.file_id,
+            expansion,
+            &expansion_span_map,
+            krate,
+        );
+        if let Some(err) = err {
+            expansion.insert_str(
+                0,
+                &format!("Expansion had errors: {}\n\n", err.render_to_string(sema.db)),
             );
-            if let Some(err) = err {
-                expansion.insert_str(
-                    0,
-                    &format!(
-                        "Expansion had errors: {}\n\n",
-                        err.render_to_string(sema.db)
-                    ),
-                );
-            }
-            Some(ExpandedMacro { name, expansion })
-        });
+        }
+        Some(ExpandedMacro { name, expansion })
+    });
 
     if derive.is_some() {
         return derive;
             if let Some(mac) = ast::MacroCall::cast(node) {
                 let mut name = mac.path()?.segment()?.name_ref()?.to_string();
                 name.push('!');
-                let syntax_kind = mac
-                    .syntax()
-                    .parent()
-                    .map(|it| it.kind())
-                    .unwrap_or(SyntaxKind::MACRO_ITEMS);
+                let syntax_kind =
+                    mac.syntax().parent().map(|it| it.kind()).unwrap_or(SyntaxKind::MACRO_ITEMS);
                 break (
                     name,
                     expand_macro_recur(
     result_span_map: &mut SpanMap<SyntaxContext>,
     offset_in_original_node: TextSize,
 ) -> Option<SyntaxNode> {
-    let ExpandResult {
-        value: expanded,
-        err,
-    } = match macro_call {
+    let ExpandResult { value: expanded, err } = match macro_call {
         item @ ast::Item::MacroCall(macro_call) => sema
             .expand_attr_macro(item)
             .map(|it| it.map(|it| it.value))
     if let Some(err) = err {
         format_to!(error, "\n{}", err.render_to_string(sema.db));
     }
-    let file_id = sema
-        .hir_file_for(&expanded)
-        .macro_file()
-        .expect("expansion must produce a macro file");
+    let file_id =
+        sema.hir_file_for(&expanded).macro_file().expect("expansion must produce a macro file");
     let expansion_span_map = sema.db.expansion_span_map(file_id);
     result_span_map.merge(
-        TextRange::at(
-            offset_in_original_node,
-            macro_call.syntax().text_range().len(),
-        ),
+        TextRange::at(offset_in_original_node, macro_call.syntax().text_range().len()),
         expanded.text_range().len(),
         &expansion_span_map,
     );
-    Some(expand(
-        sema,
-        expanded,
-        error,
-        result_span_map,
-        u32::from(offset_in_original_node) as i32,
-    ))
+    Some(expand(sema, expanded, error, result_span_map, u32::from(offset_in_original_node) as i32))
 }
 
 fn expand(
         }
     }
 
-    replacements
-        .into_iter()
-        .rev()
-        .for_each(|(old, new)| ted::replace(old.syntax(), new));
+    replacements.into_iter().rev().for_each(|(old, new)| ted::replace(old.syntax(), new));
     expanded
 }
 
     // hack until we get hygiene working (same character amount to preserve formatting as much as possible)
     const DOLLAR_CRATE_REPLACE: &str = "__r_a_";
     const BUILTIN_REPLACE: &str = "builtin__POUND";
-    let expansion = expansion
-        .replace("$crate", DOLLAR_CRATE_REPLACE)
-        .replace("builtin #", BUILTIN_REPLACE);
+    let expansion =
+        expansion.replace("$crate", DOLLAR_CRATE_REPLACE).replace("builtin #", BUILTIN_REPLACE);
     let (prefix, suffix) = match kind {
         SyntaxKind::MACRO_PAT => ("fn __(", ": u32);"),
         SyntaxKind::MACRO_EXPR | SyntaxKind::MACRO_STMTS => ("fn __() {", "}"),
             .replace(BUILTIN_REPLACE, "builtin #");
         let output = output.trim().strip_prefix(prefix)?;
         let output = match kind {
-            SyntaxKind::MACRO_PAT => output
-                .strip_suffix(suffix)
-                .or_else(|| output.strip_suffix(": u32,\n);"))?,
+            SyntaxKind::MACRO_PAT => {
+                output.strip_suffix(suffix).or_else(|| output.strip_suffix(": u32,\n);"))?
+            }
             _ => output.strip_suffix(suffix)?,
         };
         let trim_indent = stdx::trim_indent(output);
 #[cfg(test)]
 mod tests {
     use expect_test::{Expect, expect};
-
     use crate::fixture;
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, pos) = fixture::position(ra_fixture);
         let actual = format!("{}\n{}", expansion.name, expansion.expansion);
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn expand_allowed_builtin_macro() {
         check(
                 "test10btrue""#]],
         );
     }
-
     #[test]
     fn do_not_expand_disallowed_macro() {
         let (analysis, pos) = fixture::position(
         let expansion = analysis.expand_macro(pos).unwrap();
         assert!(expansion.is_none());
     }
-
     #[test]
     fn macro_expand_as_keyword() {
         check(
                 5i64 as _"#]],
         );
     }
-
     #[test]
     fn macro_expand_underscore() {
         check(
                 for _ in 0..42{}"#]],
         );
     }
-
     #[test]
     fn macro_expand_recursive_expansion() {
         check(
                 fn b(){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_multiple_lines() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_match_ast() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_match_ast_inside_let_statement() {
         check(
                 {}"#]],
         );
     }
-
     #[test]
     fn macro_expand_inner_macro_rules() {
         check(
                 }"#]],
         );
     }
-
     #[test]
     fn macro_expand_inner_macro_fail_to_expand() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn macro_expand_with_dollar_crate() {
         check(
                 0"#]],
         );
     }
-
     #[test]
     fn macro_expand_with_dyn_absolute_path() {
         check(
                 fn f<T>(_: &dyn ::std::marker::Copy){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_item_expansion_in_expression_call() {
         check(
                 fn f<T>(){}"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive() {
         check(
                     }"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive2() {
         check(
                 impl <>core::marker::Copy for Foo< >where{}"#]],
         );
     }
-
     #[test]
     fn macro_expand_derive_multi() {
         check(
                     }"#]],
         );
     }
-
     #[test]
     fn dollar_crate() {
         check(
 crate::Foo;"#]],
         );
     }
-
     #[test]
     fn semi_glueing() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn assoc_call() {
         check(
                 fn assoc(){}"#]],
         );
     }
-
     #[test]
     fn eager() {
         check(
                 "<>""#]],
         );
     }
-
     #[test]
     fn in_included() {
         check(
                 fn item(){}"#]],
         );
     }
-
     #[test]
     fn include() {
         check(
                 foo();"#]],
         );
     }
-
     #[test]
     fn works_in_sig() {
         check(
                 u32"#]],
         );
     }
-
     #[test]
     fn works_in_generics() {
         check(
                 Trait"#]],
         );
     }
-
     #[test]
     fn works_in_fields() {
         check(