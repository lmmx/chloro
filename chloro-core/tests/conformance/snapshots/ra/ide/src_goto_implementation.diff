COMPARISON DIFF
============================================================

Original size: 10632 bytes
Chloro size:   10142 bytes
Rustfmt size:  10803 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     pub filter_adjacent_derive_implementations: bool,
 }
 
-// Feature: Go to Implementation
-//
-// Navigates to the impl items of types.
-//
-// | Editor  | Shortcut |
-// |---------|----------|
-// | VS Code | <kbd>Ctrl+F12</kbd>
-//
-// ![Go to Implementation](https://user-images.githubusercontent.com/48062697/113065566-02f85480-91b1-11eb-9288-aaad8abd8841.gif)
 pub(crate) fn goto_implementation(
     db: &RootDatabase,
     config: &GotoImplementationConfig,
 }
 
 fn impls_for_ty(sema: &Semantics<'_, RootDatabase>, ty: hir::Type<'_>) -> Vec<NavigationTarget> {
-    Impl::all_for_type(sema.db, ty)
-        .into_iter()
-        .filter_map(|imp| imp.try_to_nav(sema))
-        .flatten()
-        .collect()
+    Impl::all_for_type(sema.db, ty).into_iter().filter_map(|imp| imp.try_to_nav(sema)).flatten().collect(
+    )
 }
 
 fn impls_for_trait(
     sema: &Semantics<'_, RootDatabase>,
     trait_: hir::Trait,
 ) -> Vec<NavigationTarget> {
-    Impl::all_for_trait(sema.db, trait_)
-        .into_iter()
-        .filter_map(|imp| imp.try_to_nav(sema))
-        .flatten()
-        .collect()
+    Impl::all_for_trait(sema.db, trait_).into_iter().filter_map(|imp| imp.try_to_nav(sema)).flatten(
+    ).collect(
+    )
 }
 
 fn impls_for_trait_item(
     trait_: hir::Trait,
     fun_name: hir::Name,
 ) -> Vec<NavigationTarget> {
-    Impl::all_for_trait(sema.db, trait_)
-        .into_iter()
-        .filter_map(|imp| {
+    Impl::all_for_trait(sema.db, trait_).into_iter().filter_map(|imp| {
             let item = imp.items(sema.db).iter().find_map(|itm| {
                 let itm_name = itm.name(sema.db)?;
                 (itm_name == fun_name).then_some(*itm)
             })?;
             item.try_to_nav(sema)
-        })
-        .flatten()
-        .collect()
+        }).flatten(
+    ).collect(
+    )
 }
 
 #[cfg(test)]
 mod tests {
     use ide_db::FileRange;
     use itertools::Itertools;
-
     use crate::{fixture, GotoImplementationConfig};
-
-    const TEST_CONFIG: &GotoImplementationConfig = &GotoImplementationConfig {
-        filter_adjacent_derive_implementations: false,
-    };
-
+    const TEST_CONFIG: &GotoImplementationConfig = &GotoImplementationConfig { filter_adjacent_derive_implementations: false };
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(TEST_CONFIG, ra_fixture);
     }
-
     #[track_caller]
     fn check_with_config(
         config: &GotoImplementationConfig,
     ) {
         let (analysis, position, expected) = fixture::annotations(ra_fixture);
 
-        let navs = analysis
-            .goto_implementation(config, position)
-            .unwrap()
-            .unwrap()
-            .info;
+        let navs = analysis.goto_implementation(config, position).unwrap().unwrap().info;
 
         let cmp = |frange: &FileRange| (frange.file_id, frange.range.start());
 
         let actual = navs
             .into_iter()
-            .map(|nav| FileRange {
-                file_id: nav.file_id,
-                range: nav.focus_or_full_range(),
-            })
-            .sorted_by_key(cmp)
-            .collect::<Vec<_>>();
-        let expected = expected
-            .into_iter()
-            .map(|(range, _)| range)
+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })
             .sorted_by_key(cmp)
             .collect::<Vec<_>>();
+        let expected =
+            expected.into_iter().map(|(range, _)| range).sorted_by_key(cmp).collect::<Vec<_>>();
         assert_eq!(expected, actual);
     }
-
     #[test]
     fn goto_implementation_works() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_works_multiple_blocks() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_works_multiple_mods() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_works_multiple_files() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_for_trait() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_for_trait_multiple_files() {
         check(
             "#,
         );
     }
-
-    // FIXME(next-solver): it would be nice to be able to also point to `&Foo`
     #[test]
     fn goto_implementation_all_impls() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_to_builtin_derive() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_type_alias() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_adt_generic() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_builtin() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_trait_functions() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_trait_assoc_const() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_adt_implementation_inside_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_trait_implementation_inside_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn filter_adjacent_derives() {
         check_with_config(
-            &GotoImplementationConfig {
-                filter_adjacent_derive_implementations: true,
-            },
+            &GotoImplementationConfig { filter_adjacent_derive_implementations: true },
             r#"
 //- minicore: clone, copy, derive
 