COMPARISON DIFF
============================================================

Original size: 10632 bytes
Chloro size:   10604 bytes
Rustfmt size:  10803 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 mod tests {
     use ide_db::FileRange;
     use itertools::Itertools;
-
     use crate::{GotoImplementationConfig, fixture};
-
-    const TEST_CONFIG: &GotoImplementationConfig = &GotoImplementationConfig {
-        filter_adjacent_derive_implementations: false,
-    };
-
+    const TEST_CONFIG: &GotoImplementationConfig = &GotoImplementationConfig { filter_adjacent_derive_implementations: false };
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(TEST_CONFIG, ra_fixture);
     }
-
     #[track_caller]
     fn check_with_config(
         config: &GotoImplementationConfig,
     ) {
         let (analysis, position, expected) = fixture::annotations(ra_fixture);
 
-        let navs = analysis
-            .goto_implementation(config, position)
-            .unwrap()
-            .unwrap()
-            .info;
+        let navs = analysis.goto_implementation(config, position).unwrap().unwrap().info;
 
         let cmp = |frange: &FileRange| (frange.file_id, frange.range.start());
 
         let actual = navs
             .into_iter()
-            .map(|nav| FileRange {
-                file_id: nav.file_id,
-                range: nav.focus_or_full_range(),
-            })
-            .sorted_by_key(cmp)
-            .collect::<Vec<_>>();
-        let expected = expected
-            .into_iter()
-            .map(|(range, _)| range)
+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })
             .sorted_by_key(cmp)
             .collect::<Vec<_>>();
+        let expected =
+            expected.into_iter().map(|(range, _)| range).sorted_by_key(cmp).collect::<Vec<_>>();
         assert_eq!(expected, actual);
     }
-
     #[test]
     fn goto_implementation_works() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_works_multiple_blocks() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_works_multiple_mods() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_works_multiple_files() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_for_trait() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_for_trait_multiple_files() {
         check(
             "#,
         );
     }
-
     // FIXME(next-solver): it would be nice to be able to also point to `&Foo`
     #[test]
     fn goto_implementation_all_impls() {
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_to_builtin_derive() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_type_alias() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_adt_generic() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_builtin() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_trait_functions() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_implementation_trait_assoc_const() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_adt_implementation_inside_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_trait_implementation_inside_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn filter_adjacent_derives() {
         check_with_config(
-            &GotoImplementationConfig {
-                filter_adjacent_derive_implementations: true,
-            },
+            &GotoImplementationConfig { filter_adjacent_derive_implementations: true },
             r#"
 //- minicore: clone, copy, derive
 