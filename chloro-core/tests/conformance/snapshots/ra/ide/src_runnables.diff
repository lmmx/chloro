COMPARISON DIFF
============================================================

Original size: 50564 bytes
Chloro size:   50618 bytes
Rustfmt size:  51087 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 #[derive(Debug, Clone, Hash, PartialEq, Eq)]
 pub enum RunnableKind {
-    TestMod { path: String },
-    Test { test_id: TestId, attr: TestAttr },
-    Bench { test_id: TestId },
-    DocTest { test_id: TestId },
+    TestMod {
+        path: String,
+    },
+    Test {
+        test_id: TestId,
+        attr: TestAttr,
+    },
+    Bench {
+        test_id: TestId,
+    },
+    DocTest {
+        test_id: TestId,
+    },
     Bin,
 }
 
                     _ => None,
                 };
                 if let Some(file_id) = file_id.filter(|file| file.macro_file().is_some()) {
-                    in_macro_expansion
-                        .entry(file_id)
-                        .or_default()
-                        .push(runnable);
+                    in_macro_expansion.entry(file_id).or_default().push(runnable);
                     return;
                 }
             }
             Definition::SelfType(impl_) => runnable_impl(&sema, &impl_),
             _ => None,
         };
-        add_opt(
-            runnable.or_else(|| module_def_doctest(&sema, def)),
-            Some(def),
-        );
+        add_opt(runnable.or_else(|| module_def_doctest(&sema, def)), Some(def));
         if let Definition::SelfType(impl_) = def {
             impl_.items(db).into_iter().for_each(|assoc| {
                 let runnable = match assoc {
 
 fn cmp_runnables(
     Runnable { nav, kind, .. }: &Runnable,
-    Runnable {
-        nav: nav_b,
-        kind: kind_b,
-        ..
-    }: &Runnable,
+    Runnable { nav: nav_b, kind: kind_b, .. }: &Runnable,
 ) -> std::cmp::Ordering {
     // full_range.start < focus_range.start < name, should give us a decent unique ordering
     nav.full_range
                 FileReferenceNode::NameRef(name_ref) => name_ref,
                 _ => continue,
             };
-            if let Some(fn_def) = sema
-                .ancestors_with_macros(name_ref.syntax().clone())
-                .find_map(ast::Fn::cast)
-            {
+            if let Some(fn_def) =
+                sema.ancestors_with_macros(name_ref.syntax().clone()).find_map(ast::Fn::cast) {
                 if let Some(runnable) = as_test_runnable(sema, &fn_def) {
                     // direct test
                     tests.insert(runnable);
     let mod_source = parent_module.definition_source_range(sema.db);
 
     let file_id = mod_source.file_id.original_file(sema.db);
-    let mod_scope = SearchScope::file_range(hir::FileRange {
-        file_id,
-        range: mod_source.value,
-    });
+    let mod_scope = SearchScope::file_range(hir::FileRange { file_id, range: mod_source.value });
     let fn_pos = FilePosition {
         file_id: file_id.file_id(sema.db),
         offset: fn_name.syntax().text_range().start(),
     }
 }
 
-fn parent_test_module(sema: &Semantics<'_, RootDatabase>, fn_def: &ast::Fn) -> Option<hir::Module> {
+fn parent_test_module(
+    sema: &Semantics<'_, RootDatabase>,
+    fn_def: &ast::Fn,
+) -> Option<hir::Module> {
     fn_def.syntax().ancestors().find_map(|node| {
         let module = ast::Module::cast(node)?;
         let module = sema.to_def(&module)?;
                 let def: hir::ModuleDef = def.into();
                 def.canonical_path(sema.db, edition)
             };
-            canonical_path.map(TestId::Path).unwrap_or(TestId::Name(
-                def.name(sema.db).display_no_db(edition).to_smolstr(),
-            ))
+            canonical_path
+                .map(TestId::Path)
+                .unwrap_or(TestId::Name(def.name(sema.db).display_no_db(edition).to_smolstr()))
         };
 
         if def.is_test(sema.db) {
             let attr = TestAttr::from_fn(sema.db, def);
-            RunnableKind::Test {
-                test_id: test_id(),
-                attr,
-            }
+            RunnableKind::Test { test_id: test_id(), attr }
         } else if def.is_bench(sema.db) {
             RunnableKind::Bench { test_id: test_id() }
         } else {
     )
     .call_site();
 
-    let file_range = fn_source
-        .syntax()
-        .original_file_range_with_macro_call_input(sema.db);
+    let file_range = fn_source.syntax().original_file_range_with_macro_call_input(sema.db);
     let update_test = UpdateTest::find_snapshot_macro(sema, file_range);
 
     let cfg = def.attrs(sema.db).cfg();
-    Some(Runnable {
-        use_name_in_title: false,
-        nav,
-        kind,
-        cfg,
-        update_test,
-    })
+    Some(Runnable { use_name_in_title: false, nav, kind, cfg, update_test })
 }
 
 pub(crate) fn runnable_mod(
         .rev()
         .filter_map(|module| {
             module.name(sema.db).map(|mod_name| {
-                mod_name
-                    .display(sema.db, module.krate().edition(sema.db))
-                    .to_string()
+                mod_name.display(sema.db, module.krate().edition(sema.db)).to_string()
             })
         })
         .join("::");
 }
 
 fn has_cfg_test(attrs: AttrsWithOwner) -> bool {
-    attrs
-        .cfgs()
-        .any(|cfg| matches!(&cfg, CfgExpr::Atom(CfgAtom::Flag(s)) if *s == sym::test))
+    attrs.cfgs().any(|cfg| matches!(&cfg, CfgExpr::Atom(CfgAtom::Flag(s)) if *s == sym::test))
 }
 
 /// Creates a test mod runnable for outline modules at the top of their definition.
         .rev()
         .filter_map(|module| {
             module.name(sema.db).map(|mod_name| {
-                mod_name
-                    .display(sema.db, module.krate().edition(sema.db))
-                    .to_string()
+                mod_name.display(sema.db, module.krate().edition(sema.db)).to_string()
             })
         })
         .join("::");
         Some(path)
     })();
 
-    let test_id = path.map_or_else(
-        || TestId::Name(def_name.display_no_db(edition).to_smolstr()),
-        TestId::Path,
-    );
+    let test_id = path
+        .map_or_else(|| TestId::Name(def_name.display_no_db(edition).to_smolstr()), TestId::Path);
 
     let mut nav = match def {
         Definition::Module(def) => NavigationTarget::from_module_to_decl(db, def),
 
 impl TestAttr {
     fn from_fn(db: &dyn HirDatabase, fn_def: hir::Function) -> TestAttr {
-        TestAttr {
-            ignore: fn_def.is_ignore(db),
-        }
+        TestAttr { ignore: fn_def.is_ignore(db) }
     }
 }
 
 fn has_runnable_doc_test(attrs: &hir::Attrs) -> bool {
     const RUSTDOC_FENCES: [&str; 2] = ["```", "~~~"];
-    const RUSTDOC_CODE_BLOCK_ATTRIBUTES_RUNNABLE: &[&str] = &[
-        "",
-        "rust",
-        "should_panic",
-        "edition2015",
-        "edition2018",
-        "edition2021",
-    ];
+    const RUSTDOC_CODE_BLOCK_ATTRIBUTES_RUNNABLE: &[&str] =
+        &["", "rust", "should_panic", "edition2015", "edition2018", "edition2021"];
 
     docs_from_attrs(attrs).is_some_and(|doc| {
         let mut in_code_block = false;
 
         for line in doc.lines() {
-            if let Some(header) = RUSTDOC_FENCES
-                .into_iter()
-                .find_map(|fence| line.strip_prefix(fence))
+            if let Some(header) =
+                RUSTDOC_FENCES.into_iter().find_map(|fence| line.strip_prefix(fence))
             {
                 in_code_block = !in_code_block;
 
 
 impl UpdateTest {
     const EXPECT_CRATE: &str = "expect_test";
+
     const EXPECT_MACROS: &[&str] = &["expect", "expect_file"];
 
     const INSTA_CRATE: &str = "insta";
+
     const INSTA_MACROS: &[&str] = &[
         "assert_snapshot",
         "assert_debug_snapshot",
     ];
 
     const SNAPBOX_CRATE: &str = "snapbox";
+
     const SNAPBOX_MACROS: &[&str] = &["assert_data_eq", "file", "str"];
 
-    fn find_snapshot_macro(sema: &Semantics<'_, RootDatabase>, file_range: hir::FileRange) -> Self {
+    fn find_snapshot_macro(
+        sema: &Semantics<'_, RootDatabase>,
+        file_range: hir::FileRange,
+    ) -> Self {
         fn init<'a>(
             krate_name: &'a str,
             paths: &[&str],
 #[cfg(test)]
 mod tests {
     use expect_test::{Expect, expect};
-
     use crate::fixture;
-
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, position) = fixture::position(ra_fixture);
         let result = analysis
             .collect::<Vec<_>>();
         expect.assert_debug_eq(&result);
     }
-
     fn check_tests(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, position) = fixture::position(ra_fixture);
         let tests = analysis.related_tests(position, None).unwrap();
-        let navigation_targets = tests
-            .into_iter()
-            .map(|runnable| runnable.nav)
-            .collect::<Vec<_>>();
+        let navigation_targets = tests.into_iter().map(|runnable| runnable.nav).collect::<Vec<_>>();
         expect.assert_debug_eq(&navigation_targets);
     }
-
     #[test]
     fn test_runnables() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_and_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_const() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_types_and_const() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn only_modules_with_test_functions_or_more_than_one_test_submodule_have_runners() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_with_feature() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_with_features() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_no_test_function_in_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_doc_runnables_impl_mod() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn big_mac() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn dont_recurse_in_outline_submodules() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn outline_submodule1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn outline_submodule2() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn attributed_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn find_no_tests() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_direct_fn_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_direct_struct_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_indirect_fn_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn tests_are_unique() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_type_const_value() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn doc_test_type_params() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn doc_test_macro_export_mbe() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_paths_with_raw_ident() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn exported_main_is_test_in_cfg_test_mod() {
         check(