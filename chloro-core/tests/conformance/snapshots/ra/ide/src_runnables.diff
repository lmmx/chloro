COMPARISON DIFF
============================================================

Original size: 50564 bytes
Chloro size:   49532 bytes
Rustfmt size:  50564 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::{fmt, sync::OnceLock};
 
 use arrayvec::ArrayVec;
 use ast::HasName;
 use cfg::{CfgAtom, CfgExpr};
 use hir::{
-    AsAssocItem, AttrsWithOwner, HasAttrs, HasCrate, HasSource, Semantics, Symbol, db::HirDatabase,
-    sym,
+    db::HirDatabase, sym, AsAssocItem, AttrsWithOwner, HasAttrs, HasCrate, HasSource, Semantics,
+    Symbol,
 };
 use ide_assists::utils::{has_test_related_attribute, test_related_attribute_syn};
 use ide_db::impl_empty_upmap_from_ra_fixture;
 use ide_db::{
-    FilePosition, FxHashMap, FxIndexMap, FxIndexSet, RootDatabase, SymbolKind,
     base_db::RootQueryDb,
     defs::Definition,
     documentation::docs_from_attrs,
     helpers::visit_file_defs,
     search::{FileReferenceNode, SearchScope},
+    FilePosition, FxHashMap, FxIndexMap, FxIndexSet, RootDatabase, SymbolKind,
 };
 use itertools::Itertools;
 use macros::UpmapFromRaFixture;
 use span::{Edition, TextSize};
 use stdx::format_to;
 use syntax::{
-    SmolStr, SyntaxNode, ToSmolStr,
     ast::{self, AstNode},
-    format_smolstr,
+    format_smolstr, SmolStr, SyntaxNode, ToSmolStr,
 };
 
-use crate::{FileId, NavigationTarget, ToNav, TryToNav, references};
+use crate::{references, FileId, NavigationTarget, ToNav, TryToNav};
 
 #[derive(Debug, Clone, Hash, PartialEq, Eq, UpmapFromRaFixture)]
 pub struct Runnable {
 
 #[derive(Debug, Clone, Hash, PartialEq, Eq)]
 pub enum RunnableKind {
-    TestMod { path: String },
-    Test { test_id: TestId, attr: TestAttr },
-    Bench { test_id: TestId },
-    DocTest { test_id: TestId },
+    TestMod {
+        path: String,
+    },
+    Test {
+        test_id: TestId,
+        attr: TestAttr,
+    },
+    Bench {
+        test_id: TestId,
+    },
+    DocTest {
+        test_id: TestId,
+    },
     Bin,
 }
 
     }
 }
 
-// Feature: Run
-//
-// Shows a popup suggesting to run a test/benchmark/binary **at the current cursor
-// location**. Super useful for repeatedly running just a single test. Do bind this
-// to a shortcut!
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Run** |
-//
-// ![Run](https://user-images.githubusercontent.com/48062697/113065583-055aae80-91b1-11eb-958f-d67efcaf6a2f.gif)
 pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {
     let sema = Semantics::new(db);
 
     res
 }
 
-// Feature: Related Tests
-//
-// Provides a sneak peek of all tests where the current item is used.
-//
-// The simplest way to use this feature is via the context menu. Right-click on
-// the selected item. The context menu opens. Select **Peek Related Tests**.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Peek Related Tests** |
 pub(crate) fn related_tests(
     db: &RootDatabase,
     position: FilePosition,
     Runnable { nav: nav_b, kind: kind_b, .. }: &Runnable,
 ) -> std::cmp::Ordering {
     // full_range.start < focus_range.start < name, should give us a decent unique ordering
-    nav.full_range
-        .start()
-        .cmp(&nav_b.full_range.start())
-        .then_with(|| {
+    nav.full_range.start().cmp(&nav_b.full_range.start()).then_with(|| {
             let t_0 = || TextSize::from(0);
             nav.focus_range
                 .map_or_else(t_0, |it| it.start())
                 .cmp(&nav_b.focus_range.map_or_else(t_0, |it| it.start()))
-        })
-        .then_with(|| kind.disc().cmp(&kind_b.disc()))
-        .then_with(|| nav.name.as_str().cmp(nav_b.name.as_str()))
+        }).then_with(
+        || kind.disc().cmp(&kind_b.disc()),
+    ).then_with(
+        || nav.name.as_str().cmp(nav_b.name.as_str()),
+    )
 }
 
 fn find_related_tests(
                 FileReferenceNode::NameRef(name_ref) => name_ref,
                 _ => continue,
             };
-            if let Some(fn_def) =
-                sema.ancestors_with_macros(name_ref.syntax().clone()).find_map(ast::Fn::cast)
-            {
+            if let Some(fn_def) = sema.ancestors_with_macros(name_ref.syntax().clone()).find_map(ast::Fn::cast) {
                 if let Some(runnable) = as_test_runnable(sema, &fn_def) {
-                    // direct test
                     tests.insert(runnable);
                 } else if let Some(module) = parent_test_module(sema, &fn_def) {
-                    // indirect test
                     find_related_tests_in_module(sema, syntax, &fn_def, &module, tests);
                 }
             }
     }
 }
 
-fn parent_test_module(sema: &Semantics<'_, RootDatabase>, fn_def: &ast::Fn) -> Option<hir::Module> {
+fn parent_test_module(
+    sema: &Semantics<'_, RootDatabase>,
+    fn_def: &ast::Fn,
+) -> Option<hir::Module> {
     fn_def.syntax().ancestors().find_map(|node| {
         let module = ast::Module::cast(node)?;
         let module = sema.to_def(&module)?;
     })
 }
 
-// We could create runnables for modules with number_of_test_submodules > 0,
-// but that bloats the runnables for no real benefit, since all tests can be run by the submodule already
 fn has_test_function_or_multiple_test_submodules(
     sema: &Semantics<'_, RootDatabase>,
     module: &hir::Module,
 
 impl UpdateTest {
     const EXPECT_CRATE: &str = "expect_test";
+
     const EXPECT_MACROS: &[&str] = &["expect", "expect_file"];
 
     const INSTA_CRATE: &str = "insta";
+
     const INSTA_MACROS: &[&str] = &[
         "assert_snapshot",
         "assert_debug_snapshot",
     ];
 
     const SNAPBOX_CRATE: &str = "snapbox";
+
     const SNAPBOX_MACROS: &[&str] = &["assert_data_eq", "file", "str"];
 
-    fn find_snapshot_macro(sema: &Semantics<'_, RootDatabase>, file_range: hir::FileRange) -> Self {
+    fn find_snapshot_macro(
+        sema: &Semantics<'_, RootDatabase>,
+        file_range: hir::FileRange,
+    ) -> Self {
         fn init<'a>(
             krate_name: &'a str,
             paths: &[&str],
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{Expect, expect};
-
+    use expect_test::{expect, Expect};
     use crate::fixture;
-
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, position) = fixture::position(ra_fixture);
         let result = analysis
             .collect::<Vec<_>>();
         expect.assert_debug_eq(&result);
     }
-
     fn check_tests(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, position) = fixture::position(ra_fixture);
         let tests = analysis.related_tests(position, None).unwrap();
         let navigation_targets = tests.into_iter().map(|runnable| runnable.nav).collect::<Vec<_>>();
         expect.assert_debug_eq(&navigation_targets);
     }
-
     #[test]
     fn test_runnables() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_and_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_const() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_types_and_const() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn only_modules_with_test_functions_or_more_than_one_test_submodule_have_runners() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_with_feature() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_with_features() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_no_test_function_in_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_doc_runnables_impl_mod() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn big_mac() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn dont_recurse_in_outline_submodules() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn outline_submodule1() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn outline_submodule2() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn attributed_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn find_no_tests() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_direct_fn_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_direct_struct_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn find_indirect_fn_test() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn tests_are_unique() {
         check_tests(
             "#]],
         );
     }
-
     #[test]
     fn test_runnables_doc_test_in_impl_with_lifetime_type_const_value() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn doc_test_type_params() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn doc_test_macro_export_mbe() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_paths_with_raw_ident() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn exported_main_is_test_in_cfg_test_mod() {
         check(