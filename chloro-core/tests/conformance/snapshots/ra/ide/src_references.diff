COMPARISON DIFF
============================================================

Original size: 66636 bytes
Chloro size:   66534 bytes
Rustfmt size:  67044 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     let syntax = sema.parse_guess_edition(position.file_id).syntax().clone();
     let make_searcher = |literal_search: bool| {
         move |def: Definition| {
-            let mut usages = def
-                .usages(sema)
-                .set_scope(config.search_scope.as_ref())
-                .include_self_refs()
-                .all();
+            let mut usages =
+                def.usages(sema).set_scope(config.search_scope.as_ref()).include_self_refs().all();
             if literal_search {
                 retain_adt_literal_usages(&mut usages, def, sema);
             }
                     nav,
                 }
             });
-            ReferenceSearchResult {
-                declaration,
-                references,
-            }
+            ReferenceSearchResult { declaration, references }
         }
     };
 
             fixture_analysis.map_offset_down(position.offset)
     {
         return analysis
-            .find_all_refs(
-                FilePosition {
-                    file_id: virtual_file_id,
-                    offset: file_offset,
-                },
-                config,
-            )
+            .find_all_refs(FilePosition { file_id: virtual_file_id, offset: file_offset }, config)
             .ok()??
             .upmap_from_ra_fixture(&fixture_analysis, virtual_file_id, position.file_id)
             .ok();
         Some(name) => {
             let def = match NameClass::classify(sema, &name)? {
                 NameClass::Definition(it) | NameClass::ConstReference(it) => it,
-                NameClass::PatFieldShorthand {
-                    local_def: _,
-                    field_ref,
-                    adt_subst: _,
-                } => Definition::Field(field_ref),
+                NameClass::PatFieldShorthand { local_def: _, field_ref, adt_subst: _ } => {
+                    Definition::Field(field_ref)
+                }
             };
             Some(vec![make_searcher(true)(def)])
         }
         None => {
             let search = make_searcher(false);
-            Some(
-                find_defs(sema, &syntax, position.offset)?
-                    .into_iter()
-                    .map(search)
-                    .collect(),
-            )
+            Some(find_defs(sema, &syntax, position.offset)?.into_iter().map(search).collect())
         }
     }
 }
                     }
                     ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {
                         NameClass::Definition(it) | NameClass::ConstReference(it) => it,
-                        NameClass::PatFieldShorthand {
-                            local_def,
-                            field_ref: _,
-                            adt_subst: _,
-                        } => Definition::Local(local_def),
+                        NameClass::PatFieldShorthand { local_def, field_ref: _, adt_subst: _ } => {
+                            Definition::Local(local_def)
+                        }
                     },
                     ast::NameLike::Lifetime(lifetime) => {
                         NameRefClass::classify_lifetime(sema, &lifetime)
     })
     .collect();
 
-    Some(ReferenceSearchResult {
-        declaration: None,
-        references,
-    })
+    Some(ReferenceSearchResult { declaration: None, references })
 }
 
 #[cfg(test)]
     use hir::EditionedFileId;
     use ide_db::{FileId, MiniCore, RootDatabase};
     use stdx::format_to;
-
     use crate::{SearchScope, fixture, references::FindAllRefsConfig};
-
     #[test]
     fn exclude_tests() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_access() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_literal_after_space() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_literal_before_space() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_literal_with_generic_type() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_literal_for_tuple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_literal_for_union() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_after_space() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_variant_record_after_space() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_variant_tuple_before_paren() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_before_space() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_with_generic_type() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_for_tuple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_for_local() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn search_filters_by_range() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_for_param_inside() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_for_fn_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_field_name() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_impl_item_name() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_enum_var_name() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_enum_var_field() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_self() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn test_self_inside_not_adt_impl() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn test_find_all_refs_two_modules() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_decl_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_decl_module_on_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_decl_module_on_self_crate_root() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_super_mod_vis() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_with_scope() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_macro_def() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_basic_highlight_read_write() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_basic_highlight_field_read_write() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_basic_highlight_decl_no_write() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_struct_function_refs_outside_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_nested_module() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_struct_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_enum_var_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_all_refs_enum_var_privacy() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_self_refs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_self_refs_decl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_highlight_if_branches() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_highlight_match_branches() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_highlight_match_arm_arrow() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_highlight_nested_branches() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_highlight_match_with_complex_guards() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_highlight_mixed_if_match_expressions() {
         check(
             "#]],
         );
     }
-
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         check_with_scope(ra_fixture, None, expect)
     }
-
     fn check_with_scope(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         search_scope: Option<&mut dyn FnMut(&RootDatabase) -> SearchScope>,
         }
         expect.assert_eq(actual.trim_start())
     }
-
     #[test]
     fn test_find_lifetimes_function() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_lifetimes_type_alias() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_lifetimes_trait_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_map_range_to_original() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_map_range_to_original_ref() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_labels() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_find_const_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_self_ty() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait_alias() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait_alias_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_attr_differs_from_fn_with_same_name() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_const_in_pattern() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_primitives() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_transitive() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_decl_macro_references() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn macro_doesnt_reference_attribute_on_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multi_def() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn attr_expanded() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn attr_assoc_item() {
         check(
             "#]],
         )
     }
-
     // FIXME: import is classified as function
     #[test]
     fn attr() {
             "#]],
         );
     }
-
     // FIXME: import is classified as function
     #[test]
     fn proc_macro() {
             "#]],
         )
     }
-
     #[test]
     fn derive() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn assoc_items_trait_def() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn assoc_items_trait_impl_def() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn assoc_items_ref() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn name_clashes() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn raw_identifier() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn implicit_format_args() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_fn_kw() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn goto_ref_exit_points() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_ref_yield_points() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_for_kw() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn goto_ref_on_break_kw() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn goto_ref_on_break_kw_for_block() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn goto_ref_on_break_with_label() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_on_return_in_try() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn goto_ref_on_break_in_try() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn goto_ref_on_return_in_async_block() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn goto_ref_on_return_in_macro_call() {
         check(
             "#]],
         )
     }
-
     // The following are tests for short_associated_function_fast_search() in crates/ide-db/src/search.rs, because find all references
     // use `FindUsages` and I found it easy to test it here.
-
     #[test]
     fn goto_ref_on_short_associated_function() {
         cov_mark::check!(short_associated_function_fast_search);
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_on_short_associated_function_with_aliases() {
         cov_mark::check!(short_associated_function_fast_search);
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_on_short_associated_function_self_works() {
         cov_mark::check!(short_associated_function_fast_search);
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_on_short_associated_function_overlapping_self_ranges() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_on_short_associated_function_no_direct_self_but_path_contains_self() {
         cov_mark::check!(short_associated_function_fast_search);
             "#]],
         );
     }
-
     // Checks that we can circumvent our fast path logic using complicated type level functions.
     // This mainly exists as a documentation. I don't believe it is fixable.
     // Usages search is not 100% accurate anyway; we miss macros.
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_on_short_associated_function_same_path_mention_alias_and_self() {
         cov_mark::check!(short_associated_function_fast_search);
             "#]],
         );
     }
-
     #[test]
     fn goto_ref_on_included_file() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_highlight_if_let_match_combined() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_highlight_nested_match_expressions() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn raw_labels_and_lifetimes() {
         check(