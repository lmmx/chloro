COMPARISON DIFF
============================================================

Original size: 21059 bytes
Chloro size:   20623 bytes
Rustfmt size:  21059 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::{
     Direction, NodeOrToken,
     SyntaxKind::{self, *},
-    SyntaxNode, SyntaxToken, T, TextRange, TextSize, TokenAtOffset,
+    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset,
     algo::{self, skip_trivia_token},
     ast::{self, AstNode, AstToken},
+    T,
 };
 
 use crate::FileRange;
 
-// Feature: Expand and Shrink Selection
-//
-// Extends or shrinks the current selection to the encompassing syntactic construct
-// (expression, statement, item, module, etc). It works with multiple cursors.
-//
-// | Editor  | Shortcut |
-// |---------|----------|
-// | VS Code | <kbd>Alt+Shift+→</kbd>, <kbd>Alt+Shift+←</kbd> |
-//
-// ![Expand and Shrink Selection](https://user-images.githubusercontent.com/48062697/113020651-b42fc800-917a-11eb-8a4f-cf1a07859fac.gif)
 pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {
     let sema = Semantics::new(db);
     let src = sema.parse_guess_edition(frange.file_id);
     .last()?;
 
     let range = first.text_range().cover(last.text_range());
-    if range.contains_range(original_range) && original_range != range { Some(range) } else { None }
+    if range.contains_range(original_range) && original_range != range {
+        Some(range)
+    } else {
+        None
+    }
 }
 
 /// Find the shallowest node with same range, which allows us to traverse siblings.
     let to: TextSize = (cursor_position + end_idx).into();
 
     let range = TextRange::new(from, to);
-    if range.is_empty() { None } else { Some(range + leaf.text_range().start()) }
+    if range.is_empty() {
+        None
+    } else {
+        Some(range + leaf.text_range().start())
+    }
 }
 
 fn extend_ws(root: &SyntaxNode, ws: SyntaxToken, offset: TextSize) -> TextRange {
 #[cfg(test)]
 mod tests {
     use crate::fixture;
-
     use super::*;
-
     fn do_check(before: &str, afters: &[&str]) {
         let (analysis, position) = fixture::position(before);
         let before = analysis.file_text(position.file_id).unwrap();
             assert_eq!(after, actual);
         }
     }
-
     #[test]
     fn test_extend_selection_arith() {
         do_check(r#"fn foo() { $01 + 1 }"#, &["1", "1 + 1", "{ 1 + 1 }"]);
     }
-
     #[test]
     fn test_extend_selection_list() {
         do_check(r#"fn foo($0x: i32) {}"#, &["x", "x: i32"]);
             &["33", "33,"],
         );
     }
-
     #[test]
     fn test_extend_selection_start_of_the_line() {
         do_check(
             &["    fn foo() {\n\n    }\n"],
         );
     }
-
     #[test]
     fn test_extend_selection_doc_comments() {
         do_check(
             &["\n    \n", "{\n    \n}", "/// bla\n/// bla\nstruct B {\n    \n}"],
         )
     }
-
     #[test]
     fn test_extend_selection_comments() {
         do_check(
 
         do_check(r#"/$0/foo bar"#, &["//foo bar"]);
     }
-
     #[test]
     fn test_extend_selection_prefer_idents() {
         do_check(
             &["bar", "foo+bar"],
         );
     }
-
     #[test]
     fn test_extend_selection_prefer_lifetimes() {
         do_check(r#"fn foo<$0'a>() {}"#, &["'a", "<'a>"]);
         do_check(r#"fn foo<'a$0>() {}"#, &["'a", "<'a>"]);
     }
-
     #[test]
     fn test_extend_selection_select_first_word() {
         do_check(r#"// foo bar b$0az quxx"#, &["baz", "// foo bar baz quxx"]);
             &["hello", "// hello world"],
         );
     }
-
     #[test]
     fn test_extend_selection_string() {
         do_check(
             &["foo", "\" fn foo() {\""],
         );
     }
-
     #[test]
     fn test_extend_trait_bounds_list_in_where_clause() {
         do_check(
         do_check(r#"fn foo<T>() where T: Copy + $0Display + Sync"#, &["Display", "Display + "]);
         do_check(r#"fn foo<T>() where T: Copy +$0Display"#, &["Display", "+Display"]);
     }
-
     #[test]
     fn test_extend_trait_bounds_list_inline() {
         do_check(r#"fn foo<T: $0Copy>() {}"#, &["Copy"]);
             ],
         );
     }
-
     #[test]
     fn test_extend_selection_on_tuple_in_type() {
         do_check(
             ],
         );
     }
-
     #[test]
     fn test_extend_selection_on_tuple_in_rvalue() {
         do_check(
             ],
         );
     }
-
     #[test]
     fn test_extend_selection_on_tuple_pat() {
         do_check(
             ],
         );
     }
-
     #[test]
     fn extend_selection_inside_macros() {
         do_check(
             ],
         );
     }
-
     #[test]
     fn extend_selection_inside_recur_macros() {
         do_check(
             ],
         );
     }
-
     #[test]
     fn extend_selection_inside_str_with_wide_char() {
         // should not panic