COMPARISON DIFF
============================================================

Original size: 21059 bytes
Chloro size:   21088 bytes
Rustfmt size:  22212 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
     let node = shallowest_node(&node);
 
-    if node
-        .parent()
-        .is_some_and(|n| list_kinds.contains(&n.kind()))
+    if node.parent().is_some_and(|n| list_kinds.contains(&n.kind()))
         && let Some(range) = extend_list_item(&node)
     {
         return Some(range);
 
 /// Find the shallowest node with same range, which allows us to traverse siblings.
 fn shallowest_node(node: &SyntaxNode) -> SyntaxNode {
-    node.ancestors()
-        .take_while(|n| n.text_range() == node.text_range())
-        .last()
-        .unwrap()
+    node.ancestors().take_while(|n| n.text_range() == node.text_range()).last().unwrap()
 }
 
 fn extend_single_word_in_comment_or_string(
     // FIXME: use `ceil_char_boundary` from `std::str` when it gets stable
     // https://github.com/rust-lang/rust/issues/93743
     fn ceil_char_boundary(text: &str, index: u32) -> u32 {
-        (index..)
-            .find(|&index| text.is_char_boundary(index as usize))
-            .unwrap_or(text.len() as u32)
+        (index..).find(|&index| text.is_char_boundary(index as usize)).unwrap_or(text.len() as u32)
     }
 
     let from: TextSize = ceil_char_boundary(text, start_idx + 1).into();
             .filter(is_single_line_ws)
             .unwrap_or(delimiter_node);
 
-        return Some(TextRange::new(
-            node.text_range().start(),
-            final_node.text_range().end(),
-        ));
+        return Some(TextRange::new(node.text_range().start(), final_node.text_range().end()));
     }
     if let Some(delimiter_node) = nearby_delimiter(delimiter, node, Direction::Prev) {
-        return Some(TextRange::new(
-            delimiter_node.text_range().start(),
-            node.text_range().end(),
-        ));
+        return Some(TextRange::new(delimiter_node.text_range().start(), node.text_range().end()));
     }
 
     None
     let prev = adj_comments(&comment, Direction::Prev);
     let next = adj_comments(&comment, Direction::Next);
     if prev != next {
-        Some(TextRange::new(
-            prev.syntax().text_range().start(),
-            next.syntax().text_range().end(),
-        ))
+        Some(TextRange::new(prev.syntax().text_range().start(), next.syntax().text_range().end()))
     } else {
         None
     }
 #[cfg(test)]
 mod tests {
     use crate::fixture;
-
     use super::*;
-
     fn do_check(before: &str, afters: &[&str]) {
         let (analysis, position) = fixture::position(before);
         let before = analysis.file_text(position.file_id).unwrap();
         let range = TextRange::empty(position.offset);
-        let mut frange = FileRange {
-            file_id: position.file_id,
-            range,
-        };
+        let mut frange = FileRange { file_id: position.file_id, range };
 
         for &after in afters {
             frange.range = analysis.extend_selection(frange).unwrap();
             assert_eq!(after, actual);
         }
     }
-
     #[test]
     fn test_extend_selection_arith() {
         do_check(r#"fn foo() { $01 + 1 }"#, &["1", "1 + 1", "{ 1 + 1 }"]);
     }
-
     #[test]
     fn test_extend_selection_list() {
         do_check(r#"fn foo($0x: i32) {}"#, &["x", "x: i32"]);
-        do_check(
-            r#"fn foo($0x: i32, y: i32) {}"#,
-            &["x", "x: i32", "x: i32, "],
-        );
-        do_check(
-            r#"fn foo($0x: i32,y: i32) {}"#,
-            &["x", "x: i32", "x: i32,", "(x: i32,y: i32)"],
-        );
-        do_check(
-            r#"fn foo(x: i32, $0y: i32) {}"#,
-            &["y", "y: i32", ", y: i32"],
-        );
-        do_check(
-            r#"fn foo(x: i32, $0y: i32, ) {}"#,
-            &["y", "y: i32", "y: i32, "],
-        );
+        do_check(r#"fn foo($0x: i32, y: i32) {}"#, &["x", "x: i32", "x: i32, "]);
+        do_check(r#"fn foo($0x: i32,y: i32) {}"#, &["x", "x: i32", "x: i32,", "(x: i32,y: i32)"]);
+        do_check(r#"fn foo(x: i32, $0y: i32) {}"#, &["y", "y: i32", ", y: i32"]);
+        do_check(r#"fn foo(x: i32, $0y: i32, ) {}"#, &["y", "y: i32", "y: i32, "]);
         do_check(r#"fn foo(x: i32,$0y: i32) {}"#, &["y", "y: i32", ",y: i32"]);
 
         do_check(r#"const FOO: [usize; 2] = [ 22$0 , 33];"#, &["22", "22 , "]);
         do_check(r#"const FOO: [usize; 2] = [ 22 , 33$0];"#, &["33", ", 33"]);
-        do_check(
-            r#"const FOO: [usize; 2] = [ 22 , 33$0 ,];"#,
-            &["33", "33 ,", "[ 22 , 33 ,]"],
-        );
+        do_check(r#"const FOO: [usize; 2] = [ 22 , 33$0 ,];"#, &["33", "33 ,", "[ 22 , 33 ,]"]);
 
         do_check(r#"fn main() { (1, 2$0) }"#, &["2", ", 2", "(1, 2)"]);
 
             &["33", "33,"],
         );
     }
-
     #[test]
     fn test_extend_selection_start_of_the_line() {
         do_check(
             &["    fn foo() {\n\n    }\n"],
         );
     }
-
     #[test]
     fn test_extend_selection_doc_comments() {
         do_check(
     $0
 }
             "#,
-            &[
-                "\n    \n",
-                "{\n    \n}",
-                "/// bla\n/// bla\nstruct B {\n    \n}",
-            ],
+            &["\n    \n", "{\n    \n}", "/// bla\n/// bla\nstruct B {\n    \n}"],
         )
     }
-
     #[test]
     fn test_extend_selection_comments() {
         do_check(
 
         do_check(r#"/$0/foo bar"#, &["//foo bar"]);
     }
-
     #[test]
     fn test_extend_selection_prefer_idents() {
         do_check(
             &["bar", "foo+bar"],
         );
     }
-
     #[test]
     fn test_extend_selection_prefer_lifetimes() {
         do_check(r#"fn foo<$0'a>() {}"#, &["'a", "<'a>"]);
         do_check(r#"fn foo<'a$0>() {}"#, &["'a", "<'a>"]);
     }
-
     #[test]
     fn test_extend_selection_select_first_word() {
         do_check(r#"// foo bar b$0az quxx"#, &["baz", "// foo bar baz quxx"]);
             &["hello", "// hello world"],
         );
     }
-
     #[test]
     fn test_extend_selection_string() {
         do_check(
             &["foo", "\" fn foo() {\""],
         );
     }
-
     #[test]
     fn test_extend_trait_bounds_list_in_where_clause() {
         do_check(
             ],
         );
         do_check(r#"fn foo<T>() where T: $0Copy"#, &["Copy"]);
-        do_check(
-            r#"fn foo<T>() where T: $0Copy + Display"#,
-            &["Copy", "Copy + "],
-        );
-        do_check(
-            r#"fn foo<T>() where T: $0Copy +Display"#,
-            &["Copy", "Copy +"],
-        );
+        do_check(r#"fn foo<T>() where T: $0Copy + Display"#, &["Copy", "Copy + "]);
+        do_check(r#"fn foo<T>() where T: $0Copy +Display"#, &["Copy", "Copy +"]);
         do_check(r#"fn foo<T>() where T: $0Copy+Display"#, &["Copy", "Copy+"]);
-        do_check(
-            r#"fn foo<T>() where T: Copy + $0Display"#,
-            &["Display", "+ Display"],
-        );
-        do_check(
-            r#"fn foo<T>() where T: Copy + $0Display + Sync"#,
-            &["Display", "Display + "],
-        );
-        do_check(
-            r#"fn foo<T>() where T: Copy +$0Display"#,
-            &["Display", "+Display"],
-        );
+        do_check(r#"fn foo<T>() where T: Copy + $0Display"#, &["Display", "+ Display"]);
+        do_check(r#"fn foo<T>() where T: Copy + $0Display + Sync"#, &["Display", "Display + "]);
+        do_check(r#"fn foo<T>() where T: Copy +$0Display"#, &["Display", "+Display"]);
     }
-
     #[test]
     fn test_extend_trait_bounds_list_inline() {
         do_check(r#"fn foo<T: $0Copy>() {}"#, &["Copy"]);
         do_check(r#"fn foo<T: $0Copy + Display>() {}"#, &["Copy", "Copy + "]);
         do_check(r#"fn foo<T: $0Copy +Display>() {}"#, &["Copy", "Copy +"]);
         do_check(r#"fn foo<T: $0Copy+Display>() {}"#, &["Copy", "Copy+"]);
-        do_check(
-            r#"fn foo<T: Copy + $0Display>() {}"#,
-            &["Display", "+ Display"],
-        );
-        do_check(
-            r#"fn foo<T: Copy + $0Display + Sync>() {}"#,
-            &["Display", "Display + "],
-        );
-        do_check(
-            r#"fn foo<T: Copy +$0Display>() {}"#,
-            &["Display", "+Display"],
-        );
+        do_check(r#"fn foo<T: Copy + $0Display>() {}"#, &["Display", "+ Display"]);
+        do_check(r#"fn foo<T: Copy + $0Display + Sync>() {}"#, &["Display", "Display + "]);
+        do_check(r#"fn foo<T: Copy +$0Display>() {}"#, &["Display", "+Display"]);
         do_check(
             r#"fn foo<T: Copy$0 + Display, U: Copy>() {}"#,
             &[
             ],
         );
     }
-
     #[test]
     fn test_extend_selection_on_tuple_in_type() {
         do_check(
             r#"fn main() { let _: (krate, $0_crate_def_map, module_id) = (); }"#,
-            &[
-                "_crate_def_map",
-                "_crate_def_map, ",
-                "(krate, _crate_def_map, module_id)",
-            ],
+            &["_crate_def_map", "_crate_def_map, ", "(krate, _crate_def_map, module_id)"],
         );
         // white space variations
         do_check(
             r#"fn main() { let _: (krate,$0_crate_def_map,module_id) = (); }"#,
-            &[
-                "_crate_def_map",
-                "_crate_def_map,",
-                "(krate,_crate_def_map,module_id)",
-            ],
+            &["_crate_def_map", "_crate_def_map,", "(krate,_crate_def_map,module_id)"],
         );
         do_check(
             r#"
             ],
         );
     }
-
     #[test]
     fn test_extend_selection_on_tuple_in_rvalue() {
         do_check(
             r#"fn main() { let var = (krate, _crate_def_map$0, module_id); }"#,
-            &[
-                "_crate_def_map",
-                "_crate_def_map, ",
-                "(krate, _crate_def_map, module_id)",
-            ],
+            &["_crate_def_map", "_crate_def_map, ", "(krate, _crate_def_map, module_id)"],
         );
         // white space variations
         do_check(
             r#"fn main() { let var = (krate,_crate$0_def_map,module_id); }"#,
-            &[
-                "_crate_def_map",
-                "_crate_def_map,",
-                "(krate,_crate_def_map,module_id)",
-            ],
+            &["_crate_def_map", "_crate_def_map,", "(krate,_crate_def_map,module_id)"],
         );
         do_check(
             r#"
             ],
         );
     }
-
     #[test]
     fn test_extend_selection_on_tuple_pat() {
         do_check(
             r#"fn main() { let (krate, _crate_def_map$0, module_id) = var; }"#,
-            &[
-                "_crate_def_map",
-                "_crate_def_map, ",
-                "(krate, _crate_def_map, module_id)",
-            ],
+            &["_crate_def_map", "_crate_def_map, ", "(krate, _crate_def_map, module_id)"],
         );
         // white space variations
         do_check(
             r#"fn main() { let (krate,_crate$0_def_map,module_id) = var; }"#,
-            &[
-                "_crate_def_map",
-                "_crate_def_map,",
-                "(krate,_crate_def_map,module_id)",
-            ],
+            &["_crate_def_map", "_crate_def_map,", "(krate,_crate_def_map,module_id)"],
         );
         do_check(
             r#"
             ],
         );
     }
-
     #[test]
     fn extend_selection_inside_macros() {
         do_check(
             ],
         );
     }
-
     #[test]
     fn extend_selection_inside_recur_macros() {
         do_check(
             ],
         );
     }
-
     #[test]
     fn extend_selection_inside_str_with_wide_char() {
         // should not panic