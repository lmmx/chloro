COMPARISON DIFF
============================================================

Original size: 3032 bytes
Chloro size:   2589 bytes
Rustfmt size:  3074 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use dot::{Id, LabelText};
 use ide_db::base_db::salsa::plumbing::AsId;
 use ide_db::{
-    base_db::{
-        BuiltCrateData, BuiltDependency, Crate, ExtraCrateData, RootQueryDb, SourceDatabase,
-    },
+    base_db::{BuiltCrateData, BuiltDependency, Crate, ExtraCrateData, RootQueryDb, SourceDatabase},
     FxHashMap, RootDatabase,
 };
 
-// Feature: View Crate Graph
-//
-// Renders the currently loaded crate graph as an SVG graphic. Requires the `dot` tool, which
-// is part of graphviz, to be installed.
-//
-// Only workspace crates are included, no crates.io dependencies or sysroot crates.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: View Crate Graph** |
 pub(crate) fn view_crate_graph(db: &RootDatabase, full: bool) -> Result<String, String> {
     let all_crates = db.all_crates();
     let crates_to_render = all_crates
                 true
             } else {
                 // Only render workspace crates
-                let root_id = db
-                    .file_source_root(crate_data.root_file_id)
-                    .source_root_id(db);
+                let root_id = db.file_source_root(crate_data.root_file_id).source_root_id(db);
                 !db.source_root(root_id).source_root(db).is_library
             }
         })
     }
 
     fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> {
-        self.crates_to_render
-            .iter()
-            .flat_map(|(krate, (crate_data, _))| {
-                crate_data
-                    .dependencies
-                    .iter()
-                    .filter(|dep| self.crates_to_render.contains_key(&dep.crate_id))
-                    .map(move |dep| (*krate, dep))
-            })
-            .collect()
+        self.crates_to_render.iter().flat_map(|(krate, (crate_data, _))| {
+            crate_data.dependencies.iter().filter(
+                |dep| self.crates_to_render.contains_key(&dep.crate_id),
+            ).map(
+                move |dep| (*krate, dep),
+            )
+        }).collect(
+        )
     }
 
     fn source(&'a self, edge: &Edge<'a>) -> Crate {