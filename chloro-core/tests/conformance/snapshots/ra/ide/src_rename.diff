COMPARISON DIFF
============================================================

Original size: 91697 bytes
Chloro size:   90802 bytes
Rustfmt size:  91697 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Renaming functionality.
 //!
 //! This is mostly front-end for [`ide_db::rename`], but it also includes the
 //! tests. This module also implements a couple of magic tricks, like renaming
 //! `self` and to `self` (to switch between associated function and method).
 
-use hir::{AsAssocItem, FindPathConfig, HasContainer, HirDisplay, InFile, Name, Semantics, sym};
+use std::fmt::Write;
+
+use hir::{sym, AsAssocItem, FindPathConfig, HasContainer, HirDisplay, InFile, Name, Semantics};
+pub use ide_db::rename::RenameError;
+use ide_db::text_edit::TextEdit;
 use ide_db::{
-    FileId, FileRange, RootDatabase,
     defs::{Definition, NameClass, NameRefClass},
-    rename::{IdentifierKind, RenameDefinition, bail, format_err, source_edit_from_references},
+    rename::{bail, format_err, source_edit_from_references, IdentifierKind, RenameDefinition},
     source_change::SourceChangeBuilder,
+    FileId, FileRange, RootDatabase,
 };
 use itertools::Itertools;
-use std::fmt::Write;
 use stdx::{always, format_to, never};
 use syntax::{
+    ast::{self, prec::ExprPrecedence, HasArgList},
     AstNode, SyntaxKind, SyntaxNode, TextRange, TextSize,
-    ast::{self, HasArgList, prec::ExprPrecedence},
 };
 
-use ide_db::text_edit::TextEdit;
-
 use crate::{FilePosition, RangeInfo, SourceChange};
 
-pub use ide_db::rename::RenameError;
-
 type RenameResult<T> = Result<T, RenameError>;
 
 pub struct RenameConfig {
         });
 
     match res {
-        // ensure at least one definition was found
         Some(res) => res.map(|range| RangeInfo::new(range, ())),
         None => bail!("No references found at position"),
     }
 }
 
-// Feature: Rename
-//
-// Renames the item below the cursor and all of its references
-//
-// | Editor  | Shortcut |
-// |---------|----------|
-// | VS Code | <kbd>F2</kbd> |
-//
-// ![Rename](https://user-images.githubusercontent.com/48062697/113065582-055aae80-91b1-11eb-8ade-2b58e6d81883.gif)
 pub(crate) fn rename(
     db: &RootDatabase,
     position: FilePosition,
         })),
     };
 
-    ops?.into_iter()
-        .chain(alias_fallback)
-        .reduce(|acc, elem| acc.merge(elem))
-        .ok_or_else(|| format_err!("No references found at position"))
+    ops?.into_iter().chain(alias_fallback).reduce(|acc, elem| acc.merge(elem)).ok_or_else(
+        || format_err!("No references found at position"),
+    )
 }
 
 /// Called by the client when it is about to rename a file.
     Some(change)
 }
 
-// FIXME: Should support `extern crate`.
 fn alias_fallback(
     syntax: &SyntaxNode,
     FilePosition { file_id, offset }: FilePosition,
     syntax: &SyntaxNode,
     FilePosition { file_id, offset }: FilePosition,
     new_name: &Name,
-) -> RenameResult<impl Iterator<Item = (FileRange, SyntaxKind, Definition, Name, RenameDefinition)>>
-{
+) -> RenameResult<impl Iterator<Item = (FileRange, SyntaxKind, Definition, Name, RenameDefinition)>> {
     let maybe_format_args =
         syntax.token_at_offset(offset).find(|t| matches!(t.kind(), SyntaxKind::STRING));
 
     let res: RenameResult<Vec<_>> = ok_if_any(symbols.filter_map(Result::transpose));
     match res {
         Ok(v) => {
-            // remove duplicates, comparing `Definition`s
-            Ok(v.into_iter()
-                .unique_by(|&(.., def, _, _)| def)
-                .map(|(a, b, c, d, e)| (a.into_file_id(sema.db), b, c, d, e))
-                .collect::<Vec<_>>()
-                .into_iter())
-        }
+            Ok(v.into_iter().unique_by(|&(.., def, _, _)| def).map(
+                |(a, b, c, d, e)| (a.into_file_id(sema.db), b, c, d, e),
+            ).collect::<Vec<_>>(
+            ).into_iter(
+            ))
+        },
         Err(e) => Err(e),
     }
 }
                 continue;
             };
             let path = path.parent_path();
-            // The `PathExpr` is the direct parent, above it is the `CallExpr`.
             let Some(call) =
                 path.syntax().parent().and_then(|it| ast::CallExpr::cast(it.parent()?))
             else {
                 continue;
             };
-
             let Some(arg_list) = call.arg_list() else { continue };
             let mut args = arg_list.args();
             let Some(mut self_arg) = args.next() else { continue };
             let second_arg = args.next();
-
-            // Strip (de)references, as they will be taken automatically by auto(de)ref.
             loop {
                 let self_ = match &self_arg {
                     ast::Expr::RefExpr(self_) => self_.expr(),
                     None => break,
                 };
             }
-
             let self_needs_parens =
                 self_arg.precedence().needs_parentheses_in(ExprPrecedence::Postfix);
-
             let replace_start = path.syntax().text_range().start();
             let replace_end = match second_arg {
                 Some(second_arg) => second_arg.syntax().text_range().start(),
             else {
                 continue;
             };
-
             let Some(macro_mapped_self) = sema.original_range_opt(self_arg.syntax()) else {
                 continue;
             };
             replacement.push('.');
             format_to!(replacement, "{fn_name}");
             replacement.push('(');
-
             source_change.insert_source_edit(
                 replace_range.file_id.file_id(sema.db),
                 TextEdit::replace(replace_range.range, replacement),
             let Some(mut self_arg) = method_call.receiver() else {
                 continue;
             };
-
             let Some(scope) = sema.scope(fn_name.syntax()) else {
                 continue;
             };
             let self_adjust = method_to_assoc_fn_call_self_adjust(sema, &self_arg);
-
-            // Strip parentheses, function arguments have higher precedence than any operator.
             while let ast::Expr::ParenExpr(it) = &self_arg {
                 self_arg = match it.expr() {
                     Some(it) => it,
                     None => break,
                 };
             }
-
             let needs_comma = method_call.arg_list().is_some_and(|it| it.args().next().is_some());
-
             let self_needs_parens = self_adjust != CallReceiverAdjust::None
                 && self_arg.precedence().needs_parentheses_in(ExprPrecedence::Prefix);
-
             let replace_start = method_call.syntax().text_range().start();
             let replace_end = method_call
                 .arg_list()
             else {
                 continue;
             };
-
             let fn_container_path = match f.container(sema.db) {
                 hir::ItemContainer::Trait(trait_) => {
                     // FIXME: We always put it as `Trait::function`. Is it better to use `Type::function` (but
                 }
                 _ => continue,
             };
-
             let Some(macro_mapped_self) = sema.original_range_opt(self_arg.syntax()) else {
                 continue;
             };
             if needs_comma {
                 replacement.push_str(", ");
             }
-
             source_change.insert_source_edit(
                 replace_range.file_id.file_id(sema.db),
                 TextEdit::replace(replace_range.range, replacement),
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{Expect, expect};
+    use expect_test::{expect, Expect};
     use ide_db::source_change::SourceChange;
     use ide_db::text_edit::TextEdit;
     use itertools::Itertools;
     use stdx::trim_indent;
     use test_utils::assert_eq_text;
-
     use crate::fixture;
-
     use super::{RangeInfo, RenameConfig, RenameError};
-
-    const TEST_CONFIG: RenameConfig =
-        RenameConfig { prefer_no_std: false, prefer_prelude: true, prefer_absolute: false };
-
+    const TEST_CONFIG: RenameConfig = RenameConfig { prefer_no_std: false, prefer_prelude: true, prefer_absolute: false };
     #[track_caller]
     fn check(
         new_name: &str,
             }
         };
     }
-
     #[track_caller]
     fn check_conflicts(new_name: &str, #[rust_analyzer::rust_fixture] ra_fixture: &str) {
         let (analysis, position, conflicts) = fixture::annotations(ra_fixture);
             "rename conflicts mismatch: {source_change:#?}"
         );
     }
-
     fn check_expect(
         new_name: &str,
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
             .expect("Expect returned a RenameError");
         expect.assert_eq(&filter_expect(source_change))
     }
-
     fn check_expect_will_rename_file(
         new_name: &str,
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
             .expect("Expect returned a RenameError");
         expect.assert_eq(&filter_expect(source_change))
     }
-
     fn check_prepare(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (analysis, position) = fixture::position(ra_fixture);
         let result = analysis
             Err(RenameError(err)) => expect.assert_eq(&err),
         };
     }
-
     fn filter_expect(source_change: SourceChange) -> String {
         let source_file_edits = source_change
             .source_file_edits
             source_file_edits, source_change.file_system_edits
         )
     }
-
     #[test]
     fn rename_will_shadow() {
         check_conflicts(
         "#,
         );
     }
-
     #[test]
     fn rename_will_be_shadowed() {
         check_conflicts(
         "#,
         );
     }
-
     #[test]
     fn test_prepare_rename_namelikes() {
         check_prepare(r"fn name$0<'lifetime>() {}", expect![[r#"3..7: name"#]]);
         check_prepare(r"fn name<'lifetime$0>() {}", expect![[r#"9..17: lifetime"#]]);
         check_prepare(r"fn name<'lifetime>() { name$0(); }", expect![[r#"23..27: name"#]]);
     }
-
     #[test]
     fn test_prepare_rename_in_macro() {
         check_prepare(
             expect![[r#"83..86: Foo"#]],
         );
     }
-
     #[test]
     fn test_prepare_rename_keyword() {
         check_prepare(r"struct$0 Foo;", expect![[r#"No references found at position"#]]);
     }
-
     #[test]
     fn test_prepare_rename_tuple_field() {
         check_prepare(
             expect![[r#"No references found at position"#]],
         );
     }
-
     #[test]
     fn test_prepare_rename_builtin() {
         check_prepare(
             expect![[r#"No references found at position"#]],
         );
     }
-
     #[test]
     fn test_prepare_rename_self() {
         check_prepare(
             expect![[r#"No references found at position"#]],
         );
     }
-
     #[test]
     fn test_rename_to_underscore() {
         check("_", r#"fn main() { let i$0 = 1; }"#, r#"fn main() { let _ = 1; }"#);
     }
-
     #[test]
     fn test_rename_to_raw_identifier() {
         check("r#fn", r#"fn main() { let i$0 = 1; }"#, r#"fn main() { let r#fn = 1; }"#);
     }
-
     #[test]
     fn test_rename_to_invalid_identifier1() {
         check(
             "error: Invalid name `invalid!`: not an identifier",
         );
     }
-
     #[test]
     fn test_rename_to_invalid_identifier2() {
         check(
             "error: Invalid name `multiple tokens`: not an identifier",
         );
     }
-
     #[test]
     fn test_rename_to_invalid_identifier3() {
         check(
             "error: Invalid name `super`: cannot rename to a keyword",
         );
     }
-
     #[test]
     fn test_rename_to_invalid_identifier_lifetime() {
         cov_mark::check!(rename_not_an_ident_ref);
             "error: Invalid name `'foo`: not an identifier",
         );
     }
-
     #[test]
     fn test_rename_to_invalid_identifier_lifetime2() {
         check(
             r#"error: Invalid name `_`: not a lifetime identifier"#,
         );
     }
-
     #[test]
     fn test_rename_accepts_lifetime_without_apostrophe() {
         check("foo", r#"fn main<'a>(_: &'a$0 ()) {}"#, r#"fn main<'foo>(_: &'foo ()) {}"#);
     }
-
     #[test]
     fn test_rename_to_underscore_invalid() {
         cov_mark::check!(rename_underscore_multiple);
             "error: Cannot rename reference to `_` as it is being referenced multiple times",
         );
     }
-
     #[test]
     fn test_rename_mod_invalid() {
         check(
             "error: Invalid name `'foo`: cannot rename module to 'foo",
         );
     }
-
     #[test]
     fn test_rename_mod_invalid_raw_ident() {
         check(
             "error: Invalid name `self`: cannot rename module to self",
         );
     }
-
     #[test]
     fn test_rename_for_local() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_unresolved_reference() {
         check(
             "error: No references found at position",
         );
     }
-
     #[test]
     fn test_rename_macro_multiple_occurrences() {
         check(
     "#,
         )
     }
-
     #[test]
     fn test_rename_for_macro_args() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_for_macro_args_rev() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_for_macro_define_fn() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_for_macro_define_fn_rev() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_for_param_inside() {
         check("j", r#"fn foo(i : u32) -> u32 { i$0 }"#, r#"fn foo(j : u32) -> u32 { j }"#);
     }
-
     #[test]
     fn test_rename_refs_for_fn_param() {
         check("j", r#"fn foo(i$0 : u32) -> u32 { i }"#, r#"fn foo(j : u32) -> u32 { j }"#);
     }
-
     #[test]
     fn test_rename_for_mut_param() {
         check("j", r#"fn foo(mut i$0 : u32) -> u32 { i }"#, r#"fn foo(mut j : u32) -> u32 { j }"#);
     }
-
     #[test]
     fn test_rename_struct_field() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_field_in_field_shorthand() {
         cov_mark::check!(test_rename_field_in_field_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_rename_local_in_field_shorthand() {
         cov_mark::check!(test_rename_local_in_field_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_field_shorthand_correct_struct() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_shadow_local_for_struct_shorthand() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_mod() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_mod_in_use_tree() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_mod_in_dir() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_unusually_nested_mod() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_module_rename_in_path() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_mod_filename_and_path() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_mod_recursive() {
         check_expect(
             "#,
         )
     }
-
     #[test]
     fn test_rename_mod_in_macro() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_rename_mod_for_crate_root() {
         check_expect_will_rename_file(
             "#]],
         )
     }
-
     #[test]
     fn test_rename_mod_to_raw_ident() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_mod_from_raw_ident() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_each_usage_gets_appropriate_rawness() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn rename_raw_identifier() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_variant_from_module_1() {
         cov_mark::check!(rename_non_local);
 "#,
         );
     }
-
     #[test]
     fn test_enum_variant_from_module_2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_parameter_to_self() {
         cov_mark::check!(rename_to_self);
 "#,
         );
     }
-
     #[test]
     fn test_parameter_to_self_error_no_impl() {
         check(
             "error: Parameter type differs from impl block type",
         );
     }
-
     #[test]
     fn test_parameter_to_self_error_not_first() {
         check(
             "error: Only the first parameter may be renamed to self",
         );
     }
-
     #[test]
     fn test_parameter_to_self_impl_ref() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_self_to_parameter() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_owned_self_to_parameter() {
         cov_mark::check!(rename_self_to_param);
 "#,
         );
     }
-
     #[test]
     fn test_owned_self_to_parameter_with_lifetime() {
         cov_mark::check!(rename_self_to_param);
 "#,
         );
     }
-
     #[test]
     fn test_self_outside_of_methods() {
         check(
 "#,
         );
     }
-
     #[test]
     fn no_type_value_ns_confuse() {
         // Test that we don't rename items from different namespaces.
 "#,
         );
     }
-
     #[test]
     fn test_self_in_path_to_parameter() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_field_put_init_shorthand() {
         cov_mark::check!(test_rename_field_put_init_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_rename_local_simple() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_local_put_init_shorthand() {
         cov_mark::check!(test_rename_local_put_init_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_struct_field_pat_into_shorthand() {
         cov_mark::check!(test_rename_field_put_init_shorthand_pat);
 "#,
         );
     }
-
     #[test]
     fn test_struct_local_pat_into_shorthand() {
         cov_mark::check!(test_rename_local_put_init_shorthand_pat);
 "#,
         );
     }
-
     #[test]
     fn test_rename_binding_in_destructure_pat() {
         let expected_fixture = r#"
             expected_fixture,
         );
     }
-
     #[test]
     fn test_rename_binding_in_destructure_param_pat() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_struct_field_complex_ident_pat() {
         cov_mark::check!(rename_record_pat_field_name_split);
 "#,
         );
     }
-
     #[test]
     fn test_rename_lifetimes() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_rename_bind_pat() {
         check(
 }"#,
         );
     }
-
     #[test]
     fn test_rename_label() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_rename_label_new_name_without_apostrophe() {
         check(
         "#,
         );
     }
-
     #[test]
     fn test_self_to_self() {
         cov_mark::check!(rename_self_to_self);
 "#,
         )
     }
-
     #[test]
     fn test_rename_field_in_pat_in_macro_doesnt_shorthand() {
         // ideally we would be able to make this emit a short hand, but I doubt this is easily possible
 "#,
         )
     }
-
     #[test]
     fn test_rename_tuple_field() {
         check(
             "error: No references found at position",
         );
     }
-
     #[test]
     fn test_rename_builtin() {
         check(
             "error: Cannot rename builtin type",
         );
     }
-
     #[test]
     fn test_rename_self() {
         check(
             "error: No references found at position",
         );
     }
-
     #[test]
     fn test_rename_ignores_self_ty() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_fails_on_aliases() {
         check(
             "error: Renaming aliases is currently unsupported",
         );
     }
-
     #[test]
     fn test_rename_trait_method() {
         let res = r"
             res,
         );
     }
-
     #[test]
     fn test_rename_trait_method_prefix_of_second() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_trait_const() {
         let res = r"
             res,
         );
     }
-
     #[test]
     fn defs_from_macros_arent_renamed() {
         check(
             "error: No identifier available to rename",
         )
     }
-
     #[test]
     fn attributed_item() {
         check(
 "#,
         )
     }
-
     #[test]
     fn in_macro_multi_mapping() {
         check(
 "#,
         )
     }
-
     #[test]
     fn rename_multi_local() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_13498() {
         check(
 ",
         )
     }
-
     #[test]
     fn extern_crate() {
         check_prepare(
         // ",
         //         );
     }
-
     #[test]
     fn extern_crate_rename() {
         check_prepare(
         // ",
         //         );
     }
-
     #[test]
     fn extern_crate_self() {
         check_prepare(
         // ",
         //         );
     }
-
     #[test]
     fn extern_crate_self_rename() {
         check_prepare(
         // ",
         //         );
     }
-
     #[test]
     fn disallow_renaming_for_non_local_definition() {
         check(
             "error: Cannot rename a non-local definition",
         );
     }
-
     #[test]
     fn disallow_renaming_for_builtin_macros() {
         check(
             "error: Cannot rename a non-local definition",
         );
     }
-
     #[test]
     fn implicit_format_args() {
         check(
 "#,
         );
     }
-
     #[test]
     fn implicit_format_args2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn asm_operand() {
         check(
 "#,
         );
     }
-
     #[test]
     fn asm_operand2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_path_inside_use_tree() {
         check(
 "#,
         )
     }
-
     #[test]
     fn rename_path_inside_use_tree_foreign() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_type_param_ref_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_type_param_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_lifetime_param_ref_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_lifetime_param_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_parent_type_param_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_macro_generated_type_from_type_with_a_suffix() {
         check(
 "#,
         );
     }
-
     #[test]
-    // FIXME
     #[should_panic]
     fn rename_macro_generated_type_from_type_usage_with_a_suffix() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_macro_generated_type_from_variant_with_a_suffix() {
         check(
 "#,
         );
     }
-
     #[test]
-    // FIXME
     #[should_panic]
     fn rename_macro_generated_type_from_variant_usage_with_a_suffix() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_to_self_callers() {
         check(
         "#,
         );
     }
-
     #[test]
     fn rename_to_self_callers_in_macro() {
         check(
         "#,
         );
     }
-
     #[test]
     fn rename_from_self_callers() {
         check(