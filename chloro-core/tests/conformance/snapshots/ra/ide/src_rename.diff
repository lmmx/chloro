COMPARISON DIFF
============================================================

Original size: 91697 bytes
Chloro size:   91262 bytes
Rustfmt size:  91697 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Renaming functionality.
 //!
 //! This is mostly front-end for [`ide_db::rename`], but it also includes the
 //! tests. This module also implements a couple of magic tricks, like renaming
 //! `self` and to `self` (to switch between associated function and method).
 
+use std::fmt::Write;
+
 use hir::{AsAssocItem, FindPathConfig, HasContainer, HirDisplay, InFile, Name, Semantics, sym};
+pub use ide_db::rename::RenameError;
+use ide_db::text_edit::TextEdit;
 use ide_db::{
-    FileId, FileRange, RootDatabase,
-    defs::{Definition, NameClass, NameRefClass},
-    rename::{IdentifierKind, RenameDefinition, bail, format_err, source_edit_from_references},
+    bail,
+
+    defs::{Definition,
+
+    format_err,
+
+    rename::{IdentifierKind,
+
     source_change::SourceChangeBuilder,
+
+    source_edit_from_references}, FileId, FileRange, NameClass, NameRefClass}, RenameDefinition,
+    RootDatabase,
 };
 use itertools::Itertools;
-use std::fmt::Write;
 use stdx::{always, format_to, never};
 use syntax::{
-    AstNode, SyntaxKind, SyntaxNode, TextRange, TextSize,
-    ast::{self, HasArgList, prec::ExprPrecedence},
+    ast::{self,
+
+    prec::ExprPrecedence},
+
+    AstNode, HasArgList, SyntaxKind, SyntaxNode, TextRange, TextSize,
 };
 
-use ide_db::text_edit::TextEdit;
-
 use crate::{FilePosition, RangeInfo, SourceChange};
 
-pub use ide_db::rename::RenameError;
-
 type RenameResult<T> = Result<T, RenameError>;
 
 pub struct RenameConfig {
     let sema = Semantics::new(db);
     let source_file = sema.parse_guess_edition(position.file_id);
     let syntax = source_file.syntax();
-
     let res = find_definitions(&sema, syntax, position, &Name::new_symbol_root(sym::underscore))?
         .filter(|(_, _, def, _, _)| def.range_for_rename(&sema).is_some())
         .map(|(frange, kind, _, _, _)| {
             (e @ Err(_), _) | (_, e @ Err(_)) => e,
             _ => bail!("inconsistent text range"),
         });
-
     match res {
         // ensure at least one definition was found
         Some(res) => res.map(|range| RangeInfo::new(range, ())),
     }
 }
 
-// Feature: Rename
-//
-// Renames the item below the cursor and all of its references
-//
-// | Editor  | Shortcut |
-// |---------|----------|
-// | VS Code | <kbd>F2</kbd> |
-//
-// ![Rename](https://user-images.githubusercontent.com/48062697/113065582-055aae80-91b1-11eb-8ade-2b58e6d81883.gif)
 pub(crate) fn rename(
     db: &RootDatabase,
     position: FilePosition,
         .ok_or_else(|| format_err!("No references found at position"))?;
     let source_file = sema.parse(file_id);
     let syntax = source_file.syntax();
-
     let edition = file_id.edition(db);
     let (new_name, kind) = IdentifierKind::classify(edition, new_name)?;
-
     let defs = find_definitions(&sema, syntax, position, &new_name)?;
     let alias_fallback =
         alias_fallback(syntax, position, &new_name.display(db, edition).to_string());
-
     let ops: RenameResult<Vec<SourceChange>> = match alias_fallback {
         Some(_) => ok_if_any(
             defs
             def.rename(&sema, new_name.as_str(), rename_def)
         })),
     };
-
     ops?.into_iter()
         .chain(alias_fallback)
         .reduce(|acc, elem| acc.merge(elem))
     Some(change)
 }
 
-// FIXME: Should support `extern crate`.
 fn alias_fallback(
     syntax: &SyntaxNode,
     FilePosition { file_id, offset }: FilePosition,
         .token_at_offset(offset)
         .flat_map(|syntax| syntax.parent_ancestors())
         .find_map(ast::UseTree::cast)?;
-
     let last_path_segment = use_tree.path()?.segments().last()?.name_ref()?;
     if !last_path_segment.syntax().text_range().contains_inclusive(offset) {
         return None;
     };
-
     let mut builder = SourceChangeBuilder::new(file_id);
-
     match use_tree.rename() {
         Some(rename) => {
             let offset = rename.syntax().text_range();
             builder.insert(offset, format!(" as {new_name}"));
         }
     }
-
     Some(builder.finish())
 }
 
     syntax: &SyntaxNode,
     FilePosition { file_id, offset }: FilePosition,
     new_name: &Name,
-) -> RenameResult<impl Iterator<Item = (FileRange, SyntaxKind, Definition, Name, RenameDefinition)>>
-{
+) -> RenameResult<impl Iterator<Item = (FileRange, SyntaxKind, Definition, Name, RenameDefinition)>> {
     let maybe_format_args =
         syntax.token_at_offset(offset).find(|t| matches!(t.kind(), SyntaxKind::STRING));
-
     if let Some((range, _, _, Some(resolution))) =
         maybe_format_args.and_then(|token| sema.check_for_format_args_template(token, offset))
     {
         )]
         .into_iter());
     }
-
     let original_ident = syntax
         .token_at_offset(offset)
         .max_by_key(|t| {
                 }
             })
         });
-
     let res: RenameResult<Vec<_>> = ok_if_any(symbols.filter_map(Result::transpose));
     match res {
         Ok(v) => {
     if never!(local.is_self(sema.db)) {
         bail!("rename_to_self invoked on self");
     }
-
     let fn_def = match local.parent(sema.db) {
         hir::DefWithBody::Function(func) => func,
         _ => bail!("Cannot rename local to self outside of function"),
     };
-
     if fn_def.self_param(sema.db).is_some() {
         bail!("Method already has a self parameter");
     }
-
     let params = fn_def.assoc_fn_params(sema.db);
     let first_param = params
         .first()
         }
         None => bail!("rename_to_self invoked on destructuring parameter"),
     }
-
     let assoc_item = fn_def
         .as_assoc_item(sema.db)
         .ok_or_else(|| format_err!("Cannot rename parameter to self for free function"))?;
             (ty, if first_param_ty.is_mutable_reference() { "&mut self" } else { "&self" })
         })
     };
-
     if ty != impl_ty {
         bail!("Parameter type differs from impl block type");
     }
-
     let InFile { file_id, value: param_source } = sema
         .source(first_param.clone())
         .ok_or_else(|| format_err!("No source for parameter found"))?;
-
     let def = Definition::Local(local);
     let usages = def.usages(sema).all();
     let mut source_change = SourceChange::default();
         cov_mark::hit!(rename_self_to_self);
         return Ok(SourceChange::default());
     }
-
     let fn_def = match local.parent(sema.db) {
         hir::DefWithBody::Function(func) => func,
         _ => bail!("Cannot rename local to self outside of function"),
     };
-
     let InFile { file_id, value: self_param } =
         sema.source(self_param).ok_or_else(|| format_err!("cannot find function source"))?;
-
     let def = Definition::Local(local);
     let usages = def.usages(sema).all();
     let edit = text_edit_from_self_param(
     Ok(source_change)
 }
 
-fn text_edit_from_self_param(self_param: &ast::SelfParam, new_name: String) -> Option<TextEdit> {
+fn text_edit_from_self_param(
+    self_param: &ast::SelfParam,
+    new_name: String,
+) -> Option<TextEdit> {
     let mut replacement_text = new_name;
     replacement_text.push_str(": ");
-
     if self_param.amp_token().is_some() {
         replacement_text.push('&');
     }
     if self_param.amp_token().and(self_param.mut_token()).is_some() {
         replacement_text.push_str("mut ");
     }
-
     replacement_text.push_str("Self");
-
     Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))
 }
 
     use itertools::Itertools;
     use stdx::trim_indent;
     use test_utils::assert_eq_text;
-
     use crate::fixture;
-
     use super::{RangeInfo, RenameConfig, RenameError};
-
-    const TEST_CONFIG: RenameConfig =
-        RenameConfig { prefer_no_std: false, prefer_prelude: true, prefer_absolute: false };
-
+    const TEST_CONFIG: RenameConfig = RenameConfig { prefer_no_std: false, prefer_prelude: true, prefer_absolute: false };
     #[track_caller]
     fn check(
         new_name: &str,
             }
         };
     }
-
     #[track_caller]
-    fn check_conflicts(new_name: &str, #[rust_analyzer::rust_fixture] ra_fixture: &str) {
+    fn check_conflicts(
+        new_name: &str,
+        #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    ) {
         let (analysis, position, conflicts) = fixture::annotations(ra_fixture);
         let source_change = analysis.rename(position, new_name, &TEST_CONFIG).unwrap().unwrap();
         let expected_conflicts = conflicts
             "rename conflicts mismatch: {source_change:#?}"
         );
     }
-
     fn check_expect(
         new_name: &str,
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
             .expect("Expect returned a RenameError");
         expect.assert_eq(&filter_expect(source_change))
     }
-
     fn check_expect_will_rename_file(
         new_name: &str,
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
             .expect("Expect returned a RenameError");
         expect.assert_eq(&filter_expect(source_change))
     }
-
-    fn check_prepare(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+    fn check_prepare(
+        #[rust_analyzer::rust_fixture] ra_fixture: &str,
+        expect: Expect,
+    ) {
         let (analysis, position) = fixture::position(ra_fixture);
         let result = analysis
             .prepare_rename(position)
             Err(RenameError(err)) => expect.assert_eq(&err),
         };
     }
-
     fn filter_expect(source_change: SourceChange) -> String {
         let source_file_edits = source_change
             .source_file_edits
             .into_iter()
             .map(|(id, (text_edit, _))| (id, text_edit.into_iter().collect::<Vec<_>>()))
             .collect::<Vec<_>>();
-
         format!(
             "source_file_edits: {:#?}\nfile_system_edits: {:#?}\n",
             source_file_edits, source_change.file_system_edits
         )
     }
-
     #[test]
     fn rename_will_shadow() {
         check_conflicts(
         "#,
         );
     }
-
     #[test]
     fn rename_will_be_shadowed() {
         check_conflicts(
         "#,
         );
     }
-
     #[test]
     fn test_prepare_rename_namelikes() {
         check_prepare(r"fn name$0<'lifetime>() {}", expect![[r#"3..7: name"#]]);
         check_prepare(r"fn name<'lifetime$0>() {}", expect![[r#"9..17: lifetime"#]]);
         check_prepare(r"fn name<'lifetime>() { name$0(); }", expect![[r#"23..27: name"#]]);
     }
-
     #[test]
     fn test_prepare_rename_in_macro() {
         check_prepare(
             expect![[r#"83..86: Foo"#]],
         );
     }
-
     #[test]
     fn test_prepare_rename_keyword() {
         check_prepare(r"struct$0 Foo;", expect![[r#"No references found at position"#]]);
     }
-
     #[test]
     fn test_prepare_rename_tuple_field() {
         check_prepare(
             expect![[r#"No references found at position"#]],
         );
     }
-
     #[test]
     fn test_prepare_rename_builtin() {
         check_prepare(
             expect![[r#"No references found at position"#]],
         );
     }
-
     #[test]
     fn test_prepare_rename_self() {
         check_prepare(
             expect![[r#"No references found at position"#]],
         );
     }
-
     #[test]
     fn test_rename_to_underscore() {
         check("_", r#"fn main() { let i$0 = 1; }"#, r#"fn main() { let _ = 1; }"#);
     }
-
     #[test]
     fn test_rename_to_raw_identifier() {
         check("r#fn", r#"fn main() { let i$0 = 1; }"#, r#"fn main() { let r#fn = 1; }"#);
     }
-
     #[test]
     fn test_rename_to_invalid_identifier1() {
         check(
             "error: Invalid name `invalid!`: not an identifier",
         );
     }
-
     #[test]
     fn test_rename_to_invalid_identifier2() {
         check(
             "error: Invalid name `multiple tokens`: not an identifier",
         );
     }
-
     #[test]
     fn test_rename_to_invalid_identifier3() {
         check(
             "error: Invalid name `super`: cannot rename to a keyword",
         );
     }
-
     #[test]
     fn test_rename_to_invalid_identifier_lifetime() {
         cov_mark::check!(rename_not_an_ident_ref);
             "error: Invalid name `'foo`: not an identifier",
         );
     }
-
     #[test]
     fn test_rename_to_invalid_identifier_lifetime2() {
         check(
             r#"error: Invalid name `_`: not a lifetime identifier"#,
         );
     }
-
     #[test]
     fn test_rename_accepts_lifetime_without_apostrophe() {
         check("foo", r#"fn main<'a>(_: &'a$0 ()) {}"#, r#"fn main<'foo>(_: &'foo ()) {}"#);
     }
-
     #[test]
     fn test_rename_to_underscore_invalid() {
         cov_mark::check!(rename_underscore_multiple);
             "error: Cannot rename reference to `_` as it is being referenced multiple times",
         );
     }
-
     #[test]
     fn test_rename_mod_invalid() {
         check(
             "error: Invalid name `'foo`: cannot rename module to 'foo",
         );
     }
-
     #[test]
     fn test_rename_mod_invalid_raw_ident() {
         check(
             "error: Invalid name `self`: cannot rename module to self",
         );
     }
-
     #[test]
     fn test_rename_for_local() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_unresolved_reference() {
         check(
             "error: No references found at position",
         );
     }
-
     #[test]
     fn test_rename_macro_multiple_occurrences() {
         check(
     "#,
         )
     }
-
     #[test]
     fn test_rename_for_macro_args() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_for_macro_args_rev() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_for_macro_define_fn() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_for_macro_define_fn_rev() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_for_param_inside() {
         check("j", r#"fn foo(i : u32) -> u32 { i$0 }"#, r#"fn foo(j : u32) -> u32 { j }"#);
     }
-
     #[test]
     fn test_rename_refs_for_fn_param() {
         check("j", r#"fn foo(i$0 : u32) -> u32 { i }"#, r#"fn foo(j : u32) -> u32 { j }"#);
     }
-
     #[test]
     fn test_rename_for_mut_param() {
         check("j", r#"fn foo(mut i$0 : u32) -> u32 { i }"#, r#"fn foo(mut j : u32) -> u32 { j }"#);
     }
-
     #[test]
     fn test_rename_struct_field() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_field_in_field_shorthand() {
         cov_mark::check!(test_rename_field_in_field_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_rename_local_in_field_shorthand() {
         cov_mark::check!(test_rename_local_in_field_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_field_shorthand_correct_struct() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_shadow_local_for_struct_shorthand() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_mod() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_mod_in_use_tree() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_mod_in_dir() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_unusually_nested_mod() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_module_rename_in_path() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_mod_filename_and_path() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_mod_recursive() {
         check_expect(
             "#,
         )
     }
-
     #[test]
     fn test_rename_mod_in_macro() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_rename_mod_for_crate_root() {
         check_expect_will_rename_file(
             "#]],
         )
     }
-
     #[test]
     fn test_rename_mod_to_raw_ident() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_mod_from_raw_ident() {
         check_expect(
             "#]],
         );
     }
-
     #[test]
     fn test_rename_each_usage_gets_appropriate_rawness() {
         check_expect(
                 file_system_edits: []
             "#]],
         );
-
         check_expect(
             "dyn",
             r#"
                 file_system_edits: []
             "#]],
         );
-
         check_expect(
             "r#dyn",
             r#"
             "#]],
         );
     }
-
     #[test]
     fn rename_raw_identifier() {
         check_expect(
                 file_system_edits: []
             "#]],
         );
-
         check_expect(
             "abc",
             r#"
             "#]],
         );
     }
-
     #[test]
     fn test_enum_variant_from_module_1() {
         cov_mark::check!(rename_non_local);
 "#,
         );
     }
-
     #[test]
     fn test_enum_variant_from_module_2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_parameter_to_self() {
         cov_mark::check!(rename_to_self);
 "#,
         );
     }
-
     #[test]
     fn test_parameter_to_self_error_no_impl() {
         check(
             "error: Parameter type differs from impl block type",
         );
     }
-
     #[test]
     fn test_parameter_to_self_error_not_first() {
         check(
             "error: Only the first parameter may be renamed to self",
         );
     }
-
     #[test]
     fn test_parameter_to_self_impl_ref() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_self_to_parameter() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_owned_self_to_parameter() {
         cov_mark::check!(rename_self_to_param);
 "#,
         );
     }
-
     #[test]
     fn test_owned_self_to_parameter_with_lifetime() {
         cov_mark::check!(rename_self_to_param);
 "#,
         );
     }
-
     #[test]
     fn test_self_outside_of_methods() {
         check(
 "#,
         );
     }
-
     #[test]
     fn no_type_value_ns_confuse() {
         // Test that we don't rename items from different namespaces.
 "#,
         );
     }
-
     #[test]
     fn test_self_in_path_to_parameter() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_field_put_init_shorthand() {
         cov_mark::check!(test_rename_field_put_init_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_rename_local_simple() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_local_put_init_shorthand() {
         cov_mark::check!(test_rename_local_put_init_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_struct_field_pat_into_shorthand() {
         cov_mark::check!(test_rename_field_put_init_shorthand_pat);
 "#,
         );
     }
-
     #[test]
     fn test_struct_local_pat_into_shorthand() {
         cov_mark::check!(test_rename_local_put_init_shorthand_pat);
 "#,
         );
     }
-
     #[test]
     fn test_rename_binding_in_destructure_pat() {
         let expected_fixture = r#"
             expected_fixture,
         );
     }
-
     #[test]
     fn test_rename_binding_in_destructure_param_pat() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_struct_field_complex_ident_pat() {
         cov_mark::check!(rename_record_pat_field_name_split);
 "#,
         );
     }
-
     #[test]
     fn test_rename_lifetimes() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_rename_bind_pat() {
         check(
 }"#,
         );
     }
-
     #[test]
     fn test_rename_label() {
         check(
 "#,
         )
     }
-
     #[test]
     fn test_rename_label_new_name_without_apostrophe() {
         check(
         "#,
         );
     }
-
     #[test]
     fn test_self_to_self() {
         cov_mark::check!(rename_self_to_self);
 "#,
         )
     }
-
     #[test]
     fn test_rename_field_in_pat_in_macro_doesnt_shorthand() {
         // ideally we would be able to make this emit a short hand, but I doubt this is easily possible
 "#,
         )
     }
-
     #[test]
     fn test_rename_tuple_field() {
         check(
             "error: No references found at position",
         );
     }
-
     #[test]
     fn test_rename_builtin() {
         check(
             "error: Cannot rename builtin type",
         );
     }
-
     #[test]
     fn test_rename_self() {
         check(
             "error: No references found at position",
         );
     }
-
     #[test]
     fn test_rename_ignores_self_ty() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_fails_on_aliases() {
         check(
             "error: Renaming aliases is currently unsupported",
         );
     }
-
     #[test]
     fn test_rename_trait_method() {
         let res = r"
             res,
         );
     }
-
     #[test]
     fn test_rename_trait_method_prefix_of_second() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_rename_trait_const() {
         let res = r"
             res,
         );
     }
-
     #[test]
     fn defs_from_macros_arent_renamed() {
         check(
             "error: No identifier available to rename",
         )
     }
-
     #[test]
     fn attributed_item() {
         check(
 "#,
         )
     }
-
     #[test]
     fn in_macro_multi_mapping() {
         check(
 "#,
         )
     }
-
     #[test]
     fn rename_multi_local() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_13498() {
         check(
 ",
         )
     }
-
     #[test]
     fn extern_crate() {
         check_prepare(
         // ",
         //         );
     }
-
     #[test]
     fn extern_crate_rename() {
         check_prepare(
         // ",
         //         );
     }
-
     #[test]
     fn extern_crate_self() {
         check_prepare(
         // ",
         //         );
     }
-
     #[test]
     fn extern_crate_self_rename() {
         check_prepare(
         // ",
         //         );
     }
-
     #[test]
     fn disallow_renaming_for_non_local_definition() {
         check(
             "error: Cannot rename a non-local definition",
         );
     }
-
     #[test]
     fn disallow_renaming_for_builtin_macros() {
         check(
             "error: Cannot rename a non-local definition",
         );
     }
-
     #[test]
     fn implicit_format_args() {
         check(
 "#,
         );
     }
-
     #[test]
     fn implicit_format_args2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn asm_operand() {
         check(
 "#,
         );
     }
-
     #[test]
     fn asm_operand2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_path_inside_use_tree() {
         check(
 "#,
         )
     }
-
     #[test]
     fn rename_path_inside_use_tree_foreign() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_type_param_ref_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_type_param_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_lifetime_param_ref_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_lifetime_param_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_parent_type_param_in_use_bound() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_macro_generated_type_from_type_with_a_suffix() {
         check(
 "#,
         );
     }
-
     #[test]
-    // FIXME
     #[should_panic]
     fn rename_macro_generated_type_from_type_usage_with_a_suffix() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_macro_generated_type_from_variant_with_a_suffix() {
         check(
 "#,
         );
     }
-
     #[test]
-    // FIXME
     #[should_panic]
     fn rename_macro_generated_type_from_variant_usage_with_a_suffix() {
         check(
 "#,
         );
     }
-
     #[test]
     fn rename_to_self_callers() {
         check(
         "#,
         );
     }
-
     #[test]
     fn rename_to_self_callers_in_macro() {
         check(
         "#,
         );
     }
-
     #[test]
     fn rename_from_self_callers() {
         check(