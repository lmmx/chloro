COMPARISON DIFF
============================================================

Original size: 36233 bytes
Chloro size:   36198 bytes
Rustfmt size:  37670 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     ClosureStyle, DisplayTarget, EditionedFileId, HasVisibility, HirDisplay, HirDisplayError,
     HirWrite, InRealFile, ModuleDef, ModuleDefId, Semantics, sym,
 };
+use ide_db::{FxHashSet, text_edit::TextEdit};
 use ide_db::{
     FileRange, MiniCore, RootDatabase, famous_defs::FamousDefs, text_edit::TextEditBuilder,
 };
-use ide_db::{FxHashSet, text_edit::TextEdit};
 use itertools::Itertools;
 use macros::UpmapFromRaFixture;
 use smallvec::{SmallVec, smallvec};
     let ctx = &mut InlayHintCtx::default();
     let mut hints = |event| {
         if let Some(node) = handle_event(ctx, event) {
-            hints(
-                &mut acc,
-                ctx,
-                &famous_defs,
-                config,
-                file_id,
-                display_target,
-                node,
-            );
+            hints(&mut acc, ctx, &famous_defs, config, file_id, display_target, node);
         }
     };
     let mut preorder = file.preorder();
     let ctx = &mut InlayHintCtx::default();
     let mut hints = |event| {
         if let Some(node) = handle_event(ctx, event) {
-            hints(
-                &mut acc,
-                ctx,
-                &famous_defs,
-                config,
-                file_id,
-                display_target,
-                node,
-            );
+            hints(&mut acc, ctx, &famous_defs, config, file_id, display_target, node);
         }
     };
 
                     .map(|it| {
                         it.lifetime_params()
                             .filter_map(|it| {
-                                it.lifetime()
-                                    .map(|it| format_smolstr!("{}", &it.text()[1..]))
+                                it.lifetime().map(|it| format_smolstr!("{}", &it.text()[1..]))
                             })
                             .collect()
                     })
         sema,
         config,
         display_target,
-        InRealFile {
-            file_id,
-            value: node.clone(),
-        },
+        InRealFile { file_id, value: node.clone() },
     );
     if let Some(any_has_generic_args) = ast::AnyHasGenericArgs::cast(node.clone()) {
         generic_param::hints(hints, famous_defs, config, any_has_generic_args);
     }
 
     fn lazy_tooltip(&self, finish: impl FnOnce() -> InlayTooltip) -> LazyProperty<InlayTooltip> {
-        if self.fields_to_resolve.resolve_hint_tooltip
-            && self.fields_to_resolve.resolve_label_tooltip
-        {
+        if self.fields_to_resolve.resolve_hint_tooltip && self.fields_to_resolve.resolve_label_tooltip {
             LazyProperty::Lazy
         } else {
             let tooltip = finish();
         linked_location: Option<LazyProperty<FileRange>>,
     ) -> InlayHintLabel {
         InlayHintLabel {
-            parts: smallvec![InlayHintLabelPart {
-                text: s.into(),
-                linked_location,
-                tooltip
-            }],
+            parts: smallvec![InlayHintLabelPart { text: s.into(), linked_location, tooltip }],
         }
     }
 
     pub fn prepend_str(&mut self, s: &str) {
         match &mut *self.parts {
-            [
-                InlayHintLabelPart {
-                    text,
-                    linked_location: None,
-                    tooltip: None,
-                },
-                ..,
-            ] => text.insert_str(0, s),
+            [InlayHintLabelPart { text, linked_location: None, tooltip: None }, ..] => {
+                text.insert_str(0, s)
+            }
             _ => self.parts.insert(
                 0,
-                InlayHintLabelPart {
-                    text: s.into(),
-                    linked_location: None,
-                    tooltip: None,
-                },
+                InlayHintLabelPart { text: s.into(), linked_location: None, tooltip: None },
             ),
         }
     }
 
     pub fn append_str(&mut self, s: &str) {
         match &mut *self.parts {
-            [
-                ..,
-                InlayHintLabelPart {
-                    text,
-                    linked_location: None,
-                    tooltip: None,
-                },
-            ] => text.push_str(s),
+            [.., InlayHintLabelPart { text, linked_location: None, tooltip: None }] => {
+                text.push_str(s)
+            }
             _ => self.parts.push(InlayHintLabelPart {
                 text: s.into(),
                 linked_location: None,
     pub fn append_part(&mut self, part: InlayHintLabelPart) {
         if part.linked_location.is_none()
             && part.tooltip.is_none()
-            && let Some(InlayHintLabelPart {
-                text,
-                linked_location: None,
-                tooltip: None,
-            }) = self.parts.last_mut()
+            && let Some(InlayHintLabelPart { text, linked_location: None, tooltip: None }) =
+                self.parts.last_mut()
         {
             text.push_str(&part.text);
             return;
 impl From<String> for InlayHintLabel {
     fn from(s: String) -> Self {
         Self {
-            parts: smallvec![InlayHintLabelPart {
-                text: s,
-                linked_location: None,
-                tooltip: None
-            }],
+            parts: smallvec![InlayHintLabelPart { text: s, linked_location: None, tooltip: None }],
         }
     }
 }
 impl fmt::Debug for InlayHintLabelPart {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         match self {
-            Self {
-                text,
-                linked_location: None,
-                tooltip: None | Some(LazyProperty::Lazy),
-            } => text.fmt(f),
-            Self {
-                text,
-                linked_location,
-                tooltip,
-            } => f
+            Self { text, linked_location: None, tooltip: None | Some(LazyProperty::Lazy) } => {
+                text.fmt(f)
+            }
+            Self { text, linked_location, tooltip } => f
                 .debug_struct("InlayHintLabelPart")
                 .field("text", text)
                 .field("linked_location", linked_location)
             LazyProperty::Lazy
         } else {
             LazyProperty::Computed({
-                let Some(location) = ModuleDef::from(def).try_to_nav(self.sema) else {
-                    return;
-                };
+                let Some(location) = ModuleDef::from(def).try_to_nav(self.sema) else { return };
                 let location = location.call_site();
-                FileRange {
-                    file_id: location.file_id,
-                    range: location.focus_or_full_range(),
-                }
+                FileRange { file_id: location.file_id, range: location.focus_or_full_range() }
             })
         });
     }
                     label_builder.write_str(LABEL_ITEM)?;
                     label_builder.end_location_link();
                     label_builder.write_str(LABEL_MIDDLE2)?;
-                    rec(
-                        sema,
-                        famous_defs,
-                        max_length,
-                        &ty,
-                        label_builder,
-                        config,
-                        display_target,
-                    )?;
+                    rec(sema, famous_defs, max_length, &ty, label_builder, config, display_target)?;
                     label_builder.write_str(LABEL_END)?;
                     Ok(())
                 }
         result: InlayHintLabel::default(),
         resolve: config.fields_to_resolve.resolve_label_location,
     };
-    let _ = rec(
-        sema,
-        famous_defs,
-        config.max_length,
-        ty,
-        &mut label_builder,
-        config,
-        display_target,
-    );
+    let _ =
+        rec(sema, famous_defs, config.max_length, ty, &mut label_builder, config, display_target);
     let r = label_builder.finish();
     Some(r)
 }
     }
 
     if ty.impls_trait(db, iter_trait, &[]) {
-        let assoc_type_item = iter_trait
-            .items(db)
-            .into_iter()
-            .find_map(|item| match item {
-                hir::AssocItem::TypeAlias(alias) if alias.name(db) == sym::Item => Some(alias),
-                _ => None,
-            })?;
+        let assoc_type_item = iter_trait.items(db).into_iter().find_map(|item| match item {
+            hir::AssocItem::TypeAlias(alias) if alias.name(db) == sym::Item => Some(alias),
+            _ => None,
+        })?;
         if let Some(ty) = ty.normalize_trait_assoc_type(db, &[], assoc_type_item) {
             return Some((iter_trait, assoc_type_item, ty));
         }
     prefix: impl Into<String>,
 ) -> Option<LazyProperty<TextEdit>> {
     // FIXME: Limit the length and bail out on excess somehow?
-    let rendered = sema.scope(node_for_hint).and_then(|scope| {
-        ty.display_source_code(scope.db, scope.module().into(), false)
-            .ok()
-    })?;
+    let rendered = sema
+        .scope(node_for_hint)
+        .and_then(|scope| ty.display_source_code(scope.db, scope.module().into(), false).ok())?;
     Some(config.lazy_text_edit(|| {
         let mut builder = TextEdit::builder();
         builder.insert(offset_to_insert_ty, prefix.into());
 
 #[cfg(test)]
 mod tests {
-
     use expect_test::Expect;
     use hir::ClosureStyle;
     use ide_db::MiniCore;
     use itertools::Itertools;
     use test_utils::extract_annotations;
-
     use crate::DiscriminantHints;
     use crate::inlay_hints::{AdjustmentHints, AdjustmentHintsMode};
     use crate::{LifetimeElisionHints, fixture, inlay_hints::InlayHintsConfig};
-
     use super::{ClosureReturnTypeHints, GenericParameterHints, InlayFieldsToResolve};
-
     pub(super) const DISABLED_CONFIG: InlayHintsConfig<'_> = InlayHintsConfig {
         discriminant_hints: DiscriminantHints::Never,
         render_colons: false,
         lifetime_elision_hints: LifetimeElisionHints::Always,
         ..DISABLED_CONFIG
     };
-
     #[track_caller]
     pub(super) fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(TEST_CONFIG, ra_fixture);
     }
-
     #[track_caller]
     pub(super) fn check_with_config(
         config: InlayHintsConfig<'_>,
             .collect::<Vec<_>>();
         expected.sort_by_key(|(range, _)| range.start());
 
-        assert_eq!(
-            expected, actual,
-            "\nExpected:\n{expected:#?}\n\nActual:\n{actual:#?}"
-        );
+        assert_eq!(expected, actual, "\nExpected:\n{expected:#?}\n\nActual:\n{actual:#?}");
     }
-
     #[track_caller]
     pub(super) fn check_expect(
         config: InlayHintsConfig<'_>,
     ) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
-        let filtered = inlay_hints
-            .into_iter()
-            .map(|hint| (hint.range, hint.label))
-            .collect::<Vec<_>>();
+        let filtered =
+            inlay_hints.into_iter().map(|hint| (hint.range, hint.label)).collect::<Vec<_>>();
         expect.assert_debug_eq(&filtered)
     }
-
     /// Computes inlay hints for the fixture, applies all the provided text edits and then runs
     /// expect test.
     #[track_caller]
         edits.apply(&mut actual);
         expect.assert_eq(&actual);
     }
-
     #[track_caller]
     pub(super) fn check_no_edit(
         config: InlayHintsConfig<'_>,
         let (analysis, file_id) = fixture::file(ra_fixture);
         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
 
-        let edits: Vec<_> = inlay_hints
-            .into_iter()
-            .filter_map(|hint| hint.text_edit?.computed())
-            .collect();
+        let edits: Vec<_> =
+            inlay_hints.into_iter().filter_map(|hint| hint.text_edit?.computed()).collect();
 
         assert!(edits.is_empty(), "unexpected edits: {edits:?}");
     }
-
     #[test]
     fn hints_disabled() {
         check_with_config(
-            InlayHintsConfig {
-                render_colons: true,
-                ..DISABLED_CONFIG
-            },
+            InlayHintsConfig { render_colons: true, ..DISABLED_CONFIG },
             r#"
 fn foo(a: i32, b: i32) -> i32 { a + b }
 fn main() {
 }"#,
         );
     }
-
     #[test]
     fn regression_18840() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_18898() {
         check(
 "#,
         );
     }
-
     #[test]
     fn closure_dependency_cycle_no_panic() {
         check(
         "#,
         );
     }
-
     #[test]
     fn regression_19610() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_20239() {
         check_with_config(
-            InlayHintsConfig {
-                parameter_hints: true,
-                type_hints: true,
-                ..DISABLED_CONFIG
-            },
+            InlayHintsConfig { parameter_hints: true, type_hints: true, ..DISABLED_CONFIG },
             r#"
 //- minicore: fn
 trait Iterator {