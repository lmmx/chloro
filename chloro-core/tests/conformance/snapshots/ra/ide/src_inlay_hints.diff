COMPARISON DIFF
============================================================

Original size: 36233 bytes
Chloro size:   36193 bytes
Rustfmt size:  36233 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     ClosureStyle, DisplayTarget, EditionedFileId, HasVisibility, HirDisplay, HirDisplayError,
     HirWrite, InRealFile, ModuleDef, ModuleDefId, Semantics, sym,
 };
+use ide_db::{FxHashSet, text_edit::TextEdit};
 use ide_db::{
     FileRange, MiniCore, RootDatabase, famous_defs::FamousDefs, text_edit::TextEditBuilder,
 };
-use ide_db::{FxHashSet, text_edit::TextEdit};
 use itertools::Itertools;
 use macros::UpmapFromRaFixture;
 use smallvec::{SmallVec, smallvec};
     }
 
     fn lazy_tooltip(&self, finish: impl FnOnce() -> InlayTooltip) -> LazyProperty<InlayTooltip> {
-        if self.fields_to_resolve.resolve_hint_tooltip
-            && self.fields_to_resolve.resolve_label_tooltip
-        {
+        if self.fields_to_resolve.resolve_hint_tooltip && self.fields_to_resolve.resolve_label_tooltip {
             LazyProperty::Lazy
         } else {
             let tooltip = finish();
 }
 
 #[derive(Default, Hash, UpmapFromRaFixture)]
-pub struct InlayHintLabel {
-    pub parts: SmallVec<[InlayHintLabelPart; 1]>,
-}
+pub struct InlayHintLabel { pub parts: SmallVec<[InlayHintLabelPart; 1]> }
 
 impl InlayHintLabel {
     pub fn simple(
 
 #[cfg(test)]
 mod tests {
-
     use expect_test::Expect;
     use hir::ClosureStyle;
     use ide_db::MiniCore;
     use itertools::Itertools;
     use test_utils::extract_annotations;
-
     use crate::DiscriminantHints;
     use crate::inlay_hints::{AdjustmentHints, AdjustmentHintsMode};
     use crate::{LifetimeElisionHints, fixture, inlay_hints::InlayHintsConfig};
-
     use super::{ClosureReturnTypeHints, GenericParameterHints, InlayFieldsToResolve};
-
     pub(super) const DISABLED_CONFIG: InlayHintsConfig<'_> = InlayHintsConfig {
         discriminant_hints: DiscriminantHints::Never,
         render_colons: false,
         lifetime_elision_hints: LifetimeElisionHints::Always,
         ..DISABLED_CONFIG
     };
-
     #[track_caller]
     pub(super) fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(TEST_CONFIG, ra_fixture);
     }
-
     #[track_caller]
     pub(super) fn check_with_config(
         config: InlayHintsConfig<'_>,
 
         assert_eq!(expected, actual, "\nExpected:\n{expected:#?}\n\nActual:\n{actual:#?}");
     }
-
     #[track_caller]
     pub(super) fn check_expect(
         config: InlayHintsConfig<'_>,
             inlay_hints.into_iter().map(|hint| (hint.range, hint.label)).collect::<Vec<_>>();
         expect.assert_debug_eq(&filtered)
     }
-
     /// Computes inlay hints for the fixture, applies all the provided text edits and then runs
     /// expect test.
     #[track_caller]
         edits.apply(&mut actual);
         expect.assert_eq(&actual);
     }
-
     #[track_caller]
     pub(super) fn check_no_edit(
         config: InlayHintsConfig<'_>,
 
         assert!(edits.is_empty(), "unexpected edits: {edits:?}");
     }
-
     #[test]
     fn hints_disabled() {
         check_with_config(
 }"#,
         );
     }
-
     #[test]
     fn regression_18840() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_18898() {
         check(
 "#,
         );
     }
-
     #[test]
     fn closure_dependency_cycle_no_panic() {
         check(
         "#,
         );
     }
-
     #[test]
     fn regression_19610() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_20239() {
         check_with_config(