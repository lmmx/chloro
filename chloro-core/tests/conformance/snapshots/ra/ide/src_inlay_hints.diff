COMPARISON DIFF
============================================================

Original size: 36233 bytes
Chloro size:   34604 bytes
Rustfmt size:  36233 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use std::{
-    fmt::{self, Write},
-    mem::{self, take},
-};
-
-use either::Either;
-use hir::{
-    ClosureStyle, DisplayTarget, EditionedFileId, HasVisibility, HirDisplay, HirDisplayError,
-    HirWrite, InRealFile, ModuleDef, ModuleDefId, Semantics, sym,
-};
-use ide_db::{
-    FileRange, MiniCore, RootDatabase, famous_defs::FamousDefs, text_edit::TextEditBuilder,
-};
-use ide_db::{FxHashSet, text_edit::TextEdit};
-use itertools::Itertools;
-use macros::UpmapFromRaFixture;
-use smallvec::{SmallVec, smallvec};
-use stdx::never;
-use syntax::{
-    SmolStr, SyntaxNode, TextRange, TextSize, WalkEvent,
-    ast::{self, AstNode, HasGenericParams},
-    format_smolstr, match_ast,
-};
-
-use crate::{FileId, navigation_target::TryToNav};
-
 mod adjustment;
 mod bind_pat;
 mod binding_mode;
 mod ra_fixture;
 mod range_exclusive;
 
-// Feature: Inlay Hints
-//
-// rust-analyzer shows additional information inline with the source code.
-// Editors usually render this using read-only virtual text snippets interspersed with code.
-//
-// rust-analyzer by default shows hints for
-//
-// * types of local variables
-// * names of function arguments
-// * names of const generic parameters
-// * types of chained expressions
-//
-// Optionally, one can enable additional hints for
-//
-// * return types of closure expressions
-// * elided lifetimes
-// * compiler inserted reborrows
-// * names of generic type and lifetime parameters
-//
-// Note: inlay hints for function argument names are heuristically omitted to reduce noise and will not appear if
-// any of the
-// [following criteria](https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L92-L99)
-// are met:
-//
-// * the parameter name is a suffix of the function's name
-// * the argument is a qualified constructing or call expression where the qualifier is an ADT
-// * exact argument<->parameter match(ignoring leading underscore) or parameter is a prefix/suffix
-//   of argument with _ splitting it off
-// * the parameter name starts with `ra_fixture`
-// * the parameter name is a
-// [well known name](https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L200)
-// in a unary function
-// * the parameter name is a
-// [single character](https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L201)
-// in a unary function
-//
-// ![Inlay hints](https://user-images.githubusercontent.com/48062697/113020660-b5f98b80-917a-11eb-8d70-3be3fd558cdd.png)
+use std::{
+    fmt::{self, Write},
+    mem::{self, take},
+};
+
+use either::Either;
+use hir::{
+    sym, ClosureStyle, DisplayTarget, EditionedFileId, HasVisibility, HirDisplay, HirDisplayError,
+    HirWrite, InRealFile, ModuleDef, ModuleDefId, Semantics,
+};
+use ide_db::{
+    famous_defs::FamousDefs,
+
+    text_edit::TextEditBuilder,
+
+    FileRange, MiniCore, RootDatabase,
+};
+use ide_db::{FxHashSet, text_edit::TextEdit};
+use itertools::Itertools;
+use macros::UpmapFromRaFixture;
+use smallvec::{SmallVec, smallvec};
+use stdx::never;
+use syntax::{
+    ast::{self,
+
+    format_smolstr, match_ast, AstNode, HasGenericParams}, SmolStr, SyntaxNode, TextRange, TextSize,
+    WalkEvent,
+};
+
+use crate::{FileId, navigation_target::TryToNav};
+
 pub(crate) fn inlay_hints(
     db: &RootDatabase,
     file_id: FileId,
         .unwrap_or_else(|| EditionedFileId::current_edition(db, file_id));
     let file = sema.parse(file_id);
     let file = file.syntax();
-
     let mut acc = Vec::new();
-
     let Some(scope) = sema.scope(file) else {
         return acc;
     };
     let famous_defs = FamousDefs(&sema, scope.krate());
     let display_target = famous_defs.1.to_display_target(sema.db);
-
     let ctx = &mut InlayHintCtx::default();
     let mut hints = |event| {
         if let Some(node) = handle_event(ctx, event) {
         .unwrap_or_else(|| EditionedFileId::current_edition(db, file_id));
     let file = sema.parse(file_id);
     let file = file.syntax();
-
     let scope = sema.scope(file)?;
     let famous_defs = FamousDefs(&sema, scope.krate());
     let mut acc = Vec::new();
-
     let display_target = famous_defs.1.to_display_target(sema.db);
-
     let ctx = &mut InlayHintCtx::default();
     let mut hints = |event| {
         if let Some(node) = handle_event(ctx, event) {
             hints(&mut acc, ctx, &famous_defs, config, file_id, display_target, node);
         }
     };
-
     let mut preorder = file.preorder();
     while let Some(event) = preorder.next() {
         // FIXME: This can miss some hints that require the parent of the range to calculate
     acc.into_iter().find(|hint| hasher(hint) == hash)
 }
 
-fn handle_event(ctx: &mut InlayHintCtx, node: WalkEvent<SyntaxNode>) -> Option<SyntaxNode> {
+fn handle_event(
+    ctx: &mut InlayHintCtx,
+    node: WalkEvent<SyntaxNode>,
+) -> Option<SyntaxNode> {
     match node {
         WalkEvent::Enter(node) => {
             if let Some(node) = ast::AnyHasGenericParams::cast(node.clone()) {
     }
 }
 
-// FIXME: At some point when our hir infra is fleshed out enough we should flip this and traverse the
-// HIR instead of the syntax tree.
 fn hints(
     hints: &mut Vec<InlayHint>,
     ctx: &mut InlayHintCtx,
     if let Some(any_has_generic_args) = ast::AnyHasGenericArgs::cast(node.clone()) {
         generic_param::hints(hints, famous_defs, config, any_has_generic_args);
     }
-
     match_ast! {
         match node {
             ast::Expr(expr) => {
 }
 
 impl InlayHintsConfig<'_> {
-    fn lazy_text_edit(&self, finish: impl FnOnce() -> TextEdit) -> LazyProperty<TextEdit> {
+    fn lazy_text_edit(
+        &self,
+        finish: impl FnOnce() -> TextEdit,
+    ) -> LazyProperty<TextEdit> {
         if self.fields_to_resolve.resolve_text_edits {
             LazyProperty::Lazy
         } else {
         }
     }
 
-    fn lazy_tooltip(&self, finish: impl FnOnce() -> InlayTooltip) -> LazyProperty<InlayTooltip> {
+    fn lazy_tooltip(
+        &self,
+        finish: impl FnOnce() -> InlayTooltip,
+    ) -> LazyProperty<InlayTooltip> {
         if self.fields_to_resolve.resolve_hint_tooltip
             && self.fields_to_resolve.resolve_label_tooltip
         {
 }
 
 impl std::hash::Hash for InlayHint {
-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+    fn hash<H: std::hash::Hasher>(
+        &self,
+        state: &mut H,
+    ) {
         self.range.hash(state);
         self.position.hash(state);
         self.pad_left.hash(state);
 }
 
 impl InlayHint {
-    fn closing_paren_after(kind: InlayKind, range: TextRange) -> InlayHint {
+    fn closing_paren_after(
+        kind: InlayKind,
+        range: TextRange,
+    ) -> InlayHint {
         InlayHint {
             range,
             kind,
         }
     }
 
-    pub fn prepend_str(&mut self, s: &str) {
+    pub fn prepend_str(
+        &mut self,
+        s: &str,
+    ) {
         match &mut *self.parts {
             [InlayHintLabelPart { text, linked_location: None, tooltip: None }, ..] => {
                 text.insert_str(0, s)
         }
     }
 
-    pub fn append_str(&mut self, s: &str) {
+    pub fn append_str(
+        &mut self,
+        s: &str,
+    ) {
         match &mut *self.parts {
             [.., InlayHintLabelPart { text, linked_location: None, tooltip: None }] => {
                 text.push_str(s)
         }
     }
 
-    pub fn append_part(&mut self, part: InlayHintLabelPart) {
+    pub fn append_part(
+        &mut self,
+        part: InlayHintLabelPart,
+    ) {
         if part.linked_location.is_none()
             && part.tooltip.is_none()
             && let Some(InlayHintLabelPart { text, linked_location: None, tooltip: None }) =
 }
 
 impl fmt::Display for InlayHintLabel {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         write!(f, "{}", self.parts.iter().map(|part| &part.text).format(""))
     }
 }
 
 impl fmt::Debug for InlayHintLabel {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_list().entries(&self.parts).finish()
     }
 }
 }
 
 impl std::hash::Hash for InlayHintLabelPart {
-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+    fn hash<H: std::hash::Hasher>(
+        &self,
+        state: &mut H,
+    ) {
         self.text.hash(state);
         self.linked_location.is_some().hash(state);
         self.tooltip.is_some().hash(state);
 }
 
 impl fmt::Debug for InlayHintLabelPart {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         match self {
             Self { text, linked_location: None, tooltip: None | Some(LazyProperty::Lazy) } => {
                 text.fmt(f)
 }
 
 impl fmt::Write for InlayHintLabelBuilder<'_> {
-    fn write_str(&mut self, s: &str) -> fmt::Result {
+    fn write_str(
+        &mut self,
+        s: &str,
+    ) -> fmt::Result {
         self.last_part.write_str(s)
     }
 }
 
 impl HirWrite for InlayHintLabelBuilder<'_> {
-    fn start_location_link(&mut self, def: ModuleDefId) {
+    fn start_location_link(
+        &mut self,
+        def: ModuleDefId,
+    ) {
         never!(self.location.is_some(), "location link is already started");
         self.make_new_part();
-
         self.location = Some(if self.resolve {
             LazyProperty::Lazy
         } else {
             }
         })
     }
-
     let mut label_builder = InlayHintLabelBuilder {
         sema,
         last_part: String::new(),
     }
     let iter_trait = famous_defs.core_iter_Iterator()?;
     let iter_mod = famous_defs.core_iter()?;
-
     // Assert that this struct comes from `core::iter`.
     if !(strukt.visibility(db) == hir::Visibility::Public
         && strukt.module(db).path_to_root(db).contains(&iter_mod))
     {
         return None;
     }
-
     if ty.impls_trait(db, iter_trait, &[]) {
         let assoc_type_item = iter_trait.items(db).into_iter().find_map(|item| match item {
             hir::AssocItem::TypeAlias(alias) if alias.name(db) == sym::Item => Some(alias),
             return Some((iter_trait, assoc_type_item, ty));
         }
     }
-
     None
 }
 
 
 #[cfg(test)]
 mod tests {
-
     use expect_test::Expect;
     use hir::ClosureStyle;
     use ide_db::MiniCore;
     use itertools::Itertools;
     use test_utils::extract_annotations;
-
     use crate::DiscriminantHints;
     use crate::inlay_hints::{AdjustmentHints, AdjustmentHintsMode};
     use crate::{LifetimeElisionHints, fixture, inlay_hints::InlayHintsConfig};
-
     use super::{ClosureReturnTypeHints, GenericParameterHints, InlayFieldsToResolve};
-
     pub(super) const DISABLED_CONFIG: InlayHintsConfig<'_> = InlayHintsConfig {
         discriminant_hints: DiscriminantHints::Never,
         render_colons: false,
         lifetime_elision_hints: LifetimeElisionHints::Always,
         ..DISABLED_CONFIG
     };
-
     #[track_caller]
     pub(super) fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(TEST_CONFIG, ra_fixture);
     }
-
     #[track_caller]
     pub(super) fn check_with_config(
         config: InlayHintsConfig<'_>,
             .sorted_by_key(|(range, _)| range.start())
             .collect::<Vec<_>>();
         expected.sort_by_key(|(range, _)| range.start());
-
         assert_eq!(expected, actual, "\nExpected:\n{expected:#?}\n\nActual:\n{actual:#?}");
     }
-
     #[track_caller]
     pub(super) fn check_expect(
         config: InlayHintsConfig<'_>,
             inlay_hints.into_iter().map(|hint| (hint.range, hint.label)).collect::<Vec<_>>();
         expect.assert_debug_eq(&filtered)
     }
-
     /// Computes inlay hints for the fixture, applies all the provided text edits and then runs
     /// expect test.
     #[track_caller]
     ) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
-
         let edits = inlay_hints
             .into_iter()
             .filter_map(|hint| hint.text_edit?.computed())
                 acc
             })
             .expect("no edit returned");
-
         let mut actual = analysis.file_text(file_id).unwrap().to_string();
         edits.apply(&mut actual);
         expect.assert_eq(&actual);
     }
-
     #[track_caller]
     pub(super) fn check_no_edit(
         config: InlayHintsConfig<'_>,
     ) {
         let (analysis, file_id) = fixture::file(ra_fixture);
         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();
-
         let edits: Vec<_> =
             inlay_hints.into_iter().filter_map(|hint| hint.text_edit?.computed()).collect();
-
         assert!(edits.is_empty(), "unexpected edits: {edits:?}");
     }
-
     #[test]
     fn hints_disabled() {
         check_with_config(
 }"#,
         );
     }
-
     #[test]
     fn regression_18840() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_18898() {
         check(
 "#,
         );
     }
-
     #[test]
     fn closure_dependency_cycle_no_panic() {
         check(
         "#,
         );
     }
-
     #[test]
     fn regression_19610() {
         check(
 "#,
         );
     }
-
     #[test]
     fn regression_20239() {
         check_with_config(