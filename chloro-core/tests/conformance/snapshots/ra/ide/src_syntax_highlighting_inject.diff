COMPARISON DIFF
============================================================

Original size: 11608 bytes
Chloro size:   11637 bytes
Rustfmt size:  12342 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! "Recursive" Syntax highlighting for code in doctests and fixtures.
 
 use std::mem;
 
 use either::Either;
-use hir::{sym, EditionedFileId, HirFileId, InFile, Semantics};
+use hir::{EditionedFileId, HirFileId, InFile, Semantics, sym};
 use ide_db::range_mapper::RangeMapper;
 use ide_db::{
-    defs::Definition, documentation::docs_with_rangemap, rust_doc::is_rust_fence, SymbolKind,
+    defs::Definition,
+
+    documentation::docs_with_rangemap,
+
+    rust_doc::is_rust_fence,
+
+    SymbolKind,
 };
 use syntax::{
-    ast::{self, AstNode, IsString, QuoteOffsets},
-    AstToken, NodeOrToken, SyntaxNode, TextRange, TextSize,
+    ast::{self,
+
+    AstNode, AstToken, IsString, NodeOrToken, QuoteOffsets}, SyntaxNode, TextRange, TextSize,
 };
 
 use crate::{
-    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},
-    syntax_highlighting::{highlights::Highlights, HighlightConfig},
+    doc_links::{doc_attributes,
+
+    extract_definitions_from_docs,
+
+    highlights::Highlights},
+
+    resolve_doc_path_for_def},
+
+    syntax_highlighting::{HighlightConfig,
+
     Analysis, HlMod, HlRange, HlTag, RootDatabase,
 };
 
             });
         },
     )?;
-
     if let Some(range) = literal.open_quote_text_range() {
-        hl.add(HlRange {
-            range,
-            highlight: HlTag::StringLiteral.into(),
-            binding_hash: None,
-        })
+        hl.add(HlRange { range, highlight: HlTag::StringLiteral.into(), binding_hash: None })
     }
-
     for tmp_file_id in fixture_analysis.files() {
         for mut hl_range in analysis
             .highlight(
             }
         }
     }
-
     if let Some(range) = literal.close_quote_text_range() {
-        hl.add(HlRange {
-            range,
-            highlight: HlTag::StringLiteral.into(),
-            binding_hash: None,
-        })
+        hl.add(HlRange { range, highlight: HlTag::StringLiteral.into(), binding_hash: None })
     }
-
     Some(())
 }
 
 const RUSTDOC_FENCE_LENGTH: usize = 3;
+
 const RUSTDOC_FENCES: [&str; 2] = ["```", "~~~"];
 
 /// Injection of syntax highlighting of doctests and intra doc links.
         None => return,
     };
     let src_file_id: HirFileId = src_file_id.into();
-
     // Extract intra-doc links and emit highlights for them.
     if let Some((docs, doc_mapping)) = docs_with_rangemap(sema.db, &attributes) {
         extract_definitions_from_docs(&docs)
                 doc_mapping
                     .map(range)
                     .filter(|(mapping, _)| mapping.file_id == src_file_id)
-                    .and_then(
-                        |(
-                            InFile {
-                                value: mapped_range,
-                                ..
-                            },
-                            attr_id,
-                        )| {
-                            Some(mapped_range).zip(resolve_doc_path_for_def(
-                                sema.db,
-                                def,
-                                &link,
-                                ns,
-                                attr_id.is_inner_attr(),
-                            ))
-                        },
-                    )
+                    .and_then(|(InFile { value: mapped_range, .. }, attr_id)| {
+                        Some(mapped_range).zip(resolve_doc_path_for_def(
+                            sema.db,
+                            def,
+                            &link,
+                            ns,
+                            attr_id.is_inner_attr(),
+                        ))
+                    })
             })
             .for_each(|(range, def)| {
                 hl.add(HlRange {
                 })
             })
     }
-
     // Extract doc-test sources from the docs and calculate highlighting for them.
-
     let mut inj = RangeMapper::default();
     inj.add_unmapped("fn doctest() {\n");
-
     let attrs_source_map = attributes.source_map(sema.db);
-
     let mut is_codeblock = false;
     let mut is_doctest = false;
-
     let mut new_comments = Vec::new();
     let mut string;
-
     for attr in attributes.by_key(sym::doc).attrs() {
-        let InFile {
-            file_id,
-            value: src,
-        } = attrs_source_map.source_of(attr);
+        let InFile { file_id, value: src } = attrs_source_map.source_of(attr);
         if file_id != src_file_id {
             continue;
         }
                 let range = comment.syntax().text_range();
                 (
                     &comment.text()[value..],
-                    TextRange::new(
-                        range.start() + TextSize::try_from(value).unwrap(),
-                        range.end(),
-                    ),
+                    TextRange::new(range.start() + TextSize::try_from(value).unwrap(), range.end()),
                 )
             }
         };
             };
             let mut pos = TextSize::from(0);
 
-            match RUSTDOC_FENCES
-                .into_iter()
-                .find_map(|fence| line.find(fence))
-            {
+            match RUSTDOC_FENCES.into_iter().find_map(|fence| line.find(fence)) {
                 Some(idx) => {
                     is_codeblock = !is_codeblock;
                     // Check whether code is rust by inspecting fence guards
             }
 
             // whitespace after comment is ignored
-            if let Some(ws) = line[pos.into()..]
-                .chars()
-                .next()
-                .filter(|c| c.is_whitespace())
-            {
+            if let Some(ws) = line[pos.into()..].chars().next().filter(|c| c.is_whitespace()) {
                 pos += TextSize::of(ws);
             }
             // lines marked with `#` should be ignored in output, we skip the `#` char
             }
 
             new_comments.push(TextRange::at(prev_range_start, pos));
-            inj.add(
-                &line[pos.into()..],
-                TextRange::new(pos, line_len) + prev_range_start,
-            );
+            inj.add(&line[pos.into()..], TextRange::new(pos, line_len) + prev_range_start);
             inj.add_unmapped("\n");
         }
     }
-
     if new_comments.is_empty() {
         return; // no need to run an analysis on an empty file
     }
-
     inj.add_unmapped("\n}");
-
     let (analysis, tmp_file_id) = Analysis::from_single_file(inj.take_text());
-
     if let Ok(ranges) = analysis.with_db(|db| {
         super::highlight(
             db,
             None,
         )
     }) {
-        for HlRange {
-            range,
-            highlight,
-            binding_hash,
-        } in ranges
-        {
+        for HlRange { range, highlight, binding_hash } in ranges {
             for range in inj.map_range_up(range) {
-                hl.add(HlRange {
-                    range,
-                    highlight: highlight | HlMod::Injected,
-                    binding_hash,
-                });
+                hl.add(HlRange { range, highlight: highlight | HlMod::Injected, binding_hash });
             }
         }
     }
-
     for range in new_comments {
         hl.add(HlRange {
             range,
     }
 }
 
-fn find_doc_string_in_attr(attr: &hir::Attr, it: &ast::Attr) -> Option<ast::String> {
+fn find_doc_string_in_attr(
+    attr: &hir::Attr,
+    it: &ast::Attr,
+) -> Option<ast::String> {
     match it.expr() {
         // #[doc = lit]
         Some(ast::Expr::Literal(lit)) => match lit.kind() {