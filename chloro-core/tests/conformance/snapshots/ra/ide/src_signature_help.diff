COMPARISON DIFF
============================================================

Original size: 62523 bytes
Chloro size:   62460 bytes
Rustfmt size:  62523 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     Semantics, Trait,
 };
 use ide_db::{
-    FilePosition, FxIndexMap,
     active_parameter::{callable_for_arg_list, generic_def_for_node},
     documentation::{Documentation, HasDocs},
+    FilePosition, FxIndexMap,
 };
 use itertools::Itertools;
 use span::Edition;
 use stdx::format_to;
 use syntax::{
-    AstNode, Direction, NodeOrToken, SyntaxElementChildren, SyntaxNode, SyntaxToken, T, TextRange,
-    TextSize, ToSmolStr, algo,
+    algo,
     ast::{self, AstChildren},
-    match_ast,
+    match_ast, AstNode, Direction, NodeOrToken, SyntaxElementChildren, SyntaxNode, SyntaxToken,
+    TextRange, TextSize, ToSmolStr, T,
 };
 
 use crate::RootDatabase;
     res.signature.push(')');
     res
 }
+
 #[cfg(test)]
 mod tests {
-
     use expect_test::{Expect, expect};
     use ide_db::FilePosition;
     use stdx::format_to;
     use test_fixture::ChangeFixture;
-
     use crate::RootDatabase;
-
     /// Creates analysis from a multi-file fixture, returns positions marked with $0.
     pub(crate) fn position(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let position = FilePosition { file_id: file_id.file_id(&database), offset };
         (database, position)
     }
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (db, position) = position(ra_fixture);
         };
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn test_fn_signature_two_args() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_empty() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_first_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_no_params() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_generic_method() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg_as_assoc_fn() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_impl() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_from_actix() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_bad_offset() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn outside_of_arg_list() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_tuple_structs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat_rest() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn generic_struct() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_enum_variants() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn cant_call_struct_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn cant_call_enum_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn fn_signature_for_call_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_signature_for_method_call_defined_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_lambdas() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_fn_def_over_reference() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_ptr() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_impl() {
         check(
             expect![""],
         );
     }
-
     #[test]
     fn call_info_for_unclosed_call() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn test_multiline_argument() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_on_variant() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_lots_of_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_trait_ufcs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_param_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_kinds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait_assoc_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_supertrait_assoc() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn no_assoc_types_outside_type_bounds() {
         check(
         "#]],
         );
     }
-
     #[test]
     fn impl_trait() {
         // FIXME: Substitute type vars in impl trait (`U` -> `i8`)
             "#]],
         );
     }
-
     #[test]
     fn fully_qualified_syntax() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn help_for_generic_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn regression_13579() {
         // FIXME(next-solver): There should be signature help available here.
             expect![""],
         );
     }
-
     #[test]
     fn record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_nonexistent_field() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_variant_record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_in_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_variant_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_arg_with_default() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_async_function() {
         check(