COMPARISON DIFF
============================================================

Original size: 62523 bytes
Chloro size:   62330 bytes
Rustfmt size:  62523 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     Semantics, Trait,
 };
 use ide_db::{
-    FilePosition, FxIndexMap,
     active_parameter::{callable_for_arg_list, generic_def_for_node},
     documentation::{Documentation, HasDocs},
+    FilePosition, FxIndexMap,
 };
 use itertools::Itertools;
 use span::Edition;
 use stdx::format_to;
 use syntax::{
-    AstNode, Direction, NodeOrToken, SyntaxElementChildren, SyntaxNode, SyntaxToken, T, TextRange,
-    TextSize, ToSmolStr, algo,
+    algo,
     ast::{self, AstChildren},
-    match_ast,
+    match_ast, AstNode, Direction, NodeOrToken, SyntaxElementChildren, SyntaxNode, SyntaxToken,
+    TextRange, TextSize, ToSmolStr, T,
 };
 
 use crate::RootDatabase;
         // this prevents us from leaving the CallExpression
         .and_then(|tok| algo::skip_trivia_token(tok, Direction::Prev))?;
     let token = sema.descend_into_macros_single_exact(token);
-    let edition =
-        sema.attach_first_edition(file_id).map(|it| it.edition(db)).unwrap_or(Edition::CURRENT);
+    let edition = sema.attach_first_edition(file_id).map(|it| it.edition(db)).unwrap_or(Edition::CURRENT);
     let display_target = sema.first_crate(file_id)?.to_display_target(db);
 
     for node in token.parent_ancestors() {
     edition: Edition,
     display_target: DisplayTarget,
 ) -> Option<SignatureHelp> {
-    let (callable, active_parameter) =
-        callable_for_arg_list(sema, arg_list, token.text_range().start())?;
+    let (callable, active_parameter) = callable_for_arg_list(sema, arg_list, token.text_range().start())?;
 
-    let mut res =
-        SignatureHelp { doc: None, signature: String::new(), parameters: vec![], active_parameter };
+    let mut res = SignatureHelp { doc: None, signature: String::new(), parameters: vec![], active_parameter };
 
     let db = sema.db;
     let mut fn_params = None;
     edition: Edition,
     display_target: DisplayTarget,
 ) -> Option<SignatureHelp> {
-    let (generics_def, mut active_parameter, first_arg_is_non_lifetime, variant) =
-        generic_def_for_node(sema, &arg_list, &token)?;
+    let (generics_def, mut active_parameter, first_arg_is_non_lifetime, variant) = generic_def_for_node(sema, &arg_list, &token)?;
     let mut res = SignatureHelp {
         doc: None,
         signature: String::new(),
     }
 
     let params = generics_def.params(sema.db);
-    let num_lifetime_params =
-        params.iter().take_while(|param| matches!(param, GenericParam::LifetimeParam(_))).count();
+    let num_lifetime_params = params.iter().take_while(|param| matches!(param, GenericParam::LifetimeParam(_))).count();
     if first_arg_is_non_lifetime {
         // Lifetime parameters were omitted.
         active_parameter += num_lifetime_params;
             ast::GenericArg::AssocTypeArg(arg) => arg.name_ref().map(|n| n.to_string()),
             _ => None,
         })
-        .collect::<BTreeSet<_>>();
+        .collect();
 
     let mut buf = String::new();
     for binding in &present_bindings {
         }
     }
 
-    let mut fields =
-        fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();
+    let mut fields = fields.into_iter().map(|field| (field.name(db), Some(field))).collect();
     let mut buf = String::new();
     for (field, ty) in fields2 {
         let name = field.name(db);
     display_target: DisplayTarget,
 ) -> SignatureHelp {
     let rest_pat = field_pats.find(|it| matches!(it, ast::Pat::RestPat(_)));
-    let is_left_of_rest_pat =
-        rest_pat.is_none_or(|it| token.text_range().start() < it.syntax().text_range().end());
+    let is_left_of_rest_pat = rest_pat.is_none_or(|it| token.text_range().start() < it.syntax().text_range().end());
 
-    let commas = pat
-        .children_with_tokens()
-        .filter_map(NodeOrToken::into_token)
-        .filter(|t| t.kind() == T![,]);
+    let commas = pat.children_with_tokens().filter_map(NodeOrToken::into_token).filter(|t| t.kind() == T![,]);
 
     res.active_parameter = {
         Some(if is_left_of_rest_pat {
     res.signature.push(')');
     res
 }
+
 #[cfg(test)]
 mod tests {
-
-    use expect_test::{Expect, expect};
+    use expect_test::{expect, Expect};
     use ide_db::FilePosition;
     use stdx::format_to;
     use test_fixture::ChangeFixture;
-
     use crate::RootDatabase;
-
     /// Creates analysis from a multi-file fixture, returns positions marked with $0.
     pub(crate) fn position(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let mut database = RootDatabase::default();
         let change_fixture = ChangeFixture::parse(&database, ra_fixture);
         database.apply_change(change_fixture.change);
-        let (file_id, range_or_offset) =
-            change_fixture.file_position.expect("expected a marker ($0)");
+        let (file_id, range_or_offset) = change_fixture.file_position.expect("expected a marker ($0)");
         let offset = range_or_offset.expect_offset();
         let position = FilePosition { file_id: file_id.file_id(&database), offset };
         (database, position)
     }
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (db, position) = position(ra_fixture);
         };
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn test_fn_signature_two_args() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_empty() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_first_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_no_params() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_generic_method() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg_as_assoc_fn() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_impl() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_from_actix() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_bad_offset() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn outside_of_arg_list() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_tuple_structs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat_rest() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn generic_struct() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_enum_variants() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn cant_call_struct_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn cant_call_enum_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn fn_signature_for_call_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_signature_for_method_call_defined_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_lambdas() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_fn_def_over_reference() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_ptr() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_impl() {
         check(
             expect![""],
         );
     }
-
     #[test]
     fn call_info_for_unclosed_call() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn test_multiline_argument() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_on_variant() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_lots_of_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_trait_ufcs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_param_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_kinds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait_assoc_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_supertrait_assoc() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn no_assoc_types_outside_type_bounds() {
         check(
         "#]],
         );
     }
-
     #[test]
     fn impl_trait() {
         // FIXME: Substitute type vars in impl trait (`U` -> `i8`)
             "#]],
         );
     }
-
     #[test]
     fn fully_qualified_syntax() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn help_for_generic_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn regression_13579() {
         // FIXME(next-solver): There should be signature help available here.
             expect![""],
         );
     }
-
     #[test]
     fn record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_nonexistent_field() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_variant_record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_in_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_variant_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_arg_with_default() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_async_function() {
         check(