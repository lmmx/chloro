COMPARISON DIFF
============================================================

Original size: 62523 bytes
Chloro size:   62440 bytes
Rustfmt size:  63434 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         // this prevents us from leaving the CallExpression
         .and_then(|tok| algo::skip_trivia_token(tok, Direction::Prev))?;
     let token = sema.descend_into_macros_single_exact(token);
-    let edition = sema
-        .attach_first_edition(file_id)
-        .map(|it| it.edition(db))
-        .unwrap_or(Edition::CURRENT);
+    let edition =
+        sema.attach_first_edition(file_id).map(|it| it.edition(db)).unwrap_or(Edition::CURRENT);
     let display_target = sema.first_crate(file_id)?.to_display_target(db);
 
     for node in token.parent_ancestors() {
     let (callable, active_parameter) =
         callable_for_arg_list(sema, arg_list, token.text_range().start())?;
 
-    let mut res = SignatureHelp {
-        doc: None,
-        signature: String::new(),
-        parameters: vec![],
-        active_parameter,
-    };
+    let mut res =
+        SignatureHelp { doc: None, signature: String::new(), parameters: vec![], active_parameter };
 
     let db = sema.db;
     let mut fn_params = None;
         }
         hir::CallableKind::TupleStruct(strukt) => {
             res.doc = strukt.docs(db);
-            format_to!(
-                res.signature,
-                "struct {}",
-                strukt.name(db).display(db, edition)
-            );
+            format_to!(res.signature, "struct {}", strukt.name(db).display(db, edition));
 
             let generic_params = GenericDef::Adt(strukt.into())
                 .params(db)
             // In that case, fall back to render definitions of the respective parameters.
             // This is overly conservative: we do not substitute known type vars
             // (see FIXME in tests::impl_trait) and falling back on any unknowns.
-            hir::attach_db(db, || {
-                match (p.ty().contains_unknown(), fn_params.as_deref()) {
-                    (true, Some(fn_params)) => {
-                        format_to!(buf, "{}", fn_params[idx].ty().display(db, display_target))
-                    }
-                    _ => format_to!(buf, "{}", p.ty().display(db, display_target)),
+            hir::attach_db(db, || match (p.ty().contains_unknown(), fn_params.as_deref()) {
+                (true, Some(fn_params)) => {
+                    format_to!(buf, "{}", fn_params[idx].ty().display(db, display_target))
                 }
+                _ => format_to!(buf, "{}", p.ty().display(db, display_target)),
             });
             res.push_call_param(&buf);
         }
 
     let mut render = |ret_type: hir::Type<'_>| {
         if !ret_type.is_unit() {
-            format_to!(
-                res.signature,
-                " -> {}",
-                ret_type.display(db, display_target)
-            );
+            format_to!(res.signature, " -> {}", ret_type.display(db, display_target));
         }
     };
     match callable.kind() {
     }
 
     let params = generics_def.params(sema.db);
-    let num_lifetime_params = params
-        .iter()
-        .take_while(|param| matches!(param, GenericParam::LifetimeParam(_)))
-        .count();
+    let num_lifetime_params =
+        params.iter().take_while(|param| matches!(param, GenericParam::LifetimeParam(_))).count();
     if first_arg_is_non_lifetime {
         // Lifetime parameters were omitted.
         active_parameter += num_lifetime_params;
                 }
             }
             GenericParam::ConstParam(param) => {
-                if let Some(expr) = param
-                    .default(db, display_target)
-                    .and_then(|konst| konst.expr())
+                if let Some(expr) = param.default(db, display_target).and_then(|konst| konst.expr())
                 {
                     format_to!(buf, " = {}", expr);
                 }
     args: ast::GenericArgList,
     edition: Edition,
 ) {
-    if args
-        .syntax()
-        .ancestors()
-        .find_map(ast::TypeBound::cast)
-        .is_none()
-    {
+    if args.syntax().ancestors().find_map(ast::TypeBound::cast).is_none() {
         // Assoc type bindings are only valid in type bound position.
         return;
     }
 ) -> Option<SignatureHelp> {
     signature_help_for_record_(
         sema,
-        record
-            .record_expr_field_list()?
-            .syntax()
-            .children_with_tokens(),
+        record.record_expr_field_list()?.syntax().children_with_tokens(),
         &record.path()?,
         record
             .record_expr_field_list()?
 ) -> Option<SignatureHelp> {
     signature_help_for_record_(
         sema,
-        record
-            .record_pat_field_list()?
-            .syntax()
-            .children_with_tokens(),
+        record.record_pat_field_list()?.syntax().children_with_tokens(),
         &record.path()?,
         record
             .record_pat_field_list()?
         match adt {
             hir::Adt::Struct(it) => {
                 res.doc = it.docs(db);
-                format_to!(
-                    res.signature,
-                    "struct {} (",
-                    it.name(db).display(db, edition)
-                );
+                format_to!(res.signature, "struct {} (", it.name(db).display(db, edition));
                 it.fields(db)
             }
             _ => return None,
     Some(signature_help_for_tuple_pat_ish(
         db,
         SignatureHelp {
-            doc: None,
-            signature: String::from('('),
-            parameters: vec![],
-            active_parameter: None,
-        },
+        doc: None,
+        signature: String::from('('),
+        parameters: vec![],
+        active_parameter: None,
+    },
         pat.syntax(),
         token,
         field_pats,
     let fields = expr.original.tuple_fields(db);
     let mut buf = String::new();
     for ty in fields {
-        format_to!(
-            buf,
-            "{}",
-            ty.display_truncated(db, Some(20), display_target)
-        );
+        format_to!(buf, "{}", ty.display_truncated(db, Some(20), display_target));
         res.push_call_param(&buf);
         buf.clear();
     }
             hir::Adt::Struct(it) => {
                 fields = it.fields(db);
                 res.doc = it.docs(db);
-                format_to!(
-                    res.signature,
-                    "struct {} {{ ",
-                    it.name(db).display(db, edition)
-                );
+                format_to!(res.signature, "struct {} {{ ", it.name(db).display(db, edition));
             }
             hir::Adt::Union(it) => {
                 fields = it.fields(db);
                 res.doc = it.docs(db);
-                format_to!(
-                    res.signature,
-                    "union {} {{ ",
-                    it.name(db).display(db, edition)
-                );
+                format_to!(res.signature, "union {} {{ ", it.name(db).display(db, edition));
             }
             _ => return None,
         }
     }
 
-    let mut fields = fields
-        .into_iter()
-        .map(|field| (field.name(db), Some(field)))
-        .collect::<FxIndexMap<_, _>>();
+    let mut fields =
+        fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();
     let mut buf = String::new();
     for (field, ty) in fields2 {
         let name = field.name(db);
 
     res.active_parameter = {
         Some(if is_left_of_rest_pat {
-            commas
-                .take_while(|t| t.text_range().start() <= token.text_range().start())
-                .count()
+            commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()
         } else {
             let n_commas = commas
                 .collect::<Vec<_>>()
 
     let mut buf = String::new();
     for ty in fields {
-        format_to!(
-            buf,
-            "{}",
-            ty.display_truncated(db, Some(20), display_target)
-        );
+        format_to!(buf, "{}", ty.display_truncated(db, Some(20), display_target));
         res.push_call_param(&buf);
         buf.clear();
     }
     res.signature.push(')');
     res
 }
+
 #[cfg(test)]
 mod tests {
-
     use expect_test::{Expect, expect};
     use ide_db::FilePosition;
     use stdx::format_to;
     use test_fixture::ChangeFixture;
-
     use crate::RootDatabase;
-
     /// Creates analysis from a multi-file fixture, returns positions marked with $0.
     pub(crate) fn position(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let mut database = RootDatabase::default();
         let change_fixture = ChangeFixture::parse(&database, ra_fixture);
         database.apply_change(change_fixture.change);
-        let (file_id, range_or_offset) = change_fixture
-            .file_position
-            .expect("expected a marker ($0)");
+        let (file_id, range_or_offset) =
+            change_fixture.file_position.expect("expected a marker ($0)");
         let offset = range_or_offset.expect_offset();
-        let position = FilePosition {
-            file_id: file_id.file_id(&database),
-            offset,
-        };
+        let position = FilePosition { file_id: file_id.file_id(&database), offset };
         (database, position)
     }
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let (db, position) = position(ra_fixture);
 
                     let start = u32::from(range.start());
                     let gap = start.checked_sub(offset).unwrap_or_else(|| {
-                        panic!(
-                            "parameter ranges out of order: {:?}",
-                            sig_help.parameter_ranges()
-                        )
+                        panic!("parameter ranges out of order: {:?}", sig_help.parameter_ranges())
                     });
                     rendered.extend(std::iter::repeat_n(' ', gap as usize));
                     let param_text = &sig_help.signature[*range];
         };
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn test_fn_signature_two_args() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_empty() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_first_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_no_params() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_generic_method() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg_as_assoc_fn() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_impl() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_from_actix() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_bad_offset() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn outside_of_arg_list() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_tuple_structs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat_rest() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn generic_struct() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_enum_variants() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn cant_call_struct_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn cant_call_enum_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn fn_signature_for_call_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_signature_for_method_call_defined_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_lambdas() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_fn_def_over_reference() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_ptr() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_impl() {
         check(
             expect![""],
         );
     }
-
     #[test]
     fn call_info_for_unclosed_call() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn test_multiline_argument() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_on_variant() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_lots_of_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_trait_ufcs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_param_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_kinds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait_assoc_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_supertrait_assoc() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn no_assoc_types_outside_type_bounds() {
         check(
         "#]],
         );
     }
-
     #[test]
     fn impl_trait() {
         // FIXME: Substitute type vars in impl trait (`U` -> `i8`)
             "#]],
         );
     }
-
     #[test]
     fn fully_qualified_syntax() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn help_for_generic_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn regression_13579() {
         // FIXME(next-solver): There should be signature help available here.
             expect![""],
         );
     }
-
     #[test]
     fn record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_nonexistent_field() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_variant_record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_in_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_variant_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_arg_with_default() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_async_function() {
         check(