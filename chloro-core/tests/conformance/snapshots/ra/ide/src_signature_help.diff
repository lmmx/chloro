COMPARISON DIFF
============================================================

Original size: 62523 bytes
Chloro size:   62559 bytes
Rustfmt size:  62523 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         &self.parameters
     }
 
-    fn push_call_param(&mut self, param: &str) {
+    fn push_call_param(
+        &mut self,
+        param: &str,
+    ) {
         self.push_param("(", param);
     }
 
-    fn push_generic_param(&mut self, param: &str) {
+    fn push_generic_param(
+        &mut self,
+        param: &str,
+    ) {
         self.push_param("<", param);
     }
 
-    fn push_record_field(&mut self, param: &str) {
+    fn push_record_field(
+        &mut self,
+        param: &str,
+    ) {
         self.push_param("{ ", param);
     }
 
-    fn push_param(&mut self, opening_delim: &str, param: &str) {
+    fn push_param(
+        &mut self,
+        opening_delim: &str,
+        param: &str,
+    ) {
         if !self.signature.ends_with(opening_delim) {
             self.signature.push_str(", ");
         }
     let edition =
         sema.attach_first_edition(file_id).map(|it| it.edition(db)).unwrap_or(Edition::CURRENT);
     let display_target = sema.first_crate(file_id)?.to_display_target(db);
-
     for node in token.parent_ancestors() {
         match_ast! {
             match node {
             break;
         }
     }
-
     None
 }
 
 ) -> Option<SignatureHelp> {
     let (callable, active_parameter) =
         callable_for_arg_list(sema, arg_list, token.text_range().start())?;
-
     let mut res =
         SignatureHelp { doc: None, signature: String::new(), parameters: vec![], active_parameter };
-
     let db = sema.db;
     let mut fn_params = None;
     match callable.kind() {
             None => format_to!(res.signature, "impl {fn_trait}"),
         },
     }
-
     res.signature.push('(');
     {
         if let Some((self_param, _)) = callable.receiver_param(db) {
         }
     }
     res.signature.push(')');
-
     let mut render = |ret_type: hir::Type<'_>| {
         if !ret_type.is_unit() {
             format_to!(res.signature, " -> {}", ret_type.display(db, display_target));
         parameters: vec![],
         active_parameter: None,
     };
-
     let db = sema.db;
     match generics_def {
         hir::GenericDef::Function(it) => {
             return None;
         }
     }
-
     let params = generics_def.params(sema.db);
     let num_lifetime_params =
         params.iter().take_while(|param| matches!(param, GenericParam::LifetimeParam(_))).count();
         active_parameter += num_lifetime_params;
     }
     res.active_parameter = Some(active_parameter);
-
     res.signature.push('<');
     let mut buf = String::new();
     for param in params {
         add_assoc_type_bindings(db, &mut res, tr, arg_list, edition);
     }
     res.signature.push('>');
-
     Some(res)
 }
 
         // Assoc type bindings are only valid in type bound position.
         return;
     }
-
     let present_bindings = args
         .generic_args()
         .filter_map(|arg| match arg {
             _ => None,
         })
         .collect::<BTreeSet<_>>();
-
     let mut buf = String::new();
     for binding in &present_bindings {
         buf.clear();
         format_to!(buf, "{} = …", binding);
         res.push_generic_param(&buf);
     }
-
     for item in tr.items_with_supertraits(db) {
         if let AssocItem::TypeAlias(ty) = item {
             let name = ty.name(db).display_no_db(edition).to_smolstr();
         active_parameter: None,
     };
     let db = sema.db;
-
     let fields: Vec<_> = if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {
         let en = variant.parent_enum(db);
 
     let pat = pat.into();
     let ty = sema.type_of_pat(&pat)?;
     let fields = ty.original.tuple_fields(db);
-
     Some(signature_help_for_tuple_pat_ish(
         db,
         SignatureHelp {
             .take_while(|t| t.text_range().start() <= token.text_range().start())
             .count(),
     );
-
     let db = sema.db;
     let mut res = SignatureHelp {
         doc: None,
         .filter(|t| t.kind() == T![,])
         .take_while(|t| t.text_range().start() <= token.text_range().start())
         .count();
-
     let mut res = SignatureHelp {
         doc: None,
         signature: String::new(),
         parameters: vec![],
         active_parameter: Some(active_parameter),
     };
-
     let fields;
-
     let db = sema.db;
     let path_res = sema.resolve_path(path)?;
     if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {
             _ => return None,
         }
     }
-
     let mut fields =
         fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();
     let mut buf = String::new();
     let rest_pat = field_pats.find(|it| matches!(it, ast::Pat::RestPat(_)));
     let is_left_of_rest_pat =
         rest_pat.is_none_or(|it| token.text_range().start() < it.syntax().text_range().end());
-
     let commas = pat
         .children_with_tokens()
         .filter_map(NodeOrToken::into_token)
         .filter(|t| t.kind() == T![,]);
-
     res.active_parameter = {
         Some(if is_left_of_rest_pat {
             commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()
             fields.len().saturating_sub(1).saturating_sub(n_commas)
         })
     };
-
     let mut buf = String::new();
     for ty in fields {
         format_to!(buf, "{}", ty.display_truncated(db, Some(20), display_target));
     res.signature.push(')');
     res
 }
+
 #[cfg(test)]
 mod tests {
-
     use expect_test::{Expect, expect};
     use ide_db::FilePosition;
     use stdx::format_to;
     use test_fixture::ChangeFixture;
-
     use crate::RootDatabase;
-
     /// Creates analysis from a multi-file fixture, returns positions marked with $0.
     pub(crate) fn position(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let position = FilePosition { file_id: file_id.file_id(&database), offset };
         (database, position)
     }
-
     #[track_caller]
-    fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+    fn check(
+        #[rust_analyzer::rust_fixture] ra_fixture: &str,
+        expect: Expect,
+    ) {
         let (db, position) = position(ra_fixture);
         let sig_help = hir::attach_db(&db, || crate::signature_help::signature_help(&db, position));
         let actual = match sig_help {
         };
         expect.assert_eq(&actual);
     }
-
     #[test]
     fn test_fn_signature_two_args() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_empty() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_two_args_first_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_no_params() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_impl() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_generic_method() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_for_method_with_arg_as_assoc_fn() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_impl() {
         check(
             "##]],
         );
     }
-
     #[test]
     fn test_fn_signature_with_docs_from_actix() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_bad_offset() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn outside_of_arg_list() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_tuple_structs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_struct_pat_rest() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn generic_struct() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn works_for_enum_variants() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn cant_call_struct_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn cant_call_enum_record() {
         check(
             expect![[""]],
         );
     }
-
     #[test]
     fn fn_signature_for_call_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_signature_for_method_call_defined_in_macro() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_lambdas() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn call_info_for_fn_def_over_reference() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_ptr() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn call_info_for_fn_impl() {
         check(
             expect![""],
         );
     }
-
     #[test]
     fn call_info_for_unclosed_call() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn test_multiline_argument() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_simple() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_on_variant() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_lots_of_generics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_trait_ufcs() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generics_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_param_in_method_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_kinds() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_trait_assoc_types() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_supertrait_assoc() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn no_assoc_types_outside_type_bounds() {
         check(
         "#]],
         );
     }
-
     #[test]
     fn impl_trait() {
         // FIXME: Substitute type vars in impl trait (`U` -> `i8`)
             "#]],
         );
     }
-
     #[test]
     fn fully_qualified_syntax() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn help_for_generic_call() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn regression_13579() {
         // FIXME(next-solver): There should be signature help available here.
             expect![""],
         );
     }
-
     #[test]
     fn record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_nonexistent_field() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn tuple_variant_record_literal() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_literal_self() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_pat() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_in_nested_method_in_lambda() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_expr_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_free() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_pat_expected() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_enum_variant_generic_param() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn test_generic_arg_with_default() {
         check(
                          ^^^^^^
             "#]],
         );
-
         check(
             r#"
 //- minicore: sized, fn
             "#]],
         );
     }
-
     #[test]
     fn test_async_function() {
         check(