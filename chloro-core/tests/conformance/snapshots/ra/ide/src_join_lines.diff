COMPARISON DIFF
============================================================

Original size: 22055 bytes
Chloro size:   22024 bytes
Rustfmt size:  22286 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     let mut edit = TextEdit::builder();
     match file.syntax().covering_element(range) {
         NodeOrToken::Node(node) => {
-            for token in node
-                .descendants_with_tokens()
-                .filter_map(|it| it.into_token())
-            {
+            for token in node.descendants_with_tokens().filter_map(|it| it.into_token()) {
                 remove_newlines(config, &mut edit, &token, range)
             }
         }
         match next.kind() {
             T![')'] | T![']'] => {
                 // Removes: trailing comma, newline (incl. surrounding whitespace)
-                edit.delete(TextRange::new(
-                    prev.text_range().start(),
-                    token.text_range().end(),
-                ));
+                edit.delete(TextRange::new(prev.text_range().start(), token.text_range().end()));
                 return;
             }
             T!['}'] => {
     }
 
     // Remove newline but add a computed amount of whitespace characters
-    edit.replace(
-        token.text_range(),
-        compute_ws(prev.kind(), next.kind()).to_owned(),
-    );
+    edit.replace(token.text_range(), compute_ws(prev.kind(), next.kind()).to_owned());
 }
 
 fn join_single_expr_block(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {
 fn join_single_use_tree(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {
     let use_tree_list = ast::UseTreeList::cast(token.parent()?)?;
     let (tree,) = use_tree_list.use_trees().collect_tuple()?;
-    edit.replace(
-        use_tree_list.syntax().text_range(),
-        tree.syntax().text().to_string(),
-    );
+    edit.replace(use_tree_list.syntax().text_range(), tree.syntax().text().to_string());
     Some(())
 }
 
         return None;
     }
 
-    edit.delete(
-        let_stmt
-            .semicolon_token()?
-            .text_range()
-            .cover(lhs.syntax().text_range()),
-    );
+    edit.delete(let_stmt.semicolon_token()?.text_range().cover(lhs.syntax().text_range()));
     Some(())
 }
 
 #[cfg(test)]
 mod tests {
     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};
-
     use super::*;
-
     fn check_join_lines(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
         };
 
         let (before_cursor_pos, before) = extract_offset(ra_fixture_before);
-        let file = SourceFile::parse(&before, span::Edition::CURRENT)
-            .ok()
-            .unwrap();
+        let file = SourceFile::parse(&before, span::Edition::CURRENT).ok().unwrap();
 
         let range = TextRange::empty(before_cursor_pos);
         let result = join_lines(&config, &file, range);
         let actual = add_cursor(&actual, actual_cursor_pos);
         assert_eq_text!(ra_fixture_after, &actual);
     }
-
     fn check_join_lines_sel(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
         };
         assert_eq_text!(ra_fixture_after, &actual);
     }
-
     #[test]
     fn test_join_lines_comma() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_lambda_block() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_block() {
         check_join_lines(
 }",
         );
     }
-
     #[test]
     fn test_join_lines_diverging_block() {
         check_join_lines(
         ",
         );
     }
-
     #[test]
     fn join_lines_adds_comma_for_block_in_match_arm() {
         check_join_lines(
 }",
         );
     }
-
     #[test]
     fn join_lines_multiline_in_block() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn join_lines_keeps_comma_for_block_in_match_arm() {
         // We already have a comma
 }",
         );
     }
-
     #[test]
     fn join_lines_keeps_comma_with_single_arg_tuple() {
         // A single arg tuple
 }",
         );
     }
-
     #[test]
     fn test_join_lines_use_items_left() {
         // No space after the '{'
 };",
         );
     }
-
     #[test]
     fn test_join_lines_use_items_right() {
         // No space after the '}'
 $0    TextSize, TextRange};",
         );
     }
-
     #[test]
     fn test_join_lines_use_items_right_comma() {
         // No space after the '}'
 $0    TextSize, TextRange};",
         );
     }
-
     #[test]
     fn test_join_lines_use_tree() {
         check_join_lines(
 };",
         );
     }
-
     #[test]
     fn test_join_lines_normal_comments() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_doc_comments() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_mod_comments() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_multiline_comments_1() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_multiline_comments_2() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_selection_fn_args() {
         check_join_lines_sel(
     ",
         );
     }
-
     #[test]
     fn test_join_lines_selection_struct() {
         check_join_lines_sel(
     ",
         );
     }
-
     #[test]
     fn test_join_lines_selection_dot_chain() {
         check_join_lines_sel(
 }",
         );
     }
-
     #[test]
     fn test_join_lines_selection_lambda_block_body() {
         check_join_lines_sel(
 }",
         );
     }
-
     #[test]
     fn test_join_lines_commented_block() {
         check_join_lines(
         ",
         )
     }
-
     #[test]
     fn join_lines_mandatory_blocks_block() {
         check_join_lines(
         ",
         );
     }
-
     #[test]
     fn join_string_literal() {
         {
 "#,
         );
     }
-
     #[test]
     fn join_last_line_empty() {
         check_join_lines(
 "#,
         );
     }
-
     #[test]
     fn join_two_ifs() {
         cov_mark::check!(join_two_ifs);
 "#,
         );
     }
-
     #[test]
     fn join_two_ifs_with_existing_else() {
         cov_mark::check!(join_two_ifs_with_existing_else);
 "#,
         );
     }
-
     #[test]
     fn join_assignments() {
         check_join_lines(