COMPARISON DIFF
============================================================

Original size: 22055 bytes
Chloro size:   21510 bytes
Rustfmt size:  22055 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     pub join_assignments: bool,
 }
 
-// Feature: Join Lines
-//
-// Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.
-//
-// See [this gif](https://user-images.githubusercontent.com/1711539/124515923-4504e800-dde9-11eb-8d58-d97945a1a785.gif) for the cases handled specially by joined lines.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: Join lines** |
-//
-// ![Join Lines](https://user-images.githubusercontent.com/48062697/113020661-b6922200-917a-11eb-87c4-b75acc028f11.gif)
 pub(crate) fn join_lines(
     config: &JoinLinesConfig,
     file: &SourceFile,
     }
 
     // The node is between two other nodes
+
     let (prev, next) = match (token.prev_sibling_or_token(), token.next_sibling_or_token()) {
         (Some(prev), Some(next)) => (prev, next),
         _ => return,
     }
 
     // Remove newline but add a computed amount of whitespace characters
+
     edit.replace(token.text_range(), compute_ws(prev.kind(), next.kind()).to_owned());
 }
 
     let mut buf = expr.syntax().text().to_string();
 
     // Match block needs to have a comma after the block
+
     if let Some(match_arm) = block_expr.syntax().parent().and_then(ast::MatchArm::cast)
         && match_arm.comma_token().is_none()
     {
 #[cfg(test)]
 mod tests {
     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};
-
     use super::*;
-
     fn check_join_lines(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
         let actual = add_cursor(&actual, actual_cursor_pos);
         assert_eq_text!(ra_fixture_after, &actual);
     }
-
     fn check_join_lines_sel(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
         };
         assert_eq_text!(ra_fixture_after, &actual);
     }
-
     #[test]
     fn test_join_lines_comma() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_lambda_block() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_block() {
         check_join_lines(
 }",
         );
     }
-
     #[test]
     fn test_join_lines_diverging_block() {
         check_join_lines(
         ",
         );
     }
-
     #[test]
     fn join_lines_adds_comma_for_block_in_match_arm() {
         check_join_lines(
 }",
         );
     }
-
     #[test]
     fn join_lines_multiline_in_block() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn join_lines_keeps_comma_for_block_in_match_arm() {
         // We already have a comma
         );
 
         // comma with whitespace between brace and ,
+
         check_join_lines(
             r"
 fn foo(e: Result<U, V>) {
         );
 
         // comma with newline between brace and ,
+
         check_join_lines(
             r"
 fn foo(e: Result<U, V>) {
 }",
         );
     }
-
     #[test]
     fn join_lines_keeps_comma_with_single_arg_tuple() {
         // A single arg tuple
         );
 
         // single arg tuple with whitespace between brace and comma
+
         check_join_lines(
             r"
 fn foo() {
         );
 
         // single arg tuple with newline between brace and comma
+
         check_join_lines(
             r"
 fn foo() {
 }",
         );
     }
-
     #[test]
     fn test_join_lines_use_items_left() {
         // No space after the '{'
 };",
         );
     }
-
     #[test]
     fn test_join_lines_use_items_right() {
         // No space after the '}'
 $0    TextSize, TextRange};",
         );
     }
-
     #[test]
     fn test_join_lines_use_items_right_comma() {
         // No space after the '}'
 $0    TextSize, TextRange};",
         );
     }
-
     #[test]
     fn test_join_lines_use_tree() {
         check_join_lines(
 };",
         );
     }
-
     #[test]
     fn test_join_lines_normal_comments() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_doc_comments() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_mod_comments() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_multiline_comments_1() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_multiline_comments_2() {
         check_join_lines(
 ",
         );
     }
-
     #[test]
     fn test_join_lines_selection_fn_args() {
         check_join_lines_sel(
     ",
         );
     }
-
     #[test]
     fn test_join_lines_selection_struct() {
         check_join_lines_sel(
     ",
         );
     }
-
     #[test]
     fn test_join_lines_selection_dot_chain() {
         check_join_lines_sel(
 }",
         );
     }
-
     #[test]
     fn test_join_lines_selection_lambda_block_body() {
         check_join_lines_sel(
 }",
         );
     }
-
     #[test]
     fn test_join_lines_commented_block() {
         check_join_lines(
         ",
         )
     }
-
     #[test]
     fn join_lines_mandatory_blocks_block() {
         check_join_lines(
         ",
         );
     }
-
     #[test]
     fn join_string_literal() {
         {
 "#,
         );
     }
-
     #[test]
     fn join_last_line_empty() {
         check_join_lines(
 "#,
         );
     }
-
     #[test]
     fn join_two_ifs() {
         cov_mark::check!(join_two_ifs);
 "#,
         );
     }
-
     #[test]
     fn join_two_ifs_with_existing_else() {
         cov_mark::check!(join_two_ifs_with_existing_else);
 "#,
         );
     }
-
     #[test]
     fn join_assignments() {
         check_join_lines(