COMPARISON DIFF
============================================================

Original size: 53876 bytes
Chloro size:   53885 bytes
Rustfmt size:  53876 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Logic for rendering the different hover messages
+
 use std::{env, mem, ops::Not};
 
 use either::Either;
 use hir::{
-    Adt, AsAssocItem, AsExternAssocItem, CaptureKind, DisplayTarget, DropGlue,
+    db::ExpandDatabase, Adt, AsAssocItem, AsExternAssocItem, CaptureKind, DisplayTarget, DropGlue,
     DynCompatibilityViolation, HasCrate, HasSource, HirDisplay, Layout, LayoutError,
     MethodViolationCode, Name, Semantics, Symbol, Trait, Type, TypeInfo, VariantDef,
-    db::ExpandDatabase,
 };
 use ide_db::{
-    RootDatabase,
-    defs::{Definition, find_std_module},
+    defs::{find_std_module, Definition},
     documentation::{DocsRangeMap, HasDocs},
     famous_defs::FamousDefs,
     generated::lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES},
     syntax_helpers::prettify_macro_expansion,
+    RootDatabase,
 };
 use itertools::Itertools;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use span::{Edition, TextSize};
 use stdx::format_to;
-use syntax::{AstNode, AstToken, Direction, SyntaxToken, T, algo, ast, match_ast};
+use syntax::{algo, ast, match_ast, AstNode, AstToken, Direction, SyntaxToken, T};
 
 use crate::{
+    doc_links::{remove_links, rewrite_links},
+    hover::{notable_traits, walk_and_push_ty, SubstTyLen},
+    interpret::render_const_eval_error,
     HoverAction, HoverConfig, HoverResult, Markup, MemoryLayoutHoverConfig,
     MemoryLayoutHoverRenderKind,
-    doc_links::{remove_links, rewrite_links},
-    hover::{SubstTyLen, notable_traits, walk_and_push_ty},
-    interpret::render_const_eval_error,
 };
 
 pub(super) fn type_info_of(
     display_target: DisplayTarget,
 ) -> Option<HoverResult> {
     let inner_ty = sema.type_of_expr(&deref_expr.expr()?)?.original;
-    let TypeInfo { original, adjusted } =
-        sema.type_of_expr(&ast::Expr::from(deref_expr.clone()))?;
+    let TypeInfo { original, adjusted } = sema.type_of_expr(&ast::Expr::from(deref_expr.clone()))?;
 
     let mut res = HoverResult::default();
     let mut targets: Vec<hir::ModuleDef> = Vec::new();
     //         ast::TypeArg(_it) => (),
 
     //         ast::CastExpr(_it) => (),
+
     //         ast::ParenType(_it) => (),
+
     //         ast::TupleType(_it) => (),
+
     //         ast::PtrType(_it) => (),
+
     //         ast::RefType(_it) => (),
+
     //         ast::ArrayType(_it) => (),
+
     //         ast::SliceType(_it) => (),
+
     //         ast::ForType(_it) => (),
+
     //         _ => return None,
+
     //     }
+
     // }
 
     // FIXME: https://github.com/rust-lang/rust-analyzer/issues/11762, this currently always returns Unknown
+
     // type_info(sema, config, sema.resolve_type(&ast::Type::InferType(it))?, None)
     None
 }
     let parent = token.parent()?;
     let famous_defs = FamousDefs(sema, sema.scope(&parent)?.krate());
 
-    let KeywordHint { description, keyword_mod, actions } =
-        keyword_hints(sema, token, parent, edition, display_target);
+    let KeywordHint { description, keyword_mod, actions } = keyword_hints(sema, token, parent, edition, display_target);
 
     let doc_owner = find_std_module(&famous_defs, &keyword_mod, edition)?;
     let (docs, range_map) = doc_owner.docs_with_rangemap(sema.db)?;
-    let (markup, range_map) =
-        markup(Some(docs.into()), Some(range_map), description, None, None, String::new());
+    let (markup, range_map) = markup(Some(docs.into()), Some(range_map), description, None, None, String::new());
     let markup = process_markup(sema.db, Definition::Module(doc_owner), &markup, range_map, config);
     Some(HoverResult { markup, actions })
 }
     let missing_fields = sema.record_pattern_missing_fields(pattern);
 
     // if there are no missing fields, the end result is a hover that shows ".."
-    // should be left in to indicate that there are no more fields in the pattern
-    // example, S {a: 1, b: 2, ..} when struct S {a: u32, b: u32}
 
+    // should be left in to indicate that there are no more fields in the pattern
+
+    // example, S {a: 1, b: 2, ..} when struct S {a: u32, b: u32}
     let mut res = HoverResult::default();
     let mut targets: Vec<hir::ModuleDef> = Vec::new();
     let mut push_new_def = |item: hir::ModuleDef| {
         token.text()
     };
 
-    let lint =
-        lints.binary_search_by_key(&needle, |lint| lint.label).ok().map(|idx| &lints[idx])?;
+    let lint = lints.binary_search_by_key(&needle, |lint| lint.label).ok().map(|idx| &lints[idx])?;
     Some(HoverResult {
         markup: Markup::from(format!("```\n{}\n```\n---\n\n{}", lint.label, lint.description)),
         ..Default::default()
         }
         _ => def.label(db, display_target),
     };
-    let (docs, range_map) =
-        if let Some((docs, doc_range)) = def.docs_with_rangemap(db, famous_defs, display_target) {
+    let (docs, range_map) = if let Some((docs, doc_range)) = def.docs_with_rangemap(db, famous_defs, display_target) {
             (Some(docs), doc_range)
         } else {
             (None, None)
     display_target: DisplayTarget,
 ) -> Option<HoverResult> {
     let c = original.as_closure()?;
-    let mut captures_rendered = c.captured_items(sema.db)
+    let mut captures_rendered = c
+        .captured_items(sema.db)
         .into_iter()
         .map(|it| {
             let borrow_kind = match it.kind() {
         }
     };
     walk_and_push_ty(sema.db, original, &mut push_new_def);
-    c.capture_types(sema.db).into_iter().for_each(|ty| {
+    c
+        .capture_types(sema.db)
+        .into_iter()
+        .for_each(|ty| {
         walk_and_push_ty(sema.db, &ty, &mut push_new_def);
     });
 
             format_to!(label, "niches = {niches}, ");
         }
     }
-    label.pop(); // ' '
-    label.pop(); // ','
+    label.pop();
+    // ' '
+    label.pop();
+    // ','
     Some(label)
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-
     const TESTERS: [u128; 10] = [0, 1, 2, 3, 4, 255, 256, 257, u128::MAX - 1, u128::MAX];
-
     #[test]
     fn test_is_pwr2minus1() {
         const OUTCOMES: [bool; 10] =
             assert_eq!(actual, expected, "is_pwr2minu1({test}) gave {actual}, expected {expected}");
         }
     }
-
     #[test]
     fn test_is_pwr2plus1() {
         const OUTCOMES: [bool; 10] =
             assert_eq!(actual, expected, "is_pwr2plus1({test}) gave {actual}, expected {expected}");
         }
     }
-
     #[test]
     fn test_pwr2_to_exponent() {
         const TESTERS: [u128; 9] = [