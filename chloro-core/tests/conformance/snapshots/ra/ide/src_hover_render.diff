COMPARISON DIFF
============================================================

Original size: 53876 bytes
Chloro size:   53895 bytes
Rustfmt size:  53876 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Logic for rendering the different hover messages
+
 use std::{env, mem, ops::Not};
 
 use either::Either;
 use hir::{
-    Adt, AsAssocItem, AsExternAssocItem, CaptureKind, DisplayTarget, DropGlue,
+    db::ExpandDatabase, Adt, AsAssocItem, AsExternAssocItem, CaptureKind, DisplayTarget, DropGlue,
     DynCompatibilityViolation, HasCrate, HasSource, HirDisplay, Layout, LayoutError,
     MethodViolationCode, Name, Semantics, Symbol, Trait, Type, TypeInfo, VariantDef,
-    db::ExpandDatabase,
 };
 use ide_db::{
-    RootDatabase,
-    defs::{Definition, find_std_module},
+    defs::{find_std_module, Definition},
     documentation::{DocsRangeMap, HasDocs},
     famous_defs::FamousDefs,
     generated::lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES},
     syntax_helpers::prettify_macro_expansion,
+    RootDatabase,
 };
 use itertools::Itertools;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use span::{Edition, TextSize};
 use stdx::format_to;
-use syntax::{AstNode, AstToken, Direction, SyntaxToken, T, algo, ast, match_ast};
+use syntax::{algo, ast, match_ast, AstNode, AstToken, Direction, SyntaxToken, T};
 
 use crate::{
+    doc_links::{remove_links, rewrite_links},
+    hover::{notable_traits, walk_and_push_ty, SubstTyLen},
+    interpret::render_const_eval_error,
     HoverAction, HoverConfig, HoverResult, Markup, MemoryLayoutHoverConfig,
     MemoryLayoutHoverRenderKind,
-    doc_links::{remove_links, rewrite_links},
-    hover::{SubstTyLen, notable_traits, walk_and_push_ty},
-    interpret::render_const_eval_error,
 };
 
 pub(super) fn type_info_of(
     //         ast::TypeArg(_it) => (),
 
     //         ast::CastExpr(_it) => (),
+
     //         ast::ParenType(_it) => (),
+
     //         ast::TupleType(_it) => (),
+
     //         ast::PtrType(_it) => (),
+
     //         ast::RefType(_it) => (),
+
     //         ast::ArrayType(_it) => (),
+
     //         ast::SliceType(_it) => (),
+
     //         ast::ForType(_it) => (),
+
     //         _ => return None,
+
     //     }
+
     // }
 
     // FIXME: https://github.com/rust-lang/rust-analyzer/issues/11762, this currently always returns Unknown
+
     // type_info(sema, config, sema.resolve_type(&ast::Type::InferType(it))?, None)
     None
 }
     let missing_fields = sema.record_pattern_missing_fields(pattern);
 
     // if there are no missing fields, the end result is a hover that shows ".."
-    // should be left in to indicate that there are no more fields in the pattern
-    // example, S {a: 1, b: 2, ..} when struct S {a: u32, b: u32}
 
+    // should be left in to indicate that there are no more fields in the pattern
+
+    // example, S {a: 1, b: 2, ..} when struct S {a: u32, b: u32}
     let mut res = HoverResult::default();
     let mut targets: Vec<hir::ModuleDef> = Vec::new();
     let mut push_new_def = |item: hir::ModuleDef| {
                 return d.as_extern_assoc_item(db).map(|_| "<extern>".to_owned());
             }
         }
-    }
-    .map(|name| name.display(db, edition).to_string())
+    }.map(
+        |name| name.display(db, edition).to_string(),
+    )
 }
 
 pub(super) fn path(
         let offset = TextSize::new(buf.len() as u32);
         let buf_range_map = range_map.map(|range_map| range_map.shift_docstring_line_range(offset));
         format_to!(buf, "{}", doc);
-
         (buf.into(), buf_range_map)
     } else {
         (buf.into(), None)
             format_to!(label, "niches = {niches}, ");
         }
     }
-    label.pop(); // ' '
-    label.pop(); // ','
+    label.pop();
+    // ' '
+    label.pop();
+    // ','
     Some(label)
 }
 
     match token.kind() {
         T![await] | T![loop] | T![match] | T![unsafe] | T![as] | T![try] | T![if] | T![else] => {
             let keyword_mod = format!("{}_keyword", token.text());
-
             match ast::Expr::cast(parent).and_then(|site| sema.type_of_expr(&site)) {
                 // ignore the unit type ()
                 Some(ty) if !ty.adjusted.as_ref().unwrap_or(&ty.original).is_unit() => {
                         }
                     };
                     walk_and_push_ty(sema.db, &ty.original, &mut push_new_def);
-
                     let ty = ty.adjusted();
                     let description =
                         format!("{}: {}", token.text(), ty.display(sema.db, display_target));
-
                     KeywordHint {
                         description,
                         keyword_mod,
 #[cfg(test)]
 mod tests {
     use super::*;
-
     const TESTERS: [u128; 10] = [0, 1, 2, 3, 4, 255, 256, 257, u128::MAX - 1, u128::MAX];
-
     #[test]
     fn test_is_pwr2minus1() {
         const OUTCOMES: [bool; 10] =
             assert_eq!(actual, expected, "is_pwr2minu1({test}) gave {actual}, expected {expected}");
         }
     }
-
     #[test]
     fn test_is_pwr2plus1() {
         const OUTCOMES: [bool; 10] =
             assert_eq!(actual, expected, "is_pwr2plus1({test}) gave {actual}, expected {expected}");
         }
     }
-
     #[test]
     fn test_pwr2_to_exponent() {
         const TESTERS: [u128; 9] = [