COMPARISON DIFF
============================================================

Original size: 53876 bytes
Chloro size:   53889 bytes
Rustfmt size:  53876 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Logic for rendering the different hover messages
+
 use std::{env, mem, ops::Not};
 
 use either::Either;
 use hir::{
-    Adt, AsAssocItem, AsExternAssocItem, CaptureKind, DisplayTarget, DropGlue,
+    db::ExpandDatabase, Adt, AsAssocItem, AsExternAssocItem, CaptureKind, DisplayTarget, DropGlue,
     DynCompatibilityViolation, HasCrate, HasSource, HirDisplay, Layout, LayoutError,
     MethodViolationCode, Name, Semantics, Symbol, Trait, Type, TypeInfo, VariantDef,
-    db::ExpandDatabase,
 };
 use ide_db::{
-    RootDatabase,
-    defs::{Definition, find_std_module},
+    defs::{find_std_module, Definition},
     documentation::{DocsRangeMap, HasDocs},
     famous_defs::FamousDefs,
     generated::lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES},
     syntax_helpers::prettify_macro_expansion,
+    RootDatabase,
 };
 use itertools::Itertools;
 use rustc_apfloat::{
-    Float,
     ieee::{Half as f16, Quad as f128},
+    Float,
 };
 use span::{Edition, TextSize};
 use stdx::format_to;
-use syntax::{AstNode, AstToken, Direction, SyntaxToken, T, algo, ast, match_ast};
+use syntax::{algo, ast, match_ast, AstNode, AstToken, Direction, SyntaxToken, T};
 
 use crate::{
+    doc_links::{remove_links, rewrite_links},
+    hover::{notable_traits, walk_and_push_ty, SubstTyLen},
+    interpret::render_const_eval_error,
     HoverAction, HoverConfig, HoverResult, Markup, MemoryLayoutHoverConfig,
     MemoryLayoutHoverRenderKind,
-    doc_links::{remove_links, rewrite_links},
-    hover::{SubstTyLen, notable_traits, walk_and_push_ty},
-    interpret::render_const_eval_error,
 };
 
 pub(super) fn type_info_of(
     //         ast::TypeArg(_it) => (),
 
     //         ast::CastExpr(_it) => (),
+
     //         ast::ParenType(_it) => (),
+
     //         ast::TupleType(_it) => (),
+
     //         ast::PtrType(_it) => (),
+
     //         ast::RefType(_it) => (),
+
     //         ast::ArrayType(_it) => (),
+
     //         ast::SliceType(_it) => (),
+
     //         ast::ForType(_it) => (),
+
     //         _ => return None,
+
     //     }
+
     // }
 
     // FIXME: https://github.com/rust-lang/rust-analyzer/issues/11762, this currently always returns Unknown
+
     // type_info(sema, config, sema.resolve_type(&ast::Type::InferType(it))?, None)
     None
 }
     let missing_fields = sema.record_pattern_missing_fields(pattern);
 
     // if there are no missing fields, the end result is a hover that shows ".."
-    // should be left in to indicate that there are no more fields in the pattern
-    // example, S {a: 1, b: 2, ..} when struct S {a: u32, b: u32}
 
+    // should be left in to indicate that there are no more fields in the pattern
+
+    // example, S {a: 1, b: 2, ..} when struct S {a: u32, b: u32}
     let mut res = HoverResult::default();
     let mut targets: Vec<hir::ModuleDef> = Vec::new();
     let mut push_new_def = |item: hir::ModuleDef| {
             format_to!(label, "niches = {niches}, ");
         }
     }
-    label.pop(); // ' '
-    label.pop(); // ','
+    label.pop();
+    // ' '
+    label.pop();
+    // ','
     Some(label)
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-
     const TESTERS: [u128; 10] = [0, 1, 2, 3, 4, 255, 256, 257, u128::MAX - 1, u128::MAX];
-
     #[test]
     fn test_is_pwr2minus1() {
         const OUTCOMES: [bool; 10] =
             assert_eq!(actual, expected, "is_pwr2minu1({test}) gave {actual}, expected {expected}");
         }
     }
-
     #[test]
     fn test_is_pwr2plus1() {
         const OUTCOMES: [bool; 10] =
             assert_eq!(actual, expected, "is_pwr2plus1({test}) gave {actual}, expected {expected}");
         }
     }
-
     #[test]
     fn test_pwr2_to_exponent() {
         const TESTERS: [u128; 9] = [