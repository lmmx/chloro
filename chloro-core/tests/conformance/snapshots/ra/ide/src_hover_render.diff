COMPARISON DIFF
============================================================

Original size: 53876 bytes
Chloro size:   53902 bytes
Rustfmt size:  53876 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Logic for rendering the different hover messages
+
 use std::{env, mem, ops::Not};
 
 use either::Either;
             }
         };
     };
-
     if inner_ty == body_ty {
         return None;
     }
-
     let mut inner_ty = inner_ty;
     let mut s = "Try Target".to_owned();
-
     let adts = inner_ty.as_adt().zip(body_ty.as_adt());
     if let Some((hir::Adt::Enum(inner), hir::Adt::Enum(body))) = adts {
         let famous_defs = FamousDefs(sema, sema.scope(try_expr.syntax())?.krate());
             }
         }
     }
-
     let mut res = HoverResult::default();
-
     let mut targets: Vec<hir::ModuleDef> = Vec::new();
     let mut push_new_def = |item: hir::ModuleDef| {
         if !targets.contains(&item) {
     if let Some(actions) = HoverAction::goto_type_from_targets(sema, targets, edition) {
         res.actions.push(actions);
     }
-
     let inner_ty = inner_ty.display(sema.db, display_target).to_string();
     let body_ty = body_ty.display(sema.db, display_target).to_string();
     let ty_len_max = inner_ty.len().max(body_ty.len());
-
     let l = "Propagated as: ".len() - " Type: ".len();
     let static_text_len_diff = l as isize - s.len() as isize;
     let tpad = static_text_len_diff.max(0) as usize;
     let ppad = static_text_len_diff.min(0).unsigned_abs();
-
     res.markup = format!(
         "```text\n{} Type: {:>pad0$}\nPropagated as: {:>pad1$}\n```\n",
         s,
     let inner_ty = sema.type_of_expr(&deref_expr.expr()?)?.original;
     let TypeInfo { original, adjusted } =
         sema.type_of_expr(&ast::Expr::from(deref_expr.clone()))?;
-
     let mut res = HoverResult::default();
     let mut targets: Vec<hir::ModuleDef> = Vec::new();
     let mut push_new_def = |item: hir::ModuleDef| {
     };
     walk_and_push_ty(sema.db, &inner_ty, &mut push_new_def);
     walk_and_push_ty(sema.db, &original, &mut push_new_def);
-
     res.markup = if let Some(adjusted_ty) = adjusted {
         walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);
         let original = original.display(sema.db, display_target).to_string();
     if let Some(actions) = HoverAction::goto_type_from_targets(sema, targets, edition) {
         res.actions.push(actions);
     }
-
     Some(res)
 }
 
     //         ast::Param(_it) => (),
     //         ast::RetType(_it) => (),
     //         ast::TypeArg(_it) => (),
-
     //         ast::CastExpr(_it) => (),
     //         ast::ParenType(_it) => (),
     //         ast::TupleType(_it) => (),
     //         _ => return None,
     //     }
     // }
-
     // FIXME: https://github.com/rust-lang/rust-analyzer/issues/11762, this currently always returns Unknown
     // type_info(sema, config, sema.resolve_type(&ast::Type::InferType(it))?, None)
     None
     }
     let parent = token.parent()?;
     let famous_defs = FamousDefs(sema, sema.scope(&parent)?.krate());
-
     let KeywordHint { description, keyword_mod, actions } =
         keyword_hints(sema, token, parent, edition, display_target);
-
     let doc_owner = find_std_module(&famous_defs, &keyword_mod, edition)?;
     let (docs, range_map) = doc_owner.docs_with_rangemap(sema.db)?;
     let (markup, range_map) =
     display_target: DisplayTarget,
 ) -> HoverResult {
     let missing_fields = sema.record_pattern_missing_fields(pattern);
-
     // if there are no missing fields, the end result is a hover that shows ".."
     // should be left in to indicate that there are no more fields in the pattern
     // example, S {a: 1, b: 2, ..} when struct S {a: u32, b: u32}
-
     let mut res = HoverResult::default();
     let mut targets: Vec<hir::ModuleDef> = Vec::new();
     let mut push_new_def = |item: hir::ModuleDef| {
     for (_, t) in &missing_fields {
         walk_and_push_ty(sema.db, t, &mut push_new_def);
     }
-
     res.markup = {
         let mut s = String::from(".., ");
         for (f, _) in &missing_fields {
     res
 }
 
-pub(super) fn try_for_lint(attr: &ast::Attr, token: &SyntaxToken) -> Option<HoverResult> {
+pub(super) fn try_for_lint(
+    attr: &ast::Attr,
+    token: &SyntaxToken,
+) -> Option<HoverResult> {
     let (path, tt) = attr.as_simple_call()?;
     if !tt.syntax().text_range().contains(token.text_range().start()) {
         return None;
         }
         _ => return None,
     };
-
     let tmp;
     let needle = if is_clippy {
         tmp = format!("clippy::{}", token.text());
     } else {
         token.text()
     };
-
     let lint =
         lints.binary_search_by_key(&needle, |lint| lint.label).ok().map(|idx| &lints[idx])?;
     Some(HoverResult {
     Markup::from(markup)
 }
 
-fn definition_owner_name(db: &RootDatabase, def: Definition, edition: Edition) -> Option<String> {
+fn definition_owner_name(
+    db: &RootDatabase,
+    def: Definition,
+    edition: Edition,
+) -> Option<String> {
     match def {
         Definition::Field(f) => {
             let parent = f.parent_def(db);
         }
         _ => None,
     };
-
     let layout_info = || match def {
         Definition::Field(it) => render_memory_layout(
             config.memory_layout,
         ),
         _ => None,
     };
-
     let drop_info = || {
         if !config.show_drop_glue {
             return None;
 
         Some(rendered_drop_glue.to_owned())
     };
-
     let dyn_compatibility_info = || match def {
         Definition::Trait(it) => {
             let mut dyn_compatibility_info = String::new();
         }
         _ => None,
     };
-
     let variance_info = || match def {
         Definition::GenericParam(it) => it.variance(db).as_ref().map(ToString::to_string),
         _ => None,
     };
-
     let mut extra = String::new();
     if render_extras {
         if let Some(notable_traits) =
         desc.push_str(" = ");
         desc.push_str(&value);
     }
-
     let subst_types = match config.max_subst_ty_len {
         SubstTyLen::Hide => String::new(),
         SubstTyLen::LimitTo(_) | SubstTyLen::Unlimited => {
                 .unwrap_or_default()
         }
     };
-
     markup(
         docs.map(Into::into),
         range_map,
         sema.type_of_expr(&ast::Expr::Literal(lit))?
     }
     .original;
-
     let value = match_ast! {
         match token {
             ast::String(string)     => string.value().as_ref().map_err(|e| format!("{e:?}")).map(ToString::to_string),
         }
     };
     let ty = ty.display(sema.db, display_target);
-
     let mut s = format!("```rust\n{ty}\n```\n---\n\n");
     match value {
         Ok(value) => {
         }
     };
     walk_and_push_ty(db, &original, &mut push_new_def);
-
     res.markup = if let Some(adjusted_ty) = adjusted {
         walk_and_push_ty(db, &adjusted_ty, &mut push_new_def);
 
     c.capture_types(sema.db).into_iter().for_each(|ty| {
         walk_and_push_ty(sema.db, &ty, &mut push_new_def);
     });
-
     let adjusted = if let Some(adjusted_ty) = adjusted {
         walk_and_push_ty(sema.db, adjusted_ty, &mut push_new_def);
         format!(
         String::new()
     };
     let mut markup = format!("```rust\n{}\n```", c.display_with_impl(sema.db, display_target));
-
     if let Some(trait_) = c.fn_trait(sema.db).get_id(sema.db, original.krate(sema.db).into()) {
         push_new_def(hir::Trait::from(trait_).into())
     }
         format_to!(markup, "\n---\n{layout}");
     }
     format_to!(markup, "{adjusted}\n\n## Captures\n{}", captures_rendered,);
-
     let mut res = HoverResult::default();
     if let Some(actions) = HoverAction::goto_type_from_targets(sema, targets, edition) {
         res.actions.push(actions);
     Some(res)
 }
 
-fn definition_path(db: &RootDatabase, &def: &Definition, edition: Edition) -> Option<String> {
+fn definition_path(
+    db: &RootDatabase,
+    &def: &Definition,
+    edition: Edition,
+) -> Option<String> {
     if matches!(
         def,
         Definition::TupleField(_)
     subst_types: String,
 ) -> (Markup, Option<DocsRangeMap>) {
     let mut buf = String::new();
-
     if let Some(mod_path) = mod_path
         && !mod_path.is_empty()
     {
         format_to!(buf, "```rust\n{}\n```\n\n", mod_path);
     }
     format_to!(buf, "```rust\n{}\n```", rust);
-
     if let Some(extra) = extra {
         buf.push_str(&extra);
     }
-
     if !subst_types.is_empty() {
         format_to!(buf, "\n___\n{subst_types}");
     }
-
     if let Some(doc) = docs {
         format_to!(buf, "\n___\n\n");
         let offset = TextSize::new(buf.len() as u32);
 ) -> Option<String> {
     let config = config?;
     let layout = layout().ok()?;
-
     let mut label = String::new();
-
     if let Some(render) = config.size {
         let size = match tag(&layout) {
             Some(tag) => layout.size() as usize - tag,
         }
         format_to!(label, ", ");
     }
-
     if let Some(render) = config.alignment {
         let align = layout.align();
         format_to!(label, "align = ");
         }
         format_to!(label, ", ");
     }
-
     if let Some(render) = config.offset
         && let Some(offset) = offset(&layout)
     {
         }
         format_to!(label, ", ");
     }
-
     if let Some(render) = config.padding
         && let Some((padding_name, padding)) = padding(&layout)
     {
         }
         format_to!(label, ", ");
     }
-
     if config.niches
         && let Some(niches) = layout.niches()
     {
             format_to!(label, "niches = {niches}, ");
         }
     }
-    label.pop(); // ' '
-    label.pop(); // ','
+    label.pop();
+    // ' '
+    label.pop();
+    // ','
     Some(label)
 }
 
 }
 
 impl KeywordHint {
-    fn new(description: String, keyword_mod: String) -> Self {
+    fn new(
+        description: String,
+        keyword_mod: String,
+    ) -> Self {
         Self { description, keyword_mod, actions: Vec::default() }
     }
 }
 #[cfg(test)]
 mod tests {
     use super::*;
-
     const TESTERS: [u128; 10] = [0, 1, 2, 3, 4, 255, 256, 257, u128::MAX - 1, u128::MAX];
-
     #[test]
     fn test_is_pwr2minus1() {
         const OUTCOMES: [bool; 10] =
             assert_eq!(actual, expected, "is_pwr2minu1({test}) gave {actual}, expected {expected}");
         }
     }
-
     #[test]
     fn test_is_pwr2plus1() {
         const OUTCOMES: [bool; 10] =
             assert_eq!(actual, expected, "is_pwr2plus1({test}) gave {actual}, expected {expected}");
         }
     }
-
     #[test]
     fn test_pwr2_to_exponent() {
         const TESTERS: [u128; 9] = [