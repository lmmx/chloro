COMPARISON DIFF
============================================================

Original size: 19028 bytes
Chloro size:   18989 bytes
Rustfmt size:  19028 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module provides `StaticIndex` which is used for powering
 //! read-only code browsers and emitting LSIF
 
 use arrayvec::ArrayVec;
-use hir::{Crate, Module, Semantics, db::HirDatabase};
+use hir::{db::HirDatabase, Crate, Module, Semantics};
 use ide_db::{
-    FileId, FileRange, FxHashMap, FxHashSet, MiniCore, RootDatabase,
     base_db::{RootQueryDb, SourceDatabase, VfsPath},
     defs::{Definition, IdentClass},
     documentation::Documentation,
     famous_defs::FamousDefs,
+    FileId, FileRange, FxHashMap, FxHashSet, MiniCore, RootDatabase,
 };
 use span::Edition;
-use syntax::{AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, T, TextRange};
+use syntax::{AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, TextRange, T};
 
 use crate::navigation_target::UpmappingResult;
 use crate::{
-    Analysis, Fold, HoverConfig, HoverResult, InlayHint, InlayHintsConfig, TryToNav,
-    hover::{SubstTyLen, hover_for_definition},
+    hover::{hover_for_definition, SubstTyLen},
     inlay_hints::{AdjustmentHintsMode, InlayFieldsToResolve},
-    moniker::{MonikerResult, SymbolInformationKind, def_to_kind, def_to_moniker},
+    moniker::{def_to_kind, def_to_moniker, MonikerResult, SymbolInformationKind},
     parent_module::crates_for,
+    Analysis, Fold, HoverConfig, HoverResult, InlayHint, InlayHintsConfig, TryToNav,
 };
 
 /// A static representation of fully analyzed source code.
 }
 
 fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {
-    let mut worklist: Vec<_> =
-        Crate::all(db).into_iter().map(|krate| krate.root_module()).collect();
+    let mut worklist: Vec<_> = Crate::all(db).into_iter().map(|krate| krate.root_module()).collect();
     let mut modules = Vec::new();
 
     while let Some(module) = worklist.pop() {
     )
 }
 
-// FIXME: This is a weird function
 fn get_definitions(
     sema: &Semantics<'_, RootDatabase>,
     token: SyntaxToken,
 }
 
 pub enum VendoredLibrariesConfig<'a> {
-    Included { workspace_root: &'a VfsPath },
+    Included {
+        workspace_root: &'a VfsPath,
+    },
     Excluded,
 }
 
         // hovers
         let sema = hir::Semantics::new(self.db);
         let root = sema.parse_guess_edition(file_id).syntax().clone();
-        let edition = sema
-            .attach_first_edition(file_id)
-            .map(|it| it.edition(self.db))
-            .unwrap_or(Edition::CURRENT);
+        let edition = sema.attach_first_edition(file_id).map(|it| it.edition(self.db)).unwrap_or(Edition::CURRENT);
         let display_target = match sema.first_crate(file_id) {
             Some(krate) => krate.to_display_target(sema.db),
             None => return,
         };
-        let tokens = root.descendants_with_tokens().filter_map(|it| match it {
+        let tokens = root
+            .descendants_with_tokens()
+            .filter_map(|it| match it {
             syntax::NodeOrToken::Node(_) => None,
             syntax::NodeOrToken::Token(it) => Some(it),
         });
             show_drop_glue: true,
             minicore: MiniCore::default(),
         };
-        let tokens = tokens.filter(|token| {
+        let tokens = tokens
+            .filter(|token| {
             matches!(
                 token.kind(),
                 IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self]
 
 #[cfg(test)]
 mod tests {
-    use crate::{StaticIndex, fixture};
-    use ide_db::{FileRange, FxHashMap, FxHashSet, base_db::VfsPath};
+    use crate::{fixture, StaticIndex};
+    use ide_db::{base_db::VfsPath, FileRange, FxHashMap, FxHashSet};
     use syntax::TextSize;
-
     use super::VendoredLibrariesConfig;
-
     fn check_all_ranges(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         vendored_libs_config: VendoredLibrariesConfig<'_>,
             panic!("unfound ranges {range_set:?}");
         }
     }
-
     #[track_caller]
     fn check_definitions(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
             panic!("unfound definitions {range_set:?}");
         }
     }
-
     #[track_caller]
     fn check_references(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let mut range_set: FxHashMap<_, i32> = ranges.iter().map(|it| (it.0, 0)).collect();
 
         // Make sure that all references have at least one range. We use a HashMap instead of a
+
         // a HashSet so that we can have more than one reference at the same range.
         for (_, t) in s.tokens.iter() {
             for r in &t.references {
             }
         }
     }
-
     #[test]
     fn field_initialization() {
         check_references(
             },
         );
     }
-
     #[test]
     fn struct_and_enum() {
         check_all_ranges(
             },
         );
     }
-
     #[test]
     fn multi_crate() {
         check_definitions(
             },
         );
     }
-
     #[test]
     fn vendored_crate() {
         check_all_ranges(
             },
         );
     }
-
     #[test]
     fn vendored_crate_excluded() {
         check_all_ranges(
             VendoredLibrariesConfig::Excluded,
         )
     }
-
     #[test]
     fn derives() {
         check_all_ranges(