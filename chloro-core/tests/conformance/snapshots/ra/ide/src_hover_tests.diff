COMPARISON DIFF
============================================================

Original size: 210028 bytes
Chloro size:   209818 bytes
Rustfmt size:  210967 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use expect_test::{expect, Expect};
-use ide_db::{base_db::SourceDatabase, FileRange, MiniCore};
+use expect_test::{Expect, expect};
+use ide_db::{FileRange, MiniCore, base_db::SourceDatabase};
 use syntax::TextRange;
 
 use crate::{
-    fixture, HoverConfig, HoverDocFormat, MemoryLayoutHoverConfig, MemoryLayoutHoverRenderKind,
+    HoverConfig, HoverDocFormat, MemoryLayoutHoverConfig, MemoryLayoutHoverRenderKind, fixture,
 };
 
 use hir::setup_tracing;
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap();
-    assert!(
-        hover.is_none(),
-        "hover not expected but found: {:?}",
-        hover.unwrap()
-    );
+    assert!(hover.is_none(), "hover not expected but found: {:?}", hover.unwrap());
 }
 
 #[track_caller]
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
                 max_fields_count: fields_count.into(),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
                 max_enum_variants_count: variants_count.into(),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
                 max_trait_assoc_items_count: Some(count),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
     let hover = analysis
         .hover(
             &HOVER_BASE_CONFIG,
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                memory_layout: None,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { memory_layout: None, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
                 format: HoverDocFormat::PlainText,
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
     let (analysis, file_id, position) = fixture::range_or_position(ra_fixture);
     let mut hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id,
-                range: position.range_or_empty(),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id, range: position.range_or_empty() },
         )
         .unwrap()
         .unwrap();
     // stub out ranges into minicore as they can change every now and then
-    hover
-        .info
-        .actions
-        .iter_mut()
-        .for_each(|action| match action {
-            super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
-                if data.nav.file_id == file_id {
-                    return;
-                }
-                data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
-                if let Some(range) = &mut data.nav.focus_range {
-                    *range = TextRange::empty(span::TextSize::new(!0));
-                }
-            }),
-            _ => (),
-        });
+    hover.info.actions.iter_mut().for_each(|action| match action {
+        super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
+            if data.nav.file_id == file_id {
+                return;
+            }
+            data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
+            if let Some(range) = &mut data.nav.focus_range {
+                *range = TextRange::empty(span::TextSize::new(!0));
+            }
+        }),
+        _ => (),
+    });
     expect.assert_debug_eq(&hover.info.actions)
 }
 
 fn check_hover_range_actions(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
     let (analysis, range) = fixture::range(ra_fixture);
     let mut hover = analysis
-        .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            range,
-        )
+        .hover(&HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG }, range)
         .unwrap()
         .unwrap();
     // stub out ranges into minicore as they can change every now and then
-    hover
-        .info
-        .actions
-        .iter_mut()
-        .for_each(|action| match action {
-            super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
-                if data.nav.file_id == range.file_id {
-                    return;
-                }
-                data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
-                if let Some(range) = &mut data.nav.focus_range {
-                    *range = TextRange::empty(span::TextSize::new(!0));
-                }
-            }),
-            _ => (),
-        });
+    hover.info.actions.iter_mut().for_each(|action| match action {
+        super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
+            if data.nav.file_id == range.file_id {
+                return;
+            }
+            data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
+            if let Some(range) = &mut data.nav.focus_range {
+                *range = TextRange::empty(span::TextSize::new(!0));
+            }
+        }),
+        _ => (),
+    });
     expect.assert_debug_eq(&hover.info.actions);
 }
 
     );
 }
 
-// Check that we don't rewrite links which we can't identify
 #[test]
 fn test_hover_unknown_target() {
     check(
 
 mod type_param_sized_bounds {
     use super::*;
-
     #[test]
     fn single_implicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn single_explicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn single_relaxed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_implicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_explicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_relaxed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn mixed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn mixed2() {
         check(
     );
 }
 
-// FIXME(next-solver): this fails to normalize the const, probably due to the solver
-// refusing to give the impl because of the error type.
 #[test]
 fn hover_const_eval_in_generic_trait() {
     // Doesn't compile, but we shouldn't crash.
         "#]],
     );
 }
+
 #[test]
 fn hover_generic_assoc() {
     check(
     let (analysis, position) = fixture::position(r#"#![feature(intrinsics$0)]"#);
     analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
 #[test]
 fn hover_dollar_crate() {
     // $crate should be resolved to the right crate name.
-
     check(
         r#"
 //- /main.rs crate:main deps:dep