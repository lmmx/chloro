COMPARISON DIFF
============================================================

Original size: 210028 bytes
Chloro size:   209818 bytes
Rustfmt size:  210967 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use expect_test::{expect, Expect};
-use ide_db::{base_db::SourceDatabase, FileRange, MiniCore};
+use expect_test::{Expect, expect};
+use hir::setup_tracing;
+use ide_db::{FileRange, MiniCore, base_db::SourceDatabase};
 use syntax::TextRange;
 
 use crate::{
     fixture, HoverConfig, HoverDocFormat, MemoryLayoutHoverConfig, MemoryLayoutHoverRenderKind,
 };
 
-use hir::setup_tracing;
-
 const HOVER_BASE_CONFIG: HoverConfig<'_> = HoverConfig {
     links_in_hover: false,
     memory_layout: Some(MemoryLayoutHoverConfig {
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap();
-    assert!(
-        hover.is_none(),
-        "hover not expected but found: {:?}",
-        hover.unwrap()
-    );
+    assert!(hover.is_none(), "hover not expected but found: {:?}", hover.unwrap());
 }
 
 #[track_caller]
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
                 max_fields_count: fields_count.into(),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
                 max_enum_variants_count: variants_count.into(),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
                 max_trait_assoc_items_count: Some(count),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
     let hover = analysis
         .hover(
             &HOVER_BASE_CONFIG,
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                memory_layout: None,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { memory_layout: None, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
                 format: HoverDocFormat::PlainText,
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
     let (analysis, file_id, position) = fixture::range_or_position(ra_fixture);
     let mut hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id,
-                range: position.range_or_empty(),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id, range: position.range_or_empty() },
         )
         .unwrap()
         .unwrap();
     // stub out ranges into minicore as they can change every now and then
-    hover
-        .info
-        .actions
-        .iter_mut()
-        .for_each(|action| match action {
-            super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
-                if data.nav.file_id == file_id {
-                    return;
-                }
-                data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
-                if let Some(range) = &mut data.nav.focus_range {
-                    *range = TextRange::empty(span::TextSize::new(!0));
-                }
-            }),
-            _ => (),
-        });
+    hover.info.actions.iter_mut().for_each(|action| match action {
+        super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
+            if data.nav.file_id == file_id {
+                return;
+            }
+            data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
+            if let Some(range) = &mut data.nav.focus_range {
+                *range = TextRange::empty(span::TextSize::new(!0));
+            }
+        }),
+        _ => (),
+    });
     expect.assert_debug_eq(&hover.info.actions)
 }
 
 fn check_hover_range_actions(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
     let (analysis, range) = fixture::range(ra_fixture);
     let mut hover = analysis
-        .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            range,
-        )
+        .hover(&HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG }, range)
         .unwrap()
         .unwrap();
     // stub out ranges into minicore as they can change every now and then
-    hover
-        .info
-        .actions
-        .iter_mut()
-        .for_each(|action| match action {
-            super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
-                if data.nav.file_id == range.file_id {
-                    return;
-                }
-                data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
-                if let Some(range) = &mut data.nav.focus_range {
-                    *range = TextRange::empty(span::TextSize::new(!0));
-                }
-            }),
-            _ => (),
-        });
+    hover.info.actions.iter_mut().for_each(|action| match action {
+        super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
+            if data.nav.file_id == range.file_id {
+                return;
+            }
+            data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
+            if let Some(range) = &mut data.nav.focus_range {
+                *range = TextRange::empty(span::TextSize::new(!0));
+            }
+        }),
+        _ => (),
+    });
     expect.assert_debug_eq(&hover.info.actions);
 }
 
             ```
         "#]],
     );
-
     // Use literal `crate` in path
+
     check(
         r#"
 pub struct X;
             ```
         "#]],
     );
-
     // Check `super` in path
+
     check(
         r#"
 pub struct X;
             ```
         "#]],
     );
-
     // Hovering over the field in the definition
+
     check(
         r#"
 struct Foo { pub field_a$0: u32 }
             size = 12 (0xC), align = 4, largest padding = 0, no Drop
         "#]],
     );
-
     // No extra spaces within `{}` when there are no fields
+
     check_hover_fields_limit(
         5,
         r#"
     );
 }
 
-// Check that we don't rewrite links which we can't identify
 #[test]
 fn test_hover_unknown_target() {
     check(
 
 mod type_param_sized_bounds {
     use super::*;
-
     #[test]
     fn single_implicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn single_explicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn single_relaxed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_implicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_explicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_relaxed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn mixed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn mixed2() {
         check(
             false
         "#]],
     );
-
     // show hex for <10
+
     check(
         r#"
 /// This is a doc
     );
 }
 
-// FIXME(next-solver): this fails to normalize the const, probably due to the solver
-// refusing to give the impl because of the error type.
 #[test]
 fn hover_const_eval_in_generic_trait() {
     // Doesn't compile, but we shouldn't crash.
         "#]],
     );
 }
+
 #[test]
 fn hover_generic_assoc() {
     check(
     let (analysis, position) = fixture::position(r#"#![feature(intrinsics$0)]"#);
     analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
             ```
         "#]],
     );
-
     // Test case with tuple pattern and mutable parameters
+
     check(
         r#"fn test_2$0((mut x, y): (i32, i32)) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with a pattern in a reference type
+
     check(
         r#"fn test_3$0(&(a, b): &(i32, i32)) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with complex pattern (struct destructuring)
+
     check(
         r#"struct Point { x: i32, y: i32 } fn test_4$0(Point { x, y }: Point) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with a nested pattern
+
     check(
         r#"fn test_5$0(((a, b), c): ((i32, i32), i32)) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with an unused variable in the pattern
+
     check(
         r#"fn test_6$0((_, y): (i32, i64)) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with a complex pattern involving both tuple and struct
+
     check(
         r#"struct Foo { a: i32, b: i32 } fn test_7$0((x, Foo { a, b }): (i32, Foo)) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with Enum and Or pattern
+
     check(
         r#"enum MyEnum { A(i32), B(i32) } fn test_8$0((MyEnum::A(x) | MyEnum::B(x)): MyEnum) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with a pattern as a function parameter
+
     check(
         r#"struct Foo { a: i32, b: i32 } fn test_9$0(Foo { a, b }: Foo) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with a pattern as a function parameter with a different name
+
     check(
         r#"struct Foo { a: i32, b: i32 } fn test_10$0(Foo { a, b: b1 }: Foo) {}"#,
         expect![[r#"
             ```
         "#]],
     );
-
     // Test case with a pattern as a function parameter with annotations
+
     check(
         r#"struct Foo { a: i32, b: i32 } fn test_10$0(Foo { a, b: mut b }: Foo) {}"#,
         expect![[r#"
             Docs for B
         "#]],
     );
-
     // Nested.
+
     check(
         r#"
 /// Docs for C
             Docs for C
         "#]],
     );
-
     // Showing the docs for aliased struct instead of intermediate type.
+
     check(
         r#"
 /// Docs for C
             Docs for C
         "#]],
     );
-
     // No docs found.
+
     check(
         r#"
 struct C;
             size = 0, align = 1, no Drop
         "#]],
     );
-
     // Multiple nested crate.
+
     check(
         r#"
 //- /lib.rs crate:c