COMPARISON DIFF
============================================================

Original size: 210028 bytes
Chloro size:   209818 bytes
Rustfmt size:  210967 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use expect_test::{expect, Expect};
-use ide_db::{base_db::SourceDatabase, FileRange, MiniCore};
+use expect_test::{Expect, expect};
+use hir::setup_tracing;
+use ide_db::{FileRange, MiniCore, base_db::SourceDatabase};
 use syntax::TextRange;
 
 use crate::{
     fixture, HoverConfig, HoverDocFormat, MemoryLayoutHoverConfig, MemoryLayoutHoverRenderKind,
 };
 
-use hir::setup_tracing;
-
 const HOVER_BASE_CONFIG: HoverConfig<'_> = HoverConfig {
     links_in_hover: false,
     memory_layout: Some(MemoryLayoutHoverConfig {
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap();
-    assert!(
-        hover.is_none(),
-        "hover not expected but found: {:?}",
-        hover.unwrap()
-    );
+    assert!(hover.is_none(), "hover not expected but found: {:?}", hover.unwrap());
 }
 
 #[track_caller]
-fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+fn check(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    expect: Expect,
+) {
     let _tracing = setup_tracing();
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
-
     let content = analysis.db.file_text(position.file_id);
     let hovered_element = &content.text(&analysis.db)[hover.range];
-
     let actual = format!("*{hovered_element}*\n{}\n", hover.info.markup);
     expect.assert_eq(&actual)
 }
                 max_fields_count: fields_count.into(),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
-
     let content = analysis.db.file_text(position.file_id).text(&analysis.db);
     let hovered_element = &content[hover.range];
-
     let actual = format!("*{hovered_element}*\n{}\n", hover.info.markup);
     expect.assert_eq(&actual)
 }
                 max_enum_variants_count: variants_count.into(),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
-
     let content = analysis.db.file_text(position.file_id).text(&analysis.db);
     let hovered_element = &content[hover.range];
-
     let actual = format!("*{hovered_element}*\n{}\n", hover.info.markup);
     expect.assert_eq(&actual)
 }
                 max_trait_assoc_items_count: Some(count),
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
-
     let content = analysis.db.file_text(position.file_id).text(&analysis.db);
     let hovered_element = &content[hover.range];
-
     let actual = format!("*{hovered_element}*\n{}\n", hover.info.markup);
     expect.assert_eq(&actual)
 }
 
-fn check_hover_no_links(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+fn check_hover_no_links(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    expect: Expect,
+) {
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
             &HOVER_BASE_CONFIG,
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
-
     let content = analysis.db.file_text(position.file_id).text(&analysis.db);
     let hovered_element = &content[hover.range];
-
     let actual = format!("*{hovered_element}*\n{}\n", hover.info.markup);
     expect.assert_eq(&actual)
 }
 
-fn check_hover_no_memory_layout(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+fn check_hover_no_memory_layout(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    expect: Expect,
+) {
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
-            &HoverConfig {
-                memory_layout: None,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { memory_layout: None, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
-
     let content = analysis.db.file_text(position.file_id).text(&analysis.db);
     let hovered_element = &content[hover.range];
-
     let actual = format!("*{hovered_element}*\n{}\n", hover.info.markup);
     expect.assert_eq(&actual)
 }
 
-fn check_hover_no_markdown(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+fn check_hover_no_markdown(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    expect: Expect,
+) {
     let (analysis, position) = fixture::position(ra_fixture);
     let hover = analysis
         .hover(
                 format: HoverDocFormat::PlainText,
                 ..HOVER_BASE_CONFIG
             },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
-
     let content = analysis.db.file_text(position.file_id).text(&analysis.db);
     let hovered_element = &content[hover.range];
-
     let actual = format!("*{hovered_element}*\n{}\n", hover.info.markup);
     expect.assert_eq(&actual)
 }
 
-fn check_actions(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+fn check_actions(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    expect: Expect,
+) {
     let (analysis, file_id, position) = fixture::range_or_position(ra_fixture);
     let mut hover = analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id,
-                range: position.range_or_empty(),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id, range: position.range_or_empty() },
         )
         .unwrap()
         .unwrap();
     // stub out ranges into minicore as they can change every now and then
-    hover
-        .info
-        .actions
-        .iter_mut()
-        .for_each(|action| match action {
-            super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
-                if data.nav.file_id == file_id {
-                    return;
-                }
-                data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
-                if let Some(range) = &mut data.nav.focus_range {
-                    *range = TextRange::empty(span::TextSize::new(!0));
-                }
-            }),
-            _ => (),
-        });
+    hover.info.actions.iter_mut().for_each(|action| match action {
+        super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
+            if data.nav.file_id == file_id {
+                return;
+            }
+            data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
+            if let Some(range) = &mut data.nav.focus_range {
+                *range = TextRange::empty(span::TextSize::new(!0));
+            }
+        }),
+        _ => (),
+    });
     expect.assert_debug_eq(&hover.info.actions)
 }
 
-fn check_hover_range(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+fn check_hover_range(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    expect: Expect,
+) {
     let (analysis, range) = fixture::range(ra_fixture);
     let hover = analysis.hover(&HOVER_BASE_CONFIG, range).unwrap().unwrap();
     expect.assert_eq(hover.info.markup.as_str())
 }
 
-fn check_hover_range_actions(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+fn check_hover_range_actions(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    expect: Expect,
+) {
     let (analysis, range) = fixture::range(ra_fixture);
     let mut hover = analysis
-        .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            range,
-        )
+        .hover(&HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG }, range)
         .unwrap()
         .unwrap();
     // stub out ranges into minicore as they can change every now and then
-    hover
-        .info
-        .actions
-        .iter_mut()
-        .for_each(|action| match action {
-            super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
-                if data.nav.file_id == range.file_id {
-                    return;
-                }
-                data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
-                if let Some(range) = &mut data.nav.focus_range {
-                    *range = TextRange::empty(span::TextSize::new(!0));
-                }
-            }),
-            _ => (),
-        });
+    hover.info.actions.iter_mut().for_each(|action| match action {
+        super::HoverAction::GoToType(act) => act.iter_mut().for_each(|data| {
+            if data.nav.file_id == range.file_id {
+                return;
+            }
+            data.nav.full_range = TextRange::empty(span::TextSize::new(!0));
+            if let Some(range) = &mut data.nav.focus_range {
+                *range = TextRange::empty(span::TextSize::new(!0));
+            }
+        }),
+        _ => (),
+    });
     expect.assert_debug_eq(&hover.info.actions);
 }
 
             * `x` by immutable borrow
         "#]],
     );
-
     check(
         r#"
 //- minicore: copy
             This closure captures nothing
         "#]],
     );
-
     check(
         r#"
 //- minicore: copy
             ```
         "#]],
     );
-
     // Use literal `crate` in path
     check(
         r#"
             ```
         "#]],
     );
-
     // Check `super` in path
     check(
         r#"
             ```
         "#]],
     );
-
     // Hovering over the field in the definition
     check(
         r#"
             size = 12 (0xC), align = 4, largest padding = 0, no Drop
         "#]],
     );
-
     // No extra spaces within `{}` when there are no fields
     check_hover_fields_limit(
         5,
             ```
         "#]],
     );
-
     check(
         r#"static foo$0: u32 = 456;"#,
         expect![[r#"
             ```
         "#]],
     );
-
     check(
         r#"const FOO$0: i32 = -2147483648;"#,
         expect![[r#"
             ```
         "#]],
     );
-
     check(
         r#"
         const FOO: i32 = -2147483648;
             ```
         "#]],
     );
-
     check(
         r#"
 enum Option<T> { Some(T) }
             The None variant
         "#]],
     );
-
     check(
         r#"
 enum Option<T> {
             ```
         "#]],
     );
-
     check(
         r#"
 trait Foo<T> { type Bar<U>; }
     );
 }
 
-// Check that we don't rewrite links which we can't identify
 #[test]
 fn test_hover_unknown_target() {
     check(
             size = 16 (0x10), align = 8, largest padding = 3, niches = 254, no Drop
         "#]],
     );
-
     check(
         r#"#[repr(align(32))]
         struct $0Foo {
             size = 32 (0x20), align = 32 (0x20), largest padding = 19 (0x13), niches = 254, no Drop
         "#]],
     );
-
     check(
         r#"#[repr(C)]
         struct $0Foo {
             size = 24 (0x18), align = 8, tail padding = 4, niches = 254, no Drop
         "#]],
     );
-
     check(
         r#"struct $0Foo(i16, u128, u64)"#,
         expect![[r#"
             no Drop
         "#]],
     );
-
     check_hover_no_memory_layout(
         r#"
 //- minicore: copy
 #[test]
 fn test_hover_macro_generated_struct_fn_doc_comment() {
     cov_mark::check!(hover_macro_generated_struct_fn_doc_comment);
-
     check(
         r#"
 macro_rules! bar {
 #[test]
 fn test_hover_macro_generated_struct_fn_doc_attr() {
     cov_mark::check!(hover_macro_generated_struct_fn_doc_attr);
-
     check(
         r#"
 macro_rules! bar {
 
 mod type_param_sized_bounds {
     use super::*;
-
     #[test]
     fn single_implicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn single_explicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn single_relaxed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_implicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_explicit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn multiple_relaxed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn mixed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn mixed2() {
         check(
             true
         "#]],
     );
-
     check(
         r#"
 struct A {
             ```
         "#]],
     );
-
     check(
         r#"
 trait T {
             false
         "#]],
     );
-
     check(
         r#"
 trait T {
             false
         "#]],
     );
-
     check(
         r#"
 trait T {
             false
         "#]],
     );
-
     // show hex for <10
     check(
         r#"
     );
 }
 
-// FIXME(next-solver): this fails to normalize the const, probably due to the solver
-// refusing to give the impl because of the error type.
 #[test]
 fn hover_const_eval_in_generic_trait() {
     // Doesn't compile, but we shouldn't crash.
         "#]],
     );
 }
+
 #[test]
 fn hover_generic_assoc() {
     check(
     let (analysis, position) = fixture::position(r#"#![feature(intrinsics$0)]"#);
     analysis
         .hover(
-            &HoverConfig {
-                links_in_hover: true,
-                ..HOVER_BASE_CONFIG
-            },
-            FileRange {
-                file_id: position.file_id,
-                range: TextRange::empty(position.offset),
-            },
+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },
+            FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },
         )
         .unwrap()
         .unwrap();
             i32
             ```"#]],
     );
-
     check_hover_range(
         r#"
 fn f() { let expr = 1 $0+ 2 * $03 }
             i32
             ```"#]],
     );
-
     check_hover_range(
         r#"
 fn f() { let expr = 1 + $02 * 3$0 }
             [i32; 4]
             ```"#]],
     );
-
     check_hover_range(
         r#"
 fn f() { let expr = [1, 2, $03, 4]$0 }
             [i32; 4]
             ```"#]],
     );
-
     check_hover_range(
         r#"
 fn f() { let expr = [1, 2, $03$0, 4] }
             fn f<i32>(&[i32])
             ```"#]],
     );
-
     check_hover_range(
         r#"
 fn f<T>(a: &[T]) { }
 fn b()$0 { f(&[1, 2, 3, 4, 5]); }$0
 "#,
     );
-
     check_hover_range_no_results(
         r#"
 fn f<T>$0(a: &[T]) { }
 fn b() { f(&[1, 2, 3,$0 4, 5]); }
 "#,
     );
-
     check_hover_range_no_results(
         r#"
 fn $0f() { let expr = [1, 2, 3, 4]$0 }
             ()
             ```"#]],
     );
-
     check_hover_range(
         r#"
 fn f() { let expr$0 = $0[1, 2, 3, 4] }
                 i32
                 ```"#]],
     );
-
     check_hover_range(
         r#"
 fn foo() {
             Doc inner comment for [`Foo`](https://docs.rs/ra_test_fixture/*/ra_test_fixture/fn.Foo.html)
         "#]],
     );
-
     check(
         r#"
 /// outer comment for [`Foo`]
             Doc inner comment for [`Foo`](https://docs.rs/ra_test_fixture/*/ra_test_fixture/fn.Foo.html)
         "#]],
     );
-
     check(
         r#"
 /// outer comment for [`Foo$0`]
 #[test]
 fn hover_dollar_crate() {
     // $crate should be resolved to the right crate name.
-
     check(
         r#"
 //- /main.rs crate:main deps:dep
             ```
         "#]],
     );
-
     check_assoc_count(
         1,
         r#"
             ```
         "#]],
     );
-
     check_assoc_count(
         0,
         r#"
             ```
         "#]],
     );
-
     check_assoc_count(
         2,
         r#"
             ```
         "#]],
     );
-
     check_assoc_count(
         3,
         r#"
             ```
         "#]],
     );
-
     check_assoc_count(
         4,
         r#"
             ```
         "#]],
     );
-
     check(
         r#"
 struct Struct {a: u32, b: u32, c: u8, d: u16};
             ```
         "#]],
     );
-
     check(
         r#"
 struct S;
             ```
         "#]],
     );
-
     check(
         r#"
 struct S;
             ```
         "#]],
     );
-
     check(
         r#"
 struct S;
             ```
         "#]],
     );
-
     check(
         r#"
 struct S;
             ```
         "#]],
     );
-
     check(
         r#"
 //- /lib1.rs crate:with_edition_2018 edition:2018
             ```
         "#]],
     );
-
     check(
         r#"
 //- /lib1.rs crate:escaping_needlessly edition:2015
             ```
         "#]],
     );
-
     // Test case with tuple pattern and mutable parameters
     check(
         r#"fn test_2$0((mut x, y): (i32, i32)) {}"#,
             ```
         "#]],
     );
-
     // Test case with a pattern in a reference type
     check(
         r#"fn test_3$0(&(a, b): &(i32, i32)) {}"#,
             ```
         "#]],
     );
-
     // Test case with complex pattern (struct destructuring)
     check(
         r#"struct Point { x: i32, y: i32 } fn test_4$0(Point { x, y }: Point) {}"#,
             ```
         "#]],
     );
-
     // Test case with a nested pattern
     check(
         r#"fn test_5$0(((a, b), c): ((i32, i32), i32)) {}"#,
             ```
         "#]],
     );
-
     // Test case with an unused variable in the pattern
     check(
         r#"fn test_6$0((_, y): (i32, i64)) {}"#,
             ```
         "#]],
     );
-
     // Test case with a complex pattern involving both tuple and struct
     check(
         r#"struct Foo { a: i32, b: i32 } fn test_7$0((x, Foo { a, b }): (i32, Foo)) {}"#,
             ```
         "#]],
     );
-
     // Test case with Enum and Or pattern
     check(
         r#"enum MyEnum { A(i32), B(i32) } fn test_8$0((MyEnum::A(x) | MyEnum::B(x)): MyEnum) {}"#,
             ```
         "#]],
     );
-
     // Test case with a pattern as a function parameter
     check(
         r#"struct Foo { a: i32, b: i32 } fn test_9$0(Foo { a, b }: Foo) {}"#,
             ```
         "#]],
     );
-
     // Test case with a pattern as a function parameter with a different name
     check(
         r#"struct Foo { a: i32, b: i32 } fn test_10$0(Foo { a, b: b1 }: Foo) {}"#,
             ```
         "#]],
     );
-
     // Test case with a pattern as a function parameter with annotations
     check(
         r#"struct Foo { a: i32, b: i32 } fn test_10$0(Foo { a, b: mut b }: Foo) {}"#,
             Docs for B
         "#]],
     );
-
     // Nested.
     check(
         r#"
             Docs for C
         "#]],
     );
-
     // Showing the docs for aliased struct instead of intermediate type.
     check(
         r#"
             Docs for C
         "#]],
     );
-
     // No docs found.
     check(
         r#"
             size = 0, align = 1, no Drop
         "#]],
     );
-
     // Multiple nested crate.
     check(
         r#"
             size = 0, align = 1, no Drop
         "#]],
     );
-
     check(
         r#"
 pub struct Global;
             size = 0, align = 1, no Drop
         "#]],
     );
-
     check(
         r#"
 //- minicore: eq