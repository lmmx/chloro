COMPARISON DIFF
============================================================

Original size: 28332 bytes
Chloro size:   28291 bytes
Rustfmt size:  28759 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Implementation of "type" inlay hints:
 //! ```no_run
 //! fn f(a: i32, b: i32) -> i32 { a + b }
 //! let _x /* i32 */= f(4, 4);
 //! ```
+
 use hir::{DisplayTarget, Semantics};
 use ide_db::{famous_defs::FamousDefs, RootDatabase};
-
 use itertools::Itertools;
 use syntax::{
     ast::{self, AstNode, HasGenericArgs, HasName},
         }
     }?;
 
-    let expr = sema
-        .descend_node_into_attributes(expr.clone())
-        .pop()
-        .unwrap_or(expr);
+    let expr = sema.descend_node_into_attributes(expr.clone()).pop().unwrap_or(expr);
     // unwrap postfix expressions
     let expr = match expr {
         ast::Expr::TryExpr(it) => it.expr(),
     };
     let path = expr.path()?;
 
-    let callable = sema
-        .type_of_expr(&ast::Expr::PathExpr(expr))?
-        .original
-        .as_callable(sema.db);
+    let callable = sema.type_of_expr(&ast::Expr::PathExpr(expr))?.original.as_callable(sema.db);
     let callable_kind = callable.map(|it| it.kind());
     let qual_seg = match callable_kind {
         Some(hir::CallableKind::Function(_) | hir::CallableKind::TupleEnumVariant(_)) => {
                 None => name_ref.to_string(),
             }
         }
-        ast::PathSegmentKind::Type {
-            type_ref: Some(ty),
-            trait_ref: None,
-        } => ty.to_string(),
+        ast::PathSegmentKind::Type { type_ref: Some(ty), trait_ref: None } => ty.to_string(),
         _ => return None,
     };
     (ctor_name == ty_name).then_some(())
 #[cfg(test)]
 mod tests {
     // This module also contains tests for super::closure_ret
-
     use expect_test::expect;
     use hir::ClosureStyle;
     use syntax::{TextRange, TextSize};
     use test_utils::extract_annotations;
-
     use crate::{fixture, inlay_hints::InlayHintsConfig, ClosureReturnTypeHints};
-
     use crate::inlay_hints::tests::{
         check, check_edit, check_no_edit, check_with_config, DISABLED_CONFIG, TEST_CONFIG,
     };
-
     #[track_caller]
     fn check_types(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
-        check_with_config(
-            InlayHintsConfig {
-                type_hints: true,
-                ..DISABLED_CONFIG
-            },
-            ra_fixture,
-        );
+        check_with_config(InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG }, ra_fixture);
     }
-
     #[test]
     fn type_hints_only() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn type_hints_bindings_after_at() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn default_generic_types_should_not_be_displayed() {
         check(
 }"#,
         );
     }
-
     #[test]
     fn shorten_iterators_in_associated_params() {
         check_types(
 "#,
         );
     }
-
     #[test]
     fn iterator_hint_regression_issue_12674() {
         // Ensure we don't crash while solving the projection type of iterators.
         );
         analysis
             .inlay_hints(
-                &InlayHintsConfig {
-                    chaining_hints: true,
-                    ..DISABLED_CONFIG
-                },
+                &InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },
                 file_id,
                 None,
             )
             .unwrap();
     }
-
     #[test]
     fn infer_call_method_return_associated_types_with_generic() {
         check_types(
             "#,
         );
     }
-
     #[test]
     fn lt_hints() {
         check_types(
 "#,
         );
     }
-
     #[test]
     fn fn_hints() {
         check_types(
 "#,
         )
     }
-
     #[test]
     fn check_hint_range_limit() {
         let fixture = r#"
         let expected = extract_annotations(&analysis.file_text(file_id).unwrap());
         let inlay_hints = analysis
             .inlay_hints(
-                &InlayHintsConfig {
-                    type_hints: true,
-                    ..DISABLED_CONFIG
-                },
+                &InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },
                 file_id,
                 Some(TextRange::new(TextSize::from(491), TextSize::from(640))),
             )
             .unwrap();
-        let actual = inlay_hints
-            .into_iter()
-            .map(|it| (it.range, it.label.to_string()))
-            .collect::<Vec<_>>();
-        assert_eq!(
-            expected, actual,
-            "\nExpected:\n{expected:#?}\n\nActual:\n{actual:#?}"
-        );
+        let actual =
+            inlay_hints.into_iter().map(|it| (it.range, it.label.to_string())).collect::<Vec<_>>();
+        assert_eq!(expected, actual, "\nExpected:\n{expected:#?}\n\nActual:\n{actual:#?}");
     }
-
     #[test]
     fn fn_hints_ptr_rpit_fn_parentheses() {
         check_types(
 "#,
         )
     }
-
     #[test]
     fn unit_structs_have_no_type_hints() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn const_pats_have_no_type_hints() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn let_statement() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn if_expr() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn while_expr() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn match_arm_list() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn complete_for_hint() {
         check_types(
 "#,
         );
     }
-
     #[test]
     fn multi_dyn_trait_bounds() {
         check_types(
 "#,
         );
     }
-
     #[test]
     fn shorten_iterator_hints() {
         check_types(
 "#,
         );
     }
-
     #[test]
     fn skip_constructor_and_enum_type_hints() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn shows_constructor_type_hints_when_enabled() {
         check_types(
 "#,
         );
     }
-
     #[test]
     fn closure_style() {
         check_with_config(
-            InlayHintsConfig {
-                type_hints: true,
-                ..DISABLED_CONFIG
-            },
+            InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },
             r#"
 //- minicore: fn
 fn main() {
             "#,
         );
     }
-
     #[test]
     fn skip_closure_type_hints() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn skip_closure_parameter_hints() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hint_truncation() {
         check_with_config(
-            InlayHintsConfig {
-                max_length: Some(8),
-                ..TEST_CONFIG
-            },
+            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },
             r#"
 struct Smol<T>(T);
 
 }"#,
         );
     }
-
     #[test]
     fn edit_for_let_stmt() {
         check_edit(
             "#]],
         );
     }
-
     #[test]
     fn edit_for_closure_param() {
         check_edit(
             "#]],
         );
     }
-
     #[test]
     fn edit_for_closure_ret() {
         check_edit(
             "#]],
         );
     }
-
     #[test]
     fn edit_prefixes_paths() {
         check_edit(
             "#]],
         );
     }
-
     #[test]
     fn no_edit_for_top_pat_where_type_annotation_is_invalid() {
         check_no_edit(
 "#,
         )
     }
-
     #[test]
     fn no_edit_for_opaque_type() {
         check_no_edit(
 "#,
         );
     }
-
     #[test]
     fn no_edit_for_closure_return_without_body_block() {
         let config = InlayHintsConfig {
             "#]],
         );
     }
-
     #[test]
     fn type_hints_async_block() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn type_hints_async_block_with_tail_return_exp() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn works_in_included_file() {
         check_types(
 }"#,
         );
     }
-
     #[test]
     fn collapses_nested_impl_projections() {
         check_types(
 "#,
         );
     }
-
     #[test]
     fn regression_19007() {
         check_types(