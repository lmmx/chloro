COMPARISON DIFF
============================================================

Original size: 34201 bytes
Chloro size:   34292 bytes
Rustfmt size:  34820 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         (T![!], MACRO_CALL) => {
             if operator_parent
                 .and_then(ast::MacroCall::cast)
-                .is_some_and(|macro_call| sema.is_unsafe_macro_call(&macro_call))
-            {
+                .is_some_and(|macro_call| sema.is_unsafe_macro_call(&macro_call)) {
                 Highlight::from(HlPunct::MacroBang) | HlMod::Unsafe
             } else {
                 HlPunct::MacroBang.into()
             }
         }
         (T![-], PREFIX_EXPR) => {
-            let prefix_expr = operator_parent
-                .and_then(ast::PrefixExpr::cast)
-                .and_then(|e| e.expr());
+            let prefix_expr =
+                operator_parent.and_then(ast::PrefixExpr::cast).and_then(|e| e.expr());
             match prefix_expr {
                 Some(ast::Expr::Literal(_)) => HlTag::NumericLiteral,
                 _ => HlTag::Operator(HlOperator::Other),
             HlOperator::Comparison.into()
         }
         (_, ATTR) => HlTag::AttributeBracket.into(),
-        (T![>], _)
-            if operator_parent
+        (T![>], _) if operator_parent
                 .as_ref()
                 .and_then(SyntaxNode::parent)
-                .is_some_and(|it| it.kind() == MACRO_RULES) =>
-        {
+                .is_some_and(|it| it.kind() == MACRO_RULES) => {
             HlOperator::Other.into()
         }
         (kind, _) => match kind {
                 let is_unsafe = is_unsafe_macro
                     || operator_parent
                         .and_then(|it| {
-                            if ast::ArgList::can_cast(it.kind()) {
-                                it.parent()
-                            } else {
-                                Some(it)
-                            }
+                            if ast::ArgList::can_cast(it.kind()) { it.parent() } else { Some(it) }
                         })
                         .and_then(|it| AstPtr::try_from_raw(SyntaxNodePtr::new(&it)))
                         .is_some_and(is_unsafe_node);
         NameRefClass::FieldShorthand { field_ref, .. } => {
             highlight_def(sema, krate, field_ref.into(), edition, true)
         }
-        NameRefClass::ExternCrateShorthand {
-            decl,
-            krate: resolved_krate,
-        } => {
+        NameRefClass::ExternCrateShorthand { decl, krate: resolved_krate } => {
             let mut h = HlTag::Symbol(SymbolKind::Module).into();
 
             if krate.as_ref().is_some_and(|krate| resolved_krate != *krate) {
         Some(NameClass::ConstReference(def)) => highlight_def(sema, krate, def, edition, true),
         Some(NameClass::PatFieldShorthand { .. }) => {
             let mut h = HlTag::Symbol(SymbolKind::Field).into();
-            let is_unsafe = name
-                .syntax()
-                .parent()
-                .and_then(ast::IdentPat::cast)
-                .is_some_and(|it| {
+            let is_unsafe =
+                name.syntax().parent().and_then(ast::IdentPat::cast).is_some_and(|it| {
                     is_unsafe_node(AstPtr::new(&ast::Pat::IdentPat(it)).wrap_right())
                 });
             if is_unsafe {
     name_ref: &ast::NameRef,
     is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
 ) -> Option<Highlight> {
-    let mc = name_ref
-        .syntax()
-        .parent()
-        .and_then(ast::MethodCallExpr::cast)?;
+    let mc = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;
     highlight_method_call(sema, krate, &mc, is_unsafe_node)
 }
 
         RECORD_EXPR_FIELD | RECORD_PAT_FIELD => HlTag::Symbol(SymbolKind::Field).into(),
         PATH_SEGMENT => {
             let name_based_fallback = || {
-                if name
-                    .text()
-                    .chars()
-                    .next()
-                    .unwrap_or_default()
-                    .is_uppercase()
-                {
+                if name.text().chars().next().unwrap_or_default().is_uppercase() {
                     SymbolKind::Struct.into()
                 } else {
                     SymbolKind::Module.into()
 
             match parent.kind() {
                 CALL_EXPR => SymbolKind::Function.into(),
-                _ => if name
-                    .text()
-                    .chars()
-                    .next()
-                    .unwrap_or_default()
-                    .is_uppercase()
-                {
+                _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {
                     SymbolKind::Struct
                 } else {
                     SymbolKind::Const
 
 fn is_consumed_lvalue(node: &SyntaxNode, local: &hir::Local, db: &RootDatabase) -> bool {
     // When lvalues are passed as arguments and they're not Copy, then mark them as Consuming.
-    parents_match(
-        node.clone().into(),
-        &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST],
-    ) && !local.ty(db).is_copy(db)
+    parents_match(node.clone().into(), &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST])
+        && !local.ty(db).is_copy(db)
 }
 
 /// Returns true if the parent nodes of `node` all match the `SyntaxKind`s in `kinds` exactly.
-fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[SyntaxKind]) -> bool {
+fn parents_match(
+    mut node: NodeOrToken<SyntaxNode, SyntaxToken>,
+    mut kinds: &[SyntaxKind],
+) -> bool {
     while let (Some(parent), [kind, rest @ ..]) = (node.parent(), kinds) {
         if parent.kind() != *kind {
             return false;