COMPARISON DIFF
============================================================

Original size: 34201 bytes
Chloro size:   34102 bytes
Rustfmt size:  34201 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir::{AsAssocItem, HasVisibility, Semantics};
 use ide_db::{
-    FxHashMap, RootDatabase, SymbolKind,
     defs::{Definition, IdentClass, NameClass, NameRefClass},
     syntax_helpers::node_ext::walk_pat,
+    FxHashMap, RootDatabase, SymbolKind,
 };
 use span::Edition;
 use stdx::hash_once;
 use syntax::{
-    AstNode, AstPtr, AstToken, NodeOrToken,
+    ast, match_ast, AstNode, AstPtr, AstToken, NodeOrToken,
     SyntaxKind::{self, *},
-    SyntaxNode, SyntaxNodePtr, SyntaxToken, T, ast, match_ast,
+    SyntaxNode, SyntaxNodePtr, SyntaxToken, T,
 };
 
 use crate::{
-    Highlight, HlMod, HlTag,
     syntax_highlighting::tags::{HlOperator, HlPunct},
+    Highlight, HlMod, HlTag,
 };
 
 pub(super) fn token(
         },
         (T![::] | T![->] | T![=>] | T![=] | T![@] | T![.], _) => HlOperator::Other.into(),
         (T![!], MACRO_CALL) => {
-            if operator_parent
-                .and_then(ast::MacroCall::cast)
-                .is_some_and(|macro_call| sema.is_unsafe_macro_call(&macro_call))
-            {
+            if operator_parent.and_then(ast::MacroCall::cast).is_some_and(
+                |macro_call| sema.is_unsafe_macro_call(&macro_call),
+            ) {
                 Highlight::from(HlPunct::MacroBang) | HlMod::Unsafe
             } else {
                 HlPunct::MacroBang.into()
             let ptr = operator_parent
                 .as_ref()
                 .and_then(|it| AstPtr::try_from_raw(SyntaxNodePtr::new(it)));
-            if ptr.is_some_and(is_unsafe_node) { h | HlMod::Unsafe } else { h }
+            if ptr.is_some_and(is_unsafe_node) {
+                h | HlMod::Unsafe
+            } else {
+                h
+            }
         }
         (T![-], PREFIX_EXPR) => {
             let prefix_expr =
             match prefix_expr {
                 Some(ast::Expr::Literal(_)) => HlTag::NumericLiteral,
                 _ => HlTag::Operator(HlOperator::Other),
-            }
-            .into()
+            }.into(
+            )
         }
         (T![+] | T![-] | T![*] | T![/] | T![%], BIN_EXPR) => HlOperator::Arithmetic.into(),
         (T![+=] | T![-=] | T![*=] | T![/=] | T![%=], BIN_EXPR) => {
             HlOperator::Comparison.into()
         }
         (_, ATTR) => HlTag::AttributeBracket.into(),
-        (T![>], _)
-            if operator_parent
-                .as_ref()
-                .and_then(SyntaxNode::parent)
-                .is_some_and(|it| it.kind() == MACRO_RULES) =>
-        {
+        (T![>], _) if operator_parent.as_ref().and_then(SyntaxNode::parent).is_some_and(
+            |it| it.kind() == MACRO_RULES,
+        ) => {
             HlOperator::Other.into()
         }
         (kind, _) => match kind {
                         })
                         .and_then(|it| AstPtr::try_from_raw(SyntaxNodePtr::new(&it)))
                         .is_some_and(is_unsafe_node);
-
                 if is_unsafe {
                     return Highlight::from(HlPunct::Parenthesis) | HlMod::Unsafe;
                 } else {
                 }
             }
             T![<] | T![>] => HlPunct::Angle,
-            // Early return as otherwise we'd highlight these in
-            // asm expressions
             T![,] => return HlPunct::Comma.into(),
             T![:] => HlPunct::Colon,
             T![;] => HlPunct::Semi,
             T![.] => HlPunct::Dot,
             _ => HlPunct::Other,
-        }
-        .into(),
+        }.into(
+        ),
     }
 }
 
         T![unsafe] => h | HlMod::Unsafe,
         T![const] => h | HlMod::Const,
         T![true] | T![false] => HlTag::BoolLiteral.into(),
-        // crate is handled just as a token if it's in an `extern crate`
         T![crate] if parent_matches::<ast::ExternCrate>(&token) => h,
         _ => h,
     }
 
     match parent.kind() {
         EXTERN_CRATE => HlTag::Symbol(SymbolKind::Module) | HlMod::CrateRoot,
-        METHOD_CALL_EXPR => ast::MethodCallExpr::cast(parent)
-            .and_then(|it| highlight_method_call(sema, krate, &it, is_unsafe_node))
-            .unwrap_or_else(|| SymbolKind::Method.into()),
+        METHOD_CALL_EXPR => ast::MethodCallExpr::cast(parent).and_then(
+            |it| highlight_method_call(sema, krate, &it, is_unsafe_node),
+        ).unwrap_or_else(
+            || SymbolKind::Method.into(),
+        ),
         FIELD_EXPR => {
             let h = HlTag::Symbol(SymbolKind::Field);
             let is_unsafe = ast::Expr::cast(parent)
                 .is_some_and(|it| is_unsafe_node(AstPtr::new(&it).wrap_left()));
-            if is_unsafe { h | HlMod::Unsafe } else { h.into() }
+            if is_unsafe {
+                h | HlMod::Unsafe
+            } else {
+                h.into()
+            }
         }
         RECORD_EXPR_FIELD | RECORD_PAT_FIELD => HlTag::Symbol(SymbolKind::Field).into(),
         PATH_SEGMENT => {
                 Some(it) => it,
                 None => return default.into(),
             };
-
             match parent.kind() {
                 CALL_EXPR => SymbolKind::Function.into(),
                 _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {
                     SymbolKind::Struct
                 } else {
                     SymbolKind::Const
-                }
-                .into(),
+                }.into(
+                ),
             }
         }
         ASSOC_TYPE_ARG => SymbolKind::TypeAlias.into(),
 
 fn is_consumed_lvalue(node: &SyntaxNode, local: &hir::Local, db: &RootDatabase) -> bool {
     // When lvalues are passed as arguments and they're not Copy, then mark them as Consuming.
-    parents_match(node.clone().into(), &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST])
-        && !local.ty(db).is_copy(db)
+    parents_match(node.clone().into(), &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST]) && !local.ty(db).is_copy(db)
 }
 
 /// Returns true if the parent nodes of `node` all match the `SyntaxKind`s in `kinds` exactly.
-fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[SyntaxKind]) -> bool {
+fn parents_match(
+    mut node: NodeOrToken<SyntaxNode, SyntaxToken>,
+    mut kinds: &[SyntaxKind],
+) -> bool {
     while let (Some(parent), [kind, rest @ ..]) = (node.parent(), kinds) {
         if parent.kind() != *kind {
             return false;