COMPARISON DIFF
============================================================

Original size: 34201 bytes
Chloro size:   34230 bytes
Rustfmt size:  34201 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir::{AsAssocItem, HasVisibility, Semantics};
 use ide_db::{
-    FxHashMap, RootDatabase, SymbolKind,
     defs::{Definition, IdentClass, NameClass, NameRefClass},
     syntax_helpers::node_ext::walk_pat,
+    FxHashMap, RootDatabase, SymbolKind,
 };
 use span::Edition;
 use stdx::hash_once;
 use syntax::{
-    AstNode, AstPtr, AstToken, NodeOrToken,
+    ast, match_ast, AstNode, AstPtr, AstToken, NodeOrToken,
     SyntaxKind::{self, *},
-    SyntaxNode, SyntaxNodePtr, SyntaxToken, T, ast, match_ast,
+    SyntaxNode, SyntaxNodePtr, SyntaxToken, T,
 };
 
 use crate::{
             None => h.into(),
         });
     }
-
     let h = match token.kind() {
         STRING | BYTE_STRING | C_STRING => HlTag::StringLiteral.into(),
         INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),
 ) -> Highlight {
     let operator_parent = token.parent();
     let parent_kind = operator_parent.as_ref().map_or(EOF, SyntaxNode::kind);
-
     match (kind, parent_kind) {
         (T![?], TRY_EXPR) => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,
         (T![&], BIN_EXPR) => HlOperator::Bitwise.into(),
     }
 }
 
-fn keyword(token: SyntaxToken, kind: SyntaxKind) -> Highlight {
+fn keyword(
+    token: SyntaxToken,
+    kind: SyntaxKind,
+) -> Highlight {
     let h = Highlight::new(HlTag::Keyword);
     match kind {
         T![await] => h | HlMod::Async | HlMod::ControlFlow,
     if let Some(res) = highlight_method_call_by_name_ref(sema, krate, &name_ref, is_unsafe_node) {
         return res;
     }
-
     let name_class = match NameRefClass::classify(sema, &name_ref) {
         Some(name_kind) => name_kind,
         None if syntactic_name_ref_highlighting => {
             h
         }
     };
-
     h.tag = match name_ref.token_kind() {
         T![Self] => HlTag::Symbol(SymbolKind::SelfType),
         T![self] => HlTag::Symbol(SymbolKind::SelfParam),
     }
 }
 
-fn calc_binding_hash(name: &hir::Name, shadow_count: u32) -> u64 {
+fn calc_binding_hash(
+    name: &hir::Name,
+    shadow_count: u32,
+) -> u64 {
     hash_once::<ide_db::FxHasher>((name.as_str(), shadow_count))
 }
 
         }
         Definition::InlineAsmOperand(_) => Highlight::new(HlTag::Symbol(SymbolKind::Local)),
     };
-
     let def_crate = def.krate(db);
     let is_from_other_crate = def_crate != krate;
     let is_from_builtin_crate = def_crate.is_some_and(|def_crate| def_crate.is_builtin(db));
         false if def.visibility(db) == Some(hir::Visibility::Public) => h |= HlMod::Public,
         _ => (),
     }
-
     if is_from_builtin_crate {
         h |= HlMod::DefaultLibrary;
     }
-
     h
 }
 
     is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
 ) -> Option<Highlight> {
     let func = sema.resolve_method_call(method_call)?;
-
     let mut h = SymbolKind::Method.into();
-
     let is_unsafe = is_unsafe_node(AstPtr::new(method_call).upcast::<ast::Expr>().wrap_left());
     if is_unsafe {
         h |= HlMod::Unsafe;
     {
         h |= HlMod::Trait;
     }
-
     let def_crate = func.module(sema.db).krate();
     let is_from_other_crate = krate.as_ref().map_or(false, |krate| def_crate != *krate);
     let is_from_builtin_crate = def_crate.is_builtin(sema.db);
     let is_public = func.visibility(sema.db) == hir::Visibility::Public;
-
     if is_from_other_crate {
         h |= HlMod::Library;
     } else if is_public {
         h |= HlMod::Public;
     }
-
     if is_from_builtin_crate {
         h |= HlMod::DefaultLibrary;
     }
-
     if let Some(self_param) = func.self_param(sema.db) {
         match self_param.access(sema.db) {
             hir::Access::Shared => h |= HlMod::Reference,
 
 fn highlight_name_by_syntax(name: ast::Name) -> Highlight {
     let default = HlTag::UnresolvedReference;
-
     let parent = match name.syntax().parent() {
         Some(it) => it,
         _ => return default.into(),
     };
-
     let tag = match parent.kind() {
         STRUCT => SymbolKind::Struct,
         ENUM => SymbolKind::Enum,
         ASM_OPERAND_NAMED => SymbolKind::Local,
         _ => return default.into(),
     };
-
     tag.into()
 }
 
     is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
 ) -> Highlight {
     let default = HlTag::UnresolvedReference;
-
     let parent = match name.syntax().parent() {
         Some(it) => it,
         _ => return default.into(),
     };
-
     match parent.kind() {
         EXTERN_CRATE => HlTag::Symbol(SymbolKind::Module) | HlMod::CrateRoot,
         METHOD_CALL_EXPR => ast::MethodCallExpr::cast(parent)
     }
 }
 
-fn is_consumed_lvalue(node: &SyntaxNode, local: &hir::Local, db: &RootDatabase) -> bool {
+fn is_consumed_lvalue(
+    node: &SyntaxNode,
+    local: &hir::Local,
+    db: &RootDatabase,
+) -> bool {
     // When lvalues are passed as arguments and they're not Copy, then mark them as Consuming.
     parents_match(node.clone().into(), &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST])
         && !local.ty(db).is_copy(db)
 }
 
 /// Returns true if the parent nodes of `node` all match the `SyntaxKind`s in `kinds` exactly.
-fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[SyntaxKind]) -> bool {
+fn parents_match(
+    mut node: NodeOrToken<SyntaxNode, SyntaxToken>,
+    mut kinds: &[SyntaxKind],
+) -> bool {
     while let (Some(parent), [kind, rest @ ..]) = (node.parent(), kinds) {
         if parent.kind() != *kind {
             return false;
         node = parent.into();
         kinds = rest;
     }
-
     // Only true if we matched all expected kinds
     kinds.is_empty()
 }