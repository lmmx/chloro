COMPARISON DIFF
============================================================

Original size: 12984 bytes
Chloro size:   11657 bytes
Rustfmt size:  13116 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Handles the `Enter` key press. At the momently, this only continues
 //! comments, but should handle indent some time in the future as well.
 
 use ide_db::base_db::RootQueryDb;
+use ide_db::text_edit::TextEdit;
 use ide_db::{FilePosition, RootDatabase};
 use syntax::{
     algo::find_node_at_offset,
-    ast::{self, edit::IndentLevel, AstToken},
+    ast::{self, AstToken, edit::IndentLevel},
     AstNode, SmolStr, SourceFile,
     SyntaxKind::*,
     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset,
 };
 
-use ide_db::text_edit::TextEdit;
-
-// Feature: On Enter
-//
-// rust-analyzer can override <kbd>Enter</kbd> key to make it smarter:
-//
-// - <kbd>Enter</kbd> inside triple-slash comments automatically inserts `///`
-// - <kbd>Enter</kbd> in the middle or after a trailing space in `//` inserts `//`
-// - <kbd>Enter</kbd> inside `//!` doc comments automatically inserts `//!`
-// - <kbd>Enter</kbd> after `{` indents contents and closing `}` of single-line block
-//
-// This action needs to be assigned to shortcut explicitly.
-//
-// Note that, depending on the other installed extensions, this feature can visibly slow down typing.
-// Similarly, if rust-analyzer crashes or stops responding, `Enter` might not work.
-// In that case, you can still press `Shift-Enter` to insert a newline.
-//
-// #### VS Code
-//
-// Add the following to `keybindings.json`:
-// ```json
-// {
-//   "key": "Enter",
-//   "command": "rust-analyzer.onEnter",
-//   "when": "editorTextFocus && !suggestWidgetVisible && editorLangId == rust"
-// }
-// ````
-//
-// When using the Vim plugin:
-// ```json
-// {
-//   "key": "Enter",
-//   "command": "rust-analyzer.onEnter",
-//   "when": "editorTextFocus && !suggestWidgetVisible && editorLangId == rust && vim.mode == 'Insert'"
-// }
-// ````
-//
-// ![On Enter](https://user-images.githubusercontent.com/48062697/113065578-04c21800-91b1-11eb-82b8-22b8c481e645.gif)
-pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<TextEdit> {
+pub(crate) fn on_enter(
+    db: &RootDatabase,
+    position: FilePosition,
+) -> Option<TextEdit> {
     let editioned_file_id_wrapper =
         ide_db::base_db::EditionedFileId::current_edition(db, position.file_id);
     let parse = db.parse(editioned_file_id_wrapper);
     let file = parse.tree();
-    let token = file
-        .syntax()
-        .token_at_offset(position.offset)
-        .left_biased()?;
-
+    let token = file.syntax().token_at_offset(position.offset).left_biased()?;
     if let Some(comment) = ast::Comment::cast(token.clone()) {
         return on_enter_in_comment(&comment, &file, position.offset);
     }
-
     if token.kind() == L_CURLY {
         // Typing enter after the `{` of a block expression, where the `}` is on the same line
         if let Some(edit) = find_node_at_offset(file.syntax(), position.offset - TextSize::of('{'))
             return Some(edit);
         }
     }
-
     None
 }
 
     if comment.kind().shape.is_block() {
         return None;
     }
-
     let prefix = comment.prefix();
     let comment_range = comment.syntax().text_range();
     if offset < comment_range.start() + TextSize::of(prefix) {
         return None;
     }
-
     let mut remove_trailing_whitespace = false;
     // Continuing single-line non-doc comments (like this one :) ) is annoying
     if prefix == "//" && comment_range.end() == offset {
             return None;
         }
     }
-
     let indent = node_indent(file, comment.syntax())?;
     let inserted = format!("\n{indent}{prefix} $0");
     let delete = if remove_trailing_whitespace {
     Some(edit)
 }
 
-fn on_enter_in_block(block: ast::BlockExpr, position: FilePosition) -> Option<TextEdit> {
+fn on_enter_in_block(
+    block: ast::BlockExpr,
+    position: FilePosition,
+) -> Option<TextEdit> {
     let contents = block_contents(&block)?;
-
     if block.syntax().text().contains_char('\n') {
         return None;
     }
-
     let indent = IndentLevel::from_node(block.syntax());
     let mut edit = TextEdit::insert(position.offset, format!("\n{}$0", indent + 1));
-    edit.union(TextEdit::insert(
-        contents.text_range().end(),
-        format!("\n{indent}"),
-    ))
-    .ok()?;
+    edit.union(TextEdit::insert(contents.text_range().end(), format!("\n{indent}"))).ok()?;
     Some(edit)
 }
 
-fn on_enter_in_use_tree_list(list: ast::UseTreeList, position: FilePosition) -> Option<TextEdit> {
+fn on_enter_in_use_tree_list(
+    list: ast::UseTreeList,
+    position: FilePosition,
+) -> Option<TextEdit> {
     if list.syntax().text().contains_char('\n') {
         return None;
     }
-
     let indent = IndentLevel::from_node(list.syntax());
     let mut edit = TextEdit::insert(position.offset, format!("\n{}$0", indent + 1));
-    edit.union(TextEdit::insert(
-        list.r_curly_token()?.text_range().start(),
-        format!("\n{indent}"),
-    ))
-    .ok()?;
+    edit.union(TextEdit::insert(list.r_curly_token()?.text_range().start(), format!("\n{indent}")))
+        .ok()?;
     Some(edit)
 }
 
 fn block_contents(block: &ast::BlockExpr) -> Option<SyntaxNode> {
     let mut node = block.tail_expr().map(|e| e.syntax().clone());
-
     for stmt in block.statements() {
         if node.is_some() {
             // More than 1 node in the block
 
         node = Some(stmt.syntax().clone());
     }
-
     node
 }
 
 fn followed_by_comment(comment: &ast::Comment) -> bool {
-    let ws = match comment
-        .syntax()
-        .next_token()
-        .and_then(ast::Whitespace::cast)
-    {
+    let ws = match comment.syntax().next_token().and_then(ast::Whitespace::cast) {
         Some(it) => it,
         None => return false,
     };
     if ws.spans_multiple_lines() {
         return false;
     }
-    ws.syntax()
-        .next_token()
-        .and_then(ast::Comment::cast)
-        .is_some()
+    ws.syntax().next_token().and_then(ast::Comment::cast).is_some()
 }
 
-fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {
+fn node_indent(
+    file: &SourceFile,
+    token: &SyntaxToken,
+) -> Option<SmolStr> {
     let ws = match file.syntax().token_at_offset(token.text_range().start()) {
         TokenAtOffset::Between(l, r) => {
             assert!(r == *token);
 mod tests {
     use stdx::trim_indent;
     use test_utils::assert_eq_text;
-
     use crate::fixture;
-
     fn apply_on_enter(before: &str) -> Option<String> {
         let (analysis, position) = fixture::position(before);
         let result = analysis.on_enter(position).unwrap()?;
-
         let mut actual = analysis.file_text(position.file_id).unwrap().to_string();
         result.apply(&mut actual);
         Some(actual)
     }
-
     fn do_check(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
         let actual = apply_on_enter(ra_fixture_before).unwrap();
         assert_eq_text!(ra_fixture_after, &actual);
     }
-
     fn do_check_noop(ra_fixture_text: &str) {
         assert!(apply_on_enter(ra_fixture_text).is_none())
     }
-
     #[test]
     fn continues_doc_comment() {
         do_check(
 }
 ",
         );
-
         do_check(
             r"
 impl S {
 }
 ",
         );
-
         do_check(
             r"
 ///$0 Some docs
 ",
         );
     }
-
     #[test]
     fn does_not_continue_before_doc_comment() {
         do_check_noop(r"$0//! docz");
     }
-
     #[test]
     fn continues_another_doc_comment() {
         do_check(
 "#,
         );
     }
-
     #[test]
     fn continues_code_comment_in_the_middle_of_line() {
         do_check(
 ",
         );
     }
-
     #[test]
     fn continues_code_comment_in_the_middle_several_lines() {
         do_check(
 ",
         );
     }
-
     #[test]
     fn does_not_continue_end_of_line_comment() {
         do_check_noop(
 ",
         );
     }
-
     #[test]
     fn continues_end_of_line_comment_with_space() {
         cov_mark::check!(continues_end_of_line_comment_with_space);
 "#,
         );
     }
-
     #[test]
     fn trims_all_trailing_whitespace() {
         do_check(
 ",
         );
     }
-
     #[test]
     fn indents_fn_body_block() {
         cov_mark::check!(indent_block_contents);
         "#,
         );
     }
-
     #[test]
     fn indents_block_expr() {
         do_check(
         "#,
         );
     }
-
     #[test]
     fn indents_match_arm() {
         do_check(
         "#,
         );
     }
-
     #[test]
     fn indents_block_with_statement() {
         do_check(
         "#,
         );
     }
-
     #[test]
     fn indents_nested_blocks() {
         do_check(
         "#,
         );
     }
-
     #[test]
     fn does_not_indent_empty_block() {
         do_check_noop(
         "#,
         );
     }
-
     #[test]
     fn does_not_indent_block_with_too_much_content() {
         do_check_noop(
         "#,
         );
     }
-
     #[test]
     fn does_not_indent_multiline_block() {
         do_check_noop(
         "#,
         );
     }
-
     #[test]
     fn indents_use_tree_list() {
         do_check(
             "#,
         );
     }
-
     #[test]
     fn does_not_indent_use_tree_list_when_not_at_curly_brace() {
         do_check_noop(
             "#,
         );
     }
-
     #[test]
     fn does_not_indent_use_tree_list_without_curly_braces() {
         do_check_noop(
             "#,
         );
     }
-
     #[test]
     fn does_not_indent_multiline_use_tree_list() {
         do_check_noop(