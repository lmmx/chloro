COMPARISON DIFF
============================================================

Original size: 12984 bytes
Chloro size:   11627 bytes
Rustfmt size:  13116 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Handles the `Enter` key press. At the momently, this only continues
 //! comments, but should handle indent some time in the future as well.
 
 use ide_db::base_db::RootQueryDb;
+use ide_db::text_edit::TextEdit;
 use ide_db::{FilePosition, RootDatabase};
 use syntax::{
     algo::find_node_at_offset,
     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset,
 };
 
-use ide_db::text_edit::TextEdit;
-
-// Feature: On Enter
-//
-// rust-analyzer can override <kbd>Enter</kbd> key to make it smarter:
-//
-// - <kbd>Enter</kbd> inside triple-slash comments automatically inserts `///`
-// - <kbd>Enter</kbd> in the middle or after a trailing space in `//` inserts `//`
-// - <kbd>Enter</kbd> inside `//!` doc comments automatically inserts `//!`
-// - <kbd>Enter</kbd> after `{` indents contents and closing `}` of single-line block
-//
-// This action needs to be assigned to shortcut explicitly.
-//
-// Note that, depending on the other installed extensions, this feature can visibly slow down typing.
-// Similarly, if rust-analyzer crashes or stops responding, `Enter` might not work.
-// In that case, you can still press `Shift-Enter` to insert a newline.
-//
-// #### VS Code
-//
-// Add the following to `keybindings.json`:
-// ```json
-// {
-//   "key": "Enter",
-//   "command": "rust-analyzer.onEnter",
-//   "when": "editorTextFocus && !suggestWidgetVisible && editorLangId == rust"
-// }
-// ````
-//
-// When using the Vim plugin:
-// ```json
-// {
-//   "key": "Enter",
-//   "command": "rust-analyzer.onEnter",
-//   "when": "editorTextFocus && !suggestWidgetVisible && editorLangId == rust && vim.mode == 'Insert'"
-// }
-// ````
-//
-// ![On Enter](https://user-images.githubusercontent.com/48062697/113065578-04c21800-91b1-11eb-82b8-22b8c481e645.gif)
 pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<TextEdit> {
     let editioned_file_id_wrapper =
         ide_db::base_db::EditionedFileId::current_edition(db, position.file_id);
     let parse = db.parse(editioned_file_id_wrapper);
     let file = parse.tree();
-    let token = file
-        .syntax()
-        .token_at_offset(position.offset)
-        .left_biased()?;
+    let token = file.syntax().token_at_offset(position.offset).left_biased()?;
 
     if let Some(comment) = ast::Comment::cast(token.clone()) {
         return on_enter_in_comment(&comment, &file, position.offset);
 
     let indent = IndentLevel::from_node(block.syntax());
     let mut edit = TextEdit::insert(position.offset, format!("\n{}$0", indent + 1));
-    edit.union(TextEdit::insert(
-        contents.text_range().end(),
-        format!("\n{indent}"),
-    ))
-    .ok()?;
+    edit.union(TextEdit::insert(contents.text_range().end(), format!("\n{indent}"))).ok()?;
     Some(edit)
 }
 
 
     let indent = IndentLevel::from_node(list.syntax());
     let mut edit = TextEdit::insert(position.offset, format!("\n{}$0", indent + 1));
-    edit.union(TextEdit::insert(
-        list.r_curly_token()?.text_range().start(),
-        format!("\n{indent}"),
-    ))
-    .ok()?;
+    edit.union(TextEdit::insert(list.r_curly_token()?.text_range().start(), format!("\n{indent}")))
+        .ok()?;
     Some(edit)
 }
 
 }
 
 fn followed_by_comment(comment: &ast::Comment) -> bool {
-    let ws = match comment
-        .syntax()
-        .next_token()
-        .and_then(ast::Whitespace::cast)
-    {
+    let ws = match comment.syntax().next_token().and_then(ast::Whitespace::cast) {
         Some(it) => it,
         None => return false,
     };
     if ws.spans_multiple_lines() {
         return false;
     }
-    ws.syntax()
-        .next_token()
-        .and_then(ast::Comment::cast)
-        .is_some()
+    ws.syntax().next_token().and_then(ast::Comment::cast).is_some()
 }
 
 fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {
 mod tests {
     use stdx::trim_indent;
     use test_utils::assert_eq_text;
-
     use crate::fixture;
-
     fn apply_on_enter(before: &str) -> Option<String> {
         let (analysis, position) = fixture::position(before);
         let result = analysis.on_enter(position).unwrap()?;
         result.apply(&mut actual);
         Some(actual)
     }
-
     fn do_check(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
         let actual = apply_on_enter(ra_fixture_before).unwrap();
         assert_eq_text!(ra_fixture_after, &actual);
     }
-
     fn do_check_noop(ra_fixture_text: &str) {
         assert!(apply_on_enter(ra_fixture_text).is_none())
     }
-
     #[test]
     fn continues_doc_comment() {
         do_check(
 ",
         );
     }
-
     #[test]
     fn does_not_continue_before_doc_comment() {
         do_check_noop(r"$0//! docz");
     }
-
     #[test]
     fn continues_another_doc_comment() {
         do_check(
 "#,
         );
     }
-
     #[test]
     fn continues_code_comment_in_the_middle_of_line() {
         do_check(
 ",
         );
     }
-
     #[test]
     fn continues_code_comment_in_the_middle_several_lines() {
         do_check(
 ",
         );
     }
-
     #[test]
     fn does_not_continue_end_of_line_comment() {
         do_check_noop(
 ",
         );
     }
-
     #[test]
     fn continues_end_of_line_comment_with_space() {
         cov_mark::check!(continues_end_of_line_comment_with_space);
 "#,
         );
     }
-
     #[test]
     fn trims_all_trailing_whitespace() {
         do_check(
 ",
         );
     }
-
     #[test]
     fn indents_fn_body_block() {
         cov_mark::check!(indent_block_contents);
         "#,
         );
     }
-
     #[test]
     fn indents_block_expr() {
         do_check(
         "#,
         );
     }
-
     #[test]
     fn indents_match_arm() {
         do_check(
         "#,
         );
     }
-
     #[test]
     fn indents_block_with_statement() {
         do_check(
         "#,
         );
     }
-
     #[test]
     fn indents_nested_blocks() {
         do_check(
         "#,
         );
     }
-
     #[test]
     fn does_not_indent_empty_block() {
         do_check_noop(
         "#,
         );
     }
-
     #[test]
     fn does_not_indent_block_with_too_much_content() {
         do_check_noop(
         "#,
         );
     }
-
     #[test]
     fn does_not_indent_multiline_block() {
         do_check_noop(
         "#,
         );
     }
-
     #[test]
     fn indents_use_tree_list() {
         do_check(
             "#,
         );
     }
-
     #[test]
     fn does_not_indent_use_tree_list_when_not_at_curly_brace() {
         do_check_noop(
             "#,
         );
     }
-
     #[test]
     fn does_not_indent_use_tree_list_without_curly_braces() {
         do_check_noop(
             "#,
         );
     }
-
     #[test]
     fn does_not_indent_multiline_use_tree_list() {
         do_check_noop(