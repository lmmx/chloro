COMPARISON DIFF
============================================================

Original size: 6351 bytes
Chloro size:   5895 bytes
Rustfmt size:  6484 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{AsAssocItem, Semantics};
 use ide_db::{
-    defs::{Definition, NameClass, NameRefClass},
     RootDatabase,
+    defs::{Definition, NameClass, NameRefClass},
 };
-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, T};
+use syntax::{AstNode, SyntaxKind::*, T, ast, match_ast};
 
 use crate::{
     goto_definition::goto_definition, navigation_target::TryToNav, FilePosition,
     GotoDefinitionConfig, NavigationTarget, RangeInfo,
 };
 
-// Feature: Go to Declaration
-//
-// Navigates to the declaration of an identifier.
-//
-// This is the same as `Go to Definition` with the following exceptions:
-// - outline modules will navigate to the `mod name;` item declaration
-// - trait assoc items will navigate to the assoc item of the trait declaration as opposed to the trait impl
-// - fields in patterns will navigate to the field declaration of the struct, union or variant
 pub(crate) fn goto_declaration(
     db: &RootDatabase,
     position @ FilePosition { file_id, offset }: FilePosition,
 ) -> Option<RangeInfo<Vec<NavigationTarget>>> {
     let sema = Semantics::new(db);
     let file = sema.parse_guess_edition(file_id).syntax().clone();
-    let original_token = file.token_at_offset(offset).find(|it| {
-        matches!(
-            it.kind(),
-            IDENT | T![self] | T![super] | T![crate] | T![Self]
-        )
-    })?;
+    let original_token = file
+        .token_at_offset(offset)
+        .find(|it| matches!(it.kind(), IDENT | T![self] | T![super] | T![crate] | T![Self]))?;
     let range = original_token.text_range();
     let info: Vec<NavigationTarget> = sema
         .descend_into_macros_no_opaque(original_token, false)
 
             let trait_ = assoc.implemented_trait(db)?;
             let name = Some(assoc.name(db)?);
-            let item = trait_
-                .items(db)
-                .into_iter()
-                .find(|it| it.name(db) == name)?;
+            let item = trait_.items(db).into_iter().find(|it| it.name(db) == name)?;
             item.try_to_nav(&sema)
         })
         .flatten()
         .collect();
-
     if info.is_empty() {
         goto_definition(db, position, config)
     } else {
 mod tests {
     use ide_db::{FileRange, MiniCore};
     use itertools::Itertools;
-
-    use crate::{fixture, GotoDefinitionConfig};
-
-    const TEST_CONFIG: GotoDefinitionConfig<'_> = GotoDefinitionConfig {
-        minicore: MiniCore::default(),
-    };
-
+    use crate::{GotoDefinitionConfig, fixture};
+    const TEST_CONFIG: GotoDefinitionConfig<'_> = GotoDefinitionConfig { minicore: MiniCore::default() };
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         let (analysis, position, expected) = fixture::annotations(ra_fixture);
         let navs = analysis
         if navs.is_empty() {
             panic!("unresolved reference")
         }
-
         let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());
         let navs = navs
             .into_iter()
-            .map(|nav| FileRange {
-                file_id: nav.file_id,
-                range: nav.focus_or_full_range(),
-            })
+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })
             .sorted_by_key(cmp)
             .collect::<Vec<_>>();
         let expected = expected
             .collect::<Vec<_>>();
         assert_eq!(expected, navs);
     }
-
     #[test]
     fn goto_decl_module_outline() {
         check(
 "#,
         )
     }
-
     #[test]
     fn goto_decl_module_inline() {
         check(
 "#,
         )
     }
-
     #[test]
     fn goto_decl_goto_def_fallback() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_decl_assoc_item_no_impl_item() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_decl_assoc_item() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_decl_field_pat_shorthand() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_decl_constructor_shorthand() {
         check(
 "#,
         );
     }
-
     #[test]
     fn goto_decl_for_extern_crate() {
         check(
 "#,
         )
     }
-
     #[test]
     fn goto_decl_for_renamed_extern_crate() {
         check(