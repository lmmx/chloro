COMPARISON DIFF
============================================================

Original size: 58223 bytes
Chloro size:   57878 bytes
Rustfmt size:  59341 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     token: SyntaxToken,
     file_id: EditionedFileId,
 ) -> Option<Vec<HighlightedRange>> {
-    let closure = token
-        .parent_ancestors()
-        .take(2)
-        .find_map(ast::ClosureExpr::cast)?;
+    let closure = token.parent_ancestors().take(2).find_map(ast::ClosureExpr::cast)?;
     let search_range = closure.body()?.syntax().text_range();
     let ty = &sema.type_of_expr(&closure.into())?.original;
     let c = ty.as_closure()?;
             .flat_map(|local| {
                 let usages = Definition::Local(local)
                     .usages(sema)
-                    .in_scope(&SearchScope::file_range(FileRange {
-                        file_id,
-                        range: search_range,
-                    }))
+                    .in_scope(&SearchScope::file_range(FileRange { file_id, range: search_range }))
                     .include_self_refs()
                     .all()
                     .references
                     .remove(&file_id)
                     .into_iter()
                     .flatten()
-                    .map(
-                        |FileReference {
-                             category, range, ..
-                         }| HighlightedRange { range, category },
-                    );
+                    .map(|FileReference { category, range, .. }| HighlightedRange {
+                        range,
+                        category,
+                    });
                 let category = if local.is_mut(sema.db) {
                     ReferenceCategory::WRITE
                 } else {
                 .remove(&file_id)
         })
         .flatten()
-        .map(
-            |FileReference {
-                 category, range, ..
-             }| HighlightedRange { range, category },
-        );
+        .map(|FileReference { category, range, .. }| HighlightedRange { range, category });
     let mut res = FxHashSet::default();
     for &def in &defs {
         // highlight trait usages
             })();
             if let Some((trait_item_use_scope, use_tree)) = trait_item_use_scope {
                 res.extend(
-                    if use_tree {
-                        t.items(sema.db)
-                    } else {
-                        t.items_with_supertraits(sema.db)
-                    }
-                    .into_iter()
-                    .filter_map(|item| {
-                        Definition::from(item)
-                            .usages(sema)
-                            .set_scope(Some(&SearchScope::file_range(FileRange {
-                                file_id,
-                                range: trait_item_use_scope.text_range(),
-                            })))
-                            .include_self_refs()
-                            .all()
-                            .references
-                            .remove(&file_id)
-                    })
-                    .flatten()
-                    .map(
-                        |FileReference {
-                             category, range, ..
-                         }| HighlightedRange { range, category },
-                    ),
+                    if use_tree { t.items(sema.db) } else { t.items_with_supertraits(sema.db) }
+                        .into_iter()
+                        .filter_map(|item| {
+                            Definition::from(item)
+                                .usages(sema)
+                                .set_scope(Some(&SearchScope::file_range(FileRange {
+                                    file_id,
+                                    range: trait_item_use_scope.text_range(),
+                                })))
+                                .include_self_refs()
+                                .all()
+                                .references
+                                .remove(&file_id)
+                        })
+                        .flatten()
+                        .map(|FileReference { category, range, .. }| HighlightedRange {
+                            range,
+                            category,
+                        }),
                 );
             }
         }
         // highlight the tail expr of the labelled block
         if matches!(def, Definition::Label(_)) {
             let label = token.parent_ancestors().nth(1).and_then(ast::Label::cast);
-            if let Some(block) = label
-                .and_then(|label| label.syntax().parent())
-                .and_then(ast::BlockExpr::cast)
+            if let Some(block) =
+                label.and_then(|label| label.syntax().parent()).and_then(ast::BlockExpr::cast)
             {
                 for_each_tail_expr(&block.into(), &mut |tail| {
                     if !matches!(tail, ast::Expr::BreakExpr(_)) {
 
     let push_to_highlights = |file_id, range, highlights: &mut HighlightMap| {
         if let Some(FileRange { file_id, range }) = original_frange(sema.db, file_id, range) {
-            let hrange = HighlightedRange {
-                category: ReferenceCategory::empty(),
-                range,
-            };
+            let hrange = HighlightedRange { category: ReferenceCategory::empty(), range };
             highlights.entry(file_id).or_default().insert(hrange);
         }
     };
 
     let mut push_to_highlights = |file_id, range| {
         if let Some(FileRange { file_id, range }) = original_frange(sema.db, file_id, range) {
-            let hrange = HighlightedRange {
-                category: ReferenceCategory::empty(),
-                range,
-            };
+            let hrange = HighlightedRange { category: ReferenceCategory::empty(), range };
             highlights.entry(file_id).or_default().insert(hrange);
         }
     };
         let range = match &expr {
             ast::Expr::TryExpr(try_) => try_.question_mark_token().map(|token| token.text_range()),
             ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroExpr(_)
-                if sema
-                    .type_of_expr(&expr)
-                    .is_some_and(|ty| ty.original.is_never()) =>
+                if sema.type_of_expr(&expr).is_some_and(|ty| ty.original.is_never()) =>
             {
                 Some(expr.syntax().text_range())
             }
         merge_map(&mut res, new_map);
     }
 
-    res.into_iter()
-        .map(|(file_id, ranges)| (file_id, ranges.into_iter().collect()))
-        .collect()
+    res.into_iter().map(|(file_id, ranges)| (file_id, ranges.into_iter().collect())).collect()
 }
 
 pub(crate) fn highlight_break_points(
 
         let mut push_to_highlights = |file_id, range| {
             if let Some(FileRange { file_id, range }) = original_frange(sema.db, file_id, range) {
-                let hrange = HighlightedRange {
-                    category: ReferenceCategory::empty(),
-                    range,
-                };
+                let hrange = HighlightedRange { category: ReferenceCategory::empty(), range };
                 highlights.entry(file_id).or_default().insert(hrange);
             }
         };
         merge_map(&mut res, new_map);
     }
 
-    res.into_iter()
-        .map(|(file_id, ranges)| (file_id, ranges.into_iter().collect()))
-        .collect()
+    res.into_iter().map(|(file_id, ranges)| (file_id, ranges.into_iter().collect())).collect()
 }
 
 pub(crate) fn highlight_yield_points(
 
         let mut push_to_highlights = |file_id, range| {
             if let Some(FileRange { file_id, range }) = original_frange(sema.db, file_id, range) {
-                let hrange = HighlightedRange {
-                    category: ReferenceCategory::empty(),
-                    range,
-                };
+                let hrange = HighlightedRange { category: ReferenceCategory::empty(), range };
                 highlights.entry(file_id).or_default().insert(hrange);
             }
         };
         merge_map(&mut res, new_map);
     }
 
-    res.into_iter()
-        .map(|(file_id, ranges)| (file_id, ranges.into_iter().collect()))
-        .collect()
+    res.into_iter().map(|(file_id, ranges)| (file_id, ranges.into_iter().collect())).collect()
 }
 
 fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange> {
     file_id: HirFileId,
     text_range: Option<TextRange>,
 ) -> Option<FileRange> {
-    InFile::new(file_id, text_range?)
-        .original_node_file_range_opt(db)
-        .map(|(frange, _)| frange)
+    InFile::new(file_id, text_range?).original_node_file_range_opt(db).map(|(frange, _)| frange)
 }
 
 fn merge_map(res: &mut HighlightMap, new: Option<HighlightMap>) {
 
 impl<'a> WalkExpandedExprCtx<'a> {
     fn new(sema: &'a Semantics<'a, RootDatabase>) -> Self {
-        Self {
-            sema,
-            depth: 0,
-            check_ctx: &is_closure_or_blk_with_modif,
-        }
+        Self { sema, depth: 0, check_ctx: &is_closure_or_blk_with_modif }
     }
 
     fn with_check_ctx(&self, check_ctx: &'static dyn Fn(&ast::Expr) -> bool) -> Self {
     }
 
     fn walk(&mut self, expr: &ast::Expr, cb: &mut dyn FnMut(usize, ast::Expr)) {
-        preorder_expr_with_ctx_checker(expr, self.check_ctx, &mut |ev: WalkEvent<ast::Expr>| {
+        preorder_expr_with_ctx_checker(
+            expr,
+            self.check_ctx,
+            &mut |ev: WalkEvent<ast::Expr>| {
             match ev {
                 syntax::WalkEvent::Enter(expr) => {
                     cb(self.depth, expr.clone());
                     }
 
                     if let ast::Expr::MacroExpr(expr) = expr
-                        && let Some(expanded) = expr
-                            .macro_call()
-                            .and_then(|call| self.sema.expand_macro_call(&call))
+                        && let Some(expanded) =
+                            expr.macro_call().and_then(|call| self.sema.expand_macro_call(&call))
                     {
                         match_ast! {
                             match (expanded.value) {
                 _ => {}
             }
             false
-        })
+        },
+        )
     }
 
-    fn handle_expanded(&mut self, expanded: ast::MacroStmts, cb: &mut dyn FnMut(usize, ast::Expr)) {
+    fn handle_expanded(
+        &mut self,
+        expanded: ast::MacroStmts,
+        cb: &mut dyn FnMut(usize, ast::Expr),
+    ) {
         if let Some(expr) = expanded.expr() {
             self.walk(&expr, cb);
         }
 
         for stmt in expanded.statements() {
-            if let ast::Stmt::ExprStmt(stmt) = stmt
-                && let Some(expr) = stmt.expr()
-            {
+            if let ast::Stmt::ExprStmt(stmt) = stmt && let Some(expr) = stmt.expr() {
                 self.walk(&expr, cb);
             }
         }
 
         let mut push_to_highlights = |file_id, range| {
             if let Some(FileRange { file_id, range }) = original_frange(sema.db, file_id, range) {
-                let hrange = HighlightedRange {
-                    category: ReferenceCategory::empty(),
-                    range,
-                };
+                let hrange = HighlightedRange { category: ReferenceCategory::empty(), range };
                 highlights.entry(file_id).or_default().push(hrange);
             }
         };
 #[cfg(test)]
 mod tests {
     use itertools::Itertools;
-
     use crate::fixture;
-
     use super::*;
-
     const ENABLED_CONFIG: HighlightRelatedConfig = HighlightRelatedConfig {
         break_points: true,
         exit_points: true,
         yield_points: true,
         branch_exit_points: true,
     };
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(ra_fixture, ENABLED_CONFIG);
     }
-
     #[track_caller]
     fn check_with_config(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
     ) {
         let (analysis, pos, annotations) = fixture::annotations(ra_fixture);
 
-        let hls = analysis
-            .highlight_related(config, pos)
-            .unwrap()
-            .unwrap_or_default();
+        let hls = analysis.highlight_related(config, pos).unwrap().unwrap_or_default();
 
-        let mut expected = annotations
-            .into_iter()
-            .map(|(r, access)| (r.range, access))
-            .collect::<Vec<_>>();
+        let mut expected =
+            annotations.into_iter().map(|(r, access)| (r.range, access)).collect::<Vec<_>>();
 
         let mut actual: Vec<(TextRange, String)> = hls
             .into_iter()
             .map(|hl| {
                 (
                     hl.range,
-                    hl.category
-                        .iter_names()
-                        .map(|(name, _flag)| name.to_lowercase())
-                        .join(","),
+                    hl.category.iter_names().map(|(name, _flag)| name.to_lowercase()).join(","),
                 )
             })
             .collect();
 
         assert_eq!(expected, actual);
     }
-
     #[test]
     fn test_hl_unsafe_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_tuple_fields() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_module() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_self_in_crate_root() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_self_in_module() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_local() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_local_in_attr() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_multi_macro_usage() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_yield_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_yield_points2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_exit_points_of_async_blocks() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_let_else_yield_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_yield_nested_fn() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_yield_nested_async_blocks() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_exit_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_exit_points2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_exit_points3() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_let_else_exit_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_prefer_ref_over_tail_exit() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_never_call_is_exit_point() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_inner_tail_exit_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_inner_tail_exit_points_labeled_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_inner_tail_exit_points_loops() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_loop() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_loop2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_for() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_for_but_not_continue() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_continue_for_but_not_break() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_and_continue() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_while() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_labeled_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_unlabeled_loop() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_unlabeled_block_in_loop() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_field_shorthand() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_disabled_ref_local() {
-        let config = HighlightRelatedConfig {
-            references: false,
-            ..ENABLED_CONFIG
-        };
+        let config = HighlightRelatedConfig { references: false, ..ENABLED_CONFIG };
 
         check_with_config(
             r#"
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_ref_local_preserved_break() {
-        let config = HighlightRelatedConfig {
-            references: false,
-            ..ENABLED_CONFIG
-        };
+        let config = HighlightRelatedConfig { references: false, ..ENABLED_CONFIG };
 
         check_with_config(
             r#"
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_ref_local_preserved_yield() {
-        let config = HighlightRelatedConfig {
-            references: false,
-            ..ENABLED_CONFIG
-        };
+        let config = HighlightRelatedConfig { references: false, ..ENABLED_CONFIG };
 
         check_with_config(
             r#"
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_ref_local_preserved_exit() {
-        let config = HighlightRelatedConfig {
-            references: false,
-            ..ENABLED_CONFIG
-        };
+        let config = HighlightRelatedConfig { references: false, ..ENABLED_CONFIG };
 
         check_with_config(
             r#"
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_break() {
-        let config = HighlightRelatedConfig {
-            break_points: false,
-            ..ENABLED_CONFIG
-        };
+        let config = HighlightRelatedConfig { break_points: false, ..ENABLED_CONFIG };
 
         check_with_config(
             r#"
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_yield() {
-        let config = HighlightRelatedConfig {
-            yield_points: false,
-            ..ENABLED_CONFIG
-        };
+        let config = HighlightRelatedConfig { yield_points: false, ..ENABLED_CONFIG };
 
         check_with_config(
             r#"
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_exit() {
-        let config = HighlightRelatedConfig {
-            exit_points: false,
-            ..ENABLED_CONFIG
-        };
+        let config = HighlightRelatedConfig { exit_points: false, ..ENABLED_CONFIG };
 
         check_with_config(
             r#"
             config,
         );
     }
-
     #[test]
     fn test_hl_multi_local() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_trait_impl_methods() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_assoc_type_highlighting() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_closure_capture_pipe() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_closure_capture_move() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_trait_highlights_assoc_item_uses() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_trait_highlights_assoc_item_uses_use_tree() {
         check(
 "#,
         );
     }
-
     #[test]
     fn implicit_format_args() {
         check(
 "#,
         );
     }
-
     #[test]
     fn return_in_macros() {
-        check(
-            r#"
+        check(r#"
 macro_rules! N {
     ($i:ident, $x:expr, $blk:expr) => {
         for $i in 0..$x {
         })();
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn return_in_closure() {
-        check(
-            r#"
+        check(r#"
 macro_rules! N {
     ($i:ident, $x:expr, $blk:expr) => {
         for $i in 0..$x {
         })();
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn return_in_try() {
-        check(
-            r#"
+        check(r#"
 fn main() {
     fn f() {
  // ^^
      // ^^^^^^
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn break_in_try() {
-        check(
-            r#"
+        check(r#"
 fn main() {
     for i in 1..100 {
  // ^^^
         };
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn no_highlight_on_return_in_macro_call() {
-        check(
-            r#"
+        check(r#"
 //- minicore:include
 //- /lib.rs
 macro_rules! M {
 {
     return;
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn nested_match() {
-        check(
-            r#"
+        check(r#"
 fn main() {
     match$0 0 {
  // ^^^^^
           // ^
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn single_arm_highlight() {
-        check(
-            r#"
+        check(r#"
 fn main() {
     match 0 {
         0 =>$0 {
         _ => 2,
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn no_branches_when_disabled() {
-        let config = HighlightRelatedConfig {
-            branch_exit_points: false,
-            ..ENABLED_CONFIG
-        };
+        let config = HighlightRelatedConfig { branch_exit_points: false, ..ENABLED_CONFIG };
         check_with_config(
             r#"
 fn main() {
             config,
         );
     }
-
     #[test]
     fn asm() {
-        check(
-            r#"
+        check(r#"
 //- minicore: asm
 #[inline]
 pub unsafe fn bootstrap() -> ! {
         options(noreturn, nomem, nostack),
     );
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn complex_arms_highlight() {
-        check(
-            r#"
+        check(r#"
 fn calculate(n: i32) -> i32 { n * 2 }
 
 fn main() {
         },
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn match_in_macro_highlight() {
-        check(
-            r#"
+        check(r#"
 macro_rules! M {
     ($e:expr) => { $e };
 }
         }
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn match_in_macro_highlight_2() {
         check(
             "#,
         );
     }
-
     #[test]
     fn nested_if_else() {
-        check(
-            r#"
+        check(r#"
 fn main() {
     if$0 true {
  // ^^
      // ^
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn if_else_if_highlight() {
-        check(
-            r#"
+        check(r#"
 fn main() {
     if$0 true {
  // ^^
      // ^
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn complex_if_branches() {
-        check(
-            r#"
+        check(r#"
 fn calculate(n: i32) -> i32 { n * 2 }
 
 fn main() {
         }
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn if_in_macro_highlight() {
-        check(
-            r#"
+        check(r#"
 macro_rules! M {
     ($e:expr) => { $e };
 }
         }
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn match_in_macro() {
         // We should not highlight the outer `match` expression.
-        check(
-            r#"
+        check(r#"
 macro_rules! M {
     (match) => { 1 };
 }
         }
     }
 }
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn labeled_block_tail_expr() {
         check(
 "#,
         );
     }
-
     #[test]
     fn labeled_block_tail_expr_2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn different_unsafe_block() {
         check(