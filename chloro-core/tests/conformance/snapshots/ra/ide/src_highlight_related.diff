COMPARISON DIFF
============================================================

Original size: 58223 bytes
Chloro size:   57249 bytes
Rustfmt size:  58223 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::iter;
 
-use hir::{EditionedFileId, FilePosition, FileRange, HirFileId, InFile, Semantics, db};
+use hir::{db, EditionedFileId, FilePosition, FileRange, HirFileId, InFile, Semantics};
 use ide_db::{
-    FxHashMap, FxHashSet, RootDatabase,
     defs::{Definition, IdentClass},
     helpers::pick_best_token,
     search::{FileReference, ReferenceCategory, SearchScope},
         eq_label_lt, for_each_tail_expr, full_path_of_name_ref, is_closure_or_blk_with_modif,
         preorder_expr_with_ctx_checker,
     },
+    FxHashMap, FxHashSet, RootDatabase,
 };
 use syntax::{
-    AstNode,
-    SyntaxKind::{self, IDENT, INT_NUMBER},
-    SyntaxToken, T, TextRange, WalkEvent,
     ast::{self, HasLoopBody},
-    match_ast,
+    match_ast, AstNode,
+    SyntaxKind::{self, IDENT, INT_NUMBER},
+    SyntaxToken, TextRange, WalkEvent, T,
 };
 
-use crate::{NavigationTarget, TryToNav, goto_definition, navigation_target::ToNav};
+use crate::{goto_definition, navigation_target::ToNav, NavigationTarget, TryToNav};
 
 #[derive(PartialEq, Eq, Hash)]
 pub struct HighlightedRange {
 
 type HighlightMap = FxHashMap<EditionedFileId, FxHashSet<HighlightedRange>>;
 
-// Feature: Highlight Related
-//
-// Highlights constructs related to the thing under the cursor:
-//
-// 1. if on an identifier, highlights all references to that identifier in the current file
-//      * additionally, if the identifier is a trait in a where clause, type parameter trait bound or use item, highlights all references to that trait's assoc items in the corresponding scope
-// 1. if on an `async` or `await` token, highlights all yield points for that async context
-// 1. if on a `return` or `fn` keyword, `?` character or `->` return type arrow, highlights all exit points for that context
-// 1. if on a `break`, `loop`, `while` or `for` token, highlights all break points for that loop or block context
-// 1. if on a `move` or `|` token that belongs to a closure, highlights all captures of the closure.
-//
-// Note: `?`, `|` and `->` do not currently trigger this behavior in the VSCode editor.
 pub(crate) fn highlight_related(
     sema: &Semantics<'_, RootDatabase>,
     config: HighlightRelatedConfig,
         push_to_highlights(file_id, range);
     }
 
-    WalkExpandedExprCtx::new(sema).walk(&body, &mut |_, expr| {
+    WalkExpandedExprCtx::new(sema)
+        .walk(&body, &mut |_, expr| {
         let file_id = sema.hir_file_for(expr.syntax());
 
         let range = match &expr {
     });
 
     // We should handle `return` separately, because when it is used in a `try` block,
+
     // it will exit the outside function instead of the block itself.
     WalkExpandedExprCtx::new(sema)
         .with_check_ctx(&WalkExpandedExprCtx::is_async_const_block_or_closure)
     Some(highlights)
 }
 
-// If `file_id` is None,
 pub(crate) fn highlight_exit_points(
     sema: &Semantics<'_, RootDatabase>,
     token: SyntaxToken,
     let Some(new) = new else {
         return;
     };
-    new.into_iter().for_each(|(file_id, ranges)| {
+    new
+        .into_iter()
+        .for_each(|(file_id, ranges)| {
         res.entry(file_id).or_default().extend(ranges);
     });
 }
         })
     }
 
-    fn handle_expanded(&mut self, expanded: ast::MacroStmts, cb: &mut dyn FnMut(usize, ast::Expr)) {
+    fn handle_expanded(
+        &mut self,
+        expanded: ast::MacroStmts,
+        cb: &mut dyn FnMut(usize, ast::Expr),
+    ) {
         if let Some(expr) = expanded.expr() {
             self.walk(&expr, cb);
         }
 #[cfg(test)]
 mod tests {
     use itertools::Itertools;
-
     use crate::fixture;
-
     use super::*;
-
     const ENABLED_CONFIG: HighlightRelatedConfig = HighlightRelatedConfig {
         break_points: true,
         exit_points: true,
         yield_points: true,
         branch_exit_points: true,
     };
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_with_config(ra_fixture, ENABLED_CONFIG);
     }
-
     #[track_caller]
     fn check_with_config(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
 
         let hls = analysis.highlight_related(config, pos).unwrap().unwrap_or_default();
 
-        let mut expected =
-            annotations.into_iter().map(|(r, access)| (r.range, access)).collect::<Vec<_>>();
+        let mut expected = annotations.into_iter().map(|(r, access)| (r.range, access)).collect();
 
         let mut actual: Vec<(TextRange, String)> = hls
             .into_iter()
 
         assert_eq!(expected, actual);
     }
-
     #[test]
     fn test_hl_unsafe_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_tuple_fields() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_module() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_self_in_crate_root() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_self_in_module() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_local() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_local_in_attr() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_multi_macro_usage() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_yield_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_yield_points2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_exit_points_of_async_blocks() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_let_else_yield_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_yield_nested_fn() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_yield_nested_async_blocks() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_exit_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_exit_points2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_exit_points3() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_let_else_exit_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_prefer_ref_over_tail_exit() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_never_call_is_exit_point() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_inner_tail_exit_points() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_inner_tail_exit_points_labeled_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_inner_tail_exit_points_loops() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_loop() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_loop2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_for() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_for_but_not_continue() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_continue_for_but_not_break() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_and_continue() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_while() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_labeled_block() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_unlabeled_loop() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_break_unlabeled_block_in_loop() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_field_shorthand() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_disabled_ref_local() {
         let config = HighlightRelatedConfig { references: false, ..ENABLED_CONFIG };
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_ref_local_preserved_break() {
         let config = HighlightRelatedConfig { references: false, ..ENABLED_CONFIG };
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_ref_local_preserved_yield() {
         let config = HighlightRelatedConfig { references: false, ..ENABLED_CONFIG };
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_ref_local_preserved_exit() {
         let config = HighlightRelatedConfig { references: false, ..ENABLED_CONFIG };
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_break() {
         let config = HighlightRelatedConfig { break_points: false, ..ENABLED_CONFIG };
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_yield() {
         let config = HighlightRelatedConfig { yield_points: false, ..ENABLED_CONFIG };
             config,
         );
     }
-
     #[test]
     fn test_hl_disabled_exit() {
         let config = HighlightRelatedConfig { exit_points: false, ..ENABLED_CONFIG };
             config,
         );
     }
-
     #[test]
     fn test_hl_multi_local() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_hl_trait_impl_methods() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_assoc_type_highlighting() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_closure_capture_pipe() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_closure_capture_move() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_trait_highlights_assoc_item_uses() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_trait_highlights_assoc_item_uses_use_tree() {
         check(
 "#,
         );
     }
-
     #[test]
     fn implicit_format_args() {
         check(
 "#,
         );
     }
-
     #[test]
     fn return_in_macros() {
         check(
 "#,
         )
     }
-
     #[test]
     fn return_in_closure() {
         check(
 "#,
         )
     }
-
     #[test]
     fn return_in_try() {
         check(
 "#,
         )
     }
-
     #[test]
     fn break_in_try() {
         check(
 "#,
         )
     }
-
     #[test]
     fn no_highlight_on_return_in_macro_call() {
         check(
 "#,
         )
     }
-
     #[test]
     fn nested_match() {
         check(
 "#,
         )
     }
-
     #[test]
     fn single_arm_highlight() {
         check(
 "#,
         )
     }
-
     #[test]
     fn no_branches_when_disabled() {
         let config = HighlightRelatedConfig { branch_exit_points: false, ..ENABLED_CONFIG };
             config,
         );
     }
-
     #[test]
     fn asm() {
         check(
 "#,
         )
     }
-
     #[test]
     fn complex_arms_highlight() {
         check(
 "#,
         )
     }
-
     #[test]
     fn match_in_macro_highlight() {
         check(
 "#,
         )
     }
-
     #[test]
     fn match_in_macro_highlight_2() {
         check(
             "#,
         );
     }
-
     #[test]
     fn nested_if_else() {
         check(
 "#,
         )
     }
-
     #[test]
     fn if_else_if_highlight() {
         check(
 "#,
         )
     }
-
     #[test]
     fn complex_if_branches() {
         check(
 "#,
         )
     }
-
     #[test]
     fn if_in_macro_highlight() {
         check(
 "#,
         )
     }
-
     #[test]
     fn match_in_macro() {
         // We should not highlight the outer `match` expression.
             "#,
         )
     }
-
     #[test]
     fn labeled_block_tail_expr() {
         check(
 "#,
         );
     }
-
     #[test]
     fn labeled_block_tail_expr_2() {
         check(
 "#,
         );
     }
-
     #[test]
     fn different_unsafe_block() {
         check(