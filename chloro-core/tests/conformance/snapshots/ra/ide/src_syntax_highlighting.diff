COMPARISON DIFF
============================================================

Original size: 24849 bytes
Chloro size:   18546 bytes
Rustfmt size:  25118 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{DefWithBody, EditionedFileId, InFile, InRealFile, MacroKind, Name, Semantics};
 use ide_db::{FxHashMap, FxHashSet, MiniCore, Ranker, RootDatabase, SymbolKind};
 use syntax::{
-    ast::{self, IsString},
     AstNode, AstToken, NodeOrToken,
     SyntaxKind::*,
-    SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,
+    SyntaxNode, SyntaxToken, T, TextRange, WalkEvent,
+    ast::{self, IsString},
 };
 
 use crate::{
+    FileId, HlMod, HlOperator, HlPunct, HlTag,
     syntax_highlighting::{
         escape::{highlight_escape_byte, highlight_escape_char, highlight_escape_string},
-        format::highlight_format_string,
-        highlights::Highlights,
-        tags::Highlight,
+        format::highlight_format_string, highlights::Highlights, tags::Highlight,
     },
-    FileId, HlMod, HlOperator, HlPunct, HlTag,
 };
 
 pub(crate) use html::highlight_as_html;
     pub minicore: MiniCore<'a>,
 }
 
-// Feature: Semantic Syntax Highlighting
-//
-// rust-analyzer highlights the code semantically.
-// For example, `Bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.
-// rust-analyzer does not specify colors directly, instead it assigns a tag (like `struct`) and a set of modifiers (like `declaration`) to each token.
-// It's up to the client to map those to specific colors.
-//
-// The general rule is that a reference to an entity gets colored the same way as the entity itself.
-// We also give special modifier for `mut` and `&mut` local variables.
-//
-//
-// #### Token Tags
-//
-// Rust-analyzer currently emits the following token tags:
-//
-// - For items:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// | attribute |  Emitted for attribute macros. |
-// |enum| Emitted for enums. |
-// |function| Emitted for free-standing functions. |
-// |derive| Emitted for derive macros. |
-// |macro| Emitted for function-like macros. |
-// |method| Emitted for associated functions, also knowns as methods. |
-// |namespace| Emitted for modules. |
-// |struct| Emitted for structs.|
-// |trait| Emitted for traits.|
-// |typeAlias| Emitted for type aliases and `Self` in `impl`s.|
-// |union| Emitted for unions.|
-//
-// - For literals:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// | boolean|  Emitted for the boolean literals `true` and `false`.|
-// | character| Emitted for character literals.|
-// | number| Emitted for numeric literals.|
-// | string| Emitted for string literals.|
-// | escapeSequence| Emitted for escaped sequences inside strings like `\n`.|
-// | formatSpecifier| Emitted for format specifiers `{:?}` in `format!`-like macros.|
-//
-// - For operators:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// |operator| Emitted for general operators.|
-// |arithmetic| Emitted for the arithmetic operators `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`.|
-// |bitwise| Emitted for the bitwise operators `\|`, `&`, `!`, `^`, `\|=`, `&=`, `^=`.|
-// |comparison| Emitted for the comparison oerators `>`, `<`, `==`, `>=`, `<=`, `!=`.|
-// |logical| Emitted for the logical operators `\|\|`, `&&`, `!`.|
-//
-// - For punctuation:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// |punctuation| Emitted for general punctuation.|
-// |attributeBracket| Emitted for attribute invocation brackets, that is the `#[` and `]` tokens.|
-// |angle| Emitted for `<>` angle brackets.|
-// |brace| Emitted for `{}` braces.|
-// |bracket| Emitted for `[]` brackets.|
-// |parenthesis| Emitted for `()` parentheses.|
-// |colon| Emitted for the `:` token.|
-// |comma| Emitted for the `,` token.|
-// |dot| Emitted for the `.` token.|
-// |semi| Emitted for the `;` token.|
-// |macroBang| Emitted for the `!` token in macro calls.|
-//
-//-
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// |builtinAttribute| Emitted for names to builtin attributes in attribute path, the `repr` in `#[repr(u8)]` for example.|
-// |builtinType| Emitted for builtin types like `u32`, `str` and `f32`.|
-// |comment| Emitted for comments.|
-// |constParameter| Emitted for const parameters.|
-// |deriveHelper| Emitted for derive helper attributes.|
-// |enumMember| Emitted for enum variants.|
-// |generic| Emitted for generic tokens that have no mapping.|
-// |keyword| Emitted for keywords.|
-// |label| Emitted for labels.|
-// |lifetime| Emitted for lifetimes.|
-// |parameter| Emitted for non-self function parameters.|
-// |property| Emitted for struct and union fields.|
-// |selfKeyword| Emitted for the self function parameter and self path-specifier.|
-// |selfTypeKeyword| Emitted for the Self type parameter.|
-// |toolModule| Emitted for tool modules.|
-// |typeParameter| Emitted for type parameters.|
-// |unresolvedReference| Emitted for unresolved references, names that rust-analyzer can't find the definition of.|
-// |variable| Emitted for locals, constants and statics.|
-//
-//
-// #### Token Modifiers
-//
-// Token modifiers allow to style some elements in the source code more precisely.
-//
-// Rust-analyzer currently emits the following token modifiers:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// |async| Emitted for async functions and the `async` and `await` keywords.|
-// |attribute| Emitted for tokens inside attributes.|
-// |callable| Emitted for locals whose types implements one of the `Fn*` traits.|
-// |constant| Emitted for const.|
-// |consuming| Emitted for locals that are being consumed when use in a function call.|
-// |controlFlow| Emitted for control-flow related tokens, this includes th `?` operator.|
-// |crateRoot| Emitted for crate names, like `serde` and `crate`.|
-// |declaration| Emitted for names of definitions, like `foo` in `fn foo(){}`.|
-// |defaultLibrary| Emitted for items from built-in crates (std, core, alloc, test and proc_macro).|
-// |documentation| Emitted for documentation comment.|
-// |injected| Emitted for doc-string injected highlighting like rust source blocks in documentation.|
-// |intraDocLink| Emitted for intra doc links in doc-string.|
-// |library| Emitted for items that are defined outside of the current crate.|
-// |macro|  Emitted for tokens inside macro call.|
-// |mutable| Emitted for mutable locals and statics as well as functions taking `&mut self`.|
-// |public| Emitted for items that are from the current crate and are `pub`.|
-// |reference| Emitted for locals behind a reference and functions taking `self` by reference.|
-// |static| Emitted for "static" functions, also known as functions that do not take a `self` param, as well as statics and consts.|
-// |trait| Emitted for associated trait item.|
-// |unsafe| Emitted for unsafe operations, like unsafe function calls, as well as the `unsafe` token.|
-//
-// ![Semantic Syntax Highlighting](https://user-images.githubusercontent.com/48062697/113164457-06cfb980-9239-11eb-819b-0f93e646acf8.png)
-// ![Semantic Syntax Highlighting](https://user-images.githubusercontent.com/48062697/113187625-f7f50100-9250-11eb-825e-91c58f236071.png)
 pub(crate) fn highlight(
     db: &RootDatabase,
     config: &HighlightConfig<'_>,
         .unwrap_or_else(|| EditionedFileId::current_edition(db, file_id));
 
     // Determine the root based on the given range.
+
     let (root, range_to_highlight) = {
         let file = sema.parse(file_id);
         let source_file = file.syntax();
 
     let mut hl = highlights::Highlights::new(root.text_range());
     let krate = sema.scope(&root).map(|it| it.krate());
-    traverse(
-        &mut hl,
-        &sema,
-        config,
-        InRealFile::new(file_id, &root),
-        krate,
-        range_to_highlight,
-    );
+    traverse(&mut hl, &sema, config, InRealFile::new(file_id, &root), krate, range_to_highlight);
     hl.to_vec()
 }
 
     hl: &mut Highlights,
     sema: &Semantics<'_, RootDatabase>,
     config: &HighlightConfig<'_>,
-    InRealFile {
-        file_id,
-        value: root,
-    }: InRealFile<&SyntaxNode>,
+    InRealFile { file_id, value: root }: InRealFile<&SyntaxNode>,
     krate: Option<hir::Crate>,
     range_to_highlight: TextRange,
 ) {
     let empty = FxHashSet::default();
 
     // FIXME: accommodate range highlighting
+
     let mut tt_level = 0;
     // FIXME: accommodate range highlighting
     let mut attr_or_derive_item = None;
 
     // FIXME: these are not perfectly accurate, we determine them by the real file's syntax tree
+
     // an attribute nested in a macro call will not emit `inside_attribute`
+
     let mut inside_attribute = false;
 
     // FIXME: accommodate range highlighting
+
     let mut body_stack: Vec<Option<DefWithBody>> = vec![];
     let mut per_body_cache: FxHashMap<DefWithBody, (FxHashSet<_>, FxHashMap<Name, u32>)> =
         FxHashMap::default();
 
     // Walk all nodes, keeping track of whether we are inside a macro or not.
+
     // If in macro, expand it first and highlight the expanded code.
+
     let mut preorder = root.preorder_with_tokens();
     while let Some(event) = preorder.next() {
+        // Element outside of the viewport, no need to highlight
+        // Descending tokens into macros is expensive even if no descending occurs, so make sure
+        // that we actually are in a position where descending is possible.
+        // string highlight injections
         use WalkEvent::{Enter, Leave};
-
         let range = match &event {
             Enter(it) | Leave(it) => it.text_range(),
         };
-
-        // Element outside of the viewport, no need to highlight
         if range_to_highlight.intersect(range).is_none() {
             continue;
         }
-
         match event.clone() {
             Enter(NodeOrToken::Node(node)) if ast::TokenTree::can_cast(node.kind()) => {
                 tt_level += 1;
             {
                 match ast::Item::cast(node.clone()) {
                     Some(item) => {
-                        if attr_or_derive_item
-                            .as_ref()
-                            .is_some_and(|it| *it.item() == item)
-                        {
+                        if attr_or_derive_item.as_ref().is_some_and(|it| *it.item() == item) {
                             attr_or_derive_item = None;
                         }
                         if matches!(
             }
             _ => (),
         }
-
         let element = match event {
             Enter(NodeOrToken::Token(tok)) if tok.kind() == WHITESPACE => continue,
             Enter(it) => it,
                 continue;
             }
         };
-
         let element = match element.clone() {
             NodeOrToken::Node(n) => match ast::NameLike::cast(n) {
                 Some(n) => NodeOrToken::Node(n),
             NodeOrToken::Token(t) => NodeOrToken::Token(t),
         };
         let original_token = element.as_token().cloned();
-
-        // Descending tokens into macros is expensive even if no descending occurs, so make sure
-        // that we actually are in a position where descending is possible.
         let in_macro = tt_level > 0
             || match attr_or_derive_item {
                 Some(AttrOrDerive::Attr(_)) => true,
                 Some(AttrOrDerive::Derive(_)) => inside_attribute,
                 None => false,
             };
-
         let (descended_element, current_body) = match element {
             // Attempt to descend tokens into macro-calls.
             NodeOrToken::Token(token) if in_macro => {
                     NodeOrToken::Node(n) => {
                         sema.body_for(InFile::new(descended.file_id, n.syntax()))
                     }
-                    NodeOrToken::Token(t) => t
-                        .parent()
-                        .and_then(|it| sema.body_for(InFile::new(descended.file_id, &it))),
+                    NodeOrToken::Token(t) => {
+                        t.parent().and_then(|it| sema.body_for(InFile::new(descended.file_id, &it)))
+                    }
                 };
                 (descended, body)
             }
-            n => (
-                InFile::new(file_id.into(), n),
-                body_stack.last().copied().flatten(),
-            ),
+            n => (InFile::new(file_id.into(), n), body_stack.last().copied().flatten()),
         };
-        // string highlight injections
         if let (Some(original_token), Some(descended_token)) =
             (original_token, descended_element.value.as_token())
         {
                 continue;
             }
         }
-
         let edition = descended_element.file_id.edition(sema.db);
         let (unsafe_ops, bindings_shadow_count) = match current_body {
             Some(current_body) => {
             }),
         };
         if let Some((mut highlight, binding_hash)) = element {
+            // apply config filtering
             if is_unlinked && highlight.tag == HlTag::UnresolvedReference {
                 // do not emit unresolved references if the file is unlinked
                 // let the editor do its highlighting for these tokens instead
                 continue;
             }
-
-            // apply config filtering
             if !filter_by_config(&mut highlight, config) {
                 continue;
             }
-
             if inside_attribute {
                 highlight |= HlMod::Attribute
             }
                 }
                 highlight |= HlMod::Macro
             }
-
-            hl.add(HlRange {
-                range,
-                highlight,
-                binding_hash,
-            });
+            hl.add(HlRange { range, highlight, binding_hash });
         }
     }
 }