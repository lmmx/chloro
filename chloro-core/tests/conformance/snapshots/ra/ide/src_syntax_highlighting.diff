COMPARISON DIFF
============================================================

Original size: 24849 bytes
Chloro size:   24824 bytes
Rustfmt size:  25118 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{DefWithBody, EditionedFileId, InFile, InRealFile, MacroKind, Name, Semantics};
 use ide_db::{FxHashMap, FxHashSet, MiniCore, Ranker, RootDatabase, SymbolKind};
 use syntax::{
-    ast::{self, IsString},
     AstNode, AstToken, NodeOrToken,
     SyntaxKind::*,
-    SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,
+    SyntaxNode, SyntaxToken, T, TextRange, WalkEvent,
+    ast::{self, IsString},
 };
 
 use crate::{
+    FileId, HlMod, HlOperator, HlPunct, HlTag,
     syntax_highlighting::{
         escape::{highlight_escape_byte, highlight_escape_char, highlight_escape_string},
-        format::highlight_format_string,
-        highlights::Highlights,
-        tags::Highlight,
+        format::highlight_format_string, highlights::Highlights, tags::Highlight,
     },
-    FileId, HlMod, HlOperator, HlPunct, HlTag,
 };
 
 pub(crate) use html::highlight_as_html;
 
     let mut hl = highlights::Highlights::new(root.text_range());
     let krate = sema.scope(&root).map(|it| it.krate());
-    traverse(
-        &mut hl,
-        &sema,
-        config,
-        InRealFile::new(file_id, &root),
-        krate,
-        range_to_highlight,
-    );
+    traverse(&mut hl, &sema, config, InRealFile::new(file_id, &root), krate, range_to_highlight);
     hl.to_vec()
 }
 
     hl: &mut Highlights,
     sema: &Semantics<'_, RootDatabase>,
     config: &HighlightConfig<'_>,
-    InRealFile {
-        file_id,
-        value: root,
-    }: InRealFile<&SyntaxNode>,
+    InRealFile { file_id, value: root }: InRealFile<&SyntaxNode>,
     krate: Option<hir::Crate>,
     range_to_highlight: TextRange,
 ) {
     let mut attr_or_derive_item = None;
 
     // FIXME: these are not perfectly accurate, we determine them by the real file's syntax tree
+
     // an attribute nested in a macro call will not emit `inside_attribute`
     let mut inside_attribute = false;
 
         FxHashMap::default();
 
     // Walk all nodes, keeping track of whether we are inside a macro or not.
+
     // If in macro, expand it first and highlight the expanded code.
     let mut preorder = root.preorder_with_tokens();
     while let Some(event) = preorder.next() {
+        // Element outside of the viewport, no need to highlight
+        // Descending tokens into macros is expensive even if no descending occurs, so make sure
+        // that we actually are in a position where descending is possible.
+        // string highlight injections
         use WalkEvent::{Enter, Leave};
-
         let range = match &event {
             Enter(it) | Leave(it) => it.text_range(),
         };
-
-        // Element outside of the viewport, no need to highlight
         if range_to_highlight.intersect(range).is_none() {
             continue;
         }
-
         match event.clone() {
             Enter(NodeOrToken::Node(node)) if ast::TokenTree::can_cast(node.kind()) => {
                 tt_level += 1;
             {
                 match ast::Item::cast(node.clone()) {
                     Some(item) => {
-                        if attr_or_derive_item
-                            .as_ref()
-                            .is_some_and(|it| *it.item() == item)
-                        {
+                        if attr_or_derive_item.as_ref().is_some_and(|it| *it.item() == item) {
                             attr_or_derive_item = None;
                         }
                         if matches!(
             }
             _ => (),
         }
-
         let element = match event {
             Enter(NodeOrToken::Token(tok)) if tok.kind() == WHITESPACE => continue,
             Enter(it) => it,
                 continue;
             }
         };
-
         let element = match element.clone() {
             NodeOrToken::Node(n) => match ast::NameLike::cast(n) {
                 Some(n) => NodeOrToken::Node(n),
             NodeOrToken::Token(t) => NodeOrToken::Token(t),
         };
         let original_token = element.as_token().cloned();
-
-        // Descending tokens into macros is expensive even if no descending occurs, so make sure
-        // that we actually are in a position where descending is possible.
         let in_macro = tt_level > 0
             || match attr_or_derive_item {
                 Some(AttrOrDerive::Attr(_)) => true,
                 Some(AttrOrDerive::Derive(_)) => inside_attribute,
                 None => false,
             };
-
         let (descended_element, current_body) = match element {
             // Attempt to descend tokens into macro-calls.
             NodeOrToken::Token(token) if in_macro => {
                     NodeOrToken::Node(n) => {
                         sema.body_for(InFile::new(descended.file_id, n.syntax()))
                     }
-                    NodeOrToken::Token(t) => t
-                        .parent()
-                        .and_then(|it| sema.body_for(InFile::new(descended.file_id, &it))),
+                    NodeOrToken::Token(t) => {
+                        t.parent().and_then(|it| sema.body_for(InFile::new(descended.file_id, &it)))
+                    }
                 };
                 (descended, body)
             }
-            n => (
-                InFile::new(file_id.into(), n),
-                body_stack.last().copied().flatten(),
-            ),
+            n => (InFile::new(file_id.into(), n), body_stack.last().copied().flatten()),
         };
-        // string highlight injections
         if let (Some(original_token), Some(descended_token)) =
             (original_token, descended_element.value.as_token())
         {
                 continue;
             }
         }
-
         let edition = descended_element.file_id.edition(sema.db);
         let (unsafe_ops, bindings_shadow_count) = match current_body {
             Some(current_body) => {
             }),
         };
         if let Some((mut highlight, binding_hash)) = element {
+            // apply config filtering
             if is_unlinked && highlight.tag == HlTag::UnresolvedReference {
                 // do not emit unresolved references if the file is unlinked
                 // let the editor do its highlighting for these tokens instead
                 continue;
             }
-
-            // apply config filtering
             if !filter_by_config(&mut highlight, config) {
                 continue;
             }
-
             if inside_attribute {
                 highlight |= HlMod::Attribute
             }
                 }
                 highlight |= HlMod::Macro
             }
-
-            hl.add(HlRange {
-                range,
-                highlight,
-                binding_hash,
-            });
+            hl.add(HlRange { range, highlight, binding_hash });
         }
     }
 }