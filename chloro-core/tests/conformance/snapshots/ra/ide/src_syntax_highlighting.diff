COMPARISON DIFF
============================================================

Original size: 24849 bytes
Chloro size:   18602 bytes
Rustfmt size:  25118 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 pub(crate) mod tags;
-
 mod highlights;
-
 mod escape;
 mod format;
 mod highlight;
 mod inject;
-
 mod html;
 #[cfg(test)]
 mod tests;
 
 use either::Either;
 use hir::{DefWithBody, EditionedFileId, InFile, InRealFile, MacroKind, Name, Semantics};
+pub(crate) use html::highlight_as_html;
+pub(crate) use html::highlight_as_html_with_config;
 use ide_db::{FxHashMap, FxHashSet, MiniCore, Ranker, RootDatabase, SymbolKind};
 use syntax::{
     ast::{self, IsString},
-    AstNode, AstToken, NodeOrToken,
+    AstNode,
+    AstToken,
+    NodeOrToken,
     SyntaxKind::*,
-    SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,
+    SyntaxNode,
+    SyntaxToken,
+    TextRange,
+    WalkEvent,
+    T,
 };
 
 use crate::{
         highlights::Highlights,
         tags::Highlight,
     },
-    FileId, HlMod, HlOperator, HlPunct, HlTag,
+    FileId,
+    HlMod,
+    HlOperator,
+    HlPunct,
+    HlTag,
 };
 
-pub(crate) use html::highlight_as_html;
-pub(crate) use html::highlight_as_html_with_config;
-
 #[derive(Debug, Clone, Copy)]
 pub struct HlRange {
     pub range: TextRange,
     pub minicore: MiniCore<'a>,
 }
 
-// Feature: Semantic Syntax Highlighting
-//
-// rust-analyzer highlights the code semantically.
-// For example, `Bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.
-// rust-analyzer does not specify colors directly, instead it assigns a tag (like `struct`) and a set of modifiers (like `declaration`) to each token.
-// It's up to the client to map those to specific colors.
-//
-// The general rule is that a reference to an entity gets colored the same way as the entity itself.
-// We also give special modifier for `mut` and `&mut` local variables.
-//
-//
-// #### Token Tags
-//
-// Rust-analyzer currently emits the following token tags:
-//
-// - For items:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// | attribute |  Emitted for attribute macros. |
-// |enum| Emitted for enums. |
-// |function| Emitted for free-standing functions. |
-// |derive| Emitted for derive macros. |
-// |macro| Emitted for function-like macros. |
-// |method| Emitted for associated functions, also knowns as methods. |
-// |namespace| Emitted for modules. |
-// |struct| Emitted for structs.|
-// |trait| Emitted for traits.|
-// |typeAlias| Emitted for type aliases and `Self` in `impl`s.|
-// |union| Emitted for unions.|
-//
-// - For literals:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// | boolean|  Emitted for the boolean literals `true` and `false`.|
-// | character| Emitted for character literals.|
-// | number| Emitted for numeric literals.|
-// | string| Emitted for string literals.|
-// | escapeSequence| Emitted for escaped sequences inside strings like `\n`.|
-// | formatSpecifier| Emitted for format specifiers `{:?}` in `format!`-like macros.|
-//
-// - For operators:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// |operator| Emitted for general operators.|
-// |arithmetic| Emitted for the arithmetic operators `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`.|
-// |bitwise| Emitted for the bitwise operators `\|`, `&`, `!`, `^`, `\|=`, `&=`, `^=`.|
-// |comparison| Emitted for the comparison oerators `>`, `<`, `==`, `>=`, `<=`, `!=`.|
-// |logical| Emitted for the logical operators `\|\|`, `&&`, `!`.|
-//
-// - For punctuation:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// |punctuation| Emitted for general punctuation.|
-// |attributeBracket| Emitted for attribute invocation brackets, that is the `#[` and `]` tokens.|
-// |angle| Emitted for `<>` angle brackets.|
-// |brace| Emitted for `{}` braces.|
-// |bracket| Emitted for `[]` brackets.|
-// |parenthesis| Emitted for `()` parentheses.|
-// |colon| Emitted for the `:` token.|
-// |comma| Emitted for the `,` token.|
-// |dot| Emitted for the `.` token.|
-// |semi| Emitted for the `;` token.|
-// |macroBang| Emitted for the `!` token in macro calls.|
-//
-//-
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// |builtinAttribute| Emitted for names to builtin attributes in attribute path, the `repr` in `#[repr(u8)]` for example.|
-// |builtinType| Emitted for builtin types like `u32`, `str` and `f32`.|
-// |comment| Emitted for comments.|
-// |constParameter| Emitted for const parameters.|
-// |deriveHelper| Emitted for derive helper attributes.|
-// |enumMember| Emitted for enum variants.|
-// |generic| Emitted for generic tokens that have no mapping.|
-// |keyword| Emitted for keywords.|
-// |label| Emitted for labels.|
-// |lifetime| Emitted for lifetimes.|
-// |parameter| Emitted for non-self function parameters.|
-// |property| Emitted for struct and union fields.|
-// |selfKeyword| Emitted for the self function parameter and self path-specifier.|
-// |selfTypeKeyword| Emitted for the Self type parameter.|
-// |toolModule| Emitted for tool modules.|
-// |typeParameter| Emitted for type parameters.|
-// |unresolvedReference| Emitted for unresolved references, names that rust-analyzer can't find the definition of.|
-// |variable| Emitted for locals, constants and statics.|
-//
-//
-// #### Token Modifiers
-//
-// Token modifiers allow to style some elements in the source code more precisely.
-//
-// Rust-analyzer currently emits the following token modifiers:
-//
-// |           |                                |
-// |-----------|--------------------------------|
-// |async| Emitted for async functions and the `async` and `await` keywords.|
-// |attribute| Emitted for tokens inside attributes.|
-// |callable| Emitted for locals whose types implements one of the `Fn*` traits.|
-// |constant| Emitted for const.|
-// |consuming| Emitted for locals that are being consumed when use in a function call.|
-// |controlFlow| Emitted for control-flow related tokens, this includes th `?` operator.|
-// |crateRoot| Emitted for crate names, like `serde` and `crate`.|
-// |declaration| Emitted for names of definitions, like `foo` in `fn foo(){}`.|
-// |defaultLibrary| Emitted for items from built-in crates (std, core, alloc, test and proc_macro).|
-// |documentation| Emitted for documentation comment.|
-// |injected| Emitted for doc-string injected highlighting like rust source blocks in documentation.|
-// |intraDocLink| Emitted for intra doc links in doc-string.|
-// |library| Emitted for items that are defined outside of the current crate.|
-// |macro|  Emitted for tokens inside macro call.|
-// |mutable| Emitted for mutable locals and statics as well as functions taking `&mut self`.|
-// |public| Emitted for items that are from the current crate and are `pub`.|
-// |reference| Emitted for locals behind a reference and functions taking `self` by reference.|
-// |static| Emitted for "static" functions, also known as functions that do not take a `self` param, as well as statics and consts.|
-// |trait| Emitted for associated trait item.|
-// |unsafe| Emitted for unsafe operations, like unsafe function calls, as well as the `unsafe` token.|
-//
-// ![Semantic Syntax Highlighting](https://user-images.githubusercontent.com/48062697/113164457-06cfb980-9239-11eb-819b-0f93e646acf8.png)
-// ![Semantic Syntax Highlighting](https://user-images.githubusercontent.com/48062697/113187625-f7f50100-9250-11eb-825e-91c58f236071.png)
 pub(crate) fn highlight(
     db: &RootDatabase,
     config: &HighlightConfig<'_>,
     let file_id = sema
         .attach_first_edition(file_id)
         .unwrap_or_else(|| EditionedFileId::current_edition(db, file_id));
-
     // Determine the root based on the given range.
     let (root, range_to_highlight) = {
         let file = sema.parse(file_id);
             None => (source_file.clone(), source_file.text_range()),
         }
     };
-
     let mut hl = highlights::Highlights::new(root.text_range());
     let krate = sema.scope(&root).map(|it| it.krate());
-    traverse(
-        &mut hl,
-        &sema,
-        config,
-        InRealFile::new(file_id, &root),
-        krate,
-        range_to_highlight,
-    );
+    traverse(&mut hl, &sema, config, InRealFile::new(file_id, &root), krate, range_to_highlight);
     hl.to_vec()
 }
 
     hl: &mut Highlights,
     sema: &Semantics<'_, RootDatabase>,
     config: &HighlightConfig<'_>,
-    InRealFile {
-        file_id,
-        value: root,
-    }: InRealFile<&SyntaxNode>,
+    InRealFile { file_id, value: root }: InRealFile<&SyntaxNode>,
     krate: Option<hir::Crate>,
     range_to_highlight: TextRange,
 ) {
     let is_unlinked = sema.file_to_module_def(file_id.file_id(sema.db)).is_none();
-
     enum AttrOrDerive {
         Attr(ast::Item),
         Derive(ast::Item),
     }
-
     impl AttrOrDerive {
         fn item(&self) -> &ast::Item {
             match self {
             }
         }
     }
-
     let empty = FxHashSet::default();
-
     // FIXME: accommodate range highlighting
     let mut tt_level = 0;
     // FIXME: accommodate range highlighting
     let mut attr_or_derive_item = None;
-
     // FIXME: these are not perfectly accurate, we determine them by the real file's syntax tree
     // an attribute nested in a macro call will not emit `inside_attribute`
     let mut inside_attribute = false;
-
     // FIXME: accommodate range highlighting
     let mut body_stack: Vec<Option<DefWithBody>> = vec![];
     let mut per_body_cache: FxHashMap<DefWithBody, (FxHashSet<_>, FxHashMap<Name, u32>)> =
         FxHashMap::default();
-
     // Walk all nodes, keeping track of whether we are inside a macro or not.
     // If in macro, expand it first and highlight the expanded code.
     let mut preorder = root.preorder_with_tokens();
             {
                 match ast::Item::cast(node.clone()) {
                     Some(item) => {
-                        if attr_or_derive_item
-                            .as_ref()
-                            .is_some_and(|it| *it.item() == item)
-                        {
+                        if attr_or_derive_item.as_ref().is_some_and(|it| *it.item() == item) {
                             attr_or_derive_item = None;
                         }
                         if matches!(
                     NodeOrToken::Node(n) => {
                         sema.body_for(InFile::new(descended.file_id, n.syntax()))
                     }
-                    NodeOrToken::Token(t) => t
-                        .parent()
-                        .and_then(|it| sema.body_for(InFile::new(descended.file_id, &it))),
+                    NodeOrToken::Token(t) => {
+                        t.parent().and_then(|it| sema.body_for(InFile::new(descended.file_id, &it)))
+                    }
                 };
                 (descended, body)
             }
-            n => (
-                InFile::new(file_id.into(), n),
-                body_stack.last().copied().flatten(),
-            ),
+            n => (InFile::new(file_id.into(), n), body_stack.last().copied().flatten()),
         };
         // string highlight injections
         if let (Some(original_token), Some(descended_token)) =
                 highlight |= HlMod::Macro
             }
 
-            hl.add(HlRange {
-                range,
-                highlight,
-                binding_hash,
-            });
+            hl.add(HlRange { range, highlight, binding_hash });
         }
     }
 }
         return token.map(NodeOrToken::Token).into();
     }
     let ranker = Ranker::from_token(&token.value);
-
     let mut t = None;
     let mut r = 0;
     sema.descend_into_macros_breakable(token.clone().into(), |tok, _ctx| {
         }
         ControlFlow::Continue(())
     });
-
     let token = t.unwrap_or_else(|| token.into());
     token.map(|token| match token.parent().and_then(ast::NameLike::cast) {
         // Remap the token into the wrapping single token nodes
     })
 }
 
-fn filter_by_config(highlight: &mut Highlight, config: &HighlightConfig<'_>) -> bool {
+fn filter_by_config(
+    highlight: &mut Highlight,
+    config: &HighlightConfig<'_>,
+) -> bool {
     match &mut highlight.tag {
         HlTag::StringLiteral if !config.strings => return false,
         HlTag::Comment if !config.comments => return false,