COMPARISON DIFF
============================================================

Original size: 11061 bytes
Chloro size:   10731 bytes
Rustfmt size:  11278 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     pub nodes: Vec<MemoryLayoutNode>,
 }
 
-// NOTE: this is currently strictly for testing and so isn't super useful as a visualization tool, however it could be adapted to become one?
 impl fmt::Display for RecursiveMemoryLayout {
     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
         fn process(
     }
 }
 
-// Feature: View Memory Layout
-//
-// Displays the recursive memory layout of a datatype.
-//
-// | Editor  | Action Name |
-// |---------|-------------|
-// | VS Code | **rust-analyzer: View Memory Layout** |
 pub(crate) fn view_memory_layout(
     db: &RootDatabase,
     position: FilePosition,
     let sema = Semantics::new(db);
     let file = sema.parse_guess_edition(position.file_id);
     let display_target = sema.first_crate(position.file_id)?.to_display_target(db);
-    let token = pick_best_token(
-        file.syntax().token_at_offset(position.offset),
-        |kind| match kind {
+    let token = pick_best_token(file.syntax().token_at_offset(position.offset), |kind| match kind {
             SyntaxKind::IDENT => 3,
             _ => 0,
-        },
-    )?;
+        })?;
 
     let def = get_definition(&sema, token)?;
 
 
         for (i, (_, child_ty)) in fields.iter().enumerate() {
             if let Ok(child_layout) = child_ty.layout(db) {
-                read_layout(
-                    nodes,
-                    db,
-                    child_ty,
-                    &child_layout,
-                    children_start + i,
-                    display_target,
-                );
+                read_layout(nodes, db, child_ty, &child_layout, children_start + i, display_target);
             }
         }
     }
                 | Definition::SelfType(_) => "[ROOT]".to_owned(),
 
                 // def is an item
-                def => def
-                    .name(db)
-                    .map(|n| n.as_str().to_owned())
-                    .unwrap_or("[ROOT]".to_owned()),
+                def => def.name(db).map(|n| n.as_str().to_owned()).unwrap_or("[ROOT]".to_owned()),
             };
 
             let typename = ty.display(db, display_target).to_string();
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::fixture;
     use expect_test::expect;
-
     fn make_memory_layout(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
     ) -> Option<RecursiveMemoryLayout> {
 
         hir::attach_db(&analysis.db, || view_memory_layout(&analysis.db, position))
     }
-
     #[test]
     fn view_memory_layout_none() {
         assert!(make_memory_layout(r#"$0"#).is_none());
         assert!(make_memory_layout(r#"stru$0ct Blah {}"#).is_none());
     }
-
     #[test]
     fn view_memory_layout_primitive() {
         expect![[r#"
             foo: i32 (size: 4, align: 4, field offset: 0)
         "#]]
-        .assert_eq(
+            .assert_eq(
             &make_memory_layout(
                 r#"
 fn main() {
             .to_string(),
         );
     }
-
     #[test]
     fn view_memory_layout_constant() {
         expect![[r#"
             BLAH: bool (size: 1, align: 1, field offset: 0)
         "#]]
-        .assert_eq(
+            .assert_eq(
             &make_memory_layout(
                 r#"
 const BLAH$0: bool = 0;
             .to_string(),
         );
     }
-
     #[test]
     fn view_memory_layout_static() {
         expect![[r#"
             BLAH: bool (size: 1, align: 1, field offset: 0)
         "#]]
-        .assert_eq(
+            .assert_eq(
             &make_memory_layout(
                 r#"
 static BLAH$0: bool = 0;
             .to_string(),
         );
     }
-
     #[test]
     fn view_memory_layout_tuple() {
         expect![[r#"
             	.1: u8 (size: 1, align: 1, field offset: 8)
             	.2: i64 (size: 8, align: 8, field offset: 16)
         "#]]
-        .assert_eq(
+            .assert_eq(
             &make_memory_layout(
                 r#"
 fn main() {
             .to_string(),
         );
     }
-
     #[test]
     fn view_memory_layout_c_struct() {
         expect![[r#"
             		.1: u8 (size: 1, align: 1, field offset: 4)
             	c: i8 (size: 1, align: 1, field offset: 12)
         "#]]
-        .assert_eq(
+            .assert_eq(
             &make_memory_layout(
                 r#"
 #[repr(C)]
             .to_string(),
         );
     }
-
     #[test]
     fn view_memory_layout_struct() {
         expect![[r#"
             	a: u32 (size: 4, align: 4, field offset: 8)
             	c: i8 (size: 1, align: 1, field offset: 12)
         "#]]
-        .assert_eq(
+            .assert_eq(
             &make_memory_layout(
                 r#"
 struct Blah$0 {
             .to_string(),
         );
     }
-
     #[test]
     fn view_memory_layout_member() {
         expect![[r#"
             a: bool (size: 1, align: 1, field offset: 0)
         "#]]
-        .assert_eq(
+            .assert_eq(
             &make_memory_layout(
                 r#"
 #[repr(C)]
             .to_string(),
         );
     }
-
     #[test]
     fn view_memory_layout_alias() {
         let ml_a = make_memory_layout(
 type Foo$0 = X;
 "#,
         )
-        .unwrap();
+            .unwrap();
 
         let ml_b = make_memory_layout(
             r#"
 }
 "#,
         )
-        .unwrap();
+            .unwrap();
 
         assert_eq!(ml_a.to_string(), ml_b.to_string());
     }