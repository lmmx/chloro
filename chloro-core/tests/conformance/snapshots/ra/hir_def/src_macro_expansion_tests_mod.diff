COMPARISON DIFF
============================================================

Original size: 15554 bytes
Chloro size:   15367 bytes
Rustfmt size:  15554 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::RootQueryDb;
 use expect_test::Expect;
 use hir_expand::{
-    AstId, InFile, MacroCallId, MacroCallKind, MacroKind,
     builtin::quote::quote,
     db::ExpandDatabase,
     proc_macro::{ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacroKind},
     span_map::SpanMapRef,
+    AstId, InFile, MacroCallId, MacroCallKind, MacroKind,
 };
 use intern::{Symbol, sym};
 use itertools::Itertools;
 use span::{Edition, ROOT_ERASED_FILE_AST_ID, Span, SpanAnchor, SyntaxContext};
 use stdx::{format_to, format_to_acc};
 use syntax::{
+    ast::{edit::IndentLevel, self},
     AstNode, AstPtr,
     SyntaxKind::{COMMENT, EOF, IDENT, LIFETIME_IDENT},
     SyntaxNode, T,
-    ast::{self, edit::IndentLevel},
 };
 use syntax_bridge::token_tree_to_syntax_node;
 use test_fixture::WithFixture;
 use tt::{TextRange, TextSize};
 
 use crate::{
-    AdtId, Lookup, ModuleDefId,
     db::DefDatabase,
-    nameres::{DefMap, ModuleSource, crate_def_map},
+    nameres::{crate_def_map, DefMap, ModuleSource},
     src::HasSource,
     test_db::TestDB,
     tt::TopSubtree,
+    AdtId, Lookup, ModuleDefId,
 };
 
 #[track_caller]
             disabled: false,
         },
     )];
-
     fn resolve(
         db: &dyn DefDatabase,
         def_map: &DefMap,
             module.1.scope.macro_invoc(ast_id)
         })
     }
-
     let db = TestDB::with_files_extra_proc_macros(ra_fixture, extra_proc_macros);
     let krate = db.fetch_test_crate();
     let def_map = crate_def_map(&db, krate);
         ModuleSource::SourceFile(it) => it,
         ModuleSource::Module(_) | ModuleSource::BlockExpr(_) => panic!(),
     };
-
     let mut text_edits = Vec::new();
     let mut expansions = Vec::new();
-
     for macro_call_node in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {
         let ast_id = db.ast_id_map(source.file_id).ast_id(&macro_call_node);
         let ast_id = InFile::new(source.file_id, ast_id);
         let expansion_result = db.parse_macro_expansion(macro_call_id);
         expansions.push((macro_call_node.clone(), expansion_result));
     }
-
     for (call, exp) in expansions.into_iter().rev() {
         let mut tree = false;
         let mut expect_errors = false;
         let range: Range<usize> = range.into();
         text_edits.push((range, expn_text));
     }
-
     text_edits.sort_by_key(|(range, _)| range.start);
     text_edits.reverse();
     let mut expanded_text = source_file.to_string();
     for (range, text) in text_edits {
         expanded_text.replace_range(range, &text);
     }
-
     for decl_id in def_map[local_id].scope.declarations() {
         // FIXME: I'm sure there's already better way to do this
         let src = match decl_id {
             format_to!(expanded_text, "\n{}", pp)
         }
     }
-
     for impl_id in def_map[local_id].scope.impls() {
         let src = impl_id.lookup(&db).source(&db);
         if let Some(macro_file) = src.file_id.macro_file()
             format_to!(expanded_text, "\n{}", pp)
         }
     }
-
     expect.indent(false);
     expect.assert_eq(&expanded_text);
 }
     res
 }
 
-// Identity mapping, but only works when the input is syntactically valid. This
-// simulates common proc macros that unnecessarily parse their input and return
-// compile errors.
 #[derive(Debug)]
 struct IdentityWhenValidProcMacroExpander;
+
 impl ProcMacroExpander for IdentityWhenValidProcMacroExpander {
     fn expand(
         &self,