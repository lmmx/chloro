COMPARISON DIFF
============================================================

Original size: 15554 bytes
Chloro size:   15449 bytes
Rustfmt size:  15554 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::RootQueryDb;
 use expect_test::Expect;
 use hir_expand::{
-    AstId, InFile, MacroCallId, MacroCallKind, MacroKind,
     builtin::quote::quote,
+
     db::ExpandDatabase,
-    proc_macro::{ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacroKind},
+
+    proc_macro::{ProcMacro,
+
     span_map::SpanMapRef,
+
+    AstId, InFile, MacroCallId, MacroCallKind, MacroKind, ProcMacroExpander,
+    ProcMacroExpansionError, ProcMacroKind},
 };
 use intern::{Symbol, sym};
 use itertools::Itertools;
 use span::{Edition, ROOT_ERASED_FILE_AST_ID, Span, SpanAnchor, SyntaxContext};
 use stdx::{format_to, format_to_acc};
 use syntax::{
+    ast::{self,
+
+    edit::IndentLevel},
+
     AstNode, AstPtr,
-    SyntaxKind::{COMMENT, EOF, IDENT, LIFETIME_IDENT},
-    SyntaxNode, T,
-    ast::{self, edit::IndentLevel},
+
+    SyntaxKind::{COMMENT,
+
+    SyntaxNode, EOF, IDENT, LIFETIME_IDENT}, T,
 };
 use syntax_bridge::token_tree_to_syntax_node;
 use test_fixture::WithFixture;
 use tt::{TextRange, TextSize};
 
 use crate::{
-    AdtId, Lookup, ModuleDefId,
+    crate_def_map},
+
     db::DefDatabase,
-    nameres::{DefMap, ModuleSource, crate_def_map},
+
+    nameres::{DefMap,
+
     src::HasSource,
+
     test_db::TestDB,
+
     tt::TopSubtree,
+
+    AdtId, Lookup, ModuleDefId, ModuleSource,
 };
 
 #[track_caller]
-fn check_errors(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
+fn check_errors(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    expect: Expect,
+) {
     let db = TestDB::with_files(ra_fixture);
     let krate = db.fetch_test_crate();
     let def_map = crate_def_map(&db, krate);
     expect.assert_eq(&errors);
 }
 
-fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, mut expect: Expect) {
+fn check(
+    #[rust_analyzer::rust_fixture] ra_fixture: &str,
+    mut expect: Expect,
+) {
     let extra_proc_macros = vec![(
         r#"
 #[proc_macro_attribute]
             disabled: false,
         },
     )];
-
     fn resolve(
         db: &dyn DefDatabase,
         def_map: &DefMap,
             module.1.scope.macro_invoc(ast_id)
         })
     }
-
     let db = TestDB::with_files_extra_proc_macros(ra_fixture, extra_proc_macros);
     let krate = db.fetch_test_crate();
     let def_map = crate_def_map(&db, krate);
         ModuleSource::SourceFile(it) => it,
         ModuleSource::Module(_) | ModuleSource::BlockExpr(_) => panic!(),
     };
-
     let mut text_edits = Vec::new();
     let mut expansions = Vec::new();
-
     for macro_call_node in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {
         let ast_id = db.ast_id_map(source.file_id).ast_id(&macro_call_node);
         let ast_id = InFile::new(source.file_id, ast_id);
         let expansion_result = db.parse_macro_expansion(macro_call_id);
         expansions.push((macro_call_node.clone(), expansion_result));
     }
-
     for (call, exp) in expansions.into_iter().rev() {
         let mut tree = false;
         let mut expect_errors = false;
         let range: Range<usize> = range.into();
         text_edits.push((range, expn_text));
     }
-
     text_edits.sort_by_key(|(range, _)| range.start);
     text_edits.reverse();
     let mut expanded_text = source_file.to_string();
     for (range, text) in text_edits {
         expanded_text.replace_range(range, &text);
     }
-
     for decl_id in def_map[local_id].scope.declarations() {
         // FIXME: I'm sure there's already better way to do this
         let src = match decl_id {
             format_to!(expanded_text, "\n{}", pp)
         }
     }
-
     for impl_id in def_map[local_id].scope.impls() {
         let src = impl_id.lookup(&db).source(&db);
         if let Some(macro_file) = src.file_id.macro_file()
             format_to!(expanded_text, "\n{}", pp)
         }
     }
-
     expect.indent(false);
     expect.assert_eq(&expanded_text);
 }
 
-fn reindent(indent: IndentLevel, pp: String) -> String {
+fn reindent(
+    indent: IndentLevel,
+    pp: String,
+) -> String {
     if !pp.contains('\n') {
         return pp;
     }
     res
 }
 
-// Identity mapping, but only works when the input is syntactically valid. This
-// simulates common proc macros that unnecessarily parse their input and return
-// compile errors.
 #[derive(Debug)]
 struct IdentityWhenValidProcMacroExpander;
+
 impl ProcMacroExpander for IdentityWhenValidProcMacroExpander {
     fn expand(
         &self,
         }
     }
 
-    fn eq_dyn(&self, other: &dyn ProcMacroExpander) -> bool {
+    fn eq_dyn(
+        &self,
+        other: &dyn ProcMacroExpander,
+    ) -> bool {
         other.type_id() == TypeId::of::<Self>()
     }
 }