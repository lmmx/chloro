COMPARISON DIFF
============================================================

Original size: 144317 bytes
Chloro size:   144974 bytes
Rustfmt size:  151577 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     expr_store::{
         Body, BodySourceMap, ExprPtr, ExpressionStore, ExpressionStoreBuilder,
         ExpressionStoreDiagnostics, ExpressionStoreSourceMap, HygieneId, LabelPtr, LifetimePtr,
-        PatPtr, TypePtr,
-        expander::Expander,
-        lower::generics::ImplTraitLowerFn,
+        PatPtr, TypePtr, expander::Expander, lower::generics::ImplTraitLowerFn,
         path::{AssociatedTypeBinding, GenericArg, GenericArgs, GenericArgsParentheses, Path},
     },
     hir::{
     // with the inner macro, and that will cause confusion because they won't be the same as `ROOT`
     // even though they should be the same. Also, when the body comes from multiple expansions, their
     // hygiene is different.
-
     let mut self_param = None;
     let mut source_map_self_param = None;
     let mut params = vec![];
     // and skip the body.
     if skip_body {
         if let Some(param_list) = parameters {
-            if let Some(self_param_syn) = param_list
-                .self_param()
-                .filter(|self_param| collector.check_cfg(self_param))
+            if let Some(self_param_syn) =
+                param_list.self_param().filter(|self_param| collector.check_cfg(self_param))
             {
                 let is_mutable =
                     self_param_syn.mut_token().is_some() && self_param_syn.amp_token().is_none();
                 source_map_self_param =
                     Some(collector.expander.in_file(AstPtr::new(&self_param_syn)));
             }
-            let count = param_list
-                .params()
-                .filter(|it| collector.check_cfg(it))
-                .count();
+            let count = param_list.params().filter(|it| collector.check_cfg(it)).count();
             params = (0..count).map(|_| collector.missing_pat()).collect();
         };
         let body_expr = collector.missing_expr();
         let (store, source_map) = collector.store.finish();
         return (
-            Body {
-                store,
-                params: params.into_boxed_slice(),
-                self_param,
-                body_expr,
-            },
-            BodySourceMap {
-                self_param: source_map_self_param,
-                store: source_map,
-            },
+            Body { store, params: params.into_boxed_slice(), self_param, body_expr },
+            BodySourceMap { self_param: source_map_self_param, store: source_map },
         );
     }
 
 
     let (store, source_map) = collector.store.finish();
     (
-        Body {
-            store,
-            params: params.into_boxed_slice(),
-            self_param,
-            body_expr,
-        },
-        BodySourceMap {
-            self_param: source_map_self_param,
-            store: source_map,
-        },
+        Body { store, params: params.into_boxed_slice(), self_param, body_expr },
+        BodySourceMap { self_param: source_map_self_param, store: source_map },
     )
 }
 
     file_id: HirFileId,
     param_list: Option<ast::GenericParamList>,
     where_clause: Option<ast::WhereClause>,
-) -> (
-    Arc<ExpressionStore>,
-    Arc<GenericParams>,
-    ExpressionStoreSourceMap,
-) {
+) -> (Arc<ExpressionStore>, Arc<GenericParams>, ExpressionStoreSourceMap) {
     let mut expr_collector = ExprCollector::new(db, module, file_id);
     let mut collector = generics::GenericParamsCollector::new(def);
     collector.lower(&mut expr_collector, param_list, where_clause);
     module: ModuleId,
     impl_syntax: InFile<ast::Impl>,
     impl_id: ImplId,
-) -> (
-    ExpressionStore,
-    ExpressionStoreSourceMap,
-    TypeRefId,
-    Option<TraitRef>,
-    Arc<GenericParams>,
-) {
+) -> (ExpressionStore, ExpressionStoreSourceMap, TypeRefId, Option<TraitRef>, Arc<GenericParams>) {
     let mut expr_collector = ExprCollector::new(db, module, impl_syntax.file_id);
     let self_ty =
         expr_collector.lower_type_ref_opt_disallow_impl_trait(impl_syntax.value.self_ty());
         ast::Type::PathType(path_type) => {
             let path = expr_collector
                 .lower_path_type(path_type, &mut ExprCollector::impl_trait_allocator)?;
-            Some(TraitRef {
-                path: expr_collector.alloc_path(path, AstPtr::new(&it)),
-            })
+            Some(TraitRef { path: expr_collector.alloc_path(path, AstPtr::new(&it)) })
         }
         _ => None,
     });
     module: ModuleId,
     trait_syntax: InFile<ast::Trait>,
     trait_id: TraitId,
-) -> (
-    ExpressionStore,
-    ExpressionStoreSourceMap,
-    Arc<GenericParams>,
-) {
+) -> (ExpressionStore, ExpressionStoreSourceMap, Arc<GenericParams>) {
     let mut expr_collector = ExprCollector::new(db, module, trait_syntax.file_id);
     let mut collector = generics::GenericParamsCollector::with_self_param(
         &mut expr_collector,
 ) {
     let mut expr_collector = ExprCollector::new(db, module, fn_.file_id);
     let mut collector = generics::GenericParamsCollector::new(function_id.into());
-    collector.lower(
-        &mut expr_collector,
-        fn_.value.generic_param_list(),
-        fn_.value.where_clause(),
-    );
+    collector.lower(&mut expr_collector, fn_.value.generic_param_list(), fn_.value.where_clause());
     let mut params = vec![];
     let mut has_self_param = false;
     let mut has_variadic = false;
             ),
             bounds: Box::default(),
         };
-        generic_args.push(Some(GenericArgs {
-            bindings: Box::new([binding]),
-            ..GenericArgs::empty()
-        }));
+        generic_args
+            .push(Some(GenericArgs { bindings: Box::new([binding]), ..GenericArgs::empty() }));
 
         let path = Path::from_known_path(path, generic_args);
         let path = PathId::from_type_ref_unchecked(
     local_def_map: &'db LocalDefMap,
     module: ModuleId,
     pub store: ExpressionStoreBuilder,
-
     // state stuff
     // Prevent nested impl traits like `impl Foo<impl Bar>`.
     outer_impl_trait: bool,
-
     is_lowering_coroutine: bool,
-
     /// Legacy (`macro_rules!`) macros can have multiple definitions and shadow each other,
     /// and we need to find the current definition. So we track the number of definitions we saw.
     current_block_legacy_macro_defs_count: FxHashMap<Name, usize>,
-
     current_try_block_label: Option<LabelId>,
-
     label_ribs: Vec<LabelRib>,
     current_binding_owner: Option<ExprId>,
-
     awaitable_context: Option<Awaitable>,
 }
 
                 return self.lower_type_ref_opt(inner.ty(), impl_trait_lower_fn);
             }
             ast::Type::TupleType(inner) => TypeRef::Tuple(ThinVec::from_iter(Vec::from_iter(
-                inner
-                    .fields()
-                    .map(|it| self.lower_type_ref(it, impl_trait_lower_fn)),
+                inner.fields().map(|it| self.lower_type_ref(it, impl_trait_lower_fn)),
             ))),
             ast::Type::NeverType(..) => TypeRef::Never,
             ast::Type::PathType(inner) => inner
                 let inner_ty = self.lower_type_ref_opt(inner.ty(), impl_trait_lower_fn);
                 let lifetime = inner.lifetime().map(|lt| self.lower_lifetime_ref(lt));
                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());
-                TypeRef::Reference(Box::new(RefType {
-                    ty: inner_ty,
-                    lifetime,
-                    mutability,
-                }))
+                TypeRef::Reference(Box::new(RefType { ty: inner_ty, lifetime, mutability }))
             }
             ast::Type::InferType(_inner) => TypeRef::Placeholder,
             ast::Type::FnPtrType(inner) => {
                             let type_ref = self.lower_type_ref_opt(it.ty(), impl_trait_lower_fn);
                             let name = match it.pat() {
                                 Some(ast::Pat::IdentPat(it)) => Some(
-                                    it.name()
-                                        .map(|nr| nr.as_name())
-                                        .unwrap_or_else(Name::missing),
+                                    it.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing),
                                 ),
                                 _ => None,
                             };
                             } else {
                                 Box::default()
                             };
-                            bindings.push(AssociatedTypeBinding {
-                                name,
-                                args,
-                                type_ref,
-                                bounds,
-                            });
+                            bindings.push(AssociatedTypeBinding { name, args, type_ref, bounds });
                         });
                     }
                 }
 
     fn collect(&mut self, expr: Option<ast::Expr>, awaitable: Awaitable) -> ExprId {
         self.awaitable_context.replace(awaitable);
-        self.with_label_rib(RibKind::Closure, |this| {
+        self.with_label_rib(
+            RibKind::Closure,
+            |this| {
             if awaitable == Awaitable::Yes {
                 match expr {
                     Some(e) => {
                         let syntax_ptr = AstPtr::new(&e);
                         let expr = this.collect_expr(e);
                         this.alloc_expr_desugared_with_ptr(
-                            Expr::Async {
-                                id: None,
-                                statements: Box::new([]),
-                                tail: Some(expr),
-                            },
+                            Expr::Async { id: None, statements: Box::new([]), tail: Some(expr) },
                             syntax_ptr,
                         )
                     }
             } else {
                 this.collect_expr_opt(expr)
             }
-        })
+        },
+        )
     }
 
     fn type_bounds_from_ast(
     ) -> ThinVec<TypeBound> {
         if let Some(type_bounds) = type_bounds_opt {
             ThinVec::from_iter(Vec::from_iter(
-                type_bounds
-                    .bounds()
-                    .map(|it| self.lower_type_bound(it, impl_trait_lower_fn)),
+                type_bounds.bounds().map(|it| self.lower_type_bound(it, impl_trait_lower_fn)),
             ))
         } else {
             ThinVec::from_iter([])
     }
 
     fn lower_const_arg_opt(&mut self, arg: Option<ast::ConstArg>) -> ConstRef {
-        ConstRef {
-            expr: self.collect_expr_opt(arg.and_then(|it| it.expr())),
-        }
+        ConstRef { expr: self.collect_expr_opt(arg.and_then(|it| it.expr())) }
     }
 
     fn lower_const_arg(&mut self, arg: ast::ConstArg) -> ConstRef {
-        ConstRef {
-            expr: self.collect_expr_opt(arg.expr()),
-        }
+        ConstRef { expr: self.collect_expr_opt(arg.expr()) }
     }
 
     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {
-        self.maybe_collect_expr(expr)
-            .unwrap_or_else(|| self.missing_expr())
+        self.maybe_collect_expr(expr).unwrap_or_else(|| self.missing_expr())
     }
 
     /// Returns `None` if and only if the expression is `#[cfg]`d out.
 
                 let condition = self.collect_expr_opt(e.condition());
 
-                self.alloc_expr(
-                    Expr::If {
-                        condition,
-                        then_branch,
-                        else_branch,
-                    },
-                    syntax_ptr,
-                )
+                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)
             }
             ast::Expr::LetExpr(e) => {
                 let pat = self.collect_pat_top(e.pat());
             ast::Expr::BlockExpr(e) => match e.modifier() {
                 Some(ast::BlockModifier::Try(_)) => self.desugar_try_block(e),
                 Some(ast::BlockModifier::Unsafe(_)) => {
-                    self.collect_block_(e, |id, statements, tail| Expr::Unsafe {
+                    self.collect_block_(
+                        e,
+                        |id, statements, tail| Expr::Unsafe {
                         id,
                         statements,
                         tail,
-                    })
+                    },
+                    )
                 }
                 Some(ast::BlockModifier::Label(label)) => {
                     let label_hygiene = self.hygiene_id_for(label.syntax().text_range());
                     let label_id = self.collect_label(label);
-                    self.with_labeled_rib(label_id, label_hygiene, |this| {
+                    self.with_labeled_rib(
+                        label_id,
+                        label_hygiene,
+                        |this| {
                         this.collect_block_(e, |id, statements, tail| Expr::Block {
                             id,
                             statements,
                             tail,
                             label: Some(label_id),
                         })
-                    })
+                    },
+                    )
                 }
                 Some(ast::BlockModifier::Async(_)) => {
-                    self.with_label_rib(RibKind::Closure, |this| {
+                    self.with_label_rib(
+                        RibKind::Closure,
+                        |this| {
                         this.with_awaitable_block(Awaitable::Yes, |this| {
                             this.collect_block_(e, |id, statements, tail| Expr::Async {
                                 id,
                                 tail,
                             })
                         })
-                    })
+                    },
+                    )
                 }
                 Some(ast::BlockModifier::Const(_)) => {
-                    self.with_label_rib(RibKind::Constant, |this| {
+                    self.with_label_rib(
+                        RibKind::Constant,
+                        |this| {
                         this.with_awaitable_block(Awaitable::No("constant block"), |this| {
                             let (result_expr_id, prev_binding_owner) =
                                 this.initialize_binding_owner(syntax_ptr);
                             this.current_binding_owner = prev_binding_owner;
                             result_expr_id
                         })
-                    })
+                    },
+                    )
                 }
                 // FIXME
                 Some(ast::BlockModifier::AsyncGen(_)) => {
                     self.with_awaitable_block(Awaitable::Yes, |this| this.collect_block(e))
                 }
-                Some(ast::BlockModifier::Gen(_)) => self
-                    .with_awaitable_block(Awaitable::No("non-async gen block"), |this| {
+                Some(ast::BlockModifier::Gen(_)) => self.with_awaitable_block(
+                    Awaitable::No("non-async gen block"),
+                    |this| {
                         this.collect_block(e)
-                    }),
+                    },
+                ),
                 None => self.collect_block(e),
             },
             ast::Expr::LoopExpr(e) => {
                 let label = e.label().map(|label| {
-                    (
-                        self.hygiene_id_for(label.syntax().text_range()),
-                        self.collect_label(label),
-                    )
+                    (self.hygiene_id_for(label.syntax().text_range()), self.collect_label(label))
                 });
                 let body = self.collect_labelled_block_opt(label, e.loop_body());
-                self.alloc_expr(
-                    Expr::Loop {
-                        body,
-                        label: label.map(|it| it.1),
-                    },
-                    syntax_ptr,
-                )
+                self.alloc_expr(Expr::Loop { body, label: label.map(|it| it.1) }, syntax_ptr)
             }
             ast::Expr::WhileExpr(e) => self.collect_while_loop(syntax_ptr, e),
             ast::Expr::ForExpr(e) => self.collect_for_loop(syntax_ptr, e),
                 // FIXME: Remove this once we drop support for <1.86, https://github.com/rust-lang/rust/commit/ac9cb908ac4301dfc25e7a2edee574320022ae2c
                 let is_rustc_box = {
                     let attrs = e.attrs();
-                    attrs
-                        .filter_map(|it| it.as_simple_atom())
-                        .any(|it| it == "rustc_box")
+                    attrs.filter_map(|it| it.as_simple_atom()).any(|it| it == "rustc_box")
                 };
                 if is_rustc_box {
                     let expr = self.collect_expr_opt(e.arg_list().and_then(|it| it.args().next()));
                 } else {
                     let callee = self.collect_expr_opt(e.expr());
                     let args = if let Some(arg_list) = e.arg_list() {
-                        arg_list
-                            .args()
-                            .filter_map(|e| self.maybe_collect_expr(e))
-                            .collect()
+                        arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()
                     } else {
                         Box::default()
                     };
             ast::Expr::MethodCallExpr(e) => {
                 let receiver = self.collect_expr_opt(e.receiver());
                 let args = if let Some(arg_list) = e.arg_list() {
-                    arg_list
-                        .args()
-                        .filter_map(|e| self.maybe_collect_expr(e))
-                        .collect()
+                    arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()
                 } else {
                     Box::default()
                 };
-                let method_name = e
-                    .name_ref()
-                    .map(|nr| nr.as_name())
-                    .unwrap_or_else(Name::missing);
+                let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);
                 let generic_args = e
                     .generic_arg_list()
                     .and_then(|it| {
                     })
                     .map(Box::new);
                 self.alloc_expr(
-                    Expr::MethodCall {
-                        receiver,
-                        method_name,
-                        args,
-                        generic_args,
-                    },
+                    Expr::MethodCall { receiver, method_name, args, generic_args },
                     syntax_ptr,
                 )
             }
                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)
             }
             ast::Expr::BecomeExpr(e) => {
-                let expr = e
-                    .expr()
-                    .map(|e| self.collect_expr(e))
-                    .unwrap_or_else(|| self.missing_expr());
+                let expr =
+                    e.expr().map(|e| self.collect_expr(e)).unwrap_or_else(|| self.missing_expr());
                 self.alloc_expr(Expr::Become { expr }, syntax_ptr)
             }
             ast::Expr::YieldExpr(e) => {
                         })
                         .collect();
                     let spread = nfl.spread().map(|s| self.collect_expr(s));
-                    Expr::RecordLit {
-                        path,
-                        fields,
-                        spread,
-                    }
+                    Expr::RecordLit { path, fields, spread }
                 } else {
-                    Expr::RecordLit {
-                        path,
-                        fields: Box::default(),
-                        spread: None,
-                    }
+                    Expr::RecordLit { path, fields: Box::default(), spread: None }
                 };
 
                 self.alloc_expr(record_lit, syntax_ptr)
             ast::Expr::AwaitExpr(e) => {
                 let expr = self.collect_expr_opt(e.expr());
                 if let Awaitable::No(location) = self.is_lowering_awaitable_block() {
-                    self.store
-                        .diagnostics
-                        .push(ExpressionStoreDiagnostics::AwaitOutsideOfAsync {
-                            node: self.expander.in_file(AstPtr::new(&e)),
-                            location: location.to_string(),
-                        });
+                    self.store.diagnostics.push(ExpressionStoreDiagnostics::AwaitOutsideOfAsync {
+                        node: self.expander.in_file(AstPtr::new(&e)),
+                        location: location.to_string(),
+                    });
                 }
                 self.alloc_expr(Expr::Await { expr }, syntax_ptr)
             }
                 let expr = self.collect_expr_opt(e.expr());
                 let raw_tok = e.raw_token().is_some();
                 let mutability = if raw_tok {
-                    if e.mut_token().is_some() {
-                        Mutability::Mut
-                    } else {
-                        Mutability::Shared
-                    }
+                    if e.mut_token().is_some() { Mutability::Mut } else { Mutability::Shared }
                 } else {
                     Mutability::from_mutable(e.mut_token().is_some())
                 };
                 let rawness = Rawness::from_raw(raw_tok);
-                self.alloc_expr(
-                    Expr::Ref {
-                        expr,
-                        rawness,
-                        mutability,
-                    },
-                    syntax_ptr,
-                )
+                self.alloc_expr(Expr::Ref { expr, rawness, mutability }, syntax_ptr)
             }
             ast::Expr::PrefixExpr(e) => {
                 let expr = self.collect_expr_opt(e.expr());
                     None => self.alloc_expr(Expr::Missing, syntax_ptr),
                 }
             }
-            ast::Expr::ClosureExpr(e) => self.with_label_rib(RibKind::Closure, |this| {
+            ast::Expr::ClosureExpr(e) => self.with_label_rib(
+                RibKind::Closure,
+                |this| {
                 let (result_expr_id, prev_binding_owner) =
                     this.initialize_binding_owner(syntax_ptr);
                 let mut args = Vec::new();
                     arg_types.reserve_exact(num_params);
                     for param in pl.params() {
                         let pat = this.collect_pat_top(param.pat());
-                        let type_ref = param
-                            .ty()
-                            .map(|it| this.lower_type_ref_disallow_impl_trait(it));
+                        let type_ref =
+                            param.ty().map(|it| this.lower_type_ref_disallow_impl_trait(it));
                         args.push(pat);
                         arg_types.push(type_ref);
                     }
                 } else {
                     ClosureKind::Closure
                 };
-                let capture_by = if e.move_token().is_some() {
-                    CaptureBy::Value
-                } else {
-                    CaptureBy::Ref
-                };
+                let capture_by =
+                    if e.move_token().is_some() { CaptureBy::Value } else { CaptureBy::Ref };
                 this.is_lowering_coroutine = prev_is_lowering_coroutine;
                 this.current_binding_owner = prev_binding_owner;
                 this.current_try_block_label = prev_try_block_label;
                     capture_by,
                 };
                 result_expr_id
-            }),
+            },
+            ),
             ast::Expr::BinExpr(e) => {
                 let op = e.op_kind();
                 if let Some(ast::BinaryOp::Assignment { op: None }) = op {
                     exprs.insert(0, self.missing_expr());
                 }
 
-                self.alloc_expr(
-                    Expr::Tuple {
-                        exprs: exprs.into_boxed_slice(),
-                    },
-                    syntax_ptr,
-                )
+                self.alloc_expr(Expr::Tuple { exprs: exprs.into_boxed_slice() }, syntax_ptr)
             }
             ast::Expr::ArrayExpr(e) => {
                 let kind = e.kind();
                         let elements = e.map(|expr| self.collect_expr(expr)).collect();
                         self.alloc_expr(Expr::Array(Array::ElementList { elements }), syntax_ptr)
                     }
-                    ArrayExprKind::Repeat {
-                        initializer,
-                        repeat,
-                    } => {
+                    ArrayExprKind::Repeat { initializer, repeat } => {
                         let initializer = self.collect_expr_opt(initializer);
                         let repeat = self.with_label_rib(RibKind::Constant, |this| {
                             if let Some(repeat) = repeat {
                             }
                         });
                         self.alloc_expr(
-                            Expr::Array(Array::Repeat {
-                                initializer,
-                                repeat,
-                            }),
+                            Expr::Array(Array::Repeat { initializer, repeat }),
                             syntax_ptr,
                         )
                     }
                 let lhs = e.start().map(|lhs| self.collect_expr(lhs));
                 let rhs = e.end().map(|rhs| self.collect_expr(rhs));
                 match e.op_kind() {
-                    Some(range_type) => self.alloc_expr(
-                        Expr::Range {
-                            lhs,
-                            rhs,
-                            range_type,
-                        },
-                        syntax_ptr,
-                    ),
+                    Some(range_type) => {
+                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr)
+                    }
                     None => self.alloc_expr(Expr::Missing, syntax_ptr),
                 }
             }
                     && range.is_range_full()
                 {
                     return Some(self.alloc_pat_from_expr(
-                        Pat::Tuple {
-                            args: Box::default(),
-                            ellipsis: Some(0),
-                        },
+                        Pat::Tuple { args: Box::default(), ellipsis: Some(0) },
                         syntax_ptr,
                     ));
                 }
-                return e
-                    .expr()
-                    .and_then(|expr| self.maybe_collect_expr_as_pat(&expr));
+                return e.expr().and_then(|expr| self.maybe_collect_expr_as_pat(&expr));
             }
             ast::Expr::TupleExpr(e) => {
                 let (ellipsis, args) = collect_tuple(self, e.fields());
                     .by_ref()
                     .map_while(|elem| collect_possibly_rest(self, elem).left())
                     .collect();
-                let suffix = elements
-                    .map(|elem| self.collect_expr_as_pat(elem))
-                    .collect();
-                self.alloc_pat_from_expr(
-                    Pat::Slice {
-                        prefix,
-                        slice: None,
-                        suffix,
-                    },
-                    syntax_ptr,
-                )
+                let suffix = elements.map(|elem| self.collect_expr_as_pat(elem)).collect();
+                self.alloc_pat_from_expr(Pat::Slice { prefix, slice: None, suffix }, syntax_ptr)
             }
             ast::Expr::CallExpr(e) => {
                 let path = collect_path(self, e.expr()?)?;
                     .and_then(|path| self.lower_path(path, &mut Self::impl_trait_error_allocator))
                     .map(Box::new);
                 let (ellipsis, args) = collect_tuple(self, e.arg_list()?.args());
-                self.alloc_pat_from_expr(
-                    Pat::TupleStruct {
-                        path,
-                        args,
-                        ellipsis,
-                    },
-                    syntax_ptr,
-                )
+                self.alloc_pat_from_expr(Pat::TupleStruct { path, args, ellipsis }, syntax_ptr)
             }
             ast::Expr::PathExpr(e) => {
                 let (path, hygiene) = self
                         Some(RecordFieldPat { name, pat })
                     })
                     .collect();
-                self.alloc_pat_from_expr(
-                    Pat::Record {
-                        path,
-                        args,
-                        ellipsis,
-                    },
-                    syntax_ptr,
-                )
+                self.alloc_pat_from_expr(Pat::Record { path, args, ellipsis }, syntax_ptr)
             }
             _ => return None,
         };
             let mut btail = None;
             let block = this.collect_block_(e, |id, statements, tail| {
                 btail = tail;
-                Expr::Block {
-                    id,
-                    statements,
-                    tail,
-                    label: Some(label),
-                }
+                Expr::Block { id, statements, tail, label: Some(label) }
             });
             (btail, block)
         });
         let callee = self
             .alloc_expr_desugared_with_ptr(try_from_output.map_or(Expr::Missing, Expr::Path), ptr);
         let next_tail = match btail {
-            Some(tail) => self.alloc_expr_desugared_with_ptr(
-                Expr::Call {
-                    callee,
-                    args: Box::new([tail]),
-                },
-                ptr,
-            ),
+            Some(tail) => self
+                .alloc_expr_desugared_with_ptr(Expr::Call { callee, args: Box::new([tail]) }, ptr),
             None => {
-                let unit = self.alloc_expr_desugared_with_ptr(
-                    Expr::Tuple {
-                        exprs: Box::new([]),
-                    },
-                    ptr,
-                );
+                let unit =
+                    self.alloc_expr_desugared_with_ptr(Expr::Tuple { exprs: Box::new([]) }, ptr);
                 self.alloc_expr_desugared_with_ptr(
-                    Expr::Call {
-                        callee,
-                        args: Box::new([unit]),
-                    },
+                    Expr::Call { callee, args: Box::new([unit]) },
                     ptr,
                 )
             }
     /// to preserve drop semantics. We should probably do the same in future.
     fn collect_while_loop(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::WhileExpr) -> ExprId {
         let label = e.label().map(|label| {
-            (
-                self.hygiene_id_for(label.syntax().text_range()),
-                self.collect_label(label),
-            )
+            (self.hygiene_id_for(label.syntax().text_range()), self.collect_label(label))
         });
         let body = self.collect_labelled_block_opt(label, e.loop_body());
 
             None => self.collect_expr_opt(e.condition()),
         };
 
-        let break_expr = self.alloc_expr(
-            Expr::Break {
-                expr: None,
-                label: None,
-            },
-            syntax_ptr,
-        );
+        let break_expr = self.alloc_expr(Expr::Break { expr: None, label: None }, syntax_ptr);
         let if_expr = self.alloc_expr(
-            Expr::If {
-                condition,
-                then_branch: body,
-                else_branch: Some(break_expr),
-            },
+            Expr::If { condition, then_branch: body, else_branch: Some(break_expr) },
             syntax_ptr,
         );
         self.alloc_expr(
             Expr::Loop {
-                body: if_expr,
-                label: label.map(|it| it.1),
-            },
+            body: if_expr,
+            label: label.map(|it| it.1),
+        },
             syntax_ptr,
         )
     }
         let into_iter_fn_expr =
             self.alloc_expr(into_iter_fn.map_or(Expr::Missing, Expr::Path), syntax_ptr);
         let iterator = self.alloc_expr(
-            Expr::Call {
-                callee: into_iter_fn_expr,
-                args: Box::new([head]),
-            },
+            Expr::Call { callee: into_iter_fn_expr, args: Box::new([head]) },
             syntax_ptr,
         );
         let none_arm = MatchArm {
             pat: self.alloc_pat_desugared(option_none.map_or(Pat::Missing, Pat::Path)),
             guard: None,
-            expr: self.alloc_expr(
-                Expr::Break {
-                    expr: None,
-                    label: None,
-                },
-                syntax_ptr,
-            ),
+            expr: self.alloc_expr(Expr::Break { expr: None, label: None }, syntax_ptr),
         };
         let some_pat = Pat::TupleStruct {
             path: option_some.map(Box::new),
             ellipsis: None,
         };
         let label = e.label().map(|label| {
-            (
-                self.hygiene_id_for(label.syntax().text_range()),
-                self.collect_label(label),
-            )
+            (self.hygiene_id_for(label.syntax().text_range()), self.collect_label(label))
         });
         let some_arm = MatchArm {
             pat: self.alloc_pat_desugared(some_pat),
         let iter_name = Name::generate_new_name(self.store.exprs.len());
         let iter_expr = self.alloc_expr(Expr::Path(Path::from(iter_name.clone())), syntax_ptr);
         let iter_expr_mut = self.alloc_expr(
-            Expr::Ref {
-                expr: iter_expr,
-                rawness: Rawness::Ref,
-                mutability: Mutability::Mut,
-            },
+            Expr::Ref { expr: iter_expr, rawness: Rawness::Ref, mutability: Mutability::Mut },
             syntax_ptr,
         );
         let iter_next_fn_expr =
             self.alloc_expr(iter_next_fn.map_or(Expr::Missing, Expr::Path), syntax_ptr);
         let iter_next_expr = self.alloc_expr(
-            Expr::Call {
-                callee: iter_next_fn_expr,
-                args: Box::new([iter_expr_mut]),
-            },
+            Expr::Call { callee: iter_next_fn_expr, args: Box::new([iter_expr_mut]) },
             syntax_ptr,
         );
         let loop_inner = self.alloc_expr(
-            Expr::Match {
-                expr: iter_next_expr,
-                arms: Box::new([none_arm, some_arm]),
-            },
+            Expr::Match { expr: iter_next_expr, arms: Box::new([none_arm, some_arm]) },
             syntax_ptr,
         );
         let loop_inner = self.alloc_expr(
             },
             syntax_ptr,
         );
-        let loop_outer = self.alloc_expr(
-            Expr::Loop {
-                body: loop_inner,
-                label: label.map(|it| it.1),
-            },
-            syntax_ptr,
-        );
+        let loop_outer = self
+            .alloc_expr(Expr::Loop { body: loop_inner, label: label.map(|it| it.1) }, syntax_ptr);
         let iter_binding =
             self.alloc_binding(iter_name, BindingAnnotation::Mutable, HygieneId::ROOT);
-        let iter_pat = self.alloc_pat_desugared(Pat::Bind {
-            id: iter_binding,
-            subpat: None,
-        });
+        let iter_pat = self.alloc_pat_desugared(Pat::Bind { id: iter_binding, subpat: None });
         self.add_definition_to_binding(iter_binding, iter_pat);
         self.alloc_expr(
             Expr::Match {
-                expr: iterator,
-                arms: Box::new([MatchArm {
-                    pat: iter_pat,
-                    guard: None,
-                    expr: loop_outer,
-                }]),
+            expr: iterator,
+            arms: Box::new([
+                MatchArm {
+                pat: iter_pat,
+                guard: None,
+                expr: loop_outer,
             },
+            ]),
+        },
             syntax_ptr,
         )
     }
         let try_from_residual = self.lang_path(LangItem::TryTraitFromResidual);
         let operand = self.collect_expr_opt(e.expr());
         let try_branch = self.alloc_expr(try_branch.map_or(Expr::Missing, Expr::Path), syntax_ptr);
-        let expr = self.alloc_expr(
-            Expr::Call {
-                callee: try_branch,
-                args: Box::new([operand]),
-            },
-            syntax_ptr,
-        );
+        let expr = self
+            .alloc_expr(Expr::Call { callee: try_branch, args: Box::new([operand]) }, syntax_ptr);
         let continue_name = Name::generate_new_name(self.store.bindings.len());
         let continue_binding = self.alloc_binding(
             continue_name.clone(),
             BindingAnnotation::Unannotated,
             HygieneId::ROOT,
         );
-        let continue_bpat = self.alloc_pat_desugared(Pat::Bind {
-            id: continue_binding,
-            subpat: None,
-        });
+        let continue_bpat =
+            self.alloc_pat_desugared(Pat::Bind { id: continue_binding, subpat: None });
         self.add_definition_to_binding(continue_binding, continue_bpat);
         let continue_arm = MatchArm {
             pat: self.alloc_pat_desugared(Pat::TupleStruct {
             expr: self.alloc_expr(Expr::Path(Path::from(continue_name)), syntax_ptr),
         };
         let break_name = Name::generate_new_name(self.store.bindings.len());
-        let break_binding = self.alloc_binding(
-            break_name.clone(),
-            BindingAnnotation::Unannotated,
-            HygieneId::ROOT,
-        );
-        let break_bpat = self.alloc_pat_desugared(Pat::Bind {
-            id: break_binding,
-            subpat: None,
-        });
+        let break_binding =
+            self.alloc_binding(break_name.clone(), BindingAnnotation::Unannotated, HygieneId::ROOT);
+        let break_bpat = self.alloc_pat_desugared(Pat::Bind { id: break_binding, subpat: None });
         self.add_definition_to_binding(break_binding, break_bpat);
         let break_arm = MatchArm {
             pat: self.alloc_pat_desugared(Pat::TupleStruct {
             guard: None,
             expr: {
                 let it = self.alloc_expr(Expr::Path(Path::from(break_name)), syntax_ptr);
-                let callee = self.alloc_expr(
-                    try_from_residual.map_or(Expr::Missing, Expr::Path),
-                    syntax_ptr,
-                );
-                let result = self.alloc_expr(
-                    Expr::Call {
-                        callee,
-                        args: Box::new([it]),
-                    },
-                    syntax_ptr,
-                );
+                let callee = self
+                    .alloc_expr(try_from_residual.map_or(Expr::Missing, Expr::Path), syntax_ptr);
+                let result =
+                    self.alloc_expr(Expr::Call { callee, args: Box::new([it]) }, syntax_ptr);
                 self.alloc_expr(
                     match self.current_try_block_label {
-                        Some(label) => Expr::Break {
-                            expr: Some(result),
-                            label: Some(label),
-                        },
+                        Some(label) => Expr::Break { expr: Some(result), label: Some(label) },
                         None => Expr::Return { expr: Some(result) },
                     },
                     syntax_ptr,
         let macro_call_ptr = self.expander.in_file(syntax_ptr);
         let module = self.module.local_id;
 
-        let block_call = self.def_map.modules[self.module.local_id]
-            .scope
-            .macro_invoc(
-                self.expander
-                    .in_file(self.expander.ast_id_map().ast_id_for_ptr(syntax_ptr)),
-            );
+        let block_call = self.def_map.modules[self.module.local_id].scope.macro_invoc(
+            self.expander.in_file(self.expander.ast_id_map().ast_id_for_ptr(syntax_ptr)),
+        );
         let res = match block_call {
             // fast path, macro call is in a block module
             Some(call) => Ok(self.expander.enter_expand_id(self.db, call)),
             Ok(res) => res,
             Err(UnresolvedMacro { path }) => {
                 if record_diagnostics {
-                    self.store
-                        .diagnostics
-                        .push(ExpressionStoreDiagnostics::UnresolvedMacroCall {
-                            node: self.expander.in_file(syntax_ptr),
-                            path,
-                        });
+                    self.store.diagnostics.push(ExpressionStoreDiagnostics::UnresolvedMacroCall {
+                        node: self.expander.in_file(syntax_ptr),
+                        path,
+                    });
                 }
                 return collector(self, None);
             }
         };
-        // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
 
+        // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
         match res.value {
             Some((mark, expansion)) => {
                 // Keep collecting even with expansion errors so we can provide completions and
             false,
             |this, expansion: Option<ast::MacroStmts>| match expansion {
                 Some(expansion) => {
-                    expansion
-                        .statements()
-                        .for_each(|stmt| this.collect_stmt(statements, stmt));
+                    expansion.statements().for_each(|stmt| this.collect_stmt(statements, stmt));
                     expansion.expr().and_then(|expr| match expr {
                         ast::Expr::MacroExpr(mac) => this.collect_macro_as_stmt(statements, mac),
                         expr => Some(this.collect_expr(expr)),
                     return;
                 }
                 let pat = self.collect_pat_top(stmt.pat());
-                let type_ref = stmt
-                    .ty()
-                    .map(|it| self.lower_type_ref_disallow_impl_trait(it));
+                let type_ref = stmt.ty().map(|it| self.lower_type_ref_disallow_impl_trait(it));
                 let initializer = stmt.initializer().map(|e| self.collect_expr(e));
                 let else_branch = stmt
                     .let_else()
                     .and_then(|let_else| let_else.block_expr())
                     .map(|block| self.collect_block(block));
-                statements.push(Statement::Let {
-                    pat,
-                    type_ref,
-                    initializer,
-                    else_branch,
-                });
+                statements.push(Statement::Let { pat, type_ref, initializer, else_branch });
             }
             ast::Stmt::ExprStmt(stmt) => {
                 let expr = stmt.expr();
                     return;
                 };
                 let name = name.as_name();
-                let macro_id = self.def_map.modules[DefMap::ROOT]
-                    .scope
-                    .get(&name)
-                    .take_macros();
+                let macro_id = self.def_map.modules[DefMap::ROOT].scope.get(&name).take_macros();
                 self.collect_macro_def(statements, macro_id);
             }
             ast::Stmt::Item(ast::Item::MacroRules(macro_)) => {
                     return;
                 };
                 let name = name.as_name();
-                let macro_defs_count = self
-                    .current_block_legacy_macro_defs_count
-                    .entry(name.clone())
-                    .or_insert(0);
+                let macro_defs_count =
+                    self.current_block_legacy_macro_defs_count.entry(name.clone()).or_insert(0);
                 let macro_id = self.def_map.modules[DefMap::ROOT]
                     .scope
                     .get_legacy_macro(&name)
         };
         let macro_id = self.db.macro_def(macro_id);
         statements.push(Statement::Item(Item::MacroDef(Box::new(macro_id))));
-        self.label_ribs
-            .push(LabelRib::new(RibKind::MacroDef(Box::new(macro_id))));
+        self.label_ribs.push(LabelRib::new(RibKind::MacroDef(Box::new(macro_id))));
     }
 
     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {
-        self.collect_block_(block, |id, statements, tail| Expr::Block {
+        self.collect_block_(
+            block,
+            |id, statements, tail| Expr::Block {
             id,
             statements,
             tail,
             label: None,
-        })
+        },
+        )
     }
 
     fn collect_block_(
         block: ast::BlockExpr,
         mk_block: impl FnOnce(Option<BlockId>, Box<[Statement]>, Option<ExprId>) -> Expr,
     ) -> ExprId {
-        let block_id = self
-            .expander
-            .ast_id_map()
-            .ast_id_for_block(&block)
-            .map(|file_local_id| {
-                let ast_id = self.expander.in_file(file_local_id);
-                self.db.intern_block(BlockLoc {
-                    ast_id,
-                    module: self.module,
-                })
-            });
+        let block_id = self.expander.ast_id_map().ast_id_for_block(&block).map(|file_local_id| {
+            let ast_id = self.expander.in_file(file_local_id);
+            self.db.intern_block(BlockLoc { ast_id, module: self.module })
+        });
 
         let (module, def_map) =
             match block_id.map(|block_id| (block_def_map(self.db, block_id), block_id)) {
         let prev_legacy_macros_count = mem::take(&mut self.current_block_legacy_macro_defs_count);
 
         let mut statements = Vec::new();
-        block
-            .statements()
-            .for_each(|s| self.collect_stmt(&mut statements, s));
+        block.statements().for_each(|s| self.collect_stmt(&mut statements, s));
         let tail = block.tail_expr().and_then(|e| match e {
             ast::Expr::MacroExpr(mac) => self.collect_macro_as_stmt(&mut statements, mac),
             expr => self.maybe_collect_expr(expr),
         });
         let tail = tail.or_else(|| {
             let stmt = statements.pop()?;
-            if let Statement::Expr {
-                expr,
-                has_semi: false,
-            } = stmt
-            {
+            if let Statement::Expr { expr, has_semi: false } = stmt {
                 return Some(expr);
             }
             statements.push(stmt);
         });
 
         let syntax_node_ptr = AstPtr::new(&block.into());
-        let expr_id = self.alloc_expr(
-            mk_block(block_id, statements.into_boxed_slice(), tail),
-            syntax_node_ptr,
-        );
+        let expr_id = self
+            .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);
 
         self.def_map = prev_def_map;
         self.module = prev_local_module;
     fn collect_pat(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {
         let pattern = match &pat {
             ast::Pat::IdentPat(bp) => {
-                let name = bp
-                    .name()
-                    .map(|nr| nr.as_name())
-                    .unwrap_or_else(Name::missing);
+                let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);
                 let hygiene = bp
                     .name()
                     .map(|name| self.hygiene_id_for(name.syntax().text_range()))
 
                 let annotation =
                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());
-                let subpat = bp
-                    .pat()
-                    .map(|subpat| self.collect_pat(subpat, binding_list));
+                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat, binding_list));
 
                 let is_simple_ident_pat =
                     annotation == BindingAnnotation::Unannotated && subpat.is_none();
                     comma_follows_token(p.l_paren_token()),
                     binding_list,
                 );
-                Pat::TupleStruct {
-                    path,
-                    args,
-                    ellipsis,
-                }
+                Pat::TupleStruct { path, args, ellipsis }
             }
             ast::Pat::RefPat(p) => {
                 let pat = self.collect_pat_opt(p.pat(), binding_list);
                     .path()
                     .and_then(|path| self.lower_path(path, &mut Self::impl_trait_error_allocator))
                     .map(Box::new);
-                let record_pat_field_list = &p
-                    .record_pat_field_list()
-                    .expect("every struct should have a field list");
+                let record_pat_field_list =
+                    &p.record_pat_field_list().expect("every struct should have a field list");
                 let args = record_pat_field_list
                     .fields()
                     .filter_map(|f| {
 
                 let ellipsis = record_pat_field_list.rest_pat().is_some();
 
-                Pat::Record {
-                    path,
-                    args,
-                    ellipsis,
-                }
+                Pat::Record { path, args, ellipsis }
             }
             ast::Pat::SlicePat(p) => {
-                let SlicePatComponents {
-                    prefix,
-                    slice,
-                    suffix,
-                } = p.components();
+                let SlicePatComponents { prefix, slice, suffix } = p.components();
 
                 // FIXME properly handle `RestPat`
                 Pat::Slice {
-                    prefix: prefix
-                        .into_iter()
-                        .map(|p| self.collect_pat(p, binding_list))
-                        .collect(),
+                    prefix: prefix.into_iter().map(|p| self.collect_pat(p, binding_list)).collect(),
                     slice: slice.map(|p| self.collect_pat(p, binding_list)),
-                    suffix: suffix
-                        .into_iter()
-                        .map(|p| self.collect_pat(p, binding_list))
-                        .collect(),
+                    suffix: suffix.into_iter().map(|p| self.collect_pat(p, binding_list)).collect(),
                 }
             }
             ast::Pat::LiteralPat(lit) => 'b: {
         has_leading_comma: bool,
         binding_list: &mut BindingList,
     ) -> (Box<[PatId]>, Option<u32>) {
-        let args: Vec<_> = args
-            .map(|p| self.collect_pat_possibly_rest(p, binding_list))
-            .collect();
+        let args: Vec<_> = args.map(|p| self.collect_pat_possibly_rest(p, binding_list)).collect();
         // Find the location of the `..`, if there is one. Note that we do not
         // consider the possibility of there being multiple `..` here.
         let ellipsis = args.iter().position(|p| p.is_right()).map(|it| it as u32);
     /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when
     /// not.
     fn check_cfg(&mut self, owner: &dyn ast::HasAttrs) -> bool {
-        let enabled = self
-            .expander
-            .is_cfg_enabled(self.db, owner, self.cfg_options);
+        let enabled = self.expander.is_cfg_enabled(self.db, owner, self.cfg_options);
         match enabled {
             Ok(()) => true,
             Err(cfg) => {
-                self.store
-                    .diagnostics
-                    .push(ExpressionStoreDiagnostics::InactiveCode {
-                        node: self.expander.in_file(SyntaxNodePtr::new(owner.syntax())),
-                        cfg,
-                        opts: self.cfg_options.clone(),
-                    });
+                self.store.diagnostics.push(ExpressionStoreDiagnostics::InactiveCode {
+                    node: self.expander.in_file(SyntaxNodePtr::new(owner.syntax())),
+                    cfg,
+                    opts: self.cfg_options.clone(),
+                });
                 false
             }
         }
     }
 
     fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {
-        self.store
-            .binding_definitions
-            .entry(binding_id)
-            .or_default()
-            .push(pat_id);
+        self.store.binding_definitions.entry(binding_id).or_default().push(pat_id);
     }
 
     // region: labels
         &self,
         lifetime: Option<ast::Lifetime>,
     ) -> Result<Option<LabelId>, ExpressionStoreDiagnostics> {
-        let Some(lifetime) = lifetime else {
-            return Ok(None);
-        };
-        let mut hygiene_id = self
-            .expander
-            .hygiene_for_range(self.db, lifetime.syntax().text_range());
+        let Some(lifetime) = lifetime else { return Ok(None) };
+        let mut hygiene_id =
+            self.expander.hygiene_for_range(self.db, lifetime.syntax().text_range());
         let mut hygiene_info = if hygiene_id.is_root() {
             None
         } else {
     }
 
     fn is_label_valid_from_rib(&self, rib_index: usize) -> bool {
-        !self.label_ribs[rib_index + 1..]
-            .iter()
-            .any(|rib| rib.kind.is_label_barrier())
+        !self.label_ribs[rib_index + 1..].iter().any(|rib| rib.kind.is_label_barrier())
     }
 
     fn pop_label_rib(&mut self) {
         // We need to pop all macro defs, plus one rib.
-        while let Some(LabelRib {
-            kind: RibKind::MacroDef(_),
-        }) = self.label_ribs.pop()
-        {
+        while let Some(LabelRib { kind: RibKind::MacroDef(_) }) = self.label_ribs.pop() {
             // Do nothing.
         }
     }
         });
         let mut mappings = vec![];
         let (fmt, hygiene) = match template.and_then(|template| {
-            self.expand_macros_to_string(template.clone())
-                .map(|it| (it, template))
+            self.expand_macros_to_string(template.clone()).map(|it| (it, template))
         }) {
             Some(((s, is_direct_literal), template)) => {
                 let call_ctx = self.expander.call_syntax_ctx();
         // E.g. "{0} {0:x} {0} {1}" -> [(0, Display), (0, LowerHex), (1, Display)]
         let mut argmap = FxIndexSet::default();
         for piece in fmt.template.iter() {
-            let FormatArgsPiece::Placeholder(placeholder) = piece else {
-                continue;
-            };
+            let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };
             if let Ok(index) = placeholder.argument.index {
                 argmap.insert((index, ArgumentType::Format(placeholder.format_trait)));
             }
                 }
             })
             .collect();
-        let lit_pieces = self.alloc_expr_desugared(Expr::Array(Array::ElementList {
-            elements: lit_pieces,
-        }));
+        let lit_pieces =
+            self.alloc_expr_desugared(Expr::Array(Array::ElementList { elements: lit_pieces }));
         let lit_pieces = self.alloc_expr_desugared(Expr::Ref {
             expr: lit_pieces,
             rawness: Rawness::Ref,
                 .template
                 .iter()
                 .filter_map(|piece| {
-                    let FormatArgsPiece::Placeholder(placeholder) = piece else {
-                        return None;
-                    };
+                    let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };
                     Some(self.make_format_spec(placeholder, &mut argmap))
                 })
                 .collect();
         let arguments = &*fmt.arguments.arguments;
 
         let args = if arguments.is_empty() {
-            let expr = self.alloc_expr_desugared(Expr::Array(Array::ElementList {
-                elements: Box::default(),
-            }));
+            let expr = self
+                .alloc_expr_desugared(Expr::Array(Array::ElementList { elements: Box::default() }));
             self.alloc_expr_desugared(Expr::Ref {
                 expr,
                 rawness: Rawness::Ref,
         //         format_options,
         //         unsafe { ::core::fmt::UnsafeArg::new() }
         //     )
-
         let new_v1_formatted = LangItem::FormatArguments.ty_rel_path(
             self.db,
             self.module.krate(),
 
         let unsafe_arg_new =
             self.alloc_expr_desugared(unsafe_arg_new.map_or(Expr::Missing, Expr::Path));
-        let unsafe_arg_new = self.alloc_expr_desugared(Expr::Call {
-            callee: unsafe_arg_new,
-            args: Box::default(),
-        });
+        let unsafe_arg_new =
+            self.alloc_expr_desugared(Expr::Call { callee: unsafe_arg_new, args: Box::default() });
         let mut unsafe_arg_new = self.alloc_expr_desugared(Expr::Unsafe {
             id: None,
             statements: Box::new([]),
                 statements: fmt
                     .orphans
                     .into_iter()
-                    .map(|expr| Statement::Expr {
-                        expr,
-                        has_semi: true,
-                    })
+                    .map(|expr| Statement::Expr { expr, has_semi: true })
                     .collect(),
                 tail: Some(unsafe_arg_new),
                 label: None,
 
         self.alloc_expr(
             Expr::Call {
-                callee: new_v1_formatted,
-                args: Box::new([lit_pieces, args, format_options, unsafe_arg_new]),
-            },
+            callee: new_v1_formatted,
+            args: Box::new([lit_pieces, args, format_options, unsafe_arg_new]),
+        },
             syntax_ptr,
         )
     }
                 BindingAnnotation::Unannotated,
                 HygieneId::ROOT,
             );
-            let args_pat = self.alloc_pat_desugared(Pat::Bind {
-                id: args_binding,
-                subpat: None,
-            });
+            let args_pat = self.alloc_pat_desugared(Pat::Bind { id: args_binding, subpat: None });
             self.add_definition_to_binding(args_binding, args_pat);
             // TODO: We don't have `super let` yet.
             let let_stmt = Statement::Let {
                 initializer: Some(args),
                 else_branch: None,
             };
-            (
-                vec![let_stmt],
-                self.alloc_expr_desugared(Expr::Path(args_name.into())),
-            )
+            (vec![let_stmt], self.alloc_expr_desugared(Expr::Path(args_name.into())))
         } else {
             // Generate:
             //     super let args = (&arg0, &arg1, &...);
                 BindingAnnotation::Unannotated,
                 HygieneId::ROOT,
             );
-            let args_pat = self.alloc_pat_desugared(Pat::Bind {
-                id: args_binding,
-                subpat: None,
-            });
+            let args_pat = self.alloc_pat_desugared(Pat::Bind { id: args_binding, subpat: None });
             self.add_definition_to_binding(args_binding, args_pat);
             let elements = arguments
                 .iter()
                 BindingAnnotation::Unannotated,
                 HygieneId::ROOT,
             );
-            let args_pat = self.alloc_pat_desugared(Pat::Bind {
-                id: args_binding,
-                subpat: None,
-            });
+            let args_pat = self.alloc_pat_desugared(Pat::Bind { id: args_binding, subpat: None });
             self.add_definition_to_binding(args_binding, args_pat);
             let let_stmt2 = Statement::Let {
                 pat: args_pat,
                 initializer: Some(array),
                 else_branch: None,
             };
-            (
-                vec![let_stmt1, let_stmt2],
-                self.alloc_expr_desugared(Expr::Path(args_name.into())),
-            )
+            (vec![let_stmt1, let_stmt2], self.alloc_expr_desugared(Expr::Path(args_name.into())))
         };
 
         // Generate:
             let new_v1_formatted =
                 self.alloc_expr_desugared(new_v1_formatted.map_or(Expr::Missing, Expr::Path));
             let args = [lit_pieces, args, format_options];
-            let call = self.alloc_expr_desugared(Expr::Call {
-                callee: new_v1_formatted,
-                args: args.into(),
-            });
+            let call = self
+                .alloc_expr_desugared(Expr::Call { callee: new_v1_formatted, args: args.into() });
 
-            Expr::Unsafe {
-                id: None,
-                statements: Box::default(),
-                tail: Some(call),
-            }
+            Expr::Unsafe { id: None, statements: Box::default(), tail: Some(call) }
         };
 
         if !let_stmts.is_empty() {
             let call = self.alloc_expr_desugared(call_block);
             self.alloc_expr(
                 Expr::Block {
-                    id: None,
-                    statements: let_stmts.into(),
-                    tail: Some(call),
-                    label: None,
-                },
+                id: None,
+                statements: let_stmts.into(),
+                tail: Some(call),
+                label: None,
+            },
                 syntax_ptr,
             )
         } else {
                 Some(BuiltinUint::U32),
             )));
 
-            let position = RecordLitField {
-                name: Name::new_symbol_root(sym::position),
-                expr: position,
-            };
-            let flags = RecordLitField {
-                name: Name::new_symbol_root(sym::flags),
-                expr: flags,
-            };
+            let position =
+                RecordLitField { name: Name::new_symbol_root(sym::position), expr: position };
+            let flags = RecordLitField { name: Name::new_symbol_root(sym::flags), expr: flags };
             let precision = RecordLitField {
                 name: Name::new_symbol_root(sym::precision),
                 expr: precision_expr,
             };
-            let width = RecordLitField {
-                name: Name::new_symbol_root(sym::width),
-                expr: width_expr,
-            };
+            let width =
+                RecordLitField { name: Name::new_symbol_root(sym::width), expr: width_expr };
             self.alloc_expr_desugared(Expr::RecordLit {
-                path: LangItem::FormatPlaceholder
-                    .path(self.db, self.module.krate())
-                    .map(Box::new),
+                path: LangItem::FormatPlaceholder.path(self.db, self.module.krate()).map(Box::new),
                 fields: Box::new([position, flags, precision, width]),
                 spread: None,
             })
     fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
-        self.store
-            .expr_map_back
-            .insert(id, src.map(AstPtr::wrap_left));
+        self.store.expr_map_back.insert(id, src.map(AstPtr::wrap_left));
         self.store.expr_map.insert(src, id.into());
         id
     }
+
     // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed.
     // Migrate to alloc_expr_desugared_with_ptr and then rename back
     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {
         self.store.exprs.alloc(expr)
     }
+
     fn alloc_expr_desugared_with_ptr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
-        self.store
-            .expr_map_back
-            .insert(id, src.map(AstPtr::wrap_left));
+        self.store.expr_map_back.insert(id, src.map(AstPtr::wrap_left));
         // We intentionally don't fill this as it could overwrite a non-desugared entry
         // self.store.expr_map.insert(src, id);
         id
     }
+
     fn missing_expr(&mut self) -> ExprId {
         self.alloc_expr_desugared(Expr::Missing)
     }
         mode: BindingAnnotation,
         hygiene: HygieneId,
     ) -> BindingId {
-        let binding = self.store.bindings.alloc(Binding {
-            name,
-            mode,
-            problems: None,
-            hygiene,
-        });
+        let binding = self.store.bindings.alloc(Binding { name, mode, problems: None, hygiene });
         if let Some(owner) = self.current_binding_owner {
             self.store.binding_owners.insert(binding, owner);
         }
         let src = self.expander.in_file(ptr);
         let id = self.store.pats.alloc(pat);
         self.store.expr_map.insert(src, id.into());
-        self.store
-            .pat_map_back
-            .insert(id, src.map(AstPtr::wrap_left));
+        self.store.pat_map_back.insert(id, src.map(AstPtr::wrap_left));
         id
     }
 
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         self.store.pat_map.insert(src, id.into());
-        self.store
-            .expr_map_back
-            .insert(id, src.map(AstPtr::wrap_right));
+        self.store.expr_map_back.insert(id, src.map(AstPtr::wrap_right));
         id
     }
 
     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {
         let src = self.expander.in_file(ptr);
         let id = self.store.pats.alloc(pat);
-        self.store
-            .pat_map_back
-            .insert(id, src.map(AstPtr::wrap_right));
+        self.store.pat_map_back.insert(id, src.map(AstPtr::wrap_right));
         self.store.pat_map.insert(src, id.into());
         id
     }
+
     // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.
     fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {
         self.store.pats.alloc(pat)
     }
+
     fn missing_pat(&mut self) -> PatId {
         self.store.pats.alloc(Pat::Missing)
     }
         self.store.label_map.insert(src, id);
         id
     }
+
     // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.
     fn alloc_label_desugared(&mut self, label: Label) -> LabelId {
         self.store.labels.alloc(label)
     }
 
     fn is_lowering_awaitable_block(&self) -> &Awaitable {
-        self.awaitable_context
-            .as_ref()
-            .unwrap_or(&Awaitable::No("unknown"))
+        self.awaitable_context.as_ref().unwrap_or(&Awaitable::No("unknown"))
     }
 
     fn with_awaitable_block<T>(
 }
 
 fn comma_follows_token(t: Option<syntax::SyntaxToken>) -> bool {
-    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))()
-        .is_some_and(|it| it.kind() == syntax::T![,])
+    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))().is_some_and(
+        |it| it.kind() == syntax::T![,],
+    )
 }
 
 #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]