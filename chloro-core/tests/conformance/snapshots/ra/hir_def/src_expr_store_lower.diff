COMPARISON DIFF
============================================================

Original size: 144317 bytes
Chloro size:   144054 bytes
Rustfmt size:  144317 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use cfg::CfgOptions;
 use either::Either;
 use hir_expand::{
-    HirFileId, InFile, MacroDefId,
     mod_path::tool_path,
     name::{AsName, Name},
     span_map::SpanMapRef,
+    HirFileId, InFile, MacroDefId,
 };
-use intern::{Symbol, sym};
+use intern::{sym, Symbol};
 use rustc_hash::FxHashMap;
 use stdx::never;
 use syntax::{
-    AstNode, AstPtr, AstToken as _, SyntaxNodePtr,
     ast::{
         self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasAttrs, HasGenericArgs,
         HasGenericParams, HasLoopBody, HasName, HasTypeBounds, IsString, RangeItem,
         SlicePatComponents,
     },
+    AstNode, AstPtr, AstToken as _, SyntaxNodePtr,
 };
 use thin_vec::ThinVec;
 use triomphe::Arc;
 use tt::TextRange;
 
 use crate::{
-    AdtId, BlockId, BlockLoc, DefWithBodyId, FunctionId, GenericDefId, ImplId, MacroId,
-    ModuleDefId, ModuleId, TraitId, TypeAliasId, UnresolvedMacro,
     builtin_type::BuiltinUint,
     db::DefDatabase,
     expr_store::{
+        expander::Expander, lower::generics::ImplTraitLowerFn,
+        path::{AssociatedTypeBinding, GenericArg, GenericArgs, GenericArgsParentheses, Path},
         Body, BodySourceMap, ExprPtr, ExpressionStore, ExpressionStoreBuilder,
         ExpressionStoreDiagnostics, ExpressionStoreSourceMap, HygieneId, LabelPtr, LifetimePtr,
         PatPtr, TypePtr,
-        expander::Expander,
-        lower::generics::ImplTraitLowerFn,
-        path::{AssociatedTypeBinding, GenericArg, GenericArgs, GenericArgsParentheses, Path},
     },
     hir::{
-        Array, Binding, BindingAnnotation, BindingId, BindingProblems, CaptureBy, ClosureKind,
-        Expr, ExprId, Item, Label, LabelId, Literal, MatchArm, Movability, OffsetOf, Pat, PatId,
-        RecordFieldPat, RecordLitField, Statement,
         format_args::{
             self, FormatAlignment, FormatArgs, FormatArgsPiece, FormatArgument, FormatArgumentKind,
             FormatArgumentsCollector, FormatCount, FormatDebugHex, FormatOptions,
             FormatPlaceholder, FormatSign, FormatTrait,
         },
-        generics::GenericParams,
+        generics::GenericParams, Array, Binding, BindingAnnotation, BindingId, BindingProblems,
+        CaptureBy, ClosureKind, Expr, ExprId, Item, Label, LabelId, Literal, MatchArm, Movability,
+        OffsetOf, Pat, PatId, RecordFieldPat, RecordLitField, Statement,
     },
     item_scope::BuiltinShadowMode,
     item_tree::FieldsShape,
     lang_item::LangItem,
-    nameres::{DefMap, LocalDefMap, MacroSubNs, block_def_map},
+    nameres::{block_def_map, DefMap, LocalDefMap, MacroSubNs},
     type_ref::{
         ArrayType, ConstRef, FnType, LifetimeRef, LifetimeRefId, Mutability, PathId, Rawness,
         RefType, TraitBoundModifier, TraitRef, TypeBound, TypeRef, TypeRefId, UseArgRef,
     },
+    AdtId, BlockId, BlockLoc, DefWithBodyId, FunctionId, GenericDefId, ImplId, MacroId,
+    ModuleDefId, ModuleId, TraitId, TypeAliasId, UnresolvedMacro,
 };
-
 pub use self::path::hir_segment_to_ast_segment;
 
 pub(super) fn lower_body(
     // with the inner macro, and that will cause confusion because they won't be the same as `ROOT`
     // even though they should be the same. Also, when the body comes from multiple expansions, their
     // hygiene is different.
-
     let mut self_param = None;
     let mut source_map_self_param = None;
     let mut params = vec![];
         DefWithBodyId::ConstId(it) => db.attrs(it.into()),
         DefWithBodyId::VariantId(it) => db.attrs(it.into()),
     }
-    .rust_analyzer_tool()
-    .any(|attr| *attr.path() == tool_path![skip]);
+        .rust_analyzer_tool()
+        .any(|attr| *attr.path() == tool_path![skip]);
     // If #[rust_analyzer::skip] annotated, only construct enough information for the signature
     // and skip the body.
     if skip_body {
         }
     };
 
-    let body_expr = collector.collect(
+    let body_expr = collector
+        .collect(
         body,
         if is_async_fn {
             Awaitable::Yes
     type_ref: InFile<Option<ast::Type>>,
 ) -> (ExpressionStore, ExpressionStoreSourceMap, TypeRefId) {
     let mut expr_collector = ExprCollector::new(db, module, type_ref.file_id);
-    let type_ref =
-        expr_collector.lower_type_ref_opt(type_ref.value, &mut ExprCollector::impl_trait_allocator);
+    let type_ref = expr_collector.lower_type_ref_opt(type_ref.value, &mut ExprCollector::impl_trait_allocator);
     let (store, source_map) = expr_collector.store.finish();
     (store, source_map, type_ref)
 }
     impl_id: ImplId,
 ) -> (ExpressionStore, ExpressionStoreSourceMap, TypeRefId, Option<TraitRef>, Arc<GenericParams>) {
     let mut expr_collector = ExprCollector::new(db, module, impl_syntax.file_id);
-    let self_ty =
-        expr_collector.lower_type_ref_opt_disallow_impl_trait(impl_syntax.value.self_ty());
-    let trait_ = impl_syntax.value.trait_().and_then(|it| match &it {
+    let self_ty = expr_collector.lower_type_ref_opt_disallow_impl_trait(impl_syntax.value.self_ty());
+    let trait_ = impl_syntax.value
+        .trait_()
+        .and_then(|it| match &it {
         ast::Type::PathType(path_type) => {
             let path = expr_collector
                 .lower_path_type(path_type, &mut ExprCollector::impl_trait_allocator)?;
         _ => None,
     });
     let mut collector = generics::GenericParamsCollector::new(impl_id.into());
-    collector.lower(
+    collector
+        .lower(
         &mut expr_collector,
         impl_syntax.value.generic_param_list(),
         impl_syntax.value.where_clause(),
         trait_id.into(),
         trait_syntax.value.type_bound_list(),
     );
-    collector.lower(
+    collector
+        .lower(
         &mut expr_collector,
         trait_syntax.value.generic_param_list(),
         trait_syntax.value.where_clause(),
         })
         .unwrap_or_default();
     let mut collector = generics::GenericParamsCollector::new(type_alias_id.into());
-    collector.lower(
+    collector
+        .lower(
         &mut expr_collector,
         alias.value.generic_param_list(),
         alias.value.where_clause(),
     let mut params = vec![];
     let mut has_self_param = false;
     let mut has_variadic = false;
-    collector.collect_impl_trait(&mut expr_collector, |collector, mut impl_trait_lower_fn| {
+    collector
+        .collect_impl_trait(&mut expr_collector, |collector, mut impl_trait_lower_fn| {
         if let Some(param_list) = fn_.value.param_list() {
             if let Some(param) = param_list.self_param() {
                 let enabled = collector.check_cfg(&param);
         }
     });
     let generics = collector.finish();
-    let return_type = fn_.value.ret_type().map(|ret_type| {
+    let return_type = fn_.value
+        .ret_type()
+        .map(|ret_type| {
         expr_collector.lower_type_ref_opt(ret_type.ty(), &mut ExprCollector::impl_trait_allocator)
     });
 
     local_def_map: &'db LocalDefMap,
     module: ModuleId,
     pub store: ExpressionStoreBuilder,
-
     // state stuff
     // Prevent nested impl traits like `impl Foo<impl Bar>`.
     outer_impl_trait: bool,
-
     is_lowering_coroutine: bool,
-
     /// Legacy (`macro_rules!`) macros can have multiple definitions and shadow each other,
     /// and we need to find the current definition. So we track the number of definitions we saw.
     current_block_legacy_macro_defs_count: FxHashMap<Name, usize>,
-
     current_try_block_label: Option<LabelId>,
-
     label_ribs: Vec<LabelRib>,
     current_binding_owner: Option<ExprId>,
-
     awaitable_context: Option<Awaitable>,
 }
 
     /// and save the `<new_label>` to use it as a break target for desugaring of the `?` operator.
     fn desugar_try_block(&mut self, e: BlockExpr) -> ExprId {
         let try_from_output = self.lang_path(LangItem::TryTraitFromOutput);
-        let label = self.alloc_label_desugared(Label {
+        let label = self
+            .alloc_label_desugared(Label {
             name: Name::generate_new_name(self.store.labels.len()),
         });
         let old_label = self.current_try_block_label.replace(label);
 
         let ptr = AstPtr::new(&e).upcast();
-        let (btail, expr_id) = self.with_labeled_rib(label, HygieneId::ROOT, |this| {
+        let (btail, expr_id) = self
+            .with_labeled_rib(label, HygieneId::ROOT, |this| {
             let mut btail = None;
             let block = this.collect_block_(e, |id, statements, tail| {
                 btail = tail;
             (btail, block)
         });
 
-        let callee = self
-            .alloc_expr_desugared_with_ptr(try_from_output.map_or(Expr::Missing, Expr::Path), ptr);
+        let callee = self.alloc_expr_desugared_with_ptr(try_from_output.map_or(Expr::Missing, Expr::Path), ptr);
         let next_tail = match btail {
             Some(tail) => self
                 .alloc_expr_desugared_with_ptr(Expr::Call { callee, args: Box::new([tail]) }, ptr),
     /// FIXME: Rustc wraps the condition in a construct equivalent to `{ let _t = <cond>; _t }`
     /// to preserve drop semantics. We should probably do the same in future.
     fn collect_while_loop(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::WhileExpr) -> ExprId {
-        let label = e.label().map(|label| {
+        let label = e
+            .label()
+            .map(|label| {
             (self.hygiene_id_for(label.syntax().text_range()), self.collect_label(label))
         });
         let body = self.collect_labelled_block_opt(label, e.loop_body());
 
         // Labels can also be used in the condition expression, like this:
+
         // ```
+
         // fn main() {
+
         //     let mut optional = Some(0);
+
         //     'my_label: while let Some(a) = match optional {
+
         //         None => break 'my_label,
+
         //         Some(val) => Some(val),
+
         //     } {
+
         //         println!("{}", a);
+
         //         optional = None;
+
         //     }
+
         // }
+
         // ```
         let condition = match label {
             Some((label_hygiene, label)) => self.with_labeled_rib(label, label_hygiene, |this| {
         };
 
         let break_expr = self.alloc_expr(Expr::Break { expr: None, label: None }, syntax_ptr);
-        let if_expr = self.alloc_expr(
+        let if_expr = self
+            .alloc_expr(
             Expr::If { condition, then_branch: body, else_branch: Some(break_expr) },
             syntax_ptr,
         );
         let option_some = self.lang_path(LangItem::OptionSome);
         let option_none = self.lang_path(LangItem::OptionNone);
         let head = self.collect_expr_opt(e.iterable());
-        let into_iter_fn_expr =
-            self.alloc_expr(into_iter_fn.map_or(Expr::Missing, Expr::Path), syntax_ptr);
-        let iterator = self.alloc_expr(
+        let into_iter_fn_expr = self.alloc_expr(into_iter_fn.map_or(Expr::Missing, Expr::Path), syntax_ptr);
+        let iterator = self
+            .alloc_expr(
             Expr::Call { callee: into_iter_fn_expr, args: Box::new([head]) },
             syntax_ptr,
         );
             args: Box::new([self.collect_pat_top(e.pat())]),
             ellipsis: None,
         };
-        let label = e.label().map(|label| {
+        let label = e
+            .label()
+            .map(|label| {
             (self.hygiene_id_for(label.syntax().text_range()), self.collect_label(label))
         });
         let some_arm = MatchArm {
         };
         let iter_name = Name::generate_new_name(self.store.exprs.len());
         let iter_expr = self.alloc_expr(Expr::Path(Path::from(iter_name.clone())), syntax_ptr);
-        let iter_expr_mut = self.alloc_expr(
+        let iter_expr_mut = self
+            .alloc_expr(
             Expr::Ref { expr: iter_expr, rawness: Rawness::Ref, mutability: Mutability::Mut },
             syntax_ptr,
         );
-        let iter_next_fn_expr =
-            self.alloc_expr(iter_next_fn.map_or(Expr::Missing, Expr::Path), syntax_ptr);
-        let iter_next_expr = self.alloc_expr(
+        let iter_next_fn_expr = self.alloc_expr(iter_next_fn.map_or(Expr::Missing, Expr::Path), syntax_ptr);
+        let iter_next_expr = self
+            .alloc_expr(
             Expr::Call { callee: iter_next_fn_expr, args: Box::new([iter_expr_mut]) },
             syntax_ptr,
         );
-        let loop_inner = self.alloc_expr(
+        let loop_inner = self
+            .alloc_expr(
             Expr::Match { expr: iter_next_expr, arms: Box::new([none_arm, some_arm]) },
             syntax_ptr,
         );
-        let loop_inner = self.alloc_expr(
+        let loop_inner = self
+            .alloc_expr(
             Expr::Block {
                 id: None,
                 statements: Box::default(),
             },
             syntax_ptr,
         );
-        let loop_outer = self
-            .alloc_expr(Expr::Loop { body: loop_inner, label: label.map(|it| it.1) }, syntax_ptr);
-        let iter_binding =
-            self.alloc_binding(iter_name, BindingAnnotation::Mutable, HygieneId::ROOT);
+        let loop_outer = self.alloc_expr(Expr::Loop { body: loop_inner, label: label.map(|it| it.1) }, syntax_ptr);
+        let iter_binding = self.alloc_binding(iter_name, BindingAnnotation::Mutable, HygieneId::ROOT);
         let iter_pat = self.alloc_pat_desugared(Pat::Bind { id: iter_binding, subpat: None });
         self.add_definition_to_binding(iter_binding, iter_pat);
         self.alloc_expr(
         let try_from_residual = self.lang_path(LangItem::TryTraitFromResidual);
         let operand = self.collect_expr_opt(e.expr());
         let try_branch = self.alloc_expr(try_branch.map_or(Expr::Missing, Expr::Path), syntax_ptr);
-        let expr = self
-            .alloc_expr(Expr::Call { callee: try_branch, args: Box::new([operand]) }, syntax_ptr);
+        let expr = self.alloc_expr(Expr::Call { callee: try_branch, args: Box::new([operand]) }, syntax_ptr);
         let continue_name = Name::generate_new_name(self.store.bindings.len());
-        let continue_binding = self.alloc_binding(
+        let continue_binding = self
+            .alloc_binding(
             continue_name.clone(),
             BindingAnnotation::Unannotated,
             HygieneId::ROOT,
         );
-        let continue_bpat =
-            self.alloc_pat_desugared(Pat::Bind { id: continue_binding, subpat: None });
+        let continue_bpat = self.alloc_pat_desugared(Pat::Bind { id: continue_binding, subpat: None });
         self.add_definition_to_binding(continue_binding, continue_bpat);
         let continue_arm = MatchArm {
             pat: self.alloc_pat_desugared(Pat::TupleStruct {
             expr: self.alloc_expr(Expr::Path(Path::from(continue_name)), syntax_ptr),
         };
         let break_name = Name::generate_new_name(self.store.bindings.len());
-        let break_binding =
-            self.alloc_binding(break_name.clone(), BindingAnnotation::Unannotated, HygieneId::ROOT);
+        let break_binding = self.alloc_binding(break_name.clone(), BindingAnnotation::Unannotated, HygieneId::ROOT);
         let break_bpat = self.alloc_pat_desugared(Pat::Bind { id: break_binding, subpat: None });
         self.add_definition_to_binding(break_binding, break_bpat);
         let break_arm = MatchArm {
         let macro_call_ptr = self.expander.in_file(syntax_ptr);
         let module = self.module.local_id;
 
-        let block_call = self.def_map.modules[self.module.local_id].scope.macro_invoc(
+        let block_call = self.def_map.modules[self.module.local_id].scope
+            .macro_invoc(
             self.expander.in_file(self.expander.ast_id_map().ast_id_for_ptr(syntax_ptr)),
         );
         let res = match block_call {
             }
         };
         // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
-
         match res.value {
             Some((mark, expansion)) => {
                 // Keep collecting even with expansion errors so we can provide completions and
         let mac_call = mac.macro_call()?;
         let syntax_ptr = AstPtr::new(&ast::Expr::from(mac));
         let macro_ptr = AstPtr::new(&mac_call);
-        let expansion = self.collect_macro_call(
+        let expansion = self
+            .collect_macro_call(
             mac_call,
             macro_ptr,
             false,
         block: ast::BlockExpr,
         mk_block: impl FnOnce(Option<BlockId>, Box<[Statement]>, Option<ExprId>) -> Expr,
     ) -> ExprId {
-        let block_id = self.expander.ast_id_map().ast_id_for_block(&block).map(|file_local_id| {
+        let block_id = self.expander
+            .ast_id_map()
+            .ast_id_for_block(&block)
+            .map(|file_local_id| {
             let ast_id = self.expander.in_file(file_local_id);
             self.db.intern_block(BlockLoc { ast_id, module: self.module })
         });
 
-        let (module, def_map) =
-            match block_id.map(|block_id| (block_def_map(self.db, block_id), block_id)) {
+        let (module, def_map) = match block_id.map(|block_id| (block_def_map(self.db, block_id), block_id)) {
                 Some((def_map, block_id)) => {
                     self.store.block_scopes.push(block_id);
                     (def_map.module_id(DefMap::ROOT), def_map)
 
         let mut statements = Vec::new();
         block.statements().for_each(|s| self.collect_stmt(&mut statements, s));
-        let tail = block.tail_expr().and_then(|e| match e {
+        let tail = block
+            .tail_expr()
+            .and_then(|e| match e {
             ast::Expr::MacroExpr(mac) => self.collect_macro_as_stmt(&mut statements, mac),
             expr => self.maybe_collect_expr(expr),
         });
-        let tail = tail.or_else(|| {
+        let tail = tail
+            .or_else(|| {
             let stmt = statements.pop()?;
             if let Statement::Expr { expr, has_semi: false } = stmt {
                 return Some(expr);
         });
 
         let syntax_node_ptr = AstPtr::new(&block.into());
-        let expr_id = self
-            .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);
+        let expr_id = self.alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);
 
         self.def_map = prev_def_map;
         self.module = prev_local_module;
         (args.into_boxed_slice(), ellipsis)
     }
 
-    // `collect_pat` rejects `ast::Pat::RestPat`, but it should be handled in some cases that
-    // it is the macro expansion result of an arg sub-pattern in a slice or tuple pattern.
     fn collect_pat_possibly_rest(
         &mut self,
         pat: ast::Pat,
         lifetime: Option<ast::Lifetime>,
     ) -> Result<Option<LabelId>, ExpressionStoreDiagnostics> {
         let Some(lifetime) = lifetime else { return Ok(None) };
-        let mut hygiene_id =
-            self.expander.hygiene_for_range(self.db, lifetime.syntax().text_range());
+        let mut hygiene_id = self.expander.hygiene_for_range(self.db, lifetime.syntax().text_range());
         let mut hygiene_info = if hygiene_id.is_root() {
             None
         } else {
         hygiene: HygieneId,
         f: impl FnOnce(&mut Self) -> T,
     ) -> T {
-        self.label_ribs.push(LabelRib::new(RibKind::Normal(
+        self.label_ribs
+            .push(LabelRib::new(RibKind::Normal(
             self.store.labels[label].name.clone(),
             label,
             hygiene,
     }
     // endregion: labels
 
-    // region: format
     fn expand_macros_to_string(&mut self, expr: ast::Expr) -> Option<(ast::String, bool)> {
         let m = match expr {
             ast::Expr::MacroExpr(m) => m,
         syntax_ptr: AstPtr<ast::Expr>,
     ) -> ExprId {
         let mut args = FormatArgumentsCollector::default();
-        f.args().for_each(|arg| {
+        f
+            .args()
+            .for_each(|arg| {
             args.add(FormatArgument {
                 kind: match arg.name() {
                     Some(name) => FormatArgumentKind::Named(name.as_name()),
             });
         });
         let template = f.template();
-        let fmt_snippet = template.as_ref().and_then(|it| match it {
+        let fmt_snippet = template
+            .as_ref()
+            .and_then(|it| match it {
             ast::Expr::Literal(literal) => match literal.kind() {
                 ast::LiteralKind::String(s) => Some(s.text().to_owned()),
                 _ => None,
         };
 
         // Create a list of all _unique_ (argument, format trait) combinations.
+
         // E.g. "{0} {0:x} {0} {1}" -> [(0, Display), (0, LowerHex), (1, Display)]
         let mut argmap = FxIndexSet::default();
         for piece in fmt.template.iter() {
                 }
             })
             .collect();
-        let lit_pieces =
-            self.alloc_expr_desugared(Expr::Array(Array::ElementList { elements: lit_pieces }));
-        let lit_pieces = self.alloc_expr_desugared(Expr::Ref {
+        let lit_pieces = self.alloc_expr_desugared(Expr::Array(Array::ElementList { elements: lit_pieces }));
+        let lit_pieces = self
+            .alloc_expr_desugared(Expr::Ref {
             expr: lit_pieces,
             rawness: Rawness::Ref,
             mutability: Mutability::Shared,
         };
 
         // Assume that rustc version >= 1.89.0 iff lang item `format_arguments` exists
+
         // but `format_unsafe_arg` does not
-        let fmt_args =
-            || crate::lang_item::lang_item(self.db, self.module.krate(), LangItem::FormatArguments);
-        let fmt_unsafe_arg =
-            || crate::lang_item::lang_item(self.db, self.module.krate(), LangItem::FormatUnsafeArg);
+        let fmt_args = || crate::lang_item::lang_item(self.db, self.module.krate(), LangItem::FormatArguments);
+        let fmt_unsafe_arg = || crate::lang_item::lang_item(self.db, self.module.krate(), LangItem::FormatUnsafeArg);
         let use_format_args_since_1_89_0 = fmt_args().is_some() && fmt_unsafe_arg().is_none();
 
         let idx = if use_format_args_since_1_89_0 {
         };
 
         // Generate:
-        //     <core::fmt::Arguments>::new_v1_formatted(
-        //         lit_pieces,
-        //         args,
-        //         format_options,
-        //         unsafe { ::core::fmt::UnsafeArg::new() }
-        //     )
 
-        let new_v1_formatted = LangItem::FormatArguments.ty_rel_path(
+        //     <core::fmt::Arguments>::new_v1_formatted(
+
+        //         lit_pieces,
+
+        //         args,
+
+        //         format_options,
+
+        //         unsafe { ::core::fmt::UnsafeArg::new() }
+
+        //     )
+        let new_v1_formatted = LangItem::FormatArguments
+            .ty_rel_path(
             self.db,
             self.module.krate(),
             Name::new_symbol_root(sym::new_v1_formatted),
         );
-        let unsafe_arg_new = LangItem::FormatUnsafeArg.ty_rel_path(
+        let unsafe_arg_new = LangItem::FormatUnsafeArg
+            .ty_rel_path(
             self.db,
             self.module.krate(),
             Name::new_symbol_root(sym::new),
         );
-        let new_v1_formatted =
-            self.alloc_expr_desugared(new_v1_formatted.map_or(Expr::Missing, Expr::Path));
+        let new_v1_formatted = self.alloc_expr_desugared(new_v1_formatted.map_or(Expr::Missing, Expr::Path));
 
-        let unsafe_arg_new =
-            self.alloc_expr_desugared(unsafe_arg_new.map_or(Expr::Missing, Expr::Path));
-        let unsafe_arg_new =
-            self.alloc_expr_desugared(Expr::Call { callee: unsafe_arg_new, args: Box::default() });
-        let mut unsafe_arg_new = self.alloc_expr_desugared(Expr::Unsafe {
+        let unsafe_arg_new = self.alloc_expr_desugared(unsafe_arg_new.map_or(Expr::Missing, Expr::Path));
+        let unsafe_arg_new = self.alloc_expr_desugared(Expr::Call { callee: unsafe_arg_new, args: Box::default() });
+        let mut unsafe_arg_new = self
+            .alloc_expr_desugared(Expr::Unsafe {
             id: None,
             statements: Box::new([]),
             tail: Some(unsafe_arg_new),
         };
 
         // Generate:
+
         //     &args
-        let args = self.alloc_expr_desugared(Expr::Ref {
+        let args = self
+            .alloc_expr_desugared(Expr::Ref {
             expr: args,
             rawness: Rawness::Ref,
             mutability: Mutability::Shared,
         self.store.expr_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed.
-    // Migrate to alloc_expr_desugared_with_ptr and then rename back
+
     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {
         self.store.exprs.alloc(expr)
     }
+
     fn alloc_expr_desugared_with_ptr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         // self.store.expr_map.insert(src, id);
         id
     }
+
     fn missing_expr(&mut self) -> ExprId {
         self.alloc_expr_desugared(Expr::Missing)
     }
         self.store.pat_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.
+
     fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {
         self.store.pats.alloc(pat)
     }
+
     fn missing_pat(&mut self) -> PatId {
         self.store.pats.alloc(Pat::Missing)
     }
         self.store.label_map.insert(src, id);
         id
     }
-    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.
+
     fn alloc_label_desugared(&mut self, label: Label) -> LabelId {
         self.store.labels.alloc(label)
     }