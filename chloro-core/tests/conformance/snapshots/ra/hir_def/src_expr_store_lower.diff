COMPARISON DIFF
============================================================

Original size: 144317 bytes
Chloro size:   143651 bytes
Rustfmt size:  144317 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use cfg::CfgOptions;
 use either::Either;
 use hir_expand::{
-    HirFileId, InFile, MacroDefId,
     mod_path::tool_path,
     name::{AsName, Name},
     span_map::SpanMapRef,
+    HirFileId, InFile, MacroDefId,
 };
 use intern::{Symbol, sym};
 use rustc_hash::FxHashMap;
 use stdx::never;
 use syntax::{
-    AstNode, AstPtr, AstToken as _, SyntaxNodePtr,
     ast::{
         self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasAttrs, HasGenericArgs,
         HasGenericParams, HasLoopBody, HasName, HasTypeBounds, IsString, RangeItem,
         SlicePatComponents,
     },
+    AstNode, AstPtr, AstToken as _, SyntaxNodePtr,
 };
 use thin_vec::ThinVec;
 use triomphe::Arc;
 use tt::TextRange;
 
 use crate::{
-    AdtId, BlockId, BlockLoc, DefWithBodyId, FunctionId, GenericDefId, ImplId, MacroId,
-    ModuleDefId, ModuleId, TraitId, TypeAliasId, UnresolvedMacro,
     builtin_type::BuiltinUint,
     db::DefDatabase,
     expr_store::{
         ArrayType, ConstRef, FnType, LifetimeRef, LifetimeRefId, Mutability, PathId, Rawness,
         RefType, TraitBoundModifier, TraitRef, TypeBound, TypeRef, TypeRefId, UseArgRef,
     },
+    AdtId, BlockId, BlockLoc, DefWithBodyId, FunctionId, GenericDefId, ImplId, MacroId, ModuleDefId,
+    ModuleId, TraitId, TypeAliasId, UnresolvedMacro,
 };
-
 pub use self::path::hir_segment_to_ast_segment;
 
 pub(super) fn lower_body(
     // with the inner macro, and that will cause confusion because they won't be the same as `ROOT`
     // even though they should be the same. Also, when the body comes from multiple expansions, their
     // hygiene is different.
-
     let mut self_param = None;
     let mut source_map_self_param = None;
     let mut params = vec![];
     let mut collector = ExprCollector::new(db, module, current_file_id);
-
     let skip_body = match owner {
         DefWithBodyId::FunctionId(it) => db.attrs(it.into()),
         DefWithBodyId::StaticId(it) => db.attrs(it.into()),
             BodySourceMap { self_param: source_map_self_param, store: source_map },
         );
     }
-
     if let Some(param_list) = parameters {
         if let Some(self_param_syn) = param_list.self_param().filter(|it| collector.check_cfg(it)) {
             let is_mutable =
             }
         }
     };
-
     let body_expr = collector.collect(
         body,
         if is_async_fn {
             }
         },
     );
-
     let (store, source_map) = collector.store.finish();
     (
         Body { store, params: params.into_boxed_slice(), self_param, body_expr },
     let return_type = fn_.value.ret_type().map(|ret_type| {
         expr_collector.lower_type_ref_opt(ret_type.ty(), &mut ExprCollector::impl_trait_allocator)
     });
-
     let return_type = if fn_.value.async_token().is_some() {
         let path = hir_expand::mod_path::path![core::future::Future];
         let mut generic_args: Vec<_> =
     local_def_map: &'db LocalDefMap,
     module: ModuleId,
     pub store: ExpressionStoreBuilder,
-
-    // state stuff
-    // Prevent nested impl traits like `impl Foo<impl Bar>`.
     outer_impl_trait: bool,
-
     is_lowering_coroutine: bool,
-
     /// Legacy (`macro_rules!`) macros can have multiple definitions and shadow each other,
     /// and we need to find the current definition. So we track the number of definitions we saw.
     current_block_legacy_macro_defs_count: FxHashMap<Name, usize>,
-
     current_try_block_label: Option<LabelId>,
-
     label_ribs: Vec<LabelRib>,
     current_binding_owner: Option<ExprId>,
-
     awaitable_context: Option<Awaitable>,
 }
 
                 }
             }
         }
-
         if args.is_empty() && bindings.is_empty() {
             return None;
         }
         if !self.check_cfg(&expr) {
             return None;
         }
-
         // FIXME: Move some of these arms out into separate methods for clarity
         Some(match expr {
             ast::Expr::IfExpr(e) => {
             return None;
         }
         let syntax_ptr = AstPtr::new(expr);
-
         let result = match expr {
             ast::Expr::UnderscoreExpr(_) => self.alloc_pat_from_expr(Pat::Wild, syntax_ptr),
             ast::Expr::ParenExpr(e) => {
             _ => return None,
         };
         return Some(result);
-
         fn collect_path(this: &mut ExprCollector<'_>, expr: ast::Expr) -> Option<ast::PathExpr> {
             match expr {
                 ast::Expr::PathExpr(e) => Some(e),
                 _ => None,
             }
         }
-
         fn collect_possibly_rest(
             this: &mut ExprCollector<'_>,
             expr: ast::Expr,
                 _ => Either::Left(this.collect_expr_as_pat(expr)),
             }
         }
-
         fn collect_tuple(
             this: &mut ExprCollector<'_>,
             fields: ast::AstChildren<ast::Expr>,
         let result_expr_id = self.alloc_expr(Expr::Missing, syntax_ptr);
         let prev_binding_owner = self.current_binding_owner.take();
         self.current_binding_owner = Some(result_expr_id);
-
         (result_expr_id, prev_binding_owner)
     }
 
             name: Name::generate_new_name(self.store.labels.len()),
         });
         let old_label = self.current_try_block_label.replace(label);
-
         let ptr = AstPtr::new(&e).upcast();
         let (btail, expr_id) = self.with_labeled_rib(label, HygieneId::ROOT, |this| {
             let mut btail = None;
             });
             (btail, block)
         });
-
         let callee = self
             .alloc_expr_desugared_with_ptr(try_from_output.map_or(Expr::Missing, Expr::Path), ptr);
         let next_tail = match btail {
             (self.hygiene_id_for(label.syntax().text_range()), self.collect_label(label))
         });
         let body = self.collect_labelled_block_opt(label, e.loop_body());
-
         // Labels can also be used in the condition expression, like this:
         // ```
         // fn main() {
             }),
             None => self.collect_expr_opt(e.condition()),
         };
-
         let break_expr = self.alloc_expr(Expr::Break { expr: None, label: None }, syntax_ptr);
         let if_expr = self.alloc_expr(
             Expr::If { condition, then_branch: body, else_branch: Some(break_expr) },
         collector: impl FnOnce(&mut Self, Option<T>) -> U,
     ) -> U
     where
-        T: ast::AstNode,
-    {
+        T: ast::AstNode, {
         let macro_call_ptr = self.expander.in_file(syntax_ptr);
         let module = self.module.local_id;
-
         let block_call = self.def_map.modules[self.module.local_id].scope.macro_invoc(
             self.expander.in_file(self.expander.ast_id_map().ast_id_for_ptr(syntax_ptr)),
         );
                 )
             }
         };
-
         let res = match res {
             Ok(res) => res,
             Err(UnresolvedMacro { path }) => {
             }
         };
         // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
-
         match res.value {
             Some((mark, expansion)) => {
                 // Keep collecting even with expansion errors so we can provide completions and
             let ast_id = self.expander.in_file(file_local_id);
             self.db.intern_block(BlockLoc { ast_id, module: self.module })
         });
-
         let (module, def_map) =
             match block_id.map(|block_id| (block_def_map(self.db, block_id), block_id)) {
                 Some((def_map, block_id)) => {
         let prev_def_map = mem::replace(&mut self.def_map, def_map);
         let prev_local_module = mem::replace(&mut self.module, module);
         let prev_legacy_macros_count = mem::take(&mut self.current_block_legacy_macro_defs_count);
-
         let mut statements = Vec::new();
         block.statements().for_each(|s| self.collect_stmt(&mut statements, s));
         let tail = block.tail_expr().and_then(|e| match e {
             statements.push(stmt);
             None
         });
-
         let syntax_node_ptr = AstPtr::new(&block.into());
         let expr_id = self
             .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);
-
         self.def_map = prev_def_map;
         self.module = prev_local_module;
         self.current_block_legacy_macro_defs_count = prev_legacy_macros_count;
             None => self.collect_block_opt(expr),
         }
     }
-
     // region: patterns
 
     fn collect_pat_top(&mut self, pat: Option<ast::Pat>) -> PatId {
         // Find the location of the `..`, if there is one. Note that we do not
         // consider the possibility of there being multiple `..` here.
         let ellipsis = args.iter().position(|p| p.is_right()).map(|it| it as u32);
-
         // We want to skip the `..` pattern here, since we account for it above.
         let mut args: Vec<_> = args.into_iter().filter_map(Either::left).collect();
         // if there is a leading comma, the user is most likely to type out a leading pattern
         if has_leading_comma {
             args.insert(0, self.missing_pat());
         }
-
         (args.into_boxed_slice(), ellipsis)
     }
 
-    // `collect_pat` rejects `ast::Pat::RestPat`, but it should be handled in some cases that
-    // it is the macro expansion result of an arg sub-pattern in a slice or tuple pattern.
     fn collect_pat_possibly_rest(
         &mut self,
         pat: ast::Pat,
             _ => Either::Left(self.collect_pat(pat, binding_list)),
         }
     }
-
     // endregion: patterns
 
     /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when
     fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {
         self.store.binding_definitions.entry(binding_id).or_default().push(pat_id);
     }
-
     // region: labels
 
     fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {
             })
         };
         let name = Name::new_lifetime(&lifetime.text());
-
         for (rib_idx, rib) in self.label_ribs.iter().enumerate().rev() {
             match &rib.kind {
                 RibKind::Normal(label_name, id, label_hygiene) => {
                 _ => {}
             }
         }
-
         Err(ExpressionStoreDiagnostics::UndeclaredLabel {
             name,
             node: self.expander.in_file(AstPtr::new(&lifetime)),
     }
     // endregion: labels
 
-    // region: format
     fn expand_macros_to_string(&mut self, expr: ast::Expr) -> Option<(ast::String, bool)> {
         let m = match expr {
             ast::Expr::MacroExpr(m) => m,
                 HygieneId::ROOT,
             ),
         };
-
         // Create a list of all _unique_ (argument, format trait) combinations.
         // E.g. "{0} {0:x} {0} {1}" -> [(0, Display), (0, LowerHex), (1, Display)]
         let mut argmap = FxIndexSet::default();
                 argmap.insert((index, ArgumentType::Format(placeholder.format_trait)));
             }
         }
-
         let lit_pieces = fmt
             .template
             .iter()
                 mutability: Mutability::Shared,
             })
         };
-
         // Assume that rustc version >= 1.89.0 iff lang item `format_arguments` exists
         // but `format_unsafe_arg` does not
         let fmt_args =
         let fmt_unsafe_arg =
             || crate::lang_item::lang_item(self.db, self.module.krate(), LangItem::FormatUnsafeArg);
         let use_format_args_since_1_89_0 = fmt_args().is_some() && fmt_unsafe_arg().is_none();
-
         let idx = if use_format_args_since_1_89_0 {
             self.collect_format_args_impl(syntax_ptr, fmt, argmap, lit_pieces, format_options)
         } else {
                 format_options,
             )
         };
-
         self.store
             .template_map
             .get_or_insert_with(Default::default)
         format_options: ExprId,
     ) -> ExprId {
         let arguments = &*fmt.arguments.arguments;
-
         let args = if arguments.is_empty() {
             let expr = self
                 .alloc_expr_desugared(Expr::Array(Array::ElementList { elements: Box::default() }));
                 mutability: Mutability::Shared,
             })
         };
-
         // Generate:
         //     <core::fmt::Arguments>::new_v1_formatted(
         //         lit_pieces,
         //         format_options,
         //         unsafe { ::core::fmt::UnsafeArg::new() }
         //     )
-
         let new_v1_formatted = LangItem::FormatArguments.ty_rel_path(
             self.db,
             self.module.krate(),
         );
         let new_v1_formatted =
             self.alloc_expr_desugared(new_v1_formatted.map_or(Expr::Missing, Expr::Path));
-
         let unsafe_arg_new =
             self.alloc_expr_desugared(unsafe_arg_new.map_or(Expr::Missing, Expr::Path));
         let unsafe_arg_new =
                 label: None,
             });
         }
-
         self.alloc_expr(
             Expr::Call {
                 callee: new_v1_formatted,
         format_options: ExprId,
     ) -> ExprId {
         let arguments = &*fmt.arguments.arguments;
-
         let (let_stmts, args) = if arguments.is_empty() {
             (
                 // Generate:
             };
             (vec![let_stmt1, let_stmt2], self.alloc_expr_desugared(Expr::Path(args_name.into())))
         };
-
         // Generate:
         //     &args
         let args = self.alloc_expr_desugared(Expr::Ref {
             rawness: Rawness::Ref,
             mutability: Mutability::Shared,
         });
-
         let call_block = {
             // Generate:
             //     unsafe {
 
             Expr::Unsafe { id: None, statements: Box::default(), tail: Some(call) }
         };
-
         if !let_stmts.is_empty() {
             // Generate:
             //     {
             zero_pad,
             debug_hex,
         } = &placeholder.format_options;
-
         let precision_expr = self.make_count(precision, argmap);
         let width_expr = self.make_count(width, argmap);
-
         if self.module.krate().workspace_data(self.db).is_atleast_187() {
             // These need to match the constants in library/core/src/fmt/rt.rs.
             let align = match alignment {
     fn make_argument(&mut self, arg: ExprId, ty: ArgumentType) -> ExprId {
         use ArgumentType::*;
         use FormatTrait::*;
-
         let new_fn = match LangItem::FormatArgument.ty_rel_path(
             self.db,
             self.module.krate(),
         };
         self.alloc_expr_desugared(Expr::Call { callee: new_fn, args: Box::new([arg]) })
     }
-
     // endregion: format
 
     fn lang_path(&self, lang: LangItem) -> Option<Path> {
         self.store.expr_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed.
-    // Migrate to alloc_expr_desugared_with_ptr and then rename back
+
     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {
         self.store.exprs.alloc(expr)
     }
+
     fn alloc_expr_desugared_with_ptr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         // self.store.expr_map.insert(src, id);
         id
     }
+
     fn missing_expr(&mut self) -> ExprId {
         self.alloc_expr_desugared(Expr::Missing)
     }
         self.store.pat_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.
+
     fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {
         self.store.pats.alloc(pat)
     }
+
     fn missing_pat(&mut self) -> PatId {
         self.store.pats.alloc(Pat::Missing)
     }
         self.store.label_map.insert(src, id);
         id
     }
-    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.
+
     fn alloc_label_desugared(&mut self, label: Label) -> LabelId {
         self.store.labels.alloc(label)
     }