COMPARISON DIFF
============================================================

Original size: 144317 bytes
Chloro size:   144974 bytes
Rustfmt size:  144317 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     expr_store::{
         Body, BodySourceMap, ExprPtr, ExpressionStore, ExpressionStoreBuilder,
         ExpressionStoreDiagnostics, ExpressionStoreSourceMap, HygieneId, LabelPtr, LifetimePtr,
-        PatPtr, TypePtr,
-        expander::Expander,
-        lower::generics::ImplTraitLowerFn,
+        PatPtr, TypePtr, expander::Expander, lower::generics::ImplTraitLowerFn,
         path::{AssociatedTypeBinding, GenericArg, GenericArgs, GenericArgsParentheses, Path},
     },
     hir::{
     // with the inner macro, and that will cause confusion because they won't be the same as `ROOT`
     // even though they should be the same. Also, when the body comes from multiple expansions, their
     // hygiene is different.
-
     let mut self_param = None;
     let mut source_map_self_param = None;
     let mut params = vec![];
     local_def_map: &'db LocalDefMap,
     module: ModuleId,
     pub store: ExpressionStoreBuilder,
-
     // state stuff
     // Prevent nested impl traits like `impl Foo<impl Bar>`.
     outer_impl_trait: bool,
-
     is_lowering_coroutine: bool,
-
     /// Legacy (`macro_rules!`) macros can have multiple definitions and shadow each other,
     /// and we need to find the current definition. So we track the number of definitions we saw.
     current_block_legacy_macro_defs_count: FxHashMap<Name, usize>,
-
     current_try_block_label: Option<LabelId>,
-
     label_ribs: Vec<LabelRib>,
     current_binding_owner: Option<ExprId>,
-
     awaitable_context: Option<Awaitable>,
 }
 
 
     fn collect(&mut self, expr: Option<ast::Expr>, awaitable: Awaitable) -> ExprId {
         self.awaitable_context.replace(awaitable);
-        self.with_label_rib(RibKind::Closure, |this| {
+        self.with_label_rib(
+            RibKind::Closure,
+            |this| {
             if awaitable == Awaitable::Yes {
                 match expr {
                     Some(e) => {
             } else {
                 this.collect_expr_opt(expr)
             }
-        })
+        },
+        )
     }
 
     fn type_bounds_from_ast(
             ast::Expr::BlockExpr(e) => match e.modifier() {
                 Some(ast::BlockModifier::Try(_)) => self.desugar_try_block(e),
                 Some(ast::BlockModifier::Unsafe(_)) => {
-                    self.collect_block_(e, |id, statements, tail| Expr::Unsafe {
+                    self.collect_block_(
+                        e,
+                        |id, statements, tail| Expr::Unsafe {
                         id,
                         statements,
                         tail,
-                    })
+                    },
+                    )
                 }
                 Some(ast::BlockModifier::Label(label)) => {
                     let label_hygiene = self.hygiene_id_for(label.syntax().text_range());
                     let label_id = self.collect_label(label);
-                    self.with_labeled_rib(label_id, label_hygiene, |this| {
+                    self.with_labeled_rib(
+                        label_id,
+                        label_hygiene,
+                        |this| {
                         this.collect_block_(e, |id, statements, tail| Expr::Block {
                             id,
                             statements,
                             tail,
                             label: Some(label_id),
                         })
-                    })
+                    },
+                    )
                 }
                 Some(ast::BlockModifier::Async(_)) => {
-                    self.with_label_rib(RibKind::Closure, |this| {
+                    self.with_label_rib(
+                        RibKind::Closure,
+                        |this| {
                         this.with_awaitable_block(Awaitable::Yes, |this| {
                             this.collect_block_(e, |id, statements, tail| Expr::Async {
                                 id,
                                 tail,
                             })
                         })
-                    })
+                    },
+                    )
                 }
                 Some(ast::BlockModifier::Const(_)) => {
-                    self.with_label_rib(RibKind::Constant, |this| {
+                    self.with_label_rib(
+                        RibKind::Constant,
+                        |this| {
                         this.with_awaitable_block(Awaitable::No("constant block"), |this| {
                             let (result_expr_id, prev_binding_owner) =
                                 this.initialize_binding_owner(syntax_ptr);
                             this.current_binding_owner = prev_binding_owner;
                             result_expr_id
                         })
-                    })
+                    },
+                    )
                 }
                 // FIXME
                 Some(ast::BlockModifier::AsyncGen(_)) => {
                     self.with_awaitable_block(Awaitable::Yes, |this| this.collect_block(e))
                 }
-                Some(ast::BlockModifier::Gen(_)) => self
-                    .with_awaitable_block(Awaitable::No("non-async gen block"), |this| {
+                Some(ast::BlockModifier::Gen(_)) => self.with_awaitable_block(
+                    Awaitable::No("non-async gen block"),
+                    |this| {
                         this.collect_block(e)
-                    }),
+                    },
+                ),
                 None => self.collect_block(e),
             },
             ast::Expr::LoopExpr(e) => {
                     None => self.alloc_expr(Expr::Missing, syntax_ptr),
                 }
             }
-            ast::Expr::ClosureExpr(e) => self.with_label_rib(RibKind::Closure, |this| {
+            ast::Expr::ClosureExpr(e) => self.with_label_rib(
+                RibKind::Closure,
+                |this| {
                 let (result_expr_id, prev_binding_owner) =
                     this.initialize_binding_owner(syntax_ptr);
                 let mut args = Vec::new();
                     capture_by,
                 };
                 result_expr_id
-            }),
+            },
+            ),
             ast::Expr::BinExpr(e) => {
                 let op = e.op_kind();
                 if let Some(ast::BinaryOp::Assignment { op: None }) = op {
             Expr::If { condition, then_branch: body, else_branch: Some(break_expr) },
             syntax_ptr,
         );
-        self.alloc_expr(Expr::Loop { body: if_expr, label: label.map(|it| it.1) }, syntax_ptr)
+        self.alloc_expr(
+            Expr::Loop {
+            body: if_expr,
+            label: label.map(|it| it.1),
+        },
+            syntax_ptr,
+        )
     }
 
     /// Desugar `ast::ForExpr` from: `[opt_ident]: for <pat> in <head> <body>` into:
         self.add_definition_to_binding(iter_binding, iter_pat);
         self.alloc_expr(
             Expr::Match {
-                expr: iterator,
-                arms: Box::new([MatchArm { pat: iter_pat, guard: None, expr: loop_outer }]),
+            expr: iterator,
+            arms: Box::new([
+                MatchArm {
+                pat: iter_pat,
+                guard: None,
+                expr: loop_outer,
             },
+            ]),
+        },
             syntax_ptr,
         )
     }
                 return collector(self, None);
             }
         };
-        // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
 
+        // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
         match res.value {
             Some((mark, expansion)) => {
                 // Keep collecting even with expansion errors so we can provide completions and
     }
 
     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {
-        self.collect_block_(block, |id, statements, tail| Expr::Block {
+        self.collect_block_(
+            block,
+            |id, statements, tail| Expr::Block {
             id,
             statements,
             tail,
             label: None,
-        })
+        },
+        )
     }
 
     fn collect_block_(
         //         format_options,
         //         unsafe { ::core::fmt::UnsafeArg::new() }
         //     )
-
         let new_v1_formatted = LangItem::FormatArguments.ty_rel_path(
             self.db,
             self.module.krate(),
 
         self.alloc_expr(
             Expr::Call {
-                callee: new_v1_formatted,
-                args: Box::new([lit_pieces, args, format_options, unsafe_arg_new]),
-            },
+            callee: new_v1_formatted,
+            args: Box::new([lit_pieces, args, format_options, unsafe_arg_new]),
+        },
             syntax_ptr,
         )
     }
             let call = self.alloc_expr_desugared(call_block);
             self.alloc_expr(
                 Expr::Block {
-                    id: None,
-                    statements: let_stmts.into(),
-                    tail: Some(call),
-                    label: None,
-                },
+                id: None,
+                statements: let_stmts.into(),
+                tail: Some(call),
+                label: None,
+            },
                 syntax_ptr,
             )
         } else {
                     Some(count_is) => self.alloc_expr_desugared(Expr::Path(count_is)),
                     None => self.missing_expr(),
                 };
-                self.alloc_expr_desugared(Expr::Call { callee: count_is, args: Box::new([args]) })
+                self.alloc_expr_desugared(Expr::Call {
+                    callee: count_is,
+                    args: Box::new([args]),
+                })
             }
             Some(FormatCount::Argument(arg)) => {
                 if let Ok(arg_index) = arg.index {
             Some(new_fn) => self.alloc_expr_desugared(Expr::Path(new_fn)),
             None => self.missing_expr(),
         };
-        self.alloc_expr_desugared(Expr::Call { callee: new_fn, args: Box::new([arg]) })
+        self.alloc_expr_desugared(Expr::Call {
+            callee: new_fn,
+            args: Box::new([arg]),
+        })
     }
 
     // endregion: format
         self.store.expr_map.insert(src, id.into());
         id
     }
+
     // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed.
     // Migrate to alloc_expr_desugared_with_ptr and then rename back
     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {
         self.store.exprs.alloc(expr)
     }
+
     fn alloc_expr_desugared_with_ptr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         // self.store.expr_map.insert(src, id);
         id
     }
+
     fn missing_expr(&mut self) -> ExprId {
         self.alloc_expr_desugared(Expr::Missing)
     }
         self.store.pat_map.insert(src, id.into());
         id
     }
+
     // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.
     fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {
         self.store.pats.alloc(pat)
     }
+
     fn missing_pat(&mut self) -> PatId {
         self.store.pats.alloc(Pat::Missing)
     }
         self.store.label_map.insert(src, id);
         id
     }
+
     // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.
     fn alloc_label_desugared(&mut self, label: Label) -> LabelId {
         self.store.labels.alloc(label)
 }
 
 fn comma_follows_token(t: Option<syntax::SyntaxToken>) -> bool {
-    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))()
-        .is_some_and(|it| it.kind() == syntax::T![,])
+    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))().is_some_and(
+        |it| it.kind() == syntax::T![,],
+    )
 }
 
 #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]