COMPARISON DIFF
============================================================

Original size: 144317 bytes
Chloro size:   142988 bytes
Rustfmt size:  144317 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use cfg::CfgOptions;
 use either::Either;
 use hir_expand::{
-    HirFileId, InFile, MacroDefId,
     mod_path::tool_path,
     name::{AsName, Name},
     span_map::SpanMapRef,
+    HirFileId, InFile, MacroDefId,
 };
-use intern::{Symbol, sym};
+use intern::{sym, Symbol};
 use rustc_hash::FxHashMap;
 use stdx::never;
 use syntax::{
-    AstNode, AstPtr, AstToken as _, SyntaxNodePtr,
     ast::{
         self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasAttrs, HasGenericArgs,
         HasGenericParams, HasLoopBody, HasName, HasTypeBounds, IsString, RangeItem,
         SlicePatComponents,
     },
+    AstNode, AstPtr, AstToken as _, SyntaxNodePtr,
 };
 use thin_vec::ThinVec;
 use triomphe::Arc;
 use tt::TextRange;
 
 use crate::{
-    AdtId, BlockId, BlockLoc, DefWithBodyId, FunctionId, GenericDefId, ImplId, MacroId,
-    ModuleDefId, ModuleId, TraitId, TypeAliasId, UnresolvedMacro,
     builtin_type::BuiltinUint,
     db::DefDatabase,
     expr_store::{
+        expander::Expander, lower::generics::ImplTraitLowerFn,
+        path::{AssociatedTypeBinding, GenericArg, GenericArgs, GenericArgsParentheses, Path},
         Body, BodySourceMap, ExprPtr, ExpressionStore, ExpressionStoreBuilder,
         ExpressionStoreDiagnostics, ExpressionStoreSourceMap, HygieneId, LabelPtr, LifetimePtr,
         PatPtr, TypePtr,
-        expander::Expander,
-        lower::generics::ImplTraitLowerFn,
-        path::{AssociatedTypeBinding, GenericArg, GenericArgs, GenericArgsParentheses, Path},
     },
     hir::{
-        Array, Binding, BindingAnnotation, BindingId, BindingProblems, CaptureBy, ClosureKind,
-        Expr, ExprId, Item, Label, LabelId, Literal, MatchArm, Movability, OffsetOf, Pat, PatId,
-        RecordFieldPat, RecordLitField, Statement,
         format_args::{
             self, FormatAlignment, FormatArgs, FormatArgsPiece, FormatArgument, FormatArgumentKind,
             FormatArgumentsCollector, FormatCount, FormatDebugHex, FormatOptions,
             FormatPlaceholder, FormatSign, FormatTrait,
         },
-        generics::GenericParams,
+        generics::GenericParams, Array, Binding, BindingAnnotation, BindingId, BindingProblems,
+        CaptureBy, ClosureKind, Expr, ExprId, Item, Label, LabelId, Literal, MatchArm, Movability,
+        OffsetOf, Pat, PatId, RecordFieldPat, RecordLitField, Statement,
     },
     item_scope::BuiltinShadowMode,
     item_tree::FieldsShape,
     lang_item::LangItem,
-    nameres::{DefMap, LocalDefMap, MacroSubNs, block_def_map},
+    nameres::{block_def_map, DefMap, LocalDefMap, MacroSubNs},
     type_ref::{
         ArrayType, ConstRef, FnType, LifetimeRef, LifetimeRefId, Mutability, PathId, Rawness,
         RefType, TraitBoundModifier, TraitRef, TypeBound, TypeRef, TypeRefId, UseArgRef,
     },
+    AdtId, BlockId, BlockLoc, DefWithBodyId, FunctionId, GenericDefId, ImplId, MacroId,
+    ModuleDefId, ModuleId, TraitId, TypeAliasId, UnresolvedMacro,
 };
-
 pub use self::path::hir_segment_to_ast_segment;
 
 pub(super) fn lower_body(
     // with the inner macro, and that will cause confusion because they won't be the same as `ROOT`
     // even though they should be the same. Also, when the body comes from multiple expansions, their
     // hygiene is different.
-
     let mut self_param = None;
     let mut source_map_self_param = None;
     let mut params = vec![];
     local_def_map: &'db LocalDefMap,
     module: ModuleId,
     pub store: ExpressionStoreBuilder,
-
     // state stuff
     // Prevent nested impl traits like `impl Foo<impl Bar>`.
     outer_impl_trait: bool,
-
     is_lowering_coroutine: bool,
-
     /// Legacy (`macro_rules!`) macros can have multiple definitions and shadow each other,
     /// and we need to find the current definition. So we track the number of definitions we saw.
     current_block_legacy_macro_defs_count: FxHashMap<Name, usize>,
-
     current_try_block_label: Option<LabelId>,
-
     label_ribs: Vec<LabelRib>,
     current_binding_owner: Option<ExprId>,
-
     awaitable_context: Option<Awaitable>,
 }
 
 
     fn collect(&mut self, expr: Option<ast::Expr>, awaitable: Awaitable) -> ExprId {
         self.awaitable_context.replace(awaitable);
-        self.with_label_rib(RibKind::Closure, |this| {
+        self.with_label_rib(
+            RibKind::Closure,
+            |this| {
             if awaitable == Awaitable::Yes {
                 match expr {
                     Some(e) => {
                         let syntax_ptr = AstPtr::new(&e);
                         let expr = this.collect_expr(e);
                         this.alloc_expr_desugared_with_ptr(
-                            Expr::Async { id: None, statements: Box::new([]), tail: Some(expr) },
+                            Expr::Async {
+                            id: None,
+                            statements: Box::new([]),
+                            tail: Some(expr),
+                        },
                             syntax_ptr,
                         )
-                    }
+                    },
                     None => this.missing_expr(),
                 }
             } else {
                 this.collect_expr_opt(expr)
             }
-        })
+        },
+        )
     }
 
     fn type_bounds_from_ast(
                     Some(_) => TraitBoundModifier::Maybe,
                     None => TraitBoundModifier::None,
                 };
-                self.lower_path_type(&path_type, impl_trait_lower_fn)
-                    .map(|p| {
-                        let path = self.alloc_path(p, AstPtr::new(&path_type).upcast());
-                        if binder.is_empty() {
-                            TypeBound::Path(path, m)
-                        } else {
-                            TypeBound::ForLifetime(binder, path)
-                        }
-                    })
-                    .unwrap_or(TypeBound::Error)
-            }
-            ast::TypeBoundKind::Use(gal) => TypeBound::Use(
-                gal.use_bound_generic_args()
-                    .map(|p| match p {
-                        ast::UseBoundGenericArg::Lifetime(l) => {
-                            UseArgRef::Lifetime(self.lower_lifetime_ref(l))
-                        }
-                        ast::UseBoundGenericArg::NameRef(n) => UseArgRef::Name(n.as_name()),
-                    })
-                    .collect(),
-            ),
+                self.lower_path_type(&path_type, impl_trait_lower_fn).map(|p| {
+                    let path = self.alloc_path(p, AstPtr::new(&path_type).upcast());
+                    if binder.is_empty() {
+                        TypeBound::Path(path, m)
+                    } else {
+                        TypeBound::ForLifetime(binder, path)
+                    }
+                }).unwrap_or(
+                    TypeBound::Error,
+                )
+            },
+            ast::TypeBoundKind::Use(gal) => TypeBound::Use(gal.use_bound_generic_args().map(|p| match p {
+                ast::UseBoundGenericArg::Lifetime(l) => {
+                    UseArgRef::Lifetime(self.lower_lifetime_ref(l))
+                },
+                ast::UseBoundGenericArg::NameRef(n) => UseArgRef::Name(n.as_name()),
+            }).collect(
+            )),
             ast::TypeBoundKind::Lifetime(lifetime) => {
                 TypeBound::Lifetime(self.lower_lifetime_ref(lifetime))
-            }
+            },
         }
     }
 
         Some(match expr {
             ast::Expr::IfExpr(e) => {
                 let then_branch = self.collect_block_opt(e.then_branch());
-
                 let else_branch = e.else_branch().map(|b| match b {
                     ast::ElseBranch::Block(it) => self.collect_block(it),
                     ast::ElseBranch::IfExpr(elif) => {
                         self.collect_expr(expr)
                     }
                 });
-
                 let condition = self.collect_expr_opt(e.condition());
-
                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)
-            }
+            },
             ast::Expr::LetExpr(e) => {
                 let pat = self.collect_pat_top(e.pat());
                 let expr = self.collect_expr_opt(e.expr());
                 self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)
-            }
+            },
             ast::Expr::BlockExpr(e) => match e.modifier() {
                 Some(ast::BlockModifier::Try(_)) => self.desugar_try_block(e),
                 Some(ast::BlockModifier::Unsafe(_)) => {
-                    self.collect_block_(e, |id, statements, tail| Expr::Unsafe {
+                    self.collect_block_(
+                        e,
+                        |id, statements, tail| Expr::Unsafe {
                         id,
                         statements,
                         tail,
-                    })
-                }
+                    },
+                    )
+                },
                 Some(ast::BlockModifier::Label(label)) => {
                     let label_hygiene = self.hygiene_id_for(label.syntax().text_range());
                     let label_id = self.collect_label(label);
-                    self.with_labeled_rib(label_id, label_hygiene, |this| {
-                        this.collect_block_(e, |id, statements, tail| Expr::Block {
+                    self.with_labeled_rib(
+                        label_id,
+                        label_hygiene,
+                        |this| {
+                        this.collect_block_(
+                            e,
+                            |id, statements, tail| Expr::Block {
                             id,
                             statements,
                             tail,
                             label: Some(label_id),
-                        })
-                    })
-                }
+                        },
+                        )
+                    },
+                    )
+                },
                 Some(ast::BlockModifier::Async(_)) => {
-                    self.with_label_rib(RibKind::Closure, |this| {
-                        this.with_awaitable_block(Awaitable::Yes, |this| {
-                            this.collect_block_(e, |id, statements, tail| Expr::Async {
+                    self.with_label_rib(
+                        RibKind::Closure,
+                        |this| {
+                        this.with_awaitable_block(
+                            Awaitable::Yes,
+                            |this| {
+                            this.collect_block_(
+                                e,
+                                |id, statements, tail| Expr::Async {
                                 id,
                                 statements,
                                 tail,
-                            })
-                        })
-                    })
-                }
+                            },
+                            )
+                        },
+                        )
+                    },
+                    )
+                },
                 Some(ast::BlockModifier::Const(_)) => {
-                    self.with_label_rib(RibKind::Constant, |this| {
-                        this.with_awaitable_block(Awaitable::No("constant block"), |this| {
+                    self.with_label_rib(
+                        RibKind::Constant,
+                        |this| {
+                        this.with_awaitable_block(
+                            Awaitable::No("constant block"),
+                            |this| {
                             let (result_expr_id, prev_binding_owner) =
                                 this.initialize_binding_owner(syntax_ptr);
                             let inner_expr = this.collect_block(e);
                             this.store.exprs[result_expr_id] = Expr::Const(inner_expr);
                             this.current_binding_owner = prev_binding_owner;
                             result_expr_id
-                        })
-                    })
-                }
-                // FIXME
+                        },
+                        )
+                    },
+                    )
+                },
                 Some(ast::BlockModifier::AsyncGen(_)) => {
                     self.with_awaitable_block(Awaitable::Yes, |this| this.collect_block(e))
-                }
-                Some(ast::BlockModifier::Gen(_)) => self
-                    .with_awaitable_block(Awaitable::No("non-async gen block"), |this| {
-                        this.collect_block(e)
-                    }),
+                },
+                Some(ast::BlockModifier::Gen(_)) => self.with_awaitable_block(
+                    Awaitable::No("non-async gen block"),
+                    |this| {
+                    this.collect_block(e)
+                },
+                ),
                 None => self.collect_block(e),
             },
             ast::Expr::LoopExpr(e) => {
                 });
                 let body = self.collect_labelled_block_opt(label, e.loop_body());
                 self.alloc_expr(Expr::Loop { body, label: label.map(|it| it.1) }, syntax_ptr)
-            }
+            },
             ast::Expr::WhileExpr(e) => self.collect_while_loop(syntax_ptr, e),
             ast::Expr::ForExpr(e) => self.collect_for_loop(syntax_ptr, e),
             ast::Expr::CallExpr(e) => {
-                // FIXME: Remove this once we drop support for <1.86, https://github.com/rust-lang/rust/commit/ac9cb908ac4301dfc25e7a2edee574320022ae2c
                 let is_rustc_box = {
                     let attrs = e.attrs();
                     attrs.filter_map(|it| it.as_simple_atom()).any(|it| it == "rustc_box")
                     };
                     self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)
                 }
-            }
+            },
             ast::Expr::MethodCallExpr(e) => {
                 let receiver = self.collect_expr_opt(e.receiver());
                 let args = if let Some(arg_list) = e.arg_list() {
                     Expr::MethodCall { receiver, method_name, args, generic_args },
                     syntax_ptr,
                 )
-            }
+            },
             ast::Expr::MatchExpr(e) => {
                 let expr = self.collect_expr_opt(e.expr());
                 let arms = if let Some(match_arm_list) = e.match_arm_list() {
                     Box::default()
                 };
                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)
-            }
+            },
             ast::Expr::PathExpr(e) => {
                 let (path, hygiene) = self
                     .collect_expr_path(e)
                     self.store.ident_hygiene.insert(expr_id.into(), hygiene);
                 }
                 expr_id
-            }
+            },
             ast::Expr::ContinueExpr(e) => {
                 let label = self.resolve_label(e.lifetime()).unwrap_or_else(|e| {
                     self.store.diagnostics.push(e);
                     None
                 });
                 self.alloc_expr(Expr::Continue { label }, syntax_ptr)
-            }
+            },
             ast::Expr::BreakExpr(e) => {
                 let label = self.resolve_label(e.lifetime()).unwrap_or_else(|e| {
                     self.store.diagnostics.push(e);
                 });
                 let expr = e.expr().map(|e| self.collect_expr(e));
                 self.alloc_expr(Expr::Break { expr, label }, syntax_ptr)
-            }
+            },
             ast::Expr::ParenExpr(e) => {
                 let inner = self.collect_expr_opt(e.expr());
-                // make the paren expr point to the inner expression as well for IDE resolution
                 let src = self.expander.in_file(syntax_ptr);
                 self.store.expr_map.insert(src, inner.into());
                 inner
-            }
+            },
             ast::Expr::ReturnExpr(e) => {
                 let expr = e.expr().map(|e| self.collect_expr(e));
                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)
-            }
+            },
             ast::Expr::BecomeExpr(e) => {
                 let expr =
                     e.expr().map(|e| self.collect_expr(e)).unwrap_or_else(|| self.missing_expr());
                 self.alloc_expr(Expr::Become { expr }, syntax_ptr)
-            }
+            },
             ast::Expr::YieldExpr(e) => {
                 self.is_lowering_coroutine = true;
                 let expr = e.expr().map(|e| self.collect_expr(e));
                 self.alloc_expr(Expr::Yield { expr }, syntax_ptr)
-            }
+            },
             ast::Expr::YeetExpr(e) => {
                 let expr = e.expr().map(|e| self.collect_expr(e));
                 self.alloc_expr(Expr::Yeet { expr }, syntax_ptr)
-            }
+            },
             ast::Expr::RecordExpr(e) => {
                 let path = e
                     .path()
                 } else {
                     Expr::RecordLit { path, fields: Box::default(), spread: None }
                 };
-
                 self.alloc_expr(record_lit, syntax_ptr)
-            }
+            },
             ast::Expr::FieldExpr(e) => {
                 let expr = self.collect_expr_opt(e.expr());
                 let name = match e.field_access() {
                     _ => Name::missing(),
                 };
                 self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)
-            }
+            },
             ast::Expr::AwaitExpr(e) => {
                 let expr = self.collect_expr_opt(e.expr());
                 if let Awaitable::No(location) = self.is_lowering_awaitable_block() {
                     });
                 }
                 self.alloc_expr(Expr::Await { expr }, syntax_ptr)
-            }
+            },
             ast::Expr::TryExpr(e) => self.collect_try_operator(syntax_ptr, e),
             ast::Expr::CastExpr(e) => {
                 let expr = self.collect_expr_opt(e.expr());
                 let type_ref = self.lower_type_ref_opt_disallow_impl_trait(e.ty());
                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)
-            }
+            },
             ast::Expr::RefExpr(e) => {
                 let expr = self.collect_expr_opt(e.expr());
                 let raw_tok = e.raw_token().is_some();
                 };
                 let rawness = Rawness::from_raw(raw_tok);
                 self.alloc_expr(Expr::Ref { expr, rawness, mutability }, syntax_ptr)
-            }
+            },
             ast::Expr::PrefixExpr(e) => {
                 let expr = self.collect_expr_opt(e.expr());
                 match e.op_kind() {
                     Some(op) => self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr),
                     None => self.alloc_expr(Expr::Missing, syntax_ptr),
                 }
-            }
-            ast::Expr::ClosureExpr(e) => self.with_label_rib(RibKind::Closure, |this| {
+            },
+            ast::Expr::ClosureExpr(e) => self.with_label_rib(
+                RibKind::Closure,
+                |this| {
                 let (result_expr_id, prev_binding_owner) =
                     this.initialize_binding_owner(syntax_ptr);
                 let mut args = Vec::new();
                     .ret_type()
                     .and_then(|r| r.ty())
                     .map(|it| this.lower_type_ref_disallow_impl_trait(it));
-
                 let prev_is_lowering_coroutine = mem::take(&mut this.is_lowering_coroutine);
                 let prev_try_block_label = this.current_try_block_label.take();
-
                 let awaitable = if e.async_token().is_some() {
                     Awaitable::Yes
                 } else {
                 };
                 let body =
                     this.with_awaitable_block(awaitable, |this| this.collect_expr_opt(e.body()));
-
                 let closure_kind = if this.is_lowering_coroutine {
                     let movability = if e.static_token().is_some() {
                         Movability::Static
                     capture_by,
                 };
                 result_expr_id
-            }),
+            },
+            ),
             ast::Expr::BinExpr(e) => {
                 let op = e.op_kind();
                 if let Some(ast::BinaryOp::Assignment { op: None }) = op {
                     let rhs = self.collect_expr_opt(e.rhs());
                     self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)
                 }
-            }
+            },
             ast::Expr::TupleExpr(e) => {
                 let mut exprs: Vec<_> = e.fields().map(|expr| self.collect_expr(expr)).collect();
-                // if there is a leading comma, the user is most likely to type out a leading expression
-                // so we insert a missing expression at the beginning for IDE features
                 if comma_follows_token(e.l_paren_token()) {
                     exprs.insert(0, self.missing_expr());
                 }
-
                 self.alloc_expr(Expr::Tuple { exprs: exprs.into_boxed_slice() }, syntax_ptr)
-            }
+            },
             ast::Expr::ArrayExpr(e) => {
                 let kind = e.kind();
-
                 match kind {
                     ArrayExprKind::ElementList(e) => {
                         let elements = e.map(|expr| self.collect_expr(expr)).collect();
                         self.alloc_expr(Expr::Array(Array::ElementList { elements }), syntax_ptr)
-                    }
+                    },
                     ArrayExprKind::Repeat { initializer, repeat } => {
                         let initializer = self.collect_expr_opt(initializer);
                         let repeat = self.with_label_rib(RibKind::Constant, |this| {
                             Expr::Array(Array::Repeat { initializer, repeat }),
                             syntax_ptr,
                         )
-                    }
+                    },
                 }
-            }
-
+            },
             ast::Expr::Literal(e) => self.alloc_expr(Expr::Literal(e.kind().into()), syntax_ptr),
             ast::Expr::IndexExpr(e) => {
                 let base = self.collect_expr_opt(e.base());
                 let index = self.collect_expr_opt(e.index());
                 self.alloc_expr(Expr::Index { base, index }, syntax_ptr)
-            }
+            },
             ast::Expr::RangeExpr(e) => {
                 let lhs = e.start().map(|lhs| self.collect_expr(lhs));
                 let rhs = e.end().map(|rhs| self.collect_expr(rhs));
                 match e.op_kind() {
                     Some(range_type) => {
                         self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr)
-                    }
+                    },
                     None => self.alloc_expr(Expr::Missing, syntax_ptr),
                 }
-            }
+            },
             ast::Expr::MacroExpr(e) => {
                 let e = e.macro_call()?;
                 let macro_ptr = AstPtr::new(&e);
                 });
                 match id {
                     Some(id) => {
-                        // Make the macro-call point to its expanded expression so we can query
-                        // semantics on syntax pointers to the macro
                         let src = self.expander.in_file(syntax_ptr);
                         self.store.expr_map.insert(src, id.into());
                         id
-                    }
+                    },
                     None => self.alloc_expr(Expr::Missing, syntax_ptr),
                 }
-            }
+            },
             ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),
             ast::Expr::AsmExpr(e) => self.lower_inline_asm(e, syntax_ptr),
             ast::Expr::OffsetOfExpr(e) => {
                 let container = self.lower_type_ref_opt_disallow_impl_trait(e.ty());
                 let fields = e.fields().map(|it| it.as_name()).collect();
                 self.alloc_expr(Expr::OffsetOf(OffsetOf { container, fields }), syntax_ptr)
-            }
+            },
             ast::Expr::FormatArgsExpr(f) => self.collect_format_args(f, syntax_ptr),
         })
     }
     fn collect_expr_path(&mut self, e: ast::PathExpr) -> Option<(Path, HygieneId)> {
         e.path().and_then(|path| {
             let path = self.lower_path(path, &mut Self::impl_trait_error_allocator)?;
-            // Need to enable `mod_path.len() < 1` for `self`.
             let may_be_variable = matches!(&path, Path::BarePath(mod_path) if mod_path.len() <= 1);
             let hygiene = if may_be_variable {
                 self.hygiene_id_for(e.syntax().text_range())
         self.maybe_collect_expr_as_pat(&expr).unwrap_or_else(|| {
             let src = self.expander.in_file(AstPtr::new(&expr).wrap_left());
             let expr = self.collect_expr(expr);
-            // Do not use `alloc_pat_from_expr()` here, it will override the entry in `expr_map`.
             let id = self.store.pats.alloc(Pat::Expr(expr));
             self.store.pat_map_back.insert(id, src);
             id
         let body = self.collect_labelled_block_opt(label, e.loop_body());
 
         // Labels can also be used in the condition expression, like this:
+
         // ```
+
         // fn main() {
+
         //     let mut optional = Some(0);
+
         //     'my_label: while let Some(a) = match optional {
+
         //         None => break 'my_label,
+
         //         Some(val) => Some(val),
+
         //     } {
+
         //         println!("{}", a);
+
         //         optional = None;
+
         //     }
+
         // }
+
         // ```
         let condition = match label {
             Some((label_hygiene, label)) => self.with_labeled_rib(label, label_hygiene, |this| {
             Expr::If { condition, then_branch: body, else_branch: Some(break_expr) },
             syntax_ptr,
         );
-        self.alloc_expr(Expr::Loop { body: if_expr, label: label.map(|it| it.1) }, syntax_ptr)
+        self.alloc_expr(
+            Expr::Loop {
+            body: if_expr,
+            label: label.map(|it| it.1),
+        },
+            syntax_ptr,
+        )
     }
 
     /// Desugar `ast::ForExpr` from: `[opt_ident]: for <pat> in <head> <body>` into:
         self.add_definition_to_binding(iter_binding, iter_pat);
         self.alloc_expr(
             Expr::Match {
-                expr: iterator,
-                arms: Box::new([MatchArm { pat: iter_pat, guard: None, expr: loop_outer }]),
+            expr: iterator,
+            arms: Box::new([
+                MatchArm {
+                pat: iter_pat,
+                guard: None,
+                expr: loop_outer,
             },
+            ]),
+        },
             syntax_ptr,
         )
     }
             }
         };
         // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
-
         match res.value {
             Some((mark, expansion)) => {
-                // Keep collecting even with expansion errors so we can provide completions and
-                // other services in incomplete macro expressions.
                 if let Some(macro_file) = self.expander.current_file_id().macro_file() {
                     self.store.expansions.insert(macro_call_ptr, macro_file);
                 }
-
                 let id = collector(self, expansion.map(|it| it.tree()));
                 self.expander.exit(mark);
                 id
-            }
+            },
             None => collector(self, None),
         }
     }
             },
         );
         expansion.inspect(|&tail| {
-            // Make the macro-call point to its expanded expression so we can query
-            // semantics on syntax pointers to the macro
             let src = self.expander.in_file(syntax_ptr);
             self.store.expr_map.insert(src, tail.into());
         })
                     .and_then(|let_else| let_else.block_expr())
                     .map(|block| self.collect_block(block));
                 statements.push(Statement::Let { pat, type_ref, initializer, else_branch });
-            }
+            },
             ast::Stmt::ExprStmt(stmt) => {
                 let expr = stmt.expr();
                 match &expr {
                     _ => (),
                 }
                 let has_semi = stmt.semicolon_token().is_some();
-                // Note that macro could be expanded to multiple statements
                 if let Some(ast::Expr::MacroExpr(mac)) = expr {
                     if let Some(expr) = self.collect_macro_as_stmt(statements, mac) {
                         statements.push(Statement::Expr { expr, has_semi })
                     let expr = self.collect_expr_opt(expr);
                     statements.push(Statement::Expr { expr, has_semi });
                 }
-            }
+            },
             ast::Stmt::Item(ast::Item::MacroDef(macro_)) => {
                 if !self.check_cfg(&macro_) {
                     return;
                 let name = name.as_name();
                 let macro_id = self.def_map.modules[DefMap::ROOT].scope.get(&name).take_macros();
                 self.collect_macro_def(statements, macro_id);
-            }
+            },
             ast::Stmt::Item(ast::Item::MacroRules(macro_)) => {
                 if !self.check_cfg(&macro_) {
                     return;
                     .copied();
                 *macro_defs_count += 1;
                 self.collect_macro_def(statements, macro_id);
-            }
+            },
             ast::Stmt::Item(_item) => statements.push(Statement::Item(Item::Other)),
         }
     }
     }
 
     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {
-        self.collect_block_(block, |id, statements, tail| Expr::Block {
+        self.collect_block_(
+            block,
+            |id, statements, tail| Expr::Block {
             id,
             statements,
             tail,
             label: None,
-        })
+        },
+        )
     }
 
     fn collect_block_(
         match label {
             Some((hygiene, label)) => {
                 self.with_labeled_rib(label, hygiene, |this| this.collect_block_opt(expr))
-            }
+            },
             None => self.collect_block_opt(expr),
         }
     }
         (args.into_boxed_slice(), ellipsis)
     }
 
-    // `collect_pat` rejects `ast::Pat::RestPat`, but it should be handled in some cases that
-    // it is the macro expansion result of an arg sub-pattern in a slice or tuple pattern.
     fn collect_pat_possibly_rest(
         &mut self,
         pat: ast::Pat,
                         self.store.pat_map.insert(src, pat.into());
                     }
                     pat
-                }
+                },
                 None => {
                     let ptr = AstPtr::new(&pat);
                     Either::Left(self.alloc_pat(Pat::Missing, ptr))
-                }
+                },
             },
             _ => Either::Left(self.collect_pat(pat, binding_list)),
         }
                     opts: self.cfg_options.clone(),
                 });
                 false
-            }
+            },
         }
     }
 
     fn pop_label_rib(&mut self) {
         // We need to pop all macro defs, plus one rib.
         while let Some(LabelRib { kind: RibKind::MacroDef(_) }) = self.label_ribs.pop() {
-            // Do nothing.
         }
     }
 
     }
     // endregion: labels
 
-    // region: format
     fn expand_macros_to_string(&mut self, expr: ast::Expr) -> Option<(ast::String, bool)> {
         let m = match expr {
             ast::Expr::MacroExpr(m) => m,
         };
 
         // Create a list of all _unique_ (argument, format trait) combinations.
+
         // E.g. "{0} {0:x} {0} {1}" -> [(0, Display), (0, LowerHex), (1, Display)]
         let mut argmap = FxIndexSet::default();
         for piece in fmt.template.iter() {
         };
 
         // Assume that rustc version >= 1.89.0 iff lang item `format_arguments` exists
+
         // but `format_unsafe_arg` does not
         let fmt_args =
             || crate::lang_item::lang_item(self.db, self.module.krate(), LangItem::FormatArguments);
         };
 
         // Generate:
-        //     <core::fmt::Arguments>::new_v1_formatted(
-        //         lit_pieces,
-        //         args,
-        //         format_options,
-        //         unsafe { ::core::fmt::UnsafeArg::new() }
-        //     )
 
+        //     <core::fmt::Arguments>::new_v1_formatted(
+
+        //         lit_pieces,
+
+        //         args,
+
+        //         format_options,
+
+        //         unsafe { ::core::fmt::UnsafeArg::new() }
+
+        //     )
         let new_v1_formatted = LangItem::FormatArguments.ty_rel_path(
             self.db,
             self.module.krate(),
 
         self.alloc_expr(
             Expr::Call {
-                callee: new_v1_formatted,
-                args: Box::new([lit_pieces, args, format_options, unsafe_arg_new]),
-            },
+            callee: new_v1_formatted,
+            args: Box::new([lit_pieces, args, format_options, unsafe_arg_new]),
+        },
             syntax_ptr,
         )
     }
         };
 
         // Generate:
+
         //     &args
         let args = self.alloc_expr_desugared(Expr::Ref {
             expr: args,
         };
 
         if !let_stmts.is_empty() {
-            // Generate:
-            //     {
-            //         super let …
-            //         super let …
-            //         <core::fmt::Arguments>::new_…(…)
-            //     }
             let call = self.alloc_expr_desugared(call_block);
             self.alloc_expr(
                 Expr::Block {
-                    id: None,
-                    statements: let_stmts.into(),
-                    tail: Some(call),
-                    label: None,
-                },
+                id: None,
+                statements: let_stmts.into(),
+                tail: Some(call),
+                label: None,
+            },
                 syntax_ptr,
             )
         } else {
         let width_expr = self.make_count(width, argmap);
 
         if self.module.krate().workspace_data(self.db).is_atleast_187() {
-            // These need to match the constants in library/core/src/fmt/rt.rs.
             let align = match alignment {
                 Some(FormatAlignment::Left) => 0,
                 Some(FormatAlignment::Right) => 1,
                 Some(FormatAlignment::Center) => 2,
                 None => 3,
             };
-            // This needs to match `Flag` in library/core/src/fmt/rt.rs.
             let flags = fill.unwrap_or(' ') as u32
                 | ((sign == Some(FormatSign::Plus)) as u32) << 21
                 | ((sign == Some(FormatSign::Minus)) as u32) << 22
                 | (width.is_some() as u32) << 27
                 | (precision.is_some() as u32) << 28
                 | align << 29
-                | 1 << 31; // Highest bit always set.
+                | 1 << 31;
             let flags = self.alloc_expr_desugared(Expr::Literal(Literal::Uint(
                 flags as u128,
                 Some(BuiltinUint::U32),
             )));
-
             let position =
                 RecordLitField { name: Name::new_symbol_root(sym::position), expr: position };
             let flags = RecordLitField { name: Name::new_symbol_root(sym::flags), expr: flags };
                     None => self.missing_expr(),
                 }
             };
-            // This needs to match `Flag` in library/core/src/fmt/rt.rs.
             let flags: u32 = ((sign == Some(FormatSign::Plus)) as u32)
                 | (((sign == Some(FormatSign::Minus)) as u32) << 1)
                 | ((alternate as u32) << 2)
                     Some(count_is) => self.alloc_expr_desugared(Expr::Path(count_is)),
                     None => self.missing_expr(),
                 };
-                self.alloc_expr_desugared(Expr::Call { callee: count_is, args: Box::new([args]) })
-            }
+                self.alloc_expr_desugared(Expr::Call {
+                    callee: count_is,
+                    args: Box::new([args]),
+                })
+            },
             Some(FormatCount::Argument(arg)) => {
                 if let Ok(arg_index) = arg.index {
                     let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));
-
                     let args = self.alloc_expr_desugared(Expr::Literal(Literal::Uint(
                         i as u128,
                         Some(BuiltinUint::Usize),
                         args: Box::new([args]),
                     })
                 } else {
-                    // FIXME: This drops arg causing it to potentially not be resolved/type checked
-                    // when typing?
                     self.missing_expr()
                 }
-            }
+            },
             None => match LangItem::FormatCount.ty_rel_path(
                 self.db,
                 self.module.krate(),
             Some(new_fn) => self.alloc_expr_desugared(Expr::Path(new_fn)),
             None => self.missing_expr(),
         };
-        self.alloc_expr_desugared(Expr::Call { callee: new_fn, args: Box::new([arg]) })
+        self.alloc_expr_desugared(Expr::Call {
+            callee: new_fn,
+            args: Box::new([arg]),
+        })
     }
 
     // endregion: format
         self.store.expr_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed.
-    // Migrate to alloc_expr_desugared_with_ptr and then rename back
+
     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {
         self.store.exprs.alloc(expr)
     }
+
     fn alloc_expr_desugared_with_ptr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         // self.store.expr_map.insert(src, id);
         id
     }
+
     fn missing_expr(&mut self) -> ExprId {
         self.alloc_expr_desugared(Expr::Missing)
     }
         self.store.pat_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.
+
     fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {
         self.store.pats.alloc(pat)
     }
+
     fn missing_pat(&mut self) -> PatId {
         self.store.pats.alloc(Pat::Missing)
     }
         self.store.label_map.insert(src, id);
         id
     }
-    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.
+
     fn alloc_label_desugared(&mut self, label: Label) -> LabelId {
         self.store.labels.alloc(label)
     }
 }
 
 fn comma_follows_token(t: Option<syntax::SyntaxToken>) -> bool {
-    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))()
-        .is_some_and(|it| it.kind() == syntax::T![,])
+    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))().is_some_and(
+        |it| it.kind() == syntax::T![,],
+    )
 }
 
 #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]
     segment_args: &ast::GenericArgList,
     binding_idx: u32,
 ) -> Option<ast::AssocTypeArg> {
-    segment_args
-        .generic_args()
-        .filter_map(|arg| match arg {
-            ast::GenericArg::AssocTypeArg(it) => Some(it),
-            _ => None,
-        })
-        .filter(|binding| binding.param_list().is_none() && binding.name_ref().is_some())
-        .nth(binding_idx as usize)
+    segment_args.generic_args().filter_map(|arg| match arg {
+        ast::GenericArg::AssocTypeArg(it) => Some(it),
+        _ => None,
+    }).filter(
+        |binding| binding.param_list().is_none() && binding.name_ref().is_some(),
+    ).nth(
+        binding_idx as usize,
+    )
 }
 
 /// This function find the AST generic argument from the one in the HIR. Does not support the `Self` argument.
     arg_idx: u32,
     has_self_arg: bool,
 ) -> Option<ast::GenericArg> {
-    args.generic_args()
-        .filter(|arg| match arg {
-            ast::GenericArg::AssocTypeArg(_) => false,
-            ast::GenericArg::LifetimeArg(arg) => arg.lifetime().is_some(),
-            ast::GenericArg::ConstArg(_) | ast::GenericArg::TypeArg(_) => true,
-        })
-        .nth(arg_idx as usize - has_self_arg as usize)
+    args.generic_args().filter(|arg| match arg {
+        ast::GenericArg::AssocTypeArg(_) => false,
+        ast::GenericArg::LifetimeArg(arg) => arg.lifetime().is_some(),
+        ast::GenericArg::ConstArg(_) | ast::GenericArg::TypeArg(_) => true,
+    }).nth(
+        arg_idx as usize - has_self_arg as usize,
+    )
 }