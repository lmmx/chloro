COMPARISON DIFF
============================================================

Original size: 144317 bytes
Chloro size:   144892 bytes
Rustfmt size:  144317 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         RefType, TraitBoundModifier, TraitRef, TypeBound, TypeRef, TypeRefId, UseArgRef,
     },
 };
-
 pub use self::path::hir_segment_to_ast_segment;
 
 pub(super) fn lower_body(
     // with the inner macro, and that will cause confusion because they won't be the same as `ROOT`
     // even though they should be the same. Also, when the body comes from multiple expansions, their
     // hygiene is different.
-
     let mut self_param = None;
     let mut source_map_self_param = None;
     let mut params = vec![];
     let mut collector = ExprCollector::new(db, module, current_file_id);
-
     let skip_body = match owner {
         DefWithBodyId::FunctionId(it) => db.attrs(it.into()),
         DefWithBodyId::StaticId(it) => db.attrs(it.into()),
             BodySourceMap { self_param: source_map_self_param, store: source_map },
         );
     }
-
     if let Some(param_list) = parameters {
         if let Some(self_param_syn) = param_list.self_param().filter(|it| collector.check_cfg(it)) {
             let is_mutable =
             }
         }
     };
-
     let body_expr = collector.collect(
         body,
         if is_async_fn {
             }
         },
     );
-
     let (store, source_map) = collector.store.finish();
     (
         Body { store, params: params.into_boxed_slice(), self_param, body_expr },
     let return_type = fn_.value.ret_type().map(|ret_type| {
         expr_collector.lower_type_ref_opt(ret_type.ty(), &mut ExprCollector::impl_trait_allocator)
     });
-
     let return_type = if fn_.value.async_token().is_some() {
         let path = hir_expand::mod_path::path![core::future::Future];
         let mut generic_args: Vec<_> =
     local_def_map: &'db LocalDefMap,
     module: ModuleId,
     pub store: ExpressionStoreBuilder,
-
-    // state stuff
-    // Prevent nested impl traits like `impl Foo<impl Bar>`.
     outer_impl_trait: bool,
-
     is_lowering_coroutine: bool,
-
     /// Legacy (`macro_rules!`) macros can have multiple definitions and shadow each other,
     /// and we need to find the current definition. So we track the number of definitions we saw.
     current_block_legacy_macro_defs_count: FxHashMap<Name, usize>,
-
     current_try_block_label: Option<LabelId>,
-
     label_ribs: Vec<LabelRib>,
     current_binding_owner: Option<ExprId>,
-
     awaitable_context: Option<Awaitable>,
 }
 
         id
     }
 
-    fn check_is_used(&mut self, ec: &mut ExprCollector<'_>, id: BindingId) {
+    fn check_is_used(
+        &mut self,
+        ec: &mut ExprCollector<'_>,
+        id: BindingId,
+    ) {
         match self.is_used.get(&id) {
             None => {
                 if self.reject_new {
         self.expander.span_map()
     }
 
-    pub fn lower_lifetime_ref(&mut self, lifetime: ast::Lifetime) -> LifetimeRefId {
+    pub fn lower_lifetime_ref(
+        &mut self,
+        lifetime: ast::Lifetime,
+    ) -> LifetimeRefId {
         // FIXME: Keyword check?
         let lifetime_ref = match &*lifetime.text() {
             "" | "'" => LifetimeRef::Error,
         self.alloc_lifetime_ref(lifetime_ref, AstPtr::new(&lifetime))
     }
 
-    pub fn lower_lifetime_ref_opt(&mut self, lifetime: Option<ast::Lifetime>) -> LifetimeRefId {
+    pub fn lower_lifetime_ref_opt(
+        &mut self,
+        lifetime: Option<ast::Lifetime>,
+    ) -> LifetimeRefId {
         match lifetime {
             Some(lifetime) => self.lower_lifetime_ref(lifetime),
             None => self.alloc_lifetime_ref_desugared(LifetimeRef::Placeholder),
         self.alloc_type_ref(ty, AstPtr::new(&node))
     }
 
-    pub(crate) fn lower_type_ref_disallow_impl_trait(&mut self, node: ast::Type) -> TypeRefId {
+    pub(crate) fn lower_type_ref_disallow_impl_trait(
+        &mut self,
+        node: ast::Type,
+    ) -> TypeRefId {
         self.lower_type_ref(node, &mut Self::impl_trait_error_allocator)
     }
 
         self.lower_type_ref_opt(node, &mut Self::impl_trait_error_allocator)
     }
 
-    fn alloc_type_ref(&mut self, type_ref: TypeRef, node: TypePtr) -> TypeRefId {
+    fn alloc_type_ref(
+        &mut self,
+        type_ref: TypeRef,
+        node: TypePtr,
+    ) -> TypeRefId {
         let id = self.store.types.alloc(type_ref);
         let ptr = self.expander.in_file(node);
         self.store.types_map_back.insert(id, ptr);
         id
     }
 
-    fn alloc_type_ref_desugared(&mut self, type_ref: TypeRef) -> TypeRefId {
+    fn alloc_type_ref_desugared(
+        &mut self,
+        type_ref: TypeRef,
+    ) -> TypeRefId {
         self.store.types.alloc(type_ref)
     }
 
-    fn alloc_lifetime_ref_desugared(&mut self, lifetime_ref: LifetimeRef) -> LifetimeRefId {
+    fn alloc_lifetime_ref_desugared(
+        &mut self,
+        lifetime_ref: LifetimeRef,
+    ) -> LifetimeRefId {
         self.store.lifetimes.alloc(lifetime_ref)
     }
 
         ec.alloc_type_ref(TypeRef::ImplTrait(bounds), ptr)
     }
 
-    fn alloc_path(&mut self, path: Path, node: TypePtr) -> PathId {
+    fn alloc_path(
+        &mut self,
+        path: Path,
+        node: TypePtr,
+    ) -> PathId {
         PathId::from_type_ref_unchecked(self.alloc_type_ref(TypeRef::Path(path), node))
     }
 
                 }
             }
         }
-
         if args.is_empty() && bindings.is_empty() {
             return None;
         }
         })
     }
 
-    fn collect(&mut self, expr: Option<ast::Expr>, awaitable: Awaitable) -> ExprId {
+    fn collect(
+        &mut self,
+        expr: Option<ast::Expr>,
+        awaitable: Awaitable,
+    ) -> ExprId {
         self.awaitable_context.replace(awaitable);
         self.with_label_rib(RibKind::Closure, |this| {
             if awaitable == Awaitable::Yes {
         }
     }
 
-    fn lower_const_arg_opt(&mut self, arg: Option<ast::ConstArg>) -> ConstRef {
+    fn lower_const_arg_opt(
+        &mut self,
+        arg: Option<ast::ConstArg>,
+    ) -> ConstRef {
         ConstRef { expr: self.collect_expr_opt(arg.and_then(|it| it.expr())) }
     }
 
-    fn lower_const_arg(&mut self, arg: ast::ConstArg) -> ConstRef {
+    fn lower_const_arg(
+        &mut self,
+        arg: ast::ConstArg,
+    ) -> ConstRef {
         ConstRef { expr: self.collect_expr_opt(arg.expr()) }
     }
 
-    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {
+    fn collect_expr(
+        &mut self,
+        expr: ast::Expr,
+    ) -> ExprId {
         self.maybe_collect_expr(expr).unwrap_or_else(|| self.missing_expr())
     }
 
     /// Returns `None` if and only if the expression is `#[cfg]`d out.
-    fn maybe_collect_expr(&mut self, expr: ast::Expr) -> Option<ExprId> {
+    fn maybe_collect_expr(
+        &mut self,
+        expr: ast::Expr,
+    ) -> Option<ExprId> {
         let syntax_ptr = AstPtr::new(&expr);
         if !self.check_cfg(&expr) {
             return None;
         }
-
         // FIXME: Move some of these arms out into separate methods for clarity
         Some(match expr {
             ast::Expr::IfExpr(e) => {
         })
     }
 
-    fn collect_expr_path(&mut self, e: ast::PathExpr) -> Option<(Path, HygieneId)> {
+    fn collect_expr_path(
+        &mut self,
+        e: ast::PathExpr,
+    ) -> Option<(Path, HygieneId)> {
         e.path().and_then(|path| {
             let path = self.lower_path(path, &mut Self::impl_trait_error_allocator)?;
             // Need to enable `mod_path.len() < 1` for `self`.
         })
     }
 
-    fn collect_expr_as_pat_opt(&mut self, expr: Option<ast::Expr>) -> PatId {
+    fn collect_expr_as_pat_opt(
+        &mut self,
+        expr: Option<ast::Expr>,
+    ) -> PatId {
         match expr {
             Some(expr) => self.collect_expr_as_pat(expr),
             _ => self.missing_pat(),
         }
     }
 
-    fn collect_expr_as_pat(&mut self, expr: ast::Expr) -> PatId {
+    fn collect_expr_as_pat(
+        &mut self,
+        expr: ast::Expr,
+    ) -> PatId {
         self.maybe_collect_expr_as_pat(&expr).unwrap_or_else(|| {
             let src = self.expander.in_file(AstPtr::new(&expr).wrap_left());
             let expr = self.collect_expr(expr);
         })
     }
 
-    fn maybe_collect_expr_as_pat(&mut self, expr: &ast::Expr) -> Option<PatId> {
+    fn maybe_collect_expr_as_pat(
+        &mut self,
+        expr: &ast::Expr,
+    ) -> Option<PatId> {
         if !self.check_cfg(expr) {
             return None;
         }
         let syntax_ptr = AstPtr::new(expr);
-
         let result = match expr {
             ast::Expr::UnderscoreExpr(_) => self.alloc_pat_from_expr(Pat::Wild, syntax_ptr),
             ast::Expr::ParenExpr(e) => {
             _ => return None,
         };
         return Some(result);
-
         fn collect_path(this: &mut ExprCollector<'_>, expr: ast::Expr) -> Option<ast::PathExpr> {
             match expr {
                 ast::Expr::PathExpr(e) => Some(e),
                 _ => None,
             }
         }
-
         fn collect_possibly_rest(
             this: &mut ExprCollector<'_>,
             expr: ast::Expr,
                 _ => Either::Left(this.collect_expr_as_pat(expr)),
             }
         }
-
         fn collect_tuple(
             this: &mut ExprCollector<'_>,
             fields: ast::AstChildren<ast::Expr>,
         let result_expr_id = self.alloc_expr(Expr::Missing, syntax_ptr);
         let prev_binding_owner = self.current_binding_owner.take();
         self.current_binding_owner = Some(result_expr_id);
-
         (result_expr_id, prev_binding_owner)
     }
 
     /// Desugar `try { <stmts>; <expr> }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(<expr>) }`,
     /// `try { <stmts>; }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(()) }`
     /// and save the `<new_label>` to use it as a break target for desugaring of the `?` operator.
-    fn desugar_try_block(&mut self, e: BlockExpr) -> ExprId {
+    fn desugar_try_block(
+        &mut self,
+        e: BlockExpr,
+    ) -> ExprId {
         let try_from_output = self.lang_path(LangItem::TryTraitFromOutput);
         let label = self.alloc_label_desugared(Label {
             name: Name::generate_new_name(self.store.labels.len()),
         });
         let old_label = self.current_try_block_label.replace(label);
-
         let ptr = AstPtr::new(&e).upcast();
         let (btail, expr_id) = self.with_labeled_rib(label, HygieneId::ROOT, |this| {
             let mut btail = None;
             });
             (btail, block)
         });
-
         let callee = self
             .alloc_expr_desugared_with_ptr(try_from_output.map_or(Expr::Missing, Expr::Path), ptr);
         let next_tail = match btail {
     /// ```
     /// FIXME: Rustc wraps the condition in a construct equivalent to `{ let _t = <cond>; _t }`
     /// to preserve drop semantics. We should probably do the same in future.
-    fn collect_while_loop(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::WhileExpr) -> ExprId {
+    fn collect_while_loop(
+        &mut self,
+        syntax_ptr: AstPtr<ast::Expr>,
+        e: ast::WhileExpr,
+    ) -> ExprId {
         let label = e.label().map(|label| {
             (self.hygiene_id_for(label.syntax().text_range()), self.collect_label(label))
         });
         let body = self.collect_labelled_block_opt(label, e.loop_body());
-
         // Labels can also be used in the condition expression, like this:
         // ```
         // fn main() {
             }),
             None => self.collect_expr_opt(e.condition()),
         };
-
         let break_expr = self.alloc_expr(Expr::Break { expr: None, label: None }, syntax_ptr);
         let if_expr = self.alloc_expr(
             Expr::If { condition, then_branch: body, else_branch: Some(break_expr) },
     ///     }
     /// }
     /// ```
-    fn collect_for_loop(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::ForExpr) -> ExprId {
+    fn collect_for_loop(
+        &mut self,
+        syntax_ptr: AstPtr<ast::Expr>,
+        e: ast::ForExpr,
+    ) -> ExprId {
         let into_iter_fn = self.lang_path(LangItem::IntoIterIntoIter);
         let iter_next_fn = self.lang_path(LangItem::IteratorNext);
         let option_some = self.lang_path(LangItem::OptionSome);
     ///         return Try::from_residual(residual),
     /// }
     /// ```
-    fn collect_try_operator(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::TryExpr) -> ExprId {
+    fn collect_try_operator(
+        &mut self,
+        syntax_ptr: AstPtr<ast::Expr>,
+        e: ast::TryExpr,
+    ) -> ExprId {
         let try_branch = self.lang_path(LangItem::TryTraitBranch);
         let cf_continue = self.lang_path(LangItem::ControlFlowContinue);
         let cf_break = self.lang_path(LangItem::ControlFlowBreak);
         collector: impl FnOnce(&mut Self, Option<T>) -> U,
     ) -> U
     where
-        T: ast::AstNode,
-    {
+        T: ast::AstNode, {
         let macro_call_ptr = self.expander.in_file(syntax_ptr);
         let module = self.module.local_id;
-
         let block_call = self.def_map.modules[self.module.local_id].scope.macro_invoc(
             self.expander.in_file(self.expander.ast_id_map().ast_id_for_ptr(syntax_ptr)),
         );
                 )
             }
         };
-
         let res = match res {
             Ok(res) => res,
             Err(UnresolvedMacro { path }) => {
             }
         };
         // No need to push macro and parsing errors as they'll be recreated from `macro_calls()`.
-
         match res.value {
             Some((mark, expansion)) => {
                 // Keep collecting even with expansion errors so we can provide completions and
         }
     }
 
-    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {
+    fn collect_expr_opt(
+        &mut self,
+        expr: Option<ast::Expr>,
+    ) -> ExprId {
         match expr {
             Some(expr) => self.collect_expr(expr),
             None => self.missing_expr(),
         })
     }
 
-    fn collect_stmt(&mut self, statements: &mut Vec<Statement>, s: ast::Stmt) {
+    fn collect_stmt(
+        &mut self,
+        statements: &mut Vec<Statement>,
+        s: ast::Stmt,
+    ) {
         match s {
             ast::Stmt::LetStmt(stmt) => {
                 if !self.check_cfg(&stmt) {
         }
     }
 
-    fn collect_macro_def(&mut self, statements: &mut Vec<Statement>, macro_id: Option<MacroId>) {
+    fn collect_macro_def(
+        &mut self,
+        statements: &mut Vec<Statement>,
+        macro_id: Option<MacroId>,
+    ) {
         let Some(macro_id) = macro_id else {
             never!("def map should have macro definition, but it doesn't");
             statements.push(Statement::Item(Item::Other));
         self.label_ribs.push(LabelRib::new(RibKind::MacroDef(Box::new(macro_id))));
     }
 
-    fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {
+    fn collect_block(
+        &mut self,
+        block: ast::BlockExpr,
+    ) -> ExprId {
         self.collect_block_(block, |id, statements, tail| Expr::Block {
             id,
             statements,
             let ast_id = self.expander.in_file(file_local_id);
             self.db.intern_block(BlockLoc { ast_id, module: self.module })
         });
-
         let (module, def_map) =
             match block_id.map(|block_id| (block_def_map(self.db, block_id), block_id)) {
                 Some((def_map, block_id)) => {
         let prev_def_map = mem::replace(&mut self.def_map, def_map);
         let prev_local_module = mem::replace(&mut self.module, module);
         let prev_legacy_macros_count = mem::take(&mut self.current_block_legacy_macro_defs_count);
-
         let mut statements = Vec::new();
         block.statements().for_each(|s| self.collect_stmt(&mut statements, s));
         let tail = block.tail_expr().and_then(|e| match e {
             statements.push(stmt);
             None
         });
-
         let syntax_node_ptr = AstPtr::new(&block.into());
         let expr_id = self
             .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);
-
         self.def_map = prev_def_map;
         self.module = prev_local_module;
         self.current_block_legacy_macro_defs_count = prev_legacy_macros_count;
         expr_id
     }
 
-    fn collect_block_opt(&mut self, expr: Option<ast::BlockExpr>) -> ExprId {
+    fn collect_block_opt(
+        &mut self,
+        expr: Option<ast::BlockExpr>,
+    ) -> ExprId {
         match expr {
             Some(block) => self.collect_block(block),
             None => self.missing_expr(),
             None => self.collect_block_opt(expr),
         }
     }
-
     // region: patterns
 
-    fn collect_pat_top(&mut self, pat: Option<ast::Pat>) -> PatId {
+    fn collect_pat_top(
+        &mut self,
+        pat: Option<ast::Pat>,
+    ) -> PatId {
         match pat {
             Some(pat) => self.collect_pat(pat, &mut BindingList::default()),
             None => self.missing_pat(),
         }
     }
 
-    fn collect_pat(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {
+    fn collect_pat(
+        &mut self,
+        pat: ast::Pat,
+        binding_list: &mut BindingList,
+    ) -> PatId {
         let pattern = match &pat {
             ast::Pat::IdentPat(bp) => {
                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);
         self.alloc_pat(pattern, ptr)
     }
 
-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {
+    fn collect_pat_opt(
+        &mut self,
+        pat: Option<ast::Pat>,
+        binding_list: &mut BindingList,
+    ) -> PatId {
         match pat {
             Some(pat) => self.collect_pat(pat, binding_list),
             None => self.missing_pat(),
         // Find the location of the `..`, if there is one. Note that we do not
         // consider the possibility of there being multiple `..` here.
         let ellipsis = args.iter().position(|p| p.is_right()).map(|it| it as u32);
-
         // We want to skip the `..` pattern here, since we account for it above.
         let mut args: Vec<_> = args.into_iter().filter_map(Either::left).collect();
         // if there is a leading comma, the user is most likely to type out a leading pattern
         if has_leading_comma {
             args.insert(0, self.missing_pat());
         }
-
         (args.into_boxed_slice(), ellipsis)
     }
 
-    // `collect_pat` rejects `ast::Pat::RestPat`, but it should be handled in some cases that
-    // it is the macro expansion result of an arg sub-pattern in a slice or tuple pattern.
     fn collect_pat_possibly_rest(
         &mut self,
         pat: ast::Pat,
             _ => Either::Left(self.collect_pat(pat, binding_list)),
         }
     }
-
     // endregion: patterns
 
     /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when
     /// not.
-    fn check_cfg(&mut self, owner: &dyn ast::HasAttrs) -> bool {
+    fn check_cfg(
+        &mut self,
+        owner: &dyn ast::HasAttrs,
+    ) -> bool {
         let enabled = self.expander.is_cfg_enabled(self.db, owner, self.cfg_options);
         match enabled {
             Ok(()) => true,
         }
     }
 
-    fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {
+    fn add_definition_to_binding(
+        &mut self,
+        binding_id: BindingId,
+        pat_id: PatId,
+    ) {
         self.store.binding_definitions.entry(binding_id).or_default().push(pat_id);
     }
-
     // region: labels
 
-    fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {
+    fn collect_label(
+        &mut self,
+        ast_label: ast::Label,
+    ) -> LabelId {
         let label = Label {
             name: ast_label
                 .lifetime()
             })
         };
         let name = Name::new_lifetime(&lifetime.text());
-
         for (rib_idx, rib) in self.label_ribs.iter().enumerate().rev() {
             match &rib.kind {
                 RibKind::Normal(label_name, id, label_hygiene) => {
                 _ => {}
             }
         }
-
         Err(ExpressionStoreDiagnostics::UndeclaredLabel {
             name,
             node: self.expander.in_file(AstPtr::new(&lifetime)),
         })
     }
 
-    fn is_label_valid_from_rib(&self, rib_index: usize) -> bool {
+    fn is_label_valid_from_rib(
+        &self,
+        rib_index: usize,
+    ) -> bool {
         !self.label_ribs[rib_index + 1..].iter().any(|rib| rib.kind.is_label_barrier())
     }
 
         }
     }
 
-    fn with_label_rib<T>(&mut self, kind: RibKind, f: impl FnOnce(&mut Self) -> T) -> T {
+    fn with_label_rib<T>(
+        &mut self,
+        kind: RibKind,
+        f: impl FnOnce(&mut Self) -> T,
+    ) -> T {
         self.label_ribs.push(LabelRib::new(kind));
         let res = f(self);
         self.pop_label_rib();
     }
     // endregion: labels
 
-    // region: format
-    fn expand_macros_to_string(&mut self, expr: ast::Expr) -> Option<(ast::String, bool)> {
+    fn expand_macros_to_string(
+        &mut self,
+        expr: ast::Expr,
+    ) -> Option<(ast::String, bool)> {
         let m = match expr {
             ast::Expr::MacroExpr(m) => m,
             ast::Expr::Literal(l) => {
                 HygieneId::ROOT,
             ),
         };
-
         // Create a list of all _unique_ (argument, format trait) combinations.
         // E.g. "{0} {0:x} {0} {1}" -> [(0, Display), (0, LowerHex), (1, Display)]
         let mut argmap = FxIndexSet::default();
                 argmap.insert((index, ArgumentType::Format(placeholder.format_trait)));
             }
         }
-
         let lit_pieces = fmt
             .template
             .iter()
                 mutability: Mutability::Shared,
             })
         };
-
         // Assume that rustc version >= 1.89.0 iff lang item `format_arguments` exists
         // but `format_unsafe_arg` does not
         let fmt_args =
         let fmt_unsafe_arg =
             || crate::lang_item::lang_item(self.db, self.module.krate(), LangItem::FormatUnsafeArg);
         let use_format_args_since_1_89_0 = fmt_args().is_some() && fmt_unsafe_arg().is_none();
-
         let idx = if use_format_args_since_1_89_0 {
             self.collect_format_args_impl(syntax_ptr, fmt, argmap, lit_pieces, format_options)
         } else {
                 format_options,
             )
         };
-
         self.store
             .template_map
             .get_or_insert_with(Default::default)
         format_options: ExprId,
     ) -> ExprId {
         let arguments = &*fmt.arguments.arguments;
-
         let args = if arguments.is_empty() {
             let expr = self
                 .alloc_expr_desugared(Expr::Array(Array::ElementList { elements: Box::default() }));
                 mutability: Mutability::Shared,
             })
         };
-
         // Generate:
         //     <core::fmt::Arguments>::new_v1_formatted(
         //         lit_pieces,
         //         format_options,
         //         unsafe { ::core::fmt::UnsafeArg::new() }
         //     )
-
         let new_v1_formatted = LangItem::FormatArguments.ty_rel_path(
             self.db,
             self.module.krate(),
         );
         let new_v1_formatted =
             self.alloc_expr_desugared(new_v1_formatted.map_or(Expr::Missing, Expr::Path));
-
         let unsafe_arg_new =
             self.alloc_expr_desugared(unsafe_arg_new.map_or(Expr::Missing, Expr::Path));
         let unsafe_arg_new =
                 label: None,
             });
         }
-
         self.alloc_expr(
             Expr::Call {
                 callee: new_v1_formatted,
         format_options: ExprId,
     ) -> ExprId {
         let arguments = &*fmt.arguments.arguments;
-
         let (let_stmts, args) = if arguments.is_empty() {
             (
                 // Generate:
             };
             (vec![let_stmt1, let_stmt2], self.alloc_expr_desugared(Expr::Path(args_name.into())))
         };
-
         // Generate:
         //     &args
         let args = self.alloc_expr_desugared(Expr::Ref {
             rawness: Rawness::Ref,
             mutability: Mutability::Shared,
         });
-
         let call_block = {
             // Generate:
             //     unsafe {
 
             Expr::Unsafe { id: None, statements: Box::default(), tail: Some(call) }
         };
-
         if !let_stmts.is_empty() {
             // Generate:
             //     {
             zero_pad,
             debug_hex,
         } = &placeholder.format_options;
-
         let precision_expr = self.make_count(precision, argmap);
         let width_expr = self.make_count(width, argmap);
-
         if self.module.krate().workspace_data(self.db).is_atleast_187() {
             // These need to match the constants in library/core/src/fmt/rt.rs.
             let align = match alignment {
     /// ```text
     ///     <core::fmt::Argument>::new_…(arg)
     /// ```
-    fn make_argument(&mut self, arg: ExprId, ty: ArgumentType) -> ExprId {
+    fn make_argument(
+        &mut self,
+        arg: ExprId,
+        ty: ArgumentType,
+    ) -> ExprId {
         use ArgumentType::*;
         use FormatTrait::*;
-
         let new_fn = match LangItem::FormatArgument.ty_rel_path(
             self.db,
             self.module.krate(),
         };
         self.alloc_expr_desugared(Expr::Call { callee: new_fn, args: Box::new([arg]) })
     }
-
     // endregion: format
 
-    fn lang_path(&self, lang: LangItem) -> Option<Path> {
+    fn lang_path(
+        &self,
+        lang: LangItem,
+    ) -> Option<Path> {
         lang.path(self.db, self.module.krate())
     }
 }
 }
 
 impl ExprCollector<'_> {
-    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
+    fn alloc_expr(
+        &mut self,
+        expr: Expr,
+        ptr: ExprPtr,
+    ) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         self.store.expr_map_back.insert(id, src.map(AstPtr::wrap_left));
         self.store.expr_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed.
-    // Migrate to alloc_expr_desugared_with_ptr and then rename back
-    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {
+
+    fn alloc_expr_desugared(
+        &mut self,
+        expr: Expr,
+    ) -> ExprId {
         self.store.exprs.alloc(expr)
     }
-    fn alloc_expr_desugared_with_ptr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {
+
+    fn alloc_expr_desugared_with_ptr(
+        &mut self,
+        expr: Expr,
+        ptr: ExprPtr,
+    ) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         self.store.expr_map_back.insert(id, src.map(AstPtr::wrap_left));
         // self.store.expr_map.insert(src, id);
         id
     }
+
     fn missing_expr(&mut self) -> ExprId {
         self.alloc_expr_desugared(Expr::Missing)
     }
         binding
     }
 
-    fn alloc_pat_from_expr(&mut self, pat: Pat, ptr: ExprPtr) -> PatId {
+    fn alloc_pat_from_expr(
+        &mut self,
+        pat: Pat,
+        ptr: ExprPtr,
+    ) -> PatId {
         let src = self.expander.in_file(ptr);
         let id = self.store.pats.alloc(pat);
         self.store.expr_map.insert(src, id.into());
         id
     }
 
-    fn alloc_expr_from_pat(&mut self, expr: Expr, ptr: PatPtr) -> ExprId {
+    fn alloc_expr_from_pat(
+        &mut self,
+        expr: Expr,
+        ptr: PatPtr,
+    ) -> ExprId {
         let src = self.expander.in_file(ptr);
         let id = self.store.exprs.alloc(expr);
         self.store.pat_map.insert(src, id.into());
         id
     }
 
-    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {
+    fn alloc_pat(
+        &mut self,
+        pat: Pat,
+        ptr: PatPtr,
+    ) -> PatId {
         let src = self.expander.in_file(ptr);
         let id = self.store.pats.alloc(pat);
         self.store.pat_map_back.insert(id, src.map(AstPtr::wrap_right));
         self.store.pat_map.insert(src, id.into());
         id
     }
-    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.
-    fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {
+
+    fn alloc_pat_desugared(
+        &mut self,
+        pat: Pat,
+    ) -> PatId {
         self.store.pats.alloc(pat)
     }
+
     fn missing_pat(&mut self) -> PatId {
         self.store.pats.alloc(Pat::Missing)
     }
 
-    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {
+    fn alloc_label(
+        &mut self,
+        label: Label,
+        ptr: LabelPtr,
+    ) -> LabelId {
         let src = self.expander.in_file(ptr);
         let id = self.store.labels.alloc(label);
         self.store.label_map_back.insert(id, src);
         self.store.label_map.insert(src, id);
         id
     }
-    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.
-    fn alloc_label_desugared(&mut self, label: Label) -> LabelId {
+
+    fn alloc_label_desugared(
+        &mut self,
+        label: Label,
+    ) -> LabelId {
         self.store.labels.alloc(label)
     }
 
         res
     }
 
-    fn hygiene_id_for(&self, range: TextRange) -> HygieneId {
+    fn hygiene_id_for(
+        &self,
+        range: TextRange,
+    ) -> HygieneId {
         self.expander.hygiene_for_range(self.db, range)
     }
 }