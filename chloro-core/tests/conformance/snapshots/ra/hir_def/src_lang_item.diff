COMPARISON DIFF
============================================================

Original size: 32624 bytes
Chloro size:   32626 bytes
Rustfmt size:  32624 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Collects lang items: items marked with `#[lang = "..."]` attribute.
 //!
 //! This attribute to tell the compiler about semi built-in std library
 //! features, such as Fn family of traits.
+
 use hir_expand::name::Name;
-use intern::{Symbol, sym};
+use intern::{sym, Symbol};
 use rustc_hash::FxHashMap;
 use triomphe::Arc;
 
 use crate::{
-    AdtId, AssocItemId, AttrDefId, Crate, EnumId, EnumVariantId, FunctionId, ImplId, ModuleDefId,
-    StaticId, StructId, TraitId, TypeAliasId, UnionId,
     db::DefDatabase,
     expr_store::path::Path,
     nameres::{assoc::TraitItems, crate_def_map, crate_local_def_map},
+    AdtId, AssocItemId, AttrDefId, Crate, EnumId, EnumVariantId, FunctionId, ImplId, ModuleDefId,
+    StaticId, StructId, TraitId, TypeAliasId, UnionId,
 };
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
         }
     }
 
-    if lang_items.items.is_empty() { None } else { Some(Box::new(lang_items)) }
+    if lang_items.items.is_empty() {
+        None
+    } else {
+        Some(Box::new(lang_items))
+    }
 }
 
 /// Salsa query. Look for a lang item, starting from the specified crate and recursively
     }
 
     // Our `CrateGraph` eagerly inserts sysroot dependencies like `core` or `std` into dependencies
+
     // even if the target crate has `#![no_std]`, `#![no_core]` or shadowed sysroot dependencies
+
     // like `dependencies.std.path = ".."`. So we use `extern_prelude()` instead of
+
     // `CrateData.dependencies` here, which has already come through such sysroot complexities
+
     // while nameres.
+
     //
+
     // See https://github.com/rust-lang/rust-analyzer/pull/20475 for details.
     crate_local_def_map(db, start_crate).local(db).extern_prelude().find_map(|(_, (krate, _))| {
-        // Some crates declares themselves as extern crate like `extern crate self as core`.
-        // Ignore these to prevent cycles.
-        if krate.krate == start_crate { None } else { lang_item(db, krate.krate, item) }
+        if krate.krate == start_crate {
+            None
+        } else {
+            lang_item(db, krate.krate, item)
+        }
     })
 }
 
         db: &dyn DefDatabase,
         item: T,
         constructor: fn(T) -> LangItemTarget,
-    ) where
+    )
+    where
         T: Into<AttrDefId> + Copy,
     {
         let _p = tracing::info_span!("collect_lang_item").entered();
         }
     }
 
-    if traits.is_empty() { None } else { Some(traits.into_iter().collect()) }
+    if traits.is_empty() {
+        None
+    } else {
+        Some(traits.into_iter().collect())
+    }
 }
 
 pub enum GenericRequirement {
         Some(Path::LangItem(t, None))
     }
 
-    pub fn ty_rel_path(&self, db: &dyn DefDatabase, start_crate: Crate, seg: Name) -> Option<Path> {
+    pub fn ty_rel_path(
+        &self,
+        db: &dyn DefDatabase,
+        start_crate: Crate,
+        seg: Name,
+    ) -> Option<Path> {
         let t = lang_item(db, start_crate, *self)?;
         Some(Path::LangItem(t, Some(seg)))
     }