COMPARISON DIFF
============================================================

Original size: 32624 bytes
Chloro size:   32716 bytes
Rustfmt size:  32868 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Collects lang items: items marked with `#[lang = "..."]` attribute.
 //!
 //! This attribute to tell the compiler about semi built-in std library
 //! features, such as Fn family of traits.
+
 use hir_expand::name::Name;
 use intern::{Symbol, sym};
 use rustc_hash::FxHashMap;
             match def {
                 ModuleDefId::TraitId(trait_) => {
                     lang_items.collect_lang_item(db, trait_, LangItemTarget::Trait);
-                    TraitItems::query(db, trait_)
-                        .items
-                        .iter()
-                        .for_each(|&(_, assoc_id)| match assoc_id {
+                    TraitItems::query(db, trait_).items.iter().for_each(|&(_, assoc_id)| {
+                        match assoc_id {
                             AssocItemId::FunctionId(f) => {
                                 lang_items.collect_lang_item(db, f, LangItemTarget::Function);
                             }
                                 lang_items.collect_lang_item(db, alias, LangItemTarget::TypeAlias)
                             }
                             AssocItemId::ConstId(_) => {}
-                        });
+                        }
+                    });
                 }
                 ModuleDefId::AdtId(AdtId::EnumId(e)) => {
                     lang_items.collect_lang_item(db, e, LangItemTarget::EnumId);
     item: LangItem,
 ) -> Option<LangItemTarget> {
     let _p = tracing::info_span!("lang_item_query").entered();
-    if let Some(target) = crate_lang_items(db, start_crate)
-        .as_ref()
-        .and_then(|it| it.items.get(&item).copied())
+    if let Some(target) =
+        crate_lang_items(db, start_crate).as_ref().and_then(|it| it.items.get(&item).copied())
     {
         return Some(target);
     }
     // while nameres.
     //
     // See https://github.com/rust-lang/rust-analyzer/pull/20475 for details.
-    crate_local_def_map(db, start_crate)
-        .local(db)
-        .extern_prelude()
-        .find_map(|(_, (krate, _))| {
-            // Some crates declares themselves as extern crate like `extern crate self as core`.
-            // Ignore these to prevent cycles.
-            if krate.krate == start_crate {
-                None
-            } else {
-                lang_item(db, krate.krate, item)
-            }
-        })
+    crate_local_def_map(db, start_crate).local(db).extern_prelude().find_map(|(_, (krate, _))| {
+        // Some crates declares themselves as extern crate like `extern crate self as core`.
+        // Ignore these to prevent cycles.
+        if krate.krate == start_crate { None } else { lang_item(db, krate.krate, item) }
+    })
 }
 
 #[derive(Default, Debug, Clone, PartialEq, Eq)]
         db: &dyn DefDatabase,
         item: T,
         constructor: fn(T) -> LangItemTarget,
-    ) where
+    )
+    where
         T: Into<AttrDefId> + Copy,
     {
         let _p = tracing::info_span!("collect_lang_item").entered();
         if let Some(lang_item) = lang_attr(db, item.into()) {
-            self.items
-                .entry(lang_item)
-                .or_insert_with(|| constructor(item));
+            self.items.entry(lang_item).or_insert_with(|| constructor(item));
         }
     }
 }
 pub(crate) fn notable_traits_in_deps(db: &dyn DefDatabase, krate: Crate) -> Arc<[Arc<[TraitId]>]> {
     let _p = tracing::info_span!("notable_traits_in_deps", ?krate).entered();
     Arc::from_iter(
-        db.transitive_deps(krate)
-            .into_iter()
-            .filter_map(|krate| db.crate_notable_traits(krate)),
+        db.transitive_deps(krate).into_iter().filter_map(|krate| db.crate_notable_traits(krate)),
     )
 }
 
         Some(Path::LangItem(t, None))
     }
 
-    pub fn ty_rel_path(&self, db: &dyn DefDatabase, start_crate: Crate, seg: Name) -> Option<Path> {
+    pub fn ty_rel_path(
+        &self,
+        db: &dyn DefDatabase,
+        start_crate: Crate,
+        seg: Name,
+    ) -> Option<Path> {
         let t = lang_item(db, start_crate, *self)?;
         Some(Path::LangItem(t, Some(seg)))
     }