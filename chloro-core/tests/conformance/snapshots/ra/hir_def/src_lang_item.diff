COMPARISON DIFF
============================================================

Original size: 32624 bytes
Chloro size:   32723 bytes
Rustfmt size:  32624 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Collects lang items: items marked with `#[lang = "..."]` attribute.
 //!
 //! This attribute to tell the compiler about semi built-in std library
 //! features, such as Fn family of traits.
+
 use hir_expand::name::Name;
 use intern::{Symbol, sym};
 use rustc_hash::FxHashMap;
         }
     }
 
-    if lang_items.items.is_empty() { None } else { Some(Box::new(lang_items)) }
+    if lang_items.items.is_empty() {
+        None
+    } else {
+        Some(Box::new(lang_items))
+    }
 }
 
 /// Salsa query. Look for a lang item, starting from the specified crate and recursively
     }
 
     // Our `CrateGraph` eagerly inserts sysroot dependencies like `core` or `std` into dependencies
+
     // even if the target crate has `#![no_std]`, `#![no_core]` or shadowed sysroot dependencies
+
     // like `dependencies.std.path = ".."`. So we use `extern_prelude()` instead of
+
     // `CrateData.dependencies` here, which has already come through such sysroot complexities
+
     // while nameres.
+
     //
+
     // See https://github.com/rust-lang/rust-analyzer/pull/20475 for details.
+
     crate_local_def_map(db, start_crate).local(db).extern_prelude().find_map(|(_, (krate, _))| {
         // Some crates declares themselves as extern crate like `extern crate self as core`.
         // Ignore these to prevent cycles.
         db: &dyn DefDatabase,
         item: T,
         constructor: fn(T) -> LangItemTarget,
-    ) where
+    )
+    where
         T: Into<AttrDefId> + Copy,
     {
         let _p = tracing::info_span!("collect_lang_item").entered();
         }
     }
 
-    if traits.is_empty() { None } else { Some(traits.into_iter().collect()) }
+    if traits.is_empty() {
+        None
+    } else {
+        Some(traits.into_iter().collect())
+    }
 }
 
 pub enum GenericRequirement {
         Some(Path::LangItem(t, None))
     }
 
-    pub fn ty_rel_path(&self, db: &dyn DefDatabase, start_crate: Crate, seg: Name) -> Option<Path> {
+    pub fn ty_rel_path(
+        &self,
+        db: &dyn DefDatabase,
+        start_crate: Crate,
+        seg: Name,
+    ) -> Option<Path> {
         let t = lang_item(db, start_crate, *self)?;
         Some(Path::LangItem(t, Some(seg)))
     }