COMPARISON DIFF
============================================================

Original size: 15843 bytes
Chloro size:   15882 bytes
Rustfmt size:  16061 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::{
     CrateDisplayName, CrateGraphBuilder, CrateName, CrateOrigin, CrateWorkspaceData,
     DependencyBuilder, Env, RootQueryDb, SourceDatabase,
 };
-use expect_test::{expect, Expect};
+use expect_test::{Expect, expect};
 use intern::Symbol;
 use span::Edition;
 use test_fixture::WithFixture;
                 Default::default(),
                 None,
                 Env::default(),
-                CrateOrigin::Local {
-                    repo: None,
-                    name: Some(Symbol::intern(crate_name)),
-                },
+                CrateOrigin::Local { repo: None, name: Some(Symbol::intern(crate_name)) },
                 false,
                 Arc::new(
                     // FIXME: This is less than ideal
                     )
                     .unwrap(),
                 ),
-                Arc::new(CrateWorkspaceData {
-                    target: Err("".into()),
-                    toolchain: None,
-                }),
+                Arc::new(CrateWorkspaceData { target: Err("".into()), toolchain: None }),
             )
         };
         let a = add_crate("a", 0);
 }
 
 // Would be nice if this was the case, but as attribute inputs are stored in the item tree, this is
+
 // not currently the case.
+
 // #[test]
+
 // fn typing_inside_an_attribute_arg_should_not_invalidate_def_map() {
+
 //     check_def_map_is_not_recomputed(
+
 //         r"
+
 // //- proc_macros: identity
+
 // //- /lib.rs
+
 // mod foo;
 
 // //- /foo/mod.rs
+
 // pub mod bar;
 
 // //- /foo/bar.rs
-// $0
-// #[proc_macros::identity]
-// fn f() {}
-// ",
-//         r"
-// #[proc_macros::identity(foo)]
-// fn f() {}
-// ",
-//     );
-// }
 
+// $0
+
+// #[proc_macros::identity]
+
+// fn f() {}
+
+// ",
+
+//         r"
+
+// #[proc_macros::identity(foo)]
+
+// fn f() {}
+
+// ",
+
+//     );
+
+// }
 #[test]
 fn typing_inside_macro_heavy_file_should_not_invalidate_def_map() {
     check_def_map_is_not_recomputed(
 }
 
 // Would be nice if this was the case, but as attribute inputs are stored in the item tree, this is
+
 // not currently the case.
+
 // #[test]
+
 // fn typing_inside_a_derive_should_not_invalidate_def_map() {
+
 //     check_def_map_is_not_recomputed(
+
 //         r"
+
 // //- proc_macros: derive_identity
+
 // //- minicore:derive
+
 // //- /lib.rs
+
 // mod foo;
 
 // //- /foo/mod.rs
+
 // pub mod bar;
 
 // //- /foo/bar.rs
-// $0
-// #[derive(proc_macros::DeriveIdentity)]
-// #[allow()]
-// struct S;
-// ",
-//         r"
-// #[derive(proc_macros::DeriveIdentity)]
-// #[allow(dead_code)]
-// struct S;
-// ",
-//     );
-// }
 
+// $0
+
+// #[derive(proc_macros::DeriveIdentity)]
+
+// #[allow()]
+
+// struct S;
+
+// ",
+
+//         r"
+
+// #[derive(proc_macros::DeriveIdentity)]
+
+// #[allow(dead_code)]
+
+// struct S;
+
+// ",
+
+//     );
+
+// }
 #[test]
 fn typing_inside_a_function_should_not_invalidate_item_expansions() {
     let (mut db, pos) = TestDB::with_position(
             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();
             assert_eq!(module_data.scope.resolutions().count(), 4);
         },
-        &[
-            ("file_item_tree_query", 6),
-            ("parse_macro_expansion_shim", 3),
-        ],
+        &[("file_item_tree_query", 6), ("parse_macro_expansion_shim", 3)],
         expect![[r#"
             [
                 "crate_local_def_map",
             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();
             assert_eq!(module_data.scope.resolutions().count(), 4);
         },
-        &[
-            ("file_item_tree_query", 1),
-            ("parse_macro_expansion_shim", 0),
-        ],
+        &[("file_item_tree_query", 1), ("parse_macro_expansion_shim", 0)],
         expect![[r#"
             [
                 "parse_shim",
     let events = db.log_executed(f);
     for (event, count) in required {
         let n = events.iter().filter(|it| it.contains(event)).count();
-        assert_eq!(
-            n, *count,
-            "Expected {event} to be executed {count} times, but only got {n}"
-        );
+        assert_eq!(n, *count, "Expected {event} to be executed {count} times, but only got {n}");
     }
     expect.assert_debug_eq(&events);
 }