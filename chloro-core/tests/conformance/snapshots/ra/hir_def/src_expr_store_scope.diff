COMPARISON DIFF
============================================================

Original size: 19259 bytes
Chloro size:   19516 bytes
Rustfmt size:  19938 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Name resolution for expressions.
-use hir_expand::{name::Name, MacroDefId};
+
+use hir_expand::{MacroDefId, name::Name};
 use la_arena::{Arena, ArenaMap, Idx, IdxRange, RawIdx};
 use triomphe::Arc;
 
     parent: Option<ScopeId>,
     block: Option<BlockId>,
     label: Option<(LabelId, Name)>,
-    // FIXME: We can compress this with an enum for this and `label`/`block` if memory usage matters.
     macro_def: Option<Box<MacroDefId>>,
     entries: IdxRange<ScopeEntry>,
 }
 
 impl ExprScopes {
-    pub(crate) fn expr_scopes_query(db: &dyn DefDatabase, def: DefWithBodyId) -> Arc<ExprScopes> {
+    pub(crate) fn expr_scopes_query(
+        db: &dyn DefDatabase,
+        def: DefWithBodyId,
+    ) -> Arc<ExprScopes> {
         let body = db.body(def);
         let mut scopes = ExprScopes::new_body(&body);
         scopes.shrink_to_fit();
         Arc::new(scopes)
     }
 
-    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {
+    pub fn entries(
+        &self,
+        scope: ScopeId,
+    ) -> &[ScopeEntry] {
         &self.scope_entries[self.scopes[scope].entries.clone()]
     }
 
     /// If `scope` refers to a block expression scope, returns the corresponding `BlockId`.
-    pub fn block(&self, scope: ScopeId) -> Option<BlockId> {
+    pub fn block(
+        &self,
+        scope: ScopeId,
+    ) -> Option<BlockId> {
         self.scopes[scope].block
     }
 
     /// If `scope` refers to a macro def scope, returns the corresponding `MacroId`.
-    #[allow(clippy::borrowed_box)] // If we return `&MacroDefId` we need to move it, this way we just clone the `Box`.
-    pub fn macro_def(&self, scope: ScopeId) -> Option<&Box<MacroDefId>> {
+    #[allow(clippy::borrowed_box)]
+    pub fn macro_def(
+        &self,
+        scope: ScopeId,
+    ) -> Option<&Box<MacroDefId>> {
         self.scopes[scope].macro_def.as_ref()
     }
 
     /// If `scope` refers to a labeled expression scope, returns the corresponding `Label`.
-    pub fn label(&self, scope: ScopeId) -> Option<(LabelId, Name)> {
+    pub fn label(
+        &self,
+        scope: ScopeId,
+    ) -> Option<(LabelId, Name)> {
         self.scopes[scope].label.clone()
     }
 
     /// Returns the scopes in ascending order.
-    pub fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {
+    pub fn scope_chain(
+        &self,
+        scope: Option<ScopeId>,
+    ) -> impl Iterator<Item = ScopeId> + '_ {
         std::iter::successors(scope, move |&scope| self.scopes[scope].parent)
     }
 
-    pub fn resolve_name_in_scope(&self, scope: ScopeId, name: &Name) -> Option<&ScopeEntry> {
+    pub fn resolve_name_in_scope(
+        &self,
+        scope: ScopeId,
+        name: &Name,
+    ) -> Option<&ScopeEntry> {
         self.scope_chain(Some(scope))
             .find_map(|scope| self.entries(scope).iter().find(|it| it.name == *name))
     }
 
-    pub fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {
+    pub fn scope_for(
+        &self,
+        expr: ExprId,
+    ) -> Option<ScopeId> {
         self.scope_by_expr.get(expr).copied()
     }
 
         })
     }
 
-    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {
+    fn new_scope(
+        &mut self,
+        parent: ScopeId,
+    ) -> ScopeId {
         self.scopes.alloc(ScopeData {
             parent: Some(parent),
             block: None,
         })
     }
 
-    fn new_labeled_scope(&mut self, parent: ScopeId, label: Option<(LabelId, Name)>) -> ScopeId {
+    fn new_labeled_scope(
+        &mut self,
+        parent: ScopeId,
+        label: Option<(LabelId, Name)>,
+    ) -> ScopeId {
         self.scopes.alloc(ScopeData {
             parent: Some(parent),
             block: None,
         })
     }
 
-    fn new_macro_def_scope(&mut self, parent: ScopeId, macro_id: Box<MacroDefId>) -> ScopeId {
+    fn new_macro_def_scope(
+        &mut self,
+        parent: ScopeId,
+        macro_id: Box<MacroDefId>,
+    ) -> ScopeId {
         self.scopes.alloc(ScopeData {
             parent: Some(parent),
             block: None,
         hygiene: HygieneId,
     ) {
         let Binding { name, .. } = &store[binding];
-        let entry = self.scope_entries.alloc(ScopeEntry {
-            name: name.clone(),
-            binding,
-            hygiene,
-        });
+        let entry = self.scope_entries.alloc(ScopeEntry { name: name.clone(), binding, hygiene });
         self.scopes[scope].entries =
             IdxRange::new_inclusive(self.scopes[scope].entries.start()..=entry);
     }
 
-    fn add_pat_bindings(&mut self, store: &ExpressionStore, scope: ScopeId, pat: PatId) {
+    fn add_pat_bindings(
+        &mut self,
+        store: &ExpressionStore,
+        scope: ScopeId,
+        pat: PatId,
+    ) {
         let pattern = &store[pat];
         if let Pat::Bind { id, .. } = *pattern {
             self.add_bindings(store, scope, id, store.binding_hygiene(id));
         }
-
         pattern.walk_child_pats(|pat| self.add_pat_bindings(store, scope, pat));
     }
 
-    fn add_params_bindings(&mut self, store: &ExpressionStore, scope: ScopeId, params: &[PatId]) {
-        params
-            .iter()
-            .for_each(|pat| self.add_pat_bindings(store, scope, *pat));
+    fn add_params_bindings(
+        &mut self,
+        store: &ExpressionStore,
+        scope: ScopeId,
+        params: &[PatId],
+    ) {
+        params.iter().for_each(|pat| self.add_pat_bindings(store, scope, *pat));
     }
 
-    fn set_scope(&mut self, node: ExprId, scope: ScopeId) {
+    fn set_scope(
+        &mut self,
+        node: ExprId,
+        scope: ScopeId,
+    ) {
         self.scope_by_expr.insert(node, scope);
     }
 
     fn shrink_to_fit(&mut self) {
-        let ExprScopes {
-            scopes,
-            scope_entries,
-            scope_by_expr,
-        } = self;
+        let ExprScopes { scopes, scope_entries, scope_by_expr } = self;
         scopes.shrink_to_fit();
         scope_entries.shrink_to_fit();
         scope_by_expr.shrink_to_fit();
 ) {
     for stmt in statements {
         match stmt {
-            Statement::Let {
-                pat,
-                initializer,
-                else_branch,
-                ..
-            } => {
+            Statement::Let { pat, initializer, else_branch, .. } => {
                 if let Some(expr) = initializer {
                     compute_expr_scopes(*expr, store, scopes, scope);
                 }
 ) {
     let make_label =
         |label: &Option<LabelId>| label.map(|label| (label, store[label].name.clone()));
-
     let compute_expr_scopes = |scopes: &mut ExprScopes, expr: ExprId, scope: &mut ScopeId| {
         compute_expr_scopes(expr, store, scopes, scope)
     };
-
     scopes.set_scope(expr, *scope);
     match &store[expr] {
-        Expr::Block {
-            statements,
-            tail,
-            id,
-            label,
-        } => {
+        Expr::Block { statements, tail, id, label } => {
             let mut scope = scopes.new_block_scope(*scope, *id, make_label(label));
             // Overwrite the old scope for the block expr, so that every block scope can be found
             // via the block itself (important for blocks that only contain items, no expressions).
             let mut scope = scopes.root_scope();
             compute_expr_scopes(scopes, *id, &mut scope);
         }
-        Expr::Unsafe {
-            id,
-            statements,
-            tail,
-        }
-        | Expr::Async {
-            id,
-            statements,
-            tail,
-        } => {
+        Expr::Unsafe { id, statements, tail } | Expr::Async { id, statements, tail } => {
             let mut scope = scopes.new_block_scope(*scope, *id, None);
             // Overwrite the old scope for the block expr, so that every block scope can be found
             // via the block itself (important for blocks that only contain items, no expressions).
             scopes.set_scope(expr, scope);
             compute_block_scopes(statements, *tail, store, scopes, &mut scope);
         }
-        Expr::Loop {
-            body: body_expr,
-            label,
-        } => {
+        Expr::Loop { body: body_expr, label } => {
             let mut scope = scopes.new_labeled_scope(*scope, make_label(label));
             compute_expr_scopes(scopes, *body_expr, &mut scope);
         }
-        Expr::Closure {
-            args,
-            body: body_expr,
-            ..
-        } => {
+        Expr::Closure { args, body: body_expr, .. } => {
             let mut scope = scopes.new_scope(*scope);
             scopes.add_params_bindings(store, scope, args);
             compute_expr_scopes(scopes, *body_expr, &mut scope);
                 compute_expr_scopes(scopes, arm.expr, &mut scope);
             }
         }
-        &Expr::If {
-            condition,
-            then_branch,
-            else_branch,
-        } => {
+        &Expr::If { condition, then_branch, else_branch } => {
             let mut then_branch_scope = scopes.new_scope(*scope);
             compute_expr_scopes(scopes, condition, &mut then_branch_scope);
             compute_expr_scopes(scopes, then_branch, &mut then_branch_scope);
 #[cfg(test)]
 mod tests {
     use base_db::RootQueryDb;
-    use hir_expand::{name::AsName, InFile};
+    use hir_expand::{InFile, name::AsName};
     use span::FileId;
-    use syntax::{algo::find_node_at_offset, ast, AstNode};
+    use syntax::{AstNode, algo::find_node_at_offset, ast};
     use test_fixture::WithFixture;
     use test_utils::{assert_eq_text, extract_offset};
-
     use crate::{
-        db::DefDatabase, nameres::crate_def_map, test_db::TestDB, FunctionId, ModuleDefId,
+        db::DefDatabase,
+        nameres::crate_def_map,
+        test_db::TestDB,
+        FunctionId, ModuleDefId,
     };
-
-    fn find_function(db: &TestDB, file_id: FileId) -> FunctionId {
+    fn find_function(
+        db: &TestDB,
+        file_id: FileId,
+    ) -> FunctionId {
         let krate = db.test_crate();
         let crate_def_map = crate_def_map(db, krate);
-
         let module = crate_def_map.modules_for_file(db, file_id).next().unwrap();
         let (_, def) = crate_def_map[module].scope.entries().next().unwrap();
         match def.take_values().unwrap() {
             _ => panic!(),
         }
     }
-
-    fn do_check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expected: &[&str]) {
+    fn do_check(
+        #[rust_analyzer::rust_fixture] ra_fixture: &str,
+        expected: &[&str],
+    ) {
         let (offset, code) = extract_offset(ra_fixture);
         let code = {
             let mut buf = String::new();
             buf.push_str(&code[off..]);
             buf
         };
-
         let (db, position) = TestDB::with_position(&code);
         let editioned_file_id = position.file_id;
         let offset = position.offset;
-
         let (file_id, _) = editioned_file_id.unpack(&db);
-
         let file_syntax = db.parse(editioned_file_id).syntax_node();
         let marker: ast::PathExpr = find_node_at_offset(&file_syntax, offset).unwrap();
         let function = find_function(&db, file_id);
-
         let scopes = db.expr_scopes(function.into());
         let (_body, source_map) = db.body_with_source_map(function.into());
-
         let expr_id = source_map
-            .node_expr(InFile {
-                file_id: editioned_file_id.into(),
-                value: &marker.into(),
-            })
+            .node_expr(InFile { file_id: editioned_file_id.into(), value: &marker.into() })
             .unwrap()
             .as_expr()
             .unwrap();
         let scope = scopes.scope_for(expr_id);
-
         let actual = scopes
             .scope_chain(scope)
             .flat_map(|scope| scopes.entries(scope))
         let expected = expected.join("\n");
         assert_eq_text!(&expected, &actual);
     }
-
     #[test]
     fn test_lambda_scope() {
         do_check(
             &["bar", "baz", "foo"],
         );
     }
-
     #[test]
     fn test_call_scope() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_method_call_scope() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_loop_scope() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_match() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_shadow_variable() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_bindings_after_at() {
         do_check(
             &["opt", "unit"],
         );
     }
-
     #[test]
     fn macro_inner_item() {
         do_check(
             &[],
         );
     }
-
     #[test]
     fn broken_inner_item() {
         do_check(
             &[],
         );
     }
-
-    fn do_check_local_name(#[rust_analyzer::rust_fixture] ra_fixture: &str, expected_offset: u32) {
+    fn do_check_local_name(
+        #[rust_analyzer::rust_fixture] ra_fixture: &str,
+        expected_offset: u32,
+    ) {
         let (db, position) = TestDB::with_position(ra_fixture);
         let editioned_file_id = position.file_id;
         let offset = position.offset;
-
         let (file_id, _) = editioned_file_id.unpack(&db);
-
         let file = db.parse(editioned_file_id).ok().unwrap();
         let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())
             .expect("failed to find a name at the target offset");
         let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), offset).unwrap();
-
         let function = find_function(&db, file_id);
-
         let scopes = db.expr_scopes(function.into());
         let (_, source_map) = db.body_with_source_map(function.into());
-
         let expr_scope = {
-            let expr_ast = name_ref
-                .syntax()
-                .ancestors()
-                .find_map(ast::Expr::cast)
-                .unwrap();
+            let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();
             let expr_id = source_map
-                .node_expr(InFile {
-                    file_id: editioned_file_id.into(),
-                    value: &expr_ast,
-                })
+                .node_expr(InFile { file_id: editioned_file_id.into(), value: &expr_ast })
                 .unwrap()
                 .as_expr()
                 .unwrap();
             scopes.scope_for(expr_id).unwrap()
         };
-
-        let resolved = scopes
-            .resolve_name_in_scope(expr_scope, &name_ref.as_name())
-            .unwrap();
-        let pat_src = source_map
-            .pat_syntax(source_map.patterns_for_binding(resolved.binding())[0])
-            .unwrap();
-
+        let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();
+        let pat_src =
+            source_map.pat_syntax(source_map.patterns_for_binding(resolved.binding())[0]).unwrap();
         let local_name = pat_src.value.syntax_node_ptr().to_node(file.syntax());
         assert_eq!(local_name.text_range(), expected_name.syntax().text_range());
     }
-
     #[test]
     fn test_resolve_local_name() {
         do_check_local_name(
             7,
         );
     }
-
     #[test]
     fn test_resolve_local_name_declaration() {
         do_check_local_name(
             7,
         );
     }
-
     #[test]
     fn test_resolve_local_name_shadow() {
         do_check_local_name(
             28,
         );
     }
-
     #[test]
     fn ref_patterns_contribute_bindings() {
         do_check_local_name(
             28,
         );
     }
-
     #[test]
     fn while_let_adds_binding() {
         do_check_local_name(
             107,
         );
     }
-
     #[test]
     fn match_guard_if_let() {
         do_check_local_name(
             93,
         );
     }
-
     #[test]
     fn let_chains_can_reference_previous_lets() {
         do_check_local_name(