COMPARISON DIFF
============================================================

Original size: 19259 bytes
Chloro size:   19225 bytes
Rustfmt size:  19938 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Name resolution for expressions.
+
 use hir_expand::{name::Name, MacroDefId};
 use la_arena::{Arena, ArenaMap, Idx, IdxRange, RawIdx};
 use triomphe::Arc;
     }
 
     /// If `scope` refers to a macro def scope, returns the corresponding `MacroId`.
-    #[allow(clippy::borrowed_box)] // If we return `&MacroDefId` we need to move it, this way we just clone the `Box`.
+    #[allow(clippy::borrowed_box)]
     pub fn macro_def(&self, scope: ScopeId) -> Option<&Box<MacroDefId>> {
         self.scopes[scope].macro_def.as_ref()
     }
     }
 
     fn root_scope(&mut self) -> ScopeId {
-        self.scopes.alloc(ScopeData {
+        self.scopes.alloc(
+            ScopeData {
             parent: None,
             block: None,
             label: None,
             macro_def: None,
             entries: empty_entries(self.scope_entries.len()),
-        })
+        },
+        )
     }
 
     fn new_scope(&mut self, parent: ScopeId) -> ScopeId {
-        self.scopes.alloc(ScopeData {
+        self.scopes.alloc(
+            ScopeData {
             parent: Some(parent),
             block: None,
             label: None,
             macro_def: None,
             entries: empty_entries(self.scope_entries.len()),
-        })
+        },
+        )
     }
 
     fn new_labeled_scope(&mut self, parent: ScopeId, label: Option<(LabelId, Name)>) -> ScopeId {
     }
 
     fn new_macro_def_scope(&mut self, parent: ScopeId, macro_id: Box<MacroDefId>) -> ScopeId {
-        self.scopes.alloc(ScopeData {
+        self.scopes.alloc(
+            ScopeData {
             parent: Some(parent),
             block: None,
             label: None,
             macro_def: Some(macro_id),
             entries: empty_entries(self.scope_entries.len()),
-        })
+        },
+        )
     }
 
     fn add_bindings(
         hygiene: HygieneId,
     ) {
         let Binding { name, .. } = &store[binding];
-        let entry = self.scope_entries.alloc(ScopeEntry {
-            name: name.clone(),
-            binding,
-            hygiene,
-        });
+        let entry = self.scope_entries.alloc(ScopeEntry { name: name.clone(), binding, hygiene });
         self.scopes[scope].entries =
             IdxRange::new_inclusive(self.scopes[scope].entries.start()..=entry);
     }
     }
 
     fn add_params_bindings(&mut self, store: &ExpressionStore, scope: ScopeId, params: &[PatId]) {
-        params
-            .iter()
-            .for_each(|pat| self.add_pat_bindings(store, scope, *pat));
+        params.iter().for_each(|pat| self.add_pat_bindings(store, scope, *pat));
     }
 
     fn set_scope(&mut self, node: ExprId, scope: ScopeId) {
     }
 
     fn shrink_to_fit(&mut self) {
-        let ExprScopes {
-            scopes,
-            scope_entries,
-            scope_by_expr,
-        } = self;
+        let ExprScopes { scopes, scope_entries, scope_by_expr } = self;
         scopes.shrink_to_fit();
         scope_entries.shrink_to_fit();
         scope_by_expr.shrink_to_fit();
 ) {
     for stmt in statements {
         match stmt {
-            Statement::Let {
-                pat,
-                initializer,
-                else_branch,
-                ..
-            } => {
+            Statement::Let { pat, initializer, else_branch, .. } => {
                 if let Some(expr) = initializer {
                     compute_expr_scopes(*expr, store, scopes, scope);
                 }
 
     scopes.set_scope(expr, *scope);
     match &store[expr] {
-        Expr::Block {
-            statements,
-            tail,
-            id,
-            label,
-        } => {
+        Expr::Block { statements, tail, id, label } => {
             let mut scope = scopes.new_block_scope(*scope, *id, make_label(label));
             // Overwrite the old scope for the block expr, so that every block scope can be found
             // via the block itself (important for blocks that only contain items, no expressions).
             let mut scope = scopes.root_scope();
             compute_expr_scopes(scopes, *id, &mut scope);
         }
-        Expr::Unsafe {
-            id,
-            statements,
-            tail,
-        }
-        | Expr::Async {
-            id,
-            statements,
-            tail,
-        } => {
+        Expr::Unsafe { id, statements, tail } | Expr::Async { id, statements, tail } => {
             let mut scope = scopes.new_block_scope(*scope, *id, None);
             // Overwrite the old scope for the block expr, so that every block scope can be found
             // via the block itself (important for blocks that only contain items, no expressions).
             scopes.set_scope(expr, scope);
             compute_block_scopes(statements, *tail, store, scopes, &mut scope);
         }
-        Expr::Loop {
-            body: body_expr,
-            label,
-        } => {
+        Expr::Loop { body: body_expr, label } => {
             let mut scope = scopes.new_labeled_scope(*scope, make_label(label));
             compute_expr_scopes(scopes, *body_expr, &mut scope);
         }
-        Expr::Closure {
-            args,
-            body: body_expr,
-            ..
-        } => {
+        Expr::Closure { args, body: body_expr, .. } => {
             let mut scope = scopes.new_scope(*scope);
             scopes.add_params_bindings(store, scope, args);
             compute_expr_scopes(scopes, *body_expr, &mut scope);
                 compute_expr_scopes(scopes, arm.expr, &mut scope);
             }
         }
-        &Expr::If {
-            condition,
-            then_branch,
-            else_branch,
-        } => {
+        &Expr::If { condition, then_branch, else_branch } => {
             let mut then_branch_scope = scopes.new_scope(*scope);
             compute_expr_scopes(scopes, condition, &mut then_branch_scope);
             compute_expr_scopes(scopes, then_branch, &mut then_branch_scope);
     use syntax::{algo::find_node_at_offset, ast, AstNode};
     use test_fixture::WithFixture;
     use test_utils::{assert_eq_text, extract_offset};
-
     use crate::{
         db::DefDatabase, nameres::crate_def_map, test_db::TestDB, FunctionId, ModuleDefId,
     };
-
     fn find_function(db: &TestDB, file_id: FileId) -> FunctionId {
         let krate = db.test_crate();
         let crate_def_map = crate_def_map(db, krate);
             _ => panic!(),
         }
     }
-
     fn do_check(#[rust_analyzer::rust_fixture] ra_fixture: &str, expected: &[&str]) {
         let (offset, code) = extract_offset(ra_fixture);
         let code = {
         let (_body, source_map) = db.body_with_source_map(function.into());
 
         let expr_id = source_map
-            .node_expr(InFile {
-                file_id: editioned_file_id.into(),
-                value: &marker.into(),
-            })
+            .node_expr(InFile { file_id: editioned_file_id.into(), value: &marker.into() })
             .unwrap()
             .as_expr()
             .unwrap();
         let expected = expected.join("\n");
         assert_eq_text!(&expected, &actual);
     }
-
     #[test]
     fn test_lambda_scope() {
         do_check(
             &["bar", "baz", "foo"],
         );
     }
-
     #[test]
     fn test_call_scope() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_method_call_scope() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_loop_scope() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_match() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_shadow_variable() {
         do_check(
             &["x"],
         );
     }
-
     #[test]
     fn test_bindings_after_at() {
         do_check(
             &["opt", "unit"],
         );
     }
-
     #[test]
     fn macro_inner_item() {
         do_check(
             &[],
         );
     }
-
     #[test]
     fn broken_inner_item() {
         do_check(
             &[],
         );
     }
-
     fn do_check_local_name(#[rust_analyzer::rust_fixture] ra_fixture: &str, expected_offset: u32) {
         let (db, position) = TestDB::with_position(ra_fixture);
         let editioned_file_id = position.file_id;
         let (_, source_map) = db.body_with_source_map(function.into());
 
         let expr_scope = {
-            let expr_ast = name_ref
-                .syntax()
-                .ancestors()
-                .find_map(ast::Expr::cast)
-                .unwrap();
+            let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();
             let expr_id = source_map
-                .node_expr(InFile {
-                    file_id: editioned_file_id.into(),
-                    value: &expr_ast,
-                })
+                .node_expr(InFile { file_id: editioned_file_id.into(), value: &expr_ast })
                 .unwrap()
                 .as_expr()
                 .unwrap();
             scopes.scope_for(expr_id).unwrap()
         };
 
-        let resolved = scopes
-            .resolve_name_in_scope(expr_scope, &name_ref.as_name())
-            .unwrap();
-        let pat_src = source_map
-            .pat_syntax(source_map.patterns_for_binding(resolved.binding())[0])
-            .unwrap();
+        let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();
+        let pat_src =
+            source_map.pat_syntax(source_map.patterns_for_binding(resolved.binding())[0]).unwrap();
 
         let local_name = pat_src.value.syntax_node_ptr().to_node(file.syntax());
         assert_eq!(local_name.text_range(), expected_name.syntax().text_range());
     }
-
     #[test]
     fn test_resolve_local_name() {
         do_check_local_name(
             7,
         );
     }
-
     #[test]
     fn test_resolve_local_name_declaration() {
         do_check_local_name(
             7,
         );
     }
-
     #[test]
     fn test_resolve_local_name_shadow() {
         do_check_local_name(
             28,
         );
     }
-
     #[test]
     fn ref_patterns_contribute_bindings() {
         do_check_local_name(
             28,
         );
     }
-
     #[test]
     fn while_let_adds_binding() {
         do_check_local_name(
             107,
         );
     }
-
     #[test]
     fn match_guard_if_let() {
         do_check_local_name(
             93,
         );
     }
-
     #[test]
     fn let_chains_can_reference_previous_lets() {
         do_check_local_name(