COMPARISON DIFF
============================================================

Original size: 11017 bytes
Chloro size:   11040 bytes
Rustfmt size:  11350 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
             parent,
         }
     }
+
     pub(crate) fn with_self_param(
         ec: &mut ExprCollector<'_>,
         parent: GenericDefId,
     }
 
     pub(crate) fn finish(self) -> Arc<GenericParams> {
-        let Self {
-            mut lifetimes,
-            mut type_or_consts,
-            mut where_predicates,
-            parent: _,
-        } = self;
+        let Self { mut lifetimes, mut type_or_consts, mut where_predicates, parent: _ } = self;
 
         if lifetimes.is_empty() && type_or_consts.is_empty() && where_predicates.is_empty() {
             static EMPTY: LazyLock<Arc<GenericParams>> = LazyLock::new(|| {
 
             match generic_param {
                 ast::GenericParam::TypeParam(type_param) => {
-                    let name = type_param
-                        .name()
-                        .map_or_else(Name::missing, |it| it.as_name());
+                    let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());
                     let default = type_param.default_type().map(|it| {
                         ec.lower_type_ref(it, &mut ExprCollector::impl_trait_error_allocator)
                     });
                     self.lower_bounds(ec, type_param.type_bound_list(), Either::Left(type_ref));
                 }
                 ast::GenericParam::ConstParam(const_param) => {
-                    let name = const_param
-                        .name()
-                        .map_or_else(Name::missing, |it| it.as_name());
+                    let name = const_param.name().map_or_else(Name::missing, |it| it.as_name());
                     let ty = ec.lower_type_ref_opt(
                         const_param.ty(),
                         &mut ExprCollector::impl_trait_error_allocator,
                 continue;
             };
 
-            let lifetimes: Option<Box<_>> = pred
-                .for_binder()
-                .and_then(|it| it.generic_param_list())
-                .map(|param_list| {
+            let lifetimes: Option<Box<_>> =
+                pred.for_binder().and_then(|it| it.generic_param_list()).map(|param_list| {
                     // Higher-Ranked Trait Bounds
                     param_list
                         .lifetime_params()
         type_bounds: Option<ast::TypeBoundList>,
         target: Either<TypeRefId, LifetimeRefId>,
     ) {
-        for bound in type_bounds
-            .iter()
-            .flat_map(|type_bound_list| type_bound_list.bounds())
-        {
+        for bound in type_bounds.iter().flat_map(|type_bound_list| type_bound_list.bounds()) {
             self.lower_type_bound_as_predicate(ec, bound, None, target);
         }
     }
         hrtb_lifetimes: Option<&[Name]>,
         target: Either<TypeRefId, LifetimeRefId>,
     ) {
-        let bound = ec.lower_type_bound(
+        let bound = ec
+            .lower_type_bound(
             bound,
             &mut Self::lower_argument_impl_trait(
                 &mut self.type_or_consts,
                     target: type_ref,
                     bound,
                 },
-                None => WherePredicate::TypeBound {
-                    target: type_ref,
-                    bound,
-                },
-            },
-            (Either::Right(lifetime), TypeBound::Lifetime(bound)) => WherePredicate::Lifetime {
-                target: lifetime,
-                bound,
+                None => WherePredicate::TypeBound { target: type_ref, bound },
             },
+            (Either::Right(lifetime), TypeBound::Lifetime(bound)) => {
+                WherePredicate::Lifetime { target: lifetime, bound }
+            }
             (Either::Right(_), TypeBound::ForLifetime(..) | TypeBound::Path(..)) => return,
         };
         self.where_predicates.push(predicate);
         type_or_consts: &mut Arena<TypeOrConstParamData>,
         where_predicates: &mut Vec<WherePredicate>,
         parent: GenericDefId,
-    ) -> impl for<'ec, 'db> FnMut(&'ec mut ExprCollector<'db>, TypePtr, ThinVec<TypeBound>) -> TypeRefId
-    {
+    ) -> impl for<'ec, 'db> FnMut(&'ec mut ExprCollector<'db>, TypePtr, ThinVec<TypeBound>) -> TypeRefId {
         move |ec, ptr, impl_trait_bounds| {
             let param = TypeParamData {
                 name: None,
             }));
             let type_ref = ec.alloc_type_ref(param_id, ptr);
             for bound in impl_trait_bounds {
-                where_predicates.push(WherePredicate::TypeBound {
-                    target: type_ref,
-                    bound: bound.clone(),
-                });
+                where_predicates
+                    .push(WherePredicate::TypeBound { target: type_ref, bound: bound.clone() });
             }
             type_ref
         }
 
     fn fill_self_param(&mut self, ec: &mut ExprCollector<'_>, bounds: Option<ast::TypeBoundList>) {
         let self_ = Name::new_symbol_root(sym::Self_);
-        let idx = self.type_or_consts.alloc(
+        let idx = self.type_or_consts
+            .alloc(
             TypeParamData {
                 name: Some(self_),
                 default: None,