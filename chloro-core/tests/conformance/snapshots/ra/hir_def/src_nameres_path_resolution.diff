COMPARISON DIFF
============================================================

Original size: 32735 bytes
Chloro size:   32348 bytes
Rustfmt size:  32996 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use stdx::TupleExt;
 
 use crate::{
+    AdtId, LocalModuleId, ModuleDefId,
     db::DefDatabase,
-    item_scope::{ImportOrExternCrate, BUILTIN_SCOPE},
+    item_scope::{BUILTIN_SCOPE, ImportOrExternCrate},
     item_tree::FieldsShape,
     nameres::{
-        assoc::TraitItems, crate_def_map, sub_namespace_match, BlockInfo, BuiltinShadowMode,
-        DefMap, LocalDefMap, MacroSubNs,
+        BlockInfo, BuiltinShadowMode, DefMap, LocalDefMap, MacroSubNs, assoc::TraitItems,
+        crate_def_map, sub_namespace_match,
     },
     per_ns::PerNs,
     visibility::{RawVisibility, Visibility},
-    AdtId, LocalModuleId, ModuleDefId,
 };
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
         segment_index: Option<usize>,
         prefix_info: ResolvePathResultPrefixInfo,
     ) -> ResolvePathResult {
-        ResolvePathResult {
-            resolved_def,
-            segment_index,
-            reached_fixedpoint,
-            prefix_info,
-        }
+        ResolvePathResult { resolved_def, segment_index, reached_fixedpoint, prefix_info }
     }
 }
 
         &self,
         local_def_map: &LocalDefMap,
         db: &dyn DefDatabase,
-        // module to import to
         original_module: LocalModuleId,
-        // pub(path)
-        //     ^^^^ this
         visibility: &RawVisibility,
         within_impl: bool,
     ) -> Option<Visibility> {
         Some(vis)
     }
 
-    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change
-    // the result.
     pub(super) fn resolve_path_fp_with_macro(
         &self,
         local_def_map: &LocalDefMap,
         db: &dyn DefDatabase,
         mode: ResolveMode,
-        // module to import to
         mut original_module: LocalModuleId,
         path: &ModPath,
         shadow: BuiltinShadowMode,
-        // Pass `MacroSubNs` if we know we're resolving macro names and which kind of macro we're
-        // resolving them to. Pass `None` otherwise, e.g. when we're resolving import paths.
         expected_macro_subns: Option<MacroSubNs>,
     ) -> ResolvePathResult {
         let mut result = self.resolve_path_fp_with_macro_single(
                     return result;
                 }
             }
-
             let new = current_map.resolve_path_fp_with_macro_single(
                 local_def_map,
                 db,
                 shadow,
                 expected_macro_subns,
             );
-
             merge(new);
         }
     }
                 // FIXME: If the next segment doesn't resolve in the module and
                 // BuiltinShadowMode wasn't Module, then we need to try
                 // resolving it as a builtin.
-                let prefer_module = if path.segments().len() == 1 {
-                    shadow
-                } else {
-                    BuiltinShadowMode::Module
-                };
+                let prefer_module =
+                    if path.segments().len() == 1 { shadow } else { BuiltinShadowMode::Module };
 
                 tracing::debug!("resolving {:?} in module", segment);
                 self.resolve_name_in_module(
                 extern_crate.map(ImportOrExternCrate::ExternCrate),
             ))
         } else {
-            Either::Right(ReachedFixedPoint::No) // extern crate declarations can add to the extern prelude
+            // extern crate declarations can add to the extern prelude
+            Either::Right(ReachedFixedPoint::No)
         }
     }
 
                 sub_namespace_match(Some(MacroSubNs::from_id(db, id)), expected_macro_subns)
             })
             .map_or_else(PerNs::none, |m| PerNs::macros(m, Visibility::Public, None));
-        let from_scope = self[module]
-            .scope
-            .get(name)
-            .filter_macro(db, expected_macro_subns);
+        let from_scope = self[module].scope.get(name).filter_macro(db, expected_macro_subns);
         let from_builtin = match self.block {
             Some(_) => {
                 // Only resolve to builtins in the root `DefMap`.
     }
 
     fn resolve_name_in_extern_prelude(&self, local_def_map: &LocalDefMap, name: &Name) -> PerNs {
-        local_def_map
-            .extern_prelude
-            .get(name)
-            .map_or(PerNs::none(), |&(it, extern_crate)| {
-                PerNs::types(
-                    it.into(),
-                    Visibility::Public,
-                    extern_crate.map(ImportOrExternCrate::ExternCrate),
-                )
-            })
+        local_def_map.extern_prelude.get(name).map_or(PerNs::none(), |&(it, extern_crate)| {
+            PerNs::types(
+                it.into(),
+                Visibility::Public,
+                extern_crate.map(ImportOrExternCrate::ExternCrate),
+            )
+        })
     }
 
     fn resolve_in_macro_use_prelude(&self, name: &Name) -> PerNs {
-        self.macro_use_prelude
-            .get(name)
-            .map_or(PerNs::none(), |&(it, extern_crate)| {
-                PerNs::macros(
-                    it,
-                    Visibility::Public,
-                    extern_crate.map(ImportOrExternCrate::ExternCrate),
-                )
-            })
+        self.macro_use_prelude.get(name).map_or(PerNs::none(), |&(it, extern_crate)| {
+            PerNs::macros(
+                it,
+                Visibility::Public,
+                extern_crate.map(ImportOrExternCrate::ExternCrate),
+            )
+        })
     }
 
     fn resolve_name_in_crate_root_or_extern_prelude(
     let mut def_map = def_map;
     loop {
         let BlockInfo { parent, .. } = def_map.block.expect("block module without parent module");
-
         def_map = parent.def_map(db, def_map.krate);
         local_id = parent.local_id;
         if !parent.is_block_module() {