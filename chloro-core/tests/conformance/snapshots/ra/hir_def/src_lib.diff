COMPARISON DIFF
============================================================

Original size: 44403 bytes
Chloro size:   43723 bytes
Rustfmt size:  45085 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 #![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
 
 #[cfg(feature = "in-rust-tree")]
-extern crate rustc_parse_format;
 
 #[cfg(not(feature = "in-rust-tree"))]
-extern crate ra_ap_rustc_parse_format as rustc_parse_format;
 
-extern crate ra_ap_rustc_abi as rustc_abi;
 
 pub mod db;
 
 pub mod import_map;
 pub mod visibility;
 
-use intern::{sym, Interned, Symbol};
+use intern::{Interned, Symbol, sym};
 pub use rustc_abi as layout;
 use thin_vec::ThinVec;
 use triomphe::Arc;
 
 use std::hash::{Hash, Hasher};
 
-use base_db::{impl_intern_key, Crate};
+use base_db::{Crate, impl_intern_key};
 use hir_expand::{
+    AstId, ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,
+    MacroDefKind,
     builtin::{BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerExpander},
     db::ExpandDatabase,
     eager::expand_eager_macro_input,
     mod_path::ModPath,
     name::Name,
     proc_macro::{CustomProcMacroExpander, ProcMacroKind},
-    AstId, ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,
-    MacroDefKind,
 };
 use la_arena::Idx;
 use nameres::DefMap;
 use span::{AstIdNode, Edition, FileAstId, SyntaxContext};
 use stdx::impl_from;
-use syntax::{ast, AstNode};
+use syntax::{AstNode, ast};
 
-pub use hir_expand::{tt, Intern, Lookup};
+pub use hir_expand::{Intern, Lookup, tt};
 
 use crate::{
     attr::Attrs,
     expr_store::ExpressionStoreSourceMap,
     hir::generics::{LocalLifetimeParamId, LocalTypeOrConstParamId},
     nameres::{
-        assoc::{ImplItems, TraitItems},
-        block_def_map, crate_def_map, crate_local_def_map,
-        diagnostics::DefDiagnostics,
-        LocalDefMap,
+        LocalDefMap, assoc::{ImplItems, TraitItems}, block_def_map, crate_def_map,
+        crate_local_def_map, diagnostics::DefDiagnostics,
     },
     signatures::{EnumVariants, InactiveEnumVariantCode, VariantFields},
 };
 
 type FxIndexMap<K, V> = indexmap::IndexMap<K, V, rustc_hash::FxBuildHasher>;
+
 /// A wrapper around three booleans
 #[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]
 pub struct FindPathConfig {
     }
 }
 
-impl<N: AstIdNode> Copy for ItemLoc<N> {}
+impl<N: AstIdNode> Copy for ItemLoc<N> {
+}
 
 impl<N: AstIdNode> PartialEq for ItemLoc<N> {
     fn eq(&self, other: &Self) -> bool {
     }
 }
 
-impl<N: AstIdNode> Eq for ItemLoc<N> {}
+impl<N: AstIdNode> Eq for ItemLoc<N> {
+}
 
 impl<N: AstIdNode> Hash for ItemLoc<N> {
     fn hash<H: Hasher>(&self, state: &mut H) {
     }
 }
 
-impl<N: AstIdNode> Copy for AssocItemLoc<N> {}
+impl<N: AstIdNode> Copy for AssocItemLoc<N> {
+}
 
 impl<N: AstIdNode> PartialEq for AssocItemLoc<N> {
     fn eq(&self, other: &Self) -> bool {
     }
 }
 
-impl<N: AstIdNode> Eq for AssocItemLoc<N> {}
+impl<N: AstIdNode> Eq for AssocItemLoc<N> {
+}
 
 impl<N: AstIdNode> Hash for AssocItemLoc<N> {
     fn hash<H: Hasher>(&self, state: &mut H) {
 
 pub trait AstIdLoc {
     type Container;
-    type Ast: AstNode;
+
+    type Ast;
+
     fn ast_id(&self) -> AstId<Self::Ast>;
+
     fn container(&self) -> Self::Container;
 }
 
 impl<N: AstIdNode> AstIdLoc for ItemLoc<N> {
     type Container = ModuleId;
+
     type Ast = N;
+
     #[inline]
     fn ast_id(&self) -> AstId<Self::Ast> {
         self.id
     }
+
     #[inline]
     fn container(&self) -> Self::Container {
         self.container
 
 impl<N: AstIdNode> AstIdLoc for AssocItemLoc<N> {
     type Container = ItemContainerId;
+
     type Ast = N;
+
     #[inline]
     fn ast_id(&self) -> AstId<Self::Ast> {
         self.id
     }
+
     #[inline]
     fn container(&self) -> Self::Container {
         self.container
 }
 
 type FunctionLoc = AssocItemLoc<ast::Fn>;
-impl_intern!(
-    FunctionId,
-    FunctionLoc,
-    intern_function,
-    lookup_intern_function
-);
+
+impl_intern!(FunctionId, FunctionLoc, intern_function, lookup_intern_function);
 
 type StructLoc = ItemLoc<ast::Struct>;
+
 impl_intern!(StructId, StructLoc, intern_struct, lookup_intern_struct);
 
 impl StructId {
 }
 
 pub type UnionLoc = ItemLoc<ast::Union>;
+
 impl_intern!(UnionId, UnionLoc, intern_union, lookup_intern_union);
 
 impl UnionId {
 }
 
 pub type EnumLoc = ItemLoc<ast::Enum>;
+
 impl_intern!(EnumId, EnumLoc, intern_enum, lookup_intern_enum);
 
 impl EnumId {
 }
 
 type ConstLoc = AssocItemLoc<ast::Const>;
+
 impl_intern!(ConstId, ConstLoc, intern_const, lookup_intern_const);
 
 pub type StaticLoc = AssocItemLoc<ast::Static>;
+
 impl_intern!(StaticId, StaticLoc, intern_static, lookup_intern_static);
 
 pub type TraitLoc = ItemLoc<ast::Trait>;
+
 impl_intern!(TraitId, TraitLoc, intern_trait, lookup_intern_trait);
 
 impl TraitId {
 }
 
 type TypeAliasLoc = AssocItemLoc<ast::TypeAlias>;
-impl_intern!(
-    TypeAliasId,
-    TypeAliasLoc,
-    intern_type_alias,
-    lookup_intern_type_alias
-);
+
+impl_intern!(TypeAliasId, TypeAliasLoc, intern_type_alias, lookup_intern_type_alias);
 
 type ImplLoc = ItemLoc<ast::Impl>;
+
 impl_intern!(ImplId, ImplLoc, intern_impl, lookup_intern_impl);
 
 impl ImplId {
     }
 
     #[inline]
-    pub fn impl_items_with_diagnostics(self, db: &dyn DefDatabase) -> &(ImplItems, DefDiagnostics) {
+    pub fn impl_items_with_diagnostics(
+        self,
+        db: &dyn DefDatabase,
+    ) -> &(ImplItems, DefDiagnostics) {
         ImplItems::of(db, self)
     }
 }
 
 type UseLoc = ItemLoc<ast::Use>;
+
 impl_intern!(UseId, UseLoc, intern_use, lookup_intern_use);
 
 type ExternCrateLoc = ItemLoc<ast::ExternCrate>;
-impl_intern!(
-    ExternCrateId,
-    ExternCrateLoc,
-    intern_extern_crate,
-    lookup_intern_extern_crate
-);
+
+impl_intern!(ExternCrateId, ExternCrateLoc, intern_extern_crate, lookup_intern_extern_crate);
 
 type ExternBlockLoc = ItemLoc<ast::ExternBlock>;
-impl_intern!(
-    ExternBlockId,
-    ExternBlockLoc,
-    intern_extern_block,
-    lookup_intern_extern_block
-);
+
+impl_intern!(ExternBlockId, ExternBlockLoc, intern_extern_block, lookup_intern_extern_block);
 
 #[salsa::tracked]
 impl ExternBlockId {
     pub parent: EnumId,
     pub index: u32,
 }
-impl_intern!(
-    EnumVariantId,
-    EnumVariantLoc,
-    intern_enum_variant,
-    lookup_intern_enum_variant
-);
+
+impl_intern!(EnumVariantId, EnumVariantLoc, intern_enum_variant, lookup_intern_enum_variant);
+
 impl_loc!(EnumVariantLoc, id: Variant, parent: EnumId);
 
 impl EnumVariantId {
     pub allow_internal_unsafe: bool,
     pub edition: Edition,
 }
+
 impl_intern!(Macro2Id, Macro2Loc, intern_macro2, lookup_intern_macro2);
+
 impl_loc!(Macro2Loc, id: MacroDef, container: ModuleId);
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
     pub flags: MacroRulesLocFlags,
     pub edition: Edition,
 }
-impl_intern!(
-    MacroRulesId,
-    MacroRulesLoc,
-    intern_macro_rules,
-    lookup_intern_macro_rules
-);
+
+impl_intern!(MacroRulesId, MacroRulesLoc, intern_macro_rules, lookup_intern_macro_rules);
+
 impl_loc!(MacroRulesLoc, id: MacroRules, container: ModuleId);
 
 bitflags::bitflags! {
     pub kind: ProcMacroKind,
     pub edition: Edition,
 }
-impl_intern!(
-    ProcMacroId,
-    ProcMacroLoc,
-    intern_proc_macro,
-    lookup_intern_proc_macro
-);
+
+impl_intern!(ProcMacroId, ProcMacroLoc, intern_proc_macro, lookup_intern_proc_macro);
+
 impl_loc!(ProcMacroLoc, id: Fn, container: CrateRootModuleId);
 
 #[derive(Debug, Hash, PartialEq, Eq, Clone)]
     /// The containing module.
     pub module: ModuleId,
 }
+
 impl_intern!(BlockId, BlockLoc, intern_block, lookup_intern_block);
 
 /// A `ModuleId` that is always a crate's root module.
         other.block.is_none() && other.local_id == DefMap::ROOT && self.krate == other.krate
     }
 }
+
 impl PartialEq<CrateRootModuleId> for ModuleId {
     fn eq(&self, other: &CrateRootModuleId) -> bool {
         other == self
 
 impl From<CrateRootModuleId> for ModuleId {
     fn from(CrateRootModuleId { krate }: CrateRootModuleId) -> Self {
-        ModuleId {
-            krate,
-            block: None,
-            local_id: DefMap::ROOT,
-        }
+        ModuleId { krate, block: None, local_id: DefMap::ROOT }
     }
 }
 
 impl TryFrom<ModuleId> for CrateRootModuleId {
     type Error = ();
 
-    fn try_from(
-        ModuleId {
-            krate,
-            block,
-            local_id,
-        }: ModuleId,
-    ) -> Result<Self, Self::Error> {
+    fn try_from(ModuleId { krate, block, local_id }: ModuleId) -> Result<Self, Self::Error> {
         if block.is_none() && local_id == DefMap::ROOT {
             Ok(CrateRootModuleId { krate })
         } else {
     pub fn name(self, db: &dyn DefDatabase) -> Option<Name> {
         let def_map = self.def_map(db);
         let parent = def_map[self.local_id].parent?;
-        def_map[parent]
-            .children
-            .iter()
-            .find_map(|(name, module_id)| {
-                if *module_id == self.local_id {
-                    Some(name.clone())
-                } else {
-                    None
-                }
-            })
+        def_map[parent].children.iter().find_map(|(name, module_id)| {
+            if *module_id == self.local_id { Some(name.clone()) } else { None }
+        })
     }
 
     /// Returns the module containing `self`, either the parent `mod`, or the module (or block) containing
     pub fn parent(&self) -> GenericDefId {
         self.0.parent
     }
+
     pub fn local_id(&self) -> LocalTypeOrConstParamId {
         self.0.local_id
     }
     pub fn parent(&self) -> GenericDefId {
         self.0.parent
     }
+
     pub fn local_id(&self) -> LocalTypeOrConstParamId {
         self.0.local_id
     }
     ImplId(ImplId),
     TraitId(TraitId),
 }
+
 impl_from!(ModuleId for ItemContainerId);
 
 /// A Data Type
     UnionId(UnionId),
     EnumId(EnumId),
 }
+
 impl_from!(StructId, UnionId, EnumId for AdtId);
 
 /// A macro
     MacroRulesId(MacroRulesId),
     ProcMacroId(ProcMacroId),
 }
+
 impl_from!(Macro2Id, MacroRulesId, ProcMacroId for MacroId);
 
 impl MacroId {
     ConstParamId(ConstParamId),
     LifetimeParamId(LifetimeParamId),
 }
+
 impl_from!(TypeParamId, LifetimeParamId, ConstParamId for GenericParamId);
 
 /// The defs which can be visible in the module.
 pub enum ModuleDefId {
     ModuleId(ModuleId),
     FunctionId(FunctionId),
-    AdtId(AdtId),
-    // Can't be directly declared, but can be imported.
+    AdtId(AdtId), // Can't be directly declared, but can be imported.
     EnumVariantId(EnumVariantId),
     ConstId(ConstId),
     StaticId(StaticId),
     BuiltinType(BuiltinType),
     MacroId(MacroId),
 }
+
 impl_from!(
     MacroId(Macro2Id, MacroRulesId, ProcMacroId),
     ModuleId,
 
     pub fn name(self, db: &dyn DefDatabase) -> String {
         match self {
-            GeneralConstId::StaticId(it) => db
-                .static_signature(it)
-                .name
-                .display(db, Edition::CURRENT)
-                .to_string(),
+            GeneralConstId::StaticId(it) => {
+                db.static_signature(it).name.display(db, Edition::CURRENT).to_string()
+            }
             GeneralConstId::ConstId(const_id) => {
                 db.const_signature(const_id).name.as_ref().map_or_else(
                     || "_".to_owned(),
     StaticId(StaticId),
     ConstId(ConstId),
     VariantId(EnumVariantId),
-    // /// All fields of a variant are inference roots
-    // VariantId(VariantId),
-    // /// The signature can contain inference roots in a bunch of places
-    // /// like const parameters or const arguments in paths
-    // This should likely be kept on its own with a separate query
-    // GenericDefId(GenericDefId),
 }
+
 impl_from!(FunctionId, ConstId, StaticId for DefWithBodyId);
 
 impl From<EnumVariantId> for DefWithBodyId {
     TypeAliasId(TypeAliasId),
 }
 
-// FIXME: not every function, ... is actually an assoc item. maybe we should make
-// sure that you can only turn actual assoc items into AssocItemIds. This would
-// require not implementing From, and instead having some checked way of
-// casting them, and somehow making the constructors private, which would be annoying.
 impl_from!(FunctionId, ConstId, TypeAliasId for AssocItemId);
 
 impl From<AssocItemId> for ModuleDefId {
 
 #[derive(Debug, PartialOrd, Ord, Clone, Copy, PartialEq, Eq, Hash, salsa_macros::Supertype)]
 pub enum GenericDefId {
-    AdtId(AdtId),
-    // consts can have type parameters from their parents (i.e. associated consts of traits)
+    AdtId(AdtId), // consts can have type parameters from their parents (i.e. associated consts of traits)
     ConstId(ConstId),
     FunctionId(FunctionId),
-    ImplId(ImplId),
-    // can't actually have generics currently, but they might in the future
+    ImplId(ImplId), // can't actually have generics currently, but they might in the future
     // More importantly, this completes the set of items that contain type references
     // which is to be used by the signature expression store in the future.
     StaticId(StaticId),
     TraitId(TraitId),
     TypeAliasId(TypeAliasId),
 }
+
 impl_from!(
     AdtId(StructId, EnumId, UnionId),
     ConstId,
             Loc::Value: ast::HasGenericParams,
         {
             let src = def.lookup(db).source(db);
-            (
-                src.file_id,
-                ast::HasGenericParams::generic_param_list(&src.value),
-            )
+            (src.file_id, ast::HasGenericParams::generic_param_list(&src.value))
         }
 
         match self {
 }
 
 impl_from!(FunctionId, StructId, EnumVariantId for CallableDefId);
+
 impl From<CallableDefId> for ModuleDefId {
     fn from(def: CallableDefId) -> ModuleDefId {
         match def {
         }
     }
 }
+
 impl From<AssocItemId> for AttrDefId {
     fn from(assoc: AssocItemId) -> Self {
         match assoc {
         }
     }
 }
+
 impl From<VariantId> for AttrDefId {
     fn from(vid: VariantId) -> Self {
         match vid {
     StructId(StructId),
     UnionId(UnionId),
 }
+
 impl_from!(EnumVariantId, StructId, UnionId for VariantId);
 
 impl VariantId {
 pub trait HasModule {
     /// Returns the enclosing module this thing is defined within.
     fn module(&self, db: &dyn DefDatabase) -> ModuleId;
+
     /// Returns the crate this thing is defined within.
     #[inline]
     #[doc(alias = "crate")]
                 GenericParamId::TypeParamId(it) => it.parent(),
                 GenericParamId::ConstParamId(it) => it.parent(),
                 GenericParamId::LifetimeParamId(it) => it.parent,
-            }
-            .module(db),
+            }.module(
+                db,
+            ),
             AttrDefId::MacroId(it) => it.module(db),
             AttrDefId::ExternCrateId(it) => it.module(db),
             AttrDefId::UseId(it) => it.module(db),
         })
     }
 }
+
 /// Helper wrapper for `AstId` with `ModPath`
 #[derive(Clone, Debug, Eq, PartialEq)]
 struct AstIdWithPath<T: AstIdNode> {
 
 impl<T: AstIdNode> AstIdWithPath<T> {
     fn new(file_id: HirFileId, ast_id: FileAstId<T>, path: Interned<ModPath>) -> AstIdWithPath<T> {
-        AstIdWithPath {
-            ast_id: AstId::new(file_id, ast_id),
-            path,
-        }
+        AstIdWithPath { ast_id: AstId::new(file_id, ast_id), path }
     }
 }
 
     krate: Crate,
     resolver: impl Fn(&ModPath) -> Option<MacroDefId> + Copy,
     eager_callback: &mut dyn FnMut(
-        InFile<(
-            syntax::AstPtr<ast::MacroCall>,
-            span::FileAstId<ast::MacroCall>,
-        )>,
+        InFile<(syntax::AstPtr<ast::MacroCall>, span::FileAstId<ast::MacroCall>)>,
         MacroCallId,
     ),
 ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {
             value: Some(def.make_call(
                 db,
                 krate,
-                MacroCallKind::FnLike {
-                    ast_id,
-                    expand_to,
-                    eager: None,
-                },
+                MacroCallKind::FnLike { ast_id, expand_to, eager: None },
                 call_site,
             )),
             err: None,
             }
             let action = segments[1].symbol();
             if *action == sym::completions {
-                match ra_attr
-                    .token_tree_value()
-                    .map(|tt| tt.token_trees().flat_tokens())
-                {
+                match ra_attr.token_tree_value().map(|tt| tt.token_trees().flat_tokens()) {
                     Some([tt::TokenTree::Leaf(tt::Leaf::Ident(ident))]) => {
                         if ident.sym == sym::ignore_flyimport {
                             do_not_complete = Complete::IgnoreFlyimport;