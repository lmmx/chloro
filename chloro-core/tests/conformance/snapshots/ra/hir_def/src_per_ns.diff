COMPARISON DIFF
============================================================

Original size: 5172 bytes
Chloro size:   5107 bytes
Rustfmt size:  5492 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use bitflags::bitflags;
 
 use crate::{
-    item_scope::{ImportId, ImportOrExternCrate, ImportOrGlob, ItemInNs},
-    visibility::Visibility,
+    item_scope::{ImportId, visibility::Visibility, ImportOrExternCrate, ImportOrGlob, ItemInNs},
     MacroId, ModuleDefId,
 };
 
     Values,
     Macros,
 }
-
-bitflags! {
-    /// Describes only the presence/absence of each namespace, without its value.
-    #[derive(Debug, PartialEq, Eq)]
-    pub(crate) struct NsAvailability : u32 {
-        const TYPES = 1 << 0;
-        const VALUES = 1 << 1;
-        const MACROS = 1 << 2;
-    }
-}
-
+/// Describes only the presence/absence of each namespace, without its value.
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
 pub struct Item<Def, Import = ImportId> {
     pub def: Def,
 }
 
 pub type TypesItem = Item<ModuleDefId, ImportOrExternCrate>;
+
 pub type ValuesItem = Item<ModuleDefId, ImportOrGlob>;
-// May be Externcrate for `[macro_use]`'d macros
+
 pub type MacrosItem = Item<MacroId, ImportOrExternCrate>;
 
 #[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]
     }
 
     pub fn none() -> PerNs {
-        PerNs {
-            types: None,
-            values: None,
-            macros: None,
-        }
+        PerNs { types: None, values: None, macros: None }
     }
 
-    pub fn values(def: ModuleDefId, vis: Visibility, import: Option<ImportOrGlob>) -> PerNs {
-        PerNs {
-            types: None,
-            values: Some(Item { def, vis, import }),
-            macros: None,
-        }
+    pub fn values(
+        def: ModuleDefId,
+        vis: Visibility,
+        import: Option<ImportOrGlob>,
+    ) -> PerNs {
+        PerNs { types: None, values: Some(Item { def, vis, import }), macros: None }
     }
 
-    pub fn types(def: ModuleDefId, vis: Visibility, import: Option<ImportOrExternCrate>) -> PerNs {
-        PerNs {
-            types: Some(Item { def, vis, import }),
-            values: None,
-            macros: None,
-        }
+    pub fn types(
+        def: ModuleDefId,
+        vis: Visibility,
+        import: Option<ImportOrExternCrate>,
+    ) -> PerNs {
+        PerNs { types: Some(Item { def, vis, import }), values: None, macros: None }
     }
 
     pub fn both(
         import: Option<ImportOrExternCrate>,
     ) -> PerNs {
         PerNs {
-            types: Some(Item {
-                def: types,
-                vis,
-                import,
-            }),
+            types: Some(Item { def: types, vis, import }),
             values: Some(Item {
                 def: values,
                 vis,
         }
     }
 
-    pub fn macros(def: MacroId, vis: Visibility, import: Option<ImportOrExternCrate>) -> PerNs {
-        PerNs {
-            types: None,
-            values: None,
-            macros: Some(Item { def, vis, import }),
-        }
+    pub fn macros(
+        def: MacroId,
+        vis: Visibility,
+        import: Option<ImportOrExternCrate>,
+    ) -> PerNs {
+        PerNs { types: None, values: None, macros: Some(Item { def, vis, import }) }
     }
 
     pub fn is_none(&self) -> bool {
         self.macros.map(|it| (it.def, it.import))
     }
 
-    pub fn filter_visibility(self, mut f: impl FnMut(Visibility) -> bool) -> PerNs {
+    pub fn filter_visibility(
+        self,
+        mut f: impl FnMut(Visibility) -> bool,
+    ) -> PerNs {
         let _p = tracing::info_span!("PerNs::filter_visibility").entered();
         PerNs {
             types: self.types.filter(|def| f(def.vis)),
         }
     }
 
-    pub fn with_visibility(self, vis: Visibility) -> PerNs {
+    pub fn with_visibility(
+        self,
+        vis: Visibility,
+    ) -> PerNs {
         PerNs {
             types: self.types.map(|def| Item { vis, ..def }),
             values: self.values.map(|def| Item { vis, ..def }),
         }
     }
 
-    pub fn or(self, other: PerNs) -> PerNs {
+    pub fn or(
+        self,
+        other: PerNs,
+    ) -> PerNs {
         PerNs {
             types: self.types.or(other.types),
             values: self.values.or(other.values),
         }
     }
 
-    pub fn or_else(self, f: impl FnOnce() -> PerNs) -> PerNs {
-        if self.is_full() {
-            self
-        } else {
-            self.or(f())
-        }
+    pub fn or_else(
+        self,
+        f: impl FnOnce() -> PerNs,
+    ) -> PerNs {
+        if self.is_full() { self } else { self.or(f()) }
     }
 
     pub fn iter_items(self) -> impl Iterator<Item = (ItemInNs, Option<ImportOrExternCrate>)> {
         self.types
             .map(|it| (ItemInNs::Types(it.def), it.import))
             .into_iter()
-            .chain(self.values.map(|it| {
-                (
-                    ItemInNs::Values(it.def),
-                    it.import.map(ImportOrExternCrate::from),
-                )
-            }))
+            .chain(
+                self.values
+                    .map(|it| (ItemInNs::Values(it.def), it.import.map(ImportOrExternCrate::from))),
+            )
             .chain(self.macros.map(|it| (ItemInNs::Macros(it.def), it.import)))
     }
 }