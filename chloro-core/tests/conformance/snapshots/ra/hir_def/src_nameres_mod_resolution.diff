COMPARISON DIFF
============================================================

Original size: 5229 bytes
Chloro size:   5317 bytes
Rustfmt size:  5418 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module resolves `mod foo;` declaration to file.
+
 use arrayvec::ArrayVec;
 use base_db::AnchoredPath;
-use hir_expand::{name::Name, EditionedFileId};
+use hir_expand::{EditionedFileId, name::Name};
 
-use crate::{db::DefDatabase, HirFileId};
+use crate::{HirFileId, db::DefDatabase};
 
 const MOD_DEPTH_LIMIT: usize = 32;
 
 
 impl ModDir {
     pub(super) fn root() -> ModDir {
-        ModDir {
-            dir_path: DirPath::empty(),
-            root_non_dir_owner: false,
-            depth: 0,
-        }
+        ModDir { dir_path: DirPath::empty(), root_non_dir_owner: false, depth: 0 }
     }
 
     pub(super) fn descend_into_definition(
         self.child(path, false)
     }
 
-    fn child(&self, dir_path: DirPath, root_non_dir_owner: bool) -> Option<ModDir> {
+    fn child(
+        &self,
+        dir_path: DirPath,
+        root_non_dir_owner: bool,
+    ) -> Option<ModDir> {
         let depth = self.depth + 1;
         if depth as usize > MOD_DEPTH_LIMIT {
             tracing::error!("MOD_DEPTH_LIMIT exceeded");
             cov_mark::hit!(circular_mods);
             return None;
         }
-        Some(ModDir {
-            dir_path,
-            root_non_dir_owner,
-            depth,
-        })
+        Some(ModDir { dir_path, root_non_dir_owner, depth })
     }
 
     pub(super) fn resolve_declaration(
         attr_path: Option<&str>,
     ) -> Result<(EditionedFileId, bool, ModDir), Box<[String]>> {
         let name = name.as_str();
-
         let mut candidate_files = ArrayVec::<_, 2>::new();
         match attr_path {
             Some(attr_path) => {
                 candidate_files.push(format!("{}{}/mod.rs", self.dir_path.0, name));
             }
         };
-
         let orig_file_id = file_id.original_file_respecting_includes(db);
         for candidate in candidate_files.iter() {
-            let path = AnchoredPath {
-                anchor: orig_file_id.file_id(db),
-                path: candidate.as_str(),
-            };
+            let path = AnchoredPath { anchor: orig_file_id.file_id(db), path: candidate.as_str() };
             if let Some(file_id) = db.resolve_path(path) {
                 let is_mod_rs = candidate.ends_with("/mod.rs");
 
     fn assert_invariant(&self) {
         assert!(self.0.is_empty() || self.0.ends_with('/'));
     }
+
     fn new(repr: String) -> DirPath {
         let res = DirPath(repr);
         res.assert_invariant();
         res
     }
+
     fn empty() -> DirPath {
         DirPath::new(String::new())
     }
-    fn push(&mut self, name: &str) {
+
+    fn push(
+        &mut self,
+        name: &str,
+    ) {
         self.0.push_str(name);
         self.0.push('/');
         self.assert_invariant();
     }
+
     fn parent(&self) -> Option<&str> {
         if self.0.is_empty() {
             return None;
         };
-        let idx = self.0[..self.0.len() - '/'.len_utf8()]
-            .rfind('/')
-            .map_or(0, |it| it + '/'.len_utf8());
+        let idx =
+            self.0[..self.0.len() - '/'.len_utf8()].rfind('/').map_or(0, |it| it + '/'.len_utf8());
         Some(&self.0[..idx])
     }
+
     /// So this is the case which doesn't really work I think if we try to be
     /// 100% platform agnostic:
     ///
     /// Here, we need to join logical dir path to a string path from an
     /// attribute. Ideally, we should somehow losslessly communicate the whole
     /// construction to `FileLoader`.
-    fn join_attr(&self, mut attr: &str, relative_to_parent: bool) -> String {
-        let base = if relative_to_parent {
-            self.parent().unwrap()
-        } else {
-            &self.0
-        };
-
+    fn join_attr(
+        &self,
+        mut attr: &str,
+        relative_to_parent: bool,
+    ) -> String {
+        let base = if relative_to_parent { self.parent().unwrap() } else { &self.0 };
         if attr.starts_with("./") {
             attr = &attr["./".len()..];
         }