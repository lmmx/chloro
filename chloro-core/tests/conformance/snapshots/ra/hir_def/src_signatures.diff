COMPARISON DIFF
============================================================

Original size: 33467 bytes
Chloro size:   30605 bytes
Rustfmt size:  34530 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use bitflags::bitflags;
 use cfg::{CfgExpr, CfgOptions};
 use hir_expand::{
-    name::{AsName, Name},
     InFile, Intern, Lookup,
+    name::{AsName, Name},
 };
-use intern::{sym, Symbol};
+use intern::{Symbol, sym};
 use la_arena::{Arena, Idx};
 use rustc_abi::{IntegerType, ReprOptions};
 use syntax::{
-    ast::{self, HasGenericParams, HasName, HasVisibility, IsString},
-    NodeOrToken, SyntaxNodePtr, T,
+    ast::{self, HasGenericParams, HasName, HasVisibility, IsString}, NodeOrToken, SyntaxNodePtr, T,
 };
 use thin_vec::ThinVec;
 use triomphe::Arc;
 
 use crate::{
-    attr::Attrs,
-    db::DefDatabase,
-    expr_store::{
-        lower::{
-            lower_function, lower_generic_params, lower_trait, lower_type_alias, ExprCollector,
-        },
-        ExpressionStore, ExpressionStoreSourceMap,
-    },
-    hir::{generics::GenericParams, ExprId, PatId},
-    item_tree::{visibility_from_ast, FieldsShape, RawVisibility},
-    lang_item::LangItem,
-    src::HasSource,
-    type_ref::{TraitRef, TypeBound, TypeRefId},
-    ConstId, EnumId, EnumVariantId, EnumVariantLoc, ExternBlockId, FunctionId, HasModule, ImplId,
-    ItemContainerId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,
+    attr::Attrs, db::DefDatabase, expr_store::{
+        ExpressionStore, generics::GenericParams},
+    hir::{ExprId, item_tree::{FieldsShape, lang_item::LangItem, lower::{
+            ExprCollector,
+    lower_function, lower_generic_params, lower_trait, lower_type_alias, src::HasSource,
+    type_ref::{TraitRef, visibility_from_ast}, ConstId, EnumId, EnumVariantId, EnumVariantLoc,
+    ExpressionStoreSourceMap, ExternBlockId, FunctionId, HasModule, ImplId, ItemContainerId,
+    ModuleId, PatId, RawVisibility, StaticId, StructId, TraitId, TypeAliasId, TypeBound,
+    TypeRefId}, UnionId, VariantId, }, },
 };
 
 #[inline]
     pub shape: FieldsShape,
     pub repr: Option<ReprOptions>,
 }
-
-bitflags! {
-    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
-    pub struct StructFlags: u8 {
-        /// Indicates whether the struct has a `#[rustc_has_incoherent_inherent_impls]` attribute.
-        const RUSTC_HAS_INCOHERENT_INHERENT_IMPLS = 1 << 1;
-        /// Indicates whether the struct has a `#[fundamental]` attribute.
-        const FUNDAMENTAL      = 1 << 2;
-        /// Indicates whether the struct is `PhantomData`.
-        const IS_PHANTOM_DATA  = 1 << 3;
-        /// Indicates whether this struct is `Box`.
-        const IS_BOX           = 1 << 4;
-        /// Indicates whether this struct is `ManuallyDrop`.
-        const IS_MANUALLY_DROP = 1 << 5;
-        /// Indicates whether this struct is `UnsafeCell`.
-        const IS_UNSAFE_CELL   = 1 << 6;
-        /// Indicates whether this struct is `UnsafePinned`.
-        const IS_UNSAFE_PINNED = 1 << 7;
-    }
-}
-
+/// Indicates whether the struct has a `#[rustc_has_incoherent_inherent_impls]` attribute.
+/// Indicates whether the struct has a `#[fundamental]` attribute.
+/// Indicates whether the struct is `PhantomData`.
+/// Indicates whether this struct is `Box`.
+/// Indicates whether this struct is `ManuallyDrop`.
+/// Indicates whether this struct is `UnsafeCell`.
+/// Indicates whether this struct is `UnsafePinned`.
 impl StructSignature {
-    pub fn query(db: &dyn DefDatabase, id: StructId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: StructId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let attrs = db.attrs(id.into());
-
         let mut flags = StructFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= StructFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::fundamental).exists() {
         }
         let repr = attrs.repr();
         let shape = adt_shape(source.kind());
-
         let (store, generic_params, source_map) = lower_generic_params(
             db,
             loc.container,
 }
 
 impl UnionSignature {
-    pub fn query(db: &dyn DefDatabase, id: UnionId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: UnionId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
         let attrs = db.attrs(id.into());
         let mut flags = StructFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= StructFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::fundamental).exists() {
             flags |= StructFlags::FUNDAMENTAL;
         }
-
         let repr = attrs.repr();
-
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let (store, generic_params, source_map) = lower_generic_params(
             db,
             loc.container,
         )
     }
 }
-
-bitflags! {
-    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
-    pub struct EnumFlags: u8 {
-        const RUSTC_HAS_INCOHERENT_INHERENT_IMPLS  = 1 << 1;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct EnumSignature {
     pub name: Name,
 }
 
 impl EnumSignature {
-    pub fn query(db: &dyn DefDatabase, id: EnumId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: EnumId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
         let attrs = db.attrs(id.into());
         let mut flags = EnumFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= EnumFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
-
         let repr = attrs.repr();
-
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let (store, generic_params, source_map) = lower_generic_params(
             db,
             loc.container,
             source.generic_param_list(),
             source.where_clause(),
         );
-
         (
             Arc::new(EnumSignature {
                 generic_params,
 
     pub fn variant_body_type(&self) -> IntegerType {
         match self.repr {
-            Some(ReprOptions {
-                int: Some(builtin), ..
-            }) => builtin,
+            Some(ReprOptions { int: Some(builtin), .. }) => builtin,
             _ => IntegerType::Pointer(true),
         }
     }
 }
-bitflags::bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct ConstFlags: u8 {
-        const HAS_BODY = 1 << 1;
-        const RUSTC_ALLOW_INCOHERENT_IMPL = 1 << 7;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct ConstSignature {
     pub name: Option<Name>,
-    // generic_params: Arc<GenericParams>,
     pub store: Arc<ExpressionStore>,
     pub type_ref: TypeRefId,
     pub flags: ConstFlags,
 }
 
 impl ConstSignature {
-    pub fn query(db: &dyn DefDatabase, id: ConstId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: ConstId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
-
         let module = loc.container.module(db);
         let attrs = db.attrs(id.into());
         let mut flags = ConstFlags::empty();
         if source.value.body().is_some() {
             flags.insert(ConstFlags::HAS_BODY);
         }
-
         let (store, source_map, type_ref) =
             crate::expr_store::lower::lower_type_ref(db, module, source.as_ref().map(|it| it.ty()));
-
         (
             Arc::new(ConstSignature {
                 store: Arc::new(store),
         self.flags.contains(ConstFlags::HAS_BODY)
     }
 }
-
-bitflags::bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct StaticFlags: u8 {
-        const HAS_BODY = 1 << 1;
-        const MUTABLE    = 1 << 3;
-        const UNSAFE     = 1 << 4;
-        const EXPLICIT_SAFE = 1 << 5;
-        const EXTERN     = 1 << 6;
-        const RUSTC_ALLOW_INCOHERENT_IMPL = 1 << 7;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct StaticSignature {
     pub name: Name,
-
-    // generic_params: Arc<GenericParams>,
     pub store: Arc<ExpressionStore>,
     pub type_ref: TypeRefId,
     pub flags: StaticFlags,
 }
-impl StaticSignature {
-    pub fn query(db: &dyn DefDatabase, id: StaticId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
-        let loc = id.lookup(db);
 
+impl StaticSignature {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: StaticId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+        let loc = id.lookup(db);
         let module = loc.container.module(db);
         let attrs = db.attrs(id.into());
         let mut flags = StaticFlags::empty();
         if attrs.by_key(sym::rustc_allow_incoherent_impl).exists() {
             flags |= StaticFlags::RUSTC_ALLOW_INCOHERENT_IMPL;
         }
-
         if matches!(loc.container, ItemContainerId::ExternBlockId(_)) {
             flags.insert(StaticFlags::EXTERN);
         }
-
         let source = loc.source(db);
         if source.value.body().is_some() {
             flags.insert(StaticFlags::HAS_BODY);
         if source.value.safe_token().is_some() {
             flags.insert(StaticFlags::EXPLICIT_SAFE);
         }
-
         let (store, source_map, type_ref) =
             crate::expr_store::lower::lower_type_ref(db, module, source.as_ref().map(|it| it.ty()));
-
         (
             Arc::new(StaticSignature {
                 store: Arc::new(store),
         )
     }
 }
-
-bitflags::bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct ImplFlags: u8 {
-        const NEGATIVE = 1 << 1;
-        const DEFAULT = 1 << 2;
-        const UNSAFE = 1 << 3;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct ImplSignature {
     pub generic_params: Arc<GenericParams>,
 }
 
 impl ImplSignature {
-    pub fn query(db: &dyn DefDatabase, id: ImplId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: ImplId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
-
         let mut flags = ImplFlags::empty();
         let src = loc.source(db);
         if src.value.unsafe_token().is_some() {
         if src.value.default_token().is_some() {
             flags.insert(ImplFlags::DEFAULT);
         }
-
         let (store, source_map, self_ty, target_trait, generic_params) =
             crate::expr_store::lower::lower_impl(db, loc.container, src, id);
-
         (
             Arc::new(ImplSignature {
                 store: Arc::new(store),
         self.flags.contains(ImplFlags::DEFAULT)
     }
 }
-
-bitflags::bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct TraitFlags: u16 {
-        const RUSTC_HAS_INCOHERENT_INHERENT_IMPLS = 1 << 1;
-        const FUNDAMENTAL = 1 << 2;
-        const UNSAFE = 1 << 3;
-        const AUTO = 1 << 4;
-        const SKIP_ARRAY_DURING_METHOD_DISPATCH = 1 << 5;
-        const SKIP_BOXED_SLICE_DURING_METHOD_DISPATCH = 1 << 6;
-        const RUSTC_PAREN_SUGAR = 1 << 7;
-        const COINDUCTIVE = 1 << 8;
-        const ALIAS = 1 << 9;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct TraitSignature {
     pub name: Name,
 }
 
 impl TraitSignature {
-    pub fn query(db: &dyn DefDatabase, id: TraitId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: TraitId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
-
         let mut flags = TraitFlags::empty();
         let attrs = db.attrs(id.into());
         let source = loc.source(db);
         if attrs.by_key(sym::fundamental).exists() {
             flags |= TraitFlags::FUNDAMENTAL;
         }
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::rustc_paren_sugar).exists() {
         if attrs.by_key(sym::rustc_coinductive).exists() {
             flags |= TraitFlags::COINDUCTIVE;
         }
-        let mut skip_array_during_method_dispatch = attrs
-            .by_key(sym::rustc_skip_array_during_method_dispatch)
-            .exists();
+        let mut skip_array_during_method_dispatch =
+            attrs.by_key(sym::rustc_skip_array_during_method_dispatch).exists();
         let mut skip_boxed_slice_during_method_dispatch = false;
-        for tt in attrs
-            .by_key(sym::rustc_skip_during_method_dispatch)
-            .tt_values()
-        {
+        for tt in attrs.by_key(sym::rustc_skip_during_method_dispatch).tt_values() {
             for tt in tt.iter() {
                 if let tt::iter::TtElement::Leaf(tt::Leaf::Ident(ident)) = tt {
                     skip_array_during_method_dispatch |= ident.sym == sym::array;
                 }
             }
         }
-
         if skip_array_during_method_dispatch {
             flags |= TraitFlags::SKIP_ARRAY_DURING_METHOD_DISPATCH;
         }
         if skip_boxed_slice_during_method_dispatch {
             flags |= TraitFlags::SKIP_BOXED_SLICE_DURING_METHOD_DISPATCH;
         }
-
         let name = as_name_opt(source.value.name());
         let (store, source_map, generic_params) = lower_trait(db, loc.container, source, id);
-
         (
-            Arc::new(TraitSignature {
-                store: Arc::new(store),
-                generic_params,
-                flags,
-                name,
-            }),
+            Arc::new(TraitSignature { store: Arc::new(store), generic_params, flags, name }),
             Arc::new(source_map),
         )
     }
 }
-
-bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct FnFlags: u16 {
-        const HAS_BODY = 1 << 1;
-        const DEFAULT = 1 << 2;
-        const CONST = 1 << 3;
-        const ASYNC = 1 << 4;
-        const UNSAFE = 1 << 5;
-        const HAS_VARARGS = 1 << 6;
-        const RUSTC_ALLOW_INCOHERENT_IMPL = 1 << 7;
-        const HAS_SELF_PARAM = 1 << 8;
-        /// The `#[target_feature]` attribute is necessary to check safety (with RFC 2396),
-        /// but keeping it for all functions will consume a lot of memory when there are
-        /// only very few functions with it. So we only encode its existence here, and lookup
-        /// it if needed.
-        const HAS_TARGET_FEATURE = 1 << 9;
-        const DEPRECATED_SAFE_2024 = 1 << 10;
-        const EXPLICIT_SAFE = 1 << 11;
-        const RUSTC_INTRINSIC = 1 << 12;
-    }
-}
-
+/// The `#[target_feature]` attribute is necessary to check safety (with RFC 2396),
+/// but keeping it for all functions will consume a lot of memory when there are
+/// only very few functions with it. So we only encode its existence here, and lookup
+/// it if needed.
 #[derive(Debug, PartialEq, Eq)]
 pub struct FunctionSignature {
     pub name: Name,
     pub ret_type: Option<TypeRefId>,
     pub abi: Option<Symbol>,
     pub flags: FnFlags,
-    // FIXME: we should put this behind a fn flags + query to avoid bloating the struct
     pub legacy_const_generics_indices: Option<Box<Box<[u32]>>>,
 }
 
     ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
         let module = loc.container.module(db);
-
         let mut flags = FnFlags::empty();
         let attrs = db.attrs(id.into());
         if attrs.by_key(sym::rustc_allow_incoherent_impl).exists() {
             flags.insert(FnFlags::RUSTC_ALLOW_INCOHERENT_IMPL);
         }
-
         if attrs.by_key(sym::target_feature).exists() {
             flags.insert(FnFlags::HAS_TARGET_FEATURE);
         }
             flags.insert(FnFlags::RUSTC_INTRINSIC);
         }
         let legacy_const_generics_indices = attrs.rustc_legacy_const_generics();
-
         let source = loc.source(db);
-
         if source.value.unsafe_token().is_some() {
             if attrs.by_key(sym::rustc_deprecated_safe_2024).exists() {
                 flags.insert(FnFlags::DEPRECATED_SAFE_2024);
         if source.value.body().is_some() {
             flags.insert(FnFlags::HAS_BODY);
         }
-
         let name = as_name_opt(source.value.name());
         let abi = source.value.abi().map(|abi| {
-            abi.abi_string()
-                .map_or_else(|| sym::C, |it| Symbol::intern(it.text_without_quotes()))
+            abi.abi_string().map_or_else(|| sym::C, |it| Symbol::intern(it.text_without_quotes()))
         });
         let (store, source_map, generic_params, params, ret_type, self_param, variadic) =
             lower_function(db, module, source, id);
         self.flags.contains(FnFlags::HAS_TARGET_FEATURE)
     }
 
-    pub fn is_intrinsic(db: &dyn DefDatabase, id: FunctionId) -> bool {
+    pub fn is_intrinsic(
+        db: &dyn DefDatabase,
+        id: FunctionId,
+    ) -> bool {
         let data = db.function_signature(id);
         data.flags.contains(FnFlags::RUSTC_INTRINSIC)
             // Keep this around for a bit until extern "rustc-intrinsic" abis are no longer used
             }
     }
 }
-
-bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct TypeAliasFlags: u8 {
-        const RUSTC_HAS_INCOHERENT_INHERENT_IMPL = 1 << 1;
-        const IS_EXTERN = 1 << 6;
-        const RUSTC_ALLOW_INCOHERENT_IMPL = 1 << 7;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct TypeAliasSignature {
     pub name: Name,
         id: TypeAliasId,
     ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
-
         let mut flags = TypeAliasFlags::empty();
         let attrs = db.attrs(id.into());
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags.insert(TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL);
         }
         if attrs.by_key(sym::rustc_allow_incoherent_impl).exists() {
         let name = as_name_opt(source.value.name());
         let (store, source_map, generic_params, bounds, ty) =
             lower_type_alias(db, loc.container.module(db), source, id);
-
         (
             Arc::new(TypeAliasSignature {
                 store: Arc::new(store),
 pub struct SimpleBody {
     pub store: Arc<ExpressionStore>,
 }
+
 pub type StaticBody = SimpleBody;
+
 pub type ConstBody = SimpleBody;
+
 pub type EnumVariantBody = SimpleBody;
 
 #[derive(Debug, PartialEq, Eq)]
         };
         match result {
             Some((fields, store, source_map)) => (
-                Arc::new(VariantFields {
-                    fields,
-                    store: Arc::new(store),
-                    shape,
-                }),
+                Arc::new(VariantFields { fields, store: Arc::new(store), shape }),
                 Arc::new(source_map),
             ),
             None => {
                 let (store, source_map) = ExpressionStore::empty_singleton();
-                (
-                    Arc::new(VariantFields {
-                        fields: Arena::default(),
-                        store,
-                        shape,
-                    }),
-                    source_map,
-                )
+                (Arc::new(VariantFields { fields: Arena::default(), store, shape }), source_map)
             }
         }
     }
 
     #[salsa::tracked(returns(deref))]
-    pub(crate) fn firewall(db: &dyn DefDatabase, id: VariantId) -> Arc<Self> {
+    pub(crate) fn firewall(
+        db: &dyn DefDatabase,
+        id: VariantId,
+    ) -> Arc<Self> {
         Self::query(db, id).0
     }
 }
         &self.fields
     }
 
-    pub fn field(&self, name: &Name) -> Option<LocalFieldId> {
-        self.fields()
-            .iter()
-            .find_map(|(id, data)| if &data.name == name { Some(id) } else { None })
+    pub fn field(
+        &self,
+        name: &Name,
+    ) -> Option<LocalFieldId> {
+        self.fields().iter().find_map(|(id, data)| if &data.name == name { Some(id) } else { None })
     }
 }
 
             visibility_from_ast(db, vis, &mut |range| span_map.span_for_range(range).ctx)
         })
     });
-
     let mut arena = Arena::new();
     let mut idx = 0;
     let mut has_fields = false;
                     .filter_map(NodeOrToken::into_token)
                     .any(|token| token.kind() == T![unsafe]);
                 let name = field_name(idx, &field);
-                arena.alloc(FieldData {
-                    name,
-                    type_ref,
-                    visibility,
-                    is_unsafe,
-                });
+                arena.alloc(FieldData { name, type_ref, visibility, is_unsafe });
                 idx += 1;
             }
             Err(cfg) => {
         let source = loc.source(db);
         let ast_id_map = db.ast_id_map(source.file_id);
         let span_map = db.span_map(source.file_id);
-
         let mut diagnostics = ThinVec::new();
         let cfg_options = loc.container.krate.cfg_options(db);
         let mut index = 0;
         let Some(variants) = source.value.variant_list() else {
-            return (
-                EnumVariants {
-                    variants: Box::default(),
-                },
-                None,
-            );
+            return (EnumVariants { variants: Box::default() }, None);
         };
         let variants = variants
             .variants()
                 let ast_id = ast_id_map.ast_id(&variant);
                 match Attrs::is_cfg_enabled_for(db, &variant, span_map.as_ref(), cfg_options) {
                     Ok(()) => {
-                        let enum_variant = EnumVariantLoc {
-                            id: source.with_value(ast_id),
-                            parent: e,
-                            index,
-                        }
-                        .intern(db);
+                        let enum_variant =
+                            EnumVariantLoc { id: source.with_value(ast_id), parent: e, index }
+                                .intern(db);
                         index += 1;
                         let name = as_name_opt(variant.name());
                         let shape = adt_shape(variant.kind());
                 }
             })
             .collect();
-
-        (
-            EnumVariants { variants },
-            diagnostics.is_empty().not().then_some(diagnostics),
-        )
+        (EnumVariants { variants }, diagnostics.is_empty().not().then_some(diagnostics))
     }
 }
 
 impl EnumVariants {
-    pub fn variant(&self, name: &Name) -> Option<EnumVariantId> {
+    pub fn variant(
+        &self,
+        name: &Name,
+    ) -> Option<EnumVariantId> {
+        self.variants.iter().find_map(|(v, n, _)| if n == name { Some(*v) } else { None })
+    }
+
+    pub fn variant_name_by_id(
+        &self,
+        variant_id: EnumVariantId,
+    ) -> Option<Name> {
         self.variants
             .iter()
-            .find_map(|(v, n, _)| if n == name { Some(*v) } else { None })
+            .find_map(|(id, name, _)| if *id == variant_id { Some(name.clone()) } else { None })
     }
 
-    pub fn variant_name_by_id(&self, variant_id: EnumVariantId) -> Option<Name> {
-        self.variants.iter().find_map(|(id, name, _)| {
-            if *id == variant_id {
-                Some(name.clone())
-            } else {
-                None
-            }
-        })
-    }
-
-    // [Adopted from rustc](https://github.com/rust-lang/rust/blob/bd53aa3bf7a24a70d763182303bd75e5fc51a9af/compiler/rustc_middle/src/ty/adt.rs#L446-L448)
-    pub fn is_payload_free(&self, db: &dyn DefDatabase) -> bool {
+    pub fn is_payload_free(
+        &self,
+        db: &dyn DefDatabase,
+    ) -> bool {
         self.variants.iter().all(|&(v, _, _)| {
             // The condition check order is slightly modified from rustc
             // to improve performance by early returning with relatively fast checks