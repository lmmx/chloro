COMPARISON DIFF
============================================================

Original size: 33467 bytes
Chloro size:   30594 bytes
Rustfmt size:  34530 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     name::{AsName, Name},
     InFile, Intern, Lookup,
 };
-use intern::{sym, Symbol};
+use intern::{Symbol, sym};
 use la_arena::{Arena, Idx};
 use rustc_abi::{IntegerType, ReprOptions};
 use syntax::{
     db::DefDatabase,
     expr_store::{
         lower::{
-            lower_function, lower_generic_params, lower_trait, lower_type_alias, ExprCollector,
+            ExprCollector, lower_function, lower_generic_params, lower_trait, lower_type_alias,
         },
         ExpressionStore, ExpressionStoreSourceMap,
     },
     pub shape: FieldsShape,
     pub repr: Option<ReprOptions>,
 }
-
-bitflags! {
-    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
-    pub struct StructFlags: u8 {
-        /// Indicates whether the struct has a `#[rustc_has_incoherent_inherent_impls]` attribute.
-        const RUSTC_HAS_INCOHERENT_INHERENT_IMPLS = 1 << 1;
-        /// Indicates whether the struct has a `#[fundamental]` attribute.
-        const FUNDAMENTAL      = 1 << 2;
-        /// Indicates whether the struct is `PhantomData`.
-        const IS_PHANTOM_DATA  = 1 << 3;
-        /// Indicates whether this struct is `Box`.
-        const IS_BOX           = 1 << 4;
-        /// Indicates whether this struct is `ManuallyDrop`.
-        const IS_MANUALLY_DROP = 1 << 5;
-        /// Indicates whether this struct is `UnsafeCell`.
-        const IS_UNSAFE_CELL   = 1 << 6;
-        /// Indicates whether this struct is `UnsafePinned`.
-        const IS_UNSAFE_PINNED = 1 << 7;
-    }
-}
-
+/// Indicates whether the struct has a `#[rustc_has_incoherent_inherent_impls]` attribute.
+/// Indicates whether the struct has a `#[fundamental]` attribute.
+/// Indicates whether the struct is `PhantomData`.
+/// Indicates whether this struct is `Box`.
+/// Indicates whether this struct is `ManuallyDrop`.
+/// Indicates whether this struct is `UnsafeCell`.
+/// Indicates whether this struct is `UnsafePinned`.
 impl StructSignature {
-    pub fn query(db: &dyn DefDatabase, id: StructId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: StructId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let attrs = db.attrs(id.into());
 
         let mut flags = StructFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= StructFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::fundamental).exists() {
         let loc = id.lookup(db);
         let attrs = db.attrs(id.into());
         let mut flags = StructFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= StructFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::fundamental).exists() {
 
         let repr = attrs.repr();
 
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let (store, generic_params, source_map) = lower_generic_params(
             db,
             loc.container,
         )
     }
 }
-
-bitflags! {
-    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
-    pub struct EnumFlags: u8 {
-        const RUSTC_HAS_INCOHERENT_INHERENT_IMPLS  = 1 << 1;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct EnumSignature {
     pub name: Name,
         let loc = id.lookup(db);
         let attrs = db.attrs(id.into());
         let mut flags = EnumFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= EnumFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
 
         let repr = attrs.repr();
 
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let (store, generic_params, source_map) = lower_generic_params(
             db,
             loc.container,
 
     pub fn variant_body_type(&self) -> IntegerType {
         match self.repr {
-            Some(ReprOptions {
-                int: Some(builtin), ..
-            }) => builtin,
+            Some(ReprOptions { int: Some(builtin), .. }) => builtin,
             _ => IntegerType::Pointer(true),
         }
     }
 }
-bitflags::bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct ConstFlags: u8 {
-        const HAS_BODY = 1 << 1;
-        const RUSTC_ALLOW_INCOHERENT_IMPL = 1 << 7;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct ConstSignature {
     pub name: Option<Name>,
         self.flags.contains(ConstFlags::HAS_BODY)
     }
 }
-
-bitflags::bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct StaticFlags: u8 {
-        const HAS_BODY = 1 << 1;
-        const MUTABLE    = 1 << 3;
-        const UNSAFE     = 1 << 4;
-        const EXPLICIT_SAFE = 1 << 5;
-        const EXTERN     = 1 << 6;
-        const RUSTC_ALLOW_INCOHERENT_IMPL = 1 << 7;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct StaticSignature {
     pub name: Name,
-
     // generic_params: Arc<GenericParams>,
     pub store: Arc<ExpressionStore>,
     pub type_ref: TypeRefId,
     pub flags: StaticFlags,
 }
+
 impl StaticSignature {
-    pub fn query(db: &dyn DefDatabase, id: StaticId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: StaticId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
 
         let module = loc.container.module(db);
         )
     }
 }
-
-bitflags::bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct ImplFlags: u8 {
-        const NEGATIVE = 1 << 1;
-        const DEFAULT = 1 << 2;
-        const UNSAFE = 1 << 3;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct ImplSignature {
     pub generic_params: Arc<GenericParams>,
         self.flags.contains(ImplFlags::DEFAULT)
     }
 }
-
-bitflags::bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct TraitFlags: u16 {
-        const RUSTC_HAS_INCOHERENT_INHERENT_IMPLS = 1 << 1;
-        const FUNDAMENTAL = 1 << 2;
-        const UNSAFE = 1 << 3;
-        const AUTO = 1 << 4;
-        const SKIP_ARRAY_DURING_METHOD_DISPATCH = 1 << 5;
-        const SKIP_BOXED_SLICE_DURING_METHOD_DISPATCH = 1 << 6;
-        const RUSTC_PAREN_SUGAR = 1 << 7;
-        const COINDUCTIVE = 1 << 8;
-        const ALIAS = 1 << 9;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct TraitSignature {
     pub name: Name,
         if attrs.by_key(sym::fundamental).exists() {
             flags |= TraitFlags::FUNDAMENTAL;
         }
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::rustc_paren_sugar).exists() {
         if attrs.by_key(sym::rustc_coinductive).exists() {
             flags |= TraitFlags::COINDUCTIVE;
         }
-        let mut skip_array_during_method_dispatch = attrs
-            .by_key(sym::rustc_skip_array_during_method_dispatch)
-            .exists();
+        let mut skip_array_during_method_dispatch =
+            attrs.by_key(sym::rustc_skip_array_during_method_dispatch).exists();
         let mut skip_boxed_slice_during_method_dispatch = false;
-        for tt in attrs
-            .by_key(sym::rustc_skip_during_method_dispatch)
-            .tt_values()
-        {
+        for tt in attrs.by_key(sym::rustc_skip_during_method_dispatch).tt_values() {
             for tt in tt.iter() {
                 if let tt::iter::TtElement::Leaf(tt::Leaf::Ident(ident)) = tt {
                     skip_array_during_method_dispatch |= ident.sym == sym::array;
         let (store, source_map, generic_params) = lower_trait(db, loc.container, source, id);
 
         (
-            Arc::new(TraitSignature {
-                store: Arc::new(store),
-                generic_params,
-                flags,
-                name,
-            }),
+            Arc::new(TraitSignature { store: Arc::new(store), generic_params, flags, name }),
             Arc::new(source_map),
         )
     }
 }
-
-bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct FnFlags: u16 {
-        const HAS_BODY = 1 << 1;
-        const DEFAULT = 1 << 2;
-        const CONST = 1 << 3;
-        const ASYNC = 1 << 4;
-        const UNSAFE = 1 << 5;
-        const HAS_VARARGS = 1 << 6;
-        const RUSTC_ALLOW_INCOHERENT_IMPL = 1 << 7;
-        const HAS_SELF_PARAM = 1 << 8;
-        /// The `#[target_feature]` attribute is necessary to check safety (with RFC 2396),
-        /// but keeping it for all functions will consume a lot of memory when there are
-        /// only very few functions with it. So we only encode its existence here, and lookup
-        /// it if needed.
-        const HAS_TARGET_FEATURE = 1 << 9;
-        const DEPRECATED_SAFE_2024 = 1 << 10;
-        const EXPLICIT_SAFE = 1 << 11;
-        const RUSTC_INTRINSIC = 1 << 12;
-    }
-}
-
+/// The `#[target_feature]` attribute is necessary to check safety (with RFC 2396),
+/// but keeping it for all functions will consume a lot of memory when there are
+/// only very few functions with it. So we only encode its existence here, and lookup
+/// it if needed.
 #[derive(Debug, PartialEq, Eq)]
 pub struct FunctionSignature {
     pub name: Name,
 
         let name = as_name_opt(source.value.name());
         let abi = source.value.abi().map(|abi| {
-            abi.abi_string()
-                .map_or_else(|| sym::C, |it| Symbol::intern(it.text_without_quotes()))
+            abi.abi_string().map_or_else(|| sym::C, |it| Symbol::intern(it.text_without_quotes()))
         });
         let (store, source_map, generic_params, params, ret_type, self_param, variadic) =
             lower_function(db, module, source, id);
             }
     }
 }
-
-bitflags! {
-    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
-    pub struct TypeAliasFlags: u8 {
-        const RUSTC_HAS_INCOHERENT_INHERENT_IMPL = 1 << 1;
-        const IS_EXTERN = 1 << 6;
-        const RUSTC_ALLOW_INCOHERENT_IMPL = 1 << 7;
-    }
-}
-
 #[derive(Debug, PartialEq, Eq)]
 pub struct TypeAliasSignature {
     pub name: Name,
 
         let mut flags = TypeAliasFlags::empty();
         let attrs = db.attrs(id.into());
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags.insert(TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL);
         }
         if attrs.by_key(sym::rustc_allow_incoherent_impl).exists() {
 pub struct SimpleBody {
     pub store: Arc<ExpressionStore>,
 }
+
 pub type StaticBody = SimpleBody;
+
 pub type ConstBody = SimpleBody;
+
 pub type EnumVariantBody = SimpleBody;
 
 #[derive(Debug, PartialEq, Eq)]
         };
         match result {
             Some((fields, store, source_map)) => (
-                Arc::new(VariantFields {
-                    fields,
-                    store: Arc::new(store),
-                    shape,
-                }),
+                Arc::new(VariantFields { fields, store: Arc::new(store), shape }),
                 Arc::new(source_map),
             ),
             None => {
                 let (store, source_map) = ExpressionStore::empty_singleton();
-                (
-                    Arc::new(VariantFields {
-                        fields: Arena::default(),
-                        store,
-                        shape,
-                    }),
-                    source_map,
-                )
+                (Arc::new(VariantFields { fields: Arena::default(), store, shape }), source_map)
             }
         }
     }
     }
 
     pub fn field(&self, name: &Name) -> Option<LocalFieldId> {
-        self.fields()
-            .iter()
-            .find_map(|(id, data)| if &data.name == name { Some(id) } else { None })
+        self.fields().iter().find_map(|(id, data)| if &data.name == name { Some(id) } else { None })
     }
 }
 
                     .filter_map(NodeOrToken::into_token)
                     .any(|token| token.kind() == T![unsafe]);
                 let name = field_name(idx, &field);
-                arena.alloc(FieldData {
-                    name,
-                    type_ref,
-                    visibility,
-                    is_unsafe,
-                });
+                arena.alloc(FieldData { name, type_ref, visibility, is_unsafe });
                 idx += 1;
             }
             Err(cfg) => {
         let cfg_options = loc.container.krate.cfg_options(db);
         let mut index = 0;
         let Some(variants) = source.value.variant_list() else {
-            return (
-                EnumVariants {
-                    variants: Box::default(),
-                },
-                None,
-            );
+            return (EnumVariants { variants: Box::default() }, None);
         };
         let variants = variants
             .variants()
                 let ast_id = ast_id_map.ast_id(&variant);
                 match Attrs::is_cfg_enabled_for(db, &variant, span_map.as_ref(), cfg_options) {
                     Ok(()) => {
-                        let enum_variant = EnumVariantLoc {
-                            id: source.with_value(ast_id),
-                            parent: e,
-                            index,
-                        }
-                        .intern(db);
+                        let enum_variant =
+                            EnumVariantLoc { id: source.with_value(ast_id), parent: e, index }
+                                .intern(db);
                         index += 1;
                         let name = as_name_opt(variant.name());
                         let shape = adt_shape(variant.kind());
             })
             .collect();
 
-        (
-            EnumVariants { variants },
-            diagnostics.is_empty().not().then_some(diagnostics),
-        )
+        (EnumVariants { variants }, diagnostics.is_empty().not().then_some(diagnostics))
     }
 }
 
 impl EnumVariants {
     pub fn variant(&self, name: &Name) -> Option<EnumVariantId> {
-        self.variants
-            .iter()
-            .find_map(|(v, n, _)| if n == name { Some(*v) } else { None })
+        self.variants.iter().find_map(|(v, n, _)| if n == name { Some(*v) } else { None })
     }
 
     pub fn variant_name_by_id(&self, variant_id: EnumVariantId) -> Option<Name> {
-        self.variants.iter().find_map(|(id, name, _)| {
-            if *id == variant_id {
-                Some(name.clone())
-            } else {
-                None
-            }
-        })
+        self.variants
+            .iter()
+            .find_map(|(id, name, _)| if *id == variant_id { Some(name.clone()) } else { None })
     }
 
-    // [Adopted from rustc](https://github.com/rust-lang/rust/blob/bd53aa3bf7a24a70d763182303bd75e5fc51a9af/compiler/rustc_middle/src/ty/adt.rs#L446-L448)
     pub fn is_payload_free(&self, db: &dyn DefDatabase) -> bool {
         self.variants.iter().all(|&(v, _, _)| {
             // The condition check order is slightly modified from rustc