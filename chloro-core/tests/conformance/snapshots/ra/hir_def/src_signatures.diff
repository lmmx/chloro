COMPARISON DIFF
============================================================

Original size: 33467 bytes
Chloro size:   33366 bytes
Rustfmt size:  34530 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use bitflags::bitflags;
 use cfg::{CfgExpr, CfgOptions};
 use hir_expand::{
-    name::{AsName, Name},
     InFile, Intern, Lookup,
+    name::{AsName, Name},
 };
-use intern::{sym, Symbol};
+use intern::{Symbol, sym};
 use la_arena::{Arena, Idx};
 use rustc_abi::{IntegerType, ReprOptions};
 use syntax::{
+    NodeOrToken, SyntaxNodePtr,
     ast::{self, HasGenericParams, HasName, HasVisibility, IsString},
-    NodeOrToken, SyntaxNodePtr, T,
+    T,
 };
 use thin_vec::ThinVec;
 use triomphe::Arc;
 
 use crate::{
+    ConstId, EnumId, EnumVariantId, EnumVariantLoc, ExternBlockId, FunctionId, HasModule, ImplId,
+    ItemContainerId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,
     attr::Attrs,
     db::DefDatabase,
     expr_store::{
-        lower::{
-            lower_function, lower_generic_params, lower_trait, lower_type_alias, ExprCollector,
-        },
         ExpressionStore, ExpressionStoreSourceMap,
+        lower::{
+            ExprCollector, lower_function, lower_generic_params, lower_trait, lower_type_alias,
+        },
     },
-    hir::{generics::GenericParams, ExprId, PatId},
-    item_tree::{visibility_from_ast, FieldsShape, RawVisibility},
+    hir::{ExprId, PatId, generics::GenericParams},
+    item_tree::{FieldsShape, RawVisibility, visibility_from_ast},
     lang_item::LangItem,
     src::HasSource,
     type_ref::{TraitRef, TypeBound, TypeRefId},
-    ConstId, EnumId, EnumVariantId, EnumVariantLoc, ExternBlockId, FunctionId, HasModule, ImplId,
-    ItemContainerId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,
 };
 
 #[inline]
 }
 
 impl StructSignature {
-    pub fn query(db: &dyn DefDatabase, id: StructId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: StructId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let attrs = db.attrs(id.into());
 
         let mut flags = StructFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= StructFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::fundamental).exists() {
         let loc = id.lookup(db);
         let attrs = db.attrs(id.into());
         let mut flags = StructFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= StructFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::fundamental).exists() {
 
         let repr = attrs.repr();
 
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let (store, generic_params, source_map) = lower_generic_params(
             db,
             loc.container,
         let loc = id.lookup(db);
         let attrs = db.attrs(id.into());
         let mut flags = EnumFlags::empty();
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= EnumFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
 
         let repr = attrs.repr();
 
-        let InFile {
-            file_id,
-            value: source,
-        } = loc.source(db);
+        let InFile { file_id, value: source } = loc.source(db);
         let (store, generic_params, source_map) = lower_generic_params(
             db,
             loc.container,
 
     pub fn variant_body_type(&self) -> IntegerType {
         match self.repr {
-            Some(ReprOptions {
-                int: Some(builtin), ..
-            }) => builtin,
+            Some(ReprOptions { int: Some(builtin), .. }) => builtin,
             _ => IntegerType::Pointer(true),
         }
     }
 }
+
 bitflags::bitflags! {
     #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]
     pub struct ConstFlags: u8 {
 #[derive(Debug, PartialEq, Eq)]
 pub struct StaticSignature {
     pub name: Name,
-
     // generic_params: Arc<GenericParams>,
     pub store: Arc<ExpressionStore>,
     pub type_ref: TypeRefId,
     pub flags: StaticFlags,
 }
+
 impl StaticSignature {
-    pub fn query(db: &dyn DefDatabase, id: StaticId) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
+    pub fn query(
+        db: &dyn DefDatabase,
+        id: StaticId,
+    ) -> (Arc<Self>, Arc<ExpressionStoreSourceMap>) {
         let loc = id.lookup(db);
 
         let module = loc.container.module(db);
         if attrs.by_key(sym::fundamental).exists() {
             flags |= TraitFlags::FUNDAMENTAL;
         }
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags |= TraitFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPLS;
         }
         if attrs.by_key(sym::rustc_paren_sugar).exists() {
         if attrs.by_key(sym::rustc_coinductive).exists() {
             flags |= TraitFlags::COINDUCTIVE;
         }
-        let mut skip_array_during_method_dispatch = attrs
-            .by_key(sym::rustc_skip_array_during_method_dispatch)
-            .exists();
+        let mut skip_array_during_method_dispatch =
+            attrs.by_key(sym::rustc_skip_array_during_method_dispatch).exists();
         let mut skip_boxed_slice_during_method_dispatch = false;
-        for tt in attrs
-            .by_key(sym::rustc_skip_during_method_dispatch)
-            .tt_values()
-        {
+        for tt in attrs.by_key(sym::rustc_skip_during_method_dispatch).tt_values() {
             for tt in tt.iter() {
                 if let tt::iter::TtElement::Leaf(tt::Leaf::Ident(ident)) = tt {
                     skip_array_during_method_dispatch |= ident.sym == sym::array;
         let (store, source_map, generic_params) = lower_trait(db, loc.container, source, id);
 
         (
-            Arc::new(TraitSignature {
-                store: Arc::new(store),
-                generic_params,
-                flags,
-                name,
-            }),
+            Arc::new(TraitSignature { store: Arc::new(store), generic_params, flags, name }),
             Arc::new(source_map),
         )
     }
 
         let name = as_name_opt(source.value.name());
         let abi = source.value.abi().map(|abi| {
-            abi.abi_string()
-                .map_or_else(|| sym::C, |it| Symbol::intern(it.text_without_quotes()))
+            abi.abi_string().map_or_else(|| sym::C, |it| Symbol::intern(it.text_without_quotes()))
         });
         let (store, source_map, generic_params, params, ret_type, self_param, variadic) =
             lower_function(db, module, source, id);
 
         let mut flags = TypeAliasFlags::empty();
         let attrs = db.attrs(id.into());
-        if attrs
-            .by_key(sym::rustc_has_incoherent_inherent_impls)
-            .exists()
-        {
+        if attrs.by_key(sym::rustc_has_incoherent_inherent_impls).exists() {
             flags.insert(TypeAliasFlags::RUSTC_HAS_INCOHERENT_INHERENT_IMPL);
         }
         if attrs.by_key(sym::rustc_allow_incoherent_impl).exists() {
 pub struct SimpleBody {
     pub store: Arc<ExpressionStore>,
 }
+
 pub type StaticBody = SimpleBody;
+
 pub type ConstBody = SimpleBody;
+
 pub type EnumVariantBody = SimpleBody;
 
 #[derive(Debug, PartialEq, Eq)]
         };
         match result {
             Some((fields, store, source_map)) => (
-                Arc::new(VariantFields {
-                    fields,
-                    store: Arc::new(store),
-                    shape,
-                }),
+                Arc::new(VariantFields { fields, store: Arc::new(store), shape }),
                 Arc::new(source_map),
             ),
             None => {
                 let (store, source_map) = ExpressionStore::empty_singleton();
-                (
-                    Arc::new(VariantFields {
-                        fields: Arena::default(),
-                        store,
-                        shape,
-                    }),
-                    source_map,
-                )
+                (Arc::new(VariantFields { fields: Arena::default(), store, shape }), source_map)
             }
         }
     }
     }
 
     pub fn field(&self, name: &Name) -> Option<LocalFieldId> {
-        self.fields()
-            .iter()
-            .find_map(|(id, data)| if &data.name == name { Some(id) } else { None })
+        self.fields().iter().find_map(|(id, data)| if &data.name == name { Some(id) } else { None })
     }
 }
 
                     .filter_map(NodeOrToken::into_token)
                     .any(|token| token.kind() == T![unsafe]);
                 let name = field_name(idx, &field);
-                arena.alloc(FieldData {
-                    name,
-                    type_ref,
-                    visibility,
-                    is_unsafe,
-                });
+                arena.alloc(FieldData { name, type_ref, visibility, is_unsafe });
                 idx += 1;
             }
             Err(cfg) => {
         let cfg_options = loc.container.krate.cfg_options(db);
         let mut index = 0;
         let Some(variants) = source.value.variant_list() else {
-            return (
-                EnumVariants {
-                    variants: Box::default(),
-                },
-                None,
-            );
+            return (EnumVariants { variants: Box::default() }, None);
         };
         let variants = variants
             .variants()
                 let ast_id = ast_id_map.ast_id(&variant);
                 match Attrs::is_cfg_enabled_for(db, &variant, span_map.as_ref(), cfg_options) {
                     Ok(()) => {
-                        let enum_variant = EnumVariantLoc {
-                            id: source.with_value(ast_id),
-                            parent: e,
-                            index,
-                        }
-                        .intern(db);
+                        let enum_variant =
+                            EnumVariantLoc { id: source.with_value(ast_id), parent: e, index }
+                                .intern(db);
                         index += 1;
                         let name = as_name_opt(variant.name());
                         let shape = adt_shape(variant.kind());
             })
             .collect();
 
-        (
-            EnumVariants { variants },
-            diagnostics.is_empty().not().then_some(diagnostics),
-        )
+        (EnumVariants { variants }, diagnostics.is_empty().not().then_some(diagnostics))
     }
 }
 
 impl EnumVariants {
     pub fn variant(&self, name: &Name) -> Option<EnumVariantId> {
-        self.variants
-            .iter()
-            .find_map(|(v, n, _)| if n == name { Some(*v) } else { None })
+        self.variants.iter().find_map(|(v, n, _)| if n == name { Some(*v) } else { None })
     }
 
     pub fn variant_name_by_id(&self, variant_id: EnumVariantId) -> Option<Name> {
-        self.variants.iter().find_map(|(id, name, _)| {
-            if *id == variant_id {
-                Some(name.clone())
-            } else {
-                None
-            }
-        })
+        self.variants
+            .iter()
+            .find_map(|(id, name, _)| if *id == variant_id { Some(name.clone()) } else { None })
     }
 
-    // [Adopted from rustc](https://github.com/rust-lang/rust/blob/bd53aa3bf7a24a70d763182303bd75e5fc51a9af/compiler/rustc_middle/src/ty/adt.rs#L446-L448)
     pub fn is_payload_free(&self, db: &dyn DefDatabase) -> bool {
         self.variants.iter().all(|&(v, _, _)| {
             // The condition check order is slightly modified from rustc