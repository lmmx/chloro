COMPARISON DIFF
============================================================

Original size: 33374 bytes
Chloro size:   33300 bytes
Rustfmt size:  33374 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     pub(crate) fn contains_type(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.types.contains(&(module_id, name))
     }
+
     pub(crate) fn contains_value(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.values.contains(&(module_id, name))
     }
+
     pub(crate) fn contains_macro(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.macros.contains(&(module_id, name))
     }
     values: FxIndexMap<Name, ValuesItem>,
     macros: FxIndexMap<Name, MacrosItem>,
     unresolved: FxHashSet<Name>,
-
     /// The defs declared in this scope. Each def has a single scope where it is
     /// declared.
     declarations: ThinVec<ModuleDefId>,
-
     impls: ThinVec<ImplId>,
     extern_blocks: ThinVec<ExternBlockId>,
     unnamed_consts: ThinVec<ConstId>,
     /// Traits imported via `use Trait as _;`.
     unnamed_trait_imports: ThinVec<(TraitId, Item<()>)>,
-
     // the resolutions of the imports of this scope
     use_imports_types: FxHashMap<ImportOrExternCrate, ImportOrDef>,
     use_imports_values: FxHashMap<ImportOrGlob, ImportOrDef>,
     use_imports_macros: FxHashMap<ImportOrExternCrate, ImportOrDef>,
-
     use_decls: ThinVec<UseId>,
     extern_crate_decls: ThinVec<ExternCrateId>,
+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will
+    // be all resolved to the last one defined if shadowing happens.
     /// Macros visible in current module in legacy textual scope
     ///
     /// For macros invoked by an unqualified identifier like `bar!()`, `legacy_macros` will be searched in first.
     /// Note that this automatically inherit macros defined textually before the definition of module itself.
     ///
     /// Module scoped macros will be inserted into `items` instead of here.
-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will
-    // be all resolved to the last one defined if shadowing happens.
     legacy_macros: FxHashMap<Name, SmallVec<[MacroId; 2]>>,
     /// The attribute macro invocations in this scope.
     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,
         self.types.iter().map(|(n, &i)| (n, i))
     }
 
-    pub fn macros(&self) -> impl Iterator<Item = (&Name, Item<MacroId, ImportOrExternCrate>)> + '_ {
+    pub fn macros(
+        &self,
+    ) -> impl Iterator<Item = (&Name, Item<MacroId, ImportOrExternCrate>)> + '_ {
         self.macros.iter().map(|(n, &i)| (n, i))
     }
 
     }
 
     /// XXX: this is O(N) rather than O(1), try to not introduce new usages.
-    pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility, /*declared*/ bool)> {
+    pub(crate) fn name_of(
+        &self,
+        item: ItemInNs,
+    ) -> Option<(&Name, Visibility, /*declared*/ bool)> {
         match item {
             ItemInNs::Macros(def) => self.macros.iter().find_map(|(name, other_def)| {
                 (other_def.def == def).then_some((name, other_def.vis, other_def.import.is_none()))
         self.macro_invocations.get(&call).copied()
     }
 
-    pub fn iter_macro_invoc(&self) -> impl Iterator<Item = (&AstId<ast::MacroCall>, &MacroCallId)> {
+    pub fn iter_macro_invoc(
+        &self,
+    ) -> impl Iterator<Item = (&AstId<ast::MacroCall>, &MacroCallId)> {
         self.macro_invocations.iter()
     }
 }
     ) {
         if let Some(derives) = self.derive_macros.get_mut(&adt)
             && let Some(DeriveMacroInvocation { derive_call_ids, .. }) =
-                derives.iter_mut().find(|&&mut DeriveMacroInvocation { attr_id, .. }| id == attr_id)
-        {
+                derives.iter_mut().find(|&&mut DeriveMacroInvocation { attr_id, .. }| id == attr_id) {
             derive_call_ids[idx] = Some(call);
         }
     }
         let mut changed = false;
 
         // FIXME: Document and simplify this
-
         if let Some(mut fld) = def.types {
             let existing = self.types.entry(lookup.1.clone());
             match existing {
                 "{}:",
                 name.map_or("_".to_owned(), |name| name.display(db, Edition::LATEST).to_string())
             );
-
             if let Some(Item { import, .. }) = def.types {
                 buf.push_str(" t");
                 match import {
             if def.is_none() {
                 buf.push_str(" _");
             }
-
             buf.push('\n');
         }
     }
     }
 }
 
-// These methods are a temporary measure only meant to be used by `DefCollector::push_res_and_update_glob_vis()`.
 impl ItemScope {
     pub(crate) fn update_visibility_types(&mut self, name: &Name, vis: Visibility) {
         let res =