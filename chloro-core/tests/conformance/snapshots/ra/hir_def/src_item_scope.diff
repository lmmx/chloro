COMPARISON DIFF
============================================================

Original size: 33374 bytes
Chloro size:   32565 bytes
Rustfmt size:  33374 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Describes items defined or visible (ie, imported) in a certain scope.
 //! This is shared between modules and blocks.
 
 use std::sync::LazyLock;
 
 use base_db::Crate;
-use hir_expand::{AstId, MacroCallId, attrs::AttrId, db::ExpandDatabase, name::Name};
+use hir_expand::{attrs::AttrId, db::ExpandDatabase, name::Name, AstId, MacroCallId};
 use indexmap::map::Entry;
 use itertools::Itertools;
 use la_arena::Idx;
 use rustc_hash::{FxHashMap, FxHashSet};
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use span::Edition;
 use stdx::format_to;
 use syntax::ast;
 use thin_vec::ThinVec;
 
 use crate::{
-    AdtId, BuiltinType, ConstId, ExternBlockId, ExternCrateId, FxIndexMap, HasModule, ImplId,
-    LocalModuleId, Lookup, MacroId, ModuleDefId, ModuleId, TraitId, UseId,
     db::DefDatabase,
     per_ns::{Item, MacrosItem, PerNs, TypesItem, ValuesItem},
     visibility::Visibility,
+    AdtId, BuiltinType, ConstId, ExternBlockId, ExternCrateId, FxIndexMap, HasModule, ImplId,
+    LocalModuleId, Lookup, MacroId, ModuleDefId, ModuleId, TraitId, UseId,
 };
 
 #[derive(Debug, Default)]
     pub(crate) fn contains_type(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.types.contains(&(module_id, name))
     }
+
     pub(crate) fn contains_value(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.values.contains(&(module_id, name))
     }
+
     pub(crate) fn contains_macro(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.macros.contains(&(module_id, name))
     }
     values: FxIndexMap<Name, ValuesItem>,
     macros: FxIndexMap<Name, MacrosItem>,
     unresolved: FxHashSet<Name>,
-
     /// The defs declared in this scope. Each def has a single scope where it is
     /// declared.
     declarations: ThinVec<ModuleDefId>,
-
     impls: ThinVec<ImplId>,
     extern_blocks: ThinVec<ExternBlockId>,
     unnamed_consts: ThinVec<ConstId>,
     /// Traits imported via `use Trait as _;`.
     unnamed_trait_imports: ThinVec<(TraitId, Item<()>)>,
-
     // the resolutions of the imports of this scope
     use_imports_types: FxHashMap<ImportOrExternCrate, ImportOrDef>,
     use_imports_values: FxHashMap<ImportOrGlob, ImportOrDef>,
     use_imports_macros: FxHashMap<ImportOrExternCrate, ImportOrDef>,
-
     use_decls: ThinVec<UseId>,
     extern_crate_decls: ThinVec<ExternCrateId>,
+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will
+    // be all resolved to the last one defined if shadowing happens.
     /// Macros visible in current module in legacy textual scope
     ///
     /// For macros invoked by an unqualified identifier like `bar!()`, `legacy_macros` will be searched in first.
     /// Note that this automatically inherit macros defined textually before the definition of module itself.
     ///
     /// Module scoped macros will be inserted into `items` instead of here.
-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will
-    // be all resolved to the last one defined if shadowing happens.
     legacy_macros: FxHashMap<Name, SmallVec<[MacroId; 2]>>,
     /// The attribute macro invocations in this scope.
     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,
 impl ItemScope {
     pub fn entries(&self) -> impl Iterator<Item = (&Name, PerNs)> + '_ {
         // FIXME: shadowing
-        self.types
-            .keys()
-            .chain(self.values.keys())
-            .chain(self.macros.keys())
-            .chain(self.unresolved.iter())
-            .sorted()
-            .dedup()
-            .map(move |name| (name, self.get(name)))
+        self.types.keys().chain(self.values.keys()).chain(self.macros.keys()).chain(
+            self.unresolved.iter(),
+        ).sorted(
+        ).dedup(
+        ).map(
+            move |name| (name, self.get(name)),
+        )
     }
 
     pub fn values(&self) -> impl Iterator<Item = (&Name, Item<ModuleDefId, ImportOrGlob>)> + '_ {
         self.types.iter().map(|(n, &i)| (n, i))
     }
 
-    pub fn macros(&self) -> impl Iterator<Item = (&Name, Item<MacroId, ImportOrExternCrate>)> + '_ {
+    pub fn macros(
+        &self,
+    ) -> impl Iterator<Item = (&Name, Item<MacroId, ImportOrExternCrate>)> + '_ {
         self.macros.iter().map(|(n, &i)| (n, i))
     }
 
     pub fn imports(&self) -> impl Iterator<Item = ImportId> + '_ {
-        self.use_imports_types
-            .keys()
-            .copied()
-            .chain(self.use_imports_macros.keys().copied())
-            .filter_map(ImportOrExternCrate::import_or_glob)
-            .chain(self.use_imports_values.keys().copied())
-            .filter_map(ImportOrGlob::into_import)
-            .sorted()
-            .dedup()
+        self.use_imports_types.keys().copied().chain(self.use_imports_macros.keys().copied()).filter_map(
+            ImportOrExternCrate::import_or_glob,
+        ).chain(
+            self.use_imports_values.keys().copied(),
+        ).filter_map(
+            ImportOrGlob::into_import,
+        ).sorted(
+        ).dedup(
+        )
     }
 
     pub fn fully_resolve_import(&self, db: &dyn DefDatabase, mut import: ImportId) -> PerNs {
     }
 
     pub fn all_macro_calls(&self) -> impl Iterator<Item = MacroCallId> + '_ {
-        self.macro_invocations.values().copied().chain(self.attr_macros.values().copied()).chain(
-            self.derive_macros.values().flat_map(|it| {
-                it.iter().flat_map(|it| it.derive_call_ids.iter().copied().flatten())
-            }),
-        )
+        self.macro_invocations.values().copied().chain(self.attr_macros.values().copied()).chain(self.derive_macros.values().flat_map(|it| {
+            it.iter().flat_map(|it| it.derive_call_ids.iter().copied().flatten())
+        }))
     }
 
     pub(crate) fn modules_in_scope(&self) -> impl Iterator<Item = (ModuleId, Visibility)> + '_ {
     }
 
     /// XXX: this is O(N) rather than O(1), try to not introduce new usages.
-    pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility, /*declared*/ bool)> {
+    pub(crate) fn name_of(
+        &self,
+        item: ItemInNs,
+    ) -> Option<(&Name, Visibility, /*declared*/ bool)> {
         match item {
             ItemInNs::Macros(def) => self.macros.iter().find_map(|(name, other_def)| {
                 (other_def.def == def).then_some((name, other_def.vis, other_def.import.is_none()))
         mut cb: impl FnMut(&Name, Visibility, /*declared*/ bool) -> Option<T>,
     ) -> Option<T> {
         match item {
-            ItemInNs::Macros(def) => self
-                .macros
-                .iter()
-                .filter_map(|(name, other_def)| {
-                    (other_def.def == def).then_some((
-                        name,
-                        other_def.vis,
-                        other_def.import.is_none(),
-                    ))
-                })
-                .find_map(|(a, b, c)| cb(a, b, c)),
-            ItemInNs::Types(def) => self
-                .types
-                .iter()
-                .filter_map(|(name, other_def)| {
-                    (other_def.def == def).then_some((
-                        name,
-                        other_def.vis,
-                        other_def.import.is_none(),
-                    ))
-                })
-                .find_map(|(a, b, c)| cb(a, b, c)),
-            ItemInNs::Values(def) => self
-                .values
-                .iter()
-                .filter_map(|(name, other_def)| {
-                    (other_def.def == def).then_some((
-                        name,
-                        other_def.vis,
-                        other_def.import.is_none(),
-                    ))
-                })
-                .find_map(|(a, b, c)| cb(a, b, c)),
+            ItemInNs::Macros(def) => self.macros.iter().filter_map(|(name, other_def)| {
+                (other_def.def == def).then_some((name, other_def.vis, other_def.import.is_none()))
+            }).find_map(
+                |(a, b, c)| cb(a, b, c),
+            ),
+            ItemInNs::Types(def) => self.types.iter().filter_map(|(name, other_def)| {
+                (other_def.def == def).then_some((name, other_def.vis, other_def.import.is_none()))
+            }).find_map(
+                |(a, b, c)| cb(a, b, c),
+            ),
+            ItemInNs::Values(def) => self.values.iter().filter_map(|(name, other_def)| {
+                (other_def.def == def).then_some((name, other_def.vis, other_def.import.is_none()))
+            }).find_map(
+                |(a, b, c)| cb(a, b, c),
+            ),
         }
     }
 
     pub(crate) fn traits(&self) -> impl Iterator<Item = TraitId> + '_ {
-        self.types
-            .values()
-            .filter_map(|def| match def.def {
-                ModuleDefId::TraitId(t) => Some(t),
-                _ => None,
-            })
-            .chain(self.unnamed_trait_imports.iter().map(|&(t, _)| t))
+        self.types.values().filter_map(|def| match def.def {
+            ModuleDefId::TraitId(t) => Some(t),
+            _ => None,
+        }).chain(
+            self.unnamed_trait_imports.iter().map(|&(t, _)| t),
+        )
     }
 
     pub(crate) fn resolutions(&self) -> impl Iterator<Item = (Option<Name>, PerNs)> + '_ {
-        self.entries().map(|(name, res)| (Some(name.clone()), res)).chain(
-            self.unnamed_trait_imports.iter().map(|(tr, trait_)| {
-                (
-                    None,
-                    PerNs::types(
-                        ModuleDefId::TraitId(*tr),
-                        trait_.vis,
-                        trait_.import.map(ImportOrExternCrate::Import),
-                    ),
-                )
-            }),
-        )
+        self.entries().map(|(name, res)| (Some(name.clone()), res)).chain(self.unnamed_trait_imports.iter().map(|(tr, trait_)| {
+            (
+                None,
+                PerNs::types(
+                ModuleDefId::TraitId(*tr),
+                trait_.vis,
+                trait_.import.map(ImportOrExternCrate::Import),
+            ),
+            )
+        }))
     }
 
     pub fn macro_invoc(&self, call: AstId<ast::MacroCall>) -> Option<MacroCallId> {
         self.macro_invocations.get(&call).copied()
     }
 
-    pub fn iter_macro_invoc(&self) -> impl Iterator<Item = (&AstId<ast::MacroCall>, &MacroCallId)> {
+    pub fn iter_macro_invoc(
+        &self,
+    ) -> impl Iterator<Item = (&AstId<ast::MacroCall>, &MacroCallId)> {
         self.macro_invocations.iter()
     }
 }
         id: AttrId,
         idx: usize,
     ) {
-        if let Some(derives) = self.derive_macros.get_mut(&adt)
-            && let Some(DeriveMacroInvocation { derive_call_ids, .. }) =
-                derives.iter_mut().find(|&&mut DeriveMacroInvocation { attr_id, .. }| id == attr_id)
-        {
+        if let Some(derives) = self.derive_macros.get_mut(&adt) && let Some(DeriveMacroInvocation { derive_call_ids, .. }) = derives.iter_mut().find(|&&mut DeriveMacroInvocation { attr_id, .. }| id == attr_id) {
             derive_call_ids[idx] = Some(call);
         }
     }
             (
                 *k,
                 v.iter().map(|DeriveMacroInvocation { attr_id, attr_call_id, derive_call_ids }| {
-                    (*attr_id, *attr_call_id, &**derive_call_ids)
-                }),
+                (*attr_id, *attr_call_id, &**derive_call_ids)
+            }),
             )
         })
     }
         Some(self.derive_macros.get(&ast_id)?.iter().find(|it| it.attr_id == attr_id)?.attr_call_id)
     }
 
-    // FIXME: This is only used in collection, we should move the relevant parts of it out of ItemScope
     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {
         self.unnamed_trait_imports.iter().find(|&&(t, _)| t == tr).map(|(_, trait_)| trait_.vis)
     }
         let mut changed = false;
 
         // FIXME: Document and simplify this
-
         if let Some(mut fld) = def.types {
             let existing = self.types.entry(lookup.1.clone());
             match existing {
                 "{}:",
                 name.map_or("_".to_owned(), |name| name.display(db, Edition::LATEST).to_string())
             );
-
             if let Some(Item { import, .. }) = def.types {
                 buf.push_str(" t");
                 match import {
             if def.is_none() {
                 buf.push_str(" _");
             }
-
             buf.push('\n');
         }
     }
     }
 }
 
-// These methods are a temporary measure only meant to be used by `DefCollector::push_res_and_update_glob_vis()`.
 impl ItemScope {
     pub(crate) fn update_visibility_types(&mut self, name: &Name, vis: Visibility) {
         let res =
             ModuleDefId::ModuleId(_) => PerNs::types(def, v, import),
             ModuleDefId::FunctionId(_) => {
                 PerNs::values(def, v, import.and_then(ImportOrExternCrate::import_or_glob))
-            }
+            },
             ModuleDefId::AdtId(adt) => match adt {
                 AdtId::UnionId(_) => PerNs::types(def, v, import),
                 AdtId::EnumId(_) => PerNs::types(def, v, import),
                     } else {
                         PerNs::types(def, v, import)
                     }
-                }
+                },
             },
             ModuleDefId::EnumVariantId(_) => PerNs::both(def, def, v, import),
             ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => {
                 PerNs::values(def, v, import.and_then(ImportOrExternCrate::import_or_glob))
-            }
+            },
             ModuleDefId::TraitId(_) => PerNs::types(def, v, import),
             ModuleDefId::TypeAliasId(_) => PerNs::types(def, v, import),
             ModuleDefId::BuiltinType(_) => PerNs::types(def, v, import),