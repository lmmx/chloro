COMPARISON DIFF
============================================================

Original size: 33374 bytes
Chloro size:   33310 bytes
Rustfmt size:  34468 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     pub(crate) fn contains_type(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.types.contains(&(module_id, name))
     }
+
     pub(crate) fn contains_value(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.values.contains(&(module_id, name))
     }
+
     pub(crate) fn contains_macro(&self, module_id: LocalModuleId, name: Name) -> bool {
         self.macros.contains(&(module_id, name))
     }
     values: FxIndexMap<Name, ValuesItem>,
     macros: FxIndexMap<Name, MacrosItem>,
     unresolved: FxHashSet<Name>,
-
     /// The defs declared in this scope. Each def has a single scope where it is
     /// declared.
     declarations: ThinVec<ModuleDefId>,
-
     impls: ThinVec<ImplId>,
     extern_blocks: ThinVec<ExternBlockId>,
     unnamed_consts: ThinVec<ConstId>,
     /// Traits imported via `use Trait as _;`.
     unnamed_trait_imports: ThinVec<(TraitId, Item<()>)>,
-
     // the resolutions of the imports of this scope
     use_imports_types: FxHashMap<ImportOrExternCrate, ImportOrDef>,
     use_imports_values: FxHashMap<ImportOrGlob, ImportOrDef>,
     use_imports_macros: FxHashMap<ImportOrExternCrate, ImportOrDef>,
-
     use_decls: ThinVec<UseId>,
     extern_crate_decls: ThinVec<ExternCrateId>,
+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will
+    // be all resolved to the last one defined if shadowing happens.
     /// Macros visible in current module in legacy textual scope
     ///
     /// For macros invoked by an unqualified identifier like `bar!()`, `legacy_macros` will be searched in first.
     /// Note that this automatically inherit macros defined textually before the definition of module itself.
     ///
     /// Module scoped macros will be inserted into `items` instead of here.
-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will
-    // be all resolved to the last one defined if shadowing happens.
     legacy_macros: FxHashMap<Name, SmallVec<[MacroId; 2]>>,
     /// The attribute macro invocations in this scope.
     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,
 pub(crate) static BUILTIN_SCOPE: LazyLock<FxIndexMap<Name, PerNs>> = LazyLock::new(|| {
     BuiltinType::all_builtin_types()
         .iter()
-        .map(|(name, ty)| {
-            (
-                name.clone(),
-                PerNs::types((*ty).into(), Visibility::Public, None),
-            )
-        })
+        .map(|(name, ty)| (name.clone(), PerNs::types((*ty).into(), Visibility::Public, None)))
         .collect()
 });
 
         self.types.iter().map(|(n, &i)| (n, i))
     }
 
-    pub fn macros(&self) -> impl Iterator<Item = (&Name, Item<MacroId, ImportOrExternCrate>)> + '_ {
+    pub fn macros(
+        &self,
+    ) -> impl Iterator<Item = (&Name, Item<MacroId, ImportOrExternCrate>)> + '_ {
         self.macros.iter().map(|(n, &i)| (n, i))
     }
 
 
         let mut def_map;
         let mut scope = self;
-        while let Some(&m) = scope
-            .use_imports_macros
-            .get(&ImportOrExternCrate::Import(import))
-        {
+        while let Some(&m) = scope.use_imports_macros.get(&ImportOrExternCrate::Import(import)) {
             match m {
                 ImportOrDef::Import(i) => {
                     let module_id = i.use_.lookup(db).container;
                     import = i;
                 }
                 ImportOrDef::Def(ModuleDefId::MacroId(def)) => {
-                    res.macros = Some(Item {
-                        def,
-                        vis: Visibility::Public,
-                        import: None,
-                    });
+                    res.macros = Some(Item { def, vis: Visibility::Public, import: None });
                     break;
                 }
                 _ => break,
             }
         }
         let mut scope = self;
-        while let Some(&m) = scope
-            .use_imports_types
-            .get(&ImportOrExternCrate::Import(import))
-        {
+        while let Some(&m) = scope.use_imports_types.get(&ImportOrExternCrate::Import(import)) {
             match m {
                 ImportOrDef::Import(i) => {
                     let module_id = i.use_.lookup(db).container;
                     import = i;
                 }
                 ImportOrDef::Def(def) => {
-                    res.types = Some(Item {
-                        def,
-                        vis: Visibility::Public,
-                        import: None,
-                    });
+                    res.types = Some(Item { def, vis: Visibility::Public, import: None });
                     break;
                 }
                 _ => break,
                     import = i;
                 }
                 ImportOrDef::Def(def) => {
-                    res.values = Some(Item {
-                        def,
-                        vis: Visibility::Public,
-                        import: None,
-                    });
+                    res.values = Some(Item { def, vis: Visibility::Public, import: None });
                     break;
                 }
                 _ => break,
     }
 
     pub fn all_macro_calls(&self) -> impl Iterator<Item = MacroCallId> + '_ {
-        self.macro_invocations
-            .values()
-            .copied()
-            .chain(self.attr_macros.values().copied())
-            .chain(self.derive_macros.values().flat_map(|it| {
-                it.iter()
-                    .flat_map(|it| it.derive_call_ids.iter().copied().flatten())
-            }))
+        self.macro_invocations.values().copied().chain(self.attr_macros.values().copied()).chain(
+            self.derive_macros.values().flat_map(|it| {
+                it.iter().flat_map(|it| it.derive_call_ids.iter().copied().flatten())
+            }),
+        )
     }
 
     pub(crate) fn modules_in_scope(&self) -> impl Iterator<Item = (ModuleId, Visibility)> + '_ {
     }
 
     /// XXX: this is O(N) rather than O(1), try to not introduce new usages.
-    pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility, /*declared*/ bool)> {
+    pub(crate) fn name_of(
+        &self,
+        item: ItemInNs,
+    ) -> Option<(&Name, Visibility, /*declared*/ bool)> {
         match item {
             ItemInNs::Macros(def) => self.macros.iter().find_map(|(name, other_def)| {
                 (other_def.def == def).then_some((name, other_def.vis, other_def.import.is_none()))
     }
 
     pub(crate) fn resolutions(&self) -> impl Iterator<Item = (Option<Name>, PerNs)> + '_ {
-        self.entries()
-            .map(|(name, res)| (Some(name.clone()), res))
-            .chain(self.unnamed_trait_imports.iter().map(|(tr, trait_)| {
+        self.entries().map(|(name, res)| (Some(name.clone()), res)).chain(
+            self.unnamed_trait_imports.iter().map(|(tr, trait_)| {
                 (
                     None,
                     PerNs::types(
                         trait_.import.map(ImportOrExternCrate::Import),
                     ),
                 )
-            }))
+            }),
+        )
     }
 
     pub fn macro_invoc(&self, call: AstId<ast::MacroCall>) -> Option<MacroCallId> {
         self.macro_invocations.get(&call).copied()
     }
 
-    pub fn iter_macro_invoc(&self) -> impl Iterator<Item = (&AstId<ast::MacroCall>, &MacroCallId)> {
+    pub fn iter_macro_invoc(
+        &self,
+    ) -> impl Iterator<Item = (&AstId<ast::MacroCall>, &MacroCallId)> {
         self.macro_invocations.iter()
     }
 }
         idx: usize,
     ) {
         if let Some(derives) = self.derive_macros.get_mut(&adt)
-            && let Some(DeriveMacroInvocation {
-                derive_call_ids, ..
-            }) = derives
-                .iter_mut()
-                .find(|&&mut DeriveMacroInvocation { attr_id, .. }| id == attr_id)
+            && let Some(DeriveMacroInvocation { derive_call_ids, .. }) =
+                derives.iter_mut().find(|&&mut DeriveMacroInvocation { attr_id, .. }| id == attr_id)
         {
             derive_call_ids[idx] = Some(call);
         }
         attr_call_id: MacroCallId,
         len: usize,
     ) {
-        self.derive_macros
-            .entry(adt)
-            .or_default()
-            .push(DeriveMacroInvocation {
-                attr_id,
-                attr_call_id,
-                derive_call_ids: smallvec![None; len],
-            });
+        self.derive_macros.entry(adt).or_default().push(DeriveMacroInvocation {
+            attr_id,
+            attr_call_id,
+            derive_call_ids: smallvec![None; len],
+        });
     }
 
     pub fn derive_macro_invocs(
         self.derive_macros.iter().map(|(k, v)| {
             (
                 *k,
-                v.iter().map(
-                    |DeriveMacroInvocation {
-                         attr_id,
-                         attr_call_id,
-                         derive_call_ids,
-                     }| { (*attr_id, *attr_call_id, &**derive_call_ids) },
-                ),
+                v.iter().map(|DeriveMacroInvocation { attr_id, attr_call_id, derive_call_ids }| {
+                    (*attr_id, *attr_call_id, &**derive_call_ids)
+                }),
             )
         })
     }
         ast_id: AstId<ast::Adt>,
         attr_id: AttrId,
     ) -> Option<MacroCallId> {
-        Some(
-            self.derive_macros
-                .get(&ast_id)?
-                .iter()
-                .find(|it| it.attr_id == attr_id)?
-                .attr_call_id,
-        )
+        Some(self.derive_macros.get(&ast_id)?.iter().find(|it| it.attr_id == attr_id)?.attr_call_id)
     }
 
     // FIXME: This is only used in collection, we should move the relevant parts of it out of ItemScope
     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {
-        self.unnamed_trait_imports
-            .iter()
-            .find(|&&(t, _)| t == tr)
-            .map(|(_, trait_)| trait_.vis)
+        self.unnamed_trait_imports.iter().find(|&&(t, _)| t == tr).map(|(_, trait_)| trait_.vis)
     }
 
     pub(crate) fn push_unnamed_trait(
         vis: Visibility,
         import: Option<ImportId>,
     ) {
-        self.unnamed_trait_imports.push((
-            tr,
-            Item {
-                def: (),
-                vis,
-                import,
-            },
-        ));
+        self.unnamed_trait_imports.push((tr, Item { def: (), vis, import }));
     }
 
     pub(crate) fn push_res_with_import(
         let mut changed = false;
 
         // FIXME: Document and simplify this
-
         if let Some(mut fld) = def.types {
             let existing = self.types.entry(lookup.1.clone());
             match existing {
             .values_mut()
             .map(|def| &mut def.vis)
             .chain(self.values.values_mut().map(|def| &mut def.vis))
-            .chain(
-                self.unnamed_trait_imports
-                    .iter_mut()
-                    .map(|(_, def)| &mut def.vis),
-            )
+            .chain(self.unnamed_trait_imports.iter_mut().map(|(_, def)| &mut def.vis))
             .for_each(|vis| *vis = Visibility::PubCrate(krate));
 
         for mac in self.macros.values_mut() {
             format_to!(
                 buf,
                 "{}:",
-                name.map_or("_".to_owned(), |name| name
-                    .display(db, Edition::LATEST)
-                    .to_string())
+                name.map_or("_".to_owned(), |name| name.display(db, Edition::LATEST).to_string())
             );
 
             if let Some(Item { import, .. }) = def.types {
     }
 }
 
-// These methods are a temporary measure only meant to be used by `DefCollector::push_res_and_update_glob_vis()`.
 impl ItemScope {
     pub(crate) fn update_visibility_types(&mut self, name: &Name, vis: Visibility) {
-        let res = self
-            .types
-            .get_mut(name)
-            .expect("tried to update visibility of non-existent type");
+        let res =
+            self.types.get_mut(name).expect("tried to update visibility of non-existent type");
         res.vis = vis;
     }
 
     pub(crate) fn update_visibility_values(&mut self, name: &Name, vis: Visibility) {
-        let res = self
-            .values
-            .get_mut(name)
-            .expect("tried to update visibility of non-existent value");
+        let res =
+            self.values.get_mut(name).expect("tried to update visibility of non-existent value");
         res.vis = vis;
     }
 
     pub(crate) fn update_visibility_macros(&mut self, name: &Name, vis: Visibility) {
-        let res = self
-            .macros
-            .get_mut(name)
-            .expect("tried to update visibility of non-existent macro");
+        let res =
+            self.macros.get_mut(name).expect("tried to update visibility of non-existent macro");
         res.vis = vis;
     }
 }