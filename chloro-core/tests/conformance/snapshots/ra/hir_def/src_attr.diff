COMPARISON DIFF
============================================================

Original size: 32850 bytes
Chloro size:   32866 bytes
Rustfmt size:  34419 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
                 let krate = loc.container.krate;
                 let source = loc.source(db);
                 (
-                    source
-                        .value
-                        .record_field_list()
-                        .map(ast::FieldList::RecordFieldList),
+                    source.value.record_field_list().map(ast::FieldList::RecordFieldList),
                     source.file_id,
                     krate,
                 )
             ast::FieldList::RecordFieldList(fields) => {
                 let mut idx = 0;
                 for field in fields.fields() {
-                    let attrs = Attrs(RawAttrs::new_expanded(
-                        db,
-                        &field,
-                        span_map.as_ref(),
-                        cfg_options,
-                    ));
+                    let attrs =
+                        Attrs(RawAttrs::new_expanded(db, &field, span_map.as_ref(), cfg_options));
                     if attrs.is_cfg_enabled(cfg_options).is_ok() {
                         res.insert(Idx::from_raw(RawIdx::from(idx)), attrs);
                         idx += 1;
             ast::FieldList::TupleFieldList(fields) => {
                 let mut idx = 0;
                 for field in fields.fields() {
-                    let attrs = Attrs(RawAttrs::new_expanded(
-                        db,
-                        &field,
-                        span_map.as_ref(),
-                        cfg_options,
-                    ));
+                    let attrs =
+                        Attrs(RawAttrs::new_expanded(db, &field, span_map.as_ref(), cfg_options));
                     if attrs.is_cfg_enabled(cfg_options).is_ok() {
                         res.insert(Idx::from_raw(RawIdx::from(idx)), attrs);
                         idx += 1;
 
     #[inline]
     pub fn rust_analyzer_tool(&self) -> impl Iterator<Item = &Attr> {
-        self.iter().filter(|&attr| {
-            attr.path
-                .segments()
-                .first()
-                .is_some_and(|s| *s == sym::rust_analyzer)
-        })
+        self.iter()
+            .filter(|&attr| attr.path.segments().first().is_some_and(|s| *s == sym::rust_analyzer))
     }
 
     #[inline]
     #[inline]
     pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Result<(), CfgExpr> {
         self.cfgs().try_for_each(|cfg| {
-            if cfg_options.check(&cfg) != Some(false) {
-                Ok(())
-            } else {
-                Err(cfg)
-            }
+            if cfg_options.check(&cfg) != Some(false) { Ok(()) } else { Err(cfg) }
         })
     }
 
 
     #[inline]
     pub fn lang_item(&self) -> Option<LangItem> {
-        self.by_key(sym::lang)
-            .string_value()
-            .and_then(LangItem::from_symbol)
+        self.by_key(sym::lang).string_value().and_then(LangItem::from_symbol)
     }
 
     #[inline]
 
     #[inline]
     pub fn doc_aliases(&self) -> impl Iterator<Item = Symbol> + '_ {
-        self.doc_exprs()
-            .flat_map(|doc_expr| doc_expr.aliases().to_vec())
+        self.doc_exprs().flat_map(|doc_expr| doc_expr.aliases().to_vec())
     }
 
     #[inline]
 
     #[inline]
     pub fn repr(&self) -> Option<ReprOptions> {
-        self.by_key(sym::repr)
-            .tt_values()
-            .filter_map(parse_repr_tt)
-            .fold(None, |acc, repr| {
-                acc.map_or(Some(repr), |mut acc| {
-                    merge_repr(&mut acc, repr);
-                    Some(acc)
-                })
+        self.by_key(sym::repr).tt_values().filter_map(parse_repr_tt).fold(None, |acc, repr| {
+            acc.map_or(Some(repr), |mut acc| {
+                merge_repr(&mut acc, repr);
+                Some(acc)
             })
+        })
     }
 }
 
 }
 
 fn merge_repr(this: &mut ReprOptions, other: ReprOptions) {
-    let ReprOptions {
-        int,
-        align,
-        pack,
-        flags,
-        field_shuffle_seed: _,
-    } = this;
+    let ReprOptions { int, align, pack, flags, field_shuffle_seed: _ } = this;
     flags.insert(other.flags);
     *align = (*align).max(other.align);
     *pack = match (*pack, other.pack) {
     use rustc_abi::{Align, Integer, IntegerType, ReprFlags, ReprOptions};
 
     match tt.top_subtree().delimiter {
-        tt::Delimiter {
-            kind: DelimiterKind::Parenthesis,
-            ..
-        } => {}
+        tt::Delimiter { kind: DelimiterKind::Parenthesis, .. } => {}
         _ => return None,
     }
 
                     0
                 };
                 let pack = Some(Align::from_bytes(pack).unwrap_or(Align::ONE));
-                ReprOptions {
-                    pack,
-                    ..Default::default()
-                }
+                ReprOptions { pack, ..Default::default() }
             }
             s if *s == sym::align => {
                 let mut align = None;
                         align = Align::from_bytes(a).ok();
                     }
                 }
-                ReprOptions {
-                    align,
-                    ..Default::default()
-                }
+                ReprOptions { align, ..Default::default() }
             }
-            s if *s == sym::C => ReprOptions {
-                flags: ReprFlags::IS_C,
-                ..Default::default()
-            },
-            s if *s == sym::transparent => ReprOptions {
-                flags: ReprFlags::IS_TRANSPARENT,
-                ..Default::default()
-            },
-            s if *s == sym::simd => ReprOptions {
-                flags: ReprFlags::IS_SIMD,
-                ..Default::default()
-            },
+            s if *s == sym::C => ReprOptions { flags: ReprFlags::IS_C, ..Default::default() },
+            s if *s == sym::transparent => {
+                ReprOptions { flags: ReprFlags::IS_TRANSPARENT, ..Default::default() }
+            }
+            s if *s == sym::simd => ReprOptions { flags: ReprFlags::IS_SIMD, ..Default::default() },
             repr => {
                 let mut int = None;
                 if let Some(builtin) = BuiltinInt::from_suffix_sym(repr)
                         },
                     });
                 }
-                ReprOptions {
-                    int,
-                    ..Default::default()
-                }
+                ReprOptions { int, ..Default::default() }
             }
         };
         merge_repr(&mut acc, repr);
     ///
     /// Note that a key can have multiple values that are all considered "active" at the same time.
     /// For example, `#[doc(alias = "x")]` and `#[doc(alias = "y")]`.
-    KeyValue { key: Symbol, value: Symbol },
+    KeyValue {
+        key: Symbol,
+        value: Symbol,
+    },
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
                     symbol: text,
                     kind: tt::LitKind::Str,
                     ..
-                }))) => DocAtom::KeyValue {
-                    key: name,
-                    value: text.clone(),
-                }
-                .into(),
+                }))) => DocAtom::KeyValue { key: name, value: text.clone() }.into(),
                 _ => return Some(DocExpr::Invalid),
             }
         }
 fn parse_comma_sep<S>(iter: TtIter<'_, S>) -> Vec<Symbol> {
     iter.filter_map(|tt| match tt {
         TtElement::Leaf(tt::Leaf::Literal(tt::Literal {
-            kind: tt::LitKind::Str,
-            symbol,
-            ..
+            kind: tt::LitKind::Str, symbol, ..
         })) => Some(symbol.clone()),
         _ => None,
     })
 
 impl AttrsWithOwner {
     pub fn new(db: &dyn DefDatabase, owner: AttrDefId) -> Self {
-        Self {
-            attrs: db.attrs(owner),
-            owner,
-        }
+        Self { attrs: db.attrs(owner), owner }
     }
 
     pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {
                 let mod_data = &def_map[module.local_id];
 
                 let raw_attrs = match mod_data.origin {
-                    ModuleOrigin::File {
-                        definition,
-                        declaration_tree_id,
-                        declaration,
-                        ..
-                    } => {
+                    ModuleOrigin::File { definition, declaration_tree_id, declaration, .. } => {
                         let decl_attrs = declaration_tree_id
                             .item_tree(db)
                             .raw_attrs(declaration.upcast())
                         let tree = db.file_item_tree(definition.into());
                         tree.top_level_raw_attrs().clone()
                     }
-                    ModuleOrigin::Inline {
-                        definition_tree_id,
-                        definition,
-                    } => definition_tree_id
-                        .item_tree(db)
-                        .raw_attrs(definition.upcast())
-                        .clone(),
+                    ModuleOrigin::Inline { definition_tree_id, definition } => {
+                        definition_tree_id.item_tree(db).raw_attrs(definition.upcast()).clone()
+                    }
                     ModuleOrigin::BlockExpr { id, .. } => {
                         let tree = block_item_tree_query(db, id);
                         tree.top_level_raw_attrs().clone()
                 match mod_data.declaration_source(db) {
                     Some(it) => {
                         let mut map = AttrSourceMap::new(InFile::new(it.file_id, &it.value));
-                        if let InFile {
-                            file_id,
-                            value: ModuleSource::SourceFile(file),
-                        } = mod_data.definition_source(db)
+                        if let InFile { file_id, value: ModuleSource::SourceFile(file) } =
+                            mod_data.definition_source(db)
                         {
                             map.append_module_inline_attrs(AttrSourceMap::new(InFile::new(
                                 file_id, &file,
     #[inline]
     pub fn attrs(self) -> impl Iterator<Item = &'attr Attr> + Clone {
         let key = self.key;
-        self.attrs
-            .iter()
-            .filter(move |attr| attr.path.as_ident().is_some_and(|s| *s == key))
+        self.attrs.iter().filter(move |attr| attr.path.as_ident().is_some_and(|s| *s == key))
     }
 
     /// Find string value for a specific key inside token tree
     let source = loc.source(db);
     let span_map = db.span_map(source.file_id);
     let cfg_options = loc.krate(db).cfg_options(db);
-    Attrs(RawAttrs::new_expanded(
-        db,
-        &source.value,
-        span_map.as_ref(),
-        cfg_options,
-    ))
+    Attrs(RawAttrs::new_expanded(db, &source.value, span_map.as_ref(), cfg_options))
 }
 
 pub(crate) fn fields_attrs_source_map(
     for (idx, variant) in child_source.value.iter() {
         res.insert(
             idx,
-            variant.as_ref().either(
-                |l| AstPtr::new(l).wrap_left(),
-                |r| AstPtr::new(r).wrap_right(),
-            ),
+            variant
+                .as_ref()
+                .either(|l| AstPtr::new(l).wrap_left(), |r| AstPtr::new(r).wrap_right()),
         );
     }
 
 mod tests {
     //! This module contains tests for doc-expression parsing.
     //! Currently, it tests `#[doc(hidden)]` and `#[doc(alias)]`.
-
     use intern::Symbol;
     use span::EditionedFileId;
     use triomphe::Arc;
-
     use hir_expand::span_map::{RealSpanMap, SpanMap};
     use span::FileId;
     use syntax::{AstNode, TextRange, ast};
     use syntax_bridge::{DocCommentDesugarMode, syntax_node_to_token_tree};
-
     use crate::attr::{DocAtom, DocExpr};
-
     fn assert_parse_result(input: &str, expected: DocExpr) {
-        let source_file = ast::SourceFile::parse(input, span::Edition::CURRENT)
-            .ok()
-            .unwrap();
-        let tt = source_file
-            .syntax()
-            .descendants()
-            .find_map(ast::TokenTree::cast)
-            .unwrap();
+        let source_file = ast::SourceFile::parse(input, span::Edition::CURRENT).ok().unwrap();
+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();
         let map = SpanMap::RealSpanMap(Arc::new(RealSpanMap::absolute(
             EditionedFileId::current_edition(FileId::from_raw(0)),
         )));
         let cfg = DocExpr::parse(&tt);
         assert_eq!(cfg, expected);
     }
-
     #[test]
     fn test_doc_expr_parser() {
-        assert_parse_result(
-            "#![doc(hidden)]",
-            DocAtom::Flag(Symbol::intern("hidden")).into(),
-        );
+        assert_parse_result("#![doc(hidden)]", DocAtom::Flag(Symbol::intern("hidden")).into());
 
         assert_parse_result(
             r#"#![doc(alias = "foo")]"#,
-            DocAtom::KeyValue {
-                key: Symbol::intern("alias"),
-                value: Symbol::intern("foo"),
-            }
-            .into(),
+            DocAtom::KeyValue { key: Symbol::intern("alias"), value: Symbol::intern("foo") }.into(),
         );
 
         assert_parse_result(
         assert_parse_result(
             r#"#![doc(alias("foo", "bar", "baz"))]"#,
             DocExpr::Alias(
-                [
-                    Symbol::intern("foo"),
-                    Symbol::intern("bar"),
-                    Symbol::intern("baz"),
-                ]
-                .into(),
+                [Symbol::intern("foo"), Symbol::intern("bar"), Symbol::intern("baz")].into(),
             ),
         );
 