COMPARISON DIFF
============================================================

Original size: 32850 bytes
Chloro size:   32866 bytes
Rustfmt size:  32850 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     ///
     /// Note that a key can have multiple values that are all considered "active" at the same time.
     /// For example, `#[doc(alias = "x")]` and `#[doc(alias = "y")]`.
-    KeyValue { key: Symbol, value: Symbol },
+    KeyValue {
+        key: Symbol,
+        value: Symbol,
+    },
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
     };
 
     // Peek
+
     let ret = match it.peek() {
         Some(TtElement::Leaf(tt::Leaf::Punct(punct))) if punct.char == '=' => {
             it.next();
             AttrDefId::ModuleId(module) => {
                 let def_map = module.def_map(db);
                 let mod_data = &def_map[module.local_id];
-
                 let raw_attrs = match mod_data.origin {
                     ModuleOrigin::File { definition, declaration_tree_id, declaration, .. } => {
                         let decl_attrs = declaration_tree_id
             AttrDefId::TypeAliasId(it) => attrs_from_ast_id_loc(db, it),
             AttrDefId::GenericParamId(it) => match it {
                 GenericParamId::ConstParamId(it) => {
-                    let src = it.parent().child_source(db);
                     // FIXME: We should be never getting `None` here.
+                    let src = it.parent().child_source(db);
                     Attrs(match src.value.get(it.local_id()) {
                         Some(val) => RawAttrs::new_expanded(
                             db,
                     })
                 }
                 GenericParamId::TypeParamId(it) => {
-                    let src = it.parent().child_source(db);
                     // FIXME: We should be never getting `None` here.
+                    let src = it.parent().child_source(db);
                     Attrs(match src.value.get(it.local_id()) {
                         Some(val) => RawAttrs::new_expanded(
                             db,
                     })
                 }
                 GenericParamId::LifetimeParamId(it) => {
-                    let src = it.parent.child_source(db);
                     // FIXME: We should be never getting `None` here.
+                    let src = it.parent.child_source(db);
                     Attrs(match src.value.get(it.local_id) {
                         Some(val) => RawAttrs::new_expanded(
                             db,
 mod tests {
     //! This module contains tests for doc-expression parsing.
     //! Currently, it tests `#[doc(hidden)]` and `#[doc(alias)]`.
-
     use intern::Symbol;
     use span::EditionedFileId;
     use triomphe::Arc;
-
     use hir_expand::span_map::{RealSpanMap, SpanMap};
     use span::FileId;
     use syntax::{AstNode, TextRange, ast};
     use syntax_bridge::{DocCommentDesugarMode, syntax_node_to_token_tree};
-
     use crate::attr::{DocAtom, DocExpr};
-
     fn assert_parse_result(input: &str, expected: DocExpr) {
         let source_file = ast::SourceFile::parse(input, span::Edition::CURRENT).ok().unwrap();
         let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();
         let cfg = DocExpr::parse(&tt);
         assert_eq!(cfg, expected);
     }
-
     #[test]
     fn test_doc_expr_parser() {
         assert_parse_result("#![doc(hidden)]", DocAtom::Flag(Symbol::intern("hidden")).into());