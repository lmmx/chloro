COMPARISON DIFF
============================================================

Original size: 32850 bytes
Chloro size:   32707 bytes
Rustfmt size:  32850 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use cfg::{CfgExpr, CfgOptions};
 use either::Either;
 use hir_expand::{
-    HirFileId, InFile,
-    attrs::{Attr, AttrId, RawAttrs, collect_attrs},
+    attrs::{collect_attrs, Attr, AttrId, RawAttrs},
     span_map::SpanMapRef,
+    HirFileId, InFile,
 };
-use intern::{Symbol, sym};
+use intern::{sym, Symbol};
 use la_arena::{ArenaMap, Idx, RawIdx};
 use mbe::DelimiterKind;
 use rustc_abi::ReprOptions;
 use span::AstIdNode;
 use syntax::{
-    AstPtr,
     ast::{self, HasAttrs},
+    AstPtr,
 };
 use triomphe::Arc;
 use tt::iter::{TtElement, TtIter};
 
 use crate::{
-    AdtId, AstIdLoc, AttrDefId, GenericParamId, HasModule, LocalFieldId, Lookup, MacroId,
-    VariantId,
     db::DefDatabase,
     item_tree::block_item_tree_query,
     lang_item::LangItem,
     nameres::{ModuleOrigin, ModuleSource},
     src::{HasChildSource, HasSource},
+    AdtId, AstIdLoc, AttrDefId, GenericParamId, HasModule, LocalFieldId, Lookup, MacroId,
+    VariantId,
 };
 
 /// Desugared attributes of an item post `cfg_attr` expansion.
         span_map: SpanMapRef<'_>,
         cfg_options: &CfgOptions,
     ) -> Result<(), CfgExpr> {
-        RawAttrs::attrs_iter_expanded::<false>(db, owner, span_map, cfg_options)
-            .filter_map(|attr| attr.cfg())
-            .find_map(|cfg| match cfg_options.check(&cfg).is_none_or(identity) {
+        RawAttrs::attrs_iter_expanded::<false>(db, owner, span_map, cfg_options).filter_map(
+            |attr| attr.cfg(),
+        ).find_map(|cfg| match cfg_options.check(&cfg).is_none_or(identity) {
                 true => None,
                 false => Some(cfg),
-            })
-            .map_or(Ok(()), Err)
+            }).map_or(
+            Ok(()),
+            Err,
+        )
     }
 }
 
 
     #[inline]
     pub fn rust_analyzer_tool(&self) -> impl Iterator<Item = &Attr> {
-        self.iter()
-            .filter(|&attr| attr.path.segments().first().is_some_and(|s| *s == sym::rust_analyzer))
+        self.iter().filter(
+            |&attr| attr.path.segments().first().is_some_and(|s| *s == sym::rust_analyzer),
+        )
     }
 
     #[inline]
 
     #[inline]
     pub fn rustc_legacy_const_generics(&self) -> Option<Box<Box<[u32]>>> {
-        self.by_key(sym::rustc_legacy_const_generics)
-            .tt_values()
-            .next()
-            .map(parse_rustc_legacy_const_generics)
-            .filter(|it| !it.is_empty())
-            .map(Box::new)
+        self.by_key(sym::rustc_legacy_const_generics).tt_values().next().map(
+            parse_rustc_legacy_const_generics,
+        ).filter(
+            |it| !it.is_empty(),
+        ).map(
+            Box::new,
+        )
     }
 
     #[inline]
     pub fn repr(&self) -> Option<ReprOptions> {
-        self.by_key(sym::repr).tt_values().filter_map(parse_repr_tt).fold(None, |acc, repr| {
+        self.by_key(sym::repr).tt_values().filter_map(parse_repr_tt).fold(
+            None,
+            |acc, repr| {
             acc.map_or(Some(repr), |mut acc| {
                 merge_repr(&mut acc, repr);
                 Some(acc)
             })
-        })
+        },
+        )
     }
 }
 
     ///
     /// Note that a key can have multiple values that are all considered "active" at the same time.
     /// For example, `#[doc(alias = "x")]` and `#[doc(alias = "y")]`.
-    KeyValue { key: Symbol, value: Symbol },
+    KeyValue {
+        key: Symbol,
+        value: Symbol,
+    },
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
             kind: tt::LitKind::Str, symbol, ..
         })) => Some(symbol.clone()),
         _ => None,
-    })
-    .collect()
+    }).collect(
+    )
 }
 
 impl AttrsWithOwner {
             AttrDefId::ModuleId(module) => {
                 let def_map = module.def_map(db);
                 let mod_data = &def_map[module.local_id];
-
                 let raw_attrs = match mod_data.origin {
                     ModuleOrigin::File { definition, declaration_tree_id, declaration, .. } => {
                         let decl_attrs = declaration_tree_id
             AttrDefId::GenericParamId(it) => match it {
                 GenericParamId::ConstParamId(it) => {
                     let src = it.parent().child_source(db);
-                    // FIXME: We should be never getting `None` here.
                     Attrs(match src.value.get(it.local_id()) {
                         Some(val) => RawAttrs::new_expanded(
                             db,
                 }
                 GenericParamId::TypeParamId(it) => {
                     let src = it.parent().child_source(db);
-                    // FIXME: We should be never getting `None` here.
                     Attrs(match src.value.get(it.local_id()) {
                         Some(val) => RawAttrs::new_expanded(
                             db,
                 }
                 GenericParamId::LifetimeParamId(it) => {
                     let src = it.parent.child_source(db);
-                    // FIXME: We should be never getting `None` here.
                     Attrs(match src.value.get(it.local_id) {
                         Some(val) => RawAttrs::new_expanded(
                             db,
             _ => self.file_id,
         };
 
-        self.source
-            .get(ast_idx)
-            .map(|it| InFile::new(file_id, it))
-            .unwrap_or_else(|| panic!("cannot find attr at index {id:?}"))
+        self.source.get(ast_idx).map(|it| InFile::new(file_id, it)).unwrap_or_else(
+            || panic!("cannot find attr at index {id:?}"),
+        )
     }
 }
 
 mod tests {
     //! This module contains tests for doc-expression parsing.
     //! Currently, it tests `#[doc(hidden)]` and `#[doc(alias)]`.
-
     use intern::Symbol;
     use span::EditionedFileId;
     use triomphe::Arc;
-
     use hir_expand::span_map::{RealSpanMap, SpanMap};
     use span::FileId;
-    use syntax::{AstNode, TextRange, ast};
-    use syntax_bridge::{DocCommentDesugarMode, syntax_node_to_token_tree};
-
+    use syntax::{ast, AstNode, TextRange};
+    use syntax_bridge::{syntax_node_to_token_tree, DocCommentDesugarMode};
     use crate::attr::{DocAtom, DocExpr};
-
     fn assert_parse_result(input: &str, expected: DocExpr) {
         let source_file = ast::SourceFile::parse(input, span::Edition::CURRENT).ok().unwrap();
         let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();
         let cfg = DocExpr::parse(&tt);
         assert_eq!(cfg, expected);
     }
-
     #[test]
     fn test_doc_expr_parser() {
         assert_parse_result("#![doc(hidden)]", DocAtom::Flag(Symbol::intern("hidden")).into());