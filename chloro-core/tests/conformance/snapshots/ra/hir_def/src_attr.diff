COMPARISON DIFF
============================================================

Original size: 32850 bytes
Chloro size:   33091 bytes
Rustfmt size:  32850 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use cfg::{CfgExpr, CfgOptions};
 use either::Either;
 use hir_expand::{
-    HirFileId, InFile,
-    attrs::{Attr, AttrId, RawAttrs, collect_attrs},
-    span_map::SpanMapRef,
+    attrs::{Attr, AttrId, RawAttrs, collect_attrs}, span_map::SpanMapRef, HirFileId, InFile,
 };
 use intern::{Symbol, sym};
 use la_arena::{ArenaMap, Idx, RawIdx};
 use tt::iter::{TtElement, TtIter};
 
 use crate::{
-    AdtId, AstIdLoc, AttrDefId, GenericParamId, HasModule, LocalFieldId, Lookup, MacroId,
-    VariantId,
-    db::DefDatabase,
-    item_tree::block_item_tree_query,
-    lang_item::LangItem,
-    nameres::{ModuleOrigin, ModuleSource},
-    src::{HasChildSource, HasSource},
+    db::DefDatabase, item_tree::block_item_tree_query, lang_item::LangItem,
+    nameres::{ModuleOrigin, ModuleSource}, src::{HasChildSource, HasSource}, AdtId, AstIdLoc,
+    AttrDefId, GenericParamId, HasModule, LocalFieldId, Lookup, MacroId, VariantId,
 };
 
 /// Desugared attributes of an item post `cfg_attr` expansion.
         Attrs(RawAttrs::new_expanded(db, owner, span_map, cfg_options))
     }
 
-    pub fn get(&self, id: AttrId) -> Option<&Attr> {
+    pub fn get(
+        &self,
+        id: AttrId,
+    ) -> Option<&Attr> {
         (**self).iter().find(|attr| attr.id == id)
     }
 
         let Some(fields) = fields else {
             return Arc::new(res);
         };
-
         let cfg_options = krate.cfg_options(db);
         let span_map = db.span_map(file_id);
-
         match fields {
             ast::FieldList::RecordFieldList(fields) => {
                 let mut idx = 0;
                 }
             }
         }
-
         res.shrink_to_fit();
         Arc::new(res)
     }
 
 impl Attrs {
     #[inline]
-    pub fn by_key(&self, key: Symbol) -> AttrQuery<'_> {
+    pub fn by_key(
+        &self,
+        key: Symbol,
+    ) -> AttrQuery<'_> {
         AttrQuery { attrs: self, key }
     }
 
     }
 
     #[inline]
-    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Result<(), CfgExpr> {
+    pub(crate) fn is_cfg_enabled(
+        &self,
+        cfg_options: &CfgOptions,
+    ) -> Result<(), CfgExpr> {
         self.cfgs().try_for_each(|cfg| {
             if cfg_options.check(&cfg) != Some(false) { Ok(()) } else { Err(cfg) }
         })
             }
         }
     }
-
     indices.into_boxed_slice()
 }
 
-fn merge_repr(this: &mut ReprOptions, other: ReprOptions) {
+fn merge_repr(
+    this: &mut ReprOptions,
+    other: ReprOptions,
+) {
     let ReprOptions { int, align, pack, flags, field_shuffle_seed: _ } = this;
     flags.insert(other.flags);
     *align = (*align).max(other.align);
 fn parse_repr_tt(tt: &crate::tt::TopSubtree) -> Option<ReprOptions> {
     use crate::builtin_type::{BuiltinInt, BuiltinUint};
     use rustc_abi::{Align, Integer, IntegerType, ReprFlags, ReprOptions};
-
     match tt.top_subtree().delimiter {
         tt::Delimiter { kind: DelimiterKind::Parenthesis, .. } => {}
         _ => return None,
     }
-
     let mut acc = ReprOptions::default();
     let mut tts = tt.iter();
     while let Some(tt) = tts.next() {
         };
         merge_repr(&mut acc, repr);
     }
-
     Some(acc)
 }
 
     ///
     /// Note that a key can have multiple values that are all considered "active" at the same time.
     /// For example, `#[doc(alias = "x")]` and `#[doc(alias = "y")]`.
-    KeyValue { key: Symbol, value: Symbol },
+    KeyValue {
+        key: Symbol,
+        value: Symbol,
+    },
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
         Some(TtElement::Leaf(tt::Leaf::Ident(ident))) => ident.sym.clone(),
         Some(_) => return Some(DocExpr::Invalid),
     };
-
     // Peek
     let ret = match it.peek() {
         Some(TtElement::Leaf(tt::Leaf::Punct(punct))) if punct.char == '=' => {
 }
 
 impl AttrsWithOwner {
-    pub fn new(db: &dyn DefDatabase, owner: AttrDefId) -> Self {
+    pub fn new(
+        db: &dyn DefDatabase,
+        owner: AttrDefId,
+    ) -> Self {
         Self { attrs: db.attrs(owner), owner }
     }
 
-    pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {
+    pub(crate) fn attrs_query(
+        db: &dyn DefDatabase,
+        def: AttrDefId,
+    ) -> Attrs {
         let _p = tracing::info_span!("attrs_query").entered();
         // FIXME: this should use `Trace` to avoid duplication in `source_map` below
         match def {
         }
     }
 
-    pub fn source_map(&self, db: &dyn DefDatabase) -> AttrSourceMap {
+    pub fn source_map(
+        &self,
+        db: &dyn DefDatabase,
+    ) -> AttrSourceMap {
         let owner = match self.owner {
             AttrDefId::ModuleId(module) => {
                 // Modules can have 2 attribute owners (the `mod x;` item, and the module file itself).
             AttrDefId::ExternCrateId(id) => any_has_attrs(db, id),
             AttrDefId::UseId(id) => any_has_attrs(db, id),
         };
-
         AttrSourceMap::new(owner.as_ref().map(|node| node as &dyn HasAttrs))
     }
 }
 
     /// Append a second source map to this one, this is required for modules, whose outline and inline
     /// attributes can reside in different files
-    fn append_module_inline_attrs(&mut self, other: Self) {
+    fn append_module_inline_attrs(
+        &mut self,
+        other: Self,
+    ) {
         assert!(self.mod_def_site_file_id.is_none() && other.mod_def_site_file_id.is_none());
         let len = self.source.len();
         self.source.extend(other.source);
     ///
     /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of
     /// the attribute represented by `Attr`.
-    pub fn source_of(&self, attr: &Attr) -> InFile<&Either<ast::Attr, ast::Comment>> {
+    pub fn source_of(
+        &self,
+        attr: &Attr,
+    ) -> InFile<&Either<ast::Attr, ast::Comment>> {
         self.source_of_id(attr.id)
     }
 
-    pub fn source_of_id(&self, id: AttrId) -> InFile<&Either<ast::Attr, ast::Comment>> {
+    pub fn source_of_id(
+        &self,
+        id: AttrId,
+    ) -> InFile<&Either<ast::Attr, ast::Comment>> {
         let ast_idx = id.ast_index();
         let file_id = match self.mod_def_site_file_id {
             Some((file_id, def_site_cut)) if def_site_cut <= ast_idx => file_id,
             _ => self.file_id,
         };
-
         self.source
             .get(ast_idx)
             .map(|it| InFile::new(file_id, it))
     ///       ^^^^^^^^^^^^^ key
     /// ```
     #[inline]
-    pub fn find_string_value_in_tt(self, key: Symbol) -> Option<&'attr str> {
+    pub fn find_string_value_in_tt(
+        self,
+        key: Symbol,
+    ) -> Option<&'attr str> {
         self.tt_values().find_map(|tt| {
             let name = tt.iter()
                 .skip_while(|tt| !matches!(tt, TtElement::Leaf(tt::Leaf::Ident(tt::Ident { sym, ..} )) if *sym == key))
 ) -> Arc<ArenaMap<LocalFieldId, AstPtr<Either<ast::TupleField, ast::RecordField>>>> {
     let mut res = ArenaMap::default();
     let child_source = def.child_source(db);
-
     for (idx, variant) in child_source.value.iter() {
         res.insert(
             idx,
                 .either(|l| AstPtr::new(l).wrap_left(), |r| AstPtr::new(r).wrap_right()),
         );
     }
-
     Arc::new(res)
 }
 
 mod tests {
     //! This module contains tests for doc-expression parsing.
     //! Currently, it tests `#[doc(hidden)]` and `#[doc(alias)]`.
-
     use intern::Symbol;
     use span::EditionedFileId;
     use triomphe::Arc;
-
     use hir_expand::span_map::{RealSpanMap, SpanMap};
     use span::FileId;
     use syntax::{AstNode, TextRange, ast};
     use syntax_bridge::{DocCommentDesugarMode, syntax_node_to_token_tree};
-
     use crate::attr::{DocAtom, DocExpr};
-
-    fn assert_parse_result(input: &str, expected: DocExpr) {
+    fn assert_parse_result(
+        input: &str,
+        expected: DocExpr,
+    ) {
         let source_file = ast::SourceFile::parse(input, span::Edition::CURRENT).ok().unwrap();
         let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();
         let map = SpanMap::RealSpanMap(Arc::new(RealSpanMap::absolute(
         let cfg = DocExpr::parse(&tt);
         assert_eq!(cfg, expected);
     }
-
     #[test]
     fn test_doc_expr_parser() {
         assert_parse_result("#![doc(hidden)]", DocAtom::Flag(Symbol::intern("hidden")).into());
-
         assert_parse_result(
             r#"#![doc(alias = "foo")]"#,
             DocAtom::KeyValue { key: Symbol::intern("alias"), value: Symbol::intern("foo") }.into(),
         );
-
         assert_parse_result(
             r#"#![doc(alias("foo"))]"#,
             DocExpr::Alias([Symbol::intern("foo")].into()),
                 [Symbol::intern("foo"), Symbol::intern("bar"), Symbol::intern("baz")].into(),
             ),
         );
-
         assert_parse_result(
             r#"
         #[doc(alias("Bar", "Qux"))]