COMPARISON DIFF
============================================================

Original size: 62212 bytes
Chloro size:   62243 bytes
Rustfmt size:  63726 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
     // - if the item is a builtin, it's in scope
     if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {
-        return Some(ModPath::from_segments(
-            PathKind::Plain,
-            iter::once(builtin.as_name()),
-        ));
+        return Some(ModPath::from_segments(PathKind::Plain, iter::once(builtin.as_name())));
     }
 
     // within block modules, forcing a `self` or `crate` prefix will not allow using inner items, so
 use Stability::*;
 
 const MAX_PATH_LEN: usize = 15;
+
 const FIND_PATH_FUEL: usize = 10000;
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
     };
     if may_be_in_scope {
         // - if the item is already in scope, return the name under which it is
-        let scope_name = find_in_scope(
-            ctx.db,
-            ctx.from_def_map,
-            ctx.from,
-            item,
-            ctx.ignore_local_imports,
-        );
+        let scope_name =
+            find_in_scope(ctx.db, ctx.from_def_map, ctx.from, item, ctx.ignore_local_imports);
         if let Some(scope_name) = scope_name {
-            return Some(ModPath::from_segments(
-                ctx.prefix.path_kind(),
-                iter::once(scope_name),
-            ));
+            return Some(ModPath::from_segments(ctx.prefix.path_kind(), iter::once(scope_name)));
         }
     }
 
         let loc = variant.lookup(ctx.db);
         if let Some(mut path) = find_path_inner(ctx, ItemInNs::Types(loc.parent.into()), max_len) {
             path.push_segment(
-                loc.parent.enum_variants(ctx.db).variants[loc.index as usize]
-                    .1
-                    .clone(),
+                loc.parent.enum_variants(ctx.db).variants[loc.index as usize].1.clone(),
             );
             return Some(path);
         }
     }
 
     let mut best_choice = None;
-    calculate_best_path(
-        ctx,
-        &mut FxHashSet::default(),
-        item,
-        max_len,
-        &mut best_choice,
-    );
+    calculate_best_path(ctx, &mut FxHashSet::default(), item, max_len, &mut best_choice);
     best_choice.map(|choice| choice.path)
 }
 
             } else {
                 PathKind::Plain
             };
-            return Some(Choice::new(
-                ctx.cfg.prefer_prelude,
-                kind,
-                name.clone(),
-                Stable,
-            ));
+            return Some(Choice::new(ctx.cfg.prefer_prelude, kind, name.clone(), Stable));
         }
     }
 
     ignore_local_imports: bool,
 ) -> Option<Name> {
     // FIXME: We could have multiple applicable names here, but we currently only return the first
-    def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {
+    def_map.with_ancestor_maps(
+        db,
+        from.local_id,
+        &mut |def_map, local_id| {
         def_map[local_id].scope.names_of(item, |name, _, declared| {
             (declared || !ignore_local_imports).then(|| name.clone())
         })
-    })
+    },
+    )
 }
 
 /// Returns single-segment path (i.e. without any prefix) if `item` is found in prelude and its
         // Item was defined in some upstream crate. This means that it must be exported from one,
         // too (unless we can't name it at all). It could *also* be (re)exported by the same crate
         // that wants to import it here, but we always prefer to use the external path here.
-
-        ctx.from
-            .krate
-            .data(ctx.db)
-            .dependencies
-            .iter()
-            .for_each(|dep| {
-                find_in_dep(
-                    ctx,
-                    visited_modules,
-                    item,
-                    max_len,
-                    best_choice,
-                    dep.crate_id,
-                )
-            });
+        ctx.from.krate.data(ctx.db).dependencies.iter().for_each(|dep| {
+            find_in_dep(ctx, visited_modules, item, max_len, best_choice, dep.crate_id)
+        });
     }
 }
 
 ) {
     let dependencies = &ctx.from.krate.data(ctx.db).dependencies;
     let mut search = |lang, best_choice: &mut _| {
-        if let Some(dep) = dependencies
-            .iter()
-            .filter(|it| it.is_sysroot())
-            .find(|dep| match dep.crate_id.data(ctx.db).origin {
+        if let Some(dep) = dependencies.iter().filter(|it| it.is_sysroot()).find(|dep| {
+            match dep.crate_id.data(ctx.db).origin {
                 CrateOrigin::Lang(l) => l == lang,
                 _ => false,
-            })
-        {
-            find_in_dep(
-                ctx,
-                visited_modules,
-                item,
-                max_len,
-                best_choice,
-                dep.crate_id,
-            );
+            }
+        }) {
+            find_in_dep(ctx, visited_modules, item, max_len, best_choice, dep.crate_id);
         }
     };
     if ctx.cfg.prefer_no_std {
         search(LangCrateOrigin::Core, best_choice);
-        if matches!(
-            best_choice,
-            Some(Choice {
-                stability: Stable,
-                ..
-            })
-        ) {
+        if matches!(best_choice, Some(Choice { stability: Stable, .. })) {
             return;
         }
         search(LangCrateOrigin::Std, best_choice);
-        if matches!(
-            best_choice,
-            Some(Choice {
-                stability: Stable,
-                ..
-            })
-        ) {
+        if matches!(best_choice, Some(Choice { stability: Stable, .. })) {
             return;
         }
     } else {
         search(LangCrateOrigin::Std, best_choice);
-        if matches!(
-            best_choice,
-            Some(Choice {
-                stability: Stable,
-                ..
-            })
-        ) {
+        if matches!(best_choice, Some(Choice { stability: Stable, .. })) {
             return;
         }
         search(LangCrateOrigin::Core, best_choice);
-        if matches!(
-            best_choice,
-            Some(Choice {
-                stability: Stable,
-                ..
-            })
-        ) {
+        if matches!(best_choice, Some(Choice { stability: Stable, .. })) {
             return;
         }
     }
         .filter(|it| it.is_sysroot())
         .chain(dependencies.iter().filter(|it| !it.is_sysroot()))
         .for_each(|dep| {
-            find_in_dep(
-                ctx,
-                visited_modules,
-                item,
-                max_len,
-                best_choice,
-                dep.crate_id,
-            );
+            find_in_dep(ctx, visited_modules, item, max_len, best_choice, dep.crate_id);
         });
 }
 
             choice.stability = Unstable;
         }
 
-        Choice::try_select(
-            best_choice,
-            choice,
-            ctx.cfg.prefer_prelude,
-            info.name.clone(),
-        );
+        Choice::try_select(best_choice, choice, ctx.cfg.prefer_prelude, info.name.clone());
     }
 }
 
         match other
             .stability
             .cmp(&current.stability)
-            .then_with(|| {
-                other
-                    .prefer_due_to_prelude
-                    .cmp(&current.prefer_due_to_prelude)
-            })
+            .then_with(|| other.prefer_due_to_prelude.cmp(&current.prefer_due_to_prelude))
             .then_with(|| (current.path.len()).cmp(&(other.path.len() + 1)))
         {
             Ordering::Less => return,
     // `from` can import anything below `from` with visibility of at least `from`, and anything
     // above `from` with any visibility. That means we do not need to descend into private siblings
     // of `from` (and similar).
-
     // Compute the initial worklist. We start with all direct child modules of `from` as well as all
     // of its (recursive) parent modules.
     let mut worklist = def_map[from.local_id]
         .children
         .values()
         .map(|&child| def_map.module_id(child))
-        .chain(iter::successors(from.containing_module(db), |m| {
-            m.containing_module(db)
-        }))
+        .chain(iter::successors(from.containing_module(db), |m| m.containing_module(db)))
         .zip(iter::repeat(false))
         .collect::<Vec<_>>();
 
             }
         }
     }
-    worklist
-        .into_iter()
-        .filter(|&(_, processed)| processed)
-        .for_each(|(module, _)| {
-            visited_modules.remove(&(item, module));
-        });
+    worklist.into_iter().filter(|&(_, processed)| processed).for_each(|(module, _)| {
+        visited_modules.remove(&(item, module));
+    });
 }
 
 #[cfg(test)]
     use stdx::format_to;
     use syntax::ast::AstNode;
     use test_fixture::WithFixture;
-
     use crate::test_db::TestDB;
-
     use super::*;
-
     /// `code` needs to contain a cursor marker; checks that `find_path` for the
     /// item the `path` refers to returns that same path when called from the
     /// module the cursor is in.
         let module = db.module_at_position(pos);
         let parsed_path_file =
             syntax::SourceFile::parse(&format!("use {path};"), span::Edition::CURRENT);
-        let ast_path = parsed_path_file
-            .syntax_node()
-            .descendants()
-            .find_map(syntax::ast::Path::cast)
-            .unwrap();
+        let ast_path =
+            parsed_path_file.syntax_node().descendants().find_map(syntax::ast::Path::cast).unwrap();
         let mod_path = ModPath::from_src(&db, ast_path, &mut |range| {
-            db.span_map(pos.file_id.into())
-                .as_ref()
-                .span_for_range(range)
-                .ctx
+            db.span_map(pos.file_id.into()).as_ref().span_for_range(range).ctx
         })
         .unwrap();
 
                 module,
                 prefix,
                 ignore_local_imports,
-                FindPathConfig {
-                    prefer_no_std,
-                    prefer_prelude,
-                    prefer_absolute,
-                    allow_unstable,
-                },
+                FindPathConfig { prefer_no_std, prefer_prelude, prefer_absolute, allow_unstable },
             );
             format_to!(
                 res,
         }
         expect.assert_eq(&res);
     }
-
     fn check_found_path(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, false, false, expect);
     }
-
     fn check_found_path_prelude(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, true, false, false, false, expect);
     }
-
     fn check_found_path_absolute(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, true, false, false, expect);
     }
-
     fn check_found_path_prefer_no_std(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, true, false, expect);
     }
-
     fn check_found_path_prefer_no_std_allow_unstable(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, true, true, expect);
     }
-
     #[test]
     fn same_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn sub_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn super_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn self_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn crate_root() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn partially_imported() {
         cov_mark::check!(partially_imported);
             "#]],
         );
     }
-
     #[test]
     fn partially_imported_with_prefer_absolute() {
         cov_mark::check!(partially_imported);
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport_rename() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn shadowed_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn imported_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant_from_prelude() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn shortest_path() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn discount_private_imports() {
         cov_mark::check!(discount_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports() {
         cov_mark::check!(explicit_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn import_cycle() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_std_paths_over_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_core_paths_over_std() {
         check_found_path_prefer_no_std(
             "#]],
         );
     }
-
     #[test]
     fn prefer_alloc_paths_over_std() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_shorter_paths_if_not_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn builtins_are_in_scope() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_outer_scope() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_inner_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn outer_items_with_inner_items_present() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module2() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module_with_inner_items() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn recursive_pub_mod_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn extern_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prelude_with_inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed_through_dep() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_unstable_modules() {
         check_found_path_prefer_no_std_allow_unstable(
             "#]],
         );
     }
-
     #[test]
     fn respects_prelude_setting() {
         let ra_fixture = r#"
             "#]],
         );
     }
-
     #[test]
     fn respects_absolute_setting() {
         let ra_fixture = r#"
         "#]],
         );
     }
-
     #[test]
     fn respect_segment_length() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn regression_17271() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_long_std_over_short_extern() {
         check_found_path(