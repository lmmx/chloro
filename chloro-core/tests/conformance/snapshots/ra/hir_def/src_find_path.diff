COMPARISON DIFF
============================================================

Original size: 62212 bytes
Chloro size:   62246 bytes
Rustfmt size:  62212 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! An algorithm to find a path to refer to a certain item.
 
 use std::{cell::Cell, cmp::Ordering, iter};
 
 use base_db::{Crate, CrateOrigin, LangCrateOrigin};
 use hir_expand::{
-    Lookup,
     mod_path::{ModPath, PathKind},
     name::{AsName, Name},
+    Lookup,
 };
 use intern::sym;
 use rustc_hash::FxHashSet;
 
 use crate::{
-    FindPathConfig, ModuleDefId, ModuleId,
     db::DefDatabase,
     item_scope::ItemInNs,
     nameres::DefMap,
     visibility::{Visibility, VisibilityExplicitness},
+    FindPathConfig, ModuleDefId, ModuleId,
 };
 
 /// Find a path that can be used to refer to a certain item. This can depend on
     }
 
     // within block modules, forcing a `self` or `crate` prefix will not allow using inner items, so
+
     // default to plain paths.
     let item_module = item.module(db)?;
     if item_module.is_within_block() {
 use Stability::*;
 
 const MAX_PATH_LEN: usize = 15;
+
 const FIND_PATH_FUEL: usize = 10000;
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
     ignore_local_imports: bool,
 ) -> Option<Name> {
     // FIXME: We could have multiple applicable names here, but we currently only return the first
-    def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {
+    def_map.with_ancestor_maps(
+        db,
+        from.local_id,
+        &mut |def_map, local_id| {
         def_map[local_id].scope.names_of(item, |name, _, declared| {
             (declared || !ignore_local_imports).then(|| name.clone())
         })
-    })
+    },
+    )
 }
 
 /// Returns single-segment path (i.e. without any prefix) if `item` is found in prelude and its
     } else if let Some(parent_id) = def_map[from].parent {
         if item == parent_id {
             // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)
-            Some(if parent_id == DefMap::ROOT { PathKind::Crate } else { PathKind::Super(1) })
+            Some(if parent_id == DefMap::ROOT {
+                PathKind::Crate
+            } else {
+                PathKind::Super(1)
+            })
         } else {
             None
         }
         // Item was defined in some upstream crate. This means that it must be exported from one,
         // too (unless we can't name it at all). It could *also* be (re)exported by the same crate
         // that wants to import it here, but we always prefer to use the external path here.
-
         ctx.from.krate.data(ctx.db).dependencies.iter().for_each(|dep| {
             find_in_dep(ctx, visited_modules, item, max_len, best_choice, dep.crate_id)
         });
         return;
     };
     for info in import_info_for {
+        // Determine best path for containing module and append last segment from `info`.
+        // FIXME: we should guide this to look up the path locally, or from the same crate again?
         if info.is_doc_hidden {
             // the item or import is `#[doc(hidden)]`, so skip it as it is in an external crate
             continue;
         }
-
-        // Determine best path for containing module and append last segment from `info`.
-        // FIXME: we should guide this to look up the path locally, or from the same crate again?
         let choice = find_path_for_module(
             ctx,
             visited_modules,
             }
             choice.stability = Unstable;
         }
-
         Choice::try_select(best_choice, choice, ctx.cfg.prefer_prelude, info.name.clone());
     }
 }
     let _p = tracing::info_span!("find_local_import_locations").entered();
 
     // `from` can import anything below `from` with visibility of at least `from`, and anything
+
     // above `from` with any visibility. That means we do not need to descend into private siblings
+
     // of `from` (and similar).
 
     // Compute the initial worklist. We start with all direct child modules of `from` as well as all
+
     // of its (recursive) parent modules.
     let mut worklist = def_map[from.local_id]
         .children
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{Expect, expect};
+    use expect_test::{expect, Expect};
     use hir_expand::db::ExpandDatabase;
     use itertools::Itertools;
     use span::Edition;
     use stdx::format_to;
     use syntax::ast::AstNode;
     use test_fixture::WithFixture;
-
     use crate::test_db::TestDB;
-
     use super::*;
-
     /// `code` needs to contain a cursor marker; checks that `find_path` for the
     /// item the `path` refers to returns that same path when called from the
     /// module the cursor is in.
         }
         expect.assert_eq(&res);
     }
-
     fn check_found_path(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, false, false, expect);
     }
-
     fn check_found_path_prelude(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, true, false, false, false, expect);
     }
-
     fn check_found_path_absolute(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, true, false, false, expect);
     }
-
     fn check_found_path_prefer_no_std(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, true, false, expect);
     }
-
     fn check_found_path_prefer_no_std_allow_unstable(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, true, true, expect);
     }
-
     #[test]
     fn same_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn sub_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn super_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn self_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn crate_root() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn partially_imported() {
         cov_mark::check!(partially_imported);
             "#]],
         );
     }
-
     #[test]
     fn partially_imported_with_prefer_absolute() {
         cov_mark::check!(partially_imported);
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport_rename() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn shadowed_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn imported_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant_from_prelude() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn shortest_path() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn discount_private_imports() {
         cov_mark::check!(discount_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports() {
         cov_mark::check!(explicit_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn import_cycle() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_std_paths_over_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_core_paths_over_std() {
         check_found_path_prefer_no_std(
             "#]],
         );
     }
-
     #[test]
     fn prefer_alloc_paths_over_std() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_shorter_paths_if_not_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn builtins_are_in_scope() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_outer_scope() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_inner_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn outer_items_with_inner_items_present() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module2() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module_with_inner_items() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn recursive_pub_mod_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn extern_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prelude_with_inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed_through_dep() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_unstable_modules() {
         check_found_path_prefer_no_std_allow_unstable(
             "#]],
         );
     }
-
     #[test]
     fn respects_prelude_setting() {
         let ra_fixture = r#"
             "#]],
         );
     }
-
     #[test]
     fn respects_absolute_setting() {
         let ra_fixture = r#"
         "#]],
         );
     }
-
     #[test]
     fn respect_segment_length() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn regression_17271() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_long_std_over_short_extern() {
         check_found_path(