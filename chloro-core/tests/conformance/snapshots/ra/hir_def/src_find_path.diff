COMPARISON DIFF
============================================================

Original size: 62212 bytes
Chloro size:   62157 bytes
Rustfmt size:  62212 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! An algorithm to find a path to refer to a certain item.
 
 use std::{cell::Cell, cmp::Ordering, iter};
 
 use base_db::{Crate, CrateOrigin, LangCrateOrigin};
 use hir_expand::{
-    Lookup,
     mod_path::{ModPath, PathKind},
     name::{AsName, Name},
+    Lookup,
 };
 use intern::sym;
 use rustc_hash::FxHashSet;
+use Stability::*;
 
 use crate::{
-    FindPathConfig, ModuleDefId, ModuleId,
     db::DefDatabase,
     item_scope::ItemInNs,
     nameres::DefMap,
     visibility::{Visibility, VisibilityExplicitness},
+    FindPathConfig, ModuleDefId, ModuleId,
 };
 
 /// Find a path that can be used to refer to a certain item. This can depend on
     mut cfg: FindPathConfig,
 ) -> Option<ModPath> {
     let _p = tracing::info_span!("find_path").entered();
-
     // - if the item is a builtin, it's in scope
+
     if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {
         return Some(ModPath::from_segments(PathKind::Plain, iter::once(builtin.as_name())));
     }
-
     // within block modules, forcing a `self` or `crate` prefix will not allow using inner items, so
     // default to plain paths.
+
     let item_module = item.module(db)?;
     if item_module.is_within_block() {
         prefix_kind = PrefixKind::Plain;
     Unstable,
     Stable,
 }
-use Stability::*;
 
 const MAX_PATH_LEN: usize = 15;
+
 const FIND_PATH_FUEL: usize = 10000;
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
             return Some(ModPath::from_segments(ctx.prefix.path_kind(), iter::once(scope_name)));
         }
     }
-
     // - if the item is in the prelude, return the name from there
+
     if let Some(value) = find_in_prelude(ctx.db, ctx.from_def_map, item, ctx.from) {
         return Some(value.path);
     }
             ));
         }
     }
-
     // - if the module can be referenced as self, super or crate, do that
+
     if let Some(kind) = is_kw_kind_relative_to_from(ctx.from_def_map, module_id, ctx.from)
         && (ctx.prefix != PrefixKind::ByCrate || kind == PathKind::Crate)
     {
             prefer_due_to_prelude: false,
         });
     }
-
     // - if the module is in the prelude, return it by that path
+
     let item = ItemInNs::Types(module_id.into());
     if let Some(choice) = find_in_prelude(ctx.db, ctx.from_def_map, item, ctx.from) {
         return Some(choice);
     if !vis.is_visible_from(db, from) {
         return None;
     }
-
     // Check if the name is in current scope and it points to the same def.
+
     let found_and_same_def =
         local_def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {
             let per_ns = def_map[local_id].scope.get(name);
     mut cb: impl FnMut(&mut FxHashSet<(ItemInNs, ModuleId)>, &Name, ModuleId),
 ) {
     let _p = tracing::info_span!("find_local_import_locations").entered();
-
     // `from` can import anything below `from` with visibility of at least `from`, and anything
     // above `from` with any visibility. That means we do not need to descend into private siblings
     // of `from` (and similar).
-
     // Compute the initial worklist. We start with all direct child modules of `from` as well as all
     // of its (recursive) parent modules.
+
     let mut worklist = def_map[from.local_id]
         .children
         .values()
     use stdx::format_to;
     use syntax::ast::AstNode;
     use test_fixture::WithFixture;
-
     use crate::test_db::TestDB;
-
     use super::*;
-
     /// `code` needs to contain a cursor marker; checks that `find_path` for the
     /// item the `path` refers to returns that same path when called from the
     /// module the cursor is in.
         }
         expect.assert_eq(&res);
     }
-
     fn check_found_path(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, false, false, expect);
     }
-
     fn check_found_path_prelude(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, true, false, false, false, expect);
     }
-
     fn check_found_path_absolute(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, true, false, false, expect);
     }
-
     fn check_found_path_prefer_no_std(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, true, false, expect);
     }
-
     fn check_found_path_prefer_no_std_allow_unstable(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, true, true, expect);
     }
-
     #[test]
     fn same_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn sub_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn super_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn self_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn crate_root() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn partially_imported() {
         cov_mark::check!(partially_imported);
             "#]],
         );
     }
-
     #[test]
     fn partially_imported_with_prefer_absolute() {
         cov_mark::check!(partially_imported);
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport_rename() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn shadowed_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn imported_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant_from_prelude() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn shortest_path() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn discount_private_imports() {
         cov_mark::check!(discount_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports() {
         cov_mark::check!(explicit_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn import_cycle() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_std_paths_over_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_core_paths_over_std() {
         check_found_path_prefer_no_std(
                 BySelf (imports ✖): core::fmt::Error
             "#]],
         );
-
         // Should also work (on a best-effort basis) if `no_std` is conditional.
+
         check_found_path(
             r#"
 //- /main.rs crate:main deps:core,std
             "#]],
         );
     }
-
     #[test]
     fn prefer_alloc_paths_over_std() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_shorter_paths_if_not_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn builtins_are_in_scope() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_outer_scope() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_inner_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn outer_items_with_inner_items_present() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module2() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module_with_inner_items() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn recursive_pub_mod_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn extern_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prelude_with_inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed_through_dep() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_unstable_modules() {
         check_found_path_prefer_no_std_allow_unstable(
             "#]],
         );
     }
-
     #[test]
     fn respects_prelude_setting() {
         let ra_fixture = r#"
             "#]],
         );
     }
-
     #[test]
     fn respects_absolute_setting() {
         let ra_fixture = r#"
         "#]],
         );
     }
-
     #[test]
     fn respect_segment_length() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn regression_17271() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_long_std_over_short_extern() {
         check_found_path(