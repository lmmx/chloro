COMPARISON DIFF
============================================================

Original size: 62212 bytes
Chloro size:   62220 bytes
Rustfmt size:  62212 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! An algorithm to find a path to refer to a certain item.
 
 use std::{cell::Cell, cmp::Ordering, iter};
 
+use Stability::*;
 use base_db::{Crate, CrateOrigin, LangCrateOrigin};
 use hir_expand::{
     Lookup,
     mut cfg: FindPathConfig,
 ) -> Option<ModPath> {
     let _p = tracing::info_span!("find_path").entered();
-
     // - if the item is a builtin, it's in scope
     if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {
         return Some(ModPath::from_segments(PathKind::Plain, iter::once(builtin.as_name())));
     }
-
     // within block modules, forcing a `self` or `crate` prefix will not allow using inner items, so
     // default to plain paths.
     let item_module = item.module(db)?;
         prefix_kind = PrefixKind::Plain;
     }
     cfg.prefer_no_std = cfg.prefer_no_std || db.crate_supports_no_std(from.krate());
-
     find_path_inner(
         &FindPathCtx {
             db,
     Unstable,
     Stable,
 }
-use Stability::*;
 
 const MAX_PATH_LEN: usize = 15;
+
 const FIND_PATH_FUEL: usize = 10000;
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 }
 
 /// Attempts to find a path to refer to the given `item` visible from the `from` ModuleId
-fn find_path_inner(ctx: &FindPathCtx<'_>, item: ItemInNs, max_len: usize) -> Option<ModPath> {
+fn find_path_inner(
+    ctx: &FindPathCtx<'_>,
+    item: ItemInNs,
+    max_len: usize,
+) -> Option<ModPath> {
     // - if the item is a module, jump straight to module search
     if !ctx.is_std_item
         && let ItemInNs::Types(ModuleDefId::ModuleId(module_id)) = item
         return find_path_for_module(ctx, &mut FxHashSet::default(), module_id, true, max_len)
             .map(|choice| choice.path);
     }
-
     let may_be_in_scope = match ctx.prefix {
         PrefixKind::Plain | PrefixKind::BySelf => true,
         PrefixKind::ByCrate => ctx.from.is_crate_root(),
             return Some(ModPath::from_segments(ctx.prefix.path_kind(), iter::once(scope_name)));
         }
     }
-
     // - if the item is in the prelude, return the name from there
     if let Some(value) = find_in_prelude(ctx.db, ctx.from_def_map, item, ctx.from) {
         return Some(value.path);
     }
-
     if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {
         // - if the item is an enum variant, refer to it via the enum
         let loc = variant.lookup(ctx.db);
         // enum; that's very weird, but there might still be a reexport of the
         // variant somewhere
     }
-
     let mut best_choice = None;
     calculate_best_path(ctx, &mut FxHashSet::default(), item, max_len, &mut best_choice);
     best_choice.map(|choice| choice.path)
             return Some(Choice::new(ctx.cfg.prefer_prelude, kind, name.clone(), Stable));
         }
     }
-
     let may_be_in_scope = match ctx.prefix {
         PrefixKind::Plain | PrefixKind::BySelf => true,
         PrefixKind::ByCrate => ctx.from.is_crate_root(),
             ));
         }
     }
-
     // - if the module can be referenced as self, super or crate, do that
     if let Some(kind) = is_kw_kind_relative_to_from(ctx.from_def_map, module_id, ctx.from)
         && (ctx.prefix != PrefixKind::ByCrate || kind == PathKind::Crate)
             prefer_due_to_prelude: false,
         });
     }
-
     // - if the module is in the prelude, return it by that path
     let item = ItemInNs::Types(module_id.into());
     if let Some(choice) = find_in_prelude(ctx.db, ctx.from_def_map, item, ctx.from) {
     if !vis.is_visible_from(db, from) {
         return None;
     }
-
     // Check if the name is in current scope and it points to the same def.
     let found_and_same_def =
         local_def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {
             };
             Some(same_def)
         });
-
     if found_and_same_def.unwrap_or(true) {
         Some(Choice::new(false, PathKind::Plain, name.clone(), Stable))
     } else {
         return;
     }
     ctx.fuel.set(fuel - 1);
-
     if item.krate(ctx.db) == Some(ctx.from.krate) {
         // Item was defined in the same crate that wants to import it. It cannot be found in any
         // dependency in this case.
 }
 
 impl Choice {
-    fn new(prefer_prelude: bool, kind: PathKind, name: Name, stability: Stability) -> Self {
+    fn new(
+        prefer_prelude: bool,
+        kind: PathKind,
+        name: Name,
+        stability: Stability,
+    ) -> Self {
         Self {
             path_text_len: path_kind_len(kind) + name.as_str().len(),
             stability,
         }
     }
 
-    fn push(mut self, prefer_prelude: bool, name: Name) -> Self {
+    fn push(
+        mut self,
+        prefer_prelude: bool,
+        name: Name,
+    ) -> Self {
         self.path_text_len += name.as_str().len();
         self.prefer_due_to_prelude |= prefer_prelude && name == sym::prelude;
         self.path.push_segment(name);
     mut cb: impl FnMut(&mut FxHashSet<(ItemInNs, ModuleId)>, &Name, ModuleId),
 ) {
     let _p = tracing::info_span!("find_local_import_locations").entered();
-
     // `from` can import anything below `from` with visibility of at least `from`, and anything
     // above `from` with any visibility. That means we do not need to descend into private siblings
     // of `from` (and similar).
-
     // Compute the initial worklist. We start with all direct child modules of `from` as well as all
     // of its (recursive) parent modules.
     let mut worklist = def_map[from.local_id]
         .chain(iter::successors(from.containing_module(db), |m| m.containing_module(db)))
         .zip(iter::repeat(false))
         .collect::<Vec<_>>();
-
     let def_map = def_map.crate_root().def_map(db);
     let mut block_def_map;
     let mut cursor = 0;
-
     while let Some(&mut (module, ref mut processed)) = worklist.get_mut(cursor) {
         cursor += 1;
         if !visited_modules.insert((item, module)) {
     use stdx::format_to;
     use syntax::ast::AstNode;
     use test_fixture::WithFixture;
-
     use crate::test_db::TestDB;
-
     use super::*;
-
     /// `code` needs to contain a cursor marker; checks that `find_path` for the
     /// item the `path` refers to returns that same path when called from the
     /// module the cursor is in.
             db.span_map(pos.file_id.into()).as_ref().span_for_range(range).ctx
         })
         .unwrap();
-
         let (def_map, local_def_map) = module.local_def_map(&db);
         let resolved = def_map
             .resolve_path(
             .map(ItemInNs::Types)
             .or_else(|| resolved.take_values().map(ItemInNs::Values))
             .expect("path does not resolve to a type or value");
-
         let mut res = String::new();
         for (prefix, ignore_local_imports) in
             [PrefixKind::Plain, PrefixKind::ByCrate, PrefixKind::BySelf]
         }
         expect.assert_eq(&res);
     }
-
     fn check_found_path(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, false, false, expect);
     }
-
     fn check_found_path_prelude(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, true, false, false, false, expect);
     }
-
     fn check_found_path_absolute(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, true, false, false, expect);
     }
-
     fn check_found_path_prefer_no_std(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, true, false, expect);
     }
-
     fn check_found_path_prefer_no_std_allow_unstable(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         path: &str,
     ) {
         check_found_path_(ra_fixture, path, false, false, true, true, expect);
     }
-
     #[test]
     fn same_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn sub_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn super_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn self_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn crate_root() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn partially_imported() {
         cov_mark::check!(partially_imported);
                 BySelf (imports ✖): syntax::ast::ModuleItem
             "#]],
         );
-
         check_found_path(
             r#"
 //- /main.rs crate:main deps:syntax
             "#]],
         );
     }
-
     #[test]
     fn partially_imported_with_prefer_absolute() {
         cov_mark::check!(partially_imported);
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport_rename() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn shadowed_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn imported_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant_from_prelude() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn shortest_path() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn discount_private_imports() {
         cov_mark::check!(discount_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports() {
         cov_mark::check!(explicit_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn import_cycle() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_std_paths_over_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_core_paths_over_std() {
         check_found_path_prefer_no_std(
                 BySelf (imports ✖): core::fmt::Error
             "#]],
         );
-
         // Should also work (on a best-effort basis) if `no_std` is conditional.
         check_found_path(
             r#"
             "#]],
         );
     }
-
     #[test]
     fn prefer_alloc_paths_over_std() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_shorter_paths_if_not_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn builtins_are_in_scope() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_outer_scope() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_inner_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn outer_items_with_inner_items_present() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module2() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module_with_inner_items() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn recursive_pub_mod_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn extern_crate() {
         check_found_path(
                 BySelf (imports ✖): dep
             "#]],
         );
-
         check_found_path(
             r#"
 //- /main.rs crate:main deps:dep
             "#]],
         );
     }
-
     #[test]
     fn prelude_with_inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed_through_dep() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_unstable_modules() {
         check_found_path_prefer_no_std_allow_unstable(
             "#]],
         );
     }
-
     #[test]
     fn respects_prelude_setting() {
         let ra_fixture = r#"
             "#]],
         );
     }
-
     #[test]
     fn respects_absolute_setting() {
         let ra_fixture = r#"
             BySelf (imports ✖): krate::foo::Foo
         "#]],
         );
-
         check_found_path_absolute(
             ra_fixture,
             "krate::foo::Foo",
         "#]],
         );
     }
-
     #[test]
     fn respect_segment_length() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn regression_17271() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_long_std_over_short_extern() {
         check_found_path(