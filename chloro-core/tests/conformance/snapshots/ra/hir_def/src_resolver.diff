COMPARISON DIFF
============================================================

Original size: 54481 bytes
Chloro size:   54008 bytes
Rustfmt size:  54481 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Name resolution façade.
+
 use std::{fmt, mem};
 
 use base_db::Crate;
 use hir_expand::{
-    MacroDefId,
     mod_path::{ModPath, PathKind},
     name::{AsName, Name},
+    MacroDefId,
 };
-use intern::{Symbol, sym};
+use intern::{sym, Symbol};
 use itertools::Itertools as _;
 use rustc_hash::FxHashSet;
-use smallvec::{SmallVec, smallvec};
+use smallvec::{smallvec, SmallVec};
 use span::SyntaxContext;
 use syntax::ast::HasName;
 use triomphe::Arc;
 
 use crate::{
+    builtin_type::BuiltinType,
+    db::DefDatabase,
+    expr_store::{path::Path, scope::{ExprScopes, ScopeId}, HygieneId},
+    hir::{generics::{GenericParams, TypeOrConstParamData}, BindingId, ExprId, LabelId},
+    item_scope::{BuiltinShadowMode, ImportOrExternCrate, ImportOrGlob, ItemScope, BUILTIN_SCOPE},
+    lang_item::LangItemTarget,
+    nameres::{block_def_map, DefMap, LocalDefMap, MacroSubNs, ResolvePathResultPrefixInfo},
+    per_ns::PerNs,
+    src::HasSource,
+    type_ref::LifetimeRef,
+    visibility::{RawVisibility, Visibility},
     AdtId, AstIdLoc, ConstId, ConstParamId, CrateRootModuleId, DefWithBodyId, EnumId,
     EnumVariantId, ExternBlockId, ExternCrateId, FunctionId, FxIndexMap, GenericDefId,
     GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId, LocalModuleId, Lookup,
     Macro2Id, MacroId, MacroRulesId, ModuleDefId, ModuleId, ProcMacroId, StaticId, StructId,
     TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UseId, VariantId,
-    builtin_type::BuiltinType,
-    db::DefDatabase,
-    expr_store::{
-        HygieneId,
-        path::Path,
-        scope::{ExprScopes, ScopeId},
-    },
-    hir::{
-        BindingId, ExprId, LabelId,
-        generics::{GenericParams, TypeOrConstParamData},
-    },
-    item_scope::{BUILTIN_SCOPE, BuiltinShadowMode, ImportOrExternCrate, ImportOrGlob, ItemScope},
-    lang_item::LangItemTarget,
-    nameres::{DefMap, LocalDefMap, MacroSubNs, ResolvePathResultPrefixInfo, block_def_map},
-    per_ns::PerNs,
-    src::HasSource,
-    type_ref::LifetimeRef,
-    visibility::{RawVisibility, Visibility},
 };
 
 #[derive(Debug, Clone)]
 
 impl fmt::Debug for ExprScope {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        f.debug_struct("ExprScope")
-            .field("owner", &self.owner)
-            .field("scope_id", &self.scope_id)
-            .finish()
+        f.debug_struct("ExprScope").field("owner", &self.owner).field("scope_id", &self.scope_id).finish(
+        )
     }
 }
 
     BlockScope(ModuleItemMap<'db>),
     /// Brings the generic parameters of an item into scope as well as the `Self` type alias /
     /// generic for ADTs and impls.
-    GenericParams { def: GenericDefId, params: Arc<GenericParams> },
+    GenericParams {
+        def: GenericDefId,
+        params: Arc<GenericParams>,
+    },
     /// Local bindings
     ExprScope(ExprScope),
     /// Macro definition inside bodies that affects all paths after it in the same block.
         &self,
         db: &dyn DefDatabase,
         path: &Path,
-    ) -> Option<(TypeNs, Option<usize>, Option<ImportOrExternCrate>, ResolvePathResultPrefixInfo)>
-    {
+    ) -> Option<(TypeNs, Option<usize>, Option<ImportOrExternCrate>, ResolvePathResultPrefixInfo)> {
         let path = match path {
             Path::BarePath(mod_path) => mod_path,
             Path::Normal(it) => &it.mod_path,
         }
 
         // If a path of the shape `u16::from_le_bytes` failed to resolve at all, then we fall back
+
         // to resolving to the primitive type, to allow this to still work in the presence of
+
         // `use core::u16;`.
         if path.kind == PathKind::Plain
             && n_segments > 1
         expected_macro_kind: Option<MacroSubNs>,
     ) -> Option<(MacroId, Option<ImportOrExternCrate>)> {
         let (item_map, item_local_map, module) = self.item_scope_();
-        item_map
-            .resolve_path(
-                item_local_map,
-                db,
-                module,
-                path,
-                BuiltinShadowMode::Other,
-                expected_macro_kind,
-            )
-            .0
-            .take_macros_import()
+        item_map.resolve_path(
+            item_local_map,
+            db,
+            module,
+            path,
+            BuiltinShadowMode::Other,
+            expected_macro_kind,
+        ).0.take_macros_import(
+        )
     }
 
     pub fn resolve_path_as_macro_def(
         &'a self,
         db: &'a dyn DefDatabase,
     ) -> impl Iterator<Item = Name> + 'a {
-        self.module_scope.def_map[self.module_scope.module_id]
-            .scope
-            .extern_crate_decls()
-            .filter_map(|id| {
+        self.module_scope.def_map[self.module_scope.module_id].scope.extern_crate_decls().filter_map(|id| {
                 let loc = id.lookup(db);
                 let extern_crate = loc.source(db);
                 // If there is a rename (`as x`), extract the renamed name, or remove the `extern crate`
     }
 
     pub fn extern_crates_in_scope(&self) -> impl Iterator<Item = (Name, ModuleId)> + '_ {
-        self.module_scope
-            .local_def_map
-            .extern_prelude()
-            .map(|(name, module_id)| (name.clone(), module_id.0.into()))
+        self.module_scope.local_def_map.extern_prelude().map(
+            |(name, module_id)| (name.clone(), module_id.0.into()),
+        )
     }
 
     pub fn traits_in_scope(&self, db: &dyn DefDatabase) -> FxHashSet<TraitId> {
     }
 
     pub fn traits_in_scope_from_block_scopes(&self) -> impl Iterator<Item = TraitId> + '_ {
-        self.scopes()
-            .filter_map(|scope| match scope {
+        self.scopes().filter_map(|scope| match scope {
                 Scope::BlockScope(m) => Some(m.def_map[m.module_id].scope.traits()),
                 _ => None,
-            })
-            .flatten()
+            }).flatten(
+        )
     }
 
     pub fn module(&self) -> ModuleId {
     hygiene_info: &mut Option<(SyntaxContext, MacroDefId)>,
     macro_id: &MacroDefId,
 ) {
-    if let Some((parent_ctx, label_macro_id)) = hygiene_info
-        && label_macro_id == macro_id
-    {
-        // A macro is allowed to refer to variables from before its declaration.
-        // Therefore, if we got to the rib of its declaration, give up its hygiene
-        // and use its parent expansion.
+    if let Some((parent_ctx, label_macro_id)) = hygiene_info && label_macro_id == macro_id {
         *hygiene_id = HygieneId::new(parent_ctx.opaque_and_semitransparent(db));
         *hygiene_info = parent_ctx.outer_expn(db).map(|expansion| {
             let expansion = db.lookup_intern_macro_call(expansion.into());
 
     /// The innermost block scope that contains items or the module scope that contains this resolver.
     fn item_scope_(&self) -> (&DefMap, &LocalDefMap, LocalModuleId) {
-        self.scopes()
-            .find_map(|scope| match scope {
+        self.scopes().find_map(|scope| match scope {
                 Scope::BlockScope(m) => Some((m.def_map, m.local_def_map, m.module_id)),
                 _ => None,
-            })
-            .unwrap_or((
-                self.module_scope.def_map,
-                self.module_scope.local_def_map,
-                self.module_scope.module_id,
-            ))
+            }).unwrap_or(
+            (self.module_scope.def_map, self.module_scope.local_def_map, self.module_scope.module_id),
+        )
     }
 }
 
                 } else if let GenericDefId::AdtId(adt) = parent {
                     acc.add(&Name::new_symbol_root(sym::Self_), ScopeDef::AdtSelfType(adt));
                 }
-
                 for (local_id, param) in params.iter_type_or_consts() {
                     if let Some(name) = &param.name() {
                         let id = TypeOrConstParamId { parent, local_id };
                     acc.add_local(e.name(), e.binding());
                 });
             }
-            Scope::MacroDefScope(_) => {}
+            Scope::MacroDefScope(_) => {
+            }
         }
     }
 }
         &self,
         db: &dyn DefDatabase,
         path: &ModPath,
-    ) -> Option<(TypeNs, Option<usize>, Option<ImportOrExternCrate>, ResolvePathResultPrefixInfo)>
-    {
+    ) -> Option<(TypeNs, Option<usize>, Option<ImportOrExternCrate>, ResolvePathResultPrefixInfo)> {
         let (module_def, idx, prefix_info) = self.def_map.resolve_path_locally(
             self.local_def_map,
             db,
             set.push(def)
         }
     }
+
     fn add_per_ns(&mut self, name: &Name, def: PerNs) {
         if let Some(ty) = &def.types {
             self.add(name, ScopeDef::ModuleDef(ty.def))
             self.add(name, ScopeDef::Unknown)
         }
     }
+
     fn add_local(&mut self, name: &Name, binding: BindingId) {
         let set = self.map.entry(name.clone()).or_default();
         // XXX: hack, account for local (and only local) shadowing.
     }
 }
 
-pub trait HasResolver: Copy {
+pub trait HasResolver {
     /// Builds a resolver for type references inside this def.
     fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_>;
 }