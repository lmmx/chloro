COMPARISON DIFF
============================================================

Original size: 108302 bytes
Chloro size:   107953 bytes
Rustfmt size:  108302 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     AdtId, AssocItemId, AstId, AstIdWithPath, ConstLoc, CrateRootModuleId, EnumLoc, ExternBlockLoc,
     ExternCrateId, ExternCrateLoc, FunctionId, FunctionLoc, FxIndexMap, ImplLoc, Intern,
-    ItemContainerId, LocalModuleId, Lookup, Macro2Id, Macro2Loc, MacroExpander, MacroId,
-    MacroRulesId, MacroRulesLoc, MacroRulesLocFlags, ModuleDefId, ModuleId, ProcMacroId,
-    ProcMacroLoc, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro, UseId,
-    UseLoc,
+    ItemContainerId, LocalModuleId, Lookup, MacroExpander, MacroId, MacroRulesId, MacroRulesLoc,
+    MacroRulesLocFlags, Macro2Id, Macro2Loc, ModuleDefId, ModuleId, ProcMacroId, ProcMacroLoc,
+    StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro, UseId, UseLoc,
     attr::Attrs,
     db::DefDatabase,
     item_scope::{GlobId, ImportId, ImportOrExternCrate, PerNsGlobImports},
     item_tree::{
-        self, FieldsShape, ImportAlias, ImportKind, ItemTree, ItemTreeAstId, Macro2, MacroCall,
-        MacroRules, Mod, ModItemId, ModKind, TreeId,
+        self, FieldsShape, ImportAlias, ImportKind, ItemTree, ItemTreeAstId, MacroCall,
+        MacroRules, Macro2, Mod, ModItemId, ModKind, TreeId,
     },
     macro_call_as_call_id,
     nameres::{
         BuiltinShadowMode, DefMap, LocalDefMap, MacroSubNs, ModuleData, ModuleOrigin, ResolveMode,
-        assoc::TraitItems,
-        attr_resolution::{attr_macro_as_call_id, derive_macro_as_call_id},
-        crate_def_map,
-        diagnostics::DefDiagnostic,
-        mod_resolution::ModDir,
+        assoc::TraitItems, attr_resolution::{attr_macro_as_call_id, derive_macro_as_call_id},
+        crate_def_map, diagnostics::DefDiagnostic, mod_resolution::ModDir,
         path_resolution::{ReachedFixedPoint, ResolvePathResult},
         proc_macro::{ProcMacroDef, ProcMacroKind, parse_macro_name_and_helper_attrs},
         sub_namespace_match,
 };
 
 const GLOB_RECURSION_LIMIT: usize = 100;
+
 const FIXED_POINT_LIMIT: usize = 8192;
 
 pub(super) fn collect_defs(
         ast_id: AstIdWithPath<ast::Item>,
         attr: Attr,
         mod_item: ModItemId,
-        /* is this needed? */ tree: TreeId,
+        /* is this needed? */
+        tree: TreeId,
         item_tree: &'db ItemTree,
     },
 }
     proc_macros: Box<[(Name, CustomProcMacroExpander, bool)]>,
     is_proc_macro: bool,
     from_glob_import: PerNsGlobImports,
+    // FIXME: There has to be a better way to do this
     /// If we fail to resolve an attribute on a `ModItem`, we fall back to ignoring the attribute.
     /// This map is used to skip all attributes up to and including the one that failed to resolve,
     /// in order to not expand them twice.
     ///
     /// This also stores the attributes to skip when we resolve derive helpers and non-macro
     /// non-builtin attributes in general.
-    // FIXME: There has to be a better way to do this
     skip_attrs: FxHashMap<InFile<FileAstId<ast::Item>>, AttrId>,
 }
 
 
     fn inject_prelude(&mut self) {
         // See compiler/rustc_builtin_macros/src/standard_library_imports.rs
-
         if self.def_map.data.no_core {
             // libcore does not get a prelude.
             return;
 
     fn update(
         &mut self,
-        // The module for which `resolutions` have been resolve
         module_id: LocalModuleId,
         resolutions: &[(Option<Name>, PerNs)],
-        // Visibility this import will have
         vis: Visibility,
         import: Option<ImportOrExternCrate>,
     ) {
 
     fn update_recursive(
         &mut self,
-        // The module for which `resolutions` have been resolved.
         module_id: LocalModuleId,
         resolutions: &[(Option<Name>, PerNs)],
-        // All resolutions are imported with this visibility; the visibilities in
-        // the `PerNs` values are ignored and overwritten
         vis: Visibility,
         import: Option<ImportOrExternCrate>,
         depth: usize,
             &self.item_tree[mac.visibility],
         );
         if let Some(helpers) = helpers_opt
-            && self.def_collector.def_map.block.is_none()
-        {
+            && self.def_collector.def_map.block.is_none() {
             Arc::get_mut(&mut self.def_collector.def_map.data)
                 .unwrap()
                 .exported_derives
         // FIXME: Immediately expanding in "Case 1" is insufficient since "Case 2" may also define
         // new legacy macros that create textual scopes. We need a way to resolve names in textual
         // scopes without eager expansion.
-
         let mut eager_callback_buffer = vec![];
         // Case 1: try to resolve macro calls with single-segment name and expand macro_rules
         if let Ok(res) = macro_call_as_call_id(
 #[cfg(test)]
 mod tests {
     use test_fixture::WithFixture;
-
     use crate::{nameres::DefMapCrateData, test_db::TestDB};
-
     use super::*;
-
     fn do_collect_defs(db: &dyn DefDatabase, def_map: DefMap) -> DefMap {
         let mut collector = DefCollector {
             db,
         collector.collect();
         collector.def_map
     }
-
     fn do_resolve(not_ra_fixture: &str) -> DefMap {
         let (db, file_id) = TestDB::with_single_file(not_ra_fixture);
         let krate = db.test_crate();
         );
         do_collect_defs(&db, def_map)
     }
-
     #[test]
     fn test_macro_expand_will_stop_1() {
         do_resolve(
 "#,
         );
     }
-
     #[ignore]
     #[test]
     fn test_macro_expand_will_stop_2() {