COMPARISON DIFF
============================================================

Original size: 108302 bytes
Chloro size:   107943 bytes
Rustfmt size:  108302 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use cfg::{CfgAtom, CfgExpr, CfgOptions};
 use either::Either;
 use hir_expand::{
-    EditionedFileId, ErasedAstId, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind,
-    MacroDefId, MacroDefKind,
     attrs::{Attr, AttrId},
     builtin::{find_builtin_attr, find_builtin_derive, find_builtin_macro},
     mod_path::{ModPath, PathKind},
     name::{AsName, Name},
     proc_macro::CustomProcMacroExpander,
+    EditionedFileId, ErasedAstId, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind,
+    MacroDefId, MacroDefKind,
 };
 use intern::{Interned, sym};
 use itertools::{Itertools, izip};
 use triomphe::Arc;
 
 use crate::{
-    AdtId, AssocItemId, AstId, AstIdWithPath, ConstLoc, CrateRootModuleId, EnumLoc, ExternBlockLoc,
-    ExternCrateId, ExternCrateLoc, FunctionId, FunctionLoc, FxIndexMap, ImplLoc, Intern,
-    ItemContainerId, LocalModuleId, Lookup, Macro2Id, Macro2Loc, MacroExpander, MacroId,
-    MacroRulesId, MacroRulesLoc, MacroRulesLocFlags, ModuleDefId, ModuleId, ProcMacroId,
-    ProcMacroLoc, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro, UseId,
-    UseLoc,
     attr::Attrs,
     db::DefDatabase,
     item_scope::{GlobId, ImportId, ImportOrExternCrate, PerNsGlobImports},
     per_ns::{Item, PerNs},
     tt,
     visibility::{RawVisibility, Visibility},
+    AdtId, AssocItemId, AstId, AstIdWithPath, ConstLoc, CrateRootModuleId, EnumLoc, ExternBlockLoc,
+    ExternCrateId, ExternCrateLoc, FunctionId, FunctionLoc, FxIndexMap, ImplLoc, Intern,
+    ItemContainerId, LocalModuleId, Lookup, Macro2Id, Macro2Loc, MacroExpander, MacroId,
+    MacroRulesId, MacroRulesLoc, MacroRulesLocFlags, ModuleDefId, ModuleId, ProcMacroId,
+    ProcMacroLoc, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro, UseId,
+    UseLoc,
 };
 
 const GLOB_RECURSION_LIMIT: usize = 100;
+
 const FIXED_POINT_LIMIT: usize = 8192;
 
 pub(super) fn collect_defs(
 ) -> (DefMap, LocalDefMap) {
     let krate = &def_map.krate.data(db);
     let cfg_options = def_map.krate.cfg_options(db);
-
     // populate external prelude and dependency list
     let mut deps =
         FxIndexMap::with_capacity_and_hasher(krate.dependencies.len(), Default::default());
 
         deps.insert(dep.as_name(), dep.clone());
     }
-
     let proc_macros = if krate.is_proc_macro {
         db.proc_macros_for_crate(def_map.krate)
             .and_then(|proc_macros| {
     } else {
         Default::default()
     };
-
     let mut collector = DefCollector {
         db,
         def_map,
         ast_id: AstIdWithPath<ast::Item>,
         attr: Attr,
         mod_item: ModItemId,
-        /* is this needed? */ tree: TreeId,
+        tree: TreeId,
         item_tree: &'db ItemTree,
     },
 }
     local_def_map: LocalDefMap,
     /// Set only in case of blocks.
     crate_local_def_map: Option<&'db LocalDefMap>,
-    // The dependencies of the current crate, including optional deps like `test`.
     deps: FxIndexMap<Name, BuiltDependency>,
     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility, GlobId)>>,
     unresolved_imports: Vec<ImportDirective>,
     indeterminate_imports: Vec<(ImportDirective, PerNs)>,
     unresolved_macros: Vec<MacroDirective<'db>>,
-    // We'd like to avoid emitting a diagnostics avalanche when some `extern crate` doesn't
-    // resolve. When we emit diagnostics for unresolved imports, we only do so if the import
-    // doesn't start with an unresolved crate's name.
     unresolved_extern_crates: FxHashSet<Name>,
     mod_dirs: FxHashMap<LocalModuleId, ModDir>,
     cfg_options: &'db CfgOptions,
     ///
     /// This also stores the attributes to skip when we resolve derive helpers and non-macro
     /// non-builtin attributes in general.
-    // FIXME: There has to be a better way to do this
     skip_attrs: FxHashMap<InFile<FileAstId<ast::Item>>, AttrId>,
 }
 
 impl<'db> DefCollector<'db> {
     fn seed_with_top_level(&mut self) {
         let _p = tracing::info_span!("seed_with_top_level").entered();
-
         let file_id = self.def_map.krate.data(self.db).root_file_id(self.db);
         let item_tree = self.db.file_item_tree(file_id.into());
         let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);
         let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();
-
         let mut process = true;
-
         // Process other crate-level attributes.
         for attr in &*attrs {
             if let Some(cfg) = attr.cfg()
                 () => (),
             }
         }
-
         for (name, dep) in &self.deps {
             // Add all
             if dep.is_prelude() {
                     .insert(name.clone(), (CrateRootModuleId { krate: dep.crate_id }, None));
             }
         }
-
         self.inject_prelude();
-
         if !process {
             return;
         }
-
         ModCollector {
             def_collector: self,
             macro_depth: 0,
         Arc::get_mut(&mut self.def_map.data).unwrap().shrink_to_fit();
     }
 
-    fn seed_with_inner(&mut self, tree_id: TreeId) {
+    fn seed_with_inner(
+        &mut self,
+        tree_id: TreeId,
+    ) {
         let item_tree = tree_id.item_tree(self.db);
         let is_cfg_enabled = item_tree
             .top_level_attrs(self.db, self.def_map.krate)
 
     fn resolution_loop(&mut self) {
         let _p = tracing::info_span!("DefCollector::resolution_loop").entered();
-
         // main name resolution fixed-point loop.
         let mut i = 0;
         'resolve_attr: loop {
 
     fn collect(&mut self) {
         let _p = tracing::info_span!("DefCollector::collect").entered();
-
         self.resolution_loop();
-
         let unresolved_imports = mem::take(&mut self.unresolved_imports);
         // show unresolved imports in completion, etc
         for directive in &unresolved_imports {
             self.record_resolved_import(directive);
         }
         self.unresolved_imports = unresolved_imports;
-
         if self.is_proc_macro {
             // A crate exporting procedural macros is not allowed to export anything else.
             //
     /// behavior before we supported proc. attribute macros.
     fn reseed_with_unresolved_attribute(&mut self) -> ReachedFixedPoint {
         cov_mark::hit!(unresolved_attribute_fallback);
-
         let unresolved_attr =
             self.unresolved_macros.iter().enumerate().find_map(|(idx, directive)| match &directive
                 .kind
                 }
                 _ => None,
             });
-
         match unresolved_attr {
             Some((
                 pos,
 
     fn inject_prelude(&mut self) {
         // See compiler/rustc_builtin_macros/src/standard_library_imports.rs
-
         if self.def_map.data.no_core {
             // libcore does not get a prelude.
             return;
         }
-
         let krate = if self.def_map.data.no_std {
             Name::new_symbol_root(sym::core)
         } else if self.local_def_map().extern_prelude().any(|(name, _)| *name == sym::std) {
             // keep r-a's own tests minimal.
             Name::new_symbol_root(sym::core)
         };
-
         let edition = match self.def_map.data.edition {
             Edition::Edition2015 => Name::new_symbol_root(sym::rust_2015),
             Edition::Edition2018 => Name::new_symbol_root(sym::rust_2018),
             Edition::Edition2021 => Name::new_symbol_root(sym::rust_2021),
             Edition::Edition2024 => Name::new_symbol_root(sym::rust_2024),
         };
-
         let path_kind = match self.def_map.data.edition {
             Edition::Edition2015 => PathKind::Plain,
             _ => PathKind::Abs,
             path_kind,
             [krate, Name::new_symbol_root(sym::prelude), edition],
         );
-
         let (per_ns, _) = self.def_map.resolve_path(
             self.crate_local_def_map.unwrap_or(&self.local_def_map),
             self.db,
             BuiltinShadowMode::Other,
             None,
         );
-
         match per_ns.types {
             Some(Item { def: ModuleDefId::ModuleId(m), import, .. }) => {
                 self.def_map.prelude = Some((m, import.and_then(ImportOrExternCrate::use_)));
     /// use a dummy expander that always errors. This comes with the drawback of macros potentially
     /// going out of sync with what the build system sees (since we resolve using VFS state, but
     /// Cargo builds only on-disk files). We could and probably should add diagnostics for that.
-    fn export_proc_macro(&mut self, def: ProcMacroDef, ast_id: AstId<ast::Fn>, fn_id: FunctionId) {
+    fn export_proc_macro(
+        &mut self,
+        def: ProcMacroDef,
+        ast_id: AstId<ast::Fn>,
+        fn_id: FunctionId,
+    ) {
         let kind = def.kind.to_basedb_kind();
         let (expander, kind) = match self.proc_macros.iter().find(|(n, _, _)| n == &def.name) {
             Some(_)
             Some(&(_, expander, false)) => (expander, kind),
             None => (CustomProcMacroExpander::missing_expander(), kind),
         };
-
         let proc_macro_id = ProcMacroLoc {
             container: self.def_map.crate_root(),
             id: ast_id,
             edition: self.def_map.data.edition,
         }
         .intern(self.db);
-
         self.def_map.macro_def_to_macro_id.insert(ast_id.erase(), proc_macro_id.into());
         self.define_proc_macro(def.name.clone(), proc_macro_id);
         let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();
     ) {
         // Textual scoping
         self.define_legacy_macro(module_id, name.clone(), macro_.into());
-
         // Module scoping
         // In Rust, `#[macro_export]` macros are unconditionally visible at the
         // crate root, even if the parent modules is **not** visible.
     /// the definition of current module.
     /// And also, `macro_use` on a module will import all legacy macros visible inside to
     /// current legacy scope, with possible shadowing.
-    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroId) {
+    fn define_legacy_macro(
+        &mut self,
+        module_id: LocalModuleId,
+        name: Name,
+        mac: MacroId,
+    ) {
         // Always shadowing
         self.def_map.modules[module_id].scope.define_legacy_macro(name, mac);
     }
     ///
     /// A proc macro is similar to normal macro scope, but it would not visible in legacy textual scoped.
     /// And unconditionally exported.
-    fn define_proc_macro(&mut self, name: Name, macro_: ProcMacroId) {
+    fn define_proc_macro(
+        &mut self,
+        name: Name,
+        macro_: ProcMacroId,
+    ) {
         let module_id = DefMap::ROOT;
         self.def_map.modules[module_id].scope.declare(macro_.into());
         self.update(
     fn resolve_imports(&mut self) -> ReachedFixedPoint {
         let mut res = ReachedFixedPoint::Yes;
         let imports = mem::take(&mut self.unresolved_imports);
-
         self.unresolved_imports = imports
             .into_iter()
             .filter_map(|mut directive| {
                 }
             })
             .collect();
-
         // Resolve all indeterminate resolved imports again
         // As some of the macros will expand newly import shadowing partial resolved imports
         // FIXME: We maybe could skip this, if we handle the indeterminate imports in `resolve_imports`
             }
         });
         self.indeterminate_imports = indeterminate_imports;
-
         res
     }
 
-    fn resolve_import(&self, module_id: LocalModuleId, import: &Import) -> PartialResolvedImport {
+    fn resolve_import(
+        &self,
+        module_id: LocalModuleId,
+        import: &Import,
+    ) -> PartialResolvedImport {
         let _p = tracing::info_span!("resolve_import", import_path = %import.path.display(self.db, Edition::LATEST))
             .entered();
         tracing::debug!("resolving import: {:?} ({:?})", import, self.def_map.data.edition);
                 BuiltinShadowMode::Module,
                 None, // An import may resolve to any kind of macro.
             );
-
         if reached_fixedpoint == ReachedFixedPoint::No
             || resolved_def.is_none()
             || segment_index.is_some()
         {
             return PartialResolvedImport::Unresolved;
         }
-
         if prefix_info.differing_crate {
             return PartialResolvedImport::Resolved(
                 resolved_def.filter_visibility(|v| matches!(v, Visibility::Public)),
             );
         }
-
         // Check whether all namespaces are resolved.
         if resolved_def.is_full() {
             PartialResolvedImport::Resolved(resolved_def)
         }
     }
 
-    fn record_resolved_import(&mut self, directive: &ImportDirective) {
+    fn record_resolved_import(
+        &mut self,
+        directive: &ImportDirective,
+    ) {
         let _p = tracing::info_span!("record_resolved_import").entered();
-
         let module_id = directive.module_id;
         let import = &directive.import;
         let mut def = directive.status.namespaces();
                 false,
             )
             .unwrap_or(Visibility::Public);
-
         match import.source {
             ImportSource {
                 kind: kind @ (ImportKind::Plain | ImportKind::TypeOnly),
 
     fn update(
         &mut self,
-        // The module for which `resolutions` have been resolve
         module_id: LocalModuleId,
         resolutions: &[(Option<Name>, PerNs)],
-        // Visibility this import will have
         vis: Visibility,
         import: Option<ImportOrExternCrate>,
     ) {
 
     fn update_recursive(
         &mut self,
-        // The module for which `resolutions` have been resolved.
         module_id: LocalModuleId,
         resolutions: &[(Option<Name>, PerNs)],
-        // All resolutions are imported with this visibility; the visibilities in
-        // the `PerNs` values are ignored and overwritten
         vis: Visibility,
         import: Option<ImportOrExternCrate>,
         depth: usize,
             panic!("infinite recursion in glob imports!");
         }
         let mut changed = false;
-
         for (name, res) in resolutions {
             match name {
                 Some(name) => {
                 }
             }
         }
-
         if !changed {
             return;
         }
             })
             .cloned()
             .collect::<Vec<_>>();
-
         for (glob_importing_module, glob_import_vis, glob) in glob_imports {
             let vis = glob_import_vis.min(vis, &self.def_map).unwrap_or(glob_import_vis);
             self.update_recursive(
         if let Some(def) = defs.macros.as_mut() {
             def.vis = def.vis.min(vis, &self.def_map).unwrap_or(vis);
         }
-
         let mut changed = false;
-
         if let Some(ImportOrExternCrate::Glob(_)) = def_import_type {
             let prev_defs = self.def_map[module_id].scope.get(name);
 
                 self.def_map.modules[module_id].scope.update_visibility_macros(name, def.vis);
             }
         }
-
         changed |= self.def_map.modules[module_id].scope.push_res_with_import(
             &mut self.from_glob_import,
             (module_id, name.clone()),
             defs,
             def_import_type,
         );
-
         changed
     }
 
         let mut push_resolved = |directive: &MacroDirective<'_>, call_id| {
             resolved.push((directive.module_id, directive.depth, directive.container, call_id));
         };
-
         #[derive(PartialEq, Eq)]
         enum Resolved {
             Yes,
             No,
         }
-
         let mut eager_callback_buffer = vec![];
         let mut res = ReachedFixedPoint::Yes;
         // Retain unresolved macros after this round of resolution.
         // Attribute resolution can add unresolved macro invocations, so concatenate the lists.
         macros.extend(mem::take(&mut self.unresolved_macros));
         self.unresolved_macros = macros;
-
         for (module_id, ptr, call_id) in eager_callback_buffer {
             self.def_map.modules[module_id].scope.add_macro_invoc(ptr.map(|(_, it)| it), call_id);
         }
-
         for (module_id, depth, container, macro_call_id) in resolved {
             self.collect_macro_expansion(module_id, macro_call_id, depth, container);
         }
-
         res
     }
 
             return;
         }
         let file_id = macro_call_id.into();
-
         let item_tree = self.db.file_item_tree(file_id);
-
         let mod_dir = if macro_call_id.is_include_macro(self.db) {
             ModDir::root()
         } else {
             self.mod_dirs[&module_id].clone()
         };
-
         ModCollector {
             def_collector: &mut *self,
             macro_depth: depth,
     fn finish(mut self) -> (DefMap, LocalDefMap) {
         // Emit diagnostics for all remaining unexpanded macros.
         let _p = tracing::info_span!("DefCollector::finish").entered();
-
         for directive in &self.unresolved_macros {
             match &directive.kind {
                 MacroDirectiveKind::FnLike { ast_id, expand_to, ctxt: call_site } => {
                 MacroDirectiveKind::Attr { .. } => {}
             }
         }
-
         // Emit diagnostics for all remaining unresolved imports.
         for import in &self.unresolved_imports {
             let &ImportDirective {
                 use_tree,
             ));
         }
-
         (self.def_map, self.local_def_map)
     }
 }
 }
 
 impl ModCollector<'_, '_> {
-    fn collect_in_top_module(&mut self, items: &[ModItemId]) {
+    fn collect_in_top_module(
+        &mut self,
+        items: &[ModItemId],
+    ) {
         let module = self.def_collector.def_map.module_id(self.module_id);
         self.collect(items, module.into())
     }
 
-    fn collect(&mut self, items: &[ModItemId], container: ItemContainerId) {
+    fn collect(
+        &mut self,
+        items: &[ModItemId],
+        container: ItemContainerId,
+    ) {
         let krate = self.def_collector.def_map.krate;
         let is_crate_root =
             self.module_id == DefMap::ROOT && self.def_collector.def_map.block.is_none();
-
         // Note: don't assert that inserted value is fresh: it's simply not true
         // for macros.
         self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());
-
         // Prelude module is always considered to be `#[macro_use]`.
         if let Some((prelude_module, _use)) = self.def_collector.def_map.prelude {
             // Don't insert macros from the prelude into blocks, as they can be shadowed by other macros.
                 .resolve_visibility(local_def_map, db, module_id, visibility, false)
                 .unwrap_or(Visibility::Public)
         };
-
         let mut process_mod_item = |item: ModItemId| {
             let attrs = self.item_tree.attrs(db, krate, item.ast_id());
             if let Some(cfg) = attrs.cfg()
                 }
             }
         };
-
         // extern crates should be processed eagerly instead of deferred to resolving.
         // `#[macro_use] extern crate` is hoisted to imports macros before collecting
         // any other items.
                 }
             }
         }
-
         self.def_collector.import_macros_from_extern_crate(
             target_crate,
             Some(single_imports),
         );
     }
 
-    fn collect_module(&mut self, module_ast_id: ItemTreeAstId<Mod>, attrs: &Attrs) {
+    fn collect_module(
+        &mut self,
+        module_ast_id: ItemTreeAstId<Mod>,
+        attrs: &Attrs,
+    ) {
         let path_attr = attrs.by_key(sym::path).string_value_unescape();
         let is_macro_use = attrs.by_key(sym::macro_use).exists();
         let module = &self.item_tree[module_ast_id];
                 declaration_tree_id: self.tree_id,
             },
         };
-
         let modules = &mut def_map.modules;
         let res = modules.alloc(ModuleData::new(origin, vis));
         modules[res].parent = Some(self.module_id);
-
         if let Some((target, source)) = Self::borrow_modules(modules.as_mut(), res, self.module_id)
         {
             for (name, macs) in source.scope.legacy_macros() {
             }
         }
         modules[self.module_id].children.insert(name.clone(), res);
-
         let module = def_map.module_id(res);
         let def = ModuleDefId::from(module);
-
         def_map.modules[self.module_id].scope.declare(def);
         self.def_collector.update(
             self.module_id,
                 Some(_) => true,
                 None => false,
             });
-
         for attr in iter {
             if self.def_collector.def_map.is_builtin_or_registered_attr(&attr.path) {
                 continue;
 
             return Err(());
         }
-
         Ok(())
     }
 
-    fn collect_macro_rules(&mut self, ast_id: ItemTreeAstId<MacroRules>, module: ModuleId) {
+    fn collect_macro_rules(
+        &mut self,
+        ast_id: ItemTreeAstId<MacroRules>,
+        module: ModuleId,
+    ) {
         let krate = self.def_collector.def_map.krate;
         let mac = &self.item_tree[ast_id];
         let attrs = self.item_tree.attrs(self.def_collector.db, krate, ast_id.upcast());
         let f_ast_id = InFile::new(self.file_id(), ast_id.upcast());
-
         let export_attr = || attrs.by_key(sym::macro_export);
-
         let is_export = export_attr().exists();
         let local_inner = if is_export {
             export_attr().tt_values().flat_map(|it| it.iter()).any(|it| match it {
         } else {
             false
         };
-
         // Case 1: builtin macros
         let expander = if attrs.by_key(sym::rustc_builtin_macro).exists() {
             // `#[rustc_builtin_macro = "builtin_name"]` overrides the `macro_rules!` name.
             MacroExpander::Declarative
         };
         let allow_internal_unsafe = attrs.by_key(sym::allow_internal_unsafe).exists();
-
         let mut flags = MacroRulesLocFlags::empty();
         flags.set(MacroRulesLocFlags::LOCAL_INNER, local_inner);
         flags.set(MacroRulesLocFlags::ALLOW_INTERNAL_UNSAFE, allow_internal_unsafe);
-
         let macro_id = MacroRulesLoc {
             container: module,
             id: InFile::new(self.file_id(), ast_id),
         );
     }
 
-    fn collect_macro_def(&mut self, ast_id: ItemTreeAstId<Macro2>, module: ModuleId) {
+    fn collect_macro_def(
+        &mut self,
+        ast_id: ItemTreeAstId<Macro2>,
+        module: ModuleId,
+    ) {
         let krate = self.def_collector.def_map.krate;
         let mac = &self.item_tree[ast_id];
         let attrs = self.item_tree.attrs(self.def_collector.db, krate, ast_id.upcast());
         let f_ast_id = InFile::new(self.file_id(), ast_id.upcast());
-
         // Case 1: builtin macros
         let mut helpers_opt = None;
         let expander = if attrs.by_key(sym::rustc_builtin_macro).exists() {
             MacroExpander::Declarative
         };
         let allow_internal_unsafe = attrs.by_key(sym::allow_internal_unsafe).exists();
-
         let macro_id = Macro2Loc {
             container: module,
             id: InFile::new(self.file_id(), ast_id),
         let &MacroCall { ref path, expand_to, ctxt } = &self.item_tree[ast_id];
         let ast_id = AstIdWithPath::new(self.file_id(), ast_id, path.clone());
         let db = self.def_collector.db;
-
         // FIXME: Immediately expanding in "Case 1" is insufficient since "Case 2" may also define
         // new legacy macros that create textual scopes. We need a way to resolve names in textual
         // scopes without eager expansion.
-
         let mut eager_callback_buffer = vec![];
         // Case 1: try to resolve macro calls with single-segment name and expand macro_rules
         if let Ok(res) = macro_call_as_call_id(
                 return;
             }
         }
-
         // Case 2: resolve in module scope, expand during name resolution.
         self.def_collector.unresolved_macros.push(MacroDirective {
             module_id: self.module_id,
         });
     }
 
-    fn import_all_legacy_macros(&mut self, module_id: LocalModuleId) {
+    fn import_all_legacy_macros(
+        &mut self,
+        module_id: LocalModuleId,
+    ) {
         let Some((source, target)) = Self::borrow_modules(
             self.def_collector.def_map.modules.as_mut(),
             module_id,
         ) else {
             return;
         };
-
         for (name, macs) in source.scope.legacy_macros() {
             if let Some(&mac) = macs.last() {
                 target.scope.define_legacy_macro(name.clone(), mac);
     ) -> Option<(&mut ModuleData, &mut ModuleData)> {
         let a = a.into_raw().into_u32() as usize;
         let b = b.into_raw().into_u32() as usize;
-
         let (a, b) = match a.cmp(&b) {
             Ordering::Equal => return None,
             Ordering::Less => {
         Some((a, b))
     }
 
-    fn is_cfg_enabled(&self, cfg: &CfgExpr) -> bool {
+    fn is_cfg_enabled(
+        &self,
+        cfg: &CfgExpr,
+    ) -> bool {
         self.def_collector.cfg_options.check(cfg) != Some(false)
     }
 
-    fn emit_unconfigured_diagnostic(&mut self, ast_id: ErasedAstId, cfg: &CfgExpr) {
+    fn emit_unconfigured_diagnostic(
+        &mut self,
+        ast_id: ErasedAstId,
+        cfg: &CfgExpr,
+    ) {
         self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(
             self.module_id,
             ast_id,
 #[cfg(test)]
 mod tests {
     use test_fixture::WithFixture;
-
     use crate::{nameres::DefMapCrateData, test_db::TestDB};
-
     use super::*;
-
-    fn do_collect_defs(db: &dyn DefDatabase, def_map: DefMap) -> DefMap {
+    fn do_collect_defs(
+        db: &dyn DefDatabase,
+        def_map: DefMap,
+    ) -> DefMap {
         let mut collector = DefCollector {
             db,
             def_map,
         collector.collect();
         collector.def_map
     }
-
     fn do_resolve(not_ra_fixture: &str) -> DefMap {
         let (db, file_id) = TestDB::with_single_file(not_ra_fixture);
         let krate = db.test_crate();
-
         let edition = krate.data(&db).edition;
         let module_origin = ModuleOrigin::CrateRoot { definition: file_id };
         let def_map = DefMap::empty(
         );
         do_collect_defs(&db, def_map)
     }
-
     #[test]
     fn test_macro_expand_will_stop_1() {
         do_resolve(
 "#,
         );
     }
-
     #[ignore]
     #[test]
     fn test_macro_expand_will_stop_2() {