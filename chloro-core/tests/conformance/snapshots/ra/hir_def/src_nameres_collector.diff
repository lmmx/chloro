COMPARISON DIFF
============================================================

Original size: 108302 bytes
Chloro size:   107967 bytes
Rustfmt size:  108302 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     AdtId, AssocItemId, AstId, AstIdWithPath, ConstLoc, CrateRootModuleId, EnumLoc, ExternBlockLoc,
     ExternCrateId, ExternCrateLoc, FunctionId, FunctionLoc, FxIndexMap, ImplLoc, Intern,
-    ItemContainerId, LocalModuleId, Lookup, Macro2Id, Macro2Loc, MacroExpander, MacroId,
-    MacroRulesId, MacroRulesLoc, MacroRulesLocFlags, ModuleDefId, ModuleId, ProcMacroId,
-    ProcMacroLoc, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro, UseId,
-    UseLoc,
+    ItemContainerId, LocalModuleId, Lookup, MacroExpander, MacroId, MacroRulesId, MacroRulesLoc,
+    MacroRulesLocFlags, Macro2Id, Macro2Loc, ModuleDefId, ModuleId, ProcMacroId, ProcMacroLoc,
+    StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro, UseId, UseLoc,
     attr::Attrs,
     db::DefDatabase,
     item_scope::{GlobId, ImportId, ImportOrExternCrate, PerNsGlobImports},
     item_tree::{
-        self, FieldsShape, ImportAlias, ImportKind, ItemTree, ItemTreeAstId, Macro2, MacroCall,
-        MacroRules, Mod, ModItemId, ModKind, TreeId,
+        self, FieldsShape, ImportAlias, ImportKind, ItemTree, ItemTreeAstId, MacroCall,
+        MacroRules, Macro2, Mod, ModItemId, ModKind, TreeId,
     },
     macro_call_as_call_id,
     nameres::{
         BuiltinShadowMode, DefMap, LocalDefMap, MacroSubNs, ModuleData, ModuleOrigin, ResolveMode,
-        assoc::TraitItems,
-        attr_resolution::{attr_macro_as_call_id, derive_macro_as_call_id},
-        crate_def_map,
-        diagnostics::DefDiagnostic,
-        mod_resolution::ModDir,
+        assoc::TraitItems, attr_resolution::{attr_macro_as_call_id, derive_macro_as_call_id},
+        crate_def_map, diagnostics::DefDiagnostic, mod_resolution::ModDir,
         path_resolution::{ReachedFixedPoint, ResolvePathResult},
         proc_macro::{ProcMacroDef, ProcMacroKind, parse_macro_name_and_helper_attrs},
         sub_namespace_match,
 };
 
 const GLOB_RECURSION_LIMIT: usize = 100;
+
 const FIXED_POINT_LIMIT: usize = 8192;
 
 pub(super) fn collect_defs(
     let cfg_options = def_map.krate.cfg_options(db);
 
     // populate external prelude and dependency list
+
     let mut deps =
         FxIndexMap::with_capacity_and_hasher(krate.dependencies.len(), Default::default());
     for dep in &krate.dependencies {
         ast_id: AstIdWithPath<ast::Item>,
         attr: Attr,
         mod_item: ModItemId,
-        /* is this needed? */ tree: TreeId,
+        /* is this needed? */
+        tree: TreeId,
         item_tree: &'db ItemTree,
     },
 }
     proc_macros: Box<[(Name, CustomProcMacroExpander, bool)]>,
     is_proc_macro: bool,
     from_glob_import: PerNsGlobImports,
+    // FIXME: There has to be a better way to do this
     /// If we fail to resolve an attribute on a `ModItem`, we fall back to ignoring the attribute.
     /// This map is used to skip all attributes up to and including the one that failed to resolve,
     /// in order to not expand them twice.
     ///
     /// This also stores the attributes to skip when we resolve derive helpers and non-macro
     /// non-builtin attributes in general.
-    // FIXME: There has to be a better way to do this
     skip_attrs: FxHashMap<InFile<FileAstId<ast::Item>>, AttrId>,
 }
 
         let mut process = true;
 
         // Process other crate-level attributes.
+
         for attr in &*attrs {
             if let Some(cfg) = attr.cfg()
                 && self.cfg_options.check(&cfg) == Some(false)
             .is_none_or(|cfg| self.cfg_options.check(&cfg) != Some(false));
         if is_cfg_enabled {
             self.inject_prelude();
-
             ModCollector {
                 def_collector: self,
                 macro_depth: 0,
         let _p = tracing::info_span!("DefCollector::resolution_loop").entered();
 
         // main name resolution fixed-point loop.
+
         let mut i = 0;
         'resolve_attr: loop {
             let _p = tracing::info_span!("resolve_macros loop").entered();
                     break 'resolve_attr;
                 }
             }
-
             if self.reseed_with_unresolved_attribute() == ReachedFixedPoint::Yes {
                 break 'resolve_attr;
             }
                 item_tree,
             )) => {
                 // FIXME: Remove this clone
+                // Continue name resolution with the new data.
                 let mod_dir = self.mod_dirs[&module_id].clone();
                 ModCollector {
                     def_collector: self,
                     mod_dir,
                 }
                 .collect(&[mod_item], container);
-
                 self.unresolved_macros.swap_remove(pos);
-                // Continue name resolution with the new data.
                 ReachedFixedPoint::No
             }
             None => ReachedFixedPoint::Yes,
         self.define_legacy_macro(module_id, name.clone(), macro_.into());
 
         // Module scoping
+
         // In Rust, `#[macro_export]` macros are unconditionally visible at the
+
         // crate root, even if the parent modules is **not** visible.
+
         if export {
             let module_id = DefMap::ROOT;
             self.def_map.modules[module_id].scope.declare(macro_.into());
             .collect();
 
         // Resolve all indeterminate resolved imports again
+
         // As some of the macros will expand newly import shadowing partial resolved imports
+
         // FIXME: We maybe could skip this, if we handle the indeterminate imports in `resolve_imports`
+
         // correctly
+
         let mut indeterminate_imports = std::mem::take(&mut self.indeterminate_imports);
         indeterminate_imports.retain_mut(|(directive, partially_resolved)| {
             let partially_resolved = partially_resolved.availability();
         }
 
         // Check whether all namespaces are resolved.
+
         if resolved_def.is_full() {
             PartialResolvedImport::Resolved(resolved_def)
         } else {
                 use_tree,
                 ..
             } => {
+                // `extern crate crate_name` things can be re-exported as `pub use crate_name`.
+                // But they cannot be re-exported as `pub use self::crate_name`, `pub use crate::crate_name`
+                // or `pub use ::crate_name`.
+                //
+                // This has been historically allowed, but may be not allowed in future
+                // https://github.com/rust-lang/rust/issues/127909
                 let name = match &import.alias {
                     Some(ImportAlias::Alias(name)) => Some(name),
                     Some(ImportAlias::Underscore) => None,
                         }
                     },
                 };
-
                 if kind == ImportKind::TypeOnly {
                     def.values = None;
                     def.macros = None;
                 }
                 let imp = ImportOrExternCrate::Import(ImportId { use_: id, idx: use_tree });
                 tracing::debug!("resolved import {:?} ({:?}) to {:?}", name, import, def);
-
-                // `extern crate crate_name` things can be re-exported as `pub use crate_name`.
-                // But they cannot be re-exported as `pub use self::crate_name`, `pub use crate::crate_name`
-                // or `pub use ::crate_name`.
-                //
-                // This has been historically allowed, but may be not allowed in future
-                // https://github.com/rust-lang/rust/issues/127909
                 if let Some(def) = def.types.as_mut() {
                     let is_extern_crate_reimport_without_prefix = || {
                         let Some(ImportOrExternCrate::ExternCrate(_)) = def.import else {
                         def.vis = vis;
                     }
                 }
-
                 self.update(module_id, &[(name.cloned(), def)], vis, Some(imp));
             }
             ImportSource { kind: ImportKind::Glob, id, is_prelude, use_tree, .. } => {
                             cov_mark::hit!(std_prelude);
                             self.def_map.prelude = Some((m, Some(id)));
                         } else if m.krate != self.def_map.krate {
-                            cov_mark::hit!(glob_across_crates);
                             // glob import from other crate => we can just import everything once
+                            // Module scoped macros is included
+                            cov_mark::hit!(glob_across_crates);
                             let item_map = m.def_map(self.db);
                             let scope = &item_map[m.local_id].scope;
-
-                            // Module scoped macros is included
                             let items = scope
                                 .resolutions()
                                 // only keep visible names...
                                 })
                                 .filter(|(_, res)| !res.is_none())
                                 .collect::<Vec<_>>();
-
                             self.update(
                                 module_id,
                                 &items,
                             // glob import from same crate => we do an initial
                             // import, and then need to propagate any further
                             // additions
+                            // Module scoped macros is included
+                            // record the glob import in case we add further items
                             let def_map;
                             let scope = if m.block == self.def_map.block_id() {
                                 &self.def_map[m.local_id].scope
                                 def_map = m.def_map(self.db);
                                 &def_map[m.local_id].scope
                             };
-
-                            // Module scoped macros is included
                             let items = scope
                                 .resolutions()
                                 // only keep visible names...
                                 })
                                 .filter(|(_, res)| !res.is_none())
                                 .collect::<Vec<_>>();
-
                             self.update(
                                 module_id,
                                 &items,
                                 vis,
                                 Some(ImportOrExternCrate::Glob(glob)),
                             );
-                            // record the glob import in case we add further items
                             let glob_imports = self.glob_imports.entry(m.local_id).or_default();
                             match glob_imports.iter_mut().find(|(mid, _, _)| *mid == module_id) {
                                 None => glob_imports.push((module_id, vis, glob)),
                         }
                     }
                     Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {
-                        cov_mark::hit!(glob_enum);
                         // glob import from enum => just import all the variants
+                        cov_mark::hit!(glob_enum);
                         let resolutions = e
                             .enum_variants(self.db)
                             .variants
 
     fn update(
         &mut self,
-        // The module for which `resolutions` have been resolve
         module_id: LocalModuleId,
         resolutions: &[(Option<Name>, PerNs)],
-        // Visibility this import will have
         vis: Visibility,
         import: Option<ImportOrExternCrate>,
     ) {
 
     fn update_recursive(
         &mut self,
-        // The module for which `resolutions` have been resolved.
         module_id: LocalModuleId,
         resolutions: &[(Option<Name>, PerNs)],
-        // All resolutions are imported with this visibility; the visibilities in
-        // the `PerNs` values are ignored and overwritten
         vis: Visibility,
         import: Option<ImportOrExternCrate>,
         depth: usize,
         }
 
         // Emit diagnostics for all remaining unresolved imports.
+
         for import in &self.unresolved_imports {
             let &ImportDirective {
                 module_id,
             self.module_id == DefMap::ROOT && self.def_collector.def_map.block.is_none();
 
         // Note: don't assert that inserted value is fresh: it's simply not true
+
         // for macros.
+
         self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());
 
         // Prelude module is always considered to be `#[macro_use]`.
+
         if let Some((prelude_module, _use)) = self.def_collector.def_map.prelude {
             // Don't insert macros from the prelude into blocks, as they can be shadowed by other macros.
             if prelude_module.krate != krate && is_crate_root {
         };
 
         // extern crates should be processed eagerly instead of deferred to resolving.
+
         // `#[macro_use] extern crate` is hoisted to imports macros before collecting
+
         // any other items.
+
         if is_crate_root {
             items
                 .iter()
                     None,
                     &self.item_tree[module.visibility],
                 );
-
                 let Some(mod_dir) =
                     self.mod_dir.descend_into_definition(&module.name, path_attr.as_deref())
                 else {
         };
 
         // Case 1: builtin macros
+
         let expander = if attrs.by_key(sym::rustc_builtin_macro).exists() {
             // `#[rustc_builtin_macro = "builtin_name"]` overrides the `macro_rules!` name.
             let name;
         let f_ast_id = InFile::new(self.file_id(), ast_id.upcast());
 
         // Case 1: builtin macros
+
         let mut helpers_opt = None;
         let expander = if attrs.by_key(sym::rustc_builtin_macro).exists() {
             if let Some(expander) = find_builtin_macro(&mac.name) {
             &self.item_tree[mac.visibility],
         );
         if let Some(helpers) = helpers_opt
-            && self.def_collector.def_map.block.is_none()
-        {
+            && self.def_collector.def_map.block.is_none() {
             Arc::get_mut(&mut self.def_collector.def_map.data)
                 .unwrap()
                 .exported_derives
         let db = self.def_collector.db;
 
         // FIXME: Immediately expanding in "Case 1" is insufficient since "Case 2" may also define
+
         // new legacy macros that create textual scopes. We need a way to resolve names in textual
+
         // scopes without eager expansion.
 
         let mut eager_callback_buffer = vec![];
         }
 
         // Case 2: resolve in module scope, expand during name resolution.
+
         self.def_collector.unresolved_macros.push(MacroDirective {
             module_id: self.module_id,
             depth: self.macro_depth + 1,
 #[cfg(test)]
 mod tests {
     use test_fixture::WithFixture;
-
     use crate::{nameres::DefMapCrateData, test_db::TestDB};
-
     use super::*;
-
     fn do_collect_defs(db: &dyn DefDatabase, def_map: DefMap) -> DefMap {
         let mut collector = DefCollector {
             db,
         collector.collect();
         collector.def_map
     }
-
     fn do_resolve(not_ra_fixture: &str) -> DefMap {
         let (db, file_id) = TestDB::with_single_file(not_ra_fixture);
         let krate = db.test_crate();
         );
         do_collect_defs(&db, def_map)
     }
-
     #[test]
     fn test_macro_expand_will_stop_1() {
         do_resolve(
 "#,
         );
     }
-
     #[ignore]
     #[test]
     fn test_macro_expand_will_stop_2() {