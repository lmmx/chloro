COMPARISON DIFF
============================================================

Original size: 108302 bytes
Chloro size:   107961 bytes
Rustfmt size:  112798 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     AdtId, AssocItemId, AstId, AstIdWithPath, ConstLoc, CrateRootModuleId, EnumLoc, ExternBlockLoc,
     ExternCrateId, ExternCrateLoc, FunctionId, FunctionLoc, FxIndexMap, ImplLoc, Intern,
-    ItemContainerId, LocalModuleId, Lookup, Macro2Id, Macro2Loc, MacroExpander, MacroId,
-    MacroRulesId, MacroRulesLoc, MacroRulesLocFlags, ModuleDefId, ModuleId, ProcMacroId,
-    ProcMacroLoc, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro, UseId,
-    UseLoc,
+    ItemContainerId, LocalModuleId, Lookup, MacroExpander, MacroId, MacroRulesId, MacroRulesLoc,
+    MacroRulesLocFlags, Macro2Id, Macro2Loc, ModuleDefId, ModuleId, ProcMacroId, ProcMacroLoc,
+    StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro, UseId, UseLoc,
     attr::Attrs,
     db::DefDatabase,
     item_scope::{GlobId, ImportId, ImportOrExternCrate, PerNsGlobImports},
     item_tree::{
-        self, FieldsShape, ImportAlias, ImportKind, ItemTree, ItemTreeAstId, Macro2, MacroCall,
-        MacroRules, Mod, ModItemId, ModKind, TreeId,
+        self, FieldsShape, ImportAlias, ImportKind, ItemTree, ItemTreeAstId, MacroCall,
+        MacroRules, Macro2, Mod, ModItemId, ModKind, TreeId,
     },
     macro_call_as_call_id,
     nameres::{
         BuiltinShadowMode, DefMap, LocalDefMap, MacroSubNs, ModuleData, ModuleOrigin, ResolveMode,
-        assoc::TraitItems,
-        attr_resolution::{attr_macro_as_call_id, derive_macro_as_call_id},
-        crate_def_map,
-        diagnostics::DefDiagnostic,
-        mod_resolution::ModDir,
+        assoc::TraitItems, attr_resolution::{attr_macro_as_call_id, derive_macro_as_call_id},
+        crate_def_map, diagnostics::DefDiagnostic, mod_resolution::ModDir,
         path_resolution::{ReachedFixedPoint, ResolvePathResult},
         proc_macro::{ProcMacroDef, ProcMacroKind, parse_macro_name_and_helper_attrs},
         sub_namespace_match,
 };
 
 const GLOB_RECURSION_LIMIT: usize = 100;
+
 const FIXED_POINT_LIMIT: usize = 8192;
 
 pub(super) fn collect_defs(
                 path,
                 alias,
                 visibility: visibility.clone(),
-                source: ImportSource {
-                    use_tree: idx,
-                    id,
-                    is_prelude,
-                    kind,
-                },
+                source: ImportSource { use_tree: idx, id, is_prelude, kind },
             });
         });
     }
         ast_id: AstIdWithPath<ast::Item>,
         attr: Attr,
         mod_item: ModItemId,
-        /* is this needed? */ tree: TreeId,
+        /* is this needed? */
+        tree: TreeId,
         item_tree: &'db ItemTree,
     },
 }
     proc_macros: Box<[(Name, CustomProcMacroExpander, bool)]>,
     is_proc_macro: bool,
     from_glob_import: PerNsGlobImports,
+    // FIXME: There has to be a better way to do this
     /// If we fail to resolve an attribute on a `ModItem`, we fall back to ignoring the attribute.
     /// This map is used to skip all attributes up to and including the one that failed to resolve,
     /// in order to not expand them twice.
     ///
     /// This also stores the attributes to skip when we resolve derive helpers and non-macro
     /// non-builtin attributes in general.
-    // FIXME: There has to be a better way to do this
     skip_attrs: FxHashMap<InFile<FileAstId<ast::Item>>, AttrId>,
 }
 
                 process = false;
                 break;
             }
-            let Some(attr_name) = attr.path.as_ident() else {
-                continue;
-            };
+            let Some(attr_name) = attr.path.as_ident() else { continue };
 
             match () {
                 () if *attr_name == sym::recursion_limit => {
                     crate_data.rustc_coherence_is_core = true;
                 }
                 () if *attr_name == sym::feature => {
-                    let features = attr
-                        .parse_path_comma_token_tree(self.db)
-                        .into_iter()
-                        .flatten()
-                        .filter_map(|(feat, _)| match feat.segments() {
-                            [name] => Some(name.symbol().clone()),
-                            _ => None,
-                        });
+                    let features =
+                        attr.parse_path_comma_token_tree(self.db).into_iter().flatten().filter_map(
+                            |(feat, _)| match feat.segments() {
+                                [name] => Some(name.symbol().clone()),
+                                _ => None,
+                            },
+                        );
                     crate_data.unstable_features.extend(features);
                 }
                 () if *attr_name == sym::register_tool => {
                     continue;
                 }
 
-                self.local_def_map.extern_prelude.insert(
-                    name.clone(),
-                    (
-                        CrateRootModuleId {
-                            krate: dep.crate_id,
-                        },
-                        None,
-                    ),
-                );
+                self.local_def_map
+                    .extern_prelude
+                    .insert(name.clone(), (CrateRootModuleId { krate: dep.crate_id }, None));
             }
         }
 
             mod_dir: ModDir::root(),
         }
         .collect_in_top_module(item_tree.top_level_items());
-        Arc::get_mut(&mut self.def_map.data)
-            .unwrap()
-            .shrink_to_fit();
+        Arc::get_mut(&mut self.def_map.data).unwrap().shrink_to_fit();
     }
 
     fn seed_with_inner(&mut self, tree_id: TreeId) {
         cov_mark::hit!(unresolved_attribute_fallback);
 
         let unresolved_attr =
-            self.unresolved_macros
-                .iter()
-                .enumerate()
-                .find_map(|(idx, directive)| match &directive.kind {
-                    MacroDirectiveKind::Attr {
-                        ast_id,
-                        mod_item,
-                        attr,
-                        tree,
-                        item_tree,
-                    } => {
-                        self.def_map
-                            .diagnostics
-                            .push(DefDiagnostic::unresolved_macro_call(
-                                directive.module_id,
-                                MacroCallKind::Attr {
-                                    ast_id: ast_id.ast_id,
-                                    attr_args: None,
-                                    invoc_attr_index: attr.id,
-                                },
-                                attr.path().clone(),
-                            ));
+            self.unresolved_macros.iter().enumerate().find_map(|(idx, directive)| match &directive
+                .kind
+            {
+                MacroDirectiveKind::Attr { ast_id, mod_item, attr, tree, item_tree } => {
+                    self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(
+                        directive.module_id,
+                        MacroCallKind::Attr {
+                            ast_id: ast_id.ast_id,
+                            attr_args: None,
+                            invoc_attr_index: attr.id,
+                        },
+                        attr.path().clone(),
+                    ));
 
-                        self.skip_attrs
-                            .insert(ast_id.ast_id.with_value(mod_item.ast_id()), attr.id);
+                    self.skip_attrs.insert(ast_id.ast_id.with_value(mod_item.ast_id()), attr.id);
 
-                        Some((idx, directive, *mod_item, *tree, *item_tree))
-                    }
-                    _ => None,
-                });
+                    Some((idx, directive, *mod_item, *tree, *item_tree))
+                }
+                _ => None,
+            });
 
         match unresolved_attr {
             Some((
                 pos,
-                &MacroDirective {
-                    module_id,
-                    depth,
-                    container,
-                    ..
-                },
+                &MacroDirective { module_id, depth, container, .. },
                 mod_item,
                 tree_id,
                 item_tree,
 
     fn inject_prelude(&mut self) {
         // See compiler/rustc_builtin_macros/src/standard_library_imports.rs
-
         if self.def_map.data.no_core {
             // libcore does not get a prelude.
             return;
 
         let krate = if self.def_map.data.no_std {
             Name::new_symbol_root(sym::core)
-        } else if self
-            .local_def_map()
-            .extern_prelude()
-            .any(|(name, _)| *name == sym::std)
-        {
+        } else if self.local_def_map().extern_prelude().any(|(name, _)| *name == sym::std) {
             Name::new_symbol_root(sym::std)
         } else {
             // If `std` does not exist for some reason, fall back to core. This mostly helps
         );
 
         match per_ns.types {
-            Some(Item {
-                def: ModuleDefId::ModuleId(m),
-                import,
-                ..
-            }) => {
+            Some(Item { def: ModuleDefId::ModuleId(m), import, .. }) => {
                 self.def_map.prelude = Some((m, import.and_then(ImportOrExternCrate::use_)));
             }
             types => {
         }
         .intern(self.db);
 
-        self.def_map
-            .macro_def_to_macro_id
-            .insert(ast_id.erase(), proc_macro_id.into());
+        self.def_map.macro_def_to_macro_id.insert(ast_id.erase(), proc_macro_id.into());
         self.define_proc_macro(def.name.clone(), proc_macro_id);
         let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();
         if let ProcMacroKind::Derive { helpers } = def.kind {
-            crate_data
-                .exported_derives
-                .insert(proc_macro_id.into(), helpers);
+            crate_data.exported_derives.insert(proc_macro_id.into(), helpers);
         }
-        crate_data
-            .fn_proc_macro_mapping
-            .insert(fn_id, proc_macro_id);
+        crate_data.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);
     }
 
     /// Define a macro with `macro_rules`.
             self.def_map.modules[module_id].scope.declare(macro_.into());
             self.update(
                 module_id,
-                &[(
-                    Some(name),
-                    PerNs::macros(macro_.into(), Visibility::Public, None),
-                )],
+                &[(Some(name), PerNs::macros(macro_.into(), Visibility::Public, None))],
                 Visibility::Public,
                 None,
             );
     /// current legacy scope, with possible shadowing.
     fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroId) {
         // Always shadowing
-        self.def_map.modules[module_id]
-            .scope
-            .define_legacy_macro(name, mac);
+        self.def_map.modules[module_id].scope.define_legacy_macro(name, mac);
     }
 
     /// Define a macro 2.0 macro
         self.def_map.modules[module_id].scope.declare(macro_.into());
         self.update(
             module_id,
-            &[(
-                Some(name),
-                PerNs::macros(macro_.into(), Visibility::Public, None),
-            )],
+            &[(Some(name), PerNs::macros(macro_.into(), Visibility::Public, None))],
             vis,
             None,
         );
         self.def_map.modules[module_id].scope.declare(macro_.into());
         self.update(
             module_id,
-            &[(
-                Some(name),
-                PerNs::macros(macro_.into(), Visibility::Public, None),
-            )],
+            &[(Some(name), PerNs::macros(macro_.into(), Visibility::Public, None))],
             Visibility::Public,
             None,
         );
                 for name in names {
                     // FIXME: Report diagnostic on 404.
                     if let Some(def) = root_scope.get(&name).take_macros() {
-                        self.def_map
-                            .macro_use_prelude
-                            .insert(name, (def, extern_crate));
+                        self.def_map.macro_use_prelude.insert(name, (def, extern_crate));
                     }
                 }
             }
             None => {
                 for (name, it) in root_scope.macros() {
-                    self.def_map
-                        .macro_use_prelude
-                        .insert(name.clone(), (it.def, extern_crate));
+                    self.def_map.macro_use_prelude.insert(name.clone(), (it.def, extern_crate));
                 }
             }
         }
     fn resolve_import(&self, module_id: LocalModuleId, import: &Import) -> PartialResolvedImport {
         let _p = tracing::info_span!("resolve_import", import_path = %import.path.display(self.db, Edition::LATEST))
             .entered();
-        tracing::debug!(
-            "resolving import: {:?} ({:?})",
-            import,
-            self.def_map.data.edition
-        );
-        let ResolvePathResult {
-            resolved_def,
-            segment_index,
-            reached_fixedpoint,
-            prefix_info,
-        } = self.def_map.resolve_path_fp_with_macro(
-            self.crate_local_def_map.unwrap_or(&self.local_def_map),
-            self.db,
-            ResolveMode::Import,
-            module_id,
-            &import.path,
-            BuiltinShadowMode::Module,
-            None, // An import may resolve to any kind of macro.
-        );
+        tracing::debug!("resolving import: {:?} ({:?})", import, self.def_map.data.edition);
+        let ResolvePathResult { resolved_def, segment_index, reached_fixedpoint, prefix_info } =
+            self.def_map.resolve_path_fp_with_macro(
+                self.crate_local_def_map.unwrap_or(&self.local_def_map),
+                self.db,
+                ResolveMode::Import,
+                module_id,
+                &import.path,
+                BuiltinShadowMode::Module,
+                None, // An import may resolve to any kind of macro.
+            );
 
         if reached_fixedpoint == ReachedFixedPoint::No
             || resolved_def.is_none()
                     def.values = None;
                     def.macros = None;
                 }
-                let imp = ImportOrExternCrate::Import(ImportId {
-                    use_: id,
-                    idx: use_tree,
-                });
+                let imp = ImportOrExternCrate::Import(ImportId { use_: id, idx: use_tree });
                 tracing::debug!("resolved import {:?} ({:?}) to {:?}", name, import, def);
 
                 // `extern crate crate_name` things can be re-exported as `pub use crate_name`.
 
                 self.update(module_id, &[(name.cloned(), def)], vis, Some(imp));
             }
-            ImportSource {
-                kind: ImportKind::Glob,
-                id,
-                is_prelude,
-                use_tree,
-                ..
-            } => {
+            ImportSource { kind: ImportKind::Glob, id, is_prelude, use_tree, .. } => {
                 tracing::debug!("glob import: {:?}", import);
-                let glob = GlobId {
-                    use_: id,
-                    idx: use_tree,
-                };
+                let glob = GlobId { use_: id, idx: use_tree };
                 match def.take_types() {
                     Some(ModuleDefId::ModuleId(m)) => {
                         if is_prelude {
                                 .resolutions()
                                 // only keep visible names...
                                 .map(|(n, res)| {
-                                    (
-                                        n,
-                                        res.filter_visibility(|v| v.is_visible_from_other_crate()),
-                                    )
+                                    (n, res.filter_visibility(|v| v.is_visible_from_other_crate()))
                                 })
                                 .filter(|(_, res)| !res.is_none())
                                 .collect::<Vec<_>>();
                             );
                             // record the glob import in case we add further items
                             let glob_imports = self.glob_imports.entry(m.local_id).or_default();
-                            match glob_imports
-                                .iter_mut()
-                                .find(|(mid, _, _)| *mid == module_id)
-                            {
+                            match glob_imports.iter_mut().find(|(mid, _, _)| *mid == module_id) {
                                 None => glob_imports.push((module_id, vis, glob)),
                                 Some((_, old_vis, _)) => {
                                     if let Some(new_vis) = old_vis.max(vis, &self.def_map) {
 
     fn update(
         &mut self,
-        // The module for which `resolutions` have been resolve
         module_id: LocalModuleId,
         resolutions: &[(Option<Name>, PerNs)],
-        // Visibility this import will have
         vis: Visibility,
         import: Option<ImportOrExternCrate>,
     ) {
 
     fn update_recursive(
         &mut self,
-        // The module for which `resolutions` have been resolved.
         module_id: LocalModuleId,
         resolutions: &[(Option<Name>, PerNs)],
-        // All resolutions are imported with this visibility; the visibilities in
-        // the `PerNs` values are ignored and overwritten
         vis: Visibility,
         import: Option<ImportOrExternCrate>,
         depth: usize,
                 }
                 None => {
                     let (tr, import) = match res.take_types_full() {
-                        Some(Item {
-                            def: ModuleDefId::TraitId(tr),
-                            vis: _,
-                            import,
-                        }) => (tr, import),
+                        Some(Item { def: ModuleDefId::TraitId(tr), vis: _, import }) => {
+                            (tr, import)
+                        }
                         Some(other) => {
                             tracing::debug!("non-trait `_` import of {:?}", other);
                             continue;
             .collect::<Vec<_>>();
 
         for (glob_importing_module, glob_import_vis, glob) in glob_imports {
-            let vis = glob_import_vis
-                .min(vis, &self.def_map)
-                .unwrap_or(glob_import_vis);
+            let vis = glob_import_vis.min(vis, &self.def_map).unwrap_or(glob_import_vis);
             self.update_recursive(
                 glob_importing_module,
                 resolutions,
                 // This import is being handled here, don't pass it down to
                 // `ItemScope::push_res_with_import()`.
                 defs.types = None;
-                self.def_map.modules[module_id]
-                    .scope
-                    .update_visibility_types(name, def.vis);
+                self.def_map.modules[module_id].scope.update_visibility_types(name, def.vis);
             }
 
             if let Some(def) = defs.values
                 && let Some(prev_def) = prev_defs.values
                 && def.def == prev_def.def
-                && self
-                    .from_glob_import
-                    .contains_value(module_id, name.clone())
+                && self.from_glob_import.contains_value(module_id, name.clone())
                 && def.vis != prev_def.vis
                 && def.vis.max(prev_def.vis, &self.def_map) == Some(def.vis)
             {
                 changed = true;
                 // See comment above.
                 defs.values = None;
-                self.def_map.modules[module_id]
-                    .scope
-                    .update_visibility_values(name, def.vis);
+                self.def_map.modules[module_id].scope.update_visibility_values(name, def.vis);
             }
 
             if let Some(def) = defs.macros
                 && let Some(prev_def) = prev_defs.macros
                 && def.def == prev_def.def
-                && self
-                    .from_glob_import
-                    .contains_macro(module_id, name.clone())
+                && self.from_glob_import.contains_macro(module_id, name.clone())
                 && def.vis != prev_def.vis
                 && def.vis.max(prev_def.vis, &self.def_map) == Some(def.vis)
             {
                 changed = true;
                 // See comment above.
                 defs.macros = None;
-                self.def_map.modules[module_id]
-                    .scope
-                    .update_visibility_macros(name, def.vis);
+                self.def_map.modules[module_id].scope.update_visibility_macros(name, def.vis);
             }
         }
 
         let mut macros = mem::take(&mut self.unresolved_macros);
         let mut resolved = Vec::new();
         let mut push_resolved = |directive: &MacroDirective<'_>, call_id| {
-            resolved.push((
-                directive.module_id,
-                directive.depth,
-                directive.container,
-                call_id,
-            ));
+            resolved.push((directive.module_id, directive.depth, directive.container, call_id));
         };
 
         #[derive(PartialEq, Eq)]
                     BuiltinShadowMode::Module,
                     Some(subns),
                 );
-                resolved_res
-                    .resolved_def
-                    .take_macros()
-                    .map(|it| (it, self.db.macro_def(it)))
+                resolved_res.resolved_def.take_macros().map(|it| (it, self.db.macro_def(it)))
             };
             let resolver_def_id = |path: &_| resolver(path).map(|(_, it)| it);
 
             match &directive.kind {
-                MacroDirectiveKind::FnLike {
-                    ast_id,
-                    expand_to,
-                    ctxt: call_site,
-                } => {
+                MacroDirectiveKind::FnLike { ast_id, expand_to, ctxt: call_site } => {
                     let call_id = macro_call_as_call_id(
                         self.db,
                         ast_id.ast_id,
                     );
 
                     if let Ok((macro_id, def_id, call_id)) = id {
-                        self.def_map.modules[directive.module_id]
-                            .scope
-                            .set_derive_macro_invoc(
-                                ast_id.ast_id,
-                                call_id,
-                                *derive_attr,
-                                *derive_pos,
-                            );
+                        self.def_map.modules[directive.module_id].scope.set_derive_macro_invoc(
+                            ast_id.ast_id,
+                            call_id,
+                            *derive_attr,
+                            *derive_pos,
+                        );
                         // Record its helper attributes.
                         if def_id.krate != self.def_map.krate {
                             let def_map = crate_def_map(self.db, def_id.krate);
         self.unresolved_macros = macros;
 
         for (module_id, ptr, call_id) in eager_callback_buffer {
-            self.def_map.modules[module_id]
-                .scope
-                .add_macro_invoc(ptr.map(|(_, it)| it), call_id);
+            self.def_map.modules[module_id].scope.add_macro_invoc(ptr.map(|(_, it)| it), call_id);
         }
 
         for (module_id, depth, container, macro_call_id) in resolved {
 
         for directive in &self.unresolved_macros {
             match &directive.kind {
-                MacroDirectiveKind::FnLike {
-                    ast_id,
-                    expand_to,
-                    ctxt: call_site,
-                } => {
+                MacroDirectiveKind::FnLike { ast_id, expand_to, ctxt: call_site } => {
                     // FIXME: we shouldn't need to re-resolve the macro here just to get the unresolved error!
                     let macro_call_as_call_id = macro_call_as_call_id(
                         self.db,
                                 BuiltinShadowMode::Module,
                                 Some(MacroSubNs::Bang),
                             );
-                            resolved_res
-                                .resolved_def
-                                .take_macros()
-                                .map(|it| self.db.macro_def(it))
+                            resolved_res.resolved_def.take_macros().map(|it| self.db.macro_def(it))
                         },
                         &mut |_, _| (),
                     );
                     if let Err(UnresolvedMacro { path }) = macro_call_as_call_id {
-                        self.def_map
-                            .diagnostics
-                            .push(DefDiagnostic::unresolved_macro_call(
-                                directive.module_id,
-                                MacroCallKind::FnLike {
-                                    ast_id: ast_id.ast_id,
-                                    expand_to: *expand_to,
-                                    eager: None,
-                                },
-                                path,
-                            ));
+                        self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(
+                            directive.module_id,
+                            MacroCallKind::FnLike {
+                                ast_id: ast_id.ast_id,
+                                expand_to: *expand_to,
+                                eager: None,
+                            },
+                            path,
+                        ));
                     }
                 }
                 MacroDirectiveKind::Derive {
                     derive_macro_id,
                     ..
                 } => {
-                    self.def_map
-                        .diagnostics
-                        .push(DefDiagnostic::unresolved_macro_call(
-                            directive.module_id,
-                            MacroCallKind::Derive {
-                                ast_id: ast_id.ast_id,
-                                derive_attr_index: *derive_attr,
-                                derive_index: *derive_pos as u32,
-                                derive_macro_id: *derive_macro_id,
-                            },
-                            ast_id.path.as_ref().clone(),
-                        ));
+                    self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(
+                        directive.module_id,
+                        MacroCallKind::Derive {
+                            ast_id: ast_id.ast_id,
+                            derive_attr_index: *derive_attr,
+                            derive_index: *derive_pos as u32,
+                            derive_macro_id: *derive_macro_id,
+                        },
+                        ast_id.path.as_ref().clone(),
+                    ));
                 }
                 // These are diagnosed by `reseed_with_unresolved_attribute`, as that function consumes them
                 MacroDirectiveKind::Attr { .. } => {}
                 import:
                     Import {
                         ref path,
-                        source:
-                            ImportSource {
-                                use_tree,
-                                id,
-                                is_prelude: _,
-                                kind: _,
-                            },
+                        source: ImportSource { use_tree, id, is_prelude: _, kind: _ },
                         ..
                     },
                 ..
                 continue;
             }
             let item_tree_id = id.lookup(self.db).id;
-            self.def_map
-                .diagnostics
-                .push(DefDiagnostic::unresolved_import(
-                    module_id,
-                    item_tree_id,
-                    use_tree,
-                ));
+            self.def_map.diagnostics.push(DefDiagnostic::unresolved_import(
+                module_id,
+                item_tree_id,
+                use_tree,
+            ));
         }
 
         (self.def_map, self.local_def_map)
 
         // Note: don't assert that inserted value is fresh: it's simply not true
         // for macros.
-        self.def_collector
-            .mod_dirs
-            .insert(self.module_id, self.mod_dir.clone());
+        self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());
 
         // Prelude module is always considered to be `#[macro_use]`.
         if let Some((prelude_module, _use)) = self.def_collector.def_map.prelude {
                 def_collector.def_map.modules[module_id].scope.declare(id);
                 def_collector.update(
                     module_id,
-                    &[(
-                        Some(name.clone()),
-                        PerNs::from_def(id, vis, has_constructor, None),
-                    )],
+                    &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor, None))],
                     vis,
                     None,
                 )
 
             let module = self.def_collector.def_map.module_id(module_id);
             let def_map = &mut self.def_collector.def_map;
-            let local_def_map = self
-                .def_collector
-                .crate_local_def_map
-                .unwrap_or(&self.def_collector.local_def_map);
+            let local_def_map =
+                self.def_collector.crate_local_def_map.unwrap_or(&self.def_collector.local_def_map);
 
             match item {
                 ModItemId::Mod(m) => self.collect_module(m, &attrs),
                 ModItemId::Use(item_tree_id) => {
-                    let id = UseLoc {
-                        container: module,
-                        id: InFile::new(self.file_id(), item_tree_id),
-                    }
-                    .intern(db);
+                    let id =
+                        UseLoc { container: module, id: InFile::new(self.file_id(), item_tree_id) }
+                            .intern(db);
                     let is_prelude = attrs.by_key(sym::prelude_import).exists();
                     Import::from_use(self.item_tree, item_tree_id, id, is_prelude, |import| {
                         self.def_collector.unresolved_imports.push(ImportDirective {
                     })
                 }
                 ModItemId::ExternCrate(item_tree_id) => {
-                    let item_tree::ExternCrate {
-                        name,
-                        visibility,
-                        alias,
-                    } = &self.item_tree[item_tree_id];
+                    let item_tree::ExternCrate { name, visibility, alias } =
+                        &self.item_tree[item_tree_id];
 
                     let id = ExternCrateLoc {
                         container: module,
                         id: InFile::new(self.tree_id.file_id(), item_tree_id),
                     }
                     .intern(db);
-                    def_map.modules[self.module_id]
-                        .scope
-                        .define_extern_crate_decl(id);
+                    def_map.modules[self.module_id].scope.define_extern_crate_decl(id);
 
                     let is_self = *name == sym::self_;
                     let resolved = if is_self {
                         self.def_collector
                             .deps
                             .get(name)
-                            .map(|dep| CrateRootModuleId {
-                                krate: dep.crate_id,
-                            })
+                            .map(|dep| CrateRootModuleId { krate: dep.crate_id })
                     };
 
                     let name = match alias {
                         );
                     } else {
                         if let Some(name) = name {
-                            self.def_collector
-                                .unresolved_extern_crates
-                                .insert(name.clone());
+                            self.def_collector.unresolved_extern_crates.insert(name.clone());
                         }
                         self.def_collector.def_map.diagnostics.push(
                             DefDiagnostic::unresolved_extern_crate(
                 ModItemId::MacroRules(id) => self.collect_macro_rules(id, module),
                 ModItemId::Macro2(id) => self.collect_macro_def(id, module),
                 ModItemId::Impl(imp) => {
-                    let impl_id = ImplLoc {
-                        container: module,
-                        id: InFile::new(self.file_id(), imp),
-                    }
-                    .intern(db);
-                    self.def_collector.def_map.modules[self.module_id]
-                        .scope
-                        .define_impl(impl_id)
+                    let impl_id =
+                        ImplLoc { container: module, id: InFile::new(self.file_id(), imp) }
+                            .intern(db);
+                    self.def_collector.def_map.modules[self.module_id].scope.define_impl(impl_id)
                 }
                 ModItemId::Function(id) => {
                     let it = &self.item_tree[id];
-                    let fn_id = FunctionLoc {
-                        container,
-                        id: InFile::new(self.tree_id.file_id(), id),
-                    }
-                    .intern(db);
+                    let fn_id =
+                        FunctionLoc { container, id: InFile::new(self.tree_id.file_id(), id) }
+                            .intern(db);
 
                     let vis = resolve_vis(def_map, local_def_map, &self.item_tree[it.visibility]);
 
                     let vis = resolve_vis(def_map, local_def_map, &self.item_tree[it.visibility]);
                     update_def(
                         self.def_collector,
-                        StructLoc {
-                            container: module,
-                            id: InFile::new(self.file_id(), id),
-                        }
-                        .intern(db)
-                        .into(),
+                        StructLoc { container: module, id: InFile::new(self.file_id(), id) }
+                            .intern(db)
+                            .into(),
                         &it.name,
                         vis,
                         !matches!(it.shape, FieldsShape::Record),
                     let vis = resolve_vis(def_map, local_def_map, &self.item_tree[it.visibility]);
                     update_def(
                         self.def_collector,
-                        UnionLoc {
-                            container: module,
-                            id: InFile::new(self.file_id(), id),
-                        }
-                        .intern(db)
-                        .into(),
+                        UnionLoc { container: module, id: InFile::new(self.file_id(), id) }
+                            .intern(db)
+                            .into(),
                         &it.name,
                         vis,
                         false,
                 }
                 ModItemId::Enum(id) => {
                     let it = &self.item_tree[id];
-                    let enum_ = EnumLoc {
-                        container: module,
-                        id: InFile::new(self.tree_id.file_id(), id),
-                    }
-                    .intern(db);
+                    let enum_ =
+                        EnumLoc { container: module, id: InFile::new(self.tree_id.file_id(), id) }
+                            .intern(db);
 
                     let vis = resolve_vis(def_map, local_def_map, &self.item_tree[it.visibility]);
                     update_def(self.def_collector, enum_.into(), &it.name, vis, false);
                 }
                 ModItemId::Const(id) => {
                     let it = &self.item_tree[id];
-                    let const_id = ConstLoc {
-                        container,
-                        id: InFile::new(self.tree_id.file_id(), id),
-                    }
-                    .intern(db);
+                    let const_id =
+                        ConstLoc { container, id: InFile::new(self.tree_id.file_id(), id) }
+                            .intern(db);
 
                     match &it.name {
                         Some(name) => {
                     let vis = resolve_vis(def_map, local_def_map, &self.item_tree[it.visibility]);
                     update_def(
                         self.def_collector,
-                        StaticLoc {
-                            container,
-                            id: InFile::new(self.file_id(), id),
-                        }
-                        .intern(db)
-                        .into(),
+                        StaticLoc { container, id: InFile::new(self.file_id(), id) }
+                            .intern(db)
+                            .into(),
                         &it.name,
                         vis,
                         false,
                     let vis = resolve_vis(def_map, local_def_map, &self.item_tree[it.visibility]);
                     update_def(
                         self.def_collector,
-                        TraitLoc {
-                            container: module,
-                            id: InFile::new(self.file_id(), id),
-                        }
-                        .intern(db)
-                        .into(),
+                        TraitLoc { container: module, id: InFile::new(self.file_id(), id) }
+                            .intern(db)
+                            .into(),
                         &it.name,
                         vis,
                         false,
                     let vis = resolve_vis(def_map, local_def_map, &self.item_tree[it.visibility]);
                     update_def(
                         self.def_collector,
-                        TypeAliasLoc {
-                            container,
-                            id: InFile::new(self.file_id(), id),
-                        }
-                        .intern(db)
-                        .into(),
+                        TypeAliasLoc { container, id: InFile::new(self.file_id(), id) }
+                            .intern(db)
+                            .into(),
                         &it.name,
                         vis,
                         false,
                     &self.item_tree[module.visibility],
                 );
 
-                let Some(mod_dir) = self
-                    .mod_dir
-                    .descend_into_definition(&module.name, path_attr.as_deref())
+                let Some(mod_dir) =
+                    self.mod_dir.descend_into_definition(&module.name, path_attr.as_deref())
                 else {
                     return;
                 };
         let def_map = &mut self.def_collector.def_map;
         let vis = def_map
             .resolve_visibility(
-                self.def_collector
-                    .crate_local_def_map
-                    .unwrap_or(&self.def_collector.local_def_map),
+                self.def_collector.crate_local_def_map.unwrap_or(&self.def_collector.local_def_map),
                 self.def_collector.db,
                 self.module_id,
                 visibility,
             )
             .unwrap_or(Visibility::Public);
         let origin = match definition {
-            None => ModuleOrigin::Inline {
-                definition: declaration,
-                definition_tree_id: self.tree_id,
-            },
+            None => {
+                ModuleOrigin::Inline { definition: declaration, definition_tree_id: self.tree_id }
+            }
             Some((definition, is_mod_rs)) => ModuleOrigin::File {
                 declaration,
                 definition,
             });
 
         for attr in iter {
-            if self
-                .def_collector
-                .def_map
-                .is_builtin_or_registered_attr(&attr.path)
-            {
+            if self.def_collector.def_map.is_builtin_or_registered_attr(&attr.path) {
                 continue;
             }
             tracing::debug!(
     fn collect_macro_rules(&mut self, ast_id: ItemTreeAstId<MacroRules>, module: ModuleId) {
         let krate = self.def_collector.def_map.krate;
         let mac = &self.item_tree[ast_id];
-        let attrs = self
-            .item_tree
-            .attrs(self.def_collector.db, krate, ast_id.upcast());
+        let attrs = self.item_tree.attrs(self.def_collector.db, krate, ast_id.upcast());
         let f_ast_id = InFile::new(self.file_id(), ast_id.upcast());
 
         let export_attr = || attrs.by_key(sym::macro_export);
 
         let is_export = export_attr().exists();
         let local_inner = if is_export {
-            export_attr()
-                .tt_values()
-                .flat_map(|it| it.iter())
-                .any(|it| match it {
-                    tt::TtElement::Leaf(tt::Leaf::Ident(ident)) => {
-                        ident.sym == sym::local_inner_macros
-                    }
-                    _ => false,
-                })
+            export_attr().tt_values().flat_map(|it| it.iter()).any(|it| match it {
+                tt::TtElement::Leaf(tt::Leaf::Ident(ident)) => ident.sym == sym::local_inner_macros,
+                _ => false,
+            })
         } else {
             false
         };
         let expander = if attrs.by_key(sym::rustc_builtin_macro).exists() {
             // `#[rustc_builtin_macro = "builtin_name"]` overrides the `macro_rules!` name.
             let name;
-            let name = match attrs
-                .by_key(sym::rustc_builtin_macro)
-                .string_value_with_span()
-            {
+            let name = match attrs.by_key(sym::rustc_builtin_macro).string_value_with_span() {
                 Some((it, span)) => {
                     name = Name::new_symbol(it.clone(), span.ctx);
                     &name
                 }
                 None => {
-                    let explicit_name = attrs
-                        .by_key(sym::rustc_builtin_macro)
-                        .tt_values()
-                        .next()
-                        .and_then(|tt| match tt.token_trees().flat_tokens().first() {
-                            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(name))) => Some(name),
-                            _ => None,
+                    let explicit_name =
+                        attrs.by_key(sym::rustc_builtin_macro).tt_values().next().and_then(|tt| {
+                            match tt.token_trees().flat_tokens().first() {
+                                Some(tt::TokenTree::Leaf(tt::Leaf::Ident(name))) => Some(name),
+                                _ => None,
+                            }
                         });
                     match explicit_name {
                         Some(ident) => {
                 Some(Either::Left(it)) => MacroExpander::BuiltIn(it),
                 Some(Either::Right(it)) => MacroExpander::BuiltInEager(it),
                 None => {
-                    self.def_collector.def_map.diagnostics.push(
-                        DefDiagnostic::unimplemented_builtin_macro(self.module_id, f_ast_id),
-                    );
+                    self.def_collector
+                        .def_map
+                        .diagnostics
+                        .push(DefDiagnostic::unimplemented_builtin_macro(self.module_id, f_ast_id));
                     return;
                 }
             }
 
         let mut flags = MacroRulesLocFlags::empty();
         flags.set(MacroRulesLocFlags::LOCAL_INNER, local_inner);
-        flags.set(
-            MacroRulesLocFlags::ALLOW_INTERNAL_UNSAFE,
-            allow_internal_unsafe,
-        );
+        flags.set(MacroRulesLocFlags::ALLOW_INTERNAL_UNSAFE, allow_internal_unsafe);
 
         let macro_id = MacroRulesLoc {
             container: module,
             edition: self.def_collector.def_map.data.edition,
         }
         .intern(self.def_collector.db);
-        self.def_collector
-            .def_map
-            .macro_def_to_macro_id
-            .insert(f_ast_id.erase(), macro_id.into());
+        self.def_collector.def_map.macro_def_to_macro_id.insert(f_ast_id.erase(), macro_id.into());
         self.def_collector.define_macro_rules(
             self.module_id,
             mac.name.clone(),
     fn collect_macro_def(&mut self, ast_id: ItemTreeAstId<Macro2>, module: ModuleId) {
         let krate = self.def_collector.def_map.krate;
         let mac = &self.item_tree[ast_id];
-        let attrs = self
-            .item_tree
-            .attrs(self.def_collector.db, krate, ast_id.upcast());
+        let attrs = self.item_tree.attrs(self.def_collector.db, krate, ast_id.upcast());
         let f_ast_id = InFile::new(self.file_id(), ast_id.upcast());
 
         // Case 1: builtin macros
             } else if let Some(expander) = find_builtin_attr(&mac.name) {
                 MacroExpander::BuiltInAttr(expander)
             } else {
-                self.def_collector.def_map.diagnostics.push(
-                    DefDiagnostic::unimplemented_builtin_macro(self.module_id, f_ast_id),
-                );
+                self.def_collector
+                    .def_map
+                    .diagnostics
+                    .push(DefDiagnostic::unimplemented_builtin_macro(self.module_id, f_ast_id));
                 return;
             }
         } else {
             edition: self.def_collector.def_map.data.edition,
         }
         .intern(self.def_collector.db);
-        self.def_collector
-            .def_map
-            .macro_def_to_macro_id
-            .insert(f_ast_id.erase(), macro_id.into());
+        self.def_collector.def_map.macro_def_to_macro_id.insert(f_ast_id.erase(), macro_id.into());
         self.def_collector.define_macro_def(
             self.module_id,
             mac.name.clone(),
         ast_id: FileAstId<ast::MacroCall>,
         container: ItemContainerId,
     ) {
-        let &MacroCall {
-            ref path,
-            expand_to,
-            ctxt,
-        } = &self.item_tree[ast_id];
+        let &MacroCall { ref path, expand_to, ctxt } = &self.item_tree[ast_id];
         let ast_id = AstIdWithPath::new(self.file_id(), ast_id, path.clone());
         let db = self.def_collector.db;
 
         // FIXME: Immediately expanding in "Case 1" is insufficient since "Case 2" may also define
         // new legacy macros that create textual scopes. We need a way to resolve names in textual
         // scopes without eager expansion.
-
         let mut eager_callback_buffer = vec![];
         // Case 1: try to resolve macro calls with single-segment name and expand macro_rules
         if let Ok(res) = macro_call_as_call_id(
         self.def_collector.unresolved_macros.push(MacroDirective {
             module_id: self.module_id,
             depth: self.macro_depth + 1,
-            kind: MacroDirectiveKind::FnLike {
-                ast_id,
-                expand_to,
-                ctxt,
-            },
+            kind: MacroDirectiveKind::FnLike { ast_id, expand_to, ctxt },
             container,
         });
     }
     }
 
     fn emit_unconfigured_diagnostic(&mut self, ast_id: ErasedAstId, cfg: &CfgExpr) {
-        self.def_collector
-            .def_map
-            .diagnostics
-            .push(DefDiagnostic::unconfigured_code(
-                self.module_id,
-                ast_id,
-                cfg.clone(),
-                self.def_collector.cfg_options.clone(),
-            ));
+        self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(
+            self.module_id,
+            ast_id,
+            cfg.clone(),
+            self.def_collector.cfg_options.clone(),
+        ));
     }
 
     #[inline]
 #[cfg(test)]
 mod tests {
     use test_fixture::WithFixture;
-
     use crate::{nameres::DefMapCrateData, test_db::TestDB};
-
     use super::*;
-
     fn do_collect_defs(db: &dyn DefDatabase, def_map: DefMap) -> DefMap {
         let mut collector = DefCollector {
             db,
         collector.collect();
         collector.def_map
     }
-
     fn do_resolve(not_ra_fixture: &str) -> DefMap {
         let (db, file_id) = TestDB::with_single_file(not_ra_fixture);
         let krate = db.test_crate();
 
         let edition = krate.data(&db).edition;
-        let module_origin = ModuleOrigin::CrateRoot {
-            definition: file_id,
-        };
+        let module_origin = ModuleOrigin::CrateRoot { definition: file_id };
         let def_map = DefMap::empty(
             krate,
             Arc::new(DefMapCrateData::new(edition)),
         );
         do_collect_defs(&db, def_map)
     }
-
     #[test]
     fn test_macro_expand_will_stop_1() {
         do_resolve(
 "#,
         );
     }
-
     #[ignore]
     #[test]
     fn test_macro_expand_will_stop_2() {