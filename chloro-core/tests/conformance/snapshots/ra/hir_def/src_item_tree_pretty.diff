COMPARISON DIFF
============================================================

Original size: 12076 bytes
Chloro size:   12316 bytes
Rustfmt size:  12861 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     visibility::RawVisibility,
 };
 
-pub(super) fn print_item_tree(db: &dyn DefDatabase, tree: &ItemTree, edition: Edition) -> String {
-    let mut p = Printer {
-        db,
-        tree,
-        buf: String::new(),
-        indent_level: 0,
-        needs_indent: true,
-        edition,
-    };
-
+pub(super) fn print_item_tree(
+    db: &dyn DefDatabase,
+    tree: &ItemTree,
+    edition: Edition,
+) -> String {
+    let mut p =
+        Printer { db, tree, buf: String::new(), indent_level: 0, needs_indent: true, edition };
     p.print_attrs(&tree.top_attrs, true, "\n");
     p.blank();
-
     for item in tree.top_level_items() {
         p.print_mod_item(*item);
     }
-
     let mut s = p.buf.trim_end_matches('\n').to_owned();
     s.push('\n');
     s
 }
 
 impl Printer<'_> {
-    fn indented(&mut self, f: impl FnOnce(&mut Self)) {
+    fn indented(
+        &mut self,
+        f: impl FnOnce(&mut Self),
+    ) {
         self.indent_level += 1;
         wln!(self);
         f(self);
         }
     }
 
-    fn print_attrs(&mut self, attrs: &RawAttrs, inner: bool, separated_by: &str) {
+    fn print_attrs(
+        &mut self,
+        attrs: &RawAttrs,
+        inner: bool,
+        separated_by: &str,
+    ) {
         let inner = if inner { "!" } else { "" };
         for attr in &**attrs {
             w!(
                 "#{}[{}{}]{}",
                 inner,
                 attr.path.display(self.db, self.edition),
-                attr.input
-                    .as_ref()
-                    .map(|it| it.to_string())
-                    .unwrap_or_default(),
+                attr.input.as_ref().map(|it| it.to_string()).unwrap_or_default(),
                 separated_by,
             );
         }
     }
 
-    fn print_attrs_of(&mut self, of: ModItemId, separated_by: &str) {
+    fn print_attrs_of(
+        &mut self,
+        of: ModItemId,
+        separated_by: &str,
+    ) {
         if let Some(attrs) = self.tree.attrs.get(&of.ast_id()) {
             self.print_attrs(attrs, false, separated_by);
         }
     }
 
-    fn print_visibility(&mut self, vis: RawVisibilityId) {
+    fn print_visibility(
+        &mut self,
+        vis: RawVisibilityId,
+    ) {
         match &self.tree[vis] {
             RawVisibility::Module(path, _expl) => {
                 w!(self, "pub(in {}) ", path.display(self.db, self.edition))
         };
     }
 
-    fn print_fields(&mut self, kind: FieldsShape) {
+    fn print_fields(
+        &mut self,
+        kind: FieldsShape,
+    ) {
         match kind {
             FieldsShape::Record => {
                 self.whitespace();
         }
     }
 
-    fn print_use_tree(&mut self, use_tree: &UseTree) {
+    fn print_use_tree(
+        &mut self,
+        use_tree: &UseTree,
+    ) {
         match &use_tree.kind {
             UseTreeKind::Single { path, alias } => {
                 w!(self, "{}", path.display(self.db, self.edition));
         }
     }
 
-    fn print_mod_item(&mut self, item: ModItemId) {
+    fn print_mod_item(
+        &mut self,
+        item: ModItemId,
+    ) {
         self.print_attrs_of(item, "\n");
-
         match item {
             ModItemId::Use(ast_id) => {
-                let Use {
-                    visibility,
-                    use_tree,
-                } = &self.tree[ast_id];
+                let Use { visibility, use_tree } = &self.tree[ast_id];
                 self.print_ast_id(ast_id.erase());
                 self.print_visibility(*visibility);
                 w!(self, "use ");
                 wln!(self, ";");
             }
             ModItemId::ExternCrate(ast_id) => {
-                let ExternCrate {
-                    name,
-                    alias,
-                    visibility,
-                } = &self.tree[ast_id];
+                let ExternCrate { name, alias, visibility } = &self.tree[ast_id];
                 self.print_ast_id(ast_id.erase());
                 self.print_visibility(*visibility);
                 w!(self, "extern crate {}", name.display(self.db, self.edition));
                 wln!(self, "fn {};", name.display(self.db, self.edition));
             }
             ModItemId::Struct(ast_id) => {
-                let Struct {
-                    visibility,
-                    name,
-                    shape: kind,
-                } = &self.tree[ast_id];
+                let Struct { visibility, name, shape: kind } = &self.tree[ast_id];
                 self.print_ast_id(ast_id.erase());
                 self.print_visibility(*visibility);
                 w!(self, "struct {}", name.display(self.db, self.edition));
                 let Enum { name, visibility } = &self.tree[ast_id];
                 self.print_ast_id(ast_id.erase());
                 self.print_visibility(*visibility);
-                w!(
-                    self,
-                    "enum {} {{ ... }}",
-                    name.display(self.db, self.edition)
-                );
+                w!(self, "enum {} {{ ... }}", name.display(self.db, self.edition));
             }
             ModItemId::Const(ast_id) => {
                 let Const { name, visibility } = &self.tree[ast_id];
                 let Trait { name, visibility } = &self.tree[ast_id];
                 self.print_ast_id(ast_id.erase());
                 self.print_visibility(*visibility);
-                w!(
-                    self,
-                    "trait {} {{ ... }}",
-                    name.display(self.db, self.edition)
-                );
+                w!(self, "trait {} {{ ... }}", name.display(self.db, self.edition));
             }
             ModItemId::Impl(ast_id) => {
                 let Impl {} = &self.tree[ast_id];
                 wln!(self);
             }
             ModItemId::Mod(ast_id) => {
-                let Mod {
-                    name,
-                    visibility,
-                    kind,
-                } = &self.tree[ast_id];
+                let Mod { name, visibility, kind } = &self.tree[ast_id];
                 self.print_ast_id(ast_id.erase());
                 self.print_visibility(*visibility);
                 w!(self, "mod {}", name.display(self.db, self.edition));
                 }
             }
             ModItemId::MacroCall(ast_id) => {
-                let MacroCall {
-                    path,
-                    expand_to,
-                    ctxt,
-                } = &self.tree[ast_id];
+                let MacroCall { path, expand_to, ctxt } = &self.tree[ast_id];
                 let _ = writeln!(
                     self,
                     "// AstId: {:#?}, SyntaxContextId: {}, ExpandTo: {:?}",
             ModItemId::MacroRules(ast_id) => {
                 let MacroRules { name } = &self.tree[ast_id];
                 self.print_ast_id(ast_id.erase());
-                wln!(
-                    self,
-                    "macro_rules! {} {{ ... }}",
-                    name.display(self.db, self.edition)
-                );
+                wln!(self, "macro_rules! {} {{ ... }}", name.display(self.db, self.edition));
             }
             ModItemId::Macro2(ast_id) => {
                 let Macro2 { name, visibility } = &self.tree[ast_id];
                 self.print_ast_id(ast_id.erase());
                 self.print_visibility(*visibility);
-                wln!(
-                    self,
-                    "macro {} {{ ... }}",
-                    name.display(self.db, self.edition)
-                );
+                wln!(self, "macro {} {{ ... }}", name.display(self.db, self.edition));
             }
         }
-
         self.blank();
     }
 
-    fn print_ast_id(&mut self, ast_id: ErasedFileAstId) {
+    fn print_ast_id(
+        &mut self,
+        ast_id: ErasedFileAstId,
+    ) {
         wln!(self, "// AstId: {ast_id:#?}");
     }
 }
 
 impl Write for Printer<'_> {
-    fn write_str(&mut self, s: &str) -> fmt::Result {
+    fn write_str(
+        &mut self,
+        s: &str,
+    ) -> fmt::Result {
         for line in s.split_inclusive('\n') {
             if self.needs_indent {
                 match self.buf.chars().last() {
             self.buf.push_str(line);
             self.needs_indent = line.ends_with('\n');
         }
-
         Ok(())
     }
 }