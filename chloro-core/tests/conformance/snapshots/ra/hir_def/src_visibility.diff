COMPARISON DIFF
============================================================

Original size: 13679 bytes
Chloro size:   13739 bytes
Rustfmt size:  13851 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::ast::{self, HasVisibility};
 use triomphe::Arc;
 
+pub use crate::item_tree::{RawVisibility, VisibilityExplicitness};
 use crate::{
     db::DefDatabase, nameres::DefMap, resolver::HasResolver, src::HasSource, AssocItemId,
     HasModule, ItemContainerId, LocalFieldId, LocalModuleId, ModuleId, TraitId, VariantId,
 };
 
-pub use crate::item_tree::{RawVisibility, VisibilityExplicitness};
-
 /// Visibility of an item, with the path resolved.
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
 pub enum Visibility {
         raw_vis: &RawVisibility,
     ) -> Self {
         // we fall back to public visibility (i.e. fail open) if the path can't be resolved
-        resolver
-            .resolve_visibility(db, raw_vis)
-            .unwrap_or(Visibility::Public)
+        resolver.resolve_visibility(db, raw_vis).unwrap_or(Visibility::Public)
     }
 
     pub(crate) fn is_visible_from_other_crate(self) -> bool {
         // In that case, we adjust the visibility of `to_module` to point to the containing module.
 
         // Additional complication: `to_module` might be in `from_module`'s `DefMap`, which we're
+
         // currently computing, so we must not call the `def_map` query for it.
         let def_map_block = def_map.block_id();
         loop {
                         },
                     ));
                 }
-
                 if mod_a.krate() != def_map.krate() || mod_b.krate() != def_map.krate() {
                     return None;
                 }
-
                 let def_block = def_map.block_id();
                 if mod_a.containing_block() != def_block || mod_b.containing_block() != def_block {
                     return None;
                 }
-
                 let mut a_ancestors =
                     iter::successors(Some(mod_a.local_id), |&m| def_map[m].parent);
-
                 if a_ancestors.any(|m| m == mod_b.local_id) {
                     // B is above A
                     return Some(Visibility::Module(mod_b, expl_b));
                 }
-
                 let mut b_ancestors =
                     iter::successors(Some(mod_b.local_id), |&m| def_map[m].parent);
                 if b_ancestors.any(|m| m == mod_a.local_id) {
                     // A is above B
                     return Some(Visibility::Module(mod_a, expl_a));
                 }
-
                 None
             }
         }
                         },
                     ));
                 }
-
                 if mod_a.krate() != def_map.krate() || mod_b.krate() != def_map.krate() {
                     return None;
                 }
-
                 let def_block = def_map.block_id();
                 if mod_a.containing_block() != def_block || mod_b.containing_block() != def_block {
                     return None;
                 }
-
                 let mut a_ancestors =
                     iter::successors(Some(mod_a.local_id), |&m| def_map[m].parent);
-
                 if a_ancestors.any(|m| m == mod_b.local_id) {
                     // B is above A
                     return Some(Visibility::Module(mod_a, expl_a));
                 }
-
                 let mut b_ancestors =
                     iter::successors(Some(mod_b.local_id), |&m| def_map[m].parent);
                 if b_ancestors.any(|m| m == mod_a.local_id) {
                     // A is above B
                     return Some(Visibility::Module(mod_b, expl_b));
                 }
-
                 None
             }
         }
     let resolver = variant_id.module(db).resolver(db);
     let mut res = ArenaMap::default();
     for (field_id, field_data) in fields.iter() {
-        res.insert(
-            field_id,
-            Visibility::resolve(db, &resolver, &field_data.visibility),
-        );
+        res.insert(field_id, Visibility::resolve(db, &resolver, &field_data.visibility));
     }
     res.shrink_to_fit();
     Arc::new(res)
 ) -> Visibility {
     let mut span_map = None;
     let raw_vis = crate::item_tree::visibility_from_ast(db, ast_vis.value, &mut |range| {
-        span_map
-            .get_or_insert_with(|| db.span_map(ast_vis.file_id))
-            .span_for_range(range)
-            .ctx
+        span_map.get_or_insert_with(|| db.span_map(ast_vis.file_id)).span_for_range(range).ctx
     });
     match raw_vis {
         RawVisibility::PubSelf(explicitness) => {