COMPARISON DIFF
============================================================

Original size: 23100 bytes
Chloro size:   22357 bytes
Rustfmt size:  23685 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ast::{AstNode, StructKind};
 use base_db::Crate;
 use hir_expand::{
-    attrs::RawAttrs,
-    mod_path::{ModPath, PathKind},
-    name::Name,
-    ExpandTo, HirFileId,
+    attrs::RawAttrs, mod_path::{ModPath, name::Name, ExpandTo, HirFileId, PathKind},
 };
 use intern::Interned;
 use la_arena::{Idx, RawIdx};
 use rustc_hash::FxHashMap;
 use span::{AstIdNode, Edition, FileAstId, SyntaxContext};
 use stdx::never;
-use syntax::{ast, match_ast, SyntaxKind};
+use syntax::{SyntaxKind, ast, match_ast};
 use thin_vec::ThinVec;
 use triomphe::Arc;
 
-use crate::{attr::Attrs, db::DefDatabase, BlockId, Lookup};
-
 pub(crate) use crate::item_tree::lower::{lower_use_tree, visibility_from_ast};
+use crate::{BlockId, Lookup, attr::Attrs, db::DefDatabase};
 
 #[derive(Copy, Clone, Eq, PartialEq)]
 pub(crate) struct RawVisibilityId(u32);
 
 impl RawVisibilityId {
     const PUB: Self = RawVisibilityId(u32::MAX);
+
     const PRIV_IMPLICIT: Self = RawVisibilityId(u32::MAX - 1);
+
     const PRIV_EXPLICIT: Self = RawVisibilityId(u32::MAX - 2);
+
     const PUB_CRATE: Self = RawVisibilityId(u32::MAX - 3);
 }
 
 impl fmt::Debug for RawVisibilityId {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         let mut f = f.debug_tuple("RawVisibilityId");
         match *self {
             Self::PUB => f.field(&"pub"),
 }
 
 #[salsa_macros::tracked(returns(deref))]
-pub(crate) fn file_item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {
+pub(crate) fn file_item_tree_query(
+    db: &dyn DefDatabase,
+    file_id: HirFileId,
+) -> Arc<ItemTree> {
     let _p = tracing::info_span!("file_item_tree_query", ?file_id).entered();
     static EMPTY: OnceLock<Arc<ItemTree>> = OnceLock::new();
-
     let ctx = lower::Ctx::new(db, file_id);
     let syntax = db.parse_or_expand(file_id);
     let mut item_tree = match_ast! {
             },
         }
     };
-    let ItemTree {
-        top_level,
-        top_attrs,
-        attrs,
-        vis,
-        big_data,
-        small_data,
-    } = &item_tree;
+    let ItemTree { top_level, top_attrs, attrs, vis, big_data, small_data } = &item_tree;
     if small_data.is_empty()
         && big_data.is_empty()
         && top_level.is_empty()
                     small_data: FxHashMap::default(),
                     big_data: FxHashMap::default(),
                     top_attrs: RawAttrs::EMPTY,
-                    vis: ItemVisibilities {
-                        arena: ThinVec::new(),
-                    },
+                    vis: ItemVisibilities { arena: ThinVec::new() },
                 })
             })
             .clone()
 }
 
 #[salsa_macros::tracked(returns(deref))]
-pub(crate) fn block_item_tree_query(db: &dyn DefDatabase, block: BlockId) -> Arc<ItemTree> {
+pub(crate) fn block_item_tree_query(
+    db: &dyn DefDatabase,
+    block: BlockId,
+) -> Arc<ItemTree> {
     let _p = tracing::info_span!("block_item_tree_query", ?block).entered();
     static EMPTY: OnceLock<Arc<ItemTree>> = OnceLock::new();
-
     let loc = block.lookup(db);
     let block = loc.ast_id.to_node(db);
-
     let ctx = lower::Ctx::new(db, loc.ast_id.file_id);
     let mut item_tree = ctx.lower_block(&block);
-    let ItemTree {
-        top_level,
-        top_attrs,
-        attrs,
-        vis,
-        big_data,
-        small_data,
-    } = &item_tree;
+    let ItemTree { top_level, top_attrs, attrs, vis, big_data, small_data } = &item_tree;
     if small_data.is_empty()
         && big_data.is_empty()
         && top_level.is_empty()
                     small_data: FxHashMap::default(),
                     big_data: FxHashMap::default(),
                     top_attrs: RawAttrs::EMPTY,
-                    vis: ItemVisibilities {
-                        arena: ThinVec::new(),
-                    },
+                    vis: ItemVisibilities { arena: ThinVec::new() },
                 })
             })
             .clone()
         Arc::new(item_tree)
     }
 }
+
 /// The item tree of a source file.
 #[derive(Debug, Default, Eq, PartialEq)]
 pub struct ItemTree {
     }
 
     /// Returns the inner attributes of the source file.
-    pub(crate) fn top_level_attrs(&self, db: &dyn DefDatabase, krate: Crate) -> Attrs {
+    pub(crate) fn top_level_attrs(
+        &self,
+        db: &dyn DefDatabase,
+        krate: Crate,
+    ) -> Attrs {
         Attrs::expand_cfg_attr(db, krate, self.top_attrs.clone())
     }
 
-    pub(crate) fn raw_attrs(&self, of: FileAstId<ast::Item>) -> &RawAttrs {
+    pub(crate) fn raw_attrs(
+        &self,
+        of: FileAstId<ast::Item>,
+    ) -> &RawAttrs {
         self.attrs.get(&of).unwrap_or(&RawAttrs::EMPTY)
     }
 
                 _ => {}
             }
         }
-        ItemTreeDataStats {
-            traits,
-            impls,
-            mods,
-            macro_calls,
-            macro_rules,
-        }
+        ItemTreeDataStats { traits, impls, mods, macro_calls, macro_rules }
     }
 
-    pub fn pretty_print(&self, db: &dyn DefDatabase, edition: Edition) -> String {
+    pub fn pretty_print(
+        &self,
+        db: &dyn DefDatabase,
+        edition: Edition,
+    ) -> String {
         pretty::print_item_tree(db, self, edition)
     }
 
     fn shrink_to_fit(&mut self) {
-        let ItemTree {
-            top_level: _,
-            attrs,
-            big_data,
-            small_data,
-            vis: _,
-            top_attrs: _,
-        } = self;
+        let ItemTree { top_level: _, attrs, big_data, small_data, vis: _, top_attrs: _ } = self;
         attrs.shrink_to_fit();
         big_data.shrink_to_fit();
         small_data.shrink_to_fit();
     Use(Use),
 }
 
-// `ModItem` is stored a bunch in `ItemTree`'s so we pay the max for each item. It should stay as
-// small as possible which is why we split them in two, most common ones are 3 usize but some rarer
-// ones are 5.
 #[cfg(target_pointer_width = "64")]
-const _: [(); std::mem::size_of::<BigModItem>()] = [(); std::mem::size_of::<[usize; 5]>()];
+const [(); std::mem::size_of::<BigModItem>()] = [(); std::mem::size_of::<[usize; 5]>()];
+
 #[cfg(target_pointer_width = "64")]
-const _: [(); std::mem::size_of::<SmallModItem>()] = [(); std::mem::size_of::<[usize; 3]>()];
+const [(); std::mem::size_of::<SmallModItem>()] = [(); std::mem::size_of::<[usize; 3]>()];
 
 #[derive(Default, Debug, Eq, PartialEq)]
 pub struct ItemTreeDataStats {
 }
 
 /// Trait implemented by all nodes in the item tree.
-pub(crate) trait ItemTreeNode: Clone {
-    type Source: AstIdNode;
+pub(crate) trait ItemTreeNode {
+    type Source;
 }
 
 #[allow(type_alias_bounds)]
 }
 
 impl TreeId {
-    pub(crate) fn new(file: HirFileId, block: Option<BlockId>) -> Self {
+    pub(crate) fn new(
+        file: HirFileId,
+        block: Option<BlockId>,
+    ) -> Self {
         Self { file, block }
     }
 
-    pub(crate) fn item_tree<'db>(&self, db: &'db dyn DefDatabase) -> &'db ItemTree {
+    pub(crate) fn item_tree<'db>(
+        &self,
+        db: &'db dyn DefDatabase,
+    ) -> &'db ItemTree {
         match self.block {
             Some(block) => block_item_tree_query(db, block),
             None => file_item_tree_query(db, self.file),
         )+
     };
 }
-
-mod_items! {
-ModItemId ->
-    Const in small_data -> ast::Const,
-    Enum in small_data -> ast::Enum,
-    ExternBlock in small_data -> ast::ExternBlock,
-    ExternCrate in big_data -> ast::ExternCrate,
-    Function in small_data -> ast::Fn,
-    Impl in small_data -> ast::Impl,
-    Macro2 in small_data -> ast::MacroDef,
-    MacroCall in small_data -> ast::MacroCall,
-    MacroRules in small_data -> ast::MacroRules,
-    Mod in big_data -> ast::Module,
-    Static in small_data -> ast::Static,
-    Struct in small_data -> ast::Struct,
-    Trait in small_data -> ast::Trait,
-    TypeAlias in small_data -> ast::TypeAlias,
-    Union in small_data -> ast::Union,
-    Use in big_data -> ast::Use,
-}
-
 impl Index<RawVisibilityId> for ItemTree {
     type Output = RawVisibility;
-    fn index(&self, index: RawVisibilityId) -> &Self::Output {
+
+    fn index(
+        &self,
+        index: RawVisibilityId,
+    ) -> &Self::Output {
         static VIS_PUB: RawVisibility = RawVisibility::Public;
         static VIS_PRIV_IMPLICIT: RawVisibility =
             RawVisibility::PubSelf(VisibilityExplicitness::Implicit);
         static VIS_PRIV_EXPLICIT: RawVisibility =
             RawVisibility::PubSelf(VisibilityExplicitness::Explicit);
         static VIS_PUB_CRATE: RawVisibility = RawVisibility::PubCrate;
-
         match index {
             RawVisibilityId::PRIV_IMPLICIT => &VIS_PRIV_IMPLICIT,
             RawVisibilityId::PRIV_EXPLICIT => &VIS_PRIV_EXPLICIT,
     kind: UseTreeKind,
 }
 
-// FIXME: Would be nice to encode `None` into this
-// We could just use a `Name` where `_` well means `_` ..
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum ImportAlias {
     /// Unnamed alias, as in `use Foo as _;`
 }
 
 impl ImportAlias {
-    pub fn display(&self, edition: Edition) -> impl fmt::Display + '_ {
-        ImportAliasDisplay {
-            value: self,
-            edition,
-        }
+    pub fn display(
+        &self,
+        edition: Edition,
+    ) -> impl fmt::Display + '_ {
+        ImportAliasDisplay { value: self, edition }
     }
 }
 
 }
 
 impl fmt::Display for ImportAliasDisplay<'_> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         match self.value {
             ImportAlias::Underscore => f.write_str("_"),
             ImportAlias::Alias(name) => fmt::Display::fmt(&name.display_no_db(self.edition), f),
         path: Interned<ModPath>,
         alias: Option<ImportAlias>,
     },
-
     /// ```ignore
     /// use *;  // (invalid, but can occur in nested tree)
     /// use path::*;
     /// ```
-    Glob { path: Option<Interned<ModPath>> },
-
+    Glob {
+        path: Option<Interned<ModPath>>,
+    },
     /// ```ignore
     /// use prefix::{self, Item, ...};
     /// ```
 }
 
 #[derive(Debug, Clone, Eq, PartialEq)]
-pub struct Impl {}
+pub struct Impl {
+}
 
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub struct TypeAlias {
 #[derive(Debug, Clone, Eq, PartialEq)]
 pub(crate) enum ModKind {
     /// `mod m { ... }`
-    Inline { items: Box<[ModItemId]> },
+    Inline {
+        items: Box<[ModItemId]>,
+    },
     /// `mod m;`
     Outline,
 }
                 (Some(_), _) => None,
             }
         }
-
         match &self.kind {
             UseTreeKind::Single { path, alias } => {
                 if let Some((path, kind)) = concat_mod_paths(prefix, path) {
-                    cb(
-                        Idx::from_raw(RawIdx::from_u32(*counting_index)),
-                        path,
-                        kind,
-                        alias.clone(),
-                    );
+                    cb(Idx::from_raw(RawIdx::from_u32(*counting_index)), path, kind, alias.clone());
                 }
             }
             UseTreeKind::Glob { path: Some(path) } => {
                     );
                 }
             }
-            UseTreeKind::Prefixed {
-                prefix: additional_prefix,
-                list,
-            } => {
+            UseTreeKind::Prefixed { prefix: additional_prefix, list } => {
                 let prefix = match additional_prefix {
                     Some(path) => match concat_mod_paths(prefix, path) {
                         Some((path, ImportKind::Plain)) => Some(path),