COMPARISON DIFF
============================================================

Original size: 45518 bytes
Chloro size:   45695 bytes
Rustfmt size:  45518 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! A pretty-printer for HIR.
+
 #![allow(dead_code)]
 
 use std::{
 use syntax::ast::HasName;
 
 use crate::{
-    AdtId, DefWithBodyId, GenericDefId, TypeParamId, VariantId,
     expr_store::path::{GenericArg, GenericArgs},
     hir::{
         Array, BindingAnnotation, CaptureBy, ClosureKind, Literal, Movability, Statement,
     signatures::{FnFlags, FunctionSignature, StructSignature},
     src::HasSource,
     type_ref::{ConstRef, LifetimeRef, Mutability, TraitBoundModifier, TypeBound, UseArgRef},
+    AdtId,
+    DefWithBodyId,
+    GenericDefId,
+    TypeParamId,
+    VariantId,
 };
 use crate::{LifetimeParamId, signatures::StructFlags};
 use crate::{item_tree::FieldsShape, signatures::FieldData};
-
 use super::*;
 
 macro_rules! w {
     Indentation,
 }
 
-fn item_name<Id, Loc>(db: &dyn DefDatabase, id: Id, default: &str) -> String
+fn item_name<Id, Loc>(
+    db: &dyn DefDatabase,
+    id: Id,
+    default: &str,
+) -> String
 where
     Id: Lookup<Database = dyn DefDatabase, Data = Loc>,
     Loc: HasSource,
-    Loc::Value: ast::HasName,
-{
+    Loc::Value: ast::HasName, {
     let loc = id.lookup(db);
     let source = loc.source(db);
     source.value.name().map_or_else(|| default.to_owned(), |name| name.to_string())
             item_name(db, it, "<missing>")
         ),
     };
-
     let mut p = Printer {
         db,
         store: body,
     p.buf
 }
 
-pub fn print_variant_body_hir(db: &dyn DefDatabase, owner: VariantId, edition: Edition) -> String {
+pub fn print_variant_body_hir(
+    db: &dyn DefDatabase,
+    owner: VariantId,
+    edition: Edition,
+) -> String {
     let header = match owner {
         VariantId::StructId(it) => format!("struct {}", item_name(db, it, "<missing>")),
         VariantId::EnumVariantId(it) => format!(
         ),
         VariantId::UnionId(it) => format!("union {}", item_name(db, it, "<missing>")),
     };
-
     let fields = owner.fields(db);
-
     let mut p = Printer {
         db,
         store: &fields.store,
         FieldsShape::Tuple => wln!(p, "("),
         FieldsShape::Unit => (),
     }
-
     for (_, data) in fields.fields().iter() {
         let FieldData { name, type_ref, visibility, is_unsafe } = data;
         match visibility {
         w!(p, "{}: ", name.display(db, p.edition));
         p.print_type_ref(*type_ref);
     }
-
     match fields.shape {
         FieldsShape::Record => wln!(p, "}}"),
         FieldsShape::Tuple => wln!(p, ");"),
     p.buf
 }
 
-pub fn print_signature(db: &dyn DefDatabase, owner: GenericDefId, edition: Edition) -> String {
+pub fn print_signature(
+    db: &dyn DefDatabase,
+    owner: GenericDefId,
+    edition: Edition,
+) -> String {
     match owner {
         GenericDefId::AdtId(id) => match id {
             AdtId::StructId(id) => {
         FieldsShape::Tuple => wln!(p, "(...)"),
         FieldsShape::Unit => (),
     }
-
     print_where_clauses(db, generic_params, &mut p);
-
     match shape {
         FieldsShape::Record => wln!(p),
         FieldsShape::Tuple => wln!(p, ";"),
         FieldsShape::Unit => wln!(p, ";"),
     }
-
     p.buf
 }
 
         w!(p, " -> ");
         p.print_type_ref(*ret_type);
     }
-
     print_where_clauses(db, generic_params, &mut p);
     wln!(p, " {{...}}");
-
     p.buf
 }
 
-fn print_where_clauses(db: &dyn DefDatabase, generic_params: &GenericParams, p: &mut Printer<'_>) {
+fn print_where_clauses(
+    db: &dyn DefDatabase,
+    generic_params: &GenericParams,
+    p: &mut Printer<'_>,
+) {
     if !generic_params.where_predicates.is_empty() {
         w!(p, "\nwhere\n");
         p.indented(|p| {
     }
 }
 
-fn print_generic_params(db: &dyn DefDatabase, generic_params: &GenericParams, p: &mut Printer<'_>) {
+fn print_generic_params(
+    db: &dyn DefDatabase,
+    generic_params: &GenericParams,
+    p: &mut Printer<'_>,
+) {
     if !generic_params.is_empty() {
         w!(p, "<");
         let mut first = true;
 }
 
 impl Write for Printer<'_> {
-    fn write_str(&mut self, s: &str) -> fmt::Result {
+    fn write_str(
+        &mut self,
+        s: &str,
+    ) -> fmt::Result {
         for line in s.split_inclusive('\n') {
             if matches!(self.line_format, LineFormat::Indentation) {
                 match self.buf.chars().rev().find(|ch| *ch != ' ') {
                 };
             }
         }
-
         Ok(())
     }
 }
 
 impl Printer<'_> {
-    fn indented(&mut self, f: impl FnOnce(&mut Self)) {
+    fn indented(
+        &mut self,
+        f: impl FnOnce(&mut Self),
+    ) {
         self.indent_level += 1;
         wln!(self);
         f(self);
         }
     }
 
-    // Add a newline if the current line is not empty.
-    // If the current line is empty, add a space instead.
-    //
-    // Do not use [`writeln!()`] or [`wln!()`] here, which will result in
-    // infinite recursive calls to this function.
     fn newline(&mut self) {
         if matches!(self.line_format, LineFormat::Oneline) {
             match self.buf.chars().last() {
         }
     }
 
-    fn print_expr(&mut self, expr: ExprId) {
+    fn print_expr(
+        &mut self,
+        expr: ExprId,
+    ) {
         let expr = &self.store[expr];
-
         match expr {
             Expr::Missing => w!(self, "�"),
             Expr::Underscore => w!(self, "_"),
         w!(self, "}}");
     }
 
-    fn print_pat(&mut self, pat: PatId) {
+    fn print_pat(
+        &mut self,
+        pat: PatId,
+    ) {
         let pat = &self.store[pat];
-
         match pat {
             Pat::Missing => w!(self, "�"),
             Pat::Wild => w!(self, "_"),
         }
     }
 
-    fn print_stmt(&mut self, stmt: &Statement) {
+    fn print_stmt(
+        &mut self,
+        stmt: &Statement,
+    ) {
         match stmt {
             Statement::Let { pat, type_ref, initializer, else_branch } => {
                 w!(self, "let ");
         }
     }
 
-    fn print_literal(&mut self, literal: &Literal) {
+    fn print_literal(
+        &mut self,
+        literal: &Literal,
+    ) {
         match literal {
             Literal::String(it) => w!(self, "{:?}", it),
             Literal::ByteString(it) => w!(self, "\"{}\"", it.escape_ascii()),
         }
     }
 
-    fn print_binding(&mut self, id: BindingId) {
+    fn print_binding(
+        &mut self,
+        id: BindingId,
+    ) {
         let Binding { name, mode, .. } = &self.store.assert_expr_only().bindings[id];
         let mode = match mode {
             BindingAnnotation::Unannotated => "",
         w!(self, "{}{}", mode, name.display(self.db, self.edition));
     }
 
-    fn print_path(&mut self, path: &Path) {
+    fn print_path(
+        &mut self,
+        path: &Path,
+    ) {
         if let Path::LangItem(it, s) = path {
             w!(self, "builtin#lang(");
             macro_rules! write_name {
                 ),
             },
         }
-
         for (i, segment) in path.segments().iter().enumerate() {
             if i != 0 || !matches!(path.kind(), PathKind::Plain) {
                 w!(self, "::");
         }
     }
 
-    pub(crate) fn print_generic_args(&mut self, generics: &GenericArgs) {
+    pub(crate) fn print_generic_args(
+        &mut self,
+        generics: &GenericArgs,
+    ) {
         let mut first = true;
         let args = if generics.has_self_type {
             let (self_ty, args) = generics.args.split_first().unwrap();
         }
     }
 
-    pub(crate) fn print_generic_arg(&mut self, arg: &GenericArg) {
+    pub(crate) fn print_generic_arg(
+        &mut self,
+        arg: &GenericArg,
+    ) {
         match arg {
             GenericArg::Type(ty) => self.print_type_ref(*ty),
             GenericArg::Const(ConstRef { expr }) => self.print_expr(*expr),
         }
     }
 
-    pub(crate) fn print_type_param(&mut self, param: TypeParamId) {
+    pub(crate) fn print_type_param(
+        &mut self,
+        param: TypeParamId,
+    ) {
         let generic_params = self.db.generic_params(param.parent());
-
         match generic_params[param.local_id()].name() {
             Some(name) => w!(self, "{}", name.display(self.db, self.edition)),
             None => w!(self, "Param[{}]", param.local_id().into_raw()),
         }
     }
 
-    pub(crate) fn print_lifetime_param(&mut self, param: LifetimeParamId) {
+    pub(crate) fn print_lifetime_param(
+        &mut self,
+        param: LifetimeParamId,
+    ) {
         let generic_params = self.db.generic_params(param.parent);
         w!(self, "{}", generic_params[param.local_id].name.display(self.db, self.edition))
     }
 
-    pub(crate) fn print_lifetime_ref(&mut self, lt_ref: LifetimeRefId) {
+    pub(crate) fn print_lifetime_ref(
+        &mut self,
+        lt_ref: LifetimeRefId,
+    ) {
         match &self.store[lt_ref] {
             LifetimeRef::Static => w!(self, "'static"),
             LifetimeRef::Named(lt) => {
         }
     }
 
-    pub(crate) fn print_type_ref(&mut self, type_ref: TypeRefId) {
+    pub(crate) fn print_type_ref(
+        &mut self,
+        type_ref: TypeRefId,
+    ) {
         // FIXME: deduplicate with `HirDisplay` impl
         match &self.store[type_ref] {
             TypeRef::Never => w!(self, "!"),
         }
     }
 
-    pub(crate) fn print_type_bounds(&mut self, bounds: &[TypeBound]) {
+    pub(crate) fn print_type_bounds(
+        &mut self,
+        bounds: &[TypeBound],
+    ) {
         for (i, bound) in bounds.iter().enumerate() {
             if i != 0 {
                 w!(self, " + ");