COMPARISON DIFF
============================================================

Original size: 45518 bytes
Chloro size:   45285 bytes
Rustfmt size:  45518 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! A pretty-printer for HIR.
+
 #![allow(dead_code)]
 
 use std::{
 use itertools::Itertools;
 use span::Edition;
 use syntax::ast::HasName;
+use crate::{LifetimeParamId, signatures::StructFlags};
+use crate::{item_tree::FieldsShape, signatures::FieldData};
 
 use crate::{
     AdtId, DefWithBodyId, GenericDefId, TypeParamId, VariantId,
     src::HasSource,
     type_ref::{ConstRef, LifetimeRef, Mutability, TraitBoundModifier, TypeBound, UseArgRef},
 };
-use crate::{LifetimeParamId, signatures::StructFlags};
-use crate::{item_tree::FieldsShape, signatures::FieldData};
 
 use super::*;
 
     }
 }
 
-fn print_generic_params(db: &dyn DefDatabase, generic_params: &GenericParams, p: &mut Printer<'_>) {
+fn print_generic_params(
+    db: &dyn DefDatabase,
+    generic_params: &GenericParams,
+    p: &mut Printer<'_>,
+) {
     if !generic_params.is_empty() {
         w!(p, "<");
         let mut first = true;
         }
     }
 
-    // Add a newline if the current line is not empty.
-    // If the current line is empty, add a space instead.
-    //
-    // Do not use [`writeln!()`] or [`wln!()`] here, which will result in
-    // infinite recursive calls to this function.
     fn newline(&mut self) {
         if matches!(self.line_format, LineFormat::Oneline) {
             match self.buf.chars().last() {
                     Some(path) => self.print_path(path),
                     None => w!(self, "�"),
                 }
-
                 w!(self, "{{");
                 let edition = self.edition;
                 self.indented(|p| {
                     Some(path) => self.print_path(path),
                     None => w!(self, "�"),
                 }
-
                 w!(self, " {{");
                 let edition = self.edition;
                 let oneline = matches!(self.line_format, LineFormat::Oneline);
             if i != 0 || !matches!(path.kind(), PathKind::Plain) {
                 w!(self, "::");
             }
-
             w!(self, "{}", segment.name.display(self.db, self.edition));
             if let Some(generics) = segment.args_and_bindings {
                 w!(self, "::<");
                 self.print_generic_args(generics);
-
                 w!(self, ">");
             }
         }
             if i != 0 {
                 w!(self, " + ");
             }
-
             match bound {
                 TypeBound::Path(path, modifier) => {
                     match modifier {