COMPARISON DIFF
============================================================

Original size: 45518 bytes
Chloro size:   45274 bytes
Rustfmt size:  45518 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! A pretty-printer for HIR.
+
 #![allow(dead_code)]
 
 use std::{
 use syntax::ast::HasName;
 
 use crate::{
-    AdtId, DefWithBodyId, GenericDefId, TypeParamId, VariantId,
     expr_store::path::{GenericArg, GenericArgs},
     hir::{
-        Array, BindingAnnotation, CaptureBy, ClosureKind, Literal, Movability, Statement,
-        generics::{GenericParams, WherePredicate},
+        generics::{GenericParams, WherePredicate}, Array, BindingAnnotation, CaptureBy,
+        ClosureKind, Literal, Movability, Statement,
     },
     lang_item::LangItemTarget,
     signatures::{FnFlags, FunctionSignature, StructSignature},
     src::HasSource,
     type_ref::{ConstRef, LifetimeRef, Mutability, TraitBoundModifier, TypeBound, UseArgRef},
+    AdtId, DefWithBodyId, GenericDefId, TypeParamId, VariantId,
 };
 use crate::{LifetimeParamId, signatures::StructFlags};
 use crate::{item_tree::FieldsShape, signatures::FieldData};
-
 use super::*;
 
 macro_rules! w {
             item_name(db, it, "<missing>")
         ),
     };
-
     let mut p = Printer {
         db,
         store: body,
         ),
         VariantId::UnionId(it) => format!("union {}", item_name(db, it, "<missing>")),
     };
-
     let fields = owner.fields(db);
-
     let mut p = Printer {
         db,
         store: &fields.store,
         FieldsShape::Tuple => wln!(p, "("),
         FieldsShape::Unit => (),
     }
-
     for (_, data) in fields.fields().iter() {
         let FieldData { name, type_ref, visibility, is_unsafe } = data;
         match visibility {
         w!(p, "{}: ", name.display(db, p.edition));
         p.print_type_ref(*type_ref);
     }
-
     match fields.shape {
         FieldsShape::Record => wln!(p, "}}"),
         FieldsShape::Tuple => wln!(p, ");"),
         FieldsShape::Tuple => wln!(p, "(...)"),
         FieldsShape::Unit => (),
     }
-
     print_where_clauses(db, generic_params, &mut p);
-
     match shape {
         FieldsShape::Record => wln!(p),
         FieldsShape::Tuple => wln!(p, ";"),
         FieldsShape::Unit => wln!(p, ";"),
     }
-
     p.buf
 }
 
         w!(p, " -> ");
         p.print_type_ref(*ret_type);
     }
-
     print_where_clauses(db, generic_params, &mut p);
     wln!(p, " {{...}}");
-
     p.buf
 }
 
     }
 }
 
-fn print_generic_params(db: &dyn DefDatabase, generic_params: &GenericParams, p: &mut Printer<'_>) {
+fn print_generic_params(
+    db: &dyn DefDatabase,
+    generic_params: &GenericParams,
+    p: &mut Printer<'_>,
+) {
     if !generic_params.is_empty() {
         w!(p, "<");
         let mut first = true;
                 };
             }
         }
-
         Ok(())
     }
 }
         }
     }
 
-    // Add a newline if the current line is not empty.
-    // If the current line is empty, add a space instead.
-    //
-    // Do not use [`writeln!()`] or [`wln!()`] here, which will result in
-    // infinite recursive calls to this function.
     fn newline(&mut self) {
         if matches!(self.line_format, LineFormat::Oneline) {
             match self.buf.chars().last() {
 
     fn print_expr(&mut self, expr: ExprId) {
         let expr = &self.store[expr];
-
         match expr {
             Expr::Missing => w!(self, "�"),
             Expr::Underscore => w!(self, "_"),
 
     fn print_pat(&mut self, pat: PatId) {
         let pat = &self.store[pat];
-
         match pat {
             Pat::Missing => w!(self, "�"),
             Pat::Wild => w!(self, "_"),
                 ),
             },
         }
-
         for (i, segment) in path.segments().iter().enumerate() {
             if i != 0 || !matches!(path.kind(), PathKind::Plain) {
                 w!(self, "::");
 
     pub(crate) fn print_type_param(&mut self, param: TypeParamId) {
         let generic_params = self.db.generic_params(param.parent());
-
         match generic_params[param.local_id()].name() {
             Some(name) => w!(self, "{}", name.display(self.db, self.edition)),
             None => w!(self, "Param[{}]", param.local_id().into_raw()),