COMPARISON DIFF
============================================================

Original size: 45518 bytes
Chloro size:   45534 bytes
Rustfmt size:  47357 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! A pretty-printer for HIR.
+
 #![allow(dead_code)]
 
 use std::{
 use itertools::Itertools;
 use span::Edition;
 use syntax::ast::HasName;
+use crate::{LifetimeParamId, signatures::StructFlags};
+use crate::{item_tree::FieldsShape, signatures::FieldData};
 
 use crate::{
     AdtId, DefWithBodyId, GenericDefId, TypeParamId, VariantId,
     src::HasSource,
     type_ref::{ConstRef, LifetimeRef, Mutability, TraitBoundModifier, TypeBound, UseArgRef},
 };
-use crate::{LifetimeParamId, signatures::StructFlags};
-use crate::{item_tree::FieldsShape, signatures::FieldData};
 
 use super::*;
 
 {
     let loc = id.lookup(db);
     let source = loc.source(db);
-    source
-        .value
-        .name()
-        .map_or_else(|| default.to_owned(), |name| name.to_string())
+    source.value.name().map_or_else(|| default.to_owned(), |name| name.to_string())
 }
 
 pub fn print_body_hir(
         p.buf.push(' ');
     }
     p.print_expr(body.body_expr);
-    if matches!(
-        owner,
-        DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_)
-    ) {
+    if matches!(owner, DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_)) {
         p.buf.push(';');
     }
     p.buf
     }
 
     for (_, data) in fields.fields().iter() {
-        let FieldData {
-            name,
-            type_ref,
-            visibility,
-            is_unsafe,
-        } = data;
+        let FieldData { name, type_ref, visibility, is_unsafe } = data;
         match visibility {
             crate::item_tree::RawVisibility::Module(interned, _visibility_explicitness) => {
                 w!(p, "pub(in {})", interned.display(db, p.edition))
 
 pub fn print_struct(
     db: &dyn DefDatabase,
-    StructSignature {
-        name,
-        generic_params,
-        store,
-        flags,
-        shape,
-        repr,
-    }: &StructSignature,
+    StructSignature { name, generic_params, store, flags, shape, repr }: &StructSignature,
     edition: Edition,
 ) -> String {
     let mut p = Printer {
         if i != 0 {
             w!(p, ", ");
         }
-        if legacy_const_generics_indices
-            .as_ref()
-            .is_some_and(|idx| idx.contains(&(i as u32)))
-        {
+        if legacy_const_generics_indices.as_ref().is_some_and(|idx| idx.contains(&(i as u32))) {
             w!(p, "const: ");
         }
         p.print_type_ref(*param);
                         w!(p, ": ");
                         p.print_lifetime_ref(*bound);
                     }
-                    WherePredicate::ForLifetime {
-                        lifetimes,
-                        target,
-                        bound,
-                    } => {
+                    WherePredicate::ForLifetime { lifetimes, target, bound } => {
                         w!(p, "for<");
                         for (i, lifetime) in lifetimes.iter().enumerate() {
                             if i != 0 {
     }
 }
 
-fn print_generic_params(db: &dyn DefDatabase, generic_params: &GenericParams, p: &mut Printer<'_>) {
+fn print_generic_params(
+    db: &dyn DefDatabase,
+    generic_params: &GenericParams,
+    p: &mut Printer<'_>,
+) {
     if !generic_params.is_empty() {
         w!(p, "<");
         let mut first = true;
         store,
         buf: String::new(),
         indent_level: 0,
-        line_format: if oneline {
-            LineFormat::Oneline
-        } else {
-            LineFormat::Newline
-        },
+        line_format: if oneline { LineFormat::Oneline } else { LineFormat::Newline },
         edition,
     };
     p.print_pat(pat);
 
             self.buf.push_str(line);
 
-            if matches!(
-                self.line_format,
-                LineFormat::Newline | LineFormat::Indentation
-            ) {
+            if matches!(self.line_format, LineFormat::Newline | LineFormat::Indentation) {
                 self.line_format = if line.ends_with('\n') {
                     LineFormat::Indentation
                 } else {
                 );
             }
             Expr::Path(path) => self.print_path(path),
-            Expr::If {
-                condition,
-                then_branch,
-                else_branch,
-            } => {
+            Expr::If { condition, then_branch, else_branch } => {
                 w!(self, "if ");
                 self.print_expr(*condition);
                 w!(self, " ");
             }
             Expr::Loop { body, label } => {
                 if let Some(lbl) = label {
-                    w!(
-                        self,
-                        "{}: ",
-                        self.store[*lbl].name.display(self.db, self.edition)
-                    );
+                    w!(self, "{}: ", self.store[*lbl].name.display(self.db, self.edition));
                 }
                 w!(self, "loop ");
                 self.print_expr(*body);
                 }
                 w!(self, ")");
             }
-            Expr::MethodCall {
-                receiver,
-                method_name,
-                args,
-                generic_args,
-            } => {
+            Expr::MethodCall { receiver, method_name, args, generic_args } => {
                 self.print_expr(*receiver);
                 w!(self, ".{}", method_name.display(self.db, self.edition));
                 if let Some(args) = generic_args {
             Expr::Continue { label } => {
                 w!(self, "continue");
                 if let Some(lbl) = label {
-                    w!(
-                        self,
-                        " {}",
-                        self.store[*lbl].name.display(self.db, self.edition)
-                    );
+                    w!(self, " {}", self.store[*lbl].name.display(self.db, self.edition));
                 }
             }
             Expr::Break { expr, label } => {
                 w!(self, "break");
                 if let Some(lbl) = label {
-                    w!(
-                        self,
-                        " {}",
-                        self.store[*lbl].name.display(self.db, self.edition)
-                    );
+                    w!(self, " {}", self.store[*lbl].name.display(self.db, self.edition));
                 }
                 if let Some(expr) = expr {
                     self.whitespace();
                     self.print_expr(*expr);
                 }
             }
-            Expr::RecordLit {
-                path,
-                fields,
-                spread,
-            } => {
+            Expr::RecordLit { path, fields, spread } => {
                 match path {
                     Some(path) => self.print_path(path),
                     None => w!(self, "�"),
                 w!(self, " as ");
                 self.print_type_ref(*type_ref);
             }
-            Expr::Ref {
-                expr,
-                rawness,
-                mutability,
-            } => {
+            Expr::Ref { expr, rawness, mutability } => {
                 w!(self, "&");
                 if rawness.is_raw() {
                     w!(self, "raw ");
                 self.print_expr(*rhs);
                 w!(self, "{}", ket);
             }
-            Expr::Range {
-                lhs,
-                rhs,
-                range_type,
-            } => {
+            Expr::Range { lhs, rhs, range_type } => {
                 if let Some(lhs) = lhs {
                     w!(self, "(");
                     self.print_expr(*lhs);
                 self.print_expr(*index);
                 w!(self, "]");
             }
-            Expr::Closure {
-                args,
-                arg_types,
-                ret_type,
-                body,
-                closure_kind,
-                capture_by,
-            } => {
+            Expr::Closure { args, arg_types, ret_type, body, closure_kind, capture_by } => {
                 match closure_kind {
                     ClosureKind::Coroutine(Movability::Static) => {
                         w!(self, "static ");
                                 w!(p, ", ");
                             }
                         }
-                        Array::Repeat {
-                            initializer,
-                            repeat,
-                        } => {
+                        Array::Repeat { initializer, repeat } => {
                             p.print_expr(*initializer);
                             w!(p, "; ");
                             p.print_expr(*repeat);
                 w!(self, "]");
             }
             Expr::Literal(lit) => self.print_literal(lit),
-            Expr::Block {
-                id: _,
-                statements,
-                tail,
-                label,
-            } => {
+            Expr::Block { id: _, statements, tail, label } => {
                 let label = label.map(|lbl| {
                     format!("{}: ", self.store[lbl].name.display(self.db, self.edition))
                 });
                 self.print_block(label.as_deref(), statements, tail);
             }
-            Expr::Unsafe {
-                id: _,
-                statements,
-                tail,
-            } => {
+            Expr::Unsafe { id: _, statements, tail } => {
                 self.print_block(Some("unsafe "), statements, tail);
             }
-            Expr::Async {
-                id: _,
-                statements,
-                tail,
-            } => {
+            Expr::Async { id: _, statements, tail } => {
                 self.print_block(Some("async "), statements, tail);
             }
             Expr::Const(id) => {
                 }
                 w!(self, ")");
             }
-            Pat::Record {
-                path,
-                args,
-                ellipsis,
-            } => {
+            Pat::Record { path, args, ellipsis } => {
                 match path {
                     Some(path) => self.print_path(path),
                     None => w!(self, "�"),
 
                         let mut same_name = false;
                         if let Pat::Bind { id, subpat: None } = &self.store[arg.pat]
-                            && let Binding {
-                                name,
-                                mode: BindingAnnotation::Unannotated,
-                                ..
-                            } = &self.store.assert_expr_only().bindings[*id]
+                            && let Binding { name, mode: BindingAnnotation::Unannotated, .. } =
+                                &self.store.assert_expr_only().bindings[*id]
                             && name.as_str() == field_name
                         {
                             same_name = true;
                     self.print_expr(*end);
                 }
             }
-            Pat::Slice {
-                prefix,
-                slice,
-                suffix,
-            } => {
+            Pat::Slice { prefix, slice, suffix } => {
                 w!(self, "[");
                 for pat in prefix.iter() {
                     self.print_pat(*pat);
                     self.print_pat(*pat);
                 }
             }
-            Pat::TupleStruct {
-                path,
-                args,
-                ellipsis,
-            } => {
+            Pat::TupleStruct { path, args, ellipsis } => {
                 match path {
                     Some(path) => self.print_path(path),
                     None => w!(self, "�"),
 
     fn print_stmt(&mut self, stmt: &Statement) {
         match stmt {
-            Statement::Let {
-                pat,
-                type_ref,
-                initializer,
-                else_branch,
-            } => {
+            Statement::Let { pat, type_ref, initializer, else_branch } => {
                 w!(self, "let ");
                 self.print_pat(*pat);
                 if let Some(ty) = type_ref {
 
     pub(crate) fn print_lifetime_param(&mut self, param: LifetimeParamId) {
         let generic_params = self.db.generic_params(param.parent);
-        w!(
-            self,
-            "{}",
-            generic_params[param.local_id]
-                .name
-                .display(self.db, self.edition)
-        )
+        w!(self, "{}", generic_params[param.local_id].name.display(self.db, self.edition))
     }
 
     pub(crate) fn print_lifetime_ref(&mut self, lt_ref: LifetimeRefId) {
                 w!(self, "]");
             }
             TypeRef::Fn(fn_) => {
-                let ((_, return_type), args) = fn_
-                    .params
-                    .split_last()
-                    .expect("TypeRef::Fn is missing return type");
+                let ((_, return_type), args) =
+                    fn_.params.split_last().expect("TypeRef::Fn is missing return type");
                 if fn_.is_unsafe {
                     w!(self, "unsafe ");
                 }