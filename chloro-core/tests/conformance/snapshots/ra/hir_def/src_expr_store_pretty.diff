COMPARISON DIFF
============================================================

Original size: 45518 bytes
Chloro size:   45288 bytes
Rustfmt size:  45518 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! A pretty-printer for HIR.
+
 #![allow(dead_code)]
 
 use std::{
     mem,
 };
 
-use hir_expand::{Lookup, mod_path::PathKind};
+use hir_expand::{mod_path::PathKind, Lookup};
 use itertools::Itertools;
 use span::Edition;
 use syntax::ast::HasName;
 
 use crate::{
-    AdtId, DefWithBodyId, GenericDefId, TypeParamId, VariantId,
     expr_store::path::{GenericArg, GenericArgs},
     hir::{
-        Array, BindingAnnotation, CaptureBy, ClosureKind, Literal, Movability, Statement,
-        generics::{GenericParams, WherePredicate},
+        generics::{GenericParams, WherePredicate}, Array, BindingAnnotation, CaptureBy,
+        ClosureKind, Literal, Movability, Statement,
     },
     lang_item::LangItemTarget,
     signatures::{FnFlags, FunctionSignature, StructSignature},
     src::HasSource,
     type_ref::{ConstRef, LifetimeRef, Mutability, TraitBoundModifier, TypeBound, UseArgRef},
+    AdtId, DefWithBodyId, GenericDefId, TypeParamId, VariantId,
 };
-use crate::{LifetimeParamId, signatures::StructFlags};
+use crate::{signatures::StructFlags, LifetimeParamId};
 use crate::{item_tree::FieldsShape, signatures::FieldData};
 
 use super::*;
     }
 }
 
-fn print_generic_params(db: &dyn DefDatabase, generic_params: &GenericParams, p: &mut Printer<'_>) {
+fn print_generic_params(
+    db: &dyn DefDatabase,
+    generic_params: &GenericParams,
+    p: &mut Printer<'_>,
+) {
     if !generic_params.is_empty() {
         w!(p, "<");
         let mut first = true;
 
     fn whitespace(&mut self) {
         match self.buf.chars().next_back() {
-            None | Some('\n' | ' ') => {}
+            None | Some('\n' | ' ') => {},
             _ => self.buf.push(' '),
         }
     }
 
-    // Add a newline if the current line is not empty.
-    // If the current line is empty, add a space instead.
-    //
-    // Do not use [`writeln!()`] or [`wln!()`] here, which will result in
-    // infinite recursive calls to this function.
     fn newline(&mut self) {
         if matches!(self.line_format, LineFormat::Oneline) {
             match self.buf.chars().last() {
-                Some(' ') | None => {}
+                Some(' ') | None => {},
                 Some(_) => {
                     w!(self, " ");
                 }
             }
         } else {
             match self.buf.chars().rev().find_position(|ch| *ch != ' ') {
-                Some((_, '\n')) | None => {}
+                Some((_, '\n')) | None => {},
                 Some((idx, _)) => {
                     if idx != 0 {
                         self.buf.drain(self.buf.len() - idx..);
                     Some(path) => self.print_path(path),
                     None => w!(self, "�"),
                 }
-
                 w!(self, "{{");
                 let edition = self.edition;
                 self.indented(|p| {
                     Some(path) => self.print_path(path),
                     None => w!(self, "�"),
                 }
-
                 w!(self, " {{");
                 let edition = self.edition;
                 let oneline = matches!(self.line_format, LineFormat::Oneline);
             if i != 0 || !matches!(path.kind(), PathKind::Plain) {
                 w!(self, "::");
             }
-
             w!(self, "{}", segment.name.display(self.db, self.edition));
             if let Some(generics) = segment.args_and_bindings {
                 w!(self, "::<");
                 self.print_generic_args(generics);
-
                 w!(self, ">");
             }
         }
             if i != 0 {
                 w!(self, " + ");
             }
-
             match bound {
                 TypeBound::Path(path, modifier) => {
                     match modifier {