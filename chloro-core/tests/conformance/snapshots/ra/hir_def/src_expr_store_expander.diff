COMPARISON DIFF
============================================================

Original size: 8495 bytes
Chloro size:   8586 bytes
Rustfmt size:  8873 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use cfg::CfgOptions;
 use drop_bomb::DropBomb;
-use hir_expand::span_map::SpanMapRef;
 use hir_expand::AstId;
+use hir_expand::span_map::SpanMapRef;
 use hir_expand::{
-    eager::EagerCallBackFn, mod_path::ModPath, span_map::SpanMap, ExpandError, ExpandErrorKind,
-    ExpandResult, HirFileId, InFile, Lookup, MacroCallId,
+    ExpandError, ExpandErrorKind, ExpandResult, HirFileId, InFile, Lookup, MacroCallId,
+    eager::EagerCallBackFn, mod_path::ModPath, span_map::SpanMap,
 };
 use span::{AstIdMap, Edition, SyntaxContext};
 use syntax::ast::HasAttrs;
-use syntax::{ast, AstNode, Parse};
+use syntax::{AstNode, Parse, ast};
 use triomphe::Arc;
 use tt::TextRange;
 
 use crate::expr_store::HygieneId;
 use crate::macro_call_as_call_id;
 use crate::nameres::DefMap;
-use crate::{db::DefDatabase, MacroId, UnresolvedMacro};
+use crate::{MacroId, UnresolvedMacro, db::DefDatabase};
 
 #[derive(Debug)]
 pub(super) struct Expander {
         }
     }
 
-    pub(super) fn ctx_for_range(&self, range: TextRange) -> SyntaxContext {
+    pub(super) fn ctx_for_range(
+        &self,
+        range: TextRange,
+    ) -> SyntaxContext {
         self.span_map.span_for_range(range).ctx
     }
 
-    pub(super) fn hygiene_for_range(&self, db: &dyn DefDatabase, range: TextRange) -> HygieneId {
+    pub(super) fn hygiene_for_range(
+        &self,
+        db: &dyn DefDatabase,
+        range: TextRange,
+    ) -> HygieneId {
         match self.span_map.as_ref() {
-            hir_expand::span_map::SpanMapRef::ExpansionSpanMap(span_map) => HygieneId::new(
-                span_map
-                    .span_at(range.start())
-                    .ctx
-                    .opaque_and_semitransparent(db),
-            ),
+            hir_expand::span_map::SpanMapRef::ExpansionSpanMap(span_map) => {
+                HygieneId::new(span_map.span_at(range.start()).ctx.opaque_and_semitransparent(db))
+            }
             hir_expand::span_map::SpanMapRef::RealSpanMap(_) => HygieneId::ROOT,
         }
     }
     ) -> Result<ExpandResult<Option<(Mark, Option<Parse<T>>)>>, UnresolvedMacro> {
         // FIXME: within_limit should support this, instead of us having to extract the error
         let mut unresolved_macro_err = None;
-
         let result = self.within_limit(db, |this| {
             let macro_call = this.in_file(&macro_call);
 
             let expands_to = hir_expand::ExpandTo::from_call_site(macro_call.value);
-            let ast_id = AstId::new(
-                macro_call.file_id,
-                this.ast_id_map().ast_id(macro_call.value),
-            );
+            let ast_id = AstId::new(macro_call.file_id, this.ast_id_map().ast_id(macro_call.value));
             let path = macro_call.value.path().and_then(|path| {
                 let range = path.syntax().text_range();
                 let mod_path = ModPath::from_src(db, path, &mut |range| {
 
             let Some((call_site, path)) = path else {
                 return ExpandResult::only_err(ExpandError::other(
-                    this.span_map
-                        .span_for_range(macro_call.value.syntax().text_range()),
+                    this.span_map.span_for_range(macro_call.value.syntax().text_range()),
                     "malformed macro invocation",
                 ));
             };
                 Ok(call_id) => call_id,
                 Err(resolve_err) => {
                     unresolved_macro_err = Some(resolve_err);
-                    ExpandResult {
-                        value: None,
-                        err: None,
-                    }
+                    ExpandResult { value: None, err: None }
                 }
             }
         });
-
-        if let Some(err) = unresolved_macro_err {
-            Err(err)
-        } else {
-            Ok(result)
-        }
+        if let Some(err) = unresolved_macro_err { Err(err) } else { Ok(result) }
     }
 
     pub(super) fn enter_expand_id<T: ast::AstNode>(
 
     pub(super) fn exit(
         &mut self,
-        Mark {
-            file_id,
-            span_map,
-            ast_id_map,
-            mut bomb,
-        }: Mark,
+        Mark { file_id, span_map, ast_id_map, mut bomb }: Mark,
     ) {
         self.span_map = span_map;
         self.current_file_id = file_id;
         bomb.defuse();
     }
 
-    pub(super) fn in_file<T>(&self, value: T) -> InFile<T> {
-        InFile {
-            file_id: self.current_file_id,
-            value,
-        }
+    pub(super) fn in_file<T>(
+        &self,
+        value: T,
+    ) -> InFile<T> {
+        InFile { file_id: self.current_file_id, value }
     }
 
     pub(super) fn current_file_id(&self) -> HirFileId {
         op: F,
     ) -> ExpandResult<Option<(Mark, Option<Parse<T>>)>>
     where
-        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,
-    {
+        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>, {
         if self.recursion_depth == u32::MAX {
             // Recursion limit has been reached somewhere in the macro expansion tree. We should
             // stop expanding other macro calls in this tree, or else this may result in
             cov_mark::hit!(overflow_but_not_me);
             return ExpandResult::ok(None);
         }
-
         let ExpandResult { value, err } = op(self);
         let Some(call_id) = value else {
             return ExpandResult { value: None, err };
             self.recursion_depth = u32::MAX;
             cov_mark::hit!(your_stack_belongs_to_me);
             return ExpandResult::only_err(ExpandError::new(
-                db.macro_arg_considering_derives(call_id, &call_id.lookup(db).kind)
-                    .2,
+                db.macro_arg_considering_derives(call_id, &call_id.lookup(db).kind).2,
                 ExpandErrorKind::RecursionOverflow,
             ));
         }
-
         let res = db.parse_macro_expansion(call_id);
-
         let err = err.or(res.err);
         ExpandResult {
             value: {