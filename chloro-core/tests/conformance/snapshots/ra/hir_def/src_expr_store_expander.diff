COMPARISON DIFF
============================================================

Original size: 8495 bytes
Chloro size:   8535 bytes
Rustfmt size:  8873 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::Crate;
 use cfg::CfgOptions;
 use drop_bomb::DropBomb;
-use hir_expand::span_map::SpanMapRef;
 use hir_expand::AstId;
+use hir_expand::span_map::SpanMapRef;
 use hir_expand::{
     eager::EagerCallBackFn, mod_path::ModPath, span_map::SpanMap, ExpandError, ExpandErrorKind,
     ExpandResult, HirFileId, InFile, Lookup, MacroCallId,
 
     pub(super) fn hygiene_for_range(&self, db: &dyn DefDatabase, range: TextRange) -> HygieneId {
         match self.span_map.as_ref() {
-            hir_expand::span_map::SpanMapRef::ExpansionSpanMap(span_map) => HygieneId::new(
-                span_map
-                    .span_at(range.start())
-                    .ctx
-                    .opaque_and_semitransparent(db),
-            ),
+            hir_expand::span_map::SpanMapRef::ExpansionSpanMap(span_map) => {
+                HygieneId::new(span_map.span_at(range.start()).ctx.opaque_and_semitransparent(db))
+            }
             hir_expand::span_map::SpanMapRef::RealSpanMap(_) => HygieneId::ROOT,
         }
     }
             let macro_call = this.in_file(&macro_call);
 
             let expands_to = hir_expand::ExpandTo::from_call_site(macro_call.value);
-            let ast_id = AstId::new(
-                macro_call.file_id,
-                this.ast_id_map().ast_id(macro_call.value),
-            );
+            let ast_id = AstId::new(macro_call.file_id, this.ast_id_map().ast_id(macro_call.value));
             let path = macro_call.value.path().and_then(|path| {
                 let range = path.syntax().text_range();
                 let mod_path = ModPath::from_src(db, path, &mut |range| {
 
             let Some((call_site, path)) = path else {
                 return ExpandResult::only_err(ExpandError::other(
-                    this.span_map
-                        .span_for_range(macro_call.value.syntax().text_range()),
+                    this.span_map.span_for_range(macro_call.value.syntax().text_range()),
                     "malformed macro invocation",
                 ));
             };
                 Ok(call_id) => call_id,
                 Err(resolve_err) => {
                     unresolved_macro_err = Some(resolve_err);
-                    ExpandResult {
-                        value: None,
-                        err: None,
-                    }
+                    ExpandResult { value: None, err: None }
                 }
             }
         });
         self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))
     }
 
-    pub(super) fn exit(
-        &mut self,
-        Mark {
-            file_id,
-            span_map,
-            ast_id_map,
-            mut bomb,
-        }: Mark,
-    ) {
+    pub(super) fn exit(&mut self, Mark { file_id, span_map, ast_id_map, mut bomb }: Mark) {
         self.span_map = span_map;
         self.current_file_id = file_id;
         self.ast_id_map = ast_id_map;
     }
 
     pub(super) fn in_file<T>(&self, value: T) -> InFile<T> {
-        InFile {
-            file_id: self.current_file_id,
-            value,
-        }
+        InFile { file_id: self.current_file_id, value }
     }
 
     pub(super) fn current_file_id(&self) -> HirFileId {
             self.recursion_depth = u32::MAX;
             cov_mark::hit!(your_stack_belongs_to_me);
             return ExpandResult::only_err(ExpandError::new(
-                db.macro_arg_considering_derives(call_id, &call_id.lookup(db).kind)
-                    .2,
+                db.macro_arg_considering_derives(call_id, &call_id.lookup(db).kind).2,
                 ExpandErrorKind::RecursionOverflow,
             ));
         }