COMPARISON DIFF
============================================================

Original size: 16167 bytes
Chloro size:   16226 bytes
Rustfmt size:  16197 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 mod block;
 
-use crate::{hir::MatchArm, nameres::crate_def_map, test_db::TestDB, DefWithBodyId, ModuleDefId};
-use expect_test::{expect, Expect};
+use crate::{DefWithBodyId, ModuleDefId, hir::MatchArm, nameres::crate_def_map, test_db::TestDB};
+use expect_test::{Expect, expect};
 use la_arena::RawIdx;
 use test_fixture::WithFixture;
 use triomphe::Arc;
                     }
                 },
             }
-        }"#]]
-    .assert_eq(&body.pretty_print(&db, def, Edition::CURRENT))
+        }"#]].assert_eq(
+        &body.pretty_print(&db, def, Edition::CURRENT),
+    )
 }
 
 #[test]
                     }
                 },
             );
-        }"#]]
-    .assert_eq(&body.pretty_print(&db, def, Edition::CURRENT))
+        }"#]].assert_eq(
+        &body.pretty_print(&db, def, Edition::CURRENT),
+    )
 }
 
 #[test]
                     )
                 }
             };
-        }"#]]
-    .assert_eq(&body.pretty_print(&db, def, Edition::CURRENT))
+        }"#]].assert_eq(
+        &body.pretty_print(&db, def, Edition::CURRENT),
+    )
 }
 
 #[test]
                     }
                 },
             );
-        }"#]]
-    .assert_eq(&body.pretty_print(&db, def, Edition::CURRENT))
+        }"#]].assert_eq(
+        &body.pretty_print(&db, def, Edition::CURRENT),
+    )
 }
 
 #[test]
                     ),
                 );
             };
-        }"#]]
-    .assert_eq(&body.pretty_print(&db, def, Edition::CURRENT))
+        }"#]].assert_eq(
+        &body.pretty_print(&db, def, Edition::CURRENT),
+    )
 }
 
 #[test]
     // This is a funny one. `let m!()() = Bar()` is an error in rustc, because `m!()()` isn't a valid pattern,
     // but in destructuring assignment it is valid, because `m!()()` is a valid expression, and destructuring
     // assignments start their lives as expressions. So we have to do the same.
-
     let (db, body, def) = lower(
         r#"
 struct Bar();
     expect![[r#"
         fn foo() {
             Bar() = Bar();
-        }"#]]
-    .assert_eq(&body.pretty_print(&db, def, Edition::CURRENT))
+        }"#]].assert_eq(
+        &body.pretty_print(&db, def, Edition::CURRENT),
+    )
 }
 
 #[test]
 }
     "#,
     );
-    assert_eq!(
-        body.assert_expr_only().bindings.len(),
-        1,
-        "should have a binding for `B`"
-    );
+    assert_eq!(body.assert_expr_only().bindings.len(), 1, "should have a binding for `B`");
     assert_eq!(
         body[BindingId::from_raw(RawIdx::from_u32(0))].name.as_str(),
         "B",
         Pat::Range { start, end } => {
             let hir_start = &body[start.unwrap()];
             let hir_end = &body[end.unwrap()];
-
             assert!(matches!(hir_start, Expr::Path { .. }));
             assert!(matches!(hir_end, Expr::Path { .. }));
         }
-        _ => {}
+        _ => {},
     }
 }