COMPARISON DIFF
============================================================

Original size: 10503 bytes
Chloro size:   10768 bytes
Rustfmt size:  10686 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     Crate, CrateGraphBuilder, CratesMap, FileSourceRootInput, FileText, Nonce, RootQueryDb,
     SourceDatabase, SourceRoot, SourceRootId, SourceRootInput,
 };
-use hir_expand::{files::FilePosition, InFile};
+use hir_expand::{InFile, files::FilePosition};
 use salsa::Durability;
 use span::FileId;
-use syntax::{algo, ast, AstNode};
+use syntax::{AstNode, algo, ast};
 use triomphe::Arc;
 
 use crate::{
-    db::DefDatabase,
-    nameres::{block_def_map, crate_def_map, DefMap, ModuleSource},
-    src::HasSource,
+    db::DefDatabase, nameres::{DefMap, ModuleSource, block_def_map, crate_def_map}, src::HasSource,
     LocalModuleId, Lookup, ModuleDefId, ModuleId,
 };
 
 }
 
 #[salsa_macros::db]
-impl salsa::Database for TestDB {}
+impl salsa::Database for TestDB {
+}
 
 impl fmt::Debug for TestDB {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("TestDB").finish()
     }
 }
 
-impl panic::RefUnwindSafe for TestDB {}
+impl panic::RefUnwindSafe for TestDB {
+}
 
 #[salsa_macros::db]
 impl SourceDatabase for TestDB {
-    fn file_text(&self, file_id: base_db::FileId) -> FileText {
+    fn file_text(
+        &self,
+        file_id: base_db::FileId,
+    ) -> FileText {
         self.files.file_text(file_id)
     }
 
-    fn set_file_text(&mut self, file_id: base_db::FileId, text: &str) {
+    fn set_file_text(
+        &mut self,
+        file_id: base_db::FileId,
+        text: &str,
+    ) {
         let files = Arc::clone(&self.files);
         files.set_file_text(self, file_id, text);
     }
     }
 
     /// Source root of the file.
-    fn source_root(&self, source_root_id: SourceRootId) -> SourceRootInput {
+    fn source_root(
+        &self,
+        source_root_id: SourceRootId,
+    ) -> SourceRootInput {
         self.files.source_root(source_root_id)
     }
 
         files.set_source_root_with_durability(self, source_root_id, source_root, durability);
     }
 
-    fn file_source_root(&self, id: base_db::FileId) -> FileSourceRootInput {
+    fn file_source_root(
+        &self,
+        id: base_db::FileId,
+    ) -> FileSourceRootInput {
         self.files.file_source_root(id)
     }
 
     }
 
     fn nonce_and_revision(&self) -> (Nonce, salsa::Revision) {
-        (
-            self.nonce,
-            salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision(),
-        )
+        (self.nonce, salsa::plumbing::ZalsaDatabase::zalsa(self).current_revision())
     }
 }
 
             .iter()
             .copied()
             .find(|&krate| {
-                krate
-                    .extra_data(self)
-                    .display_name
-                    .as_ref()
-                    .map(|it| it.canonical_name().as_str())
+                krate.extra_data(self).display_name.as_ref().map(|it| it.canonical_name().as_str())
                     == Some("ra_test_fixture")
             })
             .unwrap_or(*all_crates.last().unwrap())
     }
 
-    pub(crate) fn module_for_file(&self, file_id: FileId) -> ModuleId {
+    pub(crate) fn module_for_file(
+        &self,
+        file_id: FileId,
+    ) -> ModuleId {
         for &krate in self.relevant_crates(file_id).iter() {
             let crate_def_map = crate_def_map(self, krate);
             for (local_id, data) in crate_def_map.modules() {
         panic!("Can't find module for file")
     }
 
-    pub(crate) fn module_at_position(&self, position: FilePosition) -> ModuleId {
+    pub(crate) fn module_at_position(
+        &self,
+        position: FilePosition,
+    ) -> ModuleId {
         let file_module = self.module_for_file(position.file_id.file_id(self));
         let mut def_map = file_module.def_map(self);
         let module = self.mod_at_position(def_map, position);
-
         def_map = match self.block_at_position(def_map, position) {
             Some(it) => it,
             None => return def_map.module_id(module),
     }
 
     /// Finds the smallest/innermost module in `def_map` containing `position`.
-    fn mod_at_position(&self, def_map: &DefMap, position: FilePosition) -> LocalModuleId {
+    fn mod_at_position(
+        &self,
+        def_map: &DefMap,
+        position: FilePosition,
+    ) -> LocalModuleId {
         let mut size = None;
         let mut res = DefMap::ROOT;
         for (module, data) in def_map.modules() {
                 res = module;
             }
         }
-
         res
     }
 
-    fn block_at_position(&self, def_map: &DefMap, position: FilePosition) -> Option<&DefMap> {
+    fn block_at_position(
+        &self,
+        def_map: &DefMap,
+        position: FilePosition,
+    ) -> Option<&DefMap> {
         // Find the smallest (innermost) function in `def_map` containing the cursor.
         let mut size = None;
         let mut fn_def = None;
                 }
             }
         }
-
         // Find the innermost block expression that has a `DefMap`.
         let def_with_body = fn_def?.into();
         let source_map = self.body_with_source_map(def_with_body).1;
         let scopes = self.expr_scopes(def_with_body);
-
         let root_syntax_node = self.parse(position.file_id).syntax_node();
         let scope_iter =
             algo::ancestors_at_offset(&root_syntax_node, position.offset).filter_map(|node| {
                 let scope = scopes.scope_for(expr_id).unwrap();
                 Some(scope)
             });
-
         for scope in scope_iter {
-            let mut containing_blocks = scopes
-                .scope_chain(Some(scope))
-                .filter_map(|scope| scopes.block(scope));
+            let mut containing_blocks =
+                scopes.scope_chain(Some(scope)).filter_map(|scope| scopes.block(scope));
 
-            if let Some(block) = containing_blocks
-                .next()
-                .map(|block| block_def_map(self, block))
-            {
+            if let Some(block) = containing_blocks.next().map(|block| block_def_map(self, block)) {
                 return Some(block);
             }
         }
-
         None
     }
 
-    pub(crate) fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event> {
+    pub(crate) fn log(
+        &self,
+        f: impl FnOnce(),
+    ) -> Vec<salsa::Event> {
         *self.events.lock().unwrap() = Some(Vec::new());
         f();
         self.events.lock().unwrap().take().unwrap()
     }
 
-    pub(crate) fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {
+    pub(crate) fn log_executed(
+        &self,
+        f: impl FnOnce(),
+    ) -> Vec<String> {
         let events = self.log(f);
         events
             .into_iter()