COMPARISON DIFF
============================================================

Original size: 29602 bytes
Chloro size:   29511 bytes
Rustfmt size:  30449 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 mod mod_resolution;
 mod path_resolution;
 pub mod proc_macro;
-
 #[cfg(test)]
 mod tests;
 
     AstId, BlockId, BlockLoc, CrateRootModuleId, ExternCrateId, FunctionId, FxIndexMap,
     LocalModuleId, Lookup, MacroExpander, MacroId, ModuleId, ProcMacroId, UseId,
 };
-
 pub use self::path_resolution::ResolvePathResultPrefixInfo;
 
 const PREDEFINED_TOOLS: &[SmolStr] = &[
 }
 
 impl LocalDefMap {
-    pub(crate) const EMPTY: &Self = &Self {
-        extern_prelude: FxIndexMap::with_hasher(rustc_hash::FxBuildHasher),
-    };
+    pub(crate) const EMPTY: &Self = &Self { extern_prelude: FxIndexMap::with_hasher(rustc_hash::FxBuildHasher) };
 
     fn shrink_to_fit(&mut self) {
         let Self { extern_prelude } = self;
 
     pub(crate) fn extern_prelude(
         &self,
-    ) -> impl DoubleEndedIterator<Item = (&Name, (CrateRootModuleId, Option<ExternCrateId>))> + '_
-    {
+    ) -> impl DoubleEndedIterator<Item = (&Name, (CrateRootModuleId, Option<ExternCrateId>))> + '_ {
         self.extern_prelude.iter().map(|(name, &def)| (name, def))
     }
 }
     /// this contains all kinds of macro, not just `macro_rules!` macro.
     /// ExternCrateId being None implies it being imported from the general prelude import.
     macro_use_prelude: FxHashMap<Name, (MacroId, Option<ExternCrateId>)>,
-
+    // FIXME: Figure out a better way for the IDE layer to resolve these?
     /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper
     /// attributes.
-    // FIXME: Figure out a better way for the IDE layer to resolve these?
     derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<(Name, MacroId, MacroCallId)>>,
     /// A mapping from [`hir_expand::MacroDefId`] to [`crate::MacroId`].
     pub macro_def_to_macro_id: FxHashMap<ErasedAstId, MacroId>,
-
     /// The diagnostics that need to be emitted for this crate.
     diagnostics: Vec<DefDiagnostic>,
-
     /// The crate data that is shared between a crate's def map and all its block def maps.
     data: Arc<DefMapCrateData>,
 }
     /// Side table for resolving derive helpers.
     exported_derives: FxHashMap<MacroId, Box<[Name]>>,
     fn_proc_macro_mapping: FxHashMap<FunctionId, ProcMacroId>,
-
     /// Custom tool modules registered with `#![register_tool]`.
     registered_tools: Vec<Symbol>,
     /// Unstable features of Rust enabled with `#![feature(A, B)]`.
     rustc_coherence_is_core: bool,
     no_core: bool,
     no_std: bool,
-
     edition: Edition,
     recursion_limit: Option<u32>,
 }
         Self {
             exported_derives: FxHashMap::default(),
             fn_proc_macro_mapping: FxHashMap::default(),
-            registered_tools: PREDEFINED_TOOLS
-                .iter()
-                .map(|it| Symbol::intern(it))
-                .collect(),
+            registered_tools: PREDEFINED_TOOLS.iter().map(|it| Symbol::intern(it)).collect(),
             unstable_features: FxHashSet::default(),
             rustc_coherence_is_core: false,
             no_core: false,
     }
 
     fn into_module(self, krate: Crate) -> ModuleId {
-        ModuleId {
-            krate,
-            block: self.block,
-            local_id: self.local_id,
-        }
+        ModuleId { krate, block: self.block, local_id: self.local_id }
     }
 
     fn is_block_module(self) -> bool {
 
 impl std::ops::Index<LocalModuleId> for DefMap {
     type Output = ModuleData;
+
     fn index(&self, id: LocalModuleId) -> &ModuleData {
         &self.modules[id]
     }
 impl ModuleOrigin {
     pub fn declaration(&self) -> Option<AstId<ast::Module>> {
         match self {
-            &ModuleOrigin::File {
-                declaration,
-                declaration_tree_id,
-                ..
-            } => Some(AstId::new(declaration_tree_id.file_id(), declaration)),
-            &ModuleOrigin::Inline {
-                definition,
-                definition_tree_id,
-            } => Some(AstId::new(definition_tree_id.file_id(), definition)),
+            &ModuleOrigin::File { declaration, declaration_tree_id, .. } => {
+                Some(AstId::new(declaration_tree_id.file_id(), declaration))
+            }
+            &ModuleOrigin::Inline { definition, definition_tree_id } => {
+                Some(AstId::new(definition_tree_id.file_id(), definition))
+            }
             ModuleOrigin::CrateRoot { .. } | ModuleOrigin::BlockExpr { .. } => None,
         }
     }
     /// That is, a file or a `mod foo {}` with items.
     pub fn definition_source(&self, db: &dyn DefDatabase) -> InFile<ModuleSource> {
         match self {
-            &ModuleOrigin::File {
-                definition: editioned_file_id,
-                ..
-            }
-            | &ModuleOrigin::CrateRoot {
-                definition: editioned_file_id,
-            } => {
+            &ModuleOrigin::File { definition: editioned_file_id, .. }
+            | &ModuleOrigin::CrateRoot { definition: editioned_file_id } => {
                 let sf = db.parse(editioned_file_id).tree();
                 InFile::new(editioned_file_id.into(), ModuleSource::SourceFile(sf))
             }
-            &ModuleOrigin::Inline {
-                definition,
-                definition_tree_id,
-            } => InFile::new(
+            &ModuleOrigin::Inline { definition, definition_tree_id } => InFile::new(
                 definition_tree_id.file_id(),
                 ModuleSource::Module(
                     AstId::new(definition_tree_id.file_id(), definition).to_node(db),
     .entered();
 
     let module_data = ModuleData::new(
-        ModuleOrigin::CrateRoot {
-            definition: krate.root_file_id(db),
-        },
+        ModuleOrigin::CrateRoot { definition: krate.root_file_id(db) },
         Visibility::Public,
     );
 
-    let def_map = DefMap::empty(
-        crate_id,
-        Arc::new(DefMapCrateData::new(krate.edition)),
-        module_data,
-        None,
-    );
+    let def_map =
+        DefMap::empty(crate_id, Arc::new(DefMapCrateData::new(krate.edition)), module_data, None);
     let (def_map, local_def_map) = collector::collect_defs(
         db,
         def_map,
     let BlockLoc { ast_id, module } = block_id.lookup(db);
 
     let visibility = Visibility::Module(
-        ModuleId {
-            krate: module.krate,
-            local_id: DefMap::ROOT,
-            block: module.block,
-        },
+        ModuleId { krate: module.krate, local_id: DefMap::ROOT, block: module.block },
         VisibilityExplicitness::Implicit,
     );
-    let module_data = ModuleData::new(
-        ModuleOrigin::BlockExpr {
-            block: ast_id,
-            id: block_id,
-        },
-        visibility,
-    );
+    let module_data =
+        ModuleData::new(ModuleOrigin::BlockExpr { block: ast_id, id: block_id }, visibility);
 
     let local_def_map = crate_local_def_map(db, module.krate);
     let def_map = DefMap::empty(
         module_data,
         Some(BlockInfo {
             block: block_id,
-            parent: BlockRelativeModuleId {
-                block: module.block,
-                local_id: module.local_id,
-            },
+            parent: BlockRelativeModuleId { block: module.block, local_id: module.local_id },
         }),
     );
 
             macro_def_to_macro_id: FxHashMap::default(),
         }
     }
+
     fn shrink_to_fit(&mut self) {
         // Exhaustive match to require handling new fields.
         let Self {
         &self,
         id: AstId<ast::Adt>,
     ) -> Option<&[(Name, MacroId, MacroCallId)]> {
-        self.derive_helpers_in_scope
-            .get(&id.map(|it| it.upcast()))
-            .map(Deref::deref)
+        self.derive_helpers_in_scope.get(&id.map(|it| it.upcast())).map(Deref::deref)
     }
 
     pub fn registered_tools(&self) -> &[Symbol] {
 
     pub fn module_id(&self, local_id: LocalModuleId) -> ModuleId {
         let block = self.block.map(|b| b.block);
-        ModuleId {
-            krate: self.krate,
-            local_id,
-            block,
-        }
+        ModuleId { krate: self.krate, local_id, block }
     }
 
     pub fn crate_root(&self) -> CrateRootModuleId {
     /// might again be a block, or a module inside a block).
     pub fn parent(&self) -> Option<ModuleId> {
         let BlockRelativeModuleId { block, local_id } = self.block?.parent;
-        Some(ModuleId {
-            krate: self.krate,
-            block,
-            local_id,
-        })
+        Some(ModuleId { krate: self.krate, block, local_id })
     }
 
     /// Returns the module containing `local_mod`, either the parent `mod`, or the module (or block) containing
     pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {
         match self[local_mod].parent {
             Some(parent) => Some(self.module_id(parent)),
-            None => self.block.map(
-                |BlockInfo {
-                     parent: BlockRelativeModuleId { block, local_id },
-                     ..
-                 }| {
-                    ModuleId {
-                        krate: self.krate,
-                        block,
-                        local_id,
-                    }
-                },
-            ),
+            None => {
+                self.block.map(
+                    |BlockInfo { parent: BlockRelativeModuleId { block, local_id }, .. }| {
+                        ModuleId { krate: self.krate, block, local_id }
+                    },
+                )
+            }
         }
     }
 
         self.data.recursion_limit.unwrap_or(128)
     }
 
-    // FIXME: this can use some more human-readable format (ideally, an IR
-    // even), as this should be a great debugging aid.
     pub fn dump(&self, db: &dyn DefDatabase) -> String {
         let mut buf = String::new();
         let mut arc;
 
             map.modules[module].scope.dump(db, buf);
 
-            for (name, child) in map.modules[module]
-                .children
-                .iter()
-                .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
+            for (name, child) in
+                map.modules[module].children.iter().sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
             {
                 let path = format!("{path}::{}", name.display(db, Edition::LATEST));
                 buf.push('\n');
             ModuleOrigin::File { definition, .. } | ModuleOrigin::CrateRoot { definition } => {
                 definition.into()
             }
-            ModuleOrigin::Inline {
-                definition_tree_id, ..
-            } => definition_tree_id.file_id(),
+            ModuleOrigin::Inline { definition_tree_id, .. } => definition_tree_id.file_id(),
             ModuleOrigin::BlockExpr { block, .. } => block.file_id,
         }
     }
                     ErasedAstId::new(definition.into(), ROOT_ERASED_FILE_AST_ID).to_range(db),
                 )
             }
-            &ModuleOrigin::Inline {
-                definition,
-                definition_tree_id,
-            } => InFile::new(
+            &ModuleOrigin::Inline { definition, definition_tree_id } => InFile::new(
                 definition_tree_id.file_id(),
                 AstId::new(definition_tree_id.file_id(), definition).to_range(db),
             ),
     pub fn declaration_source(&self, db: &dyn DefDatabase) -> Option<InFile<ast::Module>> {
         let decl = self.origin.declaration()?;
         let value = decl.to_node(db);
-        Some(InFile {
-            file_id: decl.file_id,
-            value,
-        })
+        Some(InFile { file_id: decl.file_id, value })
     }
 
     /// Returns the range which declares this module, either a `mod foo;` or a `mod foo {}`.
     /// `None` for the crate root or block.
     pub fn declaration_source_range(&self, db: &dyn DefDatabase) -> Option<InFile<TextRange>> {
         let decl = self.origin.declaration()?;
-        Some(InFile {
+        Some(
+            InFile {
             file_id: decl.file_id,
             value: decl.to_range(db),
-        })
+        },
+        )
     }
 }
 