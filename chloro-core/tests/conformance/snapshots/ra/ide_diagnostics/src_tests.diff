COMPARISON DIFF
============================================================

Original size: 12273 bytes
Chloro size:   12273 bytes
Rustfmt size:  12328 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 #![allow(clippy::print_stderr)]
 
 mod overly_long_real_world_cases;
 
 use hir::setup_tracing;
 use ide_db::{
+    LineIndexDatabase, RootDatabase,
     assists::{AssistResolveStrategy, ExprFillDefaultMode},
     base_db::SourceDatabase,
-    LineIndexDatabase, RootDatabase,
 };
 use itertools::Itertools;
 use stdx::trim_indent;
 use test_fixture::WithFixture;
-use test_utils::{assert_eq_text, extract_annotations, MiniCore};
+use test_utils::{MiniCore, assert_eq_text, extract_annotations};
 
 use crate::{DiagnosticsConfig, Severity};
 
 ) {
     check_nth_fix(0, ra_fixture_before, ra_fixture_after);
 }
+
 /// Takes a multi-file input fixture with annotated cursor positions,
 /// and checks that:
 ///  * a diagnostic is produced
     })
     .pop()
     .unwrap();
-    assert!(
-        diagnostic.fixes.is_none(),
-        "got a fix when none was expected: {diagnostic:?}"
-    );
+    assert!(diagnostic.fixes.is_none(), "got a fix when none was expected: {diagnostic:?}");
 }
 
 #[track_caller]
     disabled: &[&str],
 ) {
     let mut config = DiagnosticsConfig::test_sample();
-    config
-        .disabled
-        .extend(disabled.iter().map(|&s| s.to_owned()));
+    config.disabled.extend(disabled.iter().map(|&s| s.to_owned()));
     check_diagnostics_with_config(config, ra_fixture)
 }
 
         .map(|(diagnostic, annotation)| (diagnostic.file_id, (diagnostic.range, annotation)))
         .into_group_map();
     for file_id in files {
+        // FIXME: We should panic on duplicates instead, but includes currently cause us to report
+        // diagnostics twice for the calling module when both files are queried.
+        // actual.iter().duplicates().for_each(|(range, msg)| {
+        //     panic!("duplicate diagnostic at {:?}: {msg:?}", line_index.line_col(range.start()))
+        // });
         let file_id = file_id.file_id(&db);
         let line_index = db.line_index(file_id);
-
         let mut actual = annotations.remove(&file_id).unwrap_or_default();
         let mut expected = extract_annotations(db.file_text(file_id).text(&db));
         expected.sort_by_key(|(range, s)| (range.start(), s.clone()));
         actual.sort_by_key(|(range, s)| (range.start(), s.clone()));
-        // FIXME: We should panic on duplicates instead, but includes currently cause us to report
-        // diagnostics twice for the calling module when both files are queried.
         actual.dedup();
-        // actual.iter().duplicates().for_each(|(range, msg)| {
-        //     panic!("duplicate diagnostic at {:?}: {msg:?}", line_index.line_col(range.start()))
-        // });
         if expected.is_empty() {
             // makes minicore smoke test debuggable
             for (e, _) in &actual {
                 .filter(|x| !expected.contains(x))
                 .map(|(range, s)| (line_index.line_col(range.start()), range, s))
                 .collect::<Vec<_>>();
-
             panic!("Diagnostic test failed.\nFalse negatives: {fneg:?}\nFalse positives: {fpos:?}");
         }
     }
     }
 
     // Checks that there is no diagnostic in minicore for each flag.
+
     for flag in MiniCore::available_flags(MiniCore::RAW_SOURCE) {
         if flag == "clone" {
             // Clone without copy has `moved-out-of-ref`, so ignoring.
     }
     // And one time for all flags, to check codes which are behind multiple flags + prevent name collisions
     eprintln!("Checking all minicore flags");
-    check(MiniCore::from_flags(MiniCore::available_flags(
-        MiniCore::RAW_SOURCE,
-    )))
+    check(MiniCore::from_flags(MiniCore::available_flags(MiniCore::RAW_SOURCE)))
 }