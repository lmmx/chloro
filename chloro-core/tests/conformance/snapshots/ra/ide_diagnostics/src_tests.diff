COMPARISON DIFF
============================================================

Original size: 12273 bytes
Chloro size:   11914 bytes
Rustfmt size:  12328 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 ) {
     check_nth_fix(0, ra_fixture_before, ra_fixture_after);
 }
+
 /// Takes a multi-file input fixture with annotated cursor positions,
 /// and checks that:
 ///  * a diagnostic is produced
     })
     .pop()
     .unwrap();
-    assert!(
-        diagnostic.fixes.is_none(),
-        "got a fix when none was expected: {diagnostic:?}"
-    );
+    assert!(diagnostic.fixes.is_none(), "got a fix when none was expected: {diagnostic:?}");
 }
 
 #[track_caller]
     disabled: &[&str],
 ) {
     let mut config = DiagnosticsConfig::test_sample();
-    config
-        .disabled
-        .extend(disabled.iter().map(|&s| s.to_owned()));
+    config.disabled.extend(disabled.iter().map(|&s| s.to_owned()));
     check_diagnostics_with_config(config, ra_fixture)
 }
 
     for file_id in files {
         let file_id = file_id.file_id(&db);
         let line_index = db.line_index(file_id);
-
         let mut actual = annotations.remove(&file_id).unwrap_or_default();
         let mut expected = extract_annotations(db.file_text(file_id).text(&db));
         expected.sort_by_key(|(range, s)| (range.start(), s.clone()));
         actual.sort_by_key(|(range, s)| (range.start(), s.clone()));
-        // FIXME: We should panic on duplicates instead, but includes currently cause us to report
-        // diagnostics twice for the calling module when both files are queried.
         actual.dedup();
-        // actual.iter().duplicates().for_each(|(range, msg)| {
-        //     panic!("duplicate diagnostic at {:?}: {msg:?}", line_index.line_col(range.start()))
-        // });
         if expected.is_empty() {
             // makes minicore smoke test debuggable
             for (e, _) in &actual {
                 .filter(|x| !expected.contains(x))
                 .map(|(range, s)| (line_index.line_col(range.start()), range, s))
                 .collect::<Vec<_>>();
-
             panic!("Diagnostic test failed.\nFalse negatives: {fneg:?}\nFalse positives: {fpos:?}");
         }
     }
     }
     // And one time for all flags, to check codes which are behind multiple flags + prevent name collisions
     eprintln!("Checking all minicore flags");
-    check(MiniCore::from_flags(MiniCore::available_flags(
-        MiniCore::RAW_SOURCE,
-    )))
+    check(MiniCore::from_flags(MiniCore::available_flags(MiniCore::RAW_SOURCE)))
 }