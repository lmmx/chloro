COMPARISON DIFF
============================================================

Original size: 15808 bytes
Chloro size:   15583 bytes
Rustfmt size:  15808 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::base_db::RootQueryDb;
 use ide_db::text_edit::TextEdit;
 use ide_db::{
-    FileId, FileRange, LineIndexDatabase, base_db::SourceDatabase, source_change::SourceChange,
+    base_db::SourceDatabase, source_change::SourceChange, FileId, FileRange, LineIndexDatabase,
 };
 use paths::Utf8Component;
 use syntax::{
+    ast::{self, edit::IndentLevel, HasModuleItem, HasName},
     AstNode, TextRange,
-    ast::{self, HasModuleItem, HasName, edit::IndentLevel},
 };
 
-use crate::{Assist, Diagnostic, DiagnosticCode, DiagnosticsContext, Severity, fix};
+use crate::{fix, Assist, Diagnostic, DiagnosticCode, DiagnosticsContext, Severity};
 
-// Diagnostic: unlinked-file
-//
-// This diagnostic is shown for files that are not included in any crate, or files that are part of
-// crates rust-analyzer failed to discover. The file will not have IDE features available.
 pub(crate) fn unlinked_file(
     ctx: &DiagnosticsContext<'_>,
     acc: &mut Vec<Diagnostic>,
         unused = false;
     }
 
-    acc.push(
+    acc
+        .push(
         Diagnostic::new(
             DiagnosticCode::Ra("unlinked-file", Severity::WeakWarning),
             message,
 ) -> Option<Vec<Assist>> {
     // If there's an existing module that could add `mod` or `pub mod` items to include the unlinked file,
     // suggest that as a fix.
-
     let db = ctx.sema.db;
 
     let source_root = ctx.sema.db.file_source_root(file_id).source_root_id(db);
     // if we aren't adding to a crate root, walk backwards such that we support `#[path = ...]` overrides if possible
 
     // build all parent paths of the form `../module_name/mod.rs` and `../module_name.rs`
-    let paths = iter::successors(Some(parent), |prev| prev.parent()).filter_map(|path| {
+    let paths = iter::successors(Some(parent), |prev| prev.parent())
+        .filter_map(|path| {
         let parent = path.parent()?;
         let (name, _) = path.name_and_extension()?;
         Some(([parent.join(&format!("{name}.rs"))?, path.join("mod.rs")?], name.to_owned()))
     });
     let mut stack = vec![];
-    let &parent_id =
-        paths.inspect(|(_, name)| stack.push(name.clone())).find_map(|(paths, _)| {
+    let &parent_id = paths.inspect(|(_, name)| stack.push(name.clone())).find_map(|(paths, _)| {
             paths.into_iter().find_map(|path| source_root.file_for_path(&path))
         })?;
     stack.pop();
     };
 
     // If there's an existing `mod m;` statement matching the new one, don't emit a fix (it's
+
     // probably `#[cfg]`d out).
     for item in items.clone() {
         if let ast::Item::Module(m) = item
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};
-
     #[test]
     fn unlinked_file_prepend_first_item() {
         cov_mark::check!(unlinked_file_prepend_before_first_item);
             ],
         );
     }
-
     #[test]
     fn unlinked_file_append_mod() {
         cov_mark::check!(unlinked_file_append_to_existing_mods);
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_in_empty_file() {
         cov_mark::check!(unlinked_file_empty_file);
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_in_empty_file_mod_file() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_old_style_modrs() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_new_style_mod() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_with_cfg_off() {
         cov_mark::check!(unlinked_file_skip_fix_when_mod_already_exists);
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_with_cfg_on() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_into_inline_simple() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_into_inline_simple_modrs() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_into_inline_simple_modrs_main() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn include_macro_works() {
         check_diagnostics(