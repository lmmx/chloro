COMPARISON DIFF
============================================================

Original size: 15808 bytes
Chloro size:   15578 bytes
Rustfmt size:  15808 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{Assist, Diagnostic, DiagnosticCode, DiagnosticsContext, Severity, fix};
 
-// Diagnostic: unlinked-file
-//
-// This diagnostic is shown for files that are not included in any crate, or files that are part of
-// crates rust-analyzer failed to discover. The file will not have IDE features available.
 pub(crate) fn unlinked_file(
     ctx: &DiagnosticsContext<'_>,
     acc: &mut Vec<Diagnostic>,
     };
 
     // check crate roots, i.e. main.rs, lib.rs, ...
+
     let relevant_crates = db.relevant_crates(file_id);
     'crates: for &krate in &*relevant_crates {
         // FIXME: This shouldnt need to access the crate def map directly
     // if we aren't adding to a crate root, walk backwards such that we support `#[path = ...]` overrides if possible
 
     // build all parent paths of the form `../module_name/mod.rs` and `../module_name.rs`
+
     let paths = iter::successors(Some(parent), |prev| prev.parent()).filter_map(|path| {
         let parent = path.parent()?;
         let (name, _) = path.name_and_extension()?;
     };
 
     // If there's an existing `mod m;` statement matching the new one, don't emit a fix (it's
+
     // probably `#[cfg]`d out).
+
     for item in items.clone() {
         if let ast::Item::Module(m) = item
             && let Some(name) = m.name()
     }
 
     // If there are existing `mod m;` items, append after them (after the first group of them, rather).
+
     match items.clone().skip_while(|item| !is_outline_mod(item)).take_while(is_outline_mod).last() {
         Some(last) => {
             cov_mark::hit!(unlinked_file_append_to_existing_mods);
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};
-
     #[test]
     fn unlinked_file_prepend_first_item() {
         cov_mark::check!(unlinked_file_prepend_before_first_item);
             ],
         );
     }
-
     #[test]
     fn unlinked_file_append_mod() {
         cov_mark::check!(unlinked_file_append_to_existing_mods);
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_in_empty_file() {
         cov_mark::check!(unlinked_file_empty_file);
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_in_empty_file_mod_file() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_old_style_modrs() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_new_style_mod() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_with_cfg_off() {
         cov_mark::check!(unlinked_file_skip_fix_when_mod_already_exists);
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_with_cfg_on() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_into_inline_simple() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_into_inline_simple_modrs() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unlinked_file_insert_into_inline_simple_modrs_main() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn include_macro_works() {
         check_diagnostics(