COMPARISON DIFF
============================================================

Original size: 9501 bytes
Chloro size:   9344 bytes
Rustfmt size:  9638 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     source_change::SourceChange,
 };
 use itertools::Itertools;
+use syntax::AstNode;
 
 use crate::{Diagnostic, DiagnosticCode, DiagnosticsContext};
 
-use syntax::AstNode;
-
-// Diagnostic: typed-hole
-//
-// This diagnostic is triggered when an underscore expression is used in an invalid position.
 pub(crate) fn typed_hole(ctx: &DiagnosticsContext<'_>, d: &hir::TypedHole<'_>) -> Diagnostic {
-    let display_range = ctx
-        .sema
-        .diagnostics_display_range(d.expr.map(|it| it.into()));
+    let display_range = ctx.sema.diagnostics_display_range(d.expr.map(|it| it.into()));
     let (message, fixes) = if d.expected.is_unknown() {
-        (
-            "`_` expressions may only appear on the left-hand side of an assignment".to_owned(),
-            None,
-        )
+        ("`_` expressions may only appear on the left-hand side of an assignment".to_owned(), None)
     } else {
         (
             format!(
         )
     };
 
-    Diagnostic::new(
-        DiagnosticCode::RustcHardError("typed-hole"),
-        message,
-        display_range,
-    )
-    .stable()
-    .with_fixes(fixes)
+    Diagnostic::new(DiagnosticCode::RustcHardError("typed-hole"), message, display_range)
+        .stable()
+        .with_fixes(fixes)
 }
 
 fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypedHole<'_>) -> Option<Vec<Assist>> {
     let db = ctx.sema.db;
     let root = db.parse_or_expand(d.expr.file_id);
-    let (original_range, _) = d
-        .expr
-        .as_ref()
-        .map(|it| it.to_node(&root))
-        .syntax()
-        .original_file_range_opt(db)?;
+    let (original_range, _) = d.expr.as_ref().map(|it| it.to_node(&root)).syntax().original_file_range_opt(db)?;
     let scope = ctx.sema.scope(d.expr.value.to_node(&root).syntax())?;
 
     let term_search_ctx = TermSearchCtx {
         })
         .collect();
 
-    if !assists.is_empty() {
-        Some(assists)
-    } else {
-        None
-    }
+    if !assists.is_empty() { Some(assists) } else { None }
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_diagnostics, check_fixes_unordered, check_has_fix};
-
     #[test]
     fn unknown() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn concrete_expectation() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn integer_ty_var() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn ty_var_resolved() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn valid_positions() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn check_quick_fix() {
         check_fixes_unordered(
             ],
         );
     }
-
     #[test]
     fn local_item_use_trait() {
         check_has_fix(
 ",
         );
     }
-
     #[test]
     fn init_struct() {
         check_has_fix(
 }"#,
         );
     }
-
     #[test]
     fn ignore_impl_func_with_incorrect_return() {
         check_fixes_unordered(
             ],
         );
     }
-
     #[test]
     fn use_impl_func_with_correct_return() {
         check_has_fix(
 }"#,
         );
     }
-
-    // FIXME
     #[test]
     fn local_shadow_fn() {
         check_fixes_unordered(
             ],
         );
     }
-
     #[test]
     fn underscore_in_asm() {
         check_diagnostics(