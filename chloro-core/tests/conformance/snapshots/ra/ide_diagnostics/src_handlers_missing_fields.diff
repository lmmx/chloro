COMPARISON DIFF
============================================================

Original size: 19114 bytes
Chloro size:   18777 bytes
Rustfmt size:  19114 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{Diagnostic, DiagnosticCode, DiagnosticsContext, fix};
 
-// Diagnostic: missing-fields
-//
-// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.
-//
-// Example:
-//
-// ```rust
-// struct A { a: u8, b: u8 }
-//
-// let a = A { a: 10 };
-// ```
 pub(crate) fn missing_fields(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Diagnostic {
     let mut message = String::from("missing structure fields:\n");
     for field in &d.missed_fields {
     match &d.field_list_parent.to_node(&root) {
         Either::Left(field_list_parent) => {
             let missing_fields = ctx.sema.record_literal_missing_fields(field_list_parent);
-
             let mut locals = FxHashMap::default();
             ctx.sema.scope(field_list_parent.syntax())?.process_all_names(&mut |name, def| {
                 if let hir::ScopeDef::Local(local) = def {
                     locals.insert(name, local);
                 }
             });
-
             let generate_fill_expr = |ty: &Type<'_>| match ctx.config.expr_fill_default {
                 ExprFillDefaultMode::Todo => make::ext::expr_todo(),
                 ExprFillDefaultMode::Underscore => make::ext::expr_underscore(),
                     get_default_constructor(ctx, d, ty).unwrap_or_else(make::ext::expr_todo)
                 }
             };
-
             let old_field_list = field_list_parent.record_expr_field_list()?;
             let new_field_list = old_field_list.clone_for_update();
             for (f, ty) in missing_fields.iter() {
         }
         Either::Right(field_list_parent) => {
             let missing_fields = ctx.sema.record_pattern_missing_fields(field_list_parent);
-
             let old_field_list = field_list_parent.record_pat_field_list()?;
             let new_field_list = old_field_list.clone_for_update();
             for (f, _) in missing_fields.iter() {
         Some(make::ext::expr_ty_new(&make_ty(ty, ctx.sema.db, module, ctx.edition)))
     } else if ty.as_adt() == famous_defs.core_option_Option()?.ty(ctx.sema.db).as_adt() {
         Some(make::ext::option_none())
-    } else if !ty.is_array()
-        && ty.impls_trait(ctx.sema.db, famous_defs.core_default_Default()?, &[])
-    {
+    } else if !ty.is_array() && ty.impls_trait(ctx.sema.db, famous_defs.core_default_Default()?, &[]) {
         Some(make::ext::expr_ty_default(&make_ty(ty, ctx.sema.db, module, ctx.edition)))
     } else {
         None
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_diagnostics, check_fix};
-
     #[test]
     fn missing_record_pat_field_diagnostic() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {
-        check_diagnostics(
-            r"
+        check_diagnostics(r"
 struct S { foo: i32, bar: () }
 fn baz(s: S) -> i32 {
     match s {
         S { foo, .. } => foo,
     }
 }
-",
-        )
+")
     }
-
     #[test]
     fn missing_record_pat_field_box() {
-        check_diagnostics(
-            r"
+        check_diagnostics(r"
 struct S { s: Box<u32> }
 fn x(a: S) {
     let S { box s } = a;
 }
-",
-        )
+")
     }
-
     #[test]
     fn missing_record_pat_field_ref() {
-        check_diagnostics(
-            r"
+        check_diagnostics(r"
 struct S { s: u32 }
 fn x(a: S) {
     let S { ref s } = a;
     _ = s;
 }
-",
-        )
+")
     }
-
     #[test]
     fn missing_record_expr_in_assignee_expr() {
         check_diagnostics(
             ",
         );
     }
-
     #[test]
     fn range_mapping_out_of_macros() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_empty() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_zst_fields() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_self() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_enum() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_partial() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_new() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_default() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_raw_ident() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_no_diagnostic() {
         check_diagnostics(
         "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_no_diagnostic_on_spread() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_blank_line() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand() {
         cov_mark::check!(field_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand_ty_mismatch() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand_unifies() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_pat_fields() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_pat_fields_partial() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn import_extern_crate_clash_with_inner_item() {
         // This is more of a resolver test, but doesn't really work with the hir_def testsuite.
-
         check_diagnostics(
             r#"
 //- /lib.rs crate:lib deps:jwt