COMPARISON DIFF
============================================================

Original size: 19114 bytes
Chloro size:   18859 bytes
Rustfmt size:  19114 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir::{
-    AssocItem, FindPathConfig, HirDisplay, InFile, Type,
     db::{ExpandDatabase, HirDatabase},
-    sym,
+    sym, AssocItem, FindPathConfig, HirDisplay, InFile, Type,
 };
 use ide_db::{
-    FxHashMap,
     assists::{Assist, ExprFillDefaultMode},
     famous_defs::FamousDefs,
     imports::import_assets::item_for_path_search,
     syntax_helpers::tree_diff::diff,
     text_edit::TextEdit,
     use_trivial_constructor::use_trivial_constructor,
+    FxHashMap,
 };
 use stdx::format_to;
 use syntax::{
+    ast::{make, self},
     AstNode, Edition, SyntaxNode, SyntaxNodePtr, ToSmolStr,
-    ast::{self, make},
 };
 
 use crate::{Diagnostic, DiagnosticCode, DiagnosticsContext, fix};
 
-// Diagnostic: missing-fields
-//
-// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.
-//
-// Example:
-//
-// ```rust
-// struct A { a: u8, b: u8 }
-//
-// let a = A { a: 10 };
-// ```
 pub(crate) fn missing_fields(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Diagnostic {
     let mut message = String::from("missing structure fields:\n");
     for field in &d.missed_fields {
         .file_to_module_def(d.file.original_file(ctx.sema.db).file_id(ctx.sema.db))?
         .krate();
     let module = krate.root_module();
-
     // Look for a ::new() associated function
+
     let has_new_func = ty
         .iterate_assoc_items(ctx.sema.db, krate, |assoc_item| {
             if let AssocItem::Function(func) = assoc_item
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_diagnostics, check_fix};
-
     #[test]
     fn missing_record_pat_field_diagnostic() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {
         check_diagnostics(
 ",
         )
     }
-
     #[test]
     fn missing_record_pat_field_box() {
         check_diagnostics(
 ",
         )
     }
-
     #[test]
     fn missing_record_pat_field_ref() {
         check_diagnostics(
 ",
         )
     }
-
     #[test]
     fn missing_record_expr_in_assignee_expr() {
         check_diagnostics(
             ",
         );
     }
-
     #[test]
     fn range_mapping_out_of_macros() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_empty() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_zst_fields() {
         check_fix(
 }
 "#,
         );
-
         // make sure the assist doesn't fill non Unit variants
+
         check_fix(
             r#"
 struct Empty {};
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_self() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_enum() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_partial() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_new() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_default() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_raw_ident() {
         check_fix(
 ",
         );
     }
-
     #[test]
     fn test_fill_struct_fields_no_diagnostic() {
         check_diagnostics(
         "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_no_diagnostic_on_spread() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_blank_line() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand() {
         cov_mark::check!(field_shorthand);
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand_ty_mismatch() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_fields_shorthand_unifies() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_pat_fields() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_fill_struct_pat_fields_partial() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn import_extern_crate_clash_with_inner_item() {
         // This is more of a resolver test, but doesn't really work with the hir_def testsuite.