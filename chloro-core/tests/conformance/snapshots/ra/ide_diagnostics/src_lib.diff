COMPARISON DIFF
============================================================

Original size: 33895 bytes
Chloro size:   33562 bytes
Rustfmt size:  33895 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! There are also a couple of ad-hoc diagnostics implemented directly here, we
 //! don't yet have a great pattern for how to do them properly.
 
+#[cfg(test)]
+mod tests;
+
+use std::{iter, sync::LazyLock};
+
+use either::Either;
+use hir::{
+    db::ExpandDatabase, diagnostics::AnyDiagnostic, Crate, DisplayTarget, InFile, Semantics,
+};
+use ide_db::{
+    assists::{Assist, AssistId, AssistResolveStrategy, ExprFillDefaultMode},
+    base_db::{ReleaseChannel, RootQueryDb as _},
+    generated::lints::{Lint, LintGroup, CLIPPY_LINT_GROUPS, DEFAULT_LINTS, DEFAULT_LINT_GROUPS},
+    imports::insert_use::InsertUseConfig,
+    label::Label,
+    source_change::SourceChange,
+    syntax_helpers::node_ext::parse_tt_as_comma_sep_paths,
+    EditionedFileId, FileId, FileRange, FxHashMap, FxHashSet, RootDatabase, Severity, SnippetCap,
+};
+use itertools::Itertools;
+use syntax::{
+    ast::{self, AstNode, HasAttrs},
+    AstPtr, Edition, NodeOrToken, SmolStr, SyntaxKind, SyntaxNode, SyntaxNodePtr, TextRange, T,
+};
+
 mod handlers {
     pub(crate) mod await_outside_of_async;
     pub(crate) mod bad_rtn;
     pub(crate) mod unresolved_method;
     pub(crate) mod unresolved_module;
     pub(crate) mod unused_variables;
-
-    // The handlers below are unusual, the implement the diagnostics as well.
     pub(crate) mod field_shorthand;
     pub(crate) mod json_is_not_rust;
     pub(crate) mod unlinked_file;
     pub(crate) mod useless_braces;
 }
 
-#[cfg(test)]
-mod tests;
-
-use std::{iter, sync::LazyLock};
-
-use either::Either;
-use hir::{
-    Crate, DisplayTarget, InFile, Semantics, db::ExpandDatabase, diagnostics::AnyDiagnostic,
-};
-use ide_db::{
-    EditionedFileId, FileId, FileRange, FxHashMap, FxHashSet, RootDatabase, Severity, SnippetCap,
-    assists::{Assist, AssistId, AssistResolveStrategy, ExprFillDefaultMode},
-    base_db::{ReleaseChannel, RootQueryDb as _},
-    generated::lints::{CLIPPY_LINT_GROUPS, DEFAULT_LINT_GROUPS, DEFAULT_LINTS, Lint, LintGroup},
-    imports::insert_use::InsertUseConfig,
-    label::Label,
-    source_change::SourceChange,
-    syntax_helpers::node_ext::parse_tt_as_comma_sep_paths,
-};
-use itertools::Itertools;
-use syntax::{
-    AstPtr, Edition, NodeOrToken, SmolStr, SyntaxKind, SyntaxNode, SyntaxNodePtr, T, TextRange,
-    ast::{self, AstNode, HasAttrs},
-};
-
-// FIXME: Make this an enum
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
 pub enum DiagnosticCode {
     RustcHardError(&'static str),
         message: impl Into<String>,
         node: InFile<SyntaxNodePtr>,
     ) -> Diagnostic {
-        Diagnostic::new(code, message, ctx.sema.diagnostics_display_range(node))
-            .with_main_node(node)
+        Diagnostic::new(code, message, ctx.sema.diagnostics_display_range(node)).with_main_node(
+            node,
+        )
     }
 
     fn stable(mut self) -> Diagnostic {
                     node.with_value(it).original_file_range_opt(sema.db)
                 }
             }
-        })()
-        .map(|frange| ide_db::FileRange {
+        })(
+        ).map(|frange| ide_db::FileRange {
             file_id: frange.file_id.file_id(self.sema.db),
             range: frange.range,
-        })
-        .unwrap_or_else(|| sema.diagnostics_display_range(*node))
+        }).unwrap_or_else(
+            || sema.diagnostics_display_range(*node),
+        )
     }
 }
 
     let (file_id, _) = editioned_file_id.unpack(db);
 
     // [#3434] Only take first 128 errors to prevent slowing down editor/ide, the number 128 is chosen arbitrarily.
-    db.parse_errors(editioned_file_id)
-        .into_iter()
-        .flatten()
-        .take(128)
-        .map(|err| {
+    db.parse_errors(editioned_file_id).into_iter().flatten().take(128).map(|err| {
             Diagnostic::new(
                 DiagnosticCode::SyntaxError,
                 format!("Syntax Error: {err}"),
                 FileRange { file_id, range: err.range() },
             )
-        })
-        .collect()
+        }).collect(
+    )
 }
 
 /// Request semantic diagnostics for the given [`FileId`]. The produced diagnostics may point to other files
     let parse = sema.parse(editioned_file_id);
 
     // FIXME: This iterates the entire file which is a rather expensive operation.
+
     // We should implement these differently in some form?
+
     // Salsa caching + incremental re-parse would be better here
     for node in parse.syntax().descendants() {
         handlers::useless_braces::useless_braces(db, &mut res, editioned_file_id, &node);
         .collect::<Vec<_>>();
 
     // The edition isn't accurate (each diagnostics may have its own edition due to macros),
+
     // but it's okay as it's only being used for error recovery.
     handle_lints(&ctx.sema, &mut lints, editioned_file_id.edition(db));
 
     groups: Vec<&'static str>,
 }
 
-static RUSTC_LINTS: LazyLock<FxHashMap<&str, BuiltLint>> =
-    LazyLock::new(|| build_lints_map(DEFAULT_LINTS, DEFAULT_LINT_GROUPS, ""));
+static RUSTC_LINTS: LazyLock<FxHashMap<&str, BuiltLint>> = LazyLock::new(|| build_lints_map(DEFAULT_LINTS, DEFAULT_LINT_GROUPS, ""));
 
 static CLIPPY_LINTS: LazyLock<FxHashMap<&str, BuiltLint>> = LazyLock::new(|| {
     build_lints_map(ide_db::generated::lints::CLIPPY_LINTS, CLIPPY_LINT_GROUPS, "clippy::")
 });
 
-// FIXME: Autogenerate this instead of enumerating by hand.
-static LINTS_TO_REPORT_IN_EXTERNAL_MACROS: LazyLock<FxHashSet<&str>> =
-    LazyLock::new(|| FxHashSet::from_iter([]));
+static LINTS_TO_REPORT_IN_EXTERNAL_MACROS: LazyLock<FxHashSet<&str>> = LazyLock::new(|| FxHashSet::from_iter([]));
 
 fn build_lints_map(
     lints: &'static [Lint],
         if !(default_severity == Severity::Allow && diag.severity == Severity::WeakWarning) {
             diag.severity = default_severity;
         }
-
         let mut diag_severity =
             lint_severity_at(sema, node, &lint_groups(&diag.code, edition), edition);
-
         if let outline_diag_severity @ Some(_) =
             find_outline_mod_lint_severity(sema, node, diag, edition)
         {
             diag_severity = outline_diag_severity;
         }
-
         if let Some(diag_severity) = diag_severity {
             diag.severity = diag_severity;
         }
     lint_groups: &LintGroups,
     edition: Edition,
 ) -> Option<Severity> {
-    node.value
-        .ancestors()
-        .filter_map(ast::AnyHasAttrs::cast)
-        .find_map(|ancestor| {
+    node.value.ancestors().filter_map(ast::AnyHasAttrs::cast).find_map(|ancestor| {
             lint_attrs(sema, ancestor, edition)
                 .find_map(|(lint, severity)| lint_groups.contains(&lint).then_some(severity))
-        })
-        .or_else(|| {
+        }).or_else(|| {
             lint_severity_at(sema, &sema.find_parent_file(node.file_id)?, lint_groups, edition)
         })
 }
     ancestor: ast::AnyHasAttrs,
     edition: Edition,
 ) -> impl Iterator<Item = (SmolStr, Severity)> + 'a {
-    ancestor
-        .attrs_including_inner()
-        .filter_map(|attr| {
+    ancestor.attrs_including_inner().filter_map(|attr| {
             attr.as_simple_call().and_then(|(name, value)| match &*name {
                 "allow" | "expect" => Some(Either::Left(iter::once((Severity::Allow, value)))),
                 "warn" => Some(Either::Left(iter::once((Severity::Warning, value)))),
                 }
                 _ => None,
             })
-        })
-        .flatten()
-        .flat_map(move |(severity, lints)| {
+        }).flatten(
+    ).flat_map(move |(severity, lints)| {
             parse_tt_as_comma_sep_paths(lints, edition).into_iter().flat_map(move |lints| {
                 // Rejoin the idents with `::`, so we have no spaces in between.
                 lints.into_iter().map(move |lint| {
         }
     }
 
-    if prev_len != lint_attrs.len()
-        && let Some(false) | None = sema.check_cfg_attr(value)
-    {
-        // Discard the attributes when the condition is false.
+    if prev_len != lint_attrs.len() && let Some(false) | None = sema.check_cfg_attr(value) {
         lint_attrs.truncate(prev_len);
     }
 }