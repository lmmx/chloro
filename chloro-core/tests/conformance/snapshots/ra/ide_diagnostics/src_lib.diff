COMPARISON DIFF
============================================================

Original size: 33895 bytes
Chloro size:   33712 bytes
Rustfmt size:  33895 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     pub(crate) mod unresolved_method;
     pub(crate) mod unresolved_module;
     pub(crate) mod unused_variables;
-
-    // The handlers below are unusual, the implement the diagnostics as well.
     pub(crate) mod field_shorthand;
     pub(crate) mod json_is_not_rust;
     pub(crate) mod unlinked_file;
     ast::{self, AstNode, HasAttrs},
 };
 
-// FIXME: Make this an enum
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
 pub enum DiagnosticCode {
     RustcHardError(&'static str),
     let (file_id, _) = editioned_file_id.unpack(db);
 
     // [#3434] Only take first 128 errors to prevent slowing down editor/ide, the number 128 is chosen arbitrarily.
+
     db.parse_errors(editioned_file_id)
         .into_iter()
         .flatten()
     let parse = sema.parse(editioned_file_id);
 
     // FIXME: This iterates the entire file which is a rather expensive operation.
+
     // We should implement these differently in some form?
+
     // Salsa caching + incremental re-parse would be better here
+
     for node in parse.syntax().descendants() {
         handlers::useless_braces::useless_braces(db, &mut res, editioned_file_id, &node);
         handlers::field_shorthand::field_shorthand(db, &mut res, editioned_file_id, &node);
         .collect::<Vec<_>>();
 
     // The edition isn't accurate (each diagnostics may have its own edition due to macros),
+
     // but it's okay as it's only being used for error recovery.
+
     handle_lints(&ctx.sema, &mut lints, editioned_file_id.edition(db));
 
     res.retain(|d| d.severity != Severity::Allow);
     groups: Vec<&'static str>,
 }
 
-static RUSTC_LINTS: LazyLock<FxHashMap<&str, BuiltLint>> =
-    LazyLock::new(|| build_lints_map(DEFAULT_LINTS, DEFAULT_LINT_GROUPS, ""));
+static RUSTC_LINTS: LazyLock<FxHashMap<&str, BuiltLint>> = LazyLock::new(|| build_lints_map(DEFAULT_LINTS, DEFAULT_LINT_GROUPS, ""));
 
 static CLIPPY_LINTS: LazyLock<FxHashMap<&str, BuiltLint>> = LazyLock::new(|| {
     build_lints_map(ide_db::generated::lints::CLIPPY_LINTS, CLIPPY_LINT_GROUPS, "clippy::")
 });
 
-// FIXME: Autogenerate this instead of enumerating by hand.
-static LINTS_TO_REPORT_IN_EXTERNAL_MACROS: LazyLock<FxHashSet<&str>> =
-    LazyLock::new(|| FxHashSet::from_iter([]));
+static LINTS_TO_REPORT_IN_EXTERNAL_MACROS: LazyLock<FxHashSet<&str>> = LazyLock::new(|| FxHashSet::from_iter([]));
 
 fn build_lints_map(
     lints: &'static [Lint],
         if !(default_severity == Severity::Allow && diag.severity == Severity::WeakWarning) {
             diag.severity = default_severity;
         }
-
         let mut diag_severity =
             lint_severity_at(sema, node, &lint_groups(&diag.code, edition), edition);
-
         if let outline_diag_severity @ Some(_) =
             find_outline_mod_lint_severity(sema, node, diag, edition)
         {
             diag_severity = outline_diag_severity;
         }
-
         if let Some(diag_severity) = diag_severity {
             diag.severity = diag_severity;
         }
     });
 
     // Skip the condition.
+
     for value in &mut iter {
         if value.as_token().is_some_and(|it| it.kind() == T![,]) {
             break;
         }
     }
 
-    if prev_len != lint_attrs.len()
-        && let Some(false) | None = sema.check_cfg_attr(value)
-    {
+    if prev_len != lint_attrs.len() && let Some(false) | None = sema.check_cfg_attr(value) {
         // Discard the attributes when the condition is false.
         lint_attrs.truncate(prev_len);
     }