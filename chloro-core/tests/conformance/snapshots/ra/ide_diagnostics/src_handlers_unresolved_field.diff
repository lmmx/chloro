COMPARISON DIFF
============================================================

Original size: 15690 bytes
Chloro size:   14846 bytes
Rustfmt size:  15822 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{adjusted_display_range, Diagnostic, DiagnosticCode, DiagnosticsContext};
 
-// Diagnostic: unresolved-field
-//
-// This diagnostic is triggered if a field does not exist on a given type.
 pub(crate) fn unresolved_field(
     ctx: &DiagnosticsContext<'_>,
     d: &hir::UnresolvedField<'_>,
             d.name.display(ctx.sema.db, ctx.edition),
             d.receiver.display(ctx.sema.db, ctx.display_target)
         ),
-        adjusted_display_range(ctx, d.expr, &|expr| {
-            Some(
-                match expr.left()? {
-                    ast::Expr::MethodCallExpr(it) => it.name_ref(),
-                    ast::Expr::FieldExpr(it) => it.name_ref(),
-                    _ => None,
-                }?
-                .syntax()
-                .text_range(),
-            )
-        }),
+        adjusted_display_range(
+        ctx,
+        d.expr,
+        &|expr| {
+        Some(match expr.left()? {
+            ast::Expr::MethodCallExpr(it) => it.name_ref(),
+            ast::Expr::FieldExpr(it) => it.name_ref(),
+            _ => None,
+        }?.syntax(
+        ).text_range(
+        ))
+    },
+    ),
+    ).with_fixes(
+        fixes(ctx, d),
     )
-    .with_fixes(fixes(ctx, d))
 }
 
 fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedField<'_>) -> Option<Vec<Assist>> {
     }
 }
 
-// FIXME: Add Snippet Support
 fn field_fix(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedField<'_>) -> Option<Assist> {
     // Get the FileRange of the invalid field access
     let root = ctx.sema.db.parse_or_expand(d.expr.file_id);
     let adt = d.receiver.strip_references().as_adt()?;
     let target_module = adt.module(ctx.sema.db);
 
-    let suggested_type = if let Some(new_field_type) = ctx
-        .sema
-        .type_of_expr(&expr)
-        .map(|v| v.adjusted())
-        .filter(|it| !it.is_unknown())
+    let suggested_type = if let Some(new_field_type) =
+        ctx.sema.type_of_expr(&expr).map(|v| v.adjusted()).filter(|it| !it.is_unknown())
     {
-        let display = new_field_type
-            .display_source_code(ctx.sema.db, target_module.into(), false)
-            .ok();
+        let display =
+            new_field_type.display_source_code(ctx.sema.db, target_module.into(), false).ok();
         make::ty(display.as_deref().unwrap_or("()"))
     } else {
         make::ty("()")
     match adt {
         Adt::Struct(adt_struct) => {
             add_field_to_struct_fix(ctx, adt_struct, field_name, suggested_type, error_range)
-        }
+        },
         Adt::Union(adt_union) => {
             add_variant_to_union(ctx, adt_union, field_name, suggested_type, error_range)
-        }
+        },
         _ => None,
     }
 }
     let range = adt_syntax.original_file_range_rooted(ctx.sema.db);
     let field_name = make::name(field_name);
 
-    let (offset, record_field) = record_field_layout(
-        None,
-        field_name,
-        suggested_type,
-        field_list,
-        adt_syntax.value,
-    )?;
+    let (offset, record_field) =
+        record_field_layout(None, field_name, suggested_type, field_list, adt_syntax.value)?;
 
     let mut src_change_builder = SourceChangeBuilder::new(range.file_id.file_id(ctx.sema.db));
     src_change_builder.insert(offset, record_field);
     let field_list = struct_source.value.field_list();
     match field_list {
         Some(FieldList::RecordFieldList(field_list)) => {
-            // Get range of final field in the struct
             let visibility = if error_range.file_id == struct_range.file_id {
                 None
             } else {
                 Some(make::visibility_pub_crate())
             };
-
             let field_name = match field_name.chars().next() {
                 Some(ch) if ch.is_numeric() => return None,
                 Some(_) => make::name(field_name),
                 None => return None,
             };
-
             let (offset, record_field) = record_field_layout(
                 visibility,
                 field_name,
                 field_list,
                 struct_syntax.value,
             )?;
-
             let mut src_change_builder =
                 SourceChangeBuilder::new(struct_range.file_id.file_id(ctx.sema.db));
-
-            // FIXME: Allow for choosing a visibility modifier see https://github.com/rust-lang/rust-analyzer/issues/11563
             src_change_builder.insert(offset, record_field);
             Some(Assist {
                 id: AssistId::quick_fix("add-field-to-record-struct"),
                 source_change: Some(src_change_builder.finish()),
                 command: None,
             })
-        }
+        },
         None => {
-            // Add a field list to the Unit Struct
             let mut src_change_builder =
                 SourceChangeBuilder::new(struct_range.file_id.file_id(ctx.sema.db));
             let field_name = match field_name.chars().next() {
             } else {
                 Some(make::visibility_pub_crate())
             };
-            // FIXME: Allow for choosing a visibility modifier see https://github.com/rust-lang/rust-analyzer/issues/11563
             let indent = IndentLevel::from_node(struct_syntax.value);
-
             let field =
                 make::record_field(visibility, field_name, suggested_type).indent(indent + 1);
-            // A Unit Struct with no `;` is invalid syntax. We should not suggest this fix.
             let semi_colon =
                 algo::skip_trivia_token(struct_syntax.value.last_token()?, Direction::Prev)?;
             if semi_colon.kind() != SyntaxKind::SEMICOLON {
                 semi_colon.text_range(),
                 format!(" {{\n{}{field},\n{indent}}}", indent + 1),
             );
-
             Some(Assist {
                 id: AssistId::quick_fix("convert-unit-struct-to-record-struct"),
                 label: Label::new("Convert Unit Struct to Record Struct and add field".to_owned()),
                 source_change: Some(src_change_builder.finish()),
                 command: None,
             })
-        }
+        },
         Some(FieldList::TupleFieldList(_tuple)) => {
-            // FIXME: Add support for Tuple Structs. Tuple Structs are not sent to this diagnostic
             None
-        }
+        },
     }
 }
 
     let comma = if needs_comma { ",\n" } else { "\n" };
     let record_field = make::record_field(visibility, name, suggested_type);
 
-    Some((
-        offset,
-        format!("{comma}{indent}{record_field}{trailing_new_line}"),
-    ))
+    Some((offset, format!("{comma}{indent}{record_field}{trailing_new_line}")))
 }
 
-// FIXME: We should fill out the call here, move the cursor and trigger signature help
 fn method_fix(
     ctx: &DiagnosticsContext<'_>,
     expr_ptr: &InFile<AstPtr<Either<ast::Expr, ast::Pat>>>,
         command: None,
     })
 }
+
 #[cfg(test)]
 mod tests {
-
     use crate::{
         tests::{
             check_diagnostics, check_diagnostics_with_config, check_diagnostics_with_disabled,
         },
         DiagnosticsConfig,
     };
-
     #[test]
     fn smoke_test() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_clash() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_trait_() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_trait_2() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn no_diagnostic_on_unknown() {
         check_diagnostics_with_disabled(
             &["E0425"],
         );
     }
-
     #[test]
     fn no_diagnostic_for_missing_name() {
         let mut config = DiagnosticsConfig::test_sample();
         config.disabled.insert("syntax-error".to_owned());
         check_diagnostics_with_config(config, "fn foo() { (). }");
     }
-
     #[test]
     fn unresolved_field_fix_on_unit() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn no_fix_when_indexed() {
-        check_no_fix(
-            r#"
+        check_no_fix(r#"
             struct Kek {}
 impl Kek {
     pub fn foo(self) {
 }
 
 fn main() {}
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn no_fix_when_without_field() {
-        check_no_fix(
-            r#"
+        check_no_fix(r#"
             struct Kek {}
 impl Kek {
     pub fn foo(self) {
 }
 
 fn main() {}
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn regression_18683() {
         check_diagnostics(