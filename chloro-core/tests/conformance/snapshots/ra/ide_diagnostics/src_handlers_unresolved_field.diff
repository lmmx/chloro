COMPARISON DIFF
============================================================

Original size: 15690 bytes
Chloro size:   15411 bytes
Rustfmt size:  15822 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{adjusted_display_range, Diagnostic, DiagnosticCode, DiagnosticsContext};
 
-// Diagnostic: unresolved-field
-//
-// This diagnostic is triggered if a field does not exist on a given type.
 pub(crate) fn unresolved_field(
     ctx: &DiagnosticsContext<'_>,
     d: &hir::UnresolvedField<'_>,
         fixes.extend(method_fix(ctx, &d.expr));
     }
     fixes.extend(field_fix(ctx, d));
-    if fixes.is_empty() {
-        None
-    } else {
-        Some(fixes)
-    }
+    if fixes.is_empty() { None } else { Some(fixes) }
 }
 
-// FIXME: Add Snippet Support
 fn field_fix(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedField<'_>) -> Option<Assist> {
     // Get the FileRange of the invalid field access
     let root = ctx.sema.db.parse_or_expand(d.expr.file_id);
     let adt = d.receiver.strip_references().as_adt()?;
     let target_module = adt.module(ctx.sema.db);
 
-    let suggested_type = if let Some(new_field_type) = ctx
-        .sema
-        .type_of_expr(&expr)
-        .map(|v| v.adjusted())
-        .filter(|it| !it.is_unknown())
+    let suggested_type = if let Some(new_field_type) =
+        ctx.sema.type_of_expr(&expr).map(|v| v.adjusted()).filter(|it| !it.is_unknown())
     {
-        let display = new_field_type
-            .display_source_code(ctx.sema.db, target_module.into(), false)
-            .ok();
+        let display =
+            new_field_type.display_source_code(ctx.sema.db, target_module.into(), false).ok();
         make::ty(display.as_deref().unwrap_or("()"))
     } else {
         make::ty("()")
     let range = adt_syntax.original_file_range_rooted(ctx.sema.db);
     let field_name = make::name(field_name);
 
-    let (offset, record_field) = record_field_layout(
-        None,
-        field_name,
-        suggested_type,
-        field_list,
-        adt_syntax.value,
-    )?;
+    let (offset, record_field) =
+        record_field_layout(None, field_name, suggested_type, field_list, adt_syntax.value)?;
 
     let mut src_change_builder = SourceChangeBuilder::new(range.file_id.file_id(ctx.sema.db));
     src_change_builder.insert(offset, record_field);
     let comma = if needs_comma { ",\n" } else { "\n" };
     let record_field = make::record_field(visibility, name, suggested_type);
 
-    Some((
-        offset,
-        format!("{comma}{indent}{record_field}{trailing_new_line}"),
-    ))
+    Some((offset, format!("{comma}{indent}{record_field}{trailing_new_line}")))
 }
 
-// FIXME: We should fill out the call here, move the cursor and trigger signature help
 fn method_fix(
     ctx: &DiagnosticsContext<'_>,
     expr_ptr: &InFile<AstPtr<Either<ast::Expr, ast::Pat>>>,
         command: None,
     })
 }
+
 #[cfg(test)]
 mod tests {
-
     use crate::{
         tests::{
             check_diagnostics, check_diagnostics_with_config, check_diagnostics_with_disabled,
         },
         DiagnosticsConfig,
     };
-
     #[test]
     fn smoke_test() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_clash() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_trait_() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_trait_2() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn no_diagnostic_on_unknown() {
         check_diagnostics_with_disabled(
             &["E0425"],
         );
     }
-
     #[test]
     fn no_diagnostic_for_missing_name() {
         let mut config = DiagnosticsConfig::test_sample();
         config.disabled.insert("syntax-error".to_owned());
         check_diagnostics_with_config(config, "fn foo() { (). }");
     }
-
     #[test]
     fn unresolved_field_fix_on_unit() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn no_fix_when_indexed() {
-        check_no_fix(
-            r#"
+        check_no_fix(r#"
             struct Kek {}
 impl Kek {
     pub fn foo(self) {
 }
 
 fn main() {}
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn no_fix_when_without_field() {
-        check_no_fix(
-            r#"
+        check_no_fix(r#"
             struct Kek {}
 impl Kek {
     pub fn foo(self) {
 }
 
 fn main() {}
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn regression_18683() {
         check_diagnostics(