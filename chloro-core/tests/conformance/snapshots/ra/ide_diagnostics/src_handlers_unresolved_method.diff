COMPARISON DIFF
============================================================

Original size: 10022 bytes
Chloro size:   9794 bytes
Rustfmt size:  10253 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{adjusted_display_range, Diagnostic, DiagnosticCode, DiagnosticsContext};
 
-// Diagnostic: unresolved-method
-//
-// This diagnostic is triggered if a method does not exist on a given type.
 pub(crate) fn unresolved_method(
     ctx: &DiagnosticsContext<'_>,
     d: &hir::UnresolvedMethodCall<'_>,
             d.name.display(ctx.sema.db, ctx.edition),
             d.receiver.display(ctx.sema.db, ctx.display_target)
         ),
-        adjusted_display_range(ctx, d.expr, &|expr| {
+        adjusted_display_range(
+        ctx,
+        d.expr,
+        &|expr| {
             Some(
                 match expr.left()? {
                     ast::Expr::MethodCallExpr(it) => it.name_ref(),
                 .syntax()
                 .text_range(),
             )
-        }),
+        },
+    ),
+    ).with_fixes(
+        fixes(ctx, d),
     )
-    .with_fixes(fixes(ctx, d))
 }
 
 fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedMethodCall<'_>) -> Option<Vec<Assist>> {
         ast::Expr::MethodCallExpr(mcall) => {
             let FileRange { range, file_id } =
                 ctx.sema.original_range_opt(mcall.receiver()?.syntax())?;
-            let FileRange {
-                range: range2,
-                file_id: file_id2,
-            } = ctx.sema.original_range_opt(mcall.name_ref()?.syntax())?;
+            let FileRange { range: range2, file_id: file_id2 } =
+                ctx.sema.original_range_opt(mcall.name_ref()?.syntax())?;
             if file_id != file_id2 {
                 return None;
             }
         group: None,
         target: range,
         source_change: Some(SourceChange::from_iter([
-            (
-                file_id.file_id(ctx.sema.db),
-                TextEdit::insert(range.start(), "(".to_owned()),
-            ),
-            (
-                file_id.file_id(ctx.sema.db),
-                TextEdit::insert(range.end(), ")".to_owned()),
-            ),
+            (file_id.file_id(ctx.sema.db), TextEdit::insert(range.start(), "(".to_owned())),
+            (file_id.file_id(ctx.sema.db), TextEdit::insert(range.end(), ")".to_owned())),
         ])),
         command: None,
     })
 ) -> Option<Assist> {
     if let Some(f) = d.assoc_func_with_same_name {
         let db = ctx.sema.db;
-
         let expr_ptr = &d.expr;
         let root = db.parse_or_expand(expr_ptr.file_id);
         let expr: ast::Expr = expr_ptr.value.to_node(&root).left()?;
-
         let call = ast::MethodCallExpr::cast(expr.syntax().clone())?;
         let range = InFile::new(expr_ptr.file_id, call.syntax().text_range())
             .original_node_file_range_rooted_opt(db)?;
-
         let receiver = call.receiver()?;
         let receiver_type = &ctx.sema.type_of_expr(&receiver)?.original;
-
         let assoc_fn_params = f.assoc_fn_params(db);
         let need_to_take_receiver_as_first_arg = if assoc_fn_params.is_empty() {
             false
                 })
                 .unwrap_or(false)
         };
-
-        let mut receiver_type_adt_name = receiver_type
-            .as_adt()?
-            .name(db)
-            .display_no_db(ctx.edition)
-            .to_smolstr();
-
-        let generic_parameters: Vec<SmolStr> = receiver_type
-            .generic_parameters(db, ctx.display_target)
-            .collect();
-        // if receiver should be pass as first arg in the assoc func,
-        // we could omit generic parameters cause compiler can deduce it automatically
+        let mut receiver_type_adt_name =
+            receiver_type.as_adt()?.name(db).display_no_db(ctx.edition).to_smolstr();
+        let generic_parameters: Vec<SmolStr> =
+            receiver_type.generic_parameters(db, ctx.display_target).collect();
         if !need_to_take_receiver_as_first_arg && !generic_parameters.is_empty() {
             let generic_parameters = generic_parameters.join(", ");
             receiver_type_adt_name =
                 format_smolstr!("{receiver_type_adt_name}::<{generic_parameters}>");
         }
-
         let method_name = call.name_ref()?;
         let assoc_func_path = format!("{receiver_type_adt_name}::{method_name}");
-
         let assoc_func_path = make::expr_path(make::path_from_text(&assoc_func_path));
-
         let args: Vec<_> = if need_to_take_receiver_as_first_arg {
-            std::iter::once(receiver)
-                .chain(call.arg_list()?.args())
-                .collect()
+            std::iter::once(receiver).chain(call.arg_list()?.args()).collect()
         } else {
             call.arg_list()?.args().collect()
         };
         let args = make::arg_list(args);
-
         let assoc_func_call_expr_string = make::expr_call(assoc_func_path, args).to_string();
-
         Some(Assist {
             id: AssistId::quick_fix("method_call_to_assoc_func_call_fix"),
             label: Label::new(format!(
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_diagnostics, check_fix};
-
     #[test]
     fn test_assoc_func_fix() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn test_assoc_func_diagnostic() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn test_assoc_func_fix_with_generic() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn smoke_test() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn smoke_test_in_macro_def_site() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn smoke_test_in_macro_call_site() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn field() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn callable_field() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn iter_collect() {
         check_diagnostics(