COMPARISON DIFF
============================================================

Original size: 27673 bytes
Chloro size:   27496 bytes
Rustfmt size:  28292 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 };
 use syntax::{
     ast::{
-        self,
-        edit::{AstNodeEdit, IndentLevel},
-        syntax_factory::SyntaxFactory,
-        BlockExpr, Expr, ExprStmt, HasArgList,
+        self, edit::{AstNodeEdit, IndentLevel}, syntax_factory::SyntaxFactory, BlockExpr, Expr,
+        ExprStmt, HasArgList,
     },
     AstNode, AstPtr, TextSize,
 };
 
 use crate::{adjusted_display_range, fix, Assist, Diagnostic, DiagnosticCode, DiagnosticsContext};
 
-// Diagnostic: type-mismatch
-//
-// This diagnostic is triggered when the type of an expression or pattern does not match
-// the expected type.
-pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch<'_>) -> Diagnostic {
+pub(crate) fn type_mismatch(
+    ctx: &DiagnosticsContext<'_>,
+    d: &hir::TypeMismatch<'_>,
+) -> Diagnostic {
     let display_range = adjusted_display_range(ctx, d.expr_or_pat, &|node| {
-        let Either::Left(expr) = node else {
-            return None;
-        };
+        let Either::Left(expr) = node else { return None };
         let salient_token_range = match expr {
             ast::Expr::IfExpr(it) => it.if_token()?.text_range(),
             ast::Expr::LoopExpr(it) => it.loop_token()?.text_range(),
                 .with_closure_style(ClosureStyle::ClosureWithId),
         ),
         display_range,
+    ).with_fixes(
+        fixes(ctx, d),
     )
-    .with_fixes(fixes(ctx, d))
 }
 
 fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch<'_>) -> Option<Vec<Assist>> {
     let mut fixes = Vec::new();
 
     if let Some(expr_ptr) = d.expr_or_pat.value.cast::<ast::Expr>() {
-        let expr_ptr = &InFile {
-            file_id: d.expr_or_pat.file_id,
-            value: expr_ptr,
-        };
+        let expr_ptr = &InFile { file_id: d.expr_or_pat.file_id, value: expr_ptr };
         add_reference(ctx, d, expr_ptr, &mut fixes);
         add_missing_ok_or_some(ctx, d, expr_ptr, &mut fixes);
         remove_unnecessary_wrapper(ctx, d, expr_ptr, &mut fixes);
         str_ref_to_owned(ctx, d, expr_ptr, &mut fixes);
     }
 
-    if fixes.is_empty() {
-        None
-    } else {
-        Some(fixes)
-    }
+    if fixes.is_empty() { None } else { Some(fixes) }
 }
 
 fn add_reference(
     expr_ptr: &InFile<AstPtr<ast::Expr>>,
     acc: &mut Vec<Assist>,
 ) -> Option<()> {
-    let range = ctx
-        .sema
-        .diagnostics_display_range((*expr_ptr).map(|it| it.into()));
+    let range = ctx.sema.diagnostics_display_range((*expr_ptr).map(|it| it.into()));
 
     let (_, mutability) = d.expected.as_reference()?;
     let actual_with_ref = d.actual.add_reference(mutability);
 
     let edit = TextEdit::insert(range.range.start(), ampersands);
     let source_change = SourceChange::from_text_edit(range.file_id, edit);
-    acc.push(fix(
-        "add_reference_here",
-        "Add reference here",
-        source_change,
-        range.range,
-    ));
+    acc.push(fix("add_reference_here", "Add reference here", source_change, range.range));
     Some(())
 }
 
         return None;
     }
 
-    let variant_name = if Some(expected_enum) == core_result {
-        "Ok"
-    } else {
-        "Some"
-    };
+    let variant_name = if Some(expected_enum) == core_result { "Ok" } else { "Some" };
 
     let wrapped_actual_ty =
         expected_adt.ty_with_args(ctx.sema.db, std::iter::once(d.actual.clone()));
                 }
 
                 let source_change = SourceChange::from_text_edit(
-                    expr_ptr
-                        .file_id
-                        .original_file(ctx.sema.db)
-                        .file_id(ctx.sema.db),
+                    expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
                     builder.finish(),
                 );
                 let name = format!("Insert {variant_name}(()) as the tail of this block");
             // Fix for forms like `fn foo() -> Result<(), String> { return; }`
             if ret_expr.expr().is_none() {
                 let mut builder = TextEdit::builder();
-                builder.insert(
-                    ret_expr.syntax().text_range().end(),
-                    format!(" {variant_name}(())"),
-                );
+                builder
+                    .insert(ret_expr.syntax().text_range().end(), format!(" {variant_name}(())"));
                 let source_change = SourceChange::from_text_edit(
-                    expr_ptr
-                        .file_id
-                        .original_file(ctx.sema.db)
-                        .file_id(ctx.sema.db),
+                    expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
                     builder.finish(),
                 );
                 let name = format!("Insert {variant_name}(()) as the return value");
     }
 
     let mut builder = TextEdit::builder();
-    builder.insert(
-        expr.syntax().text_range().start(),
-        format!("{variant_name}("),
-    );
+    builder.insert(expr.syntax().text_range().start(), format!("{variant_name}("));
     builder.insert(expr.syntax().text_range().end(), ")".to_owned());
     let source_change = SourceChange::from_text_edit(
-        expr_ptr
-            .file_id
-            .original_file(ctx.sema.db)
-            .file_id(ctx.sema.db),
+        expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
         builder.finish(),
     );
     let name = format!("Wrap in {variant_name}");
         return None;
     }
 
-    let inner_type = variant
-        .fields(db)
-        .first()?
-        .ty_with_args(db, d.actual.type_arguments());
+    let inner_type = variant.fields(db).first()?.ty_with_args(db, d.actual.type_arguments());
     if !d.expected.could_unify_with(db, &inner_type) {
         return None;
     }
         return None;
     }
     let block = BlockExpr::cast(expr.syntax().clone())?;
-    let expr_before_semi = block
-        .statements()
-        .last()
-        .and_then(|s| ExprStmt::cast(s.syntax().clone()))?;
+    let expr_before_semi =
+        block.statements().last().and_then(|s| ExprStmt::cast(s.syntax().clone()))?;
     let type_before_semi = ctx.sema.type_of_expr(&expr_before_semi.expr()?)?.original();
     if !type_before_semi.could_coerce_to(ctx.sema.db, &d.expected) {
         return None;
 
     let edit = TextEdit::delete(semicolon_range);
     let source_change = SourceChange::from_text_edit(
-        expr_ptr
-            .file_id
-            .original_file(ctx.sema.db)
-            .file_id(ctx.sema.db),
+        expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
         edit,
     );
 
-    acc.push(fix(
-        "remove_semicolon",
-        "Remove this semicolon",
-        source_change,
-        semicolon_range,
-    ));
+    acc.push(fix("remove_semicolon", "Remove this semicolon", source_change, semicolon_range));
     Some(())
 }
 
 
     let edit = TextEdit::insert(expr.syntax().text_range().end(), to_owned);
     let source_change = SourceChange::from_text_edit(
-        expr_ptr
-            .file_id
-            .original_file(ctx.sema.db)
-            .file_id(ctx.sema.db),
+        expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
         edit,
     );
-    acc.push(fix(
-        "str_ref_to_owned",
-        "Add .to_owned() here",
-        source_change,
-        expr_range,
-    ));
+    acc.push(fix("str_ref_to_owned", "Add .to_owned() here", source_change, expr_range));
 
     Some(())
 }
     use crate::tests::{
         check_diagnostics, check_diagnostics_with_disabled, check_fix, check_has_fix, check_no_fix,
     };
-
     #[test]
     fn missing_reference() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn add_reference_to_int() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_mutable_reference_to_int() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_to_array() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_with_autoderef() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_to_method_call() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_to_let_stmt() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_to_macro_call() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_mutable_reference_to_let_stmt() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn const_generic_type_mismatch() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn const_generic_unknown() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_option() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_option_tails() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_handles_generic_functions() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_handles_type_aliases() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrapped_unit_as_block_tail_expr() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn wrapped_unit_as_return_expr() {
         check_fix(
 }"#,
         );
     }
-
     #[test]
     fn wrap_in_const_and_static() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {
         check_no_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_not_applicable_when_return_type_is_not_result_or_option() {
         check_no_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_option() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_option_tails() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_option_tail_unit() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_handles_generic_functions() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_handles_type_aliases() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_tail_expr() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn unwrap_to_empty_block() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn unwrap_to_return_expr() {
         check_has_fix(
 }"#,
         );
     }
-
     #[test]
     fn unwrap_in_const_and_static() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_not_applicable_when_inner_type_does_not_match_return_type() {
         check_no_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_not_applicable_when_wrapper_type_is_not_result_or_option() {
         check_no_fix(
 "#,
         );
     }
-
     #[test]
     fn remove_semicolon() {
         check_fix(r#"fn f() -> i32 { 92$0; }"#, r#"fn f() -> i32 { 92 }"#);
     }
-
     #[test]
     fn str_ref_to_owned() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn type_mismatch_range_adjustment() {
         cov_mark::check!(type_mismatch_range_adjustment);
 "#,
         );
     }
-
     #[test]
     fn unknown_type_in_function_signature() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn evaluate_const_generics_in_types() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn type_mismatch_pat_smoke_test() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn regression_14768() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn trait_upcast_ok() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn trait_upcast_err() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn return_no_value() {
         check_diagnostics_with_disabled(
             &["needless_return"],
         );
     }
-
     #[test]
     fn smoke_test_inner_items() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn regression_17585() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn complex_enum_variant_non_ref_pat() {
         check_diagnostics(
     "#,
         );
     }
-
     #[test]
     fn regression_19844() {
         check_diagnostics(