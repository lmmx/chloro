COMPARISON DIFF
============================================================

Original size: 27673 bytes
Chloro size:   27470 bytes
Rustfmt size:  28292 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
-use hir::{db::ExpandDatabase, CallableKind, ClosureStyle, HirDisplay, InFile};
+use hir::{CallableKind, ClosureStyle, HirDisplay, InFile, db::ExpandDatabase};
 use ide_db::{
-    famous_defs::FamousDefs,
-    source_change::{SourceChange, SourceChangeBuilder},
-    text_edit::TextEdit,
+    famous_defs::FamousDefs, source_change::{SourceChange, SourceChangeBuilder}, text_edit::TextEdit,
 };
 use syntax::{
     ast::{
-        self,
+        self, BlockExpr, Expr, ExprStmt, HasArgList,
         edit::{AstNodeEdit, IndentLevel},
         syntax_factory::SyntaxFactory,
-        BlockExpr, Expr, ExprStmt, HasArgList,
     },
     AstNode, AstPtr, TextSize,
 };
 
-use crate::{adjusted_display_range, fix, Assist, Diagnostic, DiagnosticCode, DiagnosticsContext};
+use crate::{Assist, Diagnostic, DiagnosticCode, DiagnosticsContext, adjusted_display_range, fix};
 
-// Diagnostic: type-mismatch
-//
-// This diagnostic is triggered when the type of an expression or pattern does not match
-// the expected type.
-pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch<'_>) -> Diagnostic {
+pub(crate) fn type_mismatch(
+    ctx: &DiagnosticsContext<'_>,
+    d: &hir::TypeMismatch<'_>,
+) -> Diagnostic {
     let display_range = adjusted_display_range(ctx, d.expr_or_pat, &|node| {
-        let Either::Left(expr) = node else {
-            return None;
-        };
+        let Either::Left(expr) = node else { return None };
         let salient_token_range = match expr {
             ast::Expr::IfExpr(it) => it.if_token()?.text_range(),
             ast::Expr::LoopExpr(it) => it.loop_token()?.text_range(),
     .with_fixes(fixes(ctx, d))
 }
 
-fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch<'_>) -> Option<Vec<Assist>> {
+fn fixes(
+    ctx: &DiagnosticsContext<'_>,
+    d: &hir::TypeMismatch<'_>,
+) -> Option<Vec<Assist>> {
     let mut fixes = Vec::new();
-
     if let Some(expr_ptr) = d.expr_or_pat.value.cast::<ast::Expr>() {
-        let expr_ptr = &InFile {
-            file_id: d.expr_or_pat.file_id,
-            value: expr_ptr,
-        };
+        let expr_ptr = &InFile { file_id: d.expr_or_pat.file_id, value: expr_ptr };
         add_reference(ctx, d, expr_ptr, &mut fixes);
         add_missing_ok_or_some(ctx, d, expr_ptr, &mut fixes);
         remove_unnecessary_wrapper(ctx, d, expr_ptr, &mut fixes);
         remove_semicolon(ctx, d, expr_ptr, &mut fixes);
         str_ref_to_owned(ctx, d, expr_ptr, &mut fixes);
     }
-
-    if fixes.is_empty() {
-        None
-    } else {
-        Some(fixes)
-    }
+    if fixes.is_empty() { None } else { Some(fixes) }
 }
 
 fn add_reference(
     expr_ptr: &InFile<AstPtr<ast::Expr>>,
     acc: &mut Vec<Assist>,
 ) -> Option<()> {
-    let range = ctx
-        .sema
-        .diagnostics_display_range((*expr_ptr).map(|it| it.into()));
-
+    let range = ctx.sema.diagnostics_display_range((*expr_ptr).map(|it| it.into()));
     let (_, mutability) = d.expected.as_reference()?;
     let actual_with_ref = d.actual.add_reference(mutability);
     if !actual_with_ref.could_coerce_to(ctx.sema.db, &d.expected) {
         return None;
     }
-
     let ampersands = format!("&{}", mutability.as_keyword_for_ref());
-
     let edit = TextEdit::insert(range.range.start(), ampersands);
     let source_change = SourceChange::from_text_edit(range.file_id, edit);
-    acc.push(fix(
-        "add_reference_here",
-        "Add reference here",
-        source_change,
-        range.range,
-    ));
+    acc.push(fix("add_reference_here", "Add reference here", source_change, range.range));
     Some(())
 }
 
     let expr = expr_ptr.value.to_node(&root);
     let expr_range = expr.syntax().text_range();
     let scope = ctx.sema.scope(expr.syntax())?;
-
     let expected_adt = d.expected.as_adt()?;
     let expected_enum = expected_adt.as_enum()?;
-
     let famous_defs = FamousDefs(&ctx.sema, scope.krate());
     let core_result = famous_defs.core_result_Result();
     let core_option = famous_defs.core_option_Option();
-
     if Some(expected_enum) != core_result && Some(expected_enum) != core_option {
         return None;
     }
-
-    let variant_name = if Some(expected_enum) == core_result {
-        "Ok"
-    } else {
-        "Some"
-    };
-
+    let variant_name = if Some(expected_enum) == core_result { "Ok" } else { "Some" };
     let wrapped_actual_ty =
         expected_adt.ty_with_args(ctx.sema.db, std::iter::once(d.actual.clone()));
-
     if !d.expected.could_unify_with(ctx.sema.db, &wrapped_actual_ty) {
         return None;
     }
-
     if d.actual.is_unit() {
         if let Expr::BlockExpr(block) = &expr {
             if block.tail_expr().is_none() {
                 }
 
                 let source_change = SourceChange::from_text_edit(
-                    expr_ptr
-                        .file_id
-                        .original_file(ctx.sema.db)
-                        .file_id(ctx.sema.db),
+                    expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
                     builder.finish(),
                 );
                 let name = format!("Insert {variant_name}(()) as the tail of this block");
             // Fix for forms like `fn foo() -> Result<(), String> { return; }`
             if ret_expr.expr().is_none() {
                 let mut builder = TextEdit::builder();
-                builder.insert(
-                    ret_expr.syntax().text_range().end(),
-                    format!(" {variant_name}(())"),
-                );
+                builder
+                    .insert(ret_expr.syntax().text_range().end(), format!(" {variant_name}(())"));
                 let source_change = SourceChange::from_text_edit(
-                    expr_ptr
-                        .file_id
-                        .original_file(ctx.sema.db)
-                        .file_id(ctx.sema.db),
+                    expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
                     builder.finish(),
                 );
                 let name = format!("Insert {variant_name}(()) as the return value");
             return Some(());
         }
     }
-
     let mut builder = TextEdit::builder();
-    builder.insert(
-        expr.syntax().text_range().start(),
-        format!("{variant_name}("),
-    );
+    builder.insert(expr.syntax().text_range().start(), format!("{variant_name}("));
     builder.insert(expr.syntax().text_range().end(), ")".to_owned());
     let source_change = SourceChange::from_text_edit(
-        expr_ptr
-            .file_id
-            .original_file(ctx.sema.db)
-            .file_id(ctx.sema.db),
+        expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
         builder.finish(),
     );
     let name = format!("Wrap in {variant_name}");
     let root = db.parse_or_expand(expr_ptr.file_id);
     let expr = expr_ptr.value.to_node(&root);
     let expr = ctx.sema.original_ast_node(expr)?;
-
     let Expr::CallExpr(call_expr) = expr else {
         return None;
     };
-
     let callable = ctx.sema.resolve_expr_as_callable(&call_expr.expr()?)?;
     let CallableKind::TupleEnumVariant(variant) = callable.kind() else {
         return None;
     };
-
     let actual_enum = d.actual.as_adt()?.as_enum()?;
     let famous_defs = FamousDefs(&ctx.sema, ctx.sema.scope(call_expr.syntax())?.krate());
     let core_option = famous_defs.core_option_Option();
     if Some(actual_enum) != core_option && Some(actual_enum) != core_result {
         return None;
     }
-
-    let inner_type = variant
-        .fields(db)
-        .first()?
-        .ty_with_args(db, d.actual.type_arguments());
+    let inner_type = variant.fields(db).first()?.ty_with_args(db, d.actual.type_arguments());
     if !d.expected.could_unify_with(db, &inner_type) {
         return None;
     }
-
     let inner_arg = call_expr.arg_list()?.args().next()?;
-
     let file_id = expr_ptr.file_id.original_file(db);
     let mut builder = SourceChangeBuilder::new(file_id.file_id(ctx.sema.db));
     let mut editor;
             editor.replace(call_expr.syntax(), inner_arg.syntax());
         }
     }
-
     builder.add_file_edits(file_id.file_id(ctx.sema.db), editor);
     let name = format!("Remove unnecessary {}() wrapper", variant.name(db).as_str());
     acc.push(fix(
         return None;
     }
     let block = BlockExpr::cast(expr.syntax().clone())?;
-    let expr_before_semi = block
-        .statements()
-        .last()
-        .and_then(|s| ExprStmt::cast(s.syntax().clone()))?;
+    let expr_before_semi =
+        block.statements().last().and_then(|s| ExprStmt::cast(s.syntax().clone()))?;
     let type_before_semi = ctx.sema.type_of_expr(&expr_before_semi.expr()?)?.original();
     if !type_before_semi.could_coerce_to(ctx.sema.db, &d.expected) {
         return None;
     }
     let semicolon_range = expr_before_semi.semicolon_token()?.text_range();
-
     let edit = TextEdit::delete(semicolon_range);
     let source_change = SourceChange::from_text_edit(
-        expr_ptr
-            .file_id
-            .original_file(ctx.sema.db)
-            .file_id(ctx.sema.db),
+        expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
         edit,
     );
-
-    acc.push(fix(
-        "remove_semicolon",
-        "Remove this semicolon",
-        source_change,
-        semicolon_range,
-    ));
+    acc.push(fix("remove_semicolon", "Remove this semicolon", source_change, semicolon_range));
     Some(())
 }
 
     if !is_applicable {
         return None;
     }
-
     let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id);
     let expr = expr_ptr.value.to_node(&root);
     let expr_range = expr.syntax().text_range();
-
     let to_owned = ".to_owned()".to_owned();
-
     let edit = TextEdit::insert(expr.syntax().text_range().end(), to_owned);
     let source_change = SourceChange::from_text_edit(
-        expr_ptr
-            .file_id
-            .original_file(ctx.sema.db)
-            .file_id(ctx.sema.db),
+        expr_ptr.file_id.original_file(ctx.sema.db).file_id(ctx.sema.db),
         edit,
     );
-    acc.push(fix(
-        "str_ref_to_owned",
-        "Add .to_owned() here",
-        source_change,
-        expr_range,
-    ));
-
+    acc.push(fix("str_ref_to_owned", "Add .to_owned() here", source_change, expr_range));
     Some(())
 }
 
     use crate::tests::{
         check_diagnostics, check_diagnostics_with_disabled, check_fix, check_has_fix, check_no_fix,
     };
-
     #[test]
     fn missing_reference() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn add_reference_to_int() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_mutable_reference_to_int() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_to_array() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_with_autoderef() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_to_method_call() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_to_let_stmt() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_reference_to_macro_call() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn add_mutable_reference_to_let_stmt() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn const_generic_type_mismatch() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn const_generic_unknown() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_option() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_option_tails() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_handles_generic_functions() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_handles_type_aliases() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn wrapped_unit_as_block_tail_expr() {
         check_fix(
 }
             "#,
         );
-
         check_fix(
             r#"
 //- minicore: result
             "#,
         );
     }
-
     #[test]
     fn wrapped_unit_as_return_expr() {
         check_fix(
 }"#,
         );
     }
-
     #[test]
     fn wrap_in_const_and_static() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {
         check_no_fix(
 "#,
         );
     }
-
     #[test]
     fn wrap_return_type_not_applicable_when_return_type_is_not_result_or_option() {
         check_no_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_option() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_option_tails() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_option_tail_unit() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_handles_generic_functions() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_handles_type_aliases() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_tail_expr() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn unwrap_to_empty_block() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn unwrap_to_return_expr() {
         check_has_fix(
 }"#,
         );
     }
-
     #[test]
     fn unwrap_in_const_and_static() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_not_applicable_when_inner_type_does_not_match_return_type() {
         check_no_fix(
 "#,
         );
     }
-
     #[test]
     fn unwrap_return_type_not_applicable_when_wrapper_type_is_not_result_or_option() {
         check_no_fix(
 "#,
         );
     }
-
     #[test]
     fn remove_semicolon() {
         check_fix(r#"fn f() -> i32 { 92$0; }"#, r#"fn f() -> i32 { 92 }"#);
     }
-
     #[test]
     fn str_ref_to_owned() {
         check_fix(
             "#,
         );
     }
-
     #[test]
     fn type_mismatch_range_adjustment() {
         cov_mark::check!(type_mismatch_range_adjustment);
 "#,
         );
     }
-
     #[test]
     fn unknown_type_in_function_signature() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn evaluate_const_generics_in_types() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn type_mismatch_pat_smoke_test() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn regression_14768() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn trait_upcast_ok() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn trait_upcast_err() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn return_no_value() {
         check_diagnostics_with_disabled(
             &["needless_return"],
         );
     }
-
     #[test]
     fn smoke_test_inner_items() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn regression_17585() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn complex_enum_variant_non_ref_pat() {
         check_diagnostics(
     "#,
         );
     }
-
     #[test]
     fn regression_19844() {
         check_diagnostics(