COMPARISON DIFF
============================================================

Original size: 10574 bytes
Chloro size:   10130 bytes
Rustfmt size:  10774 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{adjusted_display_range, Diagnostic, DiagnosticCode, DiagnosticsContext};
 
-// Diagnostic: mismatched-tuple-struct-pat-arg-count
-//
-// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.
 pub(crate) fn mismatched_tuple_struct_pat_arg_count(
     ctx: &DiagnosticsContext<'_>,
     d: &hir::MismatchedTupleStructPatArgCount,
         DiagnosticCode::RustcHardError("E0023"),
         message,
         invalid_args_range(ctx, d.expr_or_pat, d.expected, d.found),
-    )
-    .stable()
+    ).stable()
 }
 
-// Diagnostic: mismatched-arg-count
-//
-// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.
 pub(crate) fn mismatched_arg_count(
     ctx: &DiagnosticsContext<'_>,
     d: &hir::MismatchedArgCount,
         DiagnosticCode::RustcHardError("E0107"),
         message,
         invalid_args_range(ctx, d.call_expr, d.expected, d.found),
-    )
-    .stable()
+    ).stable()
 }
 
 fn invalid_args_range(
     expected: usize,
     found: usize,
 ) -> FileRange {
-    adjusted_display_range(ctx, source, &|expr| {
+    adjusted_display_range(
+        ctx,
+        source,
+        &|expr| {
         let (text_range, r_paren_token, expected_arg) = match expr {
             Either::Left(ast::Expr::CallExpr(call)) => {
                 let arg_list = call.arg_list()?;
                 (
                     arg_list.syntax().text_range(),
                     arg_list.r_paren_token(),
-                    arg_list
-                        .args()
-                        .nth(expected)
-                        .map(|it| it.syntax().text_range()),
+                    arg_list.args().nth(expected).map(|it| it.syntax().text_range()),
                 )
             }
             Either::Left(ast::Expr::MethodCallExpr(call)) => {
                 (
                     arg_list.syntax().text_range(),
                     arg_list.r_paren_token(),
-                    arg_list
-                        .args()
-                        .nth(expected)
-                        .map(|it| it.syntax().text_range()),
+                    arg_list.args().nth(expected).map(|it| it.syntax().text_range()),
                 )
             }
             Either::Right(ast::Pat::TupleStructPat(pat)) => {
                 (
                     l_paren.text_range().cover(r_paren.text_range()),
                     Some(r_paren),
-                    pat.fields()
-                        .nth(expected)
-                        .map(|it| it.syntax().text_range()),
+                    pat.fields().nth(expected).map(|it| it.syntax().text_range()),
                 )
             }
             _ => return None,
         }
 
         None
-    })
+    },
+    )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::check_diagnostics;
-
     #[test]
     fn simple_free_fn_zero() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn simple_free_fn_one() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_as_fn() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_with_arg() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn method_unknown_receiver() {
         // note: this is incorrect code, so there might be errors on this in the
 "#,
         );
     }
-
     #[test]
     fn tuple_struct() {
-        check_diagnostics(
-            r#"
+        check_diagnostics(r#"
 struct Tup(u8, u16);
 fn f() {
     Tup(0);
 }      //^ error: expected 2 arguments, found 1
-"#,
-        )
+"#)
     }
-
     #[test]
     fn enum_variant() {
-        check_diagnostics(
-            r#"
+        check_diagnostics(r#"
 enum En { Variant(u8, u16), }
 fn f() {
     En::Variant(0);
 }              //^ error: expected 2 arguments, found 1
-"#,
-        )
+"#)
     }
-
     #[test]
     fn enum_variant_type_macro() {
         check_diagnostics(
         "#,
         );
     }
-
     #[test]
     fn rest_pat_in_macro_expansion() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn varargs() {
-        check_diagnostics(
-            r#"
+        check_diagnostics(r#"
 extern "C" {
     fn fixed(fixed: u8);
     fn varargs(fixed: u8, ...);
         varargs2(0, 1);
     }
 }
-        "#,
-        )
+        "#)
     }
-
     #[test]
     fn arg_count_lambda() {
-        check_diagnostics(
-            r#"
+        check_diagnostics(r#"
 fn main() {
     let f = |()| ();
     f();
     f((), ());
         //^^^ error: expected 1 argument, found 2
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn cfgd_out_call_arguments() {
         check_diagnostics(
             "#,
         );
     }
-
     #[test]
     fn cfgd_out_fn_params() {
-        check_diagnostics(
-            r#"
+        check_diagnostics(r#"
 fn foo(#[cfg(NEVER)] x: ()) {}
 
 struct S;
         varargs(1, 2, 3);
     }
 }
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn legacy_const_generics() {
-        check_diagnostics(
-            r#"
+        check_diagnostics(r#"
 #[rustc_legacy_const_generics(1, 3)]
 fn mixed<const N1: &'static str, const N2: bool>(
     _a: u8,
     b(0, 1, 2);
            //^ error: expected 4 arguments, found 3
 }
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn tuple_struct_pat() {
-        check_diagnostics(
-            r#"
+        check_diagnostics(r#"
 struct S(u32, u32);
 fn f(
     S(a, b, c): S,
     S(e, f, .., g, d): S
   //        ^^^^^^^^^ error: this pattern has 4 fields, but the corresponding tuple struct has 2 fields
 ) { _ = (a, b, c, d, e, f, g); }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn no_type_mismatches_when_arg_count_mismatch() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn regression_17233() {
         check_diagnostics(