COMPARISON DIFF
============================================================

Original size: 11158 bytes
Chloro size:   10978 bytes
Rustfmt size:  11215 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     DiagnosticsContext,
 };
 
-// Diagnostic: no-such-field
-//
-// This diagnostic is triggered if created structure does not have field provided in record.
 pub(crate) fn no_such_field(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Diagnostic {
     let (code, message) = if d.private.is_some() {
         ("E0451", "field is private")
     };
 
     let node = d.field.map(Into::into);
-    Diagnostic::new_with_syntax_node_ptr(ctx, DiagnosticCode::RustcHardError(code), message, node)
-        .stable()
-        .with_fixes(fixes(ctx, d))
+    Diagnostic::new_with_syntax_node_ptr(ctx, DiagnosticCode::RustcHardError(code), message, node).stable(
+    ).with_fixes(
+        fixes(ctx, d),
+    )
 }
 
 fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Option<Vec<Assist>> {
                     node,
                 )
             }
-        }
+        },
         _ => None,
     }
 }
     let new_field = make::record_field(
         None,
         make::name(record_expr_field.field_name()?.ident_token()?.text()),
-        make::ty(
-            &new_field_type
-                .display_source_code(sema.db, module.into(), true)
-                .ok()?,
-        ),
+        make::ty(&new_field_type.display_source_code(sema.db, module.into(), true).ok()?),
     );
 
     let last_field = record_fields.fields().last()?;
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_diagnostics, check_fix, check_no_fix};
-
     #[test]
     fn dont_work_for_field_with_disabled_cfg() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn no_such_field_diagnostics() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn no_such_field_enum_with_feature_flag_diagnostics() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn no_such_field_with_type_macro() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn test_add_field_from_usage() {
         check_fix(
 ",
         )
     }
-
     #[test]
     fn test_add_field_in_other_file_from_usage() {
         check_fix(
 "#,
         )
     }
-
     #[test]
     fn test_tuple_field_on_record_struct() {
-        check_no_fix(
-            r#"
+        check_no_fix(r#"
 struct Struct {}
 fn main() {
     Struct {
         0$0: 0
     }
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn test_struct_field_private() {
-        check_diagnostics(
-            r#"
+        check_diagnostics(r#"
 mod m {
     pub struct Struct {
         field: u32,
       //^^^^^^ ðŸ’¡ error: field is private
     };
 }
-"#,
-        )
+"#)
     }
-
     #[test]
     fn test_struct_field_private_same_crate_fix() {
         check_diagnostics(
 "#,
         );
     }
-
     #[test]
     fn test_struct_field_private_other_crate_fix() {
         check_fix(
 "#,
         );
     }
-
     #[test]
     fn editions_between_macros() {
         check_diagnostics(