COMPARISON DIFF
============================================================

Original size: 27822 bytes
Chloro size:   27721 bytes
Rustfmt size:  27822 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 mod tests {
     use crate::{
         DiagnosticsConfig,
-        tests::{
-            check_diagnostics, check_diagnostics_with_config, check_diagnostics_with_disabled,
-        },
+        tests::{check_diagnostics, check_diagnostics_with_config, check_diagnostics_with_disabled},
     };
     use test_utils::skip_slow_tests;
-
     #[track_caller]
     fn check_diagnostics_no_bails(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         cov_mark::check_count!(validate_match_bailed_out, 0);
         crate::tests::check_diagnostics(ra_fixture)
     }
-
     #[test]
     fn empty_body() {
         let mut config = DiagnosticsConfig::test_sample();
 "#,
         );
     }
-
     #[test]
     fn empty_tuple() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn tuple_of_two_empty_tuple() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn boolean() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn tuple_of_tuple_and_bools() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn enums() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn enum_containing_bool() {
         check_diagnostics_no_bails(
         "#,
         );
     }
-
     #[test]
     fn enum_different_sizes() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn tuple_of_enum_no_diagnostic() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn or_pattern_no_diagnostic() {
-        check_diagnostics_no_bails(
-            r#"
+        check_diagnostics_no_bails(r#"
 enum Either {A, B}
 
 fn main() {
     match (Either::A, Either::B) {
         (Either::A | Either::B, _) => (),
     }
-}"#,
-        )
+}"#)
     }
-
     #[test]
     fn mismatched_types() {
         cov_mark::check_count!(validate_match_bailed_out, 4);
             &["E0425"],
         );
     }
-
     #[test]
     fn mismatched_types_issue_15883() {
         // Check we don't panic.
             "#,
         );
     }
-
     #[test]
     fn mismatched_types_in_or_patterns() {
         cov_mark::check_count!(validate_match_bailed_out, 2);
 "#,
         );
     }
-
     #[test]
     fn malformed_match_arm_tuple_enum_missing_pattern() {
         // We are testing to be sure we don't panic here when the match
 "#,
         );
     }
-
     #[test]
     fn malformed_match_arm_extra_fields() {
         cov_mark::check_count!(validate_match_bailed_out, 2);
 "#,
         );
     }
-
     #[test]
     fn expr_diverges() {
         cov_mark::check_count!(validate_match_bailed_out, 2);
 "#,
         );
     }
-
     #[test]
     fn expr_partially_diverges() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn enum_record() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn enum_record_fields_out_of_order() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn enum_record_ellipsis() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn enum_tuple_partial_ellipsis() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn never() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn unknown_type() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn arity_mismatch_issue_16746() {
         check_diagnostics_with_disabled(
             &["E0308"],
         );
     }
-
     #[test]
     fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {
         check_diagnostics_no_bails(
 }"#,
         );
     }
-
     #[test]
     fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {
         check_diagnostics_no_bails(
 }"#,
         );
     }
-
     #[test]
     fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {
         check_diagnostics_no_bails(
 }"#,
         );
     }
-
     #[test]
     fn record_struct() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn tuple_struct() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn unit_struct() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn record_struct_ellipsis() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn internal_or() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn no_panic_at_unimplemented_subpattern_type() {
         cov_mark::check_count!(validate_match_bailed_out, 1);
 "#,
         );
     }
-
     #[test]
     fn binding() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn binding_ref_has_correct_type() {
         // Asserts `PatKind::Binding(ref _x): bool`, not &bool.
 "#,
         );
     }
-
     #[test]
     fn enum_non_exhaustive() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn match_guard() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn pattern_type_is_of_substitution() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn record_struct_no_such_field() {
         cov_mark::check_count!(validate_match_bailed_out, 1);
 "#,
         );
     }
-
     #[test]
     fn match_ergonomics_issue_9095() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn normalize_field_ty() {
         check_diagnostics_no_bails(
 };",
         );
     }
-
     #[test]
     fn binding_mode_by_ref() {
         check_diagnostics_no_bails(
 }",
         );
     }
-
     #[test]
     fn macro_or_pat() {
         check_diagnostics_no_bails(
 "#,
         );
     }
-
     #[test]
     fn unexpected_ty_fndef() {
         cov_mark::check!(validate_match_bailed_out);
             &["E0425"],
         );
     }
-
     #[test]
     fn exponential_match() {
         if skip_slow_tests() {
         write!(code, "}}").unwrap();
         check_diagnostics_no_bails(&code);
     }
-
     #[test]
     fn min_exhaustive() {
         check_diagnostics(
 "#,
         );
     }
-
     mod rust_unstable {
         use super::*;
-
         #[test]
         fn rfc_1872_exhaustive_patterns() {
             check_diagnostics_no_bails(
 }",
             );
         }
-
         #[test]
         fn rfc_1872_private_uninhabitedness() {
             check_diagnostics_no_bails(
             );
         }
     }
-
     #[test]
     fn non_exhaustive_may_be_empty() {
         check_diagnostics_no_bails(
 ",
         );
     }
-
     mod false_negatives {
         //! The implementation of match checking here is a work in progress. As we roll this out, we
         //! prefer false negatives to false positives (ideally there would be no false positives). This
         //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.
         //!   2. It ensures the code doesn't panic when handling these cases.
         use super::*;
-
         #[test]
         fn integers() {
             cov_mark::check_count!(validate_match_bailed_out, 1);
 "#,
             );
         }
-
         #[test]
         fn reference_patterns_at_top_level() {
             cov_mark::check_count!(validate_match_bailed_out, 1);
             "#,
             );
         }
-
         #[test]
         fn reference_patterns_in_fields() {
             cov_mark::check_count!(validate_match_bailed_out, 1);