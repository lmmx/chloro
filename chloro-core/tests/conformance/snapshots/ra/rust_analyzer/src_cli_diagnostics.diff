COMPARISON DIFF
============================================================

Original size: 5110 bytes
Chloro size:   5100 bytes
Rustfmt size:  5354 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Analyze all modules in a project for diagnostics. Exits with a non-zero
 //! status code if any errors are found.
 
+use hir::{Crate, Module, db::HirDatabase, sym};
+use ide::{AnalysisHost, AssistResolveStrategy, Diagnostic, DiagnosticsConfig, Severity};
+use ide_db::{LineIndexDatabase, base_db::SourceDatabase};
+use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
 use project_model::{CargoConfig, RustLibSource};
 use rustc_hash::FxHashSet;
 
-use hir::{db::HirDatabase, sym, Crate, Module};
-use ide::{AnalysisHost, AssistResolveStrategy, Diagnostic, DiagnosticsConfig, Severity};
-use ide_db::{base_db::SourceDatabase, LineIndexDatabase};
-use load_cargo::{load_workspace_at, LoadCargoConfig, ProcMacroServerChoice};
-
 use crate::cli::{flags, progress_report::ProgressReport};
 
 impl flags::Diagnostics {
     pub fn run(self) -> anyhow::Result<()> {
         const STACK_SIZE: usize = 1024 * 1024 * 8;
-
         let handle = stdx::thread::Builder::new(
             stdx::thread::ThreadIntent::LatencySensitive,
             "BIG_STACK_THREAD",
         .stack_size(STACK_SIZE)
         .spawn(|| self.run_())
         .unwrap();
-
         handle.join()
     }
+
     fn run_(self) -> anyhow::Result<()> {
         let cargo_config = CargoConfig {
             sysroot: Some(RustLibSource::Discover),
         let host = AnalysisHost::with_database(db);
         let db = host.raw_database();
         let analysis = host.analysis();
-
         let mut found_error = false;
         let mut visited_files = FxHashSet::default();
         let min_severity = self.severity.unwrap_or(flags::Severity::Weak);
-
         let work = all_modules(db)
             .into_iter()
             .filter(|module| {
                 !source_root.is_library
             })
             .collect::<Vec<_>>();
-
         let mut bar = ProgressReport::new(work.len());
         for module in work {
             let file_id = module.definition_source_file_id(db).original_file(db);
             if !visited_files.contains(&file_id) {
                 let message = format!("processing {}", _vfs.file_path(file_id.file_id(db)));
                 bar.set_message(move || message.clone());
-                let crate_name = module
-                    .krate()
-                    .display_name(db)
-                    .as_deref()
-                    .unwrap_or(&sym::unknown)
-                    .to_owned();
+                let crate_name =
+                    module.krate().display_name(db).as_deref().unwrap_or(&sym::unknown).to_owned();
                 for diagnostic in analysis
                     .full_diagnostics(
                         &DiagnosticsConfig::test_sample(),
                         found_error = true;
                     }
 
-                    let Diagnostic {
-                        code,
-                        message,
-                        range,
-                        severity,
-                        ..
-                    } = diagnostic;
+                    let Diagnostic { code, message, range, severity, .. } = diagnostic;
                     let line_index = db.line_index(range.file_id);
                     let start = line_index.line_col(range.range.start());
                     let end = line_index.line_col(range.range.end());
             bar.inc(1);
         }
         bar.finish_and_clear();
-
         println!();
         println!("diagnostic scan complete");
-
         if found_error {
             println!();
             anyhow::bail!("diagnostic error detected")
         }
-
         Ok(())
     }
 }
 
 fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {
-    let mut worklist: Vec<_> = Crate::all(db)
-        .into_iter()
-        .map(|krate| krate.root_module())
-        .collect();
+    let mut worklist: Vec<_> =
+        Crate::all(db).into_iter().map(|krate| krate.root_module()).collect();
     let mut modules = Vec::new();
-
     while let Some(module) = worklist.pop() {
         modules.push(module);
         worklist.extend(module.children(db));
     }
-
     modules
 }