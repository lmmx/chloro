COMPARISON DIFF
============================================================

Original size: 41840 bytes
Chloro size:   41792 bytes
Rustfmt size:  41840 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! correct. Instead, we try to provide a best-effort service. Even if the
 //! project is currently loading and we don't have a full project model, we
 //! still want to respond to various  requests.
-// FIXME: This is a mess that needs some untangling work
+
 use std::{iter, mem};
 
-use hir::{ChangeWithProcMacros, ProcMacrosBuilder, db::DefDatabase};
+use hir::{db::DefDatabase, ChangeWithProcMacros, ProcMacrosBuilder};
 use ide_db::{
+    base_db::{salsa::Durability, CrateGraphBuilder, ProcMacroLoadingError, ProcMacroPaths},
     FxHashMap,
-    base_db::{CrateGraphBuilder, ProcMacroLoadingError, ProcMacroPaths, salsa::Durability},
 };
 use itertools::Itertools;
-use load_cargo::{ProjectFolders, load_proc_macro};
+use load_cargo::{load_proc_macro, ProjectFolders};
 use lsp_types::FileSystemWatcher;
 use paths::Utf8Path;
 use proc_macro_api::ProcMacroClient;
 use project_model::{ManifestPath, ProjectWorkspace, ProjectWorkspaceKind, WorkspaceBuildScripts};
 use stdx::{format_to, thread::ThreadIntent};
+use tracing::{debug, info};
 use triomphe::Arc;
 use vfs::{AbsPath, AbsPathBuf, ChangeKind};
 
     main_loop::{DiscoverProjectParam, Task},
     op_queue::Cause,
 };
-use tracing::{debug, info};
 
 #[derive(Debug)]
 pub(crate) enum ProjectWorkspaceProgress {
     ) {
         info!(%cause, "will fetch workspaces");
 
-        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, {
+        self.task_pool.handle
+            .spawn_with_sender(ThreadIntent::Worker, {
             let linked_projects = self.config.linked_or_discovered_projects();
             let detached_files: Vec<_> = self
                 .config
         let config = self.config.cargo(None);
         let root_path = self.config.root_path().clone();
 
-        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {
+        self.task_pool.handle
+            .spawn_with_sender(ThreadIntent::Worker, move |sender| {
             sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();
 
             let progress = {
         let ignored_proc_macros = self.config.ignored_proc_macros(None).clone();
         let proc_macro_clients = self.proc_macro_clients.clone();
 
-        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {
+        self.task_pool.handle
+            .spawn_with_sender(ThreadIntent::Worker, move |sender| {
             sender.send(Task::LoadProcMacros(ProcMacroProgress::Begin)).unwrap();
 
             let ignored_proc_macros = &ignored_proc_macros;
             return;
         }
 
-        let workspaces =
-            workspaces.iter().filter_map(|res| res.as_ref().ok().cloned()).collect::<Vec<_>>();
+        let workspaces = workspaces.iter().filter_map(|res| res.as_ref().ok().cloned()).collect();
 
         let same_workspaces = workspaces.len() == self.workspaces.len()
             && workspaces
             FilesWatcher::Server => project_folders.watch,
         };
         self.vfs_config_version += 1;
-        self.loader.handle.set_config(vfs::loader::Config {
+        self.loader.handle
+            .set_config(vfs::loader::Config {
             load: project_folders.load,
             watch,
             version: self.vfs_config_version,
 
     fn recreate_crate_graph(&mut self, cause: String, initial_build: bool) {
         info!(?cause, "Building Crate Graph");
-        self.report_progress(
+        self
+            .report_progress(
             "Building CrateGraph",
             crate::lsp::utils::Progress::Begin,
             None,
         );
 
         // crate graph construction relies on these paths, record them so when one of them gets
+
         // deleted or created we trigger a reconstruction of the crate graph
         self.crate_graph_file_dependencies.clear();
         self.detached_files = self
             self.fetch_proc_macros_queue.request_op(cause, (change, proc_macro_paths));
         }
 
-        self.report_progress(
+        self
+            .report_progress(
             "Building CrateGraph",
             crate::lsp::utils::Progress::End,
             None,
         let config = self.config.flycheck(None);
         let sender = &self.flycheck_sender;
         let invocation_strategy = config.invocation_strategy();
-        let next_gen =
-            self.flycheck.iter().map(FlycheckHandle::generation).max().unwrap_or_default() + 1;
+        let next_gen = self.flycheck.iter().map(FlycheckHandle::generation).max().unwrap_or_default() + 1;
 
         self.flycheck = match invocation_strategy {
             crate::flycheck::InvocationStrategy::Once => {
     }
 }
 
-// FIXME: Move this into load-cargo?
 pub fn ws_to_crate_graph(
     workspaces: &[ProjectWorkspace],
     extra_env: &FxHashMap<String, Option<String>>,