COMPARISON DIFF
============================================================

Original size: 41840 bytes
Chloro size:   41824 bytes
Rustfmt size:  44085 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! correct. Instead, we try to provide a best-effort service. Even if the
 //! project is currently loading and we don't have a full project model, we
 //! still want to respond to various  requests.
-// FIXME: This is a mess that needs some untangling work
+
 use std::{iter, mem};
 
 use hir::{ChangeWithProcMacros, ProcMacrosBuilder, db::DefDatabase};
 pub(crate) enum BuildDataProgress {
     Begin,
     Report(String),
-    End(
-        (
-            Arc<Vec<ProjectWorkspace>>,
-            Vec<anyhow::Result<WorkspaceBuildScripts>>,
-        ),
-    ),
+    End((Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>)),
 }
 
 #[derive(Debug)]
         let _p = tracing::info_span!("GlobalState::update_configuration").entered();
         let old_config = mem::replace(&mut self.config, Arc::new(config));
         if self.config.lru_parse_query_capacity() != old_config.lru_parse_query_capacity() {
-            self.analysis_host
-                .update_lru_capacity(self.config.lru_parse_query_capacity());
+            self.analysis_host.update_lru_capacity(self.config.lru_parse_query_capacity());
         }
         if self.config.lru_query_capacities_config() != old_config.lru_query_capacities_config() {
             self.analysis_host.update_lru_capacities(
-                &self
-                    .config
-                    .lru_query_capacities_config()
-                    .cloned()
-                    .unwrap_or_default(),
+                &self.config.lru_query_capacities_config().cloned().unwrap_or_default(),
             );
         }
 
         if self.config.linked_or_discovered_projects() != old_config.linked_or_discovered_projects()
         {
-            let req = FetchWorkspaceRequest {
-                path: None,
-                force_crate_graph_reload: false,
-            };
-            self.fetch_workspaces_queue
-                .request_op("discovered projects changed".to_owned(), req)
+            let req = FetchWorkspaceRequest { path: None, force_crate_graph_reload: false };
+            self.fetch_workspaces_queue.request_op("discovered projects changed".to_owned(), req)
         } else if self.config.flycheck(None) != old_config.flycheck(None) {
             self.reload_flycheck();
         }
         if self.analysis_host.raw_database().expand_proc_attr_macros()
             != self.config.expand_proc_attr_macros()
         {
-            self.analysis_host
-                .raw_database_mut()
-                .set_expand_proc_attr_macros_with_durability(
-                    self.config.expand_proc_attr_macros(),
-                    Durability::HIGH,
-                );
+            self.analysis_host.raw_database_mut().set_expand_proc_attr_macros_with_durability(
+                self.config.expand_proc_attr_macros(),
+                Durability::HIGH,
+            );
         }
 
         if self.config.cargo(None) != old_config.cargo(None) {
-            let req = FetchWorkspaceRequest {
-                path: None,
-                force_crate_graph_reload: false,
-            };
-            self.fetch_workspaces_queue
-                .request_op("cargo config changed".to_owned(), req)
+            let req = FetchWorkspaceRequest { path: None, force_crate_graph_reload: false };
+            self.fetch_workspaces_queue.request_op("cargo config changed".to_owned(), req)
         }
 
         if self.config.cfg_set_test(None) != old_config.cfg_set_test(None) {
-            let req = FetchWorkspaceRequest {
-                path: None,
-                force_crate_graph_reload: false,
-            };
-            self.fetch_workspaces_queue
-                .request_op("cfg_set_test config changed".to_owned(), req)
+            let req = FetchWorkspaceRequest { path: None, force_crate_graph_reload: false };
+            self.fetch_workspaces_queue.request_op("cfg_set_test config changed".to_owned(), req)
         }
     }
 
                 message.push_str(
                     "`rust-analyzer.linkedProjects` have been specified, which may be incorrect. Specified project paths:\n",
                 );
-                message.push_str(&format!(
-                    "    {}",
-                    self.config.linked_manifests().format("\n    ")
-                ));
+                message
+                    .push_str(&format!("    {}", self.config.linked_manifests().format("\n    ")));
                 if self.config.has_linked_project_jsons() {
                     message.push_str("\nAdditionally, one or more project jsons are specified")
                 }
             let proc_macro_clients = self.proc_macro_clients.iter().chain(iter::repeat(&None));
 
             for (ws, proc_macro_client) in self.workspaces.iter().zip(proc_macro_clients) {
-                if let ProjectWorkspaceKind::Cargo {
-                    error: Some(error), ..
-                }
+                if let ProjectWorkspaceKind::Cargo { error: Some(error), .. }
                 | ProjectWorkspaceKind::DetachedFile {
-                    cargo: Some((_, _, Some(error))),
-                    ..
+                    cargo: Some((_, _, Some(error))), ..
                 } = &ws.kind
                 {
                     status.health |= lsp_ext::Health::Warning;
                     message.push_str(err);
                     message.push_str("\n\n");
                 }
-                if let ProjectWorkspaceKind::Cargo {
-                    rustc: Err(Some(err)),
-                    ..
-                } = &ws.kind
-                {
+                if let ProjectWorkspaceKind::Cargo { rustc: Err(Some(err)), .. } = &ws.kind {
                     status.health |= lsp_ext::Health::Warning;
                     format_to!(
                         message,
     ) {
         info!(%cause, "will fetch workspaces");
 
-        self.task_pool
-            .handle
-            .spawn_with_sender(ThreadIntent::Worker, {
-                let linked_projects = self.config.linked_or_discovered_projects();
-                let detached_files: Vec<_> = self
-                    .config
-                    .detached_files()
-                    .iter()
-                    .cloned()
-                    .map(ManifestPath::try_from)
-                    .filter_map(Result::ok)
-                    .collect();
-                let cargo_config = self.config.cargo(None);
-                let discover_command = self.config.discover_workspace_config().cloned();
-                let is_quiescent = !(self.discover_workspace_queue.op_in_progress()
-                    || self.vfs_progress_config_version < self.vfs_config_version
-                    || !self.vfs_done);
+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, {
+            let linked_projects = self.config.linked_or_discovered_projects();
+            let detached_files: Vec<_> = self
+                .config
+                .detached_files()
+                .iter()
+                .cloned()
+                .map(ManifestPath::try_from)
+                .filter_map(Result::ok)
+                .collect();
+            let cargo_config = self.config.cargo(None);
+            let discover_command = self.config.discover_workspace_config().cloned();
+            let is_quiescent = !(self.discover_workspace_queue.op_in_progress()
+                || self.vfs_progress_config_version < self.vfs_config_version
+                || !self.vfs_done);
 
-                move |sender| {
-                    let progress = {
-                        let sender = sender.clone();
-                        move |msg| {
-                            sender
-                                .send(Task::FetchWorkspace(ProjectWorkspaceProgress::Report(msg)))
-                                .unwrap()
-                        }
-                    };
-
-                    sender
-                        .send(Task::FetchWorkspace(ProjectWorkspaceProgress::Begin))
-                        .unwrap();
-
-                    if let (Some(_command), Some(path)) = (&discover_command, &path) {
-                        let build = linked_projects.iter().find_map(|project| match project {
-                            LinkedProject::InlineProjectJson(it) => it.crate_by_buildfile(path),
-                            _ => None,
-                        });
-
-                        if let Some(build) = build
-                            && is_quiescent
-                        {
-                            let path = AbsPathBuf::try_from(build.build_file)
-                                .expect("Unable to convert to an AbsPath");
-                            let arg = DiscoverProjectParam::Buildfile(path);
-                            sender.send(Task::DiscoverLinkedProjects(arg)).unwrap();
-                        }
+            move |sender| {
+                let progress = {
+                    let sender = sender.clone();
+                    move |msg| {
+                        sender
+                            .send(Task::FetchWorkspace(ProjectWorkspaceProgress::Report(msg)))
+                            .unwrap()
                     }
+                };
 
-                    let mut workspaces: Vec<_> = linked_projects
-                        .iter()
-                        .map(|project| match project {
-                            LinkedProject::ProjectManifest(manifest) => {
-                                debug!(path = %manifest, "loading project from manifest");
+                sender.send(Task::FetchWorkspace(ProjectWorkspaceProgress::Begin)).unwrap();
 
-                                project_model::ProjectWorkspace::load(
-                                    manifest.clone(),
-                                    &cargo_config,
-                                    &progress,
-                                )
-                            }
-                            LinkedProject::InlineProjectJson(it) => {
-                                let workspace = project_model::ProjectWorkspace::load_inline(
-                                    it.clone(),
-                                    &cargo_config,
-                                    &progress,
-                                );
-                                Ok(workspace)
-                            }
-                        })
-                        .collect();
+                if let (Some(_command), Some(path)) = (&discover_command, &path) {
+                    let build = linked_projects.iter().find_map(|project| match project {
+                        LinkedProject::InlineProjectJson(it) => it.crate_by_buildfile(path),
+                        _ => None,
+                    });
 
-                    let mut i = 0;
-                    while i < workspaces.len() {
-                        if let Ok(w) = &workspaces[i] {
-                            let dupes: Vec<_> = workspaces[i + 1..]
-                                .iter()
-                                .positions(|it| {
-                                    it.as_ref().is_ok_and(|ws| ws.eq_ignore_build_data(w))
-                                })
-                                .collect();
-                            dupes.into_iter().rev().for_each(|d| {
-                                _ = workspaces.remove(d + i + 1);
-                            });
-                        }
-                        i += 1;
+                    if let Some(build) = build
+                        && is_quiescent
+                    {
+                        let path = AbsPathBuf::try_from(build.build_file)
+                            .expect("Unable to convert to an AbsPath");
+                        let arg = DiscoverProjectParam::Buildfile(path);
+                        sender.send(Task::DiscoverLinkedProjects(arg)).unwrap();
                     }
-
-                    if !detached_files.is_empty() {
-                        workspaces.extend(project_model::ProjectWorkspace::load_detached_files(
-                            detached_files,
-                            &cargo_config,
-                        ));
-                    }
-
-                    info!(?workspaces, "did fetch workspaces");
-                    sender
-                        .send(Task::FetchWorkspace(ProjectWorkspaceProgress::End(
-                            workspaces,
-                            force_crate_graph_reload,
-                        )))
-                        .unwrap();
                 }
-            });
+
+                let mut workspaces: Vec<_> = linked_projects
+                    .iter()
+                    .map(|project| match project {
+                        LinkedProject::ProjectManifest(manifest) => {
+                            debug!(path = %manifest, "loading project from manifest");
+
+                            project_model::ProjectWorkspace::load(
+                                manifest.clone(),
+                                &cargo_config,
+                                &progress,
+                            )
+                        }
+                        LinkedProject::InlineProjectJson(it) => {
+                            let workspace = project_model::ProjectWorkspace::load_inline(
+                                it.clone(),
+                                &cargo_config,
+                                &progress,
+                            );
+                            Ok(workspace)
+                        }
+                    })
+                    .collect();
+
+                let mut i = 0;
+                while i < workspaces.len() {
+                    if let Ok(w) = &workspaces[i] {
+                        let dupes: Vec<_> = workspaces[i + 1..]
+                            .iter()
+                            .positions(|it| it.as_ref().is_ok_and(|ws| ws.eq_ignore_build_data(w)))
+                            .collect();
+                        dupes.into_iter().rev().for_each(|d| {
+                            _ = workspaces.remove(d + i + 1);
+                        });
+                    }
+                    i += 1;
+                }
+
+                if !detached_files.is_empty() {
+                    workspaces.extend(project_model::ProjectWorkspace::load_detached_files(
+                        detached_files,
+                        &cargo_config,
+                    ));
+                }
+
+                info!(?workspaces, "did fetch workspaces");
+                sender
+                    .send(Task::FetchWorkspace(ProjectWorkspaceProgress::End(
+                        workspaces,
+                        force_crate_graph_reload,
+                    )))
+                    .unwrap();
+            }
+        });
     }
 
     pub(crate) fn fetch_build_data(&mut self, cause: Cause) {
         let config = self.config.cargo(None);
         let root_path = self.config.root_path().clone();
 
-        self.task_pool
-            .handle
-            .spawn_with_sender(ThreadIntent::Worker, move |sender| {
-                sender
-                    .send(Task::FetchBuildData(BuildDataProgress::Begin))
-                    .unwrap();
+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {
+            sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();
 
-                let progress = {
-                    let sender = sender.clone();
-                    move |msg| {
-                        sender
-                            .send(Task::FetchBuildData(BuildDataProgress::Report(msg)))
-                            .unwrap()
-                    }
-                };
-                let res = ProjectWorkspace::run_all_build_scripts(
-                    &workspaces,
-                    &config,
-                    &progress,
-                    &root_path,
-                );
+            let progress = {
+                let sender = sender.clone();
+                move |msg| {
+                    sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()
+                }
+            };
+            let res = ProjectWorkspace::run_all_build_scripts(
+                &workspaces,
+                &config,
+                &progress,
+                &root_path,
+            );
 
-                sender
-                    .send(Task::FetchBuildData(BuildDataProgress::End((
-                        workspaces, res,
-                    ))))
-                    .unwrap();
-            });
+            sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();
+        });
     }
 
     pub(crate) fn fetch_proc_macros(
         let ignored_proc_macros = self.config.ignored_proc_macros(None).clone();
         let proc_macro_clients = self.proc_macro_clients.clone();
 
-        self.task_pool
-            .handle
-            .spawn_with_sender(ThreadIntent::Worker, move |sender| {
-                sender
-                    .send(Task::LoadProcMacros(ProcMacroProgress::Begin))
-                    .unwrap();
+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {
+            sender.send(Task::LoadProcMacros(ProcMacroProgress::Begin)).unwrap();
 
-                let ignored_proc_macros = &ignored_proc_macros;
-                let progress = {
-                    let sender = sender.clone();
-                    &move |msg| {
-                        sender
-                            .send(Task::LoadProcMacros(ProcMacroProgress::Report(msg)))
-                            .unwrap()
-                    }
-                };
-
-                let mut builder = ProcMacrosBuilder::default();
-                let proc_macro_clients = proc_macro_clients.iter().chain(iter::repeat(&None));
-                for (client, paths) in proc_macro_clients.zip(paths) {
-                    for (crate_id, res) in paths.iter() {
-                        let expansion_res = match client {
-                            Some(Ok(client)) => match res {
-                                Ok((crate_name, path)) => {
-                                    progress(format!("loading proc-macros: {path}"));
-                                    let ignored_proc_macros = ignored_proc_macros
-                                        .iter()
-                                        .find_map(|(name, macros)| {
-                                            eq_ignore_underscore(name, crate_name)
-                                                .then_some(&**macros)
-                                        })
-                                        .unwrap_or_default();
-
-                                    load_proc_macro(client, path, ignored_proc_macros)
-                                }
-                                Err(e) => Err(e.clone()),
-                            },
-                            Some(Err(e)) => Err(ProcMacroLoadingError::ProcMacroSrvError(
-                                e.to_string().into_boxed_str(),
-                            )),
-                            None => Err(ProcMacroLoadingError::ProcMacroSrvError(
-                                "proc-macro-srv is not running".into(),
-                            )),
-                        };
-                        builder.insert(*crate_id, expansion_res)
-                    }
+            let ignored_proc_macros = &ignored_proc_macros;
+            let progress = {
+                let sender = sender.clone();
+                &move |msg| {
+                    sender.send(Task::LoadProcMacros(ProcMacroProgress::Report(msg))).unwrap()
                 }
+            };
 
-                change.set_proc_macros(builder);
-                sender
-                    .send(Task::LoadProcMacros(ProcMacroProgress::End(change)))
-                    .unwrap();
-            });
+            let mut builder = ProcMacrosBuilder::default();
+            let proc_macro_clients = proc_macro_clients.iter().chain(iter::repeat(&None));
+            for (client, paths) in proc_macro_clients.zip(paths) {
+                for (crate_id, res) in paths.iter() {
+                    let expansion_res = match client {
+                        Some(Ok(client)) => match res {
+                            Ok((crate_name, path)) => {
+                                progress(format!("loading proc-macros: {path}"));
+                                let ignored_proc_macros = ignored_proc_macros
+                                    .iter()
+                                    .find_map(|(name, macros)| {
+                                        eq_ignore_underscore(name, crate_name).then_some(&**macros)
+                                    })
+                                    .unwrap_or_default();
+
+                                load_proc_macro(client, path, ignored_proc_macros)
+                            }
+                            Err(e) => Err(e.clone()),
+                        },
+                        Some(Err(e)) => Err(ProcMacroLoadingError::ProcMacroSrvError(
+                            e.to_string().into_boxed_str(),
+                        )),
+                        None => Err(ProcMacroLoadingError::ProcMacroSrvError(
+                            "proc-macro-srv is not running".into(),
+                        )),
+                    };
+                    builder.insert(*crate_id, expansion_res)
+                }
+            }
+
+            change.set_proc_macros(builder);
+            sender.send(Task::LoadProcMacros(ProcMacroProgress::End(change))).unwrap();
+        });
     }
 
     pub(crate) fn switch_workspaces(&mut self, cause: Cause) {
         let _p = tracing::info_span!("GlobalState::switch_workspaces").entered();
         tracing::info!(%cause, "will switch workspaces");
 
-        let Some(FetchWorkspaceResponse {
-            workspaces,
-            force_crate_graph_reload,
-        }) = self.fetch_workspaces_queue.last_op_result()
+        let Some(FetchWorkspaceResponse { workspaces, force_crate_graph_reload }) =
+            self.fetch_workspaces_queue.last_op_result()
         else {
             return;
         };
             return;
         }
 
-        let workspaces = workspaces
-            .iter()
-            .filter_map(|res| res.as_ref().ok().cloned())
-            .collect::<Vec<_>>();
+        let workspaces =
+            workspaces.iter().filter_map(|res| res.as_ref().ok().cloned()).collect::<Vec<_>>();
 
         let same_workspaces = workspaces.len() == self.workspaces.len()
             && workspaces
                 // Switching from empty to empty is a no-op
                 return;
             }
-            if let Some(FetchBuildDataResponse {
-                workspaces,
-                build_scripts,
-            }) = self.fetch_build_data_queue.last_op_result()
+            if let Some(FetchBuildDataResponse { workspaces, build_scripts }) =
+                self.fetch_build_data_queue.last_op_result()
             {
                 if Arc::ptr_eq(workspaces, &self.workspaces) {
                     info!("set build scripts to workspaces");
             self.workspaces = Arc::new(workspaces);
             self.check_workspaces_msrv().for_each(|message| {
                 self.send_notification::<lsp_types::notification::ShowMessage>(
-                    lsp_types::ShowMessageParams {
-                        typ: lsp_types::MessageType::WARNING,
-                        message,
-                    },
+                    lsp_types::ShowMessageParams { typ: lsp_types::MessageType::WARNING, message },
                 );
             });
 
             if self.config.run_build_scripts(None) {
                 self.build_deps_changed = false;
-                self.fetch_build_data_queue
-                    .request_op("workspace updated".to_owned(), ());
+                self.fetch_build_data_queue.request_op("workspace updated".to_owned(), ());
 
                 if !switching_from_empty_workspace {
                     // `switch_workspaces()` will be called again when build scripts already run, which should
                 .filter(|it| it.is_local)
                 .map(|it| it.include);
 
-            let mut watchers: Vec<FileSystemWatcher> = if self
-                .config
-                .did_change_watched_files_relative_pattern_support()
-            {
-                // When relative patterns are supported by the client, prefer using them
-                filter
-                    .flat_map(|include| {
-                        include.into_iter().flat_map(|base| {
-                            [
-                                (base.clone(), "**/*.rs"),
-                                (base.clone(), "**/Cargo.{lock,toml}"),
-                                (base, "**/rust-analyzer.toml"),
-                            ]
+            let mut watchers: Vec<FileSystemWatcher> =
+                if self.config.did_change_watched_files_relative_pattern_support() {
+                    // When relative patterns are supported by the client, prefer using them
+                    filter
+                        .flat_map(|include| {
+                            include.into_iter().flat_map(|base| {
+                                [
+                                    (base.clone(), "**/*.rs"),
+                                    (base.clone(), "**/Cargo.{lock,toml}"),
+                                    (base, "**/rust-analyzer.toml"),
+                                ]
+                            })
                         })
-                    })
-                    .map(|(base, pat)| lsp_types::FileSystemWatcher {
-                        glob_pattern: lsp_types::GlobPattern::Relative(
-                            lsp_types::RelativePattern {
-                                base_uri: lsp_types::OneOf::Right(
-                                    lsp_types::Url::from_file_path(base).unwrap(),
-                                ),
-                                pattern: pat.to_owned(),
-                            },
-                        ),
-                        kind: None,
-                    })
-                    .collect()
-            } else {
-                // When they're not, integrate the base to make them into absolute patterns
-                filter
-                    .flat_map(|include| {
-                        include.into_iter().flat_map(|base| {
-                            [
-                                format!("{base}/**/*.rs"),
-                                format!("{base}/**/Cargo.{{toml,lock}}"),
-                                format!("{base}/**/rust-analyzer.toml"),
-                            ]
+                        .map(|(base, pat)| lsp_types::FileSystemWatcher {
+                            glob_pattern: lsp_types::GlobPattern::Relative(
+                                lsp_types::RelativePattern {
+                                    base_uri: lsp_types::OneOf::Right(
+                                        lsp_types::Url::from_file_path(base).unwrap(),
+                                    ),
+                                    pattern: pat.to_owned(),
+                                },
+                            ),
+                            kind: None,
                         })
-                    })
-                    .map(|glob_pattern| lsp_types::FileSystemWatcher {
-                        glob_pattern: lsp_types::GlobPattern::String(glob_pattern),
-                        kind: None,
-                    })
-                    .collect()
-            };
+                        .collect()
+                } else {
+                    // When they're not, integrate the base to make them into absolute patterns
+                    filter
+                        .flat_map(|include| {
+                            include.into_iter().flat_map(|base| {
+                                [
+                                    format!("{base}/**/*.rs"),
+                                    format!("{base}/**/Cargo.{{toml,lock}}"),
+                                    format!("{base}/**/rust-analyzer.toml"),
+                                ]
+                            })
+                        })
+                        .map(|glob_pattern| lsp_types::FileSystemWatcher {
+                            glob_pattern: lsp_types::GlobPattern::String(glob_pattern),
+                            kind: None,
+                        })
+                        .collect()
+                };
 
             // Also explicitly watch any build files configured in JSON project files.
             for ws in self.workspaces.iter() {
 
             watchers.extend(
                 iter::once(Config::user_config_dir_path().as_deref())
-                    .chain(
-                        self.workspaces
-                            .iter()
-                            .map(|ws| ws.manifest().map(ManifestPath::as_ref)),
-                    )
+                    .chain(self.workspaces.iter().map(|ws| ws.manifest().map(ManifestPath::as_ref)))
                     .flatten()
                     .map(|glob_pattern| lsp_types::FileSystemWatcher {
                         glob_pattern: lsp_types::GlobPattern::String(glob_pattern.to_string()),
                 register_options: Some(serde_json::to_value(registration_options).unwrap()),
             };
             self.send_request::<lsp_types::request::RegisterCapability>(
-                lsp_types::RegistrationParams {
-                    registrations: vec![registration],
-                },
+                lsp_types::RegistrationParams { registrations: vec![registration] },
                 |_, _| (),
             );
         }
 
                 let env: FxHashMap<_, _> = match &ws.kind {
                     ProjectWorkspaceKind::Cargo { cargo, .. }
-                    | ProjectWorkspaceKind::DetachedFile {
-                        cargo: Some((cargo, ..)),
-                        ..
-                    } => cargo
+                    | ProjectWorkspaceKind::DetachedFile { cargo: Some((cargo, ..)), .. } => cargo
                         .env()
                         .into_iter()
                         .map(|(k, v)| (k.clone(), Some(v.clone())))
                         .chain(
-                            self.config
-                                .extra_env(None)
-                                .iter()
-                                .map(|(k, v)| (k.clone(), v.clone())),
+                            self.config.extra_env(None).iter().map(|(k, v)| (k.clone(), v.clone())),
                         )
                         .chain(
                             ws.sysroot
             self.finish_loading_crate_graph();
         } else {
             change.set_crate_graph(crate_graph);
-            self.fetch_proc_macros_queue
-                .request_op(cause, (change, proc_macro_paths));
+            self.fetch_proc_macros_queue.request_op(cause, (change, proc_macro_paths));
         }
 
         self.report_progress(
             }
         }
 
-        if buf.is_empty() { Ok(()) } else { Err(buf) }
+        if buf.is_empty() {
+            Ok(())
+        } else {
+            Err(buf)
+        }
     }
 
     fn reload_flycheck(&mut self) {
         let config = self.config.flycheck(None);
         let sender = &self.flycheck_sender;
         let invocation_strategy = config.invocation_strategy();
-        let next_gen = self
-            .flycheck
-            .iter()
-            .map(FlycheckHandle::generation)
-            .max()
-            .unwrap_or_default()
-            + 1;
+        let next_gen =
+            self.flycheck.iter().map(FlycheckHandle::generation).max().unwrap_or_default() + 1;
 
         self.flycheck = match invocation_strategy {
             crate::flycheck::InvocationStrategy::Once => {
     // .cargo/config{.toml}
     if path.extension().unwrap_or_default() != "rs" {
         let is_cargo_config = matches!(file_name, "config.toml" | "config")
-            && path
-                .parent()
-                .map(|parent| parent.as_str().ends_with(".cargo"))
-                .unwrap_or(false);
+            && path.parent().map(|parent| parent.as_str().ends_with(".cargo")).unwrap_or(false);
         return is_cargo_config;
     }
 
-    if IMPLICIT_TARGET_FILES
-        .iter()
-        .any(|it| path.as_str().ends_with(it))
-    {
+    if IMPLICIT_TARGET_FILES.iter().any(|it| path.as_str().ends_with(it)) {
         return true;
     }
     let parent = match path.parent() {
         Some(it) => it,
         None => return false,
     };
-    if IMPLICIT_TARGET_DIRS
-        .iter()
-        .any(|it| parent.as_str().ends_with(it))
-    {
+    if IMPLICIT_TARGET_DIRS.iter().any(|it| parent.as_str().ends_with(it)) {
         return true;
     }
     if file_name == "main.rs" {
             Some(it) => it,
             None => return false,
         };
-        if IMPLICIT_TARGET_DIRS
-            .iter()
-            .any(|it| grand_parent.as_str().ends_with(it))
-        {
+        if IMPLICIT_TARGET_DIRS.iter().any(|it| grand_parent.as_str().ends_with(it)) {
             return true;
         }
     }