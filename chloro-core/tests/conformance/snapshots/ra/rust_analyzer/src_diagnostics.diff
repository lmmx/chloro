COMPARISON DIFF
============================================================

Original size: 13221 bytes
Chloro size:   13226 bytes
Rustfmt size:  13526 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Book keeping for keeping diagnostics easily in sync with the client.
+
 pub(crate) mod flycheck_to_proto;
 
 use std::mem;
 
 use crate::{global_state::GlobalStateSnapshot, lsp, lsp_ext, main_loop::DiagnosticsTaskKind};
 
-pub(crate) type CheckFixes =
-    Arc<Vec<FxHashMap<Option<Arc<PackageId>>, FxHashMap<FileId, Vec<Fix>>>>>;
+pub(crate) type CheckFixes = Arc<Vec<FxHashMap<Option<Arc<PackageId>>, FxHashMap<FileId, Vec<Fix>>>>>;
 
 #[derive(Debug, Default, Clone)]
 pub struct DiagnosticsMapConfig {
 #[derive(Debug, Default, Clone)]
 pub(crate) struct DiagnosticCollection {
     // FIXME: should be FxHashMap<FileId, Vec<ra_id::Diagnostic>>
-    pub(crate) native_syntax:
-        FxHashMap<FileId, (DiagnosticsGeneration, Vec<lsp_types::Diagnostic>)>,
-    pub(crate) native_semantic:
-        FxHashMap<FileId, (DiagnosticsGeneration, Vec<lsp_types::Diagnostic>)>,
+    pub(crate) native_syntax: FxHashMap<FileId, (DiagnosticsGeneration, Vec<lsp_types::Diagnostic>)>,
+    pub(crate) native_semantic: FxHashMap<FileId, (DiagnosticsGeneration, Vec<lsp_types::Diagnostic>)>,
     pub(crate) check: Vec<WorkspaceFlycheckDiagnostic>,
     pub(crate) check_fixes: CheckFixes,
     changes: FxHashSet<FileId>,
         let Some(check) = self.check.get_mut(flycheck_id) else {
             return;
         };
-        self.changes.extend(
-            check
-                .per_package
-                .drain()
-                .flat_map(|(_, v)| v.per_file.into_keys()),
-        );
+        self.changes.extend(check.per_package.drain().flat_map(|(_, v)| v.per_file.into_keys()));
         if let Some(fixes) = Arc::make_mut(&mut self.check_fixes).get_mut(flycheck_id) {
             fixes.clear();
         }
 
     pub(crate) fn clear_check_all(&mut self) {
         Arc::make_mut(&mut self.check_fixes).clear();
-        self.changes.extend(self.check.iter_mut().flat_map(|it| {
-            it.per_package
-                .drain()
-                .flat_map(|(_, v)| v.per_file.into_keys())
-        }))
+        self.changes.extend(
+            self.check
+                .iter_mut()
+                .flat_map(|it| it.per_package.drain().flat_map(|(_, v)| v.per_file.into_keys())),
+        )
     }
 
     pub(crate) fn clear_check_for_package(
         fix: Option<Box<Fix>>,
     ) {
         if self.check.len() <= flycheck_id {
-            self.check
-                .resize_with(flycheck_id + 1, WorkspaceFlycheckDiagnostic::default);
+            self.check.resize_with(flycheck_id + 1, WorkspaceFlycheckDiagnostic::default);
         }
 
         let check = &mut self.check[flycheck_id];
-        let package = check
-            .per_package
-            .entry(package_id.clone())
-            .or_insert_with(|| PackageFlycheckDiagnostic {
-                generation,
-                per_file: FxHashMap::default(),
-            });
+        let package = check.per_package.entry(package_id.clone()).or_insert_with(|| {
+            PackageFlycheckDiagnostic { generation, per_file: FxHashMap::default() }
+        });
         // Getting message from old generation. Might happen in restarting checks.
         if package.generation > generation {
             return;
         &self,
         file_id: FileId,
     ) -> impl Iterator<Item = &lsp_types::Diagnostic> {
-        let native_syntax = self
-            .native_syntax
-            .get(&file_id)
-            .into_iter()
-            .flat_map(|(_, d)| d);
-        let native_semantic = self
-            .native_semantic
-            .get(&file_id)
-            .into_iter()
-            .flat_map(|(_, d)| d);
+        let native_syntax = self.native_syntax.get(&file_id).into_iter().flat_map(|(_, d)| d);
+        let native_semantic = self.native_semantic.get(&file_id).into_iter().flat_map(|(_, d)| d);
         let check = self
             .check
             .iter()
     let _ctx = DbPanicContext::enter("fetch_native_diagnostics".to_owned());
 
     // the diagnostics produced may point to different files not requested by the concrete request,
+
     // put those into here and filter later
     let mut odd_ones = Vec::new();
     let mut diagnostics = subscriptions[slice]
     lsp_types::Diagnostic {
         range: lsp::to_proto::range(line_index, d.range.range),
         severity: Some(lsp::to_proto::diagnostic_severity(d.severity)),
-        code: Some(lsp_types::NumberOrString::String(
-            d.code.as_str().to_owned(),
-        )),
-        code_description: Some(lsp_types::CodeDescription {
+        code: Some(lsp_types::NumberOrString::String(d.code.as_str().to_owned())),
+        code_description: Some(
+            lsp_types::CodeDescription {
             href: lsp_types::Url::parse(&d.code.url()).unwrap(),
-        }),
+        },
+        ),
         source: Some("rust-analyzer".to_owned()),
         message: d.message,
         related_information: None,
-        tags: d
-            .unused
-            .then(|| vec![lsp_types::DiagnosticTag::UNNECESSARY]),
+        tags: d.unused.then(|| vec![lsp_types::DiagnosticTag::UNNECESSARY]),
         data: None,
     }
 }