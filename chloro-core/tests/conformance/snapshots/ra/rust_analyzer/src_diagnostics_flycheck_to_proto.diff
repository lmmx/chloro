COMPARISON DIFF
============================================================

Original size: 77855 bytes
Chloro size:   77875 bytes
Rustfmt size:  77855 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! This module provides the functionality needed to convert diagnostics from
 //! `cargo check` json format to the LSP diagnostic format.
 
-use crate::flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};
 use itertools::Itertools;
 use rustc_hash::FxHashMap;
 use smallvec::SmallVec;
 use stdx::format_to;
 use vfs::{AbsPath, AbsPathBuf};
 
+use crate::flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};
 use crate::{
     global_state::GlobalStateSnapshot, line_index::PositionEncoding,
     lsp::to_proto::url_from_abs_path, lsp_ext,
 };
-
 use super::{DiagnosticsMapConfig, Fix};
 
 /// Determines the LSP severity from a diagnostic
 ) -> lsp_types::Location {
     let file_name = resolve_path(config, workspace_root, &span.file_name);
     let uri = url_from_abs_path(&file_name);
-
     let range = {
         let position_encoding = snap.config.negotiated_encoding();
         lsp_types::Range::new(
     column_offset_utf32: usize,
 ) -> lsp_types::Position {
     let line_index = line_number - span.line_start;
-
     let column_offset_encoded = match span.text.get(line_index) {
         // Fast path.
         Some(line) if line.text.is_ascii() => column_offset_utf32,
         }
         None => column_offset_utf32,
     };
-
     lsp_types::Position {
         line: (line_number as u32).saturating_sub(1),
         character: column_offset_encoded as u32,
             return location(config, workspace_root, span, snap);
         }
     }
-
     // Fall back to the outermost macro invocation if no suitable span comes up.
     let last_span = span_stack.last().unwrap();
     location(config, workspace_root, last_span, snap)
         // messages
         return MappedRustChildDiagnostic::MessageLine(rd.message.clone());
     }
-
     let mut edit_map: FxHashMap<lsp_types::Url, Vec<lsp_types::TextEdit>> = FxHashMap::default();
     let mut suggested_replacements = Vec::new();
     let mut is_preferred = true;
                 matches!(span.suggestion_applicability, Some(Applicability::MachineApplicable));
         }
     }
-
     // rustc renders suggestion diagnostics by appending the suggested replacement, so do the same
     // here, otherwise the diagnostic text is missing useful information.
     let mut message = rd.message.clone();
             suggested_replacements.iter().map(|suggestion| format!("`{suggestion}`")).join(", ");
         message.push_str(&suggestions);
     }
-
     let suggested_fix = if edit_map.is_empty() {
         None
     } else {
     if primary_spans.is_empty() {
         return Vec::new();
     }
-
     let mut code = diagnostic_code.as_ref().map(|c| &*c.code);
-
     if let Some(code_val) = code
         && config.check_ignore.contains(code_val)
     {
         return Vec::new();
     }
-
     let severity = diagnostic_severity(config, level, diagnostic_code.as_ref());
-
     let mut source = "rustc";
     if let Some(code_val) = code {
         // See if this is an RFC #2103 scoped lint (e.g. from Clippy)
             code = Some(c);
         }
     }
-
     let mut needs_primary_span_label = true;
     let mut subdiagnostics = Vec::new();
-
     for secondary_span in secondary_spans {
         let related = diagnostic_related_information(config, workspace_root, secondary_span, snap);
         if let Some(related) = related {
             subdiagnostics.push(SubDiagnostic { related, suggested_fix: None });
         }
     }
-
     for child in &children {
         let child = map_rust_child_diagnostic(config, workspace_root, child, snap);
         match child {
         }
     }
     let message = message;
-
     let mut tag = None;
     if let Some(code) = &diagnostic_code {
         match &*code.code {
             _ => {}
         }
     }
-
     let code_description = match source {
         "rustc" => rustc_code_description(code),
         "clippy" => clippy_code_description(code),
     };
     // Each primary diagnostic span may result in multiple LSP diagnostics.
     let mut diagnostics = Vec::new();
-
     for primary_span in primary_spans {
         let primary_location = primary_location(config, workspace_root, &primary_span, snap);
         let message = {
 #[cfg(not(windows))]
 mod tests {
     use crate::{config::Config, global_state::GlobalState};
-
     use super::*;
-
     use expect_test::{ExpectFile, expect_file};
     use lsp_types::ClientCapabilities;
     use paths::Utf8Path;
-
-    fn check(diagnostics_json: &str, expect: ExpectFile) {
+    fn check(
+        diagnostics_json: &str,
+        expect: ExpectFile,
+    ) {
         check_with_config(DiagnosticsMapConfig::default(), diagnostics_json, expect)
     }
-
-    fn check_with_config(config: DiagnosticsMapConfig, diagnostics_json: &str, expect: ExpectFile) {
+    fn check_with_config(
+        config: DiagnosticsMapConfig,
+        diagnostics_json: &str,
+        expect: ExpectFile,
+    ) {
         let diagnostic: crate::flycheck::Diagnostic =
             serde_json::from_str(diagnostics_json).unwrap();
         let workspace_root: &AbsPath = Utf8Path::new("/test/").try_into().unwrap();
         actual.iter_mut().for_each(|diag| diag.diagnostic.data = None);
         expect.assert_debug_eq(&actual)
     }
-
     #[test]
     fn rustc_incompatible_type_for_trait() {
         check(
             expect_file!["./test_data/rustc_incompatible_type_for_trait.txt"],
         );
     }
-
     #[test]
     fn rustc_unused_variable() {
         check(
             expect_file!["./test_data/rustc_unused_variable.txt"],
         );
     }
-
     #[test]
     #[cfg(not(windows))]
     fn rustc_unused_variable_as_info() {
             expect_file!["./test_data/rustc_unused_variable_as_info.txt"],
         );
     }
-
     #[test]
     #[cfg(not(windows))]
     fn rustc_unused_variable_as_hint() {
             expect_file!["./test_data/rustc_unused_variable_as_hint.txt"],
         );
     }
-
     #[test]
     fn rustc_wrong_number_of_parameters() {
         check(
             expect_file!["./test_data/rustc_wrong_number_of_parameters.txt"],
         );
     }
-
     #[test]
     fn clippy_pass_by_ref() {
         check(
             expect_file!["./test_data/clippy_pass_by_ref.txt"],
         );
     }
-
     #[test]
     fn rustc_range_map_lsp_position() {
         check(
             expect_file!("./test_data/rustc_range_map_lsp_position.txt"),
         )
     }
-
     #[test]
     fn rustc_mismatched_type() {
         check(
             expect_file!["./test_data/rustc_mismatched_type.txt"],
         );
     }
-
     #[test]
     fn handles_macro_location() {
         check(
             expect_file!["./test_data/handles_macro_location.txt"],
         );
     }
-
     #[test]
     fn macro_compiler_error() {
         check(
             expect_file!["./test_data/macro_compiler_error.txt"],
         );
     }
-
     #[test]
     fn snap_multi_line_fix() {
         check(
             expect_file!["./test_data/snap_multi_line_fix.txt"],
         );
     }
-
     #[test]
     fn reasonable_line_numbers_from_empty_file() {
         check(