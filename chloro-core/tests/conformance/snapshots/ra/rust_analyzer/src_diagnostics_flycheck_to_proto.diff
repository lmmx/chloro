COMPARISON DIFF
============================================================

Original size: 77855 bytes
Chloro size:   77868 bytes
Rustfmt size:  77855 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module provides the functionality needed to convert diagnostics from
 //! `cargo check` json format to the LSP diagnostic format.
 
-use crate::flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};
 use itertools::Itertools;
 use rustc_hash::FxHashMap;
 use smallvec::SmallVec;
 use stdx::format_to;
 use vfs::{AbsPath, AbsPathBuf};
 
+use crate::flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};
+
 use crate::{
-    global_state::GlobalStateSnapshot, line_index::PositionEncoding,
-    lsp::to_proto::url_from_abs_path, lsp_ext,
+    global_state::GlobalStateSnapshot, line_index::PositionEncoding, lsp_ext,
+    lsp::to_proto::url_from_abs_path,
 };
 
 use super::{DiagnosticsMapConfig, Fix};
     match config
         .remap_prefix
         .iter()
-        .find_map(|(from, to)| file_name.strip_prefix(from).map(|file_name| (to, file_name)))
-    {
+        .find_map(|(from, to)| file_name.strip_prefix(from).map(|file_name| (to, file_name))) {
         Some((to, file_name)) => workspace_root.join(format!("{to}{file_name}")),
         None => workspace_root.join(file_name),
     }
     }
 
     // rustc renders suggestion diagnostics by appending the suggested replacement, so do the same
+
     // here, otherwise the diagnostic text is missing useful information.
     let mut message = rd.message.clone();
     if !suggested_replacements.is_empty() {
 #[cfg(not(windows))]
 mod tests {
     use crate::{config::Config, global_state::GlobalState};
-
     use super::*;
-
     use expect_test::{ExpectFile, expect_file};
     use lsp_types::ClientCapabilities;
     use paths::Utf8Path;
-
     fn check(diagnostics_json: &str, expect: ExpectFile) {
         check_with_config(DiagnosticsMapConfig::default(), diagnostics_json, expect)
     }
-
-    fn check_with_config(config: DiagnosticsMapConfig, diagnostics_json: &str, expect: ExpectFile) {
+    fn check_with_config(
+        config: DiagnosticsMapConfig,
+        diagnostics_json: &str,
+        expect: ExpectFile,
+    ) {
         let diagnostic: crate::flycheck::Diagnostic =
             serde_json::from_str(diagnostics_json).unwrap();
         let workspace_root: &AbsPath = Utf8Path::new("/test/").try_into().unwrap();
         actual.iter_mut().for_each(|diag| diag.diagnostic.data = None);
         expect.assert_debug_eq(&actual)
     }
-
     #[test]
     fn rustc_incompatible_type_for_trait() {
         check(
             expect_file!["./test_data/rustc_incompatible_type_for_trait.txt"],
         );
     }
-
     #[test]
     fn rustc_unused_variable() {
         check(
             expect_file!["./test_data/rustc_unused_variable.txt"],
         );
     }
-
     #[test]
     #[cfg(not(windows))]
     fn rustc_unused_variable_as_info() {
             expect_file!["./test_data/rustc_unused_variable_as_info.txt"],
         );
     }
-
     #[test]
     #[cfg(not(windows))]
     fn rustc_unused_variable_as_hint() {
             expect_file!["./test_data/rustc_unused_variable_as_hint.txt"],
         );
     }
-
     #[test]
     fn rustc_wrong_number_of_parameters() {
         check(
             expect_file!["./test_data/rustc_wrong_number_of_parameters.txt"],
         );
     }
-
     #[test]
     fn clippy_pass_by_ref() {
         check(
             expect_file!["./test_data/clippy_pass_by_ref.txt"],
         );
     }
-
     #[test]
     fn rustc_range_map_lsp_position() {
         check(
             expect_file!("./test_data/rustc_range_map_lsp_position.txt"),
         )
     }
-
     #[test]
     fn rustc_mismatched_type() {
         check(
             expect_file!["./test_data/rustc_mismatched_type.txt"],
         );
     }
-
     #[test]
     fn handles_macro_location() {
         check(
             expect_file!["./test_data/handles_macro_location.txt"],
         );
     }
-
     #[test]
     fn macro_compiler_error() {
         check(
             expect_file!["./test_data/macro_compiler_error.txt"],
         );
     }
-
     #[test]
     fn snap_multi_line_fix() {
         check(
             expect_file!["./test_data/snap_multi_line_fix.txt"],
         );
     }
-
     #[test]
     fn reasonable_line_numbers_from_empty_file() {
         check(