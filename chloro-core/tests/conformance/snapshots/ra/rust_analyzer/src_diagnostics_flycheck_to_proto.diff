COMPARISON DIFF
============================================================

Original size: 77855 bytes
Chloro size:   77866 bytes
Rustfmt size:  78225 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use vfs::{AbsPath, AbsPathBuf};
 
 use crate::{
-    global_state::GlobalStateSnapshot, line_index::PositionEncoding,
-    lsp::to_proto::url_from_abs_path, lsp_ext,
+    global_state::GlobalStateSnapshot, line_index::PositionEncoding, lsp_ext,
+    lsp::to_proto::url_from_abs_path,
 };
 
 use super::{DiagnosticsMapConfig, Fix};
                 span.line_start,
                 span.column_start.saturating_sub(1),
             ),
-            position(
-                &position_encoding,
-                span,
-                span.line_end,
-                span.column_end.saturating_sub(1),
-            ),
+            position(&position_encoding, span, span.line_end, span.column_end.saturating_sub(1)),
         )
     };
     lsp_types::Location::new(uri, range)
     workspace_root: &AbsPath,
     file_name: &str,
 ) -> AbsPathBuf {
-    match config.remap_prefix.iter().find_map(|(from, to)| {
-        file_name
-            .strip_prefix(from)
-            .map(|file_name| (to, file_name))
-    }) {
+    match config
+        .remap_prefix
+        .iter()
+        .find_map(|(from, to)| file_name.strip_prefix(from).map(|file_name| (to, file_name))) {
         Some((to, file_name)) => workspace_root.join(format!("{to}{file_name}")),
         None => workspace_root.join(file_name),
     }
             ) {
                 edit_map.entry(location.uri).or_default().push(edit);
             }
-            is_preferred &= matches!(
-                span.suggestion_applicability,
-                Some(Applicability::MachineApplicable)
-            );
+            is_preferred &=
+                matches!(span.suggestion_applicability, Some(Applicability::MachineApplicable));
         }
     }
 
     let mut message = rd.message.clone();
     if !suggested_replacements.is_empty() {
         message.push_str(": ");
-        let suggestions = suggested_replacements
-            .iter()
-            .map(|suggestion| format!("`{suggestion}`"))
-            .join(", ");
+        let suggestions =
+            suggested_replacements.iter().map(|suggestion| format!("`{suggestion}`")).join(", ");
         message.push_str(&suggestions);
     }
 
     for secondary_span in secondary_spans {
         let related = diagnostic_related_information(config, workspace_root, secondary_span, snap);
         if let Some(related) = related {
-            subdiagnostics.push(SubDiagnostic {
-                related,
-                suggested_fix: None,
-            });
+            subdiagnostics.push(SubDiagnostic { related, suggested_fix: None });
         }
     }
 
         // where the error originated
         // Also, we would generate an additional diagnostic, so that exact place of macro
         // will be highlighted in the error origin place.
-        let span_stack = std::iter::successors(Some(&primary_span), |span| {
-            Some(&span.expansion.as_ref()?.span)
-        })
-        .skip(1);
+        let span_stack =
+            std::iter::successors(Some(&primary_span), |span| Some(&span.expansion.as_ref()?.span))
+                .skip(1);
         for (i, span) in span_stack.enumerate() {
             if is_dummy_macro_file(&span.file_name) {
                 continue;
                 range: secondary_location.range,
                 // downgrade to hint if we're pointing at the macro
                 severity: Some(lsp_types::DiagnosticSeverity::HINT),
-                code: code
-                    .map(ToOwned::to_owned)
-                    .map(lsp_types::NumberOrString::String),
+                code: code.map(ToOwned::to_owned).map(lsp_types::NumberOrString::String),
                 code_description: code_description.clone(),
                 source: Some(source.to_owned()),
                 message: message.clone(),
             diagnostic: lsp_types::Diagnostic {
                 range: primary_location.range,
                 severity,
-                code: code
-                    .map(ToOwned::to_owned)
-                    .map(lsp_types::NumberOrString::String),
+                code: code.map(ToOwned::to_owned).map(lsp_types::NumberOrString::String),
                 code_description: code_description.clone(),
                 source: Some(source.to_owned()),
                 message,
                 diagnostic: lsp_types::Diagnostic {
                     range: sub.related.location.range,
                     severity: Some(lsp_types::DiagnosticSeverity::HINT),
-                    code: code
-                        .map(ToOwned::to_owned)
-                        .map(lsp_types::NumberOrString::String),
+                    code: code.map(ToOwned::to_owned).map(lsp_types::NumberOrString::String),
                     code_description: code_description.clone(),
                     source: Some(source.to_owned()),
                     message: sub.related.message.clone(),
             && chars.next().is_none()
     })
     .and_then(|code| {
-        lsp_types::Url::parse(&format!(
-            "https://doc.rust-lang.org/error-index.html#{code}"
-        ))
-        .ok()
-        .map(|href| lsp_types::CodeDescription { href })
+        lsp_types::Url::parse(&format!("https://doc.rust-lang.org/error-index.html#{code}"))
+            .ok()
+            .map(|href| lsp_types::CodeDescription { href })
     })
 }
 
 #[cfg(not(windows))]
 mod tests {
     use crate::{config::Config, global_state::GlobalState};
-
     use super::*;
-
     use expect_test::{ExpectFile, expect_file};
     use lsp_types::ClientCapabilities;
     use paths::Utf8Path;
-
     fn check(diagnostics_json: &str, expect: ExpectFile) {
         check_with_config(DiagnosticsMapConfig::default(), diagnostics_json, expect)
     }
-
-    fn check_with_config(config: DiagnosticsMapConfig, diagnostics_json: &str, expect: ExpectFile) {
+    fn check_with_config(
+        config: DiagnosticsMapConfig,
+        diagnostics_json: &str,
+        expect: ExpectFile,
+    ) {
         let diagnostic: crate::flycheck::Diagnostic =
             serde_json::from_str(diagnostics_json).unwrap();
         let workspace_root: &AbsPath = Utf8Path::new("/test/").try_into().unwrap();
         );
         let snap = state.snapshot();
         let mut actual = map_rust_diagnostic_to_lsp(&config, diagnostic, workspace_root, &snap);
-        actual
-            .iter_mut()
-            .for_each(|diag| diag.diagnostic.data = None);
+        actual.iter_mut().for_each(|diag| diag.diagnostic.data = None);
         expect.assert_debug_eq(&actual)
     }
-
     #[test]
     fn rustc_incompatible_type_for_trait() {
         check(
             expect_file!["./test_data/rustc_incompatible_type_for_trait.txt"],
         );
     }
-
     #[test]
     fn rustc_unused_variable() {
         check(
             expect_file!["./test_data/rustc_unused_variable.txt"],
         );
     }
-
     #[test]
     #[cfg(not(windows))]
     fn rustc_unused_variable_as_info() {
             expect_file!["./test_data/rustc_unused_variable_as_info.txt"],
         );
     }
-
     #[test]
     #[cfg(not(windows))]
     fn rustc_unused_variable_as_hint() {
             expect_file!["./test_data/rustc_unused_variable_as_hint.txt"],
         );
     }
-
     #[test]
     fn rustc_wrong_number_of_parameters() {
         check(
             expect_file!["./test_data/rustc_wrong_number_of_parameters.txt"],
         );
     }
-
     #[test]
     fn clippy_pass_by_ref() {
         check(
             expect_file!["./test_data/clippy_pass_by_ref.txt"],
         );
     }
-
     #[test]
     fn rustc_range_map_lsp_position() {
         check(
             expect_file!("./test_data/rustc_range_map_lsp_position.txt"),
         )
     }
-
     #[test]
     fn rustc_mismatched_type() {
         check(
             expect_file!["./test_data/rustc_mismatched_type.txt"],
         );
     }
-
     #[test]
     fn handles_macro_location() {
         check(
             expect_file!["./test_data/handles_macro_location.txt"],
         );
     }
-
     #[test]
     fn macro_compiler_error() {
         check(
             expect_file!["./test_data/macro_compiler_error.txt"],
         );
     }
-
     #[test]
     fn snap_multi_line_fix() {
         check(
             expect_file!["./test_data/snap_multi_line_fix.txt"],
         );
     }
-
     #[test]
     fn reasonable_line_numbers_from_empty_file() {
         check(