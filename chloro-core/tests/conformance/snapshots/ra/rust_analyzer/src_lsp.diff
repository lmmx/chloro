COMPARISON DIFF
============================================================

Original size: 5113 bytes
Chloro size:   5121 bytes
Rustfmt size:  5253 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 pub mod ext;
 
 pub(crate) mod capabilities;
+
 pub(crate) mod from_proto;
+
 pub(crate) mod semantic_tokens;
+
 pub(crate) mod to_proto;
+
 pub(crate) mod utils;
 
 #[derive(Debug)]
 
 impl fmt::Display for LspError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(
-            f,
-            "Language Server request failed with {}. ({})",
-            self.code, self.message
-        )
+        write!(f, "Language Server request failed with {}. ({})", self.code, self.message)
     }
 }
 
-impl std::error::Error for LspError {}
+impl std::error::Error for LspError {
+}
 
 pub(crate) fn completion_item_hash(item: &CompletionItem, is_ref_completion: bool) -> [u8; 20] {
     fn hash_completion_relevance(hasher: &mut TentHash, relevance: &CompletionRelevance) {
 
         hasher.update([u8::from(relevance.trait_.is_some())]);
         if let Some(trait_) = &relevance.trait_ {
-            hasher.update([
-                u8::from(trait_.is_op_method),
-                u8::from(trait_.notable_trait),
-            ]);
+            hasher.update([u8::from(trait_.is_op_method), u8::from(trait_.notable_trait)]);
         }
 
         match relevance.postfix_match {
 
         hasher.update([u8::from(relevance.function.is_some())]);
         if let Some(function) = &relevance.function {
-            hasher.update([
-                u8::from(function.has_params),
-                u8::from(function.has_self_param),
-            ]);
+            hasher.update([u8::from(function.has_params), u8::from(function.has_self_param)]);
             let discriminant: u8 = match function.return_type {
                 CompletionRelevanceReturnType::Other => 0,
                 CompletionRelevanceReturnType::DirectConstructor => 1,
     }
 
     // NB: do not hash edits or source range, as those may change between the time the client sends the resolve request
-    // and the time it receives it: some editors do allow changing the buffer between that, leading to ranges being different.
-    //
-    // Documentation hashing is skipped too, as it's a large blob to process,
-    // while not really making completion properties more unique as they are already.
 
+    // and the time it receives it: some editors do allow changing the buffer between that, leading to ranges being different.
+
+    //
+
+    // Documentation hashing is skipped too, as it's a large blob to process,
+
+    // while not really making completion properties more unique as they are already.
     let kind_tag = item.kind.tag();
     hasher.update(kind_tag.len().to_ne_bytes());
     hasher.update(kind_tag);