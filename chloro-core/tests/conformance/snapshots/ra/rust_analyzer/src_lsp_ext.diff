COMPARISON DIFF
============================================================

Original size: 24042 bytes
Chloro size:   23578 bytes
Rustfmt size:  24042 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! rust-analyzer extensions to the LSP.
 
-// Note when adding new resolve payloads, add a #[serde(default)] on boolean fields as some clients
-// might strip `false` values from the JSON payload due to their reserialization logic turning false
-// into null which will then cause them to be omitted in the resolve request. See https://github.com/rust-lang/rust-analyzer/issues/18767
-
-#![allow(clippy::disallowed_types)]
-
 use std::ops;
 
-use lsp_types::request::Request;
 use lsp_types::Url;
+use lsp_types::request::Request;
 use lsp_types::{
-    notification::Notification, CodeActionKind, DocumentOnTypeFormattingParams,
-    PartialResultParams, Position, Range, TextDocumentIdentifier, WorkDoneProgressParams,
+    CodeActionKind, DocumentOnTypeFormattingParams, PartialResultParams, Position, Range,
+    TextDocumentIdentifier, WorkDoneProgressParams, notification::Notification,
 };
 use paths::Utf8PathBuf;
 use rustc_hash::FxHashMap;
 use serde::{Deserialize, Serialize};
 
-pub enum InternalTestingFetchConfig {}
+#![allow(clippy::disallowed_types)]
+pub enum InternalTestingFetchConfig {
+}
 
 #[derive(Deserialize, Serialize, Debug)]
 pub enum InternalTestingFetchConfigOption {
 
 impl Request for InternalTestingFetchConfig {
     type Params = InternalTestingFetchConfigParams;
-    // Option is solely to circumvent Default bound.
+
     type Result = Option<InternalTestingFetchConfigResponse>;
+
     const METHOD: &'static str = "rust-analyzer-internal/internalTestingFetchConfig";
 }
 
     pub text_document: Option<TextDocumentIdentifier>,
     pub config: InternalTestingFetchConfigOption,
 }
-pub enum AnalyzerStatus {}
+
+pub enum AnalyzerStatus {
+}
 
 impl Request for AnalyzerStatus {
     type Params = AnalyzerStatusParams;
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/analyzerStatus";
 }
 
     pub version: Option<String>,
     pub path: Url,
 }
-pub enum FetchDependencyList {}
+
+pub enum FetchDependencyList {
+}
 
 impl Request for FetchDependencyList {
     type Params = FetchDependencyListParams;
+
     type Result = FetchDependencyListResult;
+
     const METHOD: &'static str = "rust-analyzer/fetchDependencyList";
 }
 
 #[derive(Deserialize, Serialize, Debug)]
 #[serde(rename_all = "camelCase")]
-pub struct FetchDependencyListParams {}
+pub struct FetchDependencyListParams {
+}
 
 #[derive(Deserialize, Serialize, Debug, Default)]
 #[serde(rename_all = "camelCase")]
     pub crates: Vec<CrateInfoResult>,
 }
 
-pub enum MemoryUsage {}
+pub enum MemoryUsage {
+}
 
 impl Request for MemoryUsage {
     type Params = ();
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/memoryUsage";
 }
 
-pub enum ReloadWorkspace {}
+pub enum ReloadWorkspace {
+}
 
 impl Request for ReloadWorkspace {
     type Params = ();
+
     type Result = ();
+
     const METHOD: &'static str = "rust-analyzer/reloadWorkspace";
 }
 
-pub enum RebuildProcMacros {}
+pub enum RebuildProcMacros {
+}
 
 impl Request for RebuildProcMacros {
     type Params = ();
+
     type Result = ();
+
     const METHOD: &'static str = "rust-analyzer/rebuildProcMacros";
 }
 
-pub enum ViewSyntaxTree {}
+pub enum ViewSyntaxTree {
+}
 
 impl Request for ViewSyntaxTree {
     type Params = ViewSyntaxTreeParams;
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/viewSyntaxTree";
 }
 
     pub text_document: TextDocumentIdentifier,
 }
 
-pub enum ViewHir {}
+pub enum ViewHir {
+}
 
 impl Request for ViewHir {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/viewHir";
 }
 
-pub enum ViewMir {}
+pub enum ViewMir {
+}
 
 impl Request for ViewMir {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/viewMir";
 }
 
-pub enum InterpretFunction {}
+pub enum InterpretFunction {
+}
 
 impl Request for InterpretFunction {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/interpretFunction";
 }
 
-pub enum ViewFileText {}
+pub enum ViewFileText {
+}
 
 impl Request for ViewFileText {
     type Params = lsp_types::TextDocumentIdentifier;
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/viewFileText";
 }
 
     pub full: bool,
 }
 
-pub enum ViewCrateGraph {}
+pub enum ViewCrateGraph {
+}
 
 impl Request for ViewCrateGraph {
     type Params = ViewCrateGraphParams;
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/viewCrateGraph";
 }
 
     pub text_document: TextDocumentIdentifier,
 }
 
-pub enum ViewItemTree {}
+pub enum ViewItemTree {
+}
 
 impl Request for ViewItemTree {
     type Params = ViewItemTreeParams;
+
     type Result = String;
+
     const METHOD: &'static str = "rust-analyzer/viewItemTree";
 }
 
     pub scope_file: Option<Vec<TextDocumentIdentifier>>,
 }
 
-pub enum DiscoverTest {}
+pub enum DiscoverTest {
+}
 
 impl Request for DiscoverTest {
     type Params = DiscoverTestParams;
+
     type Result = DiscoverTestResults;
+
     const METHOD: &'static str = "experimental/discoverTest";
 }
 
-pub enum DiscoveredTests {}
+pub enum DiscoveredTests {
+}
 
 impl Notification for DiscoveredTests {
     type Params = DiscoverTestResults;
+
     const METHOD: &'static str = "experimental/discoveredTests";
 }
 
     pub exclude: Option<Vec<String>>,
 }
 
-pub enum RunTest {}
+pub enum RunTest {
+}
 
 impl Request for RunTest {
     type Params = RunTestParams;
+
     type Result = ();
+
     const METHOD: &'static str = "experimental/runTest";
 }
 
-pub enum EndRunTest {}
+pub enum EndRunTest {
+}
 
 impl Notification for EndRunTest {
     type Params = ();
+
     const METHOD: &'static str = "experimental/endRunTest";
 }
 
-pub enum AppendOutputToRunTest {}
+pub enum AppendOutputToRunTest {
+}
 
 impl Notification for AppendOutputToRunTest {
     type Params = String;
+
     const METHOD: &'static str = "experimental/appendOutputToRunTest";
 }
 
-pub enum AbortRunTest {}
+pub enum AbortRunTest {
+}
 
 impl Notification for AbortRunTest {
     type Params = ();
+
     const METHOD: &'static str = "experimental/abortRunTest";
 }
 
 #[serde(rename_all = "camelCase", tag = "tag")]
 pub enum TestState {
     Passed,
-    Failed { message: String },
+    Failed {
+        message: String,
+    },
     Skipped,
     Started,
     Enqueued,
     pub state: TestState,
 }
 
-pub enum ChangeTestState {}
+pub enum ChangeTestState {
+}
 
 impl Notification for ChangeTestState {
     type Params = ChangeTestStateParams;
+
     const METHOD: &'static str = "experimental/changeTestState";
 }
 
-pub enum ExpandMacro {}
+pub enum ExpandMacro {
+}
 
 impl Request for ExpandMacro {
     type Params = ExpandMacroParams;
+
     type Result = Option<ExpandedMacro>;
+
     const METHOD: &'static str = "rust-analyzer/expandMacro";
 }
 
     pub expansion: String,
 }
 
-pub enum ViewRecursiveMemoryLayout {}
+pub enum ViewRecursiveMemoryLayout {
+}
 
 impl Request for ViewRecursiveMemoryLayout {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = Option<RecursiveMemoryLayout>;
+
     const METHOD: &'static str = "rust-analyzer/viewRecursiveMemoryLayout";
 }
 
     pub children_len: u64,
 }
 
-pub enum CancelFlycheck {}
+pub enum CancelFlycheck {
+}
 
 impl Notification for CancelFlycheck {
     type Params = ();
+
     const METHOD: &'static str = "rust-analyzer/cancelFlycheck";
 }
 
-pub enum RunFlycheck {}
+pub enum RunFlycheck {
+}
 
 impl Notification for RunFlycheck {
     type Params = RunFlycheckParams;
+
     const METHOD: &'static str = "rust-analyzer/runFlycheck";
 }
 
-pub enum ClearFlycheck {}
+pub enum ClearFlycheck {
+}
 
 impl Notification for ClearFlycheck {
     type Params = ();
+
     const METHOD: &'static str = "rust-analyzer/clearFlycheck";
 }
 
-pub enum OpenServerLogs {}
+pub enum OpenServerLogs {
+}
 
 impl Notification for OpenServerLogs {
     type Params = ();
+
     const METHOD: &'static str = "rust-analyzer/openServerLogs";
 }
 
     pub text_document: Option<TextDocumentIdentifier>,
 }
 
-pub enum MatchingBrace {}
+pub enum MatchingBrace {
+}
 
 impl Request for MatchingBrace {
     type Params = MatchingBraceParams;
+
     type Result = Vec<Position>;
+
     const METHOD: &'static str = "experimental/matchingBrace";
 }
 
     pub positions: Vec<Position>,
 }
 
-pub enum ParentModule {}
+pub enum ParentModule {
+}
 
 impl Request for ParentModule {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = Option<lsp_types::GotoDefinitionResponse>;
+
     const METHOD: &'static str = "experimental/parentModule";
 }
 
-pub enum ChildModules {}
+pub enum ChildModules {
+}
 
 impl Request for ChildModules {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = Option<lsp_types::GotoDefinitionResponse>;
+
     const METHOD: &'static str = "experimental/childModules";
 }
 
-pub enum JoinLines {}
+pub enum JoinLines {
+}
 
 impl Request for JoinLines {
     type Params = JoinLinesParams;
+
     type Result = Vec<lsp_types::TextEdit>;
+
     const METHOD: &'static str = "experimental/joinLines";
 }
 
     pub ranges: Vec<Range>,
 }
 
-pub enum OnEnter {}
+pub enum OnEnter {
+}
 
 impl Request for OnEnter {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = Option<Vec<SnippetTextEdit>>;
+
     const METHOD: &'static str = "experimental/onEnter";
 }
 
-pub enum Runnables {}
+pub enum Runnables {
+}
 
 impl Request for Runnables {
     type Params = RunnablesParams;
+
     type Result = Vec<Runnable>;
+
     const METHOD: &'static str = "experimental/runnables";
 }
 
     pub override_cargo: Option<String>,
     #[serde(skip_serializing_if = "Option::is_none")]
     pub workspace_root: Option<Utf8PathBuf>,
-    // command, --package and --lib stuff
     pub cargo_args: Vec<String>,
-    // stuff after --
     pub executable_args: Vec<String>,
 }
 
     pub args: Vec<String>,
 }
 
-pub enum RelatedTests {}
+pub enum RelatedTests {
+}
 
 impl Request for RelatedTests {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = Vec<TestInfo>;
+
     const METHOD: &'static str = "rust-analyzer/relatedTests";
 }
 
     pub runnable: Runnable,
 }
 
-pub enum Ssr {}
+pub enum Ssr {
+}
 
 impl Request for Ssr {
     type Params = SsrParams;
+
     type Result = lsp_types::WorkspaceEdit;
+
     const METHOD: &'static str = "experimental/ssr";
 }
 
 pub struct SsrParams {
     pub query: String,
     pub parse_only: bool,
-
     /// File position where SSR was invoked. Paths in `query` will be resolved relative to this
     /// position.
     #[serde(flatten)]
     pub position: lsp_types::TextDocumentPositionParams,
-
     /// Current selections. Search/replace will be restricted to these if non-empty.
     pub selections: Vec<lsp_types::Range>,
 }
 
-pub enum ServerStatusNotification {}
+pub enum ServerStatusNotification {
+}
 
 impl Notification for ServerStatusNotification {
     type Params = ServerStatusParams;
+
     const METHOD: &'static str = "experimental/serverStatus";
 }
 
 }
 
 impl ops::BitOrAssign for Health {
-    fn bitor_assign(&mut self, rhs: Self) {
+    fn bitor_assign(
+        &mut self,
+        rhs: Self,
+    ) {
         *self = match (*self, rhs) {
             (Health::Error, _) | (_, Health::Error) => Health::Error,
             (Health::Warning, _) | (_, Health::Warning) => Health::Warning,
     }
 }
 
-pub enum CodeActionRequest {}
+pub enum CodeActionRequest {
+}
 
 impl Request for CodeActionRequest {
     type Params = lsp_types::CodeActionParams;
+
     type Result = Option<Vec<CodeAction>>;
+
     const METHOD: &'static str = "textDocument/codeAction";
 }
 
-pub enum CodeActionResolveRequest {}
+pub enum CodeActionResolveRequest {
+}
 
 impl Request for CodeActionResolveRequest {
     type Params = CodeAction;
+
     type Result = CodeAction;
+
     const METHOD: &'static str = "codeAction/resolve";
 }
 
     pub edit: Option<SnippetWorkspaceEdit>,
     #[serde(skip_serializing_if = "Option::is_none")]
     pub is_preferred: Option<bool>,
-
     #[serde(skip_serializing_if = "Option::is_none")]
     pub data: Option<CodeActionData>,
 }
     pub annotation_id: Option<lsp_types::ChangeAnnotationIdentifier>,
 }
 
-pub enum HoverRequest {}
+pub enum HoverRequest {
+}
 
 impl Request for HoverRequest {
     type Params = HoverParams;
+
     type Result = Option<Hover>;
+
     const METHOD: &'static str = lsp_types::request::HoverRequest::METHOD;
 }
 
 pub struct HoverParams {
     pub text_document: TextDocumentIdentifier,
     pub position: PositionOrRange,
-
     #[serde(flatten)]
     pub work_done_progress_params: WorkDoneProgressParams,
 }
     pub commands: Vec<CommandLink>,
 }
 
-// LSP v3.15 Command does not have a `tooltip` field, vscode supports one.
 #[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
 pub struct CommandLink {
     #[serde(flatten)]
     pub tooltip: Option<String>,
 }
 
-pub enum ExternalDocs {}
+pub enum ExternalDocs {
+}
 
 impl Request for ExternalDocs {
     type Params = lsp_types::TextDocumentPositionParams;
+
     type Result = ExternalDocsResponse;
+
     const METHOD: &'static str = "experimental/externalDocs";
 }
 
     pub local: Option<lsp_types::Url>,
 }
 
-pub enum OpenCargoToml {}
+pub enum OpenCargoToml {
+}
 
 impl Request for OpenCargoToml {
     type Params = OpenCargoTomlParams;
+
     type Result = Option<lsp_types::GotoDefinitionResponse>;
+
     const METHOD: &'static str = "experimental/openCargoToml";
 }
 
     References(lsp_types::TextDocumentPositionParams),
 }
 
-pub enum MoveItem {}
+pub enum MoveItem {
+}
 
 impl Request for MoveItem {
     type Params = MoveItemParams;
+
     type Result = Vec<SnippetTextEdit>;
+
     const METHOD: &'static str = "experimental/moveItem";
 }
 
 }
 
 #[derive(Debug)]
-pub enum WorkspaceSymbol {}
+pub enum WorkspaceSymbol {
+}
 
 impl Request for WorkspaceSymbol {
     type Params = WorkspaceSymbolParams;
+
     type Result = Option<lsp_types::WorkspaceSymbolResponse>;
+
     const METHOD: &'static str = "workspace/symbol";
 }
 
 pub struct WorkspaceSymbolParams {
     #[serde(flatten)]
     pub partial_result_params: PartialResultParams,
-
     #[serde(flatten)]
     pub work_done_progress_params: WorkDoneProgressParams,
-
     /// A non-empty query string
     pub query: String,
-
     pub search_scope: Option<WorkspaceSymbolSearchScope>,
-
     pub search_kind: Option<WorkspaceSymbolSearchKind>,
 }
 
 /// almost same as lsp_types::request::OnTypeFormatting, but the
 /// result has SnippetTextEdit in it instead of TextEdit.
 #[derive(Debug)]
-pub enum OnTypeFormatting {}
+pub enum OnTypeFormatting {
+}
 
 impl Request for OnTypeFormatting {
     type Params = DocumentOnTypeFormattingParams;
+
     type Result = Option<Vec<SnippetTextEdit>>;
+
     const METHOD: &'static str = "textDocument/onTypeFormatting";
 }
 
 #[derive(Debug, Serialize, Deserialize)]
 pub struct InlayHintResolveData {
     pub file_id: u32,
-    // This is a string instead of a u64 as javascript can't represent u64 fully
     pub hash: String,
     pub resolve_range: lsp_types::Range,
     #[serde(skip_serializing_if = "Option::is_none", default)]