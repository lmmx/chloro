COMPARISON DIFF
============================================================

Original size: 20684 bytes
Chloro size:   20892 bytes
Rustfmt size:  21158 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     time::Duration,
 };
 
-use crossbeam_channel::{after, select, Receiver};
+use crossbeam_channel::{Receiver, after, select};
 use itertools::Itertools;
 use lsp_server::{Connection, Message, Notification, Request};
-use lsp_types::{notification::Exit, request::Shutdown, TextDocumentIdentifier, Url};
+use lsp_types::{TextDocumentIdentifier, Url, notification::Exit, request::Shutdown};
 use parking_lot::{Mutex, MutexGuard};
 use paths::{Utf8Path, Utf8PathBuf};
 use rust_analyzer::{
-    cli::flags,
-    config::{Config, ConfigChange, ConfigErrors},
-    lsp, main_loop,
+    cli::flags, config::{Config, ConfigChange, ConfigErrors}, lsp, main_loop,
 };
 use serde::Serialize;
-use serde_json::{json, to_string_pretty, Value};
+use serde_json::{Value, json, to_string_pretty};
 use test_utils::FixtureWithProjectMeta;
 use tracing_subscriber::fmt::TestWriter;
 use vfs::AbsPathBuf;
         }
     }
 
-    pub(crate) fn tmp_dir(mut self, tmp_dir: TestDir) -> Self {
+    pub(crate) fn tmp_dir(
+        mut self,
+        tmp_dir: TestDir,
+    ) -> Self {
         self.tmp_dir = Some(tmp_dir);
         self
     }
 
-    pub(crate) fn root(mut self, path: &str) -> Self {
+    pub(crate) fn root(
+        mut self,
+        path: &str,
+    ) -> Self {
         self.roots.push(path.into());
         self
     }
         self
     }
 
-    pub(crate) fn with_config(mut self, config: serde_json::Value) -> Self {
+    pub(crate) fn with_config(
+        mut self,
+        config: serde_json::Value,
+    ) -> Self {
         fn merge(dst: &mut serde_json::Value, src: serde_json::Value) {
             match (dst, src) {
                 (Value::Object(dst), Value::Object(src)) => {
 
     pub(crate) fn run_lsif(self) -> String {
         let tmp_dir = self.tmp_dir.unwrap_or_else(|| {
-            if self.root_dir_contains_symlink {
-                TestDir::new_symlink()
-            } else {
-                TestDir::new()
-            }
+            if self.root_dir_contains_symlink { TestDir::new_symlink() } else { TestDir::new() }
         });
-
         let FixtureWithProjectMeta {
             fixture,
             mini_core,
         assert!(proc_macro_names.is_empty());
         assert!(mini_core.is_none());
         assert!(toolchain.is_none());
-
         for entry in fixture {
             let path = tmp_dir.path().join(&entry.path['/'.len_utf8()..]);
             fs::create_dir_all(path.parent().unwrap()).unwrap();
             fs::write(path.as_path(), entry.text.as_bytes()).unwrap();
         }
-
         let tmp_dir_path = AbsPathBuf::assert(tmp_dir.path().to_path_buf());
         let mut buf = Vec::new();
         flags::Lsif::run(
             flags::Lsif {
-                path: tmp_dir_path
-                    .join(self.roots.iter().exactly_one().unwrap())
-                    .into(),
+                path: tmp_dir_path.join(self.roots.iter().exactly_one().unwrap()).into(),
                 exclude_vendored_libraries: false,
             },
             &mut buf,
     /// if there is a path to config dir in the test fixture. However, in certain cases we create a
     /// file in the config dir after server is run, something where our naive approach comes short.
     /// Using a `prelock` allows us to force a lock when we know we need it.
-    pub(crate) fn server_with_lock(self, config_lock: bool) -> Server {
+    pub(crate) fn server_with_lock(
+        self,
+        config_lock: bool,
+    ) -> Server {
         static CONFIG_DIR_LOCK: Mutex<()> = Mutex::new(());
-
         let config_dir_guard = if config_lock {
             Some({
                 let guard = CONFIG_DIR_LOCK.lock();
         } else {
             None
         };
-
         let tmp_dir = self.tmp_dir.unwrap_or_else(|| {
-            if self.root_dir_contains_symlink {
-                TestDir::new_symlink()
-            } else {
-                TestDir::new()
-            }
+            if self.root_dir_contains_symlink { TestDir::new_symlink() } else { TestDir::new() }
         });
-
         static INIT: Once = Once::new();
         INIT.call_once(|| {
             let _ = rust_analyzer::tracing::Config {
                 writer: TestWriter::default(),
                 // Deliberately enable all `error` logs if the user has not set RA_LOG, as there is usually
                 // useful information in there for debugging.
-                filter: std::env::var("RA_LOG")
-                    .ok()
-                    .unwrap_or_else(|| "error".to_owned()),
+                filter: std::env::var("RA_LOG").ok().unwrap_or_else(|| "error".to_owned()),
                 chalk_filter: std::env::var("CHALK_DEBUG").ok(),
                 profile_filter: std::env::var("RA_PROFILE").ok(),
                 json_profile_filter: std::env::var("RA_PROFILE_JSON").ok(),
             };
         });
-
         let FixtureWithProjectMeta {
             fixture,
             mini_core,
         assert!(proc_macro_names.is_empty());
         assert!(mini_core.is_none());
         assert!(toolchain.is_none());
-
         for entry in fixture {
             if let Some(pth) = entry.path.strip_prefix("/$$CONFIG_DIR$$") {
-                let path = Config::user_config_dir_path()
-                    .unwrap()
-                    .join(&pth['/'.len_utf8()..]);
+                let path = Config::user_config_dir_path().unwrap().join(&pth['/'.len_utf8()..]);
                 fs::create_dir_all(path.parent().unwrap()).unwrap();
                 fs::write(path.as_path(), entry.text.as_bytes()).unwrap();
             } else {
                 fs::write(path.as_path(), entry.text.as_bytes()).unwrap();
             }
         }
-
         let tmp_dir_path = AbsPathBuf::assert(tmp_dir.path().to_path_buf());
-        let mut roots = self
-            .roots
-            .into_iter()
-            .map(|root| tmp_dir_path.join(root))
-            .collect::<Vec<_>>();
+        let mut roots =
+            self.roots.into_iter().map(|root| tmp_dir_path.join(root)).collect::<Vec<_>>();
         if roots.is_empty() {
             roots.push(tmp_dir_path.clone());
         }
-
         let mut config = Config::new(
             tmp_dir_path,
             lsp_types::ClientCapabilities {
             None,
         );
         let mut change = ConfigChange::default();
-
         change.change_client_config(self.config);
-
         let error_sink: ConfigErrors;
         (config, error_sink, _) = config.apply_change(change);
         assert!(error_sink.is_empty(), "{error_sink:?}");
-
         config.rediscover_workspaces();
-
         Server::new(config_dir_guard, tmp_dir.keep(), config)
     }
 }
         config: Config,
     ) -> Server {
         let (connection, client) = Connection::memory();
-
         let _thread = stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker, "test server")
             .spawn(move || main_loop(config, connection).unwrap())
             .expect("failed to spawn a thread");
-
         Server {
             req_id: Cell::new(1),
             dir,
         }
     }
 
-    pub(crate) fn doc_id(&self, rel_path: &str) -> TextDocumentIdentifier {
+    pub(crate) fn doc_id(
+        &self,
+        rel_path: &str,
+    ) -> TextDocumentIdentifier {
         let path = self.dir.path().join(rel_path);
-        TextDocumentIdentifier {
-            uri: Url::from_file_path(path).unwrap(),
-        }
+        TextDocumentIdentifier { uri: Url::from_file_path(path).unwrap() }
     }
 
-    pub(crate) fn notification<N>(&self, params: N::Params)
+    pub(crate) fn notification<N>(
+        &self,
+        params: N::Params,
+    )
     where
         N: lsp_types::notification::Notification,
-        N::Params: Serialize,
-    {
+        N::Params: Serialize, {
         let r = Notification::new(N::METHOD.to_owned(), params);
         self.send_notification(r)
     }
 
     #[track_caller]
-    pub(crate) fn request<R>(&self, params: R::Params, expected_resp: Value)
+    pub(crate) fn request<R>(
+        &self,
+        params: R::Params,
+        expected_resp: Value,
+    )
     where
         R: lsp_types::request::Request,
-        R::Params: Serialize,
-    {
+        R::Params: Serialize, {
         let actual = self.send_request::<R>(params);
         if let Some((expected_part, actual_part)) = find_mismatch(&expected_resp, &actual) {
             panic!(
     }
 
     #[track_caller]
-    pub(crate) fn send_request<R>(&self, params: R::Params) -> Value
+    pub(crate) fn send_request<R>(
+        &self,
+        params: R::Params,
+    ) -> Value
     where
         R: lsp_types::request::Request,
-        R::Params: Serialize,
-    {
+        R::Params: Serialize, {
         let id = self.req_id.get();
         self.req_id.set(id.wrapping_add(1));
-
         let r = Request::new(id.into(), R::METHOD.to_owned(), params);
         self.send_request_(r)
     }
+
     #[track_caller]
-    fn send_request_(&self, r: Request) -> Value {
+    fn send_request_(
+        &self,
+        r: Request,
+    ) -> Value {
         let id = r.id.clone();
         self.client.sender.send(r.clone().into()).unwrap();
-        while let Some(msg) = self
-            .recv()
-            .unwrap_or_else(|Timeout| panic!("timeout: {r:?}"))
-        {
+        while let Some(msg) = self.recv().unwrap_or_else(|Timeout| panic!("timeout: {r:?}")) {
             match msg {
                 Message::Request(req) => {
                     if req.method == "client/registerCapability" {
         }
         panic!("no response for {r:?}");
     }
+
     pub(crate) fn wait_until_workspace_is_loaded(self) -> Server {
         self.wait_for_message_cond(1, &|msg: &Message| match msg {
             Message::Notification(n) if n.method == "experimental/serverStatus" => {
                     .extract::<lsp::ext::ServerStatusParams>("experimental/serverStatus")
                     .unwrap();
                 if status.health != lsp::ext::Health::Ok {
-                    panic!(
-                        "server errored/warned while loading workspace: {:?}",
-                        status.message
-                    );
+                    panic!("server errored/warned while loading workspace: {:?}", status.message);
                 }
                 status.quiescent
             }
         .unwrap_or_else(|Timeout| panic!("timeout while waiting for ws to load"));
         self
     }
+
     fn wait_for_message_cond(
         &self,
         n: usize,
         }
         Ok(())
     }
+
     fn recv(&self) -> Result<Option<Message>, Timeout> {
         let msg = recv_timeout(&self.client.receiver)?;
         let msg = msg.inspect(|msg| {
         });
         Ok(msg)
     }
-    fn send_notification(&self, not: Notification) {
+
+    fn send_notification(
+        &self,
+        not: Notification,
+    ) {
         self.client.sender.send(Message::Notification(not)).unwrap();
     }
 
         self.dir.path()
     }
 
-    pub(crate) fn write_file_and_save(&self, path: &str, text: String) {
+    pub(crate) fn write_file_and_save(
+        &self,
+        path: &str,
+        text: String,
+    ) {
         fs::write(self.dir.path().join(path), &text).unwrap();
         self.notification::<lsp_types::notification::DidSaveTextDocument>(
             lsp_types::DidSaveTextDocumentParams {
 struct Timeout;
 
 fn recv_timeout(receiver: &Receiver<Message>) -> Result<Option<Message>, Timeout> {
-    let timeout = if cfg!(target_os = "macos") {
-        Duration::from_secs(300)
-    } else {
-        Duration::from_secs(120)
-    };
+    let timeout =
+        if cfg!(target_os = "macos") { Duration::from_secs(300) } else { Duration::from_secs(120) };
     select! {
         recv(receiver) -> msg => Ok(msg.ok()),
         recv(after(timeout)) -> _ => Err(Timeout),
     }
 }
 
-// Comparison functionality borrowed from cargo:
-
 /// Compares JSON object for approximate equality.
 /// You can use `[..]` wildcard in strings (useful for OS dependent things such
 /// as paths). You can use a `"{...}"` string literal as a wildcard for
 /// arbitrary nested JSON. Arrays are sorted before comparison.
-fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a Value, &'a Value)> {
+fn find_mismatch<'a>(
+    expected: &'a Value,
+    actual: &'a Value,
+) -> Option<(&'a Value, &'a Value)> {
     match (expected, actual) {
         (Value::Number(l), Value::Number(r)) if l == r => None,
         (Value::Bool(l), Value::Bool(r)) if l == r => None,
             let mut l = l.iter().collect::<Vec<_>>();
             let mut r = r.iter().collect::<Vec<_>>();
 
-            l.retain(
-                |l| match r.iter().position(|r| find_mismatch(l, r).is_none()) {
-                    Some(i) => {
-                        r.remove(i);
-                        false
-                    }
-                    None => true,
-                },
-            );
+            l.retain(|l| match r.iter().position(|r| find_mismatch(l, r).is_none()) {
+                Some(i) => {
+                    r.remove(i);
+                    false
+                }
+                None => true,
+            });
 
             if !l.is_empty() {
                 assert!(!r.is_empty());
 /// Compare a line with an expected pattern.
 /// - Use `[..]` as a wildcard to match 0 or more characters on the same line
 ///   (similar to `.*` in a regex).
-fn lines_match(expected: &str, actual: &str) -> bool {
+fn lines_match(
+    expected: &str,
+    actual: &str,
+) -> bool {
     // Let's not deal with / vs \ (windows...)
     // First replace backslash-escaped backslashes with forward slashes
     // which can occur in, for example, JSON output
     assert!(lines_match("a[..]", "a b"));
     assert!(lines_match("[..]", "a b"));
     assert!(lines_match("[..]b", "a b"));
-
     assert!(!lines_match("[..]b", "c"));
     assert!(!lines_match("b", "c"));
     assert!(!lines_match("b", "cb"));