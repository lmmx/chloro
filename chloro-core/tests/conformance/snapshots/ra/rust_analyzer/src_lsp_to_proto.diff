COMPARISON DIFF
============================================================

Original size: 111479 bytes
Chloro size:   111375 bytes
Rustfmt size:  113494 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Conversion of rust-analyzer specific types to lsp_types equivalents.
+
 use std::{
     iter::once,
     mem,
     sync::atomic::{AtomicU32, Ordering},
 };
 
-use base64::{prelude::BASE64_STANDARD, Engine};
+use base64::{Engine, prelude::BASE64_STANDARD};
 use ide::{
     Annotation, AnnotationKind, Assist, AssistKind, Cancellable, CompletionFieldsToResolve,
     CompletionItem, CompletionItemKind, CompletionRelevance, Documentation, FileId, FileRange,
     UpdateTest,
 };
 use ide_db::{
-    assists, rust_doc::format_docs, source_change::ChangeAnnotationId, FxHasher, MiniCore,
+    assists,
+
+    rust_doc::format_docs,
+
+    source_change::ChangeAnnotationId,
+
+    FxHasher, MiniCore,
 };
 use itertools::Itertools;
 use paths::{Utf8Component, Utf8Prefix};
 use vfs::AbsPath;
 
 use crate::{
-    config::{CallInfoConfig, ClientCommandsConfig, Config},
-    global_state::GlobalStateSnapshot,
+    config::{CallInfoConfig, ClientCommandsConfig, Config}, global_state::GlobalStateSnapshot,
     line_index::{LineEndings, LineIndex, PositionEncoding},
     lsp::{
-        completion_item_hash,
+        LspError, completion_item_hash,
         ext::ShellRunnableArgs,
         semantic_tokens::{self, standard_fallback_type},
         utils::invalid_params_error,
-        LspError,
     },
-    lsp_ext::{self, SnippetTextEdit},
-    target_spec::{CargoTargetSpec, TargetSpec},
+    lsp_ext::{self, SnippetTextEdit}, target_spec::{CargoTargetSpec, TargetSpec},
 };
 
-pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {
+pub(crate) fn position(
+    line_index: &LineIndex,
+    offset: TextSize,
+) -> lsp_types::Position {
     let line_col = line_index.index.line_col(offset);
     match line_index.encoding {
         PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),
     }
 }
 
-pub(crate) fn range(line_index: &LineIndex, range: TextRange) -> lsp_types::Range {
+pub(crate) fn range(
+    line_index: &LineIndex,
+    range: TextRange,
+) -> lsp_types::Range {
     let start = position(line_index, range.start());
     let end = position(line_index, range.end());
     lsp_types::Range::new(start, end)
     }
 }
 
-pub(crate) fn document_highlight_kind(
-    category: ReferenceCategory,
-) -> Option<lsp_types::DocumentHighlightKind> {
+pub(crate) fn document_highlight_kind(category: ReferenceCategory) -> Option<lsp_types::DocumentHighlightKind> {
     if category.contains(ReferenceCategory::WRITE) {
         return Some(lsp_types::DocumentHighlightKind::WRITE);
     }
 
 pub(crate) fn documentation(documentation: Documentation) -> lsp_types::Documentation {
     let value = format_docs(&documentation);
-    let markup_content = lsp_types::MarkupContent {
-        kind: lsp_types::MarkupKind::Markdown,
-        value,
-    };
+    let markup_content = lsp_types::MarkupContent { kind: lsp_types::MarkupKind::Markdown, value };
     lsp_types::Documentation::MarkupContent(markup_content)
 }
 
-pub(crate) fn completion_item_kind(
-    completion_item_kind: CompletionItemKind,
-) -> lsp_types::CompletionItemKind {
+pub(crate) fn completion_item_kind(completion_item_kind: CompletionItemKind) -> lsp_types::CompletionItemKind {
     match completion_item_kind {
         CompletionItemKind::Binding => lsp_types::CompletionItemKind::VARIABLE,
         CompletionItemKind::BuiltinType => lsp_types::CompletionItemKind::STRUCT,
     }
 }
 
-pub(crate) fn text_edit(line_index: &LineIndex, indel: Indel) -> lsp_types::TextEdit {
+pub(crate) fn text_edit(
+    line_index: &LineIndex,
+    indel: Indel,
+) -> lsp_types::TextEdit {
     let range = range(line_index, indel.delete);
     let new_text = match line_index.endings {
         LineEndings::Unix => indel.insert,
     match insert_replace_support {
         Some(cursor_pos) => lsp_types::InsertReplaceEdit {
             new_text: text_edit.new_text,
-            insert: lsp_types::Range {
-                start: text_edit.range.start,
-                end: cursor_pos,
-            },
+            insert: lsp_types::Range { start: text_edit.range.start, end: cursor_pos },
             replace: text_edit.range,
         }
         .into(),
     annotation: Option<ChangeAnnotationId>,
     client_supports_annotations: bool,
 ) -> lsp_ext::SnippetTextEdit {
-    let annotation_id = annotation
-        .filter(|_| client_supports_annotations)
-        .map(|it| it.to_string());
+    let annotation_id = annotation.filter(|_| client_supports_annotations).map(|it| it.to_string());
     let text_edit = text_edit(line_index, indel);
-    let insert_text_format = if is_snippet {
-        Some(lsp_types::InsertTextFormat::SNIPPET)
-    } else {
-        None
-    };
+    let insert_text_format =
+        if is_snippet { Some(lsp_types::InsertTextFormat::SNIPPET) } else { None };
     lsp_ext::SnippetTextEdit {
         range: text_edit.range,
         new_text: text_edit.new_text,
     line_index: &LineIndex,
     text_edit: TextEdit,
 ) -> Vec<lsp_types::TextEdit> {
-    text_edit
-        .into_iter()
-        .map(|indel| self::text_edit(line_index, indel))
-        .collect()
+    text_edit.into_iter().map(|indel| self::text_edit(line_index, indel)).collect()
 }
 
 pub(crate) fn snippet_text_edit_vec(
     if config.completion_hide_deprecated() {
         items.retain(|item| !item.deprecated);
     }
-
-    let max_relevance = items
-        .iter()
-        .map(|it| it.relevance.score())
-        .max()
-        .unwrap_or_default();
+    let max_relevance = items.iter().map(|it| it.relevance.score()).max().unwrap_or_default();
     let mut res = Vec::with_capacity(items.len());
     let client_commands = config.client_commands();
     for item in items {
             item,
         );
     }
-
     if let Some(limit) = config.completion(None, MiniCore::default()).limit {
         res.sort_by(|item1, item2| item1.sort_text.cmp(&item2.sort_text));
         res.truncate(limit);
     }
-
     res
 }
 
 ) {
     let insert_replace_support = config.insert_replace_support().then_some(tdpp.position);
     let ref_match = item.ref_match();
-
     let mut additional_text_edits = Vec::new();
     let mut something_to_resolve = false;
-
     let filter_text = if fields_to_resolve.resolve_filter_text {
         something_to_resolve |= !item.lookup().is_empty();
         None
     } else {
         Some(item.lookup().to_owned())
     };
-
     let text_edit = if fields_to_resolve.resolve_text_edit {
         something_to_resolve |= true;
         None
         }
         Some(text_edit.unwrap())
     };
-
-    let insert_text_format = item
-        .is_snippet
-        .then_some(lsp_types::InsertTextFormat::SNIPPET);
+    let insert_text_format = item.is_snippet.then_some(lsp_types::InsertTextFormat::SNIPPET);
     let tags = if fields_to_resolve.resolve_tags {
         something_to_resolve |= item.deprecated;
         None
     } else {
-        item.deprecated
-            .then(|| vec![lsp_types::CompletionItemTag::DEPRECATED])
+        item.deprecated.then(|| vec![lsp_types::CompletionItemTag::DEPRECATED])
     };
     let command = if item.trigger_call_info && client_commands.trigger_parameter_hints {
         if fields_to_resolve.resolve_command {
     } else {
         None
     };
-
     let detail = if fields_to_resolve.resolve_detail {
         something_to_resolve |= item.detail.is_some();
         None
     } else {
         item.detail.clone()
     };
-
     let documentation = if fields_to_resolve.resolve_documentation {
         something_to_resolve |= item.documentation.is_some();
         None
     } else {
         item.documentation.clone().map(documentation)
     };
-
     let mut lsp_item = lsp_types::CompletionItem {
         label: item.label.primary.to_string(),
         detail,
         insert_text_format,
         ..Default::default()
     };
-
     if config.completion_label_details_support() {
         let has_label_details =
             item.label.detail_left.is_some() || item.label.detail_right.is_some();
     } else if let Some(label_detail) = &item.label.detail_left {
         lsp_item.label.push_str(label_detail.as_str());
     }
-
     set_score(&mut lsp_item, max_relevance, item.relevance);
-
-    let imports = if config
-        .completion(None, MiniCore::default())
-        .enable_imports_on_the_fly
+    let imports = if config.completion(None, MiniCore::default()).enable_imports_on_the_fly
         && !item.import_to_add.is_empty()
     {
         item.import_to_add
             .clone()
             .into_iter()
-            .map(|import_path| lsp_ext::CompletionImport {
-                full_import_path: import_path,
-            })
+            .map(|import_path| lsp_ext::CompletionImport { full_import_path: import_path })
             .collect()
     } else {
         Vec::new()
     } else {
         (None, None)
     };
-
     if let Some((label, indel, relevance)) = ref_match {
-        let mut lsp_item_with_ref = lsp_types::CompletionItem {
-            label,
-            data: ref_resolve_data,
-            ..lsp_item.clone()
-        };
+        let mut lsp_item_with_ref =
+            lsp_types::CompletionItem { label, data: ref_resolve_data, ..lsp_item.clone() };
         lsp_item_with_ref
             .additional_text_edits
             .get_or_insert_with(Default::default)
         set_score(&mut lsp_item_with_ref, max_relevance, relevance);
         acc.push(lsp_item_with_ref);
     };
-
     lsp_item.data = resolve_data;
     acc.push(lsp_item);
-
     fn set_score(
         res: &mut lsp_types::CompletionItem,
         max_relevance: u32,
                     documentation: None,
                 })
                 .collect::<Vec<_>>();
-            let label = if concise {
-                call_info.parameter_labels().join(", ")
-            } else {
-                call_info.signature
-            };
+            let label =
+                if concise { call_info.parameter_labels().join(", ") } else { call_info.signature };
             (label, params)
         }
         (false, true) => {
             (label, params)
         }
     };
-
     let documentation = call_info.doc.filter(|_| config.docs).map(|doc| {
         lsp_types::Documentation::MarkupContent(lsp_types::MarkupContent {
             kind: lsp_types::MarkupKind::Markdown,
             value: format_docs(&doc),
         })
     });
-
     let active_parameter = call_info.active_parameter.map(|it| it as u32);
-
     let signature = lsp_types::SignatureInformation {
         label,
         documentation,
         hint.resolve_parent.filter(|_| {
             hint.text_edit.as_ref().is_some_and(LazyProperty::is_lazy)
                 || hint.label.parts.iter().any(|part| {
-                    part.linked_location
-                        .as_ref()
-                        .is_some_and(LazyProperty::is_lazy)
+                    part.linked_location.as_ref().is_some_and(LazyProperty::is_lazy)
                         || part.tooltip.as_ref().is_some_and(LazyProperty::is_lazy)
                 })
         })
     };
-
     let resolve_range_and_hash = hint_needs_resolve(&inlay_hint).map(|range| {
         (
             range,
             ),
         )
     });
-
     let mut something_to_resolve = false;
     let text_edits = inlay_hint
         .text_edit
         .and_then(|it| match it {
             LazyProperty::Computed(it) => Some(it),
             LazyProperty::Lazy => {
-                something_to_resolve |= snap
-                    .config
-                    .visual_studio_code_version()
-                    .is_none_or(|version| VersionReq::parse(">=1.86.0").unwrap().matches(version))
-                    && resolve_range_and_hash.is_some()
-                    && fields_to_resolve.resolve_text_edits;
+                something_to_resolve |=
+                    snap.config.visual_studio_code_version().is_none_or(|version| {
+                        VersionReq::parse(">=1.86.0").unwrap().matches(version)
+                    }) && resolve_range_and_hash.is_some()
+                        && fields_to_resolve.resolve_text_edits;
                 None
             }
         })
         resolve_range_and_hash.is_some(),
         inlay_hint.label,
     )?;
-
     let data = match resolve_range_and_hash {
         Some((resolve_range, hash)) if something_to_resolve => Some(
             to_value(lsp_ext::InlayHintResolveData {
         ),
         _ => None,
     };
-
     Ok(lsp_types::InlayHint {
         position: match inlay_hint.position {
             ide::InlayHintPosition::Before => position(line_index, inlay_hint.range.start()),
     something_to_resolve: &mut bool,
     needs_resolve: bool,
     mut label: InlayHintLabel,
-) -> Cancellable<(
-    lsp_types::InlayHintLabel,
-    Option<lsp_types::InlayHintTooltip>,
-)> {
+) -> Cancellable<(lsp_types::InlayHintLabel, Option<lsp_types::InlayHintTooltip>)> {
     let (label, tooltip) = match &*label.parts {
-        [InlayHintLabelPart {
-            linked_location: None,
-            ..
-        }] => {
+        [InlayHintLabelPart { linked_location: None, .. }] => {
             let InlayHintLabelPart { text, tooltip, .. } = label.parts.pop().unwrap();
             let tooltip = tooltip.and_then(|it| match it {
                 LazyProperty::Computed(it) => Some(it),
             });
             let hint_tooltip = match tooltip {
                 Some(ide::InlayTooltip::String(s)) => Some(lsp_types::InlayHintTooltip::String(s)),
-                Some(ide::InlayTooltip::Markdown(s)) => Some(
-                    lsp_types::InlayHintTooltip::MarkupContent(lsp_types::MarkupContent {
+                Some(ide::InlayTooltip::Markdown(s)) => {
+                    Some(lsp_types::InlayHintTooltip::MarkupContent(lsp_types::MarkupContent {
                         kind: lsp_types::MarkupKind::Markdown,
                         value: s,
-                    }),
-                ),
+                    }))
+                }
                 None => None,
             };
             (lsp_types::InlayHintLabel::String(text), hint_tooltip)
     semantics_tokens_augments_syntax_tokens: bool,
     non_standard_tokens: bool,
 ) -> lsp_types::SemanticTokens {
-    let id = TOKEN_RESULT_COUNTER
-        .fetch_add(1, Ordering::SeqCst)
-        .to_string();
+    let id = TOKEN_RESULT_COUNTER.fetch_add(1, Ordering::SeqCst).to_string();
     let mut builder = semantic_tokens::SemanticTokensBuilder::new(id);
-
     for highlight_range in highlights {
         if highlight_range.highlight.is_empty() {
             continue;
             builder.push(range, token_index, modifier_bitset);
         }
     }
-
     builder.build()
 }
 
     lsp_types::SemanticTokensDelta { result_id, edits }
 }
 
-fn semantic_token_type_and_modifiers(
-    highlight: Highlight,
-) -> (lsp_types::SemanticTokenType, semantic_tokens::ModifierSet) {
+fn semantic_token_type_and_modifiers(highlight: Highlight) -> (lsp_types::SemanticTokenType, semantic_tokens::ModifierSet) {
     use semantic_tokens::{modifiers as mods, types};
-
     let ty = match highlight.tag {
         HlTag::Symbol(symbol) => match symbol {
             SymbolKind::Attribute => types::DECORATOR,
             HlPunct::MacroBang => types::MACRO_BANG,
         },
     };
-
     let mut mods = semantic_tokens::ModifierSet::default();
     for modifier in highlight.mods.iter() {
         let modifier = match modifier {
         };
         mods |= modifier;
     }
-
     (ty, mods)
 }
 
         | FoldKind::MatchArm
         | FoldKind::Function => None,
     };
-
     let range = range(line_index, fold.range);
-
     if line_folding_only {
         // Clients with line_folding_only == true (such as VSCode) will fold the whole end line
         // even if it contains text not in the folding range. To prevent that we exclude
     }
 }
 
-pub(crate) fn url(snap: &GlobalStateSnapshot, file_id: FileId) -> lsp_types::Url {
+pub(crate) fn url(
+    snap: &GlobalStateSnapshot,
+    file_id: FileId,
+) -> lsp_types::Url {
     snap.file_id_to_url(file_id)
 }
 
     let url = lsp_types::Url::from_file_path(path).unwrap();
     match path.components().next() {
         Some(Utf8Component::Prefix(prefix))
-            if matches!(
-                prefix.kind(),
-                Utf8Prefix::Disk(_) | Utf8Prefix::VerbatimDisk(_)
-            ) =>
+            if matches!(prefix.kind(), Utf8Prefix::Disk(_) | Utf8Prefix::VerbatimDisk(_)) =>
         {
             // Need to lowercase driver letter
         }
         _ => return url,
     }
-
     let driver_letter_range = {
         let (scheme, drive_letter, _rest) = match url.as_str().splitn(3, ':').collect_tuple() {
             Some(it) => it,
         let start = scheme.len() + ':'.len_utf8();
         start..(start + drive_letter.len())
     };
-
     // Note: lowercasing the `path` itself doesn't help, the `Url::parse`
     // machinery *also* canonicalizes the drive letter. So, just massage the
     // string in place.
     target: NavigationTarget,
 ) -> Cancellable<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {
     let line_index = snap.file_line_index(target.file_id)?;
-
     let target_uri = url(snap, target.file_id);
     let target_range = range(&line_index, target.full_range);
-    let target_selection_range = target
-        .focus_range
-        .map(|it| range(&line_index, it))
-        .unwrap_or(target_range);
+    let target_selection_range =
+        target.focus_range.map(|it| range(&line_index, it)).unwrap_or(target_range);
     Ok((target_uri, target_range, target_selection_range))
 }
 
     } else {
         let locations = targets
             .into_iter()
-            .map(|nav| FileRange {
-                file_id: nav.file_id,
-                range: nav.focus_or_full_range(),
-            })
+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })
             .unique()
             .map(|range| location(snap, range))
             .collect::<Cancellable<Vec<_>>>()?;
     let text_edits = edit.into_iter();
     // offset to go from the final source location to the original source location
     let mut source_text_offset = 0i32;
-
     let offset_range = |range: TextRange, offset: i32| -> TextRange {
         // map the snippet range from the target location into the original source location
-        let start = u32::from(range.start())
-            .checked_add_signed(offset)
-            .unwrap_or(0);
-        let end = u32::from(range.end())
-            .checked_add_signed(offset)
-            .unwrap_or(0);
+        let start = u32::from(range.start()).checked_add_signed(offset).unwrap_or(0);
+        let end = u32::from(range.end()).checked_add_signed(offset).unwrap_or(0);
 
         TextRange::new(start.into(), end.into())
     };
-
     for current_indel in text_edits {
         let new_range = {
             let insert_len =
             edits.push(snippet_text_edit(
                 line_index,
                 true,
-                Indel {
-                    insert: format!("${snippet_index}"),
-                    delete: snippet_range,
-                },
+                Indel { insert: format!("${snippet_index}"), delete: snippet_range },
                 annotation,
                 client_supports_annotations,
             ))
         }
 
         if snippets.peek().is_some_and(|(_, range)| {
-            new_range
-                .intersect(offset_range(*range, source_text_offset))
-                .is_some()
+            new_range.intersect(offset_range(*range, source_text_offset)).is_some()
         }) {
             // at least one snippet edit intersects this text edit,
             // so gather all of the edits that intersect this text edit
             let mut all_snippets = snippets
                 .peeking_take_while(|(_, range)| {
-                    new_range
-                        .intersect(offset_range(*range, source_text_offset))
-                        .is_some()
+                    new_range.intersect(offset_range(*range, source_text_offset)).is_some()
                 })
                 .map(|(tabstop, range)| (tabstop, offset_range(range, source_text_offset)))
                 .collect_vec();
             let mut new_text = current_indel.insert;
 
             // find which snippet bits need to be escaped
-            let escape_places = new_text
-                .rmatch_indices(['\\', '$', '}'])
-                .map(|(insert, _)| insert)
-                .collect_vec();
+            let escape_places =
+                new_text.rmatch_indices(['\\', '$', '}']).map(|(insert, _)| insert).collect_vec();
             let mut escape_places = escape_places.into_iter().peekable();
             let mut escape_prior_bits = |new_text: &mut String, up_to: usize| {
                 for before in escape_places.peeking_take_while(|insert| *insert >= up_to) {
             edits.push(snippet_text_edit(
                 line_index,
                 true,
-                Indel {
-                    insert: new_text,
-                    delete: current_indel.delete,
-                },
+                Indel { insert: new_text, delete: current_indel.delete },
                 annotation,
                 client_supports_annotations,
             ))
         // update the final source -> initial source mapping offset
         source_text_offset += offset_adjustment;
     }
-
     // insert any remaining tabstops
     edits.extend(snippets.map(|(snippet_index, snippet_range)| {
         // adjust the snippet range into the corresponding initial source location
         snippet_text_edit(
             line_index,
             true,
-            Indel {
-                insert: format!("${snippet_index}"),
-                delete: snippet_range,
-            },
+            Indel { insert: format!("${snippet_index}"), delete: snippet_range },
             annotation,
             client_supports_annotations,
         )
     }));
-
     edits
 }
 
             })
             .collect()
     };
-
     if snap.analysis.is_library_file(file_id)? && snap.config.change_annotation_support() {
         for edit in &mut edits {
             edit.annotation_id = Some(outside_workspace_annotation_id())
         }
     }
-    Ok(lsp_ext::SnippetTextDocumentEdit {
-        text_document,
-        edits,
-    })
+    Ok(lsp_ext::SnippetTextDocumentEdit { text_document, edits })
 }
 
 pub(crate) fn snippet_text_document_ops(
 ) -> Cancellable<Vec<lsp_ext::SnippetDocumentChangeOperation>> {
     let mut ops = Vec::new();
     match file_system_edit {
-        FileSystemEdit::CreateFile {
-            dst,
-            initial_contents,
-        } => {
+        FileSystemEdit::CreateFile { dst, initial_contents } => {
             let uri = snap.anchored_path(&dst);
             let create_file = lsp_types::ResourceOp::Create(lsp_types::CreateFile {
                 uri: uri.clone(),
                     insert_text_format: Some(lsp_types::InsertTextFormat::PLAIN_TEXT),
                     annotation_id: None,
                 };
-                let edit_file = lsp_ext::SnippetTextDocumentEdit {
-                    text_document,
-                    edits: vec![text_edit],
-                };
+                let edit_file =
+                    lsp_ext::SnippetTextDocumentEdit { text_document, edits: vec![text_edit] };
                 ops.push(lsp_ext::SnippetDocumentChangeOperation::Edit(edit_file));
             }
         }
         FileSystemEdit::MoveFile { src, dst } => {
             let old_uri = snap.file_id_to_url(src);
             let new_uri = snap.anchored_path(&dst);
-            let mut rename_file = lsp_types::RenameFile {
-                old_uri,
-                new_uri,
-                options: None,
-                annotation_id: None,
-            };
+            let mut rename_file =
+                lsp_types::RenameFile { old_uri, new_uri, options: None, annotation_id: None };
             if snap.analysis.is_library_file(src).ok() == Some(true)
                 && snap.config.change_annotation_support()
             {
                 rename_file.annotation_id = Some(outside_workspace_annotation_id())
             }
-            ops.push(lsp_ext::SnippetDocumentChangeOperation::Op(
-                lsp_types::ResourceOp::Rename(rename_file),
-            ))
+            ops.push(lsp_ext::SnippetDocumentChangeOperation::Op(lsp_types::ResourceOp::Rename(
+                rename_file,
+            )))
         }
         FileSystemEdit::MoveDir { src, src_id, dst } => {
             let old_uri = snap.anchored_path(&src);
             let new_uri = snap.anchored_path(&dst);
-            let mut rename_file = lsp_types::RenameFile {
-                old_uri,
-                new_uri,
-                options: None,
-                annotation_id: None,
-            };
+            let mut rename_file =
+                lsp_types::RenameFile { old_uri, new_uri, options: None, annotation_id: None };
             if snap.analysis.is_library_file(src_id).ok() == Some(true)
                 && snap.config.change_annotation_support()
             {
                 rename_file.annotation_id = Some(outside_workspace_annotation_id())
             }
-            ops.push(lsp_ext::SnippetDocumentChangeOperation::Op(
-                lsp_types::ResourceOp::Rename(rename_file),
-            ))
+            ops.push(lsp_ext::SnippetDocumentChangeOperation::Op(lsp_types::ResourceOp::Rename(
+                rename_file,
+            )))
         }
     }
     Ok(ops)
     mut source_change: SourceChange,
 ) -> Cancellable<lsp_ext::SnippetWorkspaceEdit> {
     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();
-
     for op in &mut source_change.file_system_edits {
-        if let FileSystemEdit::CreateFile {
-            dst,
-            initial_contents,
-        } = op
-        {
+        if let FileSystemEdit::CreateFile { dst, initial_contents } = op {
             // replace with a placeholder to avoid cloneing the edit
             let op = FileSystemEdit::CreateFile {
                 dst: dst.clone(),
                     )),
                 },
             ))
-            .chain(
-                source_change
-                    .annotations
-                    .into_iter()
-                    .map(|(id, annotation)| {
-                        (
-                            id.to_string(),
-                            lsp_types::ChangeAnnotation {
-                                label: annotation.label,
-                                description: annotation.description,
-                                needs_confirmation: Some(annotation.needs_confirmation),
-                            },
-                        )
-                    }),
-            )
+            .chain(source_change.annotations.into_iter().map(|(id, annotation)| {
+                (
+                    id.to_string(),
+                    lsp_types::ChangeAnnotation {
+                        label: annotation.label,
+                        description: annotation.description,
+                        needs_confirmation: Some(annotation.needs_confirmation),
+                    },
+                )
+            }))
             .collect(),
         )
     }
     }
 }
 
-impl From<lsp_ext::SnippetTextEdit>
-    for lsp_types::OneOf<lsp_types::TextEdit, lsp_types::AnnotatedTextEdit>
-{
+impl From<lsp_ext::SnippetTextEdit> for lsp_types::OneOf<lsp_types::TextEdit, lsp_types::AnnotatedTextEdit> {
     fn from(
-        lsp_ext::SnippetTextEdit {
-            annotation_id,
-            insert_text_format: _,
-            new_text,
-            range,
-        }: lsp_ext::SnippetTextEdit,
+        lsp_ext::SnippetTextEdit { annotation_id, insert_text_format:_, new_text, range }: lsp_ext::SnippetTextEdit,
     ) -> Self {
         match annotation_id {
             Some(annotation_id) => lsp_types::OneOf::Right(lsp_types::AnnotatedTextEdit {
 ) -> Cancellable<lsp_types::CallHierarchyItem> {
     let name = target.name.to_string();
     let detail = target.description.clone();
-    let kind = target
-        .kind
-        .map(symbol_kind)
-        .unwrap_or(lsp_types::SymbolKind::FUNCTION);
+    let kind = target.kind.map(symbol_kind).unwrap_or(lsp_types::SymbolKind::FUNCTION);
     let (uri, range, selection_range) = location_info(snap, target)?;
     Ok(lsp_types::CallHierarchyItem {
         name,
 ) -> Cancellable<lsp_ext::CodeAction> {
     let mut res = lsp_ext::CodeAction {
         title: assist.label.to_string(),
-        group: assist
-            .group
-            .filter(|_| snap.config.code_action_group())
-            .map(|gr| gr.0),
+        group: assist.group.filter(|_| snap.config.code_action_group()).map(|gr| gr.0),
         kind: Some(code_action_kind(assist.id.1)),
         edit: None,
         is_preferred: None,
         data: None,
         command: None,
     };
-
     res.command = match assist.command {
         Some(assists::Command::TriggerParameterHints) if commands.trigger_parameter_hints => {
             Some(command::trigger_parameter_hints())
         Some(assists::Command::Rename) if commands.rename => Some(command::rename()),
         _ => None,
     };
-
     match (assist.source_change, resolve_data) {
         (Some(it), _) => res.edit = Some(snippet_workspace_edit(snap, it)?),
         (None, Some((index, code_action_params, version))) => {
     let target_spec = TargetSpec::for_file(snap, runnable.nav.file_id)?;
     let source_root = snap.analysis.source_root_id(runnable.nav.file_id).ok();
     let config = snap.config.runnables(source_root);
-
     match target_spec {
         Some(TargetSpec::Cargo(spec)) => {
             let workspace_root = spec.workspace_root.clone();
                     .filter_map(|target| {
                         location(
                             snap,
-                            FileRange {
-                                file_id: target.file_id,
-                                range: target.full_range,
-                            },
+                            FileRange { file_id: target.file_id, range: target.full_range },
                         )
                         .ok()
                     })
             let doc_pos = lsp_types::TextDocumentPositionParams::new(id, pos);
 
             let command = data.map(|ranges| {
-                let locations: Vec<lsp_types::Location> = ranges
-                    .into_iter()
-                    .filter_map(|range| location(snap, range).ok())
-                    .collect();
+                let locations: Vec<lsp_types::Location> =
+                    ranges.into_iter().filter_map(|range| location(snap, range).ok()).collect();
 
                 command::show_references(reference_title(locations.len()), &url, pos, locations)
             });
             .file
             .map(|f| lsp_types::TextDocumentIdentifier { uri: url(snap, f) }),
         range: line_index.and_then(|l| Some(range(l, test_item.text_range?))),
-        runnable: test_item
-            .runnable
-            .and_then(|r| runnable(snap, r).ok())
-            .flatten(),
+        runnable: test_item.runnable.and_then(|r| runnable(snap, r).ok()).flatten(),
     })
 }
 
 pub(crate) mod command {
     use ide::{FileRange, NavigationTarget};
     use serde_json::to_value;
-
     use crate::{
-        global_state::GlobalStateSnapshot,
-        lsp::to_proto::{location, location_link},
-        lsp_ext,
+        global_state::GlobalStateSnapshot, lsp::to_proto::{location, location_link}, lsp_ext,
     };
-
     pub(crate) fn show_references(
         title: String,
         uri: &lsp_types::Url,
         // We cannot use the 'editor.action.showReferences' command directly
         // because that command requires vscode types which we convert in the handler
         // on the client side.
-
         lsp_types::Command {
             title,
             command: "rust-analyzer.showReferences".into(),
             ]),
         }
     }
-
-    pub(crate) fn run_single(runnable: &lsp_ext::Runnable, title: &str) -> lsp_types::Command {
+    pub(crate) fn run_single(
+        runnable: &lsp_ext::Runnable,
+        title: &str,
+    ) -> lsp_types::Command {
         lsp_types::Command {
             title: title.to_owned(),
             command: "rust-analyzer.runSingle".into(),
             arguments: Some(vec![to_value(runnable).unwrap()]),
         }
     }
-
     pub(crate) fn debug_single(runnable: &lsp_ext::Runnable) -> lsp_types::Command {
         lsp_types::Command {
             title: "⚙\u{fe0e} Debug".into(),
             arguments: Some(vec![to_value(runnable).unwrap()]),
         }
     }
-
     pub(crate) fn interpret_single(_runnable: &lsp_ext::Runnable) -> lsp_types::Command {
         lsp_types::Command {
             title: "Interpret".into(),
             arguments: Some(vec![]),
         }
     }
-
     pub(crate) fn goto_location(
         snap: &GlobalStateSnapshot,
         nav: &NavigationTarget,
             let link = location_link(snap, None, nav.clone()).ok()?;
             to_value(link).ok()?
         } else {
-            let range = FileRange {
-                file_id: nav.file_id,
-                range: nav.focus_or_full_range(),
-            };
+            let range = FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() };
             let location = location(snap, range).ok()?;
             to_value(location).ok()?
         };
-
         Some(lsp_types::Command {
             title: nav.name.to_string(),
             command: "rust-analyzer.gotoLocation".into(),
             arguments: Some(vec![value]),
         })
     }
-
     pub(crate) fn trigger_parameter_hints() -> lsp_types::Command {
         lsp_types::Command {
             title: "triggerParameterHints".into(),
             arguments: None,
         }
     }
-
     pub(crate) fn rename() -> lsp_types::Command {
         lsp_types::Command {
             title: "rename".into(),
     update_test: UpdateTest,
 ) -> Option<lsp_ext::Runnable> {
     let label = update_test.label()?;
-
     let mut runnable = runnable.clone();
     runnable.label = format!("{} + {}", runnable.label, label);
-
     let lsp_ext::RunnableArgs::Cargo(r) = &mut runnable.args else {
         return None;
     };
-
-    r.environment.extend(
-        update_test
-            .env()
-            .iter()
-            .map(|(k, v)| (k.to_string(), v.to_string())),
-    );
-
+    r.environment.extend(update_test.env().iter().map(|(k, v)| (k.to_string(), v.to_string())));
     if update_test.insta {
         r.cargo_args.insert(0, "insta".to_owned());
     }
-
     Some(runnable)
 }
 
 pub(crate) fn implementation_title(count: usize) -> String {
-    if count == 1 {
-        "1 implementation".into()
-    } else {
-        format!("{count} implementations")
-    }
+    if count == 1 { "1 implementation".into() } else { format!("{count} implementations") }
 }
 
 pub(crate) fn reference_title(count: usize) -> String {
-    if count == 1 {
-        "1 reference".into()
-    } else {
-        format!("{count} references")
-    }
+    if count == 1 { "1 reference".into() } else { format!("{count} references") }
 }
 
 pub(crate) fn markup_content(
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{expect, Expect};
+    use expect_test::{Expect, expect};
     use ide::{Analysis, FilePosition};
     use ide_db::source_change::Snippet;
     use test_utils::extract_offset;
     use triomphe::Arc;
-
     use super::*;
-
     #[test]
     fn conv_fold_line_folding_only_fixup() {
         let text = r#"mod a;
         b::do_b();
     }
 }"#;
-
         let (analysis, file_id) = Analysis::from_single_file(text.to_owned());
         let folds = analysis.folding_ranges(file_id).unwrap();
         assert_eq!(folds.len(), 4);
-
         let line_index = LineIndex {
             index: Arc::new(ide::LineIndex::new(text)),
             endings: LineEndings::Unix,
             encoding: PositionEncoding::Utf8,
         };
-        let converted: Vec<lsp_types::FoldingRange> = folds
-            .into_iter()
-            .map(|it| folding_range(text, &line_index, true, it))
-            .collect();
-
+        let converted: Vec<lsp_types::FoldingRange> =
+            folds.into_iter().map(|it| folding_range(text, &line_index, true, it)).collect();
         let expected_lines = [(0, 2), (4, 10), (5, 6), (7, 9)];
         assert_eq!(converted.len(), expected_lines.len());
         for (folding_range, (start_line, end_line)) in converted.iter().zip(expected_lines.iter()) {
             assert_eq!(folding_range.end_character, None);
         }
     }
-
     #[test]
     fn calling_function_with_ignored_code_in_signature() {
         let text = r#"
 /// ```
 fn bar(_: usize) {}
 "#;
-
         let (offset, text) = extract_offset(text);
         let (analysis, file_id) = Analysis::from_single_file(text);
         let help = signature_help(
-            analysis
-                .signature_help(FilePosition { file_id, offset })
-                .unwrap()
-                .unwrap(),
-            CallInfoConfig {
-                params_only: false,
-                docs: true,
-            },
+            analysis.signature_help(FilePosition { file_id, offset }).unwrap().unwrap(),
+            CallInfoConfig { params_only: false, docs: true },
             false,
         );
         let docs = match &help.signatures[help.active_signature.unwrap() as usize].documentation {
         assert!(docs.contains("bar(5)"));
         assert!(!docs.contains("use crate::bar"));
     }
-
     #[track_caller]
-    fn check_rendered_snippets(edit: TextEdit, snippets: SnippetEdit, expect: Expect) {
+    fn check_rendered_snippets(
+        edit: TextEdit,
+        snippets: SnippetEdit,
+        expect: Expect,
+    ) {
         check_rendered_snippets_in_source(
             r"/* place to put all ranges in */",
             edit,
             expect,
         );
     }
-
     #[track_caller]
     fn check_rendered_snippets_in_source(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         expect: Expect,
     ) {
         let source = stdx::trim_indent(ra_fixture);
-        let endings = if source.contains('\r') {
-            LineEndings::Dos
-        } else {
-            LineEndings::Unix
-        };
+        let endings = if source.contains('\r') { LineEndings::Dos } else { LineEndings::Unix };
         let line_index = LineIndex {
             index: Arc::new(ide::LineIndex::new(&source)),
             endings,
             encoding: PositionEncoding::Utf8,
         };
-
         let res = merge_text_and_snippet_edits(&line_index, edit, snippets, true);
-
         // Ensure that none of the ranges overlap
         {
             let mut sorted = res.clone();
                 .all(|(l, r)| l.range.end <= r.range.start || l == r);
             assert!(disjoint_ranges, "ranges overlap for {res:#?}");
         }
-
         expect.assert_debug_eq(&res);
     }
-
     #[test]
     fn snippet_rendering_only_tabstops() {
         let edit = TextEdit::builder().finish();
             Snippet::Tabstop(1.into()),
             Snippet::Tabstop(1.into()),
         ]);
-
         check_rendered_snippets(
             edit,
             snippets,
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_only_text_edits() {
         let mut edit = TextEdit::builder();
         edit.insert(3.into(), "def".to_owned());
         let edit = edit.finish();
         let snippets = SnippetEdit::new(vec![]);
-
         check_rendered_snippets(
             edit,
             snippets,
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_after_text_edit() {
         let mut edit = TextEdit::builder();
         let edit = edit.finish();
         // Note: tabstops are positioned in the source where all text edits have been applied
         let snippets = SnippetEdit::new(vec![Snippet::Tabstop(10.into())]);
-
         check_rendered_snippets(
             edit,
             snippets,
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstops_before_text_edit() {
         let mut edit = TextEdit::builder();
         let edit = edit.finish();
         let snippets =
             SnippetEdit::new(vec![Snippet::Tabstop(0.into()), Snippet::Tabstop(0.into())]);
-
         check_rendered_snippets(
             edit,
             snippets,
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstops_between_text_edits() {
         let mut edit = TextEdit::builder();
         // Note: tabstops are positioned in the source where all text edits have been applied
         let snippets =
             SnippetEdit::new(vec![Snippet::Tabstop(7.into()), Snippet::Tabstop(7.into())]);
-
         check_rendered_snippets(
             edit,
             snippets,
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_multiple_tabstops_in_text_edit() {
         let mut edit = TextEdit::builder();
             Snippet::Tabstop(5.into()),
             Snippet::Tabstop(12.into()),
         ]);
-
         check_rendered_snippets(
             edit,
             snippets,
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_multiple_placeholders_in_text_edit() {
         let mut edit = TextEdit::builder();
             Snippet::Placeholder(TextRange::new(5.into(), 7.into())),
             Snippet::Placeholder(TextRange::new(10.into(), 12.into())),
         ]);
-
         check_rendered_snippets(
             edit,
             snippets,
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_escape_snippet_bits() {
         // only needed for snippet formats
             Snippet::Placeholder(TextRange::new(1.into(), 9.into())),
             Snippet::Tabstop(25.into()),
         ]);
-
         check_rendered_snippets(
             edit,
             snippets,
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_adjust_offset_deleted() {
         // negative offset from inserting a smaller range
         );
         let edit = edit.finish();
         let snippets = SnippetEdit::new(vec![Snippet::Tabstop(51.into())]);
-
         check_rendered_snippets_in_source(
             r"
 fn expander_to_proc_macro() -> ProcMacro {
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_adjust_offset_added() {
         // positive offset from inserting a larger range
         );
         let edit = edit.finish();
         let snippets = SnippetEdit::new(vec![Snippet::Tabstop(43.into())]);
-
         check_rendered_snippets_in_source(
             r"
 fn expander_to_proc_macro() -> P {
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_placeholder_adjust_offset_deleted() {
         // negative offset from inserting a smaller range
             "disabled = false;\n    ProcMacro {\n        disabled,\n    }".to_owned(),
         );
         let edit = edit.finish();
-        let snippets = SnippetEdit::new(vec![Snippet::Placeholder(TextRange::new(
-            51.into(),
-            59.into(),
-        ))]);
-
+        let snippets =
+            SnippetEdit::new(vec![Snippet::Placeholder(TextRange::new(51.into(), 59.into()))]);
         check_rendered_snippets_in_source(
             r"
 fn expander_to_proc_macro() -> ProcMacro {
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_placeholder_adjust_offset_added() {
         // positive offset from inserting a larger range
             "disabled = false;\n    ProcMacro {\n        disabled,\n    }".to_owned(),
         );
         let edit = edit.finish();
-        let snippets = SnippetEdit::new(vec![Snippet::Placeholder(TextRange::new(
-            43.into(),
-            51.into(),
-        ))]);
-
+        let snippets =
+            SnippetEdit::new(vec![Snippet::Placeholder(TextRange::new(43.into(), 51.into()))]);
         check_rendered_snippets_in_source(
             r"
 fn expander_to_proc_macro() -> P {
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_adjust_offset_between_text_edits() {
         // inserting between edits, tabstop should be at (1, 14)
         );
         let edit = edit.finish();
         let snippets = SnippetEdit::new(vec![Snippet::Tabstop(51.into())]);
-
         // add an extra space between `ProcMacro` and `{` to insert the tabstop at
         check_rendered_snippets_in_source(
             r"
 "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_adjust_offset_after_text_edits() {
         // inserting after edits, tabstop should be before the closing curly of the fn
         );
         let edit = edit.finish();
         let snippets = SnippetEdit::new(vec![Snippet::Tabstop(109.into())]);
-
         check_rendered_snippets_in_source(
             r"
 fn expander_to_proc_macro() -> ProcMacro {
 "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_handle_dos_line_endings() {
         // unix -> dos conversion should be handled after placing snippets
         let mut edit = TextEdit::builder();
         edit.insert(6.into(), "\n\n->".to_owned());
-
         let edit = edit.finish();
         let snippets = SnippetEdit::new(vec![Snippet::Tabstop(10.into())]);
-
         check_rendered_snippets_in_source(
             "yeah\r\n<-tabstop here",
             edit,
         "#]],
         )
     }
-
-    // `Url` is not able to parse windows paths on unix machines.
     #[test]
     #[cfg(target_os = "windows")]
     fn test_lowercase_drive_letter() {
         use paths::Utf8Path;
-
         let url = url_from_abs_path(Utf8Path::new("C:\\Test").try_into().unwrap());
         assert_eq!(url.to_string(), "file:///c:/Test");
-
-        let url = url_from_abs_path(
-            Utf8Path::new(r#"\\localhost\C$\my_dir"#)
-                .try_into()
-                .unwrap(),
-        );
+        let url = url_from_abs_path(Utf8Path::new(r#"\\localhost\C$\my_dir"#).try_into().unwrap());
         assert_eq!(url.to_string(), "file://localhost/C$/my_dir");
     }
 }