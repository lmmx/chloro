COMPARISON DIFF
============================================================

Original size: 111479 bytes
Chloro size:   111475 bytes
Rustfmt size:  113521 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Conversion of rust-analyzer specific types to lsp_types equivalents.
+
 use std::{
     iter::once,
     mem,
 };
 
 use base64::{Engine, prelude::BASE64_STANDARD};
+use ide_db::{
+    FxHasher, MiniCore, assists, rust_doc::format_docs, source_change::ChangeAnnotationId,
+};
 use ide::{
     Annotation, AnnotationKind, Assist, AssistKind, Cancellable, CompletionFieldsToResolve,
     CompletionItem, CompletionItemKind, CompletionRelevance, Documentation, FileId, FileRange,
     SnippetEdit, SourceChange, StructureNodeKind, SymbolKind, TextEdit, TextRange, TextSize,
     UpdateTest,
 };
-use ide_db::{
-    FxHasher, MiniCore, assists, rust_doc::format_docs, source_change::ChangeAnnotationId,
-};
 use itertools::Itertools;
 use paths::{Utf8Component, Utf8Prefix};
 use semver::VersionReq;
     config::{CallInfoConfig, ClientCommandsConfig, Config},
     global_state::GlobalStateSnapshot,
     line_index::{LineEndings, LineIndex, PositionEncoding},
-    lsp::{
-        LspError, completion_item_hash,
-        ext::ShellRunnableArgs,
-        semantic_tokens::{self, standard_fallback_type},
-        utils::invalid_params_error,
-    },
     lsp_ext::{self, SnippetTextEdit},
+    lsp::{
+        LspError, completion_item_hash, ext::ShellRunnableArgs,
+        semantic_tokens::{self, standard_fallback_type}, utils::invalid_params_error,
+    },
     target_spec::{CargoTargetSpec, TargetSpec},
 };
 
 
 pub(crate) fn documentation(documentation: Documentation) -> lsp_types::Documentation {
     let value = format_docs(&documentation);
-    let markup_content = lsp_types::MarkupContent {
-        kind: lsp_types::MarkupKind::Markdown,
-        value,
-    };
+    let markup_content = lsp_types::MarkupContent { kind: lsp_types::MarkupKind::Markdown, value };
     lsp_types::Documentation::MarkupContent(markup_content)
 }
 
     annotation: Option<ChangeAnnotationId>,
     client_supports_annotations: bool,
 ) -> lsp_ext::SnippetTextEdit {
-    let annotation_id = annotation
-        .filter(|_| client_supports_annotations)
-        .map(|it| it.to_string());
+    let annotation_id = annotation.filter(|_| client_supports_annotations).map(|it| it.to_string());
     let text_edit = text_edit(line_index, indel);
-    let insert_text_format = if is_snippet {
-        Some(lsp_types::InsertTextFormat::SNIPPET)
-    } else {
-        None
-    };
+    let insert_text_format =
+        if is_snippet { Some(lsp_types::InsertTextFormat::SNIPPET) } else { None };
     lsp_ext::SnippetTextEdit {
         range: text_edit.range,
         new_text: text_edit.new_text,
     line_index: &LineIndex,
     text_edit: TextEdit,
 ) -> Vec<lsp_types::TextEdit> {
-    text_edit
-        .into_iter()
-        .map(|indel| self::text_edit(line_index, indel))
-        .collect()
+    text_edit.into_iter().map(|indel| self::text_edit(line_index, indel)).collect()
 }
 
 pub(crate) fn snippet_text_edit_vec(
         items.retain(|item| !item.deprecated);
     }
 
-    let max_relevance = items
-        .iter()
-        .map(|it| it.relevance.score())
-        .max()
-        .unwrap_or_default();
+    let max_relevance = items.iter().map(|it| it.relevance.score()).max().unwrap_or_default();
     let mut res = Vec::with_capacity(items.len());
     let client_commands = config.client_commands();
     for item in items {
         Some(text_edit.unwrap())
     };
 
-    let insert_text_format = item
-        .is_snippet
-        .then_some(lsp_types::InsertTextFormat::SNIPPET);
+    let insert_text_format = item.is_snippet.then_some(lsp_types::InsertTextFormat::SNIPPET);
     let tags = if fields_to_resolve.resolve_tags {
         something_to_resolve |= item.deprecated;
         None
     } else {
-        item.deprecated
-            .then(|| vec![lsp_types::CompletionItemTag::DEPRECATED])
+        item.deprecated.then(|| vec![lsp_types::CompletionItemTag::DEPRECATED])
     };
     let command = if item.trigger_call_info && client_commands.trigger_parameter_hints {
         if fields_to_resolve.resolve_command {
 
     set_score(&mut lsp_item, max_relevance, item.relevance);
 
-    let imports = if config
-        .completion(None, MiniCore::default())
-        .enable_imports_on_the_fly
+    let imports = if config.completion(None, MiniCore::default()).enable_imports_on_the_fly
         && !item.import_to_add.is_empty()
     {
         item.import_to_add
             .clone()
             .into_iter()
-            .map(|import_path| lsp_ext::CompletionImport {
-                full_import_path: import_path,
-            })
+            .map(|import_path| lsp_ext::CompletionImport { full_import_path: import_path })
             .collect()
     } else {
         Vec::new()
     };
 
     if let Some((label, indel, relevance)) = ref_match {
-        let mut lsp_item_with_ref = lsp_types::CompletionItem {
-            label,
-            data: ref_resolve_data,
-            ..lsp_item.clone()
-        };
+        let mut lsp_item_with_ref =
+            lsp_types::CompletionItem { label, data: ref_resolve_data, ..lsp_item.clone() };
         lsp_item_with_ref
             .additional_text_edits
             .get_or_insert_with(Default::default)
                     documentation: None,
                 })
                 .collect::<Vec<_>>();
-            let label = if concise {
-                call_info.parameter_labels().join(", ")
-            } else {
-                call_info.signature
-            };
+            let label =
+                if concise { call_info.parameter_labels().join(", ") } else { call_info.signature };
             (label, params)
         }
         (false, true) => {
         hint.resolve_parent.filter(|_| {
             hint.text_edit.as_ref().is_some_and(LazyProperty::is_lazy)
                 || hint.label.parts.iter().any(|part| {
-                    part.linked_location
-                        .as_ref()
-                        .is_some_and(LazyProperty::is_lazy)
+                    part.linked_location.as_ref().is_some_and(LazyProperty::is_lazy)
                         || part.tooltip.as_ref().is_some_and(LazyProperty::is_lazy)
                 })
         })
         .and_then(|it| match it {
             LazyProperty::Computed(it) => Some(it),
             LazyProperty::Lazy => {
-                something_to_resolve |= snap
-                    .config
-                    .visual_studio_code_version()
-                    .is_none_or(|version| VersionReq::parse(">=1.86.0").unwrap().matches(version))
-                    && resolve_range_and_hash.is_some()
-                    && fields_to_resolve.resolve_text_edits;
+                something_to_resolve |=
+                    snap.config.visual_studio_code_version().is_none_or(|version| {
+                        VersionReq::parse(">=1.86.0").unwrap().matches(version)
+                    }) && resolve_range_and_hash.is_some()
+                        && fields_to_resolve.resolve_text_edits;
                 None
             }
         })
     something_to_resolve: &mut bool,
     needs_resolve: bool,
     mut label: InlayHintLabel,
-) -> Cancellable<(
-    lsp_types::InlayHintLabel,
-    Option<lsp_types::InlayHintTooltip>,
-)> {
+) -> Cancellable<(lsp_types::InlayHintLabel, Option<lsp_types::InlayHintTooltip>)> {
     let (label, tooltip) = match &*label.parts {
-        [
-            InlayHintLabelPart {
-                linked_location: None,
-                ..
-            },
-        ] => {
+        [InlayHintLabelPart { linked_location: None, .. }] => {
             let InlayHintLabelPart { text, tooltip, .. } = label.parts.pop().unwrap();
             let tooltip = tooltip.and_then(|it| match it {
                 LazyProperty::Computed(it) => Some(it),
             });
             let hint_tooltip = match tooltip {
                 Some(ide::InlayTooltip::String(s)) => Some(lsp_types::InlayHintTooltip::String(s)),
-                Some(ide::InlayTooltip::Markdown(s)) => Some(
-                    lsp_types::InlayHintTooltip::MarkupContent(lsp_types::MarkupContent {
+                Some(ide::InlayTooltip::Markdown(s)) => {
+                    Some(lsp_types::InlayHintTooltip::MarkupContent(lsp_types::MarkupContent {
                         kind: lsp_types::MarkupKind::Markdown,
                         value: s,
-                    }),
-                ),
+                    }))
+                }
                 None => None,
             };
             (lsp_types::InlayHintLabel::String(text), hint_tooltip)
     semantics_tokens_augments_syntax_tokens: bool,
     non_standard_tokens: bool,
 ) -> lsp_types::SemanticTokens {
-    let id = TOKEN_RESULT_COUNTER
-        .fetch_add(1, Ordering::SeqCst)
-        .to_string();
+    let id = TOKEN_RESULT_COUNTER.fetch_add(1, Ordering::SeqCst).to_string();
     let mut builder = semantic_tokens::SemanticTokensBuilder::new(id);
 
     for highlight_range in highlights {
     let url = lsp_types::Url::from_file_path(path).unwrap();
     match path.components().next() {
         Some(Utf8Component::Prefix(prefix))
-            if matches!(
-                prefix.kind(),
-                Utf8Prefix::Disk(_) | Utf8Prefix::VerbatimDisk(_)
-            ) =>
+            if matches!(prefix.kind(), Utf8Prefix::Disk(_) | Utf8Prefix::VerbatimDisk(_)) =>
         {
             // Need to lowercase driver letter
         }
 
     let target_uri = url(snap, target.file_id);
     let target_range = range(&line_index, target.full_range);
-    let target_selection_range = target
-        .focus_range
-        .map(|it| range(&line_index, it))
-        .unwrap_or(target_range);
+    let target_selection_range =
+        target.focus_range.map(|it| range(&line_index, it)).unwrap_or(target_range);
     Ok((target_uri, target_range, target_selection_range))
 }
 
     } else {
         let locations = targets
             .into_iter()
-            .map(|nav| FileRange {
-                file_id: nav.file_id,
-                range: nav.focus_or_full_range(),
-            })
+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })
             .unique()
             .map(|range| location(snap, range))
             .collect::<Cancellable<Vec<_>>>()?;
 
     let offset_range = |range: TextRange, offset: i32| -> TextRange {
         // map the snippet range from the target location into the original source location
-        let start = u32::from(range.start())
-            .checked_add_signed(offset)
-            .unwrap_or(0);
-        let end = u32::from(range.end())
-            .checked_add_signed(offset)
-            .unwrap_or(0);
+        let start = u32::from(range.start()).checked_add_signed(offset).unwrap_or(0);
+        let end = u32::from(range.end()).checked_add_signed(offset).unwrap_or(0);
 
         TextRange::new(start.into(), end.into())
     };
             edits.push(snippet_text_edit(
                 line_index,
                 true,
-                Indel {
-                    insert: format!("${snippet_index}"),
-                    delete: snippet_range,
-                },
+                Indel { insert: format!("${snippet_index}"), delete: snippet_range },
                 annotation,
                 client_supports_annotations,
             ))
         }
 
         if snippets.peek().is_some_and(|(_, range)| {
-            new_range
-                .intersect(offset_range(*range, source_text_offset))
-                .is_some()
+            new_range.intersect(offset_range(*range, source_text_offset)).is_some()
         }) {
             // at least one snippet edit intersects this text edit,
             // so gather all of the edits that intersect this text edit
             let mut all_snippets = snippets
                 .peeking_take_while(|(_, range)| {
-                    new_range
-                        .intersect(offset_range(*range, source_text_offset))
-                        .is_some()
+                    new_range.intersect(offset_range(*range, source_text_offset)).is_some()
                 })
                 .map(|(tabstop, range)| (tabstop, offset_range(range, source_text_offset)))
                 .collect_vec();
             let mut new_text = current_indel.insert;
 
             // find which snippet bits need to be escaped
-            let escape_places = new_text
-                .rmatch_indices(['\\', '$', '}'])
-                .map(|(insert, _)| insert)
-                .collect_vec();
+            let escape_places =
+                new_text.rmatch_indices(['\\', '$', '}']).map(|(insert, _)| insert).collect_vec();
             let mut escape_places = escape_places.into_iter().peekable();
             let mut escape_prior_bits = |new_text: &mut String, up_to: usize| {
                 for before in escape_places.peeking_take_while(|insert| *insert >= up_to) {
             edits.push(snippet_text_edit(
                 line_index,
                 true,
-                Indel {
-                    insert: new_text,
-                    delete: current_indel.delete,
-                },
+                Indel { insert: new_text, delete: current_indel.delete },
                 annotation,
                 client_supports_annotations,
             ))
         snippet_text_edit(
             line_index,
             true,
-            Indel {
-                insert: format!("${snippet_index}"),
-                delete: snippet_range,
-            },
+            Indel { insert: format!("${snippet_index}"), delete: snippet_range },
             annotation,
             client_supports_annotations,
         )
             edit.annotation_id = Some(outside_workspace_annotation_id())
         }
     }
-    Ok(lsp_ext::SnippetTextDocumentEdit {
-        text_document,
-        edits,
-    })
+    Ok(lsp_ext::SnippetTextDocumentEdit { text_document, edits })
 }
 
 pub(crate) fn snippet_text_document_ops(
 ) -> Cancellable<Vec<lsp_ext::SnippetDocumentChangeOperation>> {
     let mut ops = Vec::new();
     match file_system_edit {
-        FileSystemEdit::CreateFile {
-            dst,
-            initial_contents,
-        } => {
+        FileSystemEdit::CreateFile { dst, initial_contents } => {
             let uri = snap.anchored_path(&dst);
             let create_file = lsp_types::ResourceOp::Create(lsp_types::CreateFile {
                 uri: uri.clone(),
                     insert_text_format: Some(lsp_types::InsertTextFormat::PLAIN_TEXT),
                     annotation_id: None,
                 };
-                let edit_file = lsp_ext::SnippetTextDocumentEdit {
-                    text_document,
-                    edits: vec![text_edit],
-                };
+                let edit_file =
+                    lsp_ext::SnippetTextDocumentEdit { text_document, edits: vec![text_edit] };
                 ops.push(lsp_ext::SnippetDocumentChangeOperation::Edit(edit_file));
             }
         }
         FileSystemEdit::MoveFile { src, dst } => {
             let old_uri = snap.file_id_to_url(src);
             let new_uri = snap.anchored_path(&dst);
-            let mut rename_file = lsp_types::RenameFile {
-                old_uri,
-                new_uri,
-                options: None,
-                annotation_id: None,
-            };
+            let mut rename_file =
+                lsp_types::RenameFile { old_uri, new_uri, options: None, annotation_id: None };
             if snap.analysis.is_library_file(src).ok() == Some(true)
                 && snap.config.change_annotation_support()
             {
                 rename_file.annotation_id = Some(outside_workspace_annotation_id())
             }
-            ops.push(lsp_ext::SnippetDocumentChangeOperation::Op(
-                lsp_types::ResourceOp::Rename(rename_file),
-            ))
+            ops.push(lsp_ext::SnippetDocumentChangeOperation::Op(lsp_types::ResourceOp::Rename(
+                rename_file,
+            )))
         }
         FileSystemEdit::MoveDir { src, src_id, dst } => {
             let old_uri = snap.anchored_path(&src);
             let new_uri = snap.anchored_path(&dst);
-            let mut rename_file = lsp_types::RenameFile {
-                old_uri,
-                new_uri,
-                options: None,
-                annotation_id: None,
-            };
+            let mut rename_file =
+                lsp_types::RenameFile { old_uri, new_uri, options: None, annotation_id: None };
             if snap.analysis.is_library_file(src_id).ok() == Some(true)
                 && snap.config.change_annotation_support()
             {
                 rename_file.annotation_id = Some(outside_workspace_annotation_id())
             }
-            ops.push(lsp_ext::SnippetDocumentChangeOperation::Op(
-                lsp_types::ResourceOp::Rename(rename_file),
-            ))
+            ops.push(lsp_ext::SnippetDocumentChangeOperation::Op(lsp_types::ResourceOp::Rename(
+                rename_file,
+            )))
         }
     }
     Ok(ops)
     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();
 
     for op in &mut source_change.file_system_edits {
-        if let FileSystemEdit::CreateFile {
-            dst,
-            initial_contents,
-        } = op
-        {
+        if let FileSystemEdit::CreateFile { dst, initial_contents } = op {
             // replace with a placeholder to avoid cloneing the edit
             let op = FileSystemEdit::CreateFile {
                 dst: dst.clone(),
                     )),
                 },
             ))
-            .chain(
-                source_change
-                    .annotations
-                    .into_iter()
-                    .map(|(id, annotation)| {
-                        (
-                            id.to_string(),
-                            lsp_types::ChangeAnnotation {
-                                label: annotation.label,
-                                description: annotation.description,
-                                needs_confirmation: Some(annotation.needs_confirmation),
-                            },
-                        )
-                    }),
-            )
+            .chain(source_change.annotations.into_iter().map(|(id, annotation)| {
+                (
+                    id.to_string(),
+                    lsp_types::ChangeAnnotation {
+                        label: annotation.label,
+                        description: annotation.description,
+                        needs_confirmation: Some(annotation.needs_confirmation),
+                    },
+                )
+            }))
             .collect(),
         )
     }
     }
 }
 
-impl From<lsp_ext::SnippetTextEdit>
-    for lsp_types::OneOf<lsp_types::TextEdit, lsp_types::AnnotatedTextEdit>
-{
+impl From<lsp_ext::SnippetTextEdit> for lsp_types::OneOf<lsp_types::TextEdit, lsp_types::AnnotatedTextEdit> {
     fn from(
-        lsp_ext::SnippetTextEdit {
-            annotation_id,
-            insert_text_format: _,
-            new_text,
-            range,
-        }: lsp_ext::SnippetTextEdit,
+        lsp_ext::SnippetTextEdit { annotation_id, insert_text_format:_, new_text, range }: lsp_ext::SnippetTextEdit,
     ) -> Self {
         match annotation_id {
             Some(annotation_id) => lsp_types::OneOf::Right(lsp_types::AnnotatedTextEdit {
 ) -> Cancellable<lsp_types::CallHierarchyItem> {
     let name = target.name.to_string();
     let detail = target.description.clone();
-    let kind = target
-        .kind
-        .map(symbol_kind)
-        .unwrap_or(lsp_types::SymbolKind::FUNCTION);
+    let kind = target.kind.map(symbol_kind).unwrap_or(lsp_types::SymbolKind::FUNCTION);
     let (uri, range, selection_range) = location_info(snap, target)?;
     Ok(lsp_types::CallHierarchyItem {
         name,
 ) -> Cancellable<lsp_ext::CodeAction> {
     let mut res = lsp_ext::CodeAction {
         title: assist.label.to_string(),
-        group: assist
-            .group
-            .filter(|_| snap.config.code_action_group())
-            .map(|gr| gr.0),
+        group: assist.group.filter(|_| snap.config.code_action_group()).map(|gr| gr.0),
         kind: Some(code_action_kind(assist.id.1)),
         edit: None,
         is_preferred: None,
                     .filter_map(|target| {
                         location(
                             snap,
-                            FileRange {
-                                file_id: target.file_id,
-                                range: target.full_range,
-                            },
+                            FileRange { file_id: target.file_id, range: target.full_range },
                         )
                         .ok()
                     })
             let doc_pos = lsp_types::TextDocumentPositionParams::new(id, pos);
 
             let command = data.map(|ranges| {
-                let locations: Vec<lsp_types::Location> = ranges
-                    .into_iter()
-                    .filter_map(|range| location(snap, range).ok())
-                    .collect();
+                let locations: Vec<lsp_types::Location> =
+                    ranges.into_iter().filter_map(|range| location(snap, range).ok()).collect();
 
                 command::show_references(reference_title(locations.len()), &url, pos, locations)
             });
             .file
             .map(|f| lsp_types::TextDocumentIdentifier { uri: url(snap, f) }),
         range: line_index.and_then(|l| Some(range(l, test_item.text_range?))),
-        runnable: test_item
-            .runnable
-            .and_then(|r| runnable(snap, r).ok())
-            .flatten(),
+        runnable: test_item.runnable.and_then(|r| runnable(snap, r).ok()).flatten(),
     })
 }
 
 pub(crate) mod command {
     use ide::{FileRange, NavigationTarget};
     use serde_json::to_value;
-
     use crate::{
         global_state::GlobalStateSnapshot,
-        lsp::to_proto::{location, location_link},
         lsp_ext,
+        lsp::to_proto::{location, location_link},
     };
-
     pub(crate) fn show_references(
         title: String,
         uri: &lsp_types::Url,
         // We cannot use the 'editor.action.showReferences' command directly
         // because that command requires vscode types which we convert in the handler
         // on the client side.
-
         lsp_types::Command {
             title,
             command: "rust-analyzer.showReferences".into(),
             ]),
         }
     }
-
     pub(crate) fn run_single(runnable: &lsp_ext::Runnable, title: &str) -> lsp_types::Command {
         lsp_types::Command {
             title: title.to_owned(),
             arguments: Some(vec![to_value(runnable).unwrap()]),
         }
     }
-
     pub(crate) fn debug_single(runnable: &lsp_ext::Runnable) -> lsp_types::Command {
         lsp_types::Command {
             title: "⚙\u{fe0e} Debug".into(),
             arguments: Some(vec![to_value(runnable).unwrap()]),
         }
     }
-
     pub(crate) fn interpret_single(_runnable: &lsp_ext::Runnable) -> lsp_types::Command {
         lsp_types::Command {
             title: "Interpret".into(),
             command: "rust-analyzer.interpretFunction".into(),
-            // FIXME: use the `_runnable` here.
             arguments: Some(vec![]),
         }
     }
-
     pub(crate) fn goto_location(
         snap: &GlobalStateSnapshot,
         nav: &NavigationTarget,
             let link = location_link(snap, None, nav.clone()).ok()?;
             to_value(link).ok()?
         } else {
-            let range = FileRange {
-                file_id: nav.file_id,
-                range: nav.focus_or_full_range(),
-            };
+            let range = FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() };
             let location = location(snap, range).ok()?;
             to_value(location).ok()?
         };
             arguments: Some(vec![value]),
         })
     }
-
     pub(crate) fn trigger_parameter_hints() -> lsp_types::Command {
         lsp_types::Command {
             title: "triggerParameterHints".into(),
             arguments: None,
         }
     }
-
     pub(crate) fn rename() -> lsp_types::Command {
         lsp_types::Command {
             title: "rename".into(),
         return None;
     };
 
-    r.environment.extend(
-        update_test
-            .env()
-            .iter()
-            .map(|(k, v)| (k.to_string(), v.to_string())),
-    );
+    r.environment.extend(update_test.env().iter().map(|(k, v)| (k.to_string(), v.to_string())));
 
     if update_test.insta {
         r.cargo_args.insert(0, "insta".to_owned());
     use ide_db::source_change::Snippet;
     use test_utils::extract_offset;
     use triomphe::Arc;
-
     use super::*;
-
     #[test]
     fn conv_fold_line_folding_only_fixup() {
         let text = r#"mod a;
             endings: LineEndings::Unix,
             encoding: PositionEncoding::Utf8,
         };
-        let converted: Vec<lsp_types::FoldingRange> = folds
-            .into_iter()
-            .map(|it| folding_range(text, &line_index, true, it))
-            .collect();
+        let converted: Vec<lsp_types::FoldingRange> =
+            folds.into_iter().map(|it| folding_range(text, &line_index, true, it)).collect();
 
         let expected_lines = [(0, 2), (4, 10), (5, 6), (7, 9)];
         assert_eq!(converted.len(), expected_lines.len());
             assert_eq!(folding_range.end_character, None);
         }
     }
-
     #[test]
     fn calling_function_with_ignored_code_in_signature() {
         let text = r#"
         let (offset, text) = extract_offset(text);
         let (analysis, file_id) = Analysis::from_single_file(text);
         let help = signature_help(
-            analysis
-                .signature_help(FilePosition { file_id, offset })
-                .unwrap()
-                .unwrap(),
-            CallInfoConfig {
-                params_only: false,
-                docs: true,
-            },
+            analysis.signature_help(FilePosition { file_id, offset }).unwrap().unwrap(),
+            CallInfoConfig { params_only: false, docs: true },
             false,
         );
         let docs = match &help.signatures[help.active_signature.unwrap() as usize].documentation {
         assert!(docs.contains("bar(5)"));
         assert!(!docs.contains("use crate::bar"));
     }
-
     #[track_caller]
     fn check_rendered_snippets(edit: TextEdit, snippets: SnippetEdit, expect: Expect) {
         check_rendered_snippets_in_source(
             expect,
         );
     }
-
     #[track_caller]
     fn check_rendered_snippets_in_source(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         expect: Expect,
     ) {
         let source = stdx::trim_indent(ra_fixture);
-        let endings = if source.contains('\r') {
-            LineEndings::Dos
-        } else {
-            LineEndings::Unix
-        };
+        let endings = if source.contains('\r') { LineEndings::Dos } else { LineEndings::Unix };
         let line_index = LineIndex {
             index: Arc::new(ide::LineIndex::new(&source)),
             endings,
 
         expect.assert_debug_eq(&res);
     }
-
     #[test]
     fn snippet_rendering_only_tabstops() {
         let edit = TextEdit::builder().finish();
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_only_text_edits() {
         let mut edit = TextEdit::builder();
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_after_text_edit() {
         let mut edit = TextEdit::builder();
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstops_before_text_edit() {
         let mut edit = TextEdit::builder();
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstops_between_text_edits() {
         let mut edit = TextEdit::builder();
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_multiple_tabstops_in_text_edit() {
         let mut edit = TextEdit::builder();
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_multiple_placeholders_in_text_edit() {
         let mut edit = TextEdit::builder();
         "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_escape_snippet_bits() {
         // only needed for snippet formats
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_adjust_offset_deleted() {
         // negative offset from inserting a smaller range
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_adjust_offset_added() {
         // positive offset from inserting a larger range
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_placeholder_adjust_offset_deleted() {
         // negative offset from inserting a smaller range
             "disabled = false;\n    ProcMacro {\n        disabled,\n    }".to_owned(),
         );
         let edit = edit.finish();
-        let snippets = SnippetEdit::new(vec![Snippet::Placeholder(TextRange::new(
-            51.into(),
-            59.into(),
-        ))]);
+        let snippets =
+            SnippetEdit::new(vec![Snippet::Placeholder(TextRange::new(51.into(), 59.into()))]);
 
         check_rendered_snippets_in_source(
             r"
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_placeholder_adjust_offset_added() {
         // positive offset from inserting a larger range
             "disabled = false;\n    ProcMacro {\n        disabled,\n    }".to_owned(),
         );
         let edit = edit.finish();
-        let snippets = SnippetEdit::new(vec![Snippet::Placeholder(TextRange::new(
-            43.into(),
-            51.into(),
-        ))]);
+        let snippets =
+            SnippetEdit::new(vec![Snippet::Placeholder(TextRange::new(43.into(), 51.into()))]);
 
         check_rendered_snippets_in_source(
             r"
             "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_adjust_offset_between_text_edits() {
         // inserting between edits, tabstop should be at (1, 14)
 "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_tabstop_adjust_offset_after_text_edits() {
         // inserting after edits, tabstop should be before the closing curly of the fn
 "#]],
         );
     }
-
     #[test]
     fn snippet_rendering_handle_dos_line_endings() {
         // unix -> dos conversion should be handled after placing snippets
         "#]],
         )
     }
-
     // `Url` is not able to parse windows paths on unix machines.
     #[test]
     #[cfg(target_os = "windows")]
         let url = url_from_abs_path(Utf8Path::new("C:\\Test").try_into().unwrap());
         assert_eq!(url.to_string(), "file:///c:/Test");
 
-        let url = url_from_abs_path(
-            Utf8Path::new(r#"\\localhost\C$\my_dir"#)
-                .try_into()
-                .unwrap(),
-        );
+        let url = url_from_abs_path(Utf8Path::new(r#"\\localhost\C$\my_dir"#).try_into().unwrap());
         assert_eq!(url.to_string(), "file://localhost/C$/my_dir");
     }
 }