COMPARISON DIFF
============================================================

Original size: 15570 bytes
Chloro size:   15544 bytes
Rustfmt size:  15570 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! See [RequestDispatcher].
+
 use std::{
     fmt::{self, Debug},
     panic, thread,
     where
         R: lsp_types::request::Request,
         R::Params: DeserializeOwned + panic::UnwindSafe + fmt::Debug,
-        R::Result: Serialize,
-    {
+        R::Result: Serialize, {
         let (req, params, panic_context) = match self.parse::<R>() {
             Some(it) => it,
             None => return self,
         if let Ok(response) = result_to_response::<R>(req.id, result) {
             self.global_state.respond(response);
         }
-
         self
     }
 
     where
         R: lsp_types::request::Request,
         R::Params: DeserializeOwned + panic::UnwindSafe + fmt::Debug,
-        R::Result: Serialize,
-    {
+        R::Result: Serialize, {
         let (req, params, panic_context) = match self.parse::<R>() {
             Some(it) => it,
             None => return self,
             tracing::info_span!("request", method = ?req.method, "request_id" = ?req.id).entered();
         tracing::debug!(?params);
         let global_state_snapshot = self.global_state.snapshot();
-
         let result = panic::catch_unwind(move || {
             let _pctx = DbPanicContext::enter(panic_context);
             f(global_state_snapshot, params)
         });
-
         if let Ok(response) = thread_result_to_response::<R>(req.id, result) {
             self.global_state.respond(response);
         }
-
         self
     }
 
         R: lsp_types::request::Request<
                 Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
                 Result: Serialize + Default,
-            > + 'static,
-    {
+            > + 'static, {
         if !self.global_state.vfs_done {
             if let Some(lsp_server::Request { id, .. }) =
                 self.req.take_if(|it| it.method == R::METHOD)
         R: lsp_types::request::Request<
                 Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
                 Result: Serialize,
-            > + 'static,
-    {
+            > + 'static, {
         if !self.global_state.vfs_done || self.global_state.incomplete_crate_graph {
             if let Some(lsp_server::Request { id, .. }) =
                 self.req.take_if(|it| it.method == R::METHOD)
     ) -> &mut Self
     where
         R: lsp_types::request::Request<Params = Params, Result = Params> + 'static,
-        Params: Serialize + DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
-    {
+        Params: Serialize + DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, {
         if !self.global_state.vfs_done {
             if let Some((request, params, _)) = self.parse::<R>() {
                 self.global_state.respond(lsp_server::Response::new_ok(request.id, &params))
         R: lsp_types::request::Request<
                 Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
                 Result: Serialize + Default,
-            > + 'static,
-    {
+            > + 'static, {
         if !self.global_state.vfs_done {
             if let Some(lsp_server::Request { id, .. }) =
                 self.req.take_if(|it| it.method == R::METHOD)
     where
         R: lsp_types::request::Request + 'static,
         R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
-        R::Result: Serialize,
-    {
+        R::Result: Serialize, {
         self.on_with_thread_intent::<true, false, R>(
             ThreadIntent::LatencySensitive,
             f,
     where
         R: lsp_types::request::Request + 'static,
         R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,
-        R::Result: Serialize,
-    {
+        R::Result: Serialize, {
         let (req, params, panic_context) = match self.parse::<R>() {
             Some(it) => it,
             None => return self,
         let _guard =
             tracing::info_span!("request", method = ?req.method, "request_id" = ?req.id).entered();
         tracing::debug!(?params);
-
         let world = self.global_state.snapshot();
         if RUSTFMT {
             &mut self.global_state.fmt_pool.handle
                 }
             }
         });
-
         self
     }
 
     fn parse<R>(&mut self) -> Option<(lsp_server::Request, R::Params, String)>
     where
         R: lsp_types::request::Request,
-        R::Params: DeserializeOwned + fmt::Debug,
-    {
+        R::Params: DeserializeOwned + fmt::Debug, {
         let req = self.req.take_if(|it| it.method == R::METHOD)?;
         let res = crate::from_json(R::METHOD, &req.params);
         match res {
 }
 
 impl fmt::Display for HandlerCancelledError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         write!(f, "Cancelled")
     }
 }
 where
     R: lsp_types::request::Request,
     R::Params: DeserializeOwned,
-    R::Result: Serialize,
-{
+    R::Result: Serialize, {
     match result {
         Ok(result) => result_to_response::<R>(id, result),
         Err(panic) => {
 where
     R: lsp_types::request::Request,
     R::Params: DeserializeOwned,
-    R::Result: Serialize,
-{
+    R::Result: Serialize, {
     let res = match result {
         Ok(resp) => lsp_server::Response::new_ok(id, &resp),
         Err(e) => match e.downcast::<LspError>() {
     ) -> &mut Self
     where
         N: lsp_types::notification::Notification,
-        N::Params: DeserializeOwned + Send + Debug,
-    {
+        N::Params: DeserializeOwned + Send + Debug, {
         let not = match self.not.take() {
             Some(it) => it,
             None => return self,
         };
-
         let _guard = tracing::info_span!("notification", method = ?not.method).entered();
-
         let params = match not.extract::<N::Params>(N::METHOD) {
             Ok(it) => it,
             Err(ExtractError::JsonError { method, error }) => {
                 return self;
             }
         };
-
         tracing::debug!(?params);
-
         let _pctx =
             DbPanicContext::enter(format!("\nversion: {}\nnotification: {}", version(), N::METHOD));
         if let Err(e) = f(self.global_state, params) {