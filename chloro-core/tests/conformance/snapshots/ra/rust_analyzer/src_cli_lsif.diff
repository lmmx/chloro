COMPARISON DIFF
============================================================

Original size: 12611 bytes
Chloro size:   12840 bytes
Rustfmt size:  12892 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use ide::{
     Analysis, AnalysisHost, FileId, FileRange, MonikerKind, MonikerResult, PackageInformation,
-    RootDatabase, StaticIndex, StaticIndexedFile, TokenId, TokenStaticData,
-    VendoredLibrariesConfig,
+    RootDatabase, StaticIndex, StaticIndexedFile, TokenId, TokenStaticData, VendoredLibrariesConfig,
 };
-use ide_db::{line_index::WideEncoding, LineIndexDatabase};
-use load_cargo::{load_workspace, LoadCargoConfig, ProcMacroServerChoice};
+use ide_db::{LineIndexDatabase, line_index::WideEncoding};
+use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace};
 use lsp_types::lsif;
 use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};
 use rustc_hash::FxHashMap;
         }
     }
 
-    fn add(&mut self, data: lsif::Element) -> Id {
+    fn add(
+        &mut self,
+        data: lsif::Element,
+    ) -> Id {
         let id = Id(self.count);
-        self.emit(
-            &serde_json::to_string(&lsif::Entry {
-                id: id.into(),
-                data,
-            })
-            .unwrap(),
-        );
+        self.emit(&serde_json::to_string(&lsif::Entry { id: id.into(), data }).unwrap());
         self.count += 1;
         id
     }
 
-    fn add_vertex(&mut self, vertex: lsif::Vertex) -> Id {
+    fn add_vertex(
+        &mut self,
+        vertex: lsif::Vertex,
+    ) -> Id {
         self.add(lsif::Element::Vertex(vertex))
     }
 
-    fn add_edge(&mut self, edge: lsif::Edge) -> Id {
+    fn add_edge(
+        &mut self,
+        edge: lsif::Edge,
+    ) -> Id {
         self.add(lsif::Element::Edge(edge))
     }
 
-    fn emit(&mut self, data: &str) {
+    fn emit(
+        &mut self,
+        data: &str,
+    ) {
         format_to!(self.out, "{data}\n");
     }
 
-    fn get_token_id(&mut self, id: TokenId) -> Id {
+    fn get_token_id(
+        &mut self,
+        id: TokenId,
+    ) -> Id {
         if let Some(it) = self.token_map.get(&id) {
             return *it;
         }
         result_set_id
     }
 
-    fn get_package_id(&mut self, package_information: PackageInformation) -> Id {
+    fn get_package_id(
+        &mut self,
+        package_information: PackageInformation,
+    ) -> Id {
         if let Some(it) = self.package_map.get(&package_information) {
             return *it;
         }
         result_set_id
     }
 
-    fn get_range_id(&mut self, id: FileRange) -> Id {
+    fn get_range_id(
+        &mut self,
+        id: FileRange,
+    ) -> Id {
         if let Some(it) = self.range_map.get(&id) {
             return *it;
         }
         range_id
     }
 
-    fn get_file_id(&mut self, id: FileId) -> Id {
+    fn get_file_id(
+        &mut self,
+        id: FileId,
+    ) -> Id {
         if let Some(it) = self.file_map.get(&id) {
             return *it;
         }
         doc_id
     }
 
-    fn add_token(&mut self, id: TokenId, token: TokenStaticData) {
+    fn add_token(
+        &mut self,
+        id: TokenId,
+        token: TokenStaticData,
+    ) {
         let result_set_id = self.get_token_id(id);
         if let Some(hover) = token.hover {
             let hover_id = self.add_vertex(lsif::Vertex::HoverResult {
             let mut edges = token.references.iter().fold(
                 FxHashMap::<_, Vec<lsp_types::NumberOrString>>::default(),
                 |mut edges, it| {
-                    let entry = edges
-                        .entry((it.range.file_id, it.is_definition))
-                        .or_default();
+                    let entry = edges.entry((it.range.file_id, it.is_definition)).or_default();
                     entry.push((*self.range_map.get(&it.range).unwrap()).into());
                     edges
                 },
         }
     }
 
-    fn add_file(&mut self, file: StaticIndexedFile) {
-        let StaticIndexedFile {
-            file_id,
-            tokens,
-            folds,
-            ..
-        } = file;
+    fn add_file(
+        &mut self,
+        file: StaticIndexedFile,
+    ) {
+        let StaticIndexedFile { file_id, tokens, folds, .. } = file;
         let doc_id = self.get_file_id(file_id);
         let text = self.analysis.file_text(file_id).unwrap();
         let line_index = self.db.line_index(file_id);
                     range: to_proto::range(&line_index, range),
                     tag: None,
                 });
-                self.range_map
-                    .insert(FileRange { file_id, range }, range_id);
+                self.range_map.insert(FileRange { file_id, range }, range_id);
                 let result_set_id = self.get_token_id(id);
                 self.add_edge(lsif::Edge::Next(lsif::EdgeData {
                     in_v: result_set_id.into(),
         sysroot: Option<RustLibSource>,
     ) -> anyhow::Result<()> {
         let now = Instant::now();
-        let cargo_config = &CargoConfig {
-            sysroot,
-            all_targets: true,
-            set_test: true,
-            ..Default::default()
-        };
+        let cargo_config =
+            &CargoConfig { sysroot, all_targets: true, set_test: true, ..Default::default() };
         let no_progress = &|_| ();
         let load_cargo_config = LoadCargoConfig {
             load_out_dirs_from_check: true,
         let root = ProjectManifest::discover_single(&path)?;
         eprintln!("Generating LSIF for project at {root}");
         let mut workspace = ProjectWorkspace::load(root, cargo_config, no_progress)?;
-
         let build_scripts = workspace.run_build_scripts(cargo_config, no_progress)?;
         workspace.set_build_scripts(build_scripts);
-
         let (db, vfs, _proc_macro) =
             load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;
         let host = AnalysisHost::with_database(db);
         let db = host.raw_database();
         let analysis = host.analysis();
-
         let vendored_libs_config = if self.exclude_vendored_libraries {
             VendoredLibrariesConfig::Excluded
         } else {
-            VendoredLibrariesConfig::Included {
-                workspace_root: &path.clone().into(),
-            }
+            VendoredLibrariesConfig::Included { workspace_root: &path.clone().into() }
         };
-
         let si = StaticIndex::compute(&analysis, vendored_libs_config);
-
         let mut lsif = LsifManager::new(&analysis, db, &vfs, out);
         lsif.add_vertex(lsif::Vertex::MetaData(lsif::MetaData {
             version: String::from("0.5.0"),