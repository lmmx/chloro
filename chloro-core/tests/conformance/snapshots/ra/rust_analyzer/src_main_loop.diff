COMPARISON DIFF
============================================================

Original size: 58838 bytes
Chloro size:   57876 bytes
Rustfmt size:  58838 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     time::{Duration, Instant},
 };
 
-use crossbeam_channel::{Receiver, never, select};
-use ide_db::base_db::{SourceDatabase, VfsPath, salsa::Database as _};
+use crossbeam_channel::{never, select, Receiver};
+use ide_db::base_db::{salsa::Database as _, SourceDatabase, VfsPath};
 use lsp_server::{Connection, Notification, Request};
-use lsp_types::{TextDocumentIdentifier, notification::Notification as _};
+use lsp_types::{notification::Notification as _, TextDocumentIdentifier};
 use stdx::thread::ThreadIntent;
-use tracing::{Level, error, span};
-use vfs::{AbsPathBuf, FileId, loader::LoadingProgress};
+use tracing::{error, span, Level};
+use vfs::{loader::LoadingProgress, AbsPathBuf, FileId};
 
 use crate::{
     config::Config,
-    diagnostics::{DiagnosticsGeneration, NativeDiagnosticsFetchKind, fetch_native_diagnostics},
+    diagnostics::{fetch_native_diagnostics, DiagnosticsGeneration, NativeDiagnosticsFetchKind},
     discover::{DiscoverArgument, DiscoverCommand, DiscoverProjectMessage},
     flycheck::{self, ClearDiagnosticsKind, ClearScope, FlycheckMessage},
     global_state::{
-        FetchBuildDataResponse, FetchWorkspaceRequest, FetchWorkspaceResponse, GlobalState,
-        file_id_to_url, url_to_file_id,
+        file_id_to_url, url_to_file_id, FetchBuildDataResponse, FetchWorkspaceRequest,
+        FetchWorkspaceResponse, GlobalState,
     },
     handlers::{
-        dispatch::{NotificationDispatcher, RequestDispatcher},
-        request::empty_diagnostic_report,
-    },
-    lsp::{
-        from_proto, to_proto,
-        utils::{Progress, notification_is},
+        dispatch::{NotificationDispatcher, RequestDispatcher}, request::empty_diagnostic_report,
     },
+    lsp::{from_proto, to_proto, utils::{Progress, notification_is}},
     lsp_ext,
     reload::{BuildDataProgress, ProcMacroProgress, ProjectWorkspaceProgress},
     test_runner::{CargoTestMessage, CargoTestOutput, TestState},
     tracing::info!("initial config: {:#?}", config);
 
     // Windows scheduler implements priority boosts: if thread waits for an
+
     // event (like a condvar), and event fires, priority of the thread is
+
     // temporary bumped. This optimization backfires in our case: each time the
+
     // `main_loop` schedules a task to run on a threadpool, the worker threads
+
     // gets a higher priority, and (on a machine with fewer cores) displaces the
+
     // main loop! We work around this by marking the main loop as a
+
     // higher-priority thread.
+
     //
+
     // https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities
+
     // https://docs.microsoft.com/en-us/windows/win32/procthread/priority-boosts
+
     // https://github.com/rust-lang/rust-analyzer/issues/2835
     #[cfg(windows)]
     unsafe {
 pub(crate) enum PrimeCachesProgress {
     Begin,
     Report(ide::ParallelPrimeCachesProgress),
-    End { cancelled: bool },
+    End {
+        cancelled: bool,
+    },
 }
 
 impl fmt::Debug for Event {
             recv(self.fetch_ws_receiver.as_ref().map_or(&never(), |(chan, _)| chan)) -> _instant => {
                 Ok(Event::FetchWorkspaces(self.fetch_ws_receiver.take().unwrap().1))
             },
-        }
-        .map(Some)
+        }.map(
+            Some,
+        )
     }
 
     fn handle_event(&mut self, event: Event) {
             if slice.is_empty() {
                 break;
             }
-            // Diagnostics are triggered by the user typing
-            // so we run them on a latency sensitive thread.
             let snapshot = self.snapshot();
             self.task_pool.handle.spawn_with_sender(ThreadIntent::LatencySensitive, {
                 let subscriptions = subscriptions.clone();
         tracing::trace!("updating tests for {:?}", subscriptions);
 
         // Updating tests are triggered by the user typing
+
         // so we run them on a latency sensitive thread.
         self.task_pool.handle.spawn(ThreadIntent::LatencySensitive, {
             let snapshot = self.snapshot();
         let status = self.current_status();
         if self.last_reported_status != status {
             self.last_reported_status = status.clone();
-
             if self.config.server_status_notification() {
                 self.send_notification::<lsp_ext::ServerStatusNotification>(status);
             } else if let (
                 health @ (lsp_ext::Health::Warning | lsp_ext::Health::Error),
                 Some(message),
-            ) = (status.health, &status.message)
-            {
+            ) = (status.health, &status.message) {
                 let open_log_button = tracing::enabled!(tracing::Level::ERROR)
                     && (self.fetch_build_data_error().is_err()
                         || self.fetch_workspace_error().is_err());
     fn handle_task(&mut self, prime_caches_progress: &mut Vec<PrimeCachesProgress>, task: Task) {
         match task {
             Task::Response(response) => self.respond(response),
-            // Only retry requests that haven't been cancelled. Otherwise we do unnecessary work.
             Task::Retry(req) if !self.is_completed(&req) => self.on_request(req),
             Task::Retry(_) => (),
             Task::Diagnostics(kind) => {
                 self.diagnostics.set_native_diagnostics(kind);
-            }
+            },
             Task::PrimeCaches(progress) => match progress {
                 PrimeCachesProgress::Begin => prime_caches_progress.push(progress),
                 PrimeCachesProgress::Report(_) => {
                     match prime_caches_progress.last_mut() {
                         Some(last @ PrimeCachesProgress::Report(_)) => {
-                            // Coalesce subsequent update events.
                             *last = progress;
-                        }
+                        },
                         _ => prime_caches_progress.push(progress),
                     }
-                }
+                },
                 PrimeCachesProgress::End { .. } => prime_caches_progress.push(progress),
             },
             Task::FetchWorkspace(progress) => {
                         (Progress::End, None)
                     }
                 };
-
                 self.report_progress("Fetching", state, msg, None, None);
-            }
+            },
             Task::DiscoverLinkedProjects(arg) => {
-                if let Some(cfg) = self.config.discover_workspace_config()
-                    && !self.discover_workspace_queue.op_in_progress()
-                {
-                    // the clone is unfortunately necessary to avoid a borrowck error when
-                    // `self.report_progress` is called later
+                if let Some(cfg) = self.config.discover_workspace_config() && !self.discover_workspace_queue.op_in_progress() {
                     let title = &cfg.progress_label.clone();
                     let command = cfg.command.clone();
                     let discover = DiscoverCommand::new(self.discover_sender.clone(), command);
-
                     self.report_progress(title, Progress::Begin, None, None, None);
                     self.discover_workspace_queue
                         .request_op("Discovering workspace".to_owned(), ());
                     let _ = self.discover_workspace_queue.should_start_op();
-
                     let arg = match arg {
                         DiscoverProjectParam::Buildfile(it) => DiscoverArgument::Buildfile(it),
                         DiscoverProjectParam::Path(it) => DiscoverArgument::Path(it),
                     };
-
                     let handle = discover.spawn(
                         arg,
                         &std::env::current_dir()
                         panic!("Failed to spawn project discovery command: {e}")
                     }));
                 }
-            }
+            },
             Task::FetchBuildData(progress) => {
                 let (state, msg) = match progress {
                     BuildDataProgress::Begin => (Some(Progress::Begin), None),
                         (Some(Progress::End), None)
                     }
                 };
-
                 if let Some(state) = state {
                     self.report_progress("Building compile-time-deps", state, msg, None, None);
                 }
-            }
+            },
             Task::LoadProcMacros(progress) => {
                 let (state, msg) = match progress {
                     ProcMacroProgress::Begin => (Some(Progress::Begin), None),
                         (Some(Progress::End), None)
                     }
                 };
-
                 if let Some(state) = state {
                     self.report_progress("Loading proc-macros", state, msg, None, None);
                 }
-            }
+            },
             Task::BuildDepsHaveChanged => self.build_deps_changed = true,
             Task::DiscoverTest(tests) => {
                 self.send_notification::<lsp_ext::DiscoveredTests>(tests);
-            }
+            },
         }
     }
 
                             .as_ref()
                             .and_then(|contents| String::from_utf8(contents.clone()).ok());
                     }
-
                     let path = VfsPath::from(path);
-                    // if the file is in mem docs, it's managed by the client via notifications
-                    // so only set it if its not in there
-                    if !self.mem_docs.contains(&path)
-                        && (is_changed || vfs.file_id(&path).is_none())
-                    {
+                    if !self.mem_docs.contains(&path) && (is_changed || vfs.file_id(&path).is_none()) {
                         vfs.set_file_contents(path, contents);
                     }
                 }
-            }
+            },
             vfs::loader::Message::Progress { n_total, n_done, dir, config_version } => {
                 let _p = span!(Level::INFO, "GlobalState::handle_vfs_msg/progress").entered();
                 stdx::always!(config_version <= self.vfs_config_version);
-
                 let (n_done, state) = match n_done {
                     LoadingProgress::Started => {
                         self.vfs_span =
                         (n_total, Progress::End)
                     }
                 };
-
                 self.vfs_progress_config_version = config_version;
                 self.vfs_done = state == Progress::End;
-
                 let mut message = format!("{n_done}/{n_total}");
                 if let Some(dir) = dir {
                     message += &format!(
                         }
                     );
                 }
-
                 self.report_progress(
                     "Roots Scanned",
                     state,
                     Some(Progress::fraction(n_done, n_total)),
                     None,
                 );
-            }
+            },
         }
     }
 
         match task {
             QueuedTask::CheckIfIndexed(uri) => {
                 let snap = self.snapshot();
-
                 self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {
                     let _p = tracing::info_span!("GlobalState::check_if_indexed").entered();
                     tracing::debug!(?uri, "handling uri");
                         }
                     }
                 });
-            }
+            },
             QueuedTask::CheckProcMacroSources(modified_rust_files) => {
                 let analysis = AssertUnwindSafe(self.snapshot().analysis);
                 self.task_pool.handle.spawn_with_sender(stdx::thread::ThreadIntent::Worker, {
                         }
                     }
                 });
-            }
+            },
         }
     }
 
                 self.discover_handle = None;
                 self.report_progress(&title, Progress::End, None, None, None);
                 self.discover_workspace_queue.op_completed(());
-
                 let mut config = Config::clone(&*self.config);
                 config.add_discovered_project_from_command(project, buildfile);
                 self.update_configuration(config);
-            }
+            },
             DiscoverProjectMessage::Progress { message } => {
                 self.report_progress(&title, Progress::Report, Some(message), None, None)
-            }
+            },
             DiscoverProjectMessage::Error { error, source } => {
                 self.discover_handle = None;
                 let message = format!("Project discovery failed: {error}");
                 self.discover_workspace_queue.op_completed(());
                 self.show_and_log_error(message.clone(), source);
                 self.report_progress(&title, Progress::End, Some(message), None, None)
-            }
+            },
         }
     }
 
                     TestState::Ok => lsp_ext::TestState::Passed,
                     TestState::Failed { stdout } => lsp_ext::TestState::Failed { message: stdout },
                 };
-
-                // The notification requires the namespace form (with underscores) of the target
                 let test_id = format!("{}::{name}", message.target.target.replace('-', "_"));
-
                 self.send_notification::<lsp_ext::ChangeTestState>(
                     lsp_ext::ChangeTestStateParams { test_id, state },
                 );
-            }
+            },
             CargoTestOutput::Suite => (),
             CargoTestOutput::Finished => {
                 self.test_run_remaining_jobs = self.test_run_remaining_jobs.saturating_sub(1);
                     self.send_notification::<lsp_ext::EndRunTest>(());
                     self.test_run_session = None;
                 }
-            }
+            },
             CargoTestOutput::Custom { text } => {
                 self.send_notification::<lsp_ext::AppendOutputToRunTest>(text);
-            }
+            },
         }
     }
 
                         }
                     };
                 }
-            }
+            },
             FlycheckMessage::ClearDiagnostics {
                 id,
                 kind: ClearDiagnosticsKind::All(ClearScope::Workspace),
                         (Progress::End, None)
                     }
                 };
-
-                // When we're running multiple flychecks, we have to include a disambiguator in
-                // the title, or the editor complains. Note that this is a user-facing string.
                 let title = if self.flycheck.len() == 1 {
                     format!("{}", self.config.flycheck(None))
                 } else {
                     None,
                     Some(format!("rust-analyzer/flycheck/{id}")),
                 );
-            }
+            },
         }
     }
 