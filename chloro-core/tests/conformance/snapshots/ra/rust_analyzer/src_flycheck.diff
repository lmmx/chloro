COMPARISON DIFF
============================================================

Original size: 31299 bytes
Chloro size:   31361 bytes
Rustfmt size:  32289 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use paths::{AbsPath, AbsPathBuf, Utf8Path, Utf8PathBuf};
 use project_model::TargetDirectoryConfig;
 use rustc_hash::FxHashMap;
-use serde::Deserialize as _;
 use serde_derive::Deserialize;
+use serde::Deserialize as _;
 
 pub(crate) use cargo_metadata::diagnostic::{
     Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,
     pub(crate) fn invocation_strategy(&self) -> InvocationStrategy {
         match self {
             FlycheckConfig::CargoCommand { .. } => InvocationStrategy::PerWorkspace,
-            FlycheckConfig::CustomCommand {
-                invocation_strategy,
-                ..
-            } => invocation_strategy.clone(),
+            FlycheckConfig::CustomCommand { invocation_strategy, .. } => {
+                invocation_strategy.clone()
+            }
         }
     }
 }
                 // in the IDE (e.g. in the VS Code status bar).
                 let display_args = args
                     .iter()
-                    .map(|arg| {
-                        if arg == SAVED_FILE_PLACEHOLDER {
-                            "..."
-                        } else {
-                            arg
-                        }
-                    })
+                    .map(|arg| if arg == SAVED_FILE_PLACEHOLDER { "..." } else { arg })
                     .collect::<Vec<_>>();
 
                 write!(f, "{command} {}", display_args.join(" "))
             stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker, format!("Flycheck{id}"))
                 .spawn(move || actor.run(receiver))
                 .expect("failed to spawn thread");
-        FlycheckHandle {
-            id,
-            generation: generation.into(),
-            sender,
-            _thread: thread,
-        }
+        FlycheckHandle { id, generation: generation.into(), sender, _thread: thread }
     }
 
     /// Schedule a re-start of the cargo check worker to do a workspace wide check.
         self.sender
             .send(StateChange::Restart {
                 generation,
-                scope: FlycheckScope::Package {
-                    package,
-                    workspace_deps,
-                },
+                scope: FlycheckScope::Package { package, workspace_deps },
                 saved_file: None,
                 target,
             })
                 .field("generation", generation)
                 .field("workspace_root", workspace_root)
                 .field("package_id", package_id)
-                .field(
-                    "diagnostic_code",
-                    &diagnostic.code.as_ref().map(|it| &it.code),
-                )
-                .finish(),
-            FlycheckMessage::ClearDiagnostics { id, kind } => f
-                .debug_struct("ClearDiagnostics")
-                .field("id", id)
-                .field("kind", kind)
-                .finish(),
-            FlycheckMessage::Progress { id, progress } => f
-                .debug_struct("Progress")
-                .field("id", id)
-                .field("progress", progress)
+                .field("diagnostic_code", &diagnostic.code.as_ref().map(|it| &it.code))
                 .finish(),
+            FlycheckMessage::ClearDiagnostics { id, kind } => {
+                f.debug_struct("ClearDiagnostics").field("id", id).field("kind", kind).finish()
+            }
+            FlycheckMessage::Progress { id, progress } => {
+                f.debug_struct("Progress").field("id", id).field("progress", progress).finish()
+            }
         }
     }
 }
 struct FlycheckActor {
     /// The workspace id of this flycheck instance.
     id: usize,
-
     generation: DiagnosticsGeneration,
     sender: Sender<FlycheckMessage>,
     config: FlycheckConfig,
     }
 
     fn report_progress(&self, progress: Progress) {
-        self.send(FlycheckMessage::Progress {
-            id: self.id,
-            progress,
-        });
+        self.send(FlycheckMessage::Progress { id: self.id, progress });
     }
 
     fn next_event(&self, inbox: &Receiver<StateChange>) -> Option<Event> {
                                     kind: ClearDiagnosticsKind::All(ClearScope::Workspace),
                                 });
                             }
-                            FlycheckScope::Package {
-                                package,
-                                workspace_deps,
-                            } => {
+                            FlycheckScope::Package { package, workspace_deps } => {
                                 for pkg in
                                     std::iter::once(package).chain(workspace_deps.iter().flatten())
                                 {
                                     ),
                                 });
                             }
-                            FlycheckScope::Package {
-                                package,
-                                workspace_deps,
-                            } => {
+                            FlycheckScope::Package { package, workspace_deps } => {
                                 for pkg in
                                     std::iter::once(package).chain(workspace_deps.iter().flatten())
                                 {
                             });
                         }
                     }
-                    CargoCheckMessage::Diagnostic {
-                        diagnostic,
-                        package_id,
-                    } => {
+                    CargoCheckMessage::Diagnostic { diagnostic, package_id } => {
                         tracing::trace!(
                             flycheck_id = self.id,
                             message = diagnostic.message,
         target: Option<Target>,
     ) -> Option<Command> {
         match &self.config {
-            FlycheckConfig::CargoCommand {
-                command,
-                options,
-                ansi_color_output,
-            } => {
+            FlycheckConfig::CargoCommand { command, options, ansi_color_output } => {
                 let mut cmd =
                     toolchain::command(Tool::Cargo.path(), &*self.root, &options.extra_env);
                 if let Some(sysroot_root) = &self.sysroot_root
                     && !options.extra_env.contains_key("RUSTUP_TOOLCHAIN")
                     && std::env::var_os("RUSTUP_TOOLCHAIN").is_none()
                 {
-                    cmd.env(
-                        "RUSTUP_TOOLCHAIN",
-                        AsRef::<std::path::Path>::as_ref(sysroot_root),
-                    );
+                    cmd.env("RUSTUP_TOOLCHAIN", AsRef::<std::path::Path>::as_ref(sysroot_root));
                 }
                 cmd.env("CARGO_LOG", "cargo::core::compiler::fingerprint=info");
                 cmd.arg(command);
                 cmd.args(&options.extra_args);
                 Some(cmd)
             }
-            FlycheckConfig::CustomCommand {
-                command,
-                args,
-                extra_env,
-                invocation_strategy,
-            } => {
+            FlycheckConfig::CustomCommand { command, args, extra_env, invocation_strategy } => {
                 let root = match invocation_strategy {
                     InvocationStrategy::Once => &*self.root,
                     InvocationStrategy::PerWorkspace => {
                     }
                     _ => None,
                 },
-                JsonMessage::Rustc(message) => Some(CargoCheckMessage::Diagnostic {
-                    diagnostic: message,
-                    package_id: None,
-                }),
+                JsonMessage::Rustc(message) => {
+                    Some(CargoCheckMessage::Diagnostic { diagnostic: message, package_id: None })
+                }
             };
         }
 