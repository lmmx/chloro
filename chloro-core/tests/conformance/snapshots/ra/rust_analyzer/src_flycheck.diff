COMPARISON DIFF
============================================================

Original size: 31299 bytes
Chloro size:   31529 bytes
Rustfmt size:  31299 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Flycheck provides the functionality needed to run `cargo check` to provide
 //! LSP diagnostics based on the output of the command.
 
 use std::{
-    fmt, io,
-    process::Command,
-    sync::atomic::{AtomicUsize, Ordering},
-    time::Duration,
+    fmt, io, process::Command, sync::atomic::{AtomicUsize, Ordering}, time::Duration,
 };
 
 use cargo_metadata::PackageId;
+pub(crate) use cargo_metadata::diagnostic::{
+    Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,
+};
 use crossbeam_channel::{Receiver, Sender, select_biased, unbounded};
 use ide_db::FxHashSet;
 use itertools::Itertools;
 use rustc_hash::FxHashMap;
 use serde::Deserialize as _;
 use serde_derive::Deserialize;
-
-pub(crate) use cargo_metadata::diagnostic::{
-    Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,
-};
 use toolchain::Tool;
 use triomphe::Arc;
 
 }
 
 impl CargoOptions {
-    pub(crate) fn apply_on_command(&self, cmd: &mut Command, ws_target_dir: Option<&Utf8Path>) {
+    pub(crate) fn apply_on_command(
+        &self,
+        cmd: &mut Command,
+        ws_target_dir: Option<&Utf8Path>,
+    ) {
         for target in &self.target_tuples {
             cmd.args(["--target", target.as_str()]);
         }
 }
 
 impl fmt::Display for FlycheckConfig {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         match self {
             FlycheckConfig::CargoCommand { command, .. } => write!(f, "cargo {command}"),
             FlycheckConfig::CustomCommand { command, args, .. } => {
 /// The spawned thread is shut down when this struct is dropped.
 #[derive(Debug)]
 pub(crate) struct FlycheckHandle {
-    // XXX: drop order is significant
     sender: Sender<StateChange>,
     _thread: stdx::thread::JoinHandle,
     id: usize,
     }
 
     /// Schedule a re-start of the cargo check worker to do a workspace wide check.
-    pub(crate) fn restart_workspace(&self, saved_file: Option<AbsPathBuf>) {
+    pub(crate) fn restart_workspace(
+        &self,
+        saved_file: Option<AbsPathBuf>,
+    ) {
         let generation = self.generation.fetch_add(1, Ordering::Relaxed) + 1;
         self.sender
             .send(StateChange::Restart {
         diagnostic: Diagnostic,
         package_id: Option<Arc<PackageId>>,
     },
-
     /// Request clearing all outdated diagnostics.
-    ClearDiagnostics { id: usize, kind: ClearDiagnosticsKind },
-
+    ClearDiagnostics {
+        id: usize,
+        kind: ClearDiagnosticsKind,
+    },
     /// Request check progress notification to client
     Progress {
         /// Flycheck instance ID
 }
 
 impl fmt::Debug for FlycheckMessage {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         match self {
             FlycheckMessage::AddDiagnostic {
                 id,
 
 enum FlycheckScope {
     Workspace,
-    Package { package: Arc<PackageId>, workspace_deps: Option<FxHashSet<Arc<PackageId>>> },
+    Package {
+        package: Arc<PackageId>,
+        workspace_deps: Option<FxHashSet<Arc<PackageId>>>,
+    },
 }
 
 enum StateChange {
 struct FlycheckActor {
     /// The workspace id of this flycheck instance.
     id: usize,
-
     generation: DiagnosticsGeneration,
     sender: Sender<FlycheckMessage>,
     config: FlycheckConfig,
         }
     }
 
-    fn report_progress(&self, progress: Progress) {
+    fn report_progress(
+        &self,
+        progress: Progress,
+    ) {
         self.send(FlycheckMessage::Progress { id: self.id, progress });
     }
 
-    fn next_event(&self, inbox: &Receiver<StateChange>) -> Option<Event> {
+    fn next_event(
+        &self,
+        inbox: &Receiver<StateChange>,
+    ) -> Option<Event> {
         let Some(command_receiver) = &self.command_receiver else {
             return inbox.recv().ok().map(Event::RequestStateChange);
         };
-
         // Biased to give restarts a preference so check outputs don't block a restart or stop
         select_biased! {
             recv(inbox) -> msg => msg.ok().map(Event::RequestStateChange),
         }
     }
 
-    fn run(mut self, inbox: Receiver<StateChange>) {
+    fn run(
+        mut self,
+        inbox: Receiver<StateChange>,
+    ) {
         'event: while let Some(event) = self.next_event(&inbox) {
             match event {
                 Event::RequestStateChange(StateChange::Cancel) => {
     }
 
     #[track_caller]
-    fn send(&self, check_task: FlycheckMessage) {
+    fn send(
+        &self,
+        check_task: FlycheckMessage,
+    ) {
         self.sender.send(check_task).unwrap();
     }
 }
 #[allow(clippy::large_enum_variant)]
 enum CargoCheckMessage {
     CompilerArtifact(cargo_metadata::Artifact),
-    Diagnostic { diagnostic: Diagnostic, package_id: Option<Arc<PackageId>> },
+    Diagnostic {
+        diagnostic: Diagnostic,
+        package_id: Option<Arc<PackageId>>,
+    },
 }
 
 struct CargoCheckParser;
 
 impl CargoParser<CargoCheckMessage> for CargoCheckParser {
-    fn from_line(&self, line: &str, error: &mut String) -> Option<CargoCheckMessage> {
+    fn from_line(
+        &self,
+        line: &str,
+        error: &mut String,
+    ) -> Option<CargoCheckMessage> {
         let mut deserializer = serde_json::Deserializer::from_str(line);
         deserializer.disable_recursion_limit();
         if let Ok(message) = JsonMessage::deserialize(&mut deserializer) {
                 }
             };
         }
-
         error.push_str(line);
         error.push('\n');
         None