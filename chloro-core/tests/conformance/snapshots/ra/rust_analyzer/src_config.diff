COMPARISON DIFF
============================================================

Original size: 167117 bytes
Chloro size:   166246 bytes
Rustfmt size:  167117 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Config used by the language server.
 //!
 //! Of particular interest is the `feature_flags` hash map: while other fields
 //! configure the server itself, feature flags are passed into analysis, and
 //! tweak things like automatic insertion of `()` in completions.
+
 use std::{env, fmt, iter, ops::Not, sync::OnceLock};
 
 use cfg::{CfgAtom, CfgDiff};
 use hir::Symbol;
+use ide_db::{
+    MiniCore, SnippetCap,
+    assists::ExprFillDefaultMode,
+    imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},
+};
 use ide::{
     AnnotationConfig, AssistConfig, CallHierarchyConfig, CallableSnippets, CompletionConfig,
     CompletionFieldsToResolve, DiagnosticsConfig, GenericParameterHints, GotoDefinitionConfig,
     InlayFieldsToResolve, InlayHintsConfig, JoinLinesConfig, MemoryLayoutHoverConfig,
     MemoryLayoutHoverRenderKind, RenameConfig, Snippet, SnippetScope, SourceRootId,
 };
-use ide_db::{
-    MiniCore, SnippetCap,
-    assists::ExprFillDefaultMode,
-    imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},
-};
 use itertools::{Either, Itertools};
 use paths::{Utf8Path, Utf8PathBuf};
 use project_model::{
 use crate::{
     diagnostics::DiagnosticsMapConfig,
     flycheck::{CargoOptions, FlycheckConfig},
-    lsp::capabilities::ClientCapabilities,
     lsp_ext::{WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},
+    lsp::capabilities::ClientCapabilities,
 };
 
 type FxIndexMap<K, V> = indexmap::IndexMap<K, V, rustc_hash::FxBuildHasher>;
 mod patch_old_style;
 
 // Conventions for configuration keys to preserve maximal extendability without breakage:
-//  - Toggles (be it binary true/false or with more options in-between) should almost always suffix as `_enable`
-//    This has the benefit of namespaces being extensible, and if the suffix doesn't fit later it can be changed without breakage.
-//  - In general be wary of using the namespace of something verbatim, it prevents us from adding subkeys in the future
-//  - Don't use abbreviations unless really necessary
-//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command
 
+//  - Toggles (be it binary true/false or with more options in-between) should almost always suffix as `_enable`
+
+//    This has the benefit of namespaces being extensible, and if the suffix doesn't fit later it can be changed without breakage.
+
+//  - In general be wary of using the namespace of something verbatim, it prevents us from adding subkeys in the future
+
+//  - Don't use abbreviations unless really necessary
+
+//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command
 #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
 #[serde(rename_all = "camelCase")]
 pub enum MaxSubstitutionLength {
     Limit(usize),
 }
 
-// Defines the server-side configuration of the rust-analyzer. We generate *parts* of VS Code's
-// `package.json` config from this. Run `cargo test` to re-generate that file.
-//
-// However, editor specific config, which the server doesn't know about, should be specified
-// directly in `package.json`.
-//
-// To deprecate an option by replacing it with another name use `new_name` | `old_name` so that we
-// keep parsing the old name.
 config_data! {
     /// Configs that apply on a workspace-wide scope. There are 2 levels on which a global
     /// configuration can be configured
     root_path: AbsPathBuf,
     snippets: Vec<Snippet>,
     client_info: Option<ClientInfo>,
-
     default_config: &'static DefaultConfigData,
     /// Config node that obtains its initial value during the server initialization and
     /// by receiving a `lsp_types::notification::DidChangeConfiguration`.
     client_config: (FullConfigInput, ConfigErrors),
-
     /// Config node whose values apply to **every** Rust project.
     user_config: Option<(GlobalWorkspaceLocalConfigInput, ConfigErrors)>,
-
     ratoml_file: FxHashMap<SourceRootId, (RatomlFile, ConfigErrors)>,
-
     /// Clone of the value that is stored inside a `GlobalState`.
     source_root_parent_map: Arc<FxHashMap<SourceRootId, SourceRootId>>,
-
     /// Use case : It is an error to have an empty value for `check_command`.
     /// Since it is a `global` command at the moment, its final value can only be determined by
     /// traversing through `global` configs and the `client` config. However the non-null value constraint
     /// is config level agnostic, so this requires an independent error storage
     validation_errors: ConfigErrors,
-
     detached_files: Vec<AbsPathBuf>,
 }
 
     }
 }
 
-// Delegate capability fetching methods
 impl std::ops::Deref for Config {
     type Target = ClientCapabilities;
 
         Arc::ptr_eq(&self.source_root_parent_map, other)
     }
 
-    // FIXME @alibektas : Server's health uses error sink but in other places it is not used atm.
     /// Changes made to client and global configurations will partially not be reflected even after `.apply_change()` was called.
     /// The return tuple's bool component signals whether the `GlobalState` should call its `update_configuration()` method.
     fn apply_change_with_sink(&self, change: ConfigChange) -> (Config, bool) {
 pub struct ConfigChange {
     user_config_change: Option<Arc<str>>,
     client_config_change: Option<serde_json::Value>,
-    ratoml_file_change:
-        Option<FxHashMap<SourceRootId, (RatomlFileKind, VfsPath, Option<Arc<str>>)>>,
+    ratoml_file_change: Option<FxHashMap<SourceRootId, (RatomlFileKind, VfsPath, Option<Arc<str>>)>>,
     source_map_change: Option<Arc<FxHashMap<SourceRootId, SourceRootId>>>,
 }
 
     }
 
     pub fn change_user_config(&mut self, content: Option<Arc<str>>) {
-        assert!(self.user_config_change.is_none()); // Otherwise it is a double write.
+        assert!(self.user_config_change.is_none());
+        // Otherwise it is a double write.
         self.user_config_change = content;
     }
 
     pub debug: bool,
     pub update_test: bool,
     pub interpret: bool,
-
     // implementations
     pub implementations: bool,
-
     // references
     pub method_refs: bool,
-    pub refs_adt: bool,   // for Struct, Enum, Union and Trait
-    pub refs_trait: bool, // for Struct, Enum, Union and Trait
+    pub refs_adt: bool,
+    // for Struct, Enum, Union and Trait
+    pub refs_trait: bool,
+    // for Struct, Enum, Union and Trait
     pub enum_variant_refs: bool,
-
     // annotations
     pub location: AnnotationLocation,
     pub filter_adjacent_derive_implementations: bool,
 
 impl LensConfig {
     pub fn any(&self) -> bool {
-        self.run
-            || self.debug
-            || self.update_test
-            || self.implementations
-            || self.method_refs
-            || self.refs_adt
-            || self.refs_trait
-            || self.enum_variant_refs
+        self.run || self.debug || self.update_test || self.implementations || self.method_refs || self.refs_adt || self.refs_trait || self.enum_variant_refs
     }
 
     pub fn none(&self) -> bool {
 
 #[derive(Debug, Clone)]
 pub enum RustfmtConfig {
-    Rustfmt { extra_args: Vec<String>, enable_range_formatting: bool },
-    CustomCommand { command: String, args: Vec<String> },
+    Rustfmt {
+        extra_args: Vec<String>,
+        enable_range_formatting: bool,
+    },
+    CustomCommand {
+        command: String,
+        args: Vec<String>,
+    },
 }
 
 /// Configuration for runnable items, such as `main` function or tests.
     /// How many items are returned at most.
     pub search_limit: usize,
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub struct ClientCommandsConfig {
     pub run_single: bool,
 
 #[derive(Debug)]
 pub enum ConfigErrorInner {
-    Json { config_key: String, error: serde_json::Error },
-    Toml { config_key: String, error: toml::de::Error },
-    ParseError { reason: String },
+    Json {
+        config_key: String,
+        error: serde_json::Error,
+    },
+    Toml {
+        config_key: String,
+        error: toml::de::Error,
+    },
+    ParseError {
+        reason: String,
+    },
 }
 
 #[derive(Clone, Debug, Default)]
     }
 }
 
-impl std::error::Error for ConfigErrors {}
+impl std::error::Error for ConfigErrors {
+}
 
 impl Config {
     pub fn new(
         DiagnosticsConfig {
             enabled: true,
             disable_experimental: false,
-            ..self.diagnostics(source_root)
         }
     }
 
     }
 
     pub(crate) fn completion_snippets_default() -> FxIndexMap<String, SnippetDef> {
-        serde_json::from_str(
-            r#"{
+        serde_json::from_str(r#"{
             "Ok": {
                 "postfix": "ok",
                 "body": "Ok(${receiver})",
                 "description": "Put the expression into an `Rc`",
                 "scope": "expr"
             }
-        }"#,
-        )
-        .unwrap()
+        }"#).unwrap()
     }
 
     pub fn rustfmt(&self, source_root_id: Option<SourceRootId>) -> RustfmtConfig {
                     features: match self
                         .check_features(source_root)
                         .clone()
-                        .unwrap_or_else(|| self.cargo_features(source_root).clone())
-                    {
+                        .unwrap_or_else(|| self.cargo_features(source_root).clone()) {
                         CargoFeaturesDef::All => vec![],
                         CargoFeaturesDef::Selected(it) => it,
                     },
         LensConfig {
             run: *self.lens_enable() && *self.lens_run_enable(),
             debug: *self.lens_enable() && *self.lens_debug_enable(),
-            update_test: *self.lens_enable()
-                && *self.lens_updateTest_enable()
-                && *self.lens_run_enable(),
+            update_test: *self.lens_enable() && *self.lens_updateTest_enable() && *self.lens_run_enable(),
             interpret: *self.lens_enable() && *self.lens_run_enable() && *self.interpret_tests(),
             implementations: *self.lens_enable() && *self.lens_implementations_enable(),
             method_refs: *self.lens_enable() && *self.lens_references_method_enable(),
             refs_trait: *self.lens_enable() && *self.lens_references_trait_enable(),
             enum_variant_refs: *self.lens_enable() && *self.lens_references_enumVariant_enable(),
             location: *self.lens_location(),
-            filter_adjacent_derive_implementations: *self
-                .gotoImplementations_filterAdjacentDerives(),
+            filter_adjacent_derive_implementations: *self.gotoImplementations_filterAdjacentDerives(),
         }
     }
 
         self.typing_triggerChars().as_deref().unwrap_or_default()
     }
 
-    // VSCode is our reference implementation, so we allow ourselves to work around issues by
-    // special casing certain versions
     pub fn visual_studio_code_version(&self) -> Option<&Version> {
         self.client_info
             .as_ref()
         self.client_info.as_ref().map(|it| it.name == "Neovim").unwrap_or_default()
     }
 }
-// Deserialization definitions
 
+// Deserialization definitions
 macro_rules! create_bool_or_string_serde {
     ($ident:ident<$bool:literal, $string:literal>) => {
         mod $ident {
         }
     };
 }
+
 create_bool_or_string_serde!(true_or_always<true, "always">);
+
 create_bool_or_string_serde!(false_or_never<false, "never">);
 
 #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq)]
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     prefix: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     postfix: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     body: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     requires: Vec<String>,
-
     #[serde(skip_serializing_if = "Option::is_none")]
     description: Option<String>,
-
     scope: SnippetScopeDef,
 }
 
 mod single_or_array {
     use serde::{Deserialize, Serialize};
-
     pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Vec<String>, D::Error>
     where
         D: serde::Deserializer<'de>,
 
         deserializer.deserialize_any(SingleOrVec)
     }
-
     pub(super) fn serialize<S>(vec: &[String], serializer: S) -> Result<S::Ok, S::Error>
     where
         S: serde::Serializer,
 {
     let path = String::deserialize(de)?;
 
-    AbsPathBuf::try_from(path.as_ref())
-        .map_err(|err| serde::de::Error::custom(format!("invalid path name: {err:?}")))
+    AbsPathBuf::try_from(path.as_ref()).map_err(
+        |err| serde::de::Error::custom(format!("invalid path name: {err:?}")),
+    )
 }
 
 fn serialize_abs_pathbuf<S>(path: &AbsPathBuf, se: S) -> Result<S::Ok, S::Error>
 #[serde(rename_all = "snake_case")]
 pub enum AutoImportExclusion {
     Path(String),
-    Verbose { path: String, r#type: AutoImportExclusionType },
+    Verbose {
+        path: String,
+        r#type: AutoImportExclusionType,
+    },
 }
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
 }
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
-struct CheckOnSaveTargets(#[serde(with = "single_or_array")] Vec<String>);
+struct CheckOnSaveTargets(Vec<String>);
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
 #[serde(rename_all = "snake_case")]
 }
 
 impl GlobalWorkspaceLocalConfigInput {
-    const FIELDS: &'static [&'static [&'static str]] =
-        &[GlobalConfigInput::FIELDS, LocalConfigInput::FIELDS];
+    const FIELDS: &'static [&'static [&'static str]] = &[GlobalConfigInput::FIELDS, LocalConfigInput::FIELDS];
+
     fn from_toml(
         toml: toml::Table,
         error_sink: &mut Vec<(String, toml::de::Error)>,
 
 impl WorkspaceLocalConfigInput {
     #[allow(dead_code)]
-    const FIELDS: &'static [&'static [&'static str]] =
-        &[WorkspaceConfigInput::FIELDS, LocalConfigInput::FIELDS];
+    const FIELDS: &'static [&'static [&'static str]] = &[WorkspaceConfigInput::FIELDS, LocalConfigInput::FIELDS];
+
     fn from_toml(toml: toml::Table, error_sink: &mut Vec<(String, toml::de::Error)>) -> Self {
         Self {
             workspace: WorkspaceConfigInput::from_toml(&toml, error_sink),
             ptr.push('_');
         }
         ptr.push_str(k);
-
         match v {
             // This is a table config, any entry in it is therefore valid
             toml::Value::Table(_) if verify(ptr) => (),
                 .push((ptr.replace('_', "/"), toml::de::Error::custom("unexpected field"))),
             _ => (),
         }
-
         ptr.truncate(l);
     }
 }
 #[cfg(test)]
 mod tests {
     use std::{borrow::Cow, fs};
-
     use test_utils::{ensure_file_contents, project_root};
-
     use super::*;
-
     #[test]
     fn generate_package_json_config() {
         let s = Config::json_schema();
         schema.push_str(",\n");
 
         // Transform the asciidoc form link to markdown style.
+
         //
+
         // https://link[text] => [text](https://link)
         let url_matches = schema.match_indices("https://");
         let mut url_offsets = url_matches.map(|(idx, _)| idx).collect::<Vec<usize>>();
             ensure_file_contents(package_json_path.as_std_path(), &package_json)
         }
     }
-
     #[test]
     fn generate_config_documentation() {
         let docs_path = project_root().join("docs/book/src/configuration_generated.md");
         let expected = FullConfigInput::manual();
         ensure_file_contents(docs_path.as_std_path(), &expected);
     }
-
     fn remove_ws(text: &str) -> String {
         text.replace(char::is_whitespace, "")
     }
-
     #[test]
     fn proc_macro_srv_null() {
         let mut config =
         (config, _, _) = config.apply_change(change);
         assert_eq!(config.proc_macro_srv(), None);
     }
-
     #[test]
     fn proc_macro_srv_abs() {
         let mut config =
         (config, _, _) = config.apply_change(change);
         assert_eq!(config.proc_macro_srv(), Some(AbsPathBuf::assert(project_root())));
     }
-
     #[test]
     fn proc_macro_srv_rel() {
         let mut config =
             Some(AbsPathBuf::try_from(project_root().join("./server")).unwrap())
         );
     }
-
     #[test]
     fn cargo_target_dir_unset() {
         let mut config =
             }
         ));
     }
-
     #[test]
     fn cargo_target_dir_subdir() {
         let mut config =
                 == Some(ws_target_dir.join("rust-analyzer"))
         ));
     }
-
     #[test]
     fn cargo_target_dir_relative_dir() {
         let mut config =