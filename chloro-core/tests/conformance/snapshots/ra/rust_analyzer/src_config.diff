COMPARISON DIFF
============================================================

Original size: 167117 bytes
Chloro size:   149968 bytes
Rustfmt size:  167117 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Config used by the language server.
 //!
 //! Of particular interest is the `feature_flags` hash map: while other fields
 //! configure the server itself, feature flags are passed into analysis, and
 //! tweak things like automatic insertion of `()` in completions.
+
+mod patch_old_style;
+
 use std::{env, fmt, iter, ops::Not, sync::OnceLock};
 
 use cfg::{CfgAtom, CfgDiff};
     MemoryLayoutHoverRenderKind, RenameConfig, Snippet, SnippetScope, SourceRootId,
 };
 use ide_db::{
-    MiniCore, SnippetCap,
     assists::ExprFillDefaultMode,
     imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},
+    MiniCore, SnippetCap,
 };
 use itertools::{Either, Itertools};
 use paths::{Utf8Path, Utf8PathBuf};
 use rustc_hash::{FxHashMap, FxHashSet};
 use semver::Version;
 use serde::{
-    Deserialize, Serialize,
     de::{DeserializeOwned, Error},
+    Deserialize, Serialize,
 };
 use stdx::format_to_acc;
 use triomphe::Arc;
 use vfs::{AbsPath, AbsPathBuf, VfsPath};
+use _config_data as config_data;
+use _default_str as default_str;
+use _default_val as default_val;
+use _impl_for_config_data as impl_for_config_data;
 
 use crate::{
     diagnostics::DiagnosticsMapConfig,
 
 type FxIndexMap<K, V> = indexmap::IndexMap<K, V, rustc_hash::FxBuildHasher>;
 
-mod patch_old_style;
-
 // Conventions for configuration keys to preserve maximal extendability without breakage:
-//  - Toggles (be it binary true/false or with more options in-between) should almost always suffix as `_enable`
-//    This has the benefit of namespaces being extensible, and if the suffix doesn't fit later it can be changed without breakage.
-//  - In general be wary of using the namespace of something verbatim, it prevents us from adding subkeys in the future
-//  - Don't use abbreviations unless really necessary
-//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command
 
+//  - Toggles (be it binary true/false or with more options in-between) should almost always suffix as `_enable`
+
+//    This has the benefit of namespaces being extensible, and if the suffix doesn't fit later it can be changed without breakage.
+
+//  - In general be wary of using the namespace of something verbatim, it prevents us from adding subkeys in the future
+
+//  - Don't use abbreviations unless really necessary
+
+//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command
 #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
 #[serde(rename_all = "camelCase")]
 pub enum MaxSubstitutionLength {
     #[serde(untagged)]
     Limit(usize),
 }
-
 // Defines the server-side configuration of the rust-analyzer. We generate *parts* of VS Code's
 // `package.json` config from this. Run `cargo test` to re-generate that file.
 //
 //
 // To deprecate an option by replacing it with another name use `new_name` | `old_name` so that we
 // keep parsing the old name.
-config_data! {
-    /// Configs that apply on a workspace-wide scope. There are 2 levels on which a global
-    /// configuration can be configured
-    ///
-    /// 1. `rust-analyzer.toml` file under user's config directory (e.g
-    ///    ~/.config/rust-analyzer/rust-analyzer.toml)
-    /// 2. Client's own configurations (e.g `settings.json` on VS Code)
-    ///
-    /// A config is searched for by traversing a "config tree" in a bottom up fashion. It is chosen
-    /// by the nearest first principle.
-    global: struct GlobalDefaultConfigData <- GlobalConfigInput -> {
-        /// Warm up caches on project load.
-        cachePriming_enable: bool = true,
-
-        /// How many worker threads to handle priming caches. The default `0` means to pick
-        /// automatically.
-        cachePriming_numThreads: NumThreads = NumThreads::Physical,
-
-        /// Custom completion snippets.
-        completion_snippets_custom: FxIndexMap<String, SnippetDef> =
-            Config::completion_snippets_default(),
-
-        /// List of files to ignore
-        ///
-        /// These paths (file/directories) will be ignored by rust-analyzer. They are relative to
-        /// the workspace root, and globs are not supported. You may also need to add the folders to
-        /// Code's `files.watcherExclude`.
-        files_exclude | files_excludeDirs: Vec<Utf8PathBuf> = vec![],
-
-        /// If this is `true`, when "Goto Implementations" and in "Implementations" lens, are triggered on a `struct` or `enum` or `union`, we filter out trait implementations that originate from `derive`s above the type.
-        gotoImplementations_filterAdjacentDerives: bool = false,
-
-        /// Highlight related return values while the cursor is on any `match`, `if`, or match arm
-        /// arrow (`=>`).
-        highlightRelated_branchExitPoints_enable: bool = true,
-
-        /// Highlight related references while the cursor is on `break`, `loop`, `while`, or `for`
-        /// keywords.
-        highlightRelated_breakPoints_enable: bool = true,
-
-        /// Highlight all captures of a closure while the cursor is on the `|` or move keyword of a closure.
-        highlightRelated_closureCaptures_enable: bool = true,
-
-        /// Highlight all exit points while the cursor is on any `return`, `?`, `fn`, or return type
-        /// arrow (`->`).
-        highlightRelated_exitPoints_enable: bool = true,
-
-        /// Highlight related references while the cursor is on any identifier.
-        highlightRelated_references_enable: bool = true,
-
-        /// Highlight all break points for a loop or block context while the cursor is on any
-        /// `async` or `await` keywords.
-        highlightRelated_yieldPoints_enable: bool = true,
-
-        /// Show `Debug` action. Only applies when `#rust-analyzer.hover.actions.enable#` is set.
-        hover_actions_debug_enable: bool = true,
-
-        /// Show HoverActions in Rust files.
-        hover_actions_enable: bool = true,
-
-        /// Show `Go to Type Definition` action. Only applies when
-        /// `#rust-analyzer.hover.actions.enable#` is set.
-        hover_actions_gotoTypeDef_enable: bool = true,
-
-        /// Show `Implementations` action. Only applies when `#rust-analyzer.hover.actions.enable#`
-        /// is set.
-        hover_actions_implementations_enable: bool = true,
-
-        /// Show `References` action. Only applies when `#rust-analyzer.hover.actions.enable#` is
-        /// set.
-        hover_actions_references_enable: bool = false,
-
-        /// Show `Run` action. Only applies when `#rust-analyzer.hover.actions.enable#` is set.
-        hover_actions_run_enable: bool = true,
-
-        /// Show `Update Test` action. Only applies when `#rust-analyzer.hover.actions.enable#` and
-        /// `#rust-analyzer.hover.actions.run.enable#` are set.
-        hover_actions_updateTest_enable: bool = true,
-
-        /// Show documentation on hover.
-        hover_documentation_enable: bool = true,
-
-        /// Show keyword hover popups. Only applies when
-        /// `#rust-analyzer.hover.documentation.enable#` is set.
-        hover_documentation_keywords_enable: bool = true,
-
-        /// Show drop glue information on hover.
-        hover_dropGlue_enable: bool = true,
-
-        /// Use markdown syntax for links on hover.
-        hover_links_enable: bool = true,
-
-        /// Show what types are used as generic arguments in calls etc. on hover, and limit the max
-        /// length to show such types, beyond which they will be shown with ellipsis.
-        ///
-        /// This can take three values: `null` means "unlimited", the string `"hide"` means to not
-        /// show generic substitutions at all, and a number means to limit them to X characters.
-        ///
-        /// The default is 20 characters.
-        hover_maxSubstitutionLength: Option<MaxSubstitutionLength> =
-            Some(MaxSubstitutionLength::Limit(20)),
-
-        /// How to render the align information in a memory layout hover.
-        hover_memoryLayout_alignment: Option<MemoryLayoutHoverRenderKindDef> =
-            Some(MemoryLayoutHoverRenderKindDef::Hexadecimal),
-
-        /// Show memory layout data on hover.
-        hover_memoryLayout_enable: bool = true,
-
-        /// How to render the niche information in a memory layout hover.
-        hover_memoryLayout_niches: Option<bool> = Some(false),
-
-        /// How to render the offset information in a memory layout hover.
-        hover_memoryLayout_offset: Option<MemoryLayoutHoverRenderKindDef> =
-            Some(MemoryLayoutHoverRenderKindDef::Hexadecimal),
-
-        /// How to render the padding information in a memory layout hover.
-        hover_memoryLayout_padding: Option<MemoryLayoutHoverRenderKindDef> = None,
-
-        /// How to render the size information in a memory layout hover.
-        hover_memoryLayout_size: Option<MemoryLayoutHoverRenderKindDef> =
-            Some(MemoryLayoutHoverRenderKindDef::Both),
-
-        /// How many variants of an enum to display when hovering on. Show none if empty.
-        hover_show_enumVariants: Option<usize> = Some(5),
-
-        /// How many fields of a struct, variant or union to display when hovering on. Show none if
-        /// empty.
-        hover_show_fields: Option<usize> = Some(5),
-
-        /// How many associated items of a trait to display when hovering a trait.
-        hover_show_traitAssocItems: Option<usize> = None,
-
-        /// Show inlay type hints for binding modes.
-        inlayHints_bindingModeHints_enable: bool = false,
-
-        /// Show inlay type hints for method chains.
-        inlayHints_chainingHints_enable: bool = true,
-
-        /// Show inlay hints after a closing `}` to indicate what item it belongs to.
-        inlayHints_closingBraceHints_enable: bool = true,
-
-        /// Minimum number of lines required before the `}` until the hint is shown (set to 0 or 1
-        /// to always show them).
-        inlayHints_closingBraceHints_minLines: usize = 25,
-
-        /// Show inlay hints for closure captures.
-        inlayHints_closureCaptureHints_enable: bool = false,
-
-        /// Show inlay type hints for return types of closures.
-        inlayHints_closureReturnTypeHints_enable: ClosureReturnTypeHintsDef =
-            ClosureReturnTypeHintsDef::Never,
-
-        /// Closure notation in type and chaining inlay hints.
-        inlayHints_closureStyle: ClosureStyle = ClosureStyle::ImplFn,
-
-        /// Show enum variant discriminant hints.
-        inlayHints_discriminantHints_enable: DiscriminantHintsDef =
-            DiscriminantHintsDef::Never,
-
-        /// Disable reborrows in expression adjustments inlay hints.
-        ///
-        /// Reborrows are a pair of a builtin deref then borrow, i.e. `&*`. They are inserted by the compiler but are mostly useless to the programmer.
-        ///
-        /// Note: if the deref is not builtin (an overloaded deref), or the borrow is `&raw const`/`&raw mut`, they are not removed.
-        inlayHints_expressionAdjustmentHints_disableReborrows: bool =
-            true,
-
-        /// Show inlay hints for type adjustments.
-        inlayHints_expressionAdjustmentHints_enable: AdjustmentHintsDef =
-            AdjustmentHintsDef::Never,
-
-        /// Hide inlay hints for type adjustments outside of `unsafe` blocks.
-        inlayHints_expressionAdjustmentHints_hideOutsideUnsafe: bool = false,
-
-        /// Show inlay hints as postfix ops (`.*` instead of `*`, etc).
-        inlayHints_expressionAdjustmentHints_mode: AdjustmentHintsModeDef =
-            AdjustmentHintsModeDef::Prefix,
-
-        /// Show const generic parameter name inlay hints.
-        inlayHints_genericParameterHints_const_enable: bool = true,
-
-        /// Show generic lifetime parameter name inlay hints.
-        inlayHints_genericParameterHints_lifetime_enable: bool = false,
-
-        /// Show generic type parameter name inlay hints.
-        inlayHints_genericParameterHints_type_enable: bool = false,
-
-        /// Show implicit drop hints.
-        inlayHints_implicitDrops_enable: bool = false,
-
-        /// Show inlay hints for the implied type parameter `Sized` bound.
-        inlayHints_implicitSizedBoundHints_enable: bool = false,
-
-        /// Show inlay type hints for elided lifetimes in function signatures.
-        inlayHints_lifetimeElisionHints_enable: LifetimeElisionDef = LifetimeElisionDef::Never,
-
-        /// Prefer using parameter names as the name for elided lifetime hints if possible.
-        inlayHints_lifetimeElisionHints_useParameterNames: bool = false,
-
-        /// Maximum length for inlay hints. Set to null to have an unlimited length.
-        ///
-        /// **Note:** This is mostly a hint, and we don't guarantee to strictly follow the limit.
-        inlayHints_maxLength: Option<usize> = Some(25),
-
-        /// Show function parameter name inlay hints at the call site.
-        inlayHints_parameterHints_enable: bool = true,
-
-        /// Show exclusive range inlay hints.
-        inlayHints_rangeExclusiveHints_enable: bool = false,
-
-        /// Show inlay hints for compiler inserted reborrows.
-        ///
-        /// This setting is deprecated in favor of
-        /// #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.
-        inlayHints_reborrowHints_enable: ReborrowHintsDef = ReborrowHintsDef::Never,
-
-        /// Whether to render leading colons for type hints, and trailing colons for parameter hints.
-        inlayHints_renderColons: bool = true,
-
-        /// Show inlay type hints for variables.
-        inlayHints_typeHints_enable: bool = true,
-
-        /// Hide inlay type hints for `let` statements that initialize to a closure.
-        ///
-        /// Only applies to closures with blocks, same as
-        /// `#rust-analyzer.inlayHints.closureReturnTypeHints.enable#`.
-        inlayHints_typeHints_hideClosureInitialization: bool = false,
-
-        /// Hide inlay parameter type hints for closures.
-        inlayHints_typeHints_hideClosureParameter: bool = false,
-
-        /// Hide inlay type hints for constructors.
-        inlayHints_typeHints_hideNamedConstructor: bool = false,
-
-        /// Enable the experimental support for interpreting tests.
-        interpret_tests: bool = false,
-
-        /// Join lines merges consecutive declaration and initialization of an assignment.
-        joinLines_joinAssignments: bool = true,
-
-        /// Join lines inserts else between consecutive ifs.
-        joinLines_joinElseIf: bool = true,
-
-        /// Join lines removes trailing commas.
-        joinLines_removeTrailingComma: bool = true,
-
-        /// Join lines unwraps trivial blocks.
-        joinLines_unwrapTrivialBlock: bool = true,
-
-        /// Show `Debug` lens. Only applies when `#rust-analyzer.lens.enable#` is set.
-        lens_debug_enable: bool = true,
-
-        /// Show CodeLens in Rust files.
-        lens_enable: bool = true,
-
-        /// Show `Implementations` lens. Only applies when `#rust-analyzer.lens.enable#` is set.
-        lens_implementations_enable: bool = true,
-
-        /// Where to render annotations.
-        lens_location: AnnotationLocation = AnnotationLocation::AboveName,
-
-        /// Show `References` lens for Struct, Enum, and Union. Only applies when
-        /// `#rust-analyzer.lens.enable#` is set.
-        lens_references_adt_enable: bool = false,
-
-        /// Show `References` lens for Enum Variants. Only applies when
-        /// `#rust-analyzer.lens.enable#` is set.
-        lens_references_enumVariant_enable: bool = false,
-
-        /// Show `Method References` lens. Only applies when `#rust-analyzer.lens.enable#` is set.
-        lens_references_method_enable: bool = false,
-
-        /// Show `References` lens for Trait. Only applies when `#rust-analyzer.lens.enable#` is
-        /// set.
-        lens_references_trait_enable: bool = false,
-
-        /// Show `Run` lens. Only applies when `#rust-analyzer.lens.enable#` is set.
-        lens_run_enable: bool = true,
-
-        /// Show `Update Test` lens. Only applies when `#rust-analyzer.lens.enable#` and
-        /// `#rust-analyzer.lens.run.enable#` are set.
-        lens_updateTest_enable: bool = true,
-
-        /// Disable project auto-discovery in favor of explicitly specified set of projects.
-        ///
-        /// Elements must be paths pointing to `Cargo.toml`, `rust-project.json`, `.rs` files (which
-        /// will be treated as standalone files) or JSON objects in `rust-project.json` format.
-        linkedProjects: Vec<ManifestOrProjectJson> = vec![],
-
-        /// Number of syntax trees rust-analyzer keeps in memory. Defaults to 128.
-        lru_capacity: Option<u16> = None,
-
-        /// The LRU capacity of the specified queries.
-        lru_query_capacities: FxHashMap<Box<str>, u16> = FxHashMap::default(),
-
-        /// Show `can't find Cargo.toml` error message.
-        notifications_cargoTomlNotFound: bool = true,
-
-        /// The number of worker threads in the main loop. The default `null` means to pick
-        /// automatically.
-        numThreads: Option<NumThreads> = None,
-
-        /// Expand attribute macros. Requires `#rust-analyzer.procMacro.enable#` to be set.
-        procMacro_attributes_enable: bool = true,
-
-        /// Enable support for procedural macros, implies `#rust-analyzer.cargo.buildScripts.enable#`.
-        procMacro_enable: bool = true,
-
-        /// Internal config, path to proc-macro server executable.
-        procMacro_server: Option<Utf8PathBuf> = None,
-
-        /// The path where to save memory profiling output.
-        ///
-        /// **Note:** Memory profiling is not enabled by default in rust-analyzer builds, you need to build
-        /// from source for it.
-        profiling_memoryProfile: Option<Utf8PathBuf> = None,
-
-        /// Exclude imports from find-all-references.
-        references_excludeImports: bool = false,
-
-        /// Exclude tests from find-all-references and call-hierarchy.
-        references_excludeTests: bool = false,
-
-        /// Use semantic tokens for comments.
-        ///
-        /// In some editors (e.g. vscode) semantic tokens override other highlighting grammars.
-        /// By disabling semantic tokens for comments, other grammars can be used to highlight
-        /// their contents.
-        semanticHighlighting_comments_enable: bool = true,
-
-        /// Inject additional highlighting into doc comments.
-        ///
-        /// When enabled, rust-analyzer will highlight rust source in doc comments as well as intra
-        /// doc links.
-        semanticHighlighting_doc_comment_inject_enable: bool = true,
-
-        /// Emit non-standard tokens and modifiers
-        ///
-        /// When enabled, rust-analyzer will emit tokens and modifiers that are not part of the
-        /// standard set of semantic tokens.
-        semanticHighlighting_nonStandardTokens: bool = true,
-
-        /// Use semantic tokens for operators.
-        ///
-        /// When disabled, rust-analyzer will emit semantic tokens only for operator tokens when
-        /// they are tagged with modifiers.
-        semanticHighlighting_operator_enable: bool = true,
-
-        /// Use specialized semantic tokens for operators.
-        ///
-        /// When enabled, rust-analyzer will emit special token types for operator tokens instead
-        /// of the generic `operator` token type.
-        semanticHighlighting_operator_specialization_enable: bool = false,
-
-        /// Use semantic tokens for punctuation.
-        ///
-        /// When disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when
-        /// they are tagged with modifiers or have a special role.
-        semanticHighlighting_punctuation_enable: bool = false,
-
-        /// When enabled, rust-analyzer will emit a punctuation semantic token for the `!` of macro
-        /// calls.
-        semanticHighlighting_punctuation_separate_macro_bang: bool = false,
-
-        /// Use specialized semantic tokens for punctuation.
-        ///
-        /// When enabled, rust-analyzer will emit special token types for punctuation tokens instead
-        /// of the generic `punctuation` token type.
-        semanticHighlighting_punctuation_specialization_enable: bool = false,
-
-        /// Use semantic tokens for strings.
-        ///
-        /// In some editors (e.g. vscode) semantic tokens override other highlighting grammars.
-        /// By disabling semantic tokens for strings, other grammars can be used to highlight
-        /// their contents.
-        semanticHighlighting_strings_enable: bool = true,
-
-        /// Show full signature of the callable. Only shows parameters if disabled.
-        signatureInfo_detail: SignatureDetail = SignatureDetail::Full,
-
-        /// Show documentation.
-        signatureInfo_documentation_enable: bool = true,
-
-        /// Specify the characters allowed to invoke special on typing triggers.
-        ///
-        /// - typing `=` after `let` tries to smartly add `;` if `=` is followed by an existing
-        ///   expression
-        /// - typing `=` between two expressions adds `;` when in statement position
-        /// - typing `=` to turn an assignment into an equality comparison removes `;` when in
-        ///   expression position
-        /// - typing `.` in a chain method call auto-indents
-        /// - typing `{` or `(` in front of an expression inserts a closing `}` or `)` after the
-        ///   expression
-        /// - typing `{` in a use item adds a closing `}` in the right place
-        /// - typing `>` to complete a return type `->` will insert a whitespace after it
-        /// - typing `<` in a path or type position inserts a closing `>` after the path or type.
-        typing_triggerChars: Option<String> = Some("=.".to_owned()),
-
-
-        /// Enables automatic discovery of projects using [`DiscoverWorkspaceConfig::command`].
-        ///
-        /// [`DiscoverWorkspaceConfig`] also requires setting `progress_label` and `files_to_watch`.
-        /// `progress_label` is used for the title in progress indicators, whereas `files_to_watch`
-        /// is used to determine which build system-specific files should be watched in order to
-        /// reload rust-analyzer.
-        ///
-        /// Below is an example of a valid configuration:
-        /// ```json
-        /// "rust-analyzer.workspace.discoverConfig": {
-        ///     "command": [
-        ///         "rust-project",
-        ///         "develop-json"
-        ///     ],
-        ///     "progressLabel": "rust-analyzer",
-        ///     "filesToWatch": [
-        ///         "BUCK"
-        ///     ]
-        /// }
-        /// ```
-        ///
-        /// ## On `DiscoverWorkspaceConfig::command`
-        ///
-        /// **Warning**: This format is provisional and subject to change.
-        ///
-        /// [`DiscoverWorkspaceConfig::command`] *must* return a JSON object corresponding to
-        /// `DiscoverProjectData::Finished`:
-        ///
-        /// ```norun
-        /// #[derive(Debug, Clone, Deserialize, Serialize)]
-        /// #[serde(tag = "kind")]
-        /// #[serde(rename_all = "snake_case")]
-        /// enum DiscoverProjectData {
-        ///     Finished { buildfile: Utf8PathBuf, project: ProjectJsonData },
-        ///     Error { error: String, source: Option<String> },
-        ///     Progress { message: String },
-        /// }
-        /// ```
-        ///
-        /// As JSON, `DiscoverProjectData::Finished` is:
-        ///
-        /// ```json
-        /// {
-        ///     // the internally-tagged representation of the enum.
-        ///     "kind": "finished",
-        ///     // the file used by a non-Cargo build system to define
-        ///     // a package or target.
-        ///     "buildfile": "rust-analyzer/BUILD",
-        ///     // the contents of a rust-project.json, elided for brevity
-        ///     "project": {
-        ///         "sysroot": "foo",
-        ///         "crates": []
-        ///     }
-        /// }
-        /// ```
-        ///
-        /// It is encouraged, but not required, to use the other variants on `DiscoverProjectData`
-        /// to provide a more polished end-user experience.
-        ///
-        /// `DiscoverWorkspaceConfig::command` may *optionally* include an `{arg}`, which will be
-        /// substituted with the JSON-serialized form of the following enum:
-        ///
-        /// ```norun
-        /// #[derive(PartialEq, Clone, Debug, Serialize)]
-        /// #[serde(rename_all = "camelCase")]
-        /// pub enum DiscoverArgument {
-        ///    Path(AbsPathBuf),
-        ///    Buildfile(AbsPathBuf),
-        /// }
-        /// ```
-        ///
-        /// The JSON representation of `DiscoverArgument::Path` is:
-        ///
-        /// ```json
-        /// {
-        ///     "path": "src/main.rs"
-        /// }
-        /// ```
-        ///
-        /// Similarly, the JSON representation of `DiscoverArgument::Buildfile` is:
-        ///
-        /// ```json
-        /// {
-        ///     "buildfile": "BUILD"
-        /// }
-        /// ```
-        ///
-        /// `DiscoverArgument::Path` is used to find and generate a `rust-project.json`, and
-        /// therefore, a workspace, whereas `DiscoverArgument::buildfile` is used to to update an
-        /// existing workspace. As a reference for implementors, buck2's `rust-project` will likely
-        /// be useful: https://github.com/facebook/buck2/tree/main/integrations/rust-project.
-        workspace_discoverConfig: Option<DiscoverWorkspaceConfig> = None,
-    }
-}
-
-config_data! {
-    /// Local configurations can be defined per `SourceRoot`. This almost always corresponds to a `Crate`.
-    local: struct LocalDefaultConfigData <- LocalConfigInput ->  {
-        /// Insert #[must_use] when generating `as_` methods for enum variants.
-        assist_emitMustUse: bool = false,
-
-        /// Placeholder expression to use for missing expressions in assists.
-        assist_expressionFillDefault: ExprFillDefaultDef = ExprFillDefaultDef::Todo,
-
-        /// Prefer to use `Self` over the type name when inserting a type (e.g. in "fill match arms" assist).
-        assist_preferSelf: bool = false,
-
-        /// Enable borrow checking for term search code assists. If set to false, also there will be
-        /// more suggestions, but some of them may not borrow-check.
-        assist_termSearch_borrowcheck: bool = true,
-
-        /// Term search fuel in "units of work" for assists (Defaults to 1800).
-        assist_termSearch_fuel: usize = 1800,
-
-        /// Automatically add a semicolon when completing unit-returning functions.
-        ///
-        /// In `match` arms it completes a comma instead.
-        completion_addSemicolonToUnit: bool = true,
-
-        /// Show method calls and field accesses completions with `await` prefixed to them when
-        /// completing on a future.
-        completion_autoAwait_enable: bool = true,
-
-        /// Show method call completions with `iter()` or `into_iter()` prefixed to them when
-        /// completing on a type that has them.
-        completion_autoIter_enable: bool = true,
-
-        /// Show completions that automatically add imports when completed.
-        ///
-        /// Note that your client must specify the `additionalTextEdits` LSP client capability to
-        /// truly have this feature enabled.
-        completion_autoimport_enable: bool = true,
-
-        /// A list of full paths to items to exclude from auto-importing completions.
-        ///
-        /// Traits in this list won't have their methods suggested in completions unless the trait
-        /// is in scope.
-        ///
-        /// You can either specify a string path which defaults to type "always" or use the more
-        /// verbose form `{ "path": "path::to::item", type: "always" }`.
-        ///
-        /// For traits the type "methods" can be used to only exclude the methods but not the trait
-        /// itself.
-        ///
-        /// This setting also inherits `#rust-analyzer.completion.excludeTraits#`.
-        completion_autoimport_exclude: Vec<AutoImportExclusion> = vec![
-            AutoImportExclusion::Verbose { path: "core::borrow::Borrow".to_owned(), r#type: AutoImportExclusionType::Methods },
-            AutoImportExclusion::Verbose { path: "core::borrow::BorrowMut".to_owned(), r#type: AutoImportExclusionType::Methods },
-        ],
-
-        /// Show method calls and field access completions with `self` prefixed to them when
-        /// inside a method.
-        completion_autoself_enable: bool = true,
-
-        /// Add parenthesis and argument snippets when completing function.
-        completion_callable_snippets: CallableCompletionDef = CallableCompletionDef::FillArguments,
-
-        /// A list of full paths to traits whose methods to exclude from completion.
-        ///
-        /// Methods from these traits won't be completed, even if the trait is in scope. However,
-        /// they will still be suggested on expressions whose type is `dyn Trait`, `impl Trait` or
-        /// `T where T: Trait`.
-        ///
-        /// Note that the trait themselves can still be completed.
-        completion_excludeTraits: Vec<String> = Vec::new(),
-
-        /// Show full function / method signatures in completion docs.
-        completion_fullFunctionSignatures_enable: bool = false,
-
-        /// Omit deprecated items from completions. By default they are marked as deprecated but not
-        /// hidden.
-        completion_hideDeprecated: bool = false,
-
-        /// Maximum number of completions to return. If `None`, the limit is infinite.
-        completion_limit: Option<usize> = None,
-
-        /// Show postfix snippets like `dbg`, `if`, `not`, etc.
-        completion_postfix_enable: bool = true,
-
-        /// Show completions of private items and fields that are defined in the current workspace
-        /// even if they are not visible at the current position.
-        completion_privateEditable_enable: bool = false,
-
-        /// Enable term search based snippets like `Some(foo.bar().baz())`.
-        completion_termSearch_enable: bool = false,
-
-        /// Term search fuel in "units of work" for autocompletion (Defaults to 1000).
-        completion_termSearch_fuel: usize = 1000,
-
-        /// List of rust-analyzer diagnostics to disable.
-        diagnostics_disabled: FxHashSet<String> = FxHashSet::default(),
-
-        /// Show native rust-analyzer diagnostics.
-        diagnostics_enable: bool = true,
-
-        /// Show experimental rust-analyzer diagnostics that might have more false positives than
-        /// usual.
-        diagnostics_experimental_enable: bool = false,
-
-        /// Map of prefixes to be substituted when parsing diagnostic file paths. This should be the
-        /// reverse mapping of what is passed to `rustc` as `--remap-path-prefix`.
-        diagnostics_remapPrefix: FxHashMap<String, String> = FxHashMap::default(),
-
-        /// Run additional style lints.
-        diagnostics_styleLints_enable: bool = false,
-
-        /// List of warnings that should be displayed with hint severity.
-        ///
-        /// The warnings will be indicated by faded text or three dots in code and will not show up
-        /// in the `Problems Panel`.
-        diagnostics_warningsAsHint: Vec<String> = vec![],
-
-        /// List of warnings that should be displayed with info severity.
-        ///
-        /// The warnings will be indicated by a blue squiggly underline in code and a blue icon in
-        /// the `Problems Panel`.
-        diagnostics_warningsAsInfo: Vec<String> = vec![],
-
-        /// Enforce the import granularity setting for all files. If set to false rust-analyzer will
-        /// try to keep import styles consistent per file.
-        imports_granularity_enforce: bool = false,
-
-        /// How imports should be grouped into use statements.
-        imports_granularity_group: ImportGranularityDef = ImportGranularityDef::Crate,
-
-        /// Group inserted imports by the [following
-        /// order](https://rust-analyzer.github.io/book/features.html#auto-import). Groups are
-        /// separated by newlines.
-        imports_group_enable: bool = true,
-
-        /// Allow import insertion to merge new imports into single path glob imports like `use
-        /// std::fmt::*;`.
-        imports_merge_glob: bool = true,
-
-        /// Prefer to unconditionally use imports of the core and alloc crate, over the std crate.
-        imports_preferNoStd | imports_prefer_no_std: bool = false,
-
-        /// Prefer import paths containing a `prelude` module.
-        imports_preferPrelude: bool = false,
-
-        /// The path structure for newly inserted paths to use.
-        imports_prefix: ImportPrefixDef = ImportPrefixDef::ByCrate,
-
-        /// Prefix external (including std, core) crate imports with `::`.
-        ///
-        /// E.g. `use ::std::io::Read;`.
-        imports_prefixExternPrelude: bool = false,
-    }
-}
-
-config_data! {
-    workspace: struct WorkspaceDefaultConfigData <- WorkspaceConfigInput -> {
-        /// Pass `--all-targets` to cargo invocation.
-        cargo_allTargets: bool           = true,
-        /// Automatically refresh project info via `cargo metadata` on
-        /// `Cargo.toml` or `.cargo/config.toml` changes.
-        cargo_autoreload: bool           = true,
-        /// Run build scripts (`build.rs`) for more precise code analysis.
-        cargo_buildScripts_enable: bool  = true,
-        /// Specifies the invocation strategy to use when running the build scripts command.
-        /// If `per_workspace` is set, the command will be executed for each Rust workspace with the
-        /// workspace as the working directory.
-        /// If `once` is set, the command will be executed once with the opened project as the
-        /// working directory.
-        /// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`
-        /// is set.
-        cargo_buildScripts_invocationStrategy: InvocationStrategy = InvocationStrategy::PerWorkspace,
-        /// Override the command rust-analyzer uses to run build scripts and
-        /// build procedural macros. The command is required to output json
-        /// and should therefore include `--message-format=json` or a similar
-        /// option.
-        ///
-        /// If there are multiple linked projects/workspaces, this command is invoked for
-        /// each of them, with the working directory being the workspace root
-        /// (i.e., the folder containing the `Cargo.toml`). This can be overwritten
-        /// by changing `#rust-analyzer.cargo.buildScripts.invocationStrategy#`.
-        ///
-        /// By default, a cargo invocation will be constructed for the configured
-        /// targets and features, with the following base command line:
-        ///
-        /// ```bash
-        /// cargo check --quiet --workspace --message-format=json --all-targets --keep-going
-        /// ```
-        ///
-        /// Note: The option must be specified as an array of command line arguments, with
-        /// the first argument being the name of the command to run.
-        cargo_buildScripts_overrideCommand: Option<Vec<String>> = None,
-        /// Rerun proc-macros building/build-scripts running when proc-macro
-        /// or build-script sources change and are saved.
-        cargo_buildScripts_rebuildOnSave: bool = true,
-        /// Use `RUSTC_WRAPPER=rust-analyzer` when running build scripts to
-        /// avoid checking unnecessary things.
-        cargo_buildScripts_useRustcWrapper: bool = true,
-        /// List of cfg options to enable with the given values.
-        ///
-        /// To enable a name without a value, use `"key"`.
-        /// To enable a name with a value, use `"key=value"`.
-        /// To disable, prefix the entry with a `!`.
-        cargo_cfgs: Vec<String> = {
-            vec!["debug_assertions".into(), "miri".into()]
-        },
-        /// Extra arguments that are passed to every cargo invocation.
-        cargo_extraArgs: Vec<String> = vec![],
-        /// Extra environment variables that will be set when running cargo, rustc
-        /// or other commands within the workspace. Useful for setting RUSTFLAGS.
-        cargo_extraEnv: FxHashMap<String, Option<String>> = FxHashMap::default(),
-        /// List of features to activate.
-        ///
-        /// Set this to `"all"` to pass `--all-features` to cargo.
-        cargo_features: CargoFeaturesDef      = CargoFeaturesDef::Selected(vec![]),
-        /// Whether to pass `--no-default-features` to cargo.
-        cargo_noDefaultFeatures: bool    = false,
-        /// Whether to skip fetching dependencies. If set to "true", the analysis is performed
-        /// entirely offline, and Cargo metadata for dependencies is not fetched.
-        cargo_noDeps: bool = false,
-        /// Relative path to the sysroot, or "discover" to try to automatically find it via
-        /// "rustc --print sysroot".
-        ///
-        /// Unsetting this disables sysroot loading.
-        ///
-        /// This option does not take effect until rust-analyzer is restarted.
-        cargo_sysroot: Option<String>    = Some("discover".to_owned()),
-        /// Relative path to the sysroot library sources. If left unset, this will default to
-        /// `{cargo.sysroot}/lib/rustlib/src/rust/library`.
-        ///
-        /// This option does not take effect until rust-analyzer is restarted.
-        cargo_sysrootSrc: Option<String>    = None,
-        /// Compilation target override (target tuple).
-        // FIXME(@poliorcetics): move to multiple targets here too, but this will need more work
-        // than `checkOnSave_target`
-        cargo_target: Option<String>     = None,
-        /// Optional path to a rust-analyzer specific target directory.
-        /// This prevents rust-analyzer's `cargo check` and initial build-script and proc-macro
-        /// building from locking the `Cargo.lock` at the expense of duplicating build artifacts.
-        ///
-        /// Set to `true` to use a subdirectory of the existing target directory or
-        /// set to a path relative to the workspace to use that path.
-        cargo_targetDir | rust_analyzerTargetDir: Option<TargetDirectory> = None,
-
-        /// Set `cfg(test)` for local crates. Defaults to true.
-        cfg_setTest: bool = true,
-
-        /// Run the check command for diagnostics on save.
-        checkOnSave | checkOnSave_enable: bool                         = true,
-
-
-        /// Check all targets and tests (`--all-targets`). Defaults to
-        /// `#rust-analyzer.cargo.allTargets#`.
-        check_allTargets | checkOnSave_allTargets: Option<bool>          = None,
-        /// Cargo command to use for `cargo check`.
-        check_command | checkOnSave_command: String                      = "check".to_owned(),
-        /// Extra arguments for `cargo check`.
-        check_extraArgs | checkOnSave_extraArgs: Vec<String>             = vec![],
-        /// Extra environment variables that will be set when running `cargo check`.
-        /// Extends `#rust-analyzer.cargo.extraEnv#`.
-        check_extraEnv | checkOnSave_extraEnv: FxHashMap<String, Option<String>> = FxHashMap::default(),
-        /// List of features to activate. Defaults to
-        /// `#rust-analyzer.cargo.features#`.
-        ///
-        /// Set to `"all"` to pass `--all-features` to Cargo.
-        check_features | checkOnSave_features: Option<CargoFeaturesDef>  = None,
-        /// List of `cargo check` (or other command specified in `check.command`) diagnostics to ignore.
-        ///
-        /// For example for `cargo check`: `dead_code`, `unused_imports`, `unused_variables`,...
-        check_ignore: FxHashSet<String> = FxHashSet::default(),
-        /// Specifies the invocation strategy to use when running the check command.
-        /// If `per_workspace` is set, the command will be executed for each workspace.
-        /// If `once` is set, the command will be executed once.
-        /// This config only has an effect when `#rust-analyzer.check.overrideCommand#`
-        /// is set.
-        check_invocationStrategy | checkOnSave_invocationStrategy: InvocationStrategy = InvocationStrategy::PerWorkspace,
-        /// Whether to pass `--no-default-features` to Cargo. Defaults to
-        /// `#rust-analyzer.cargo.noDefaultFeatures#`.
-        check_noDefaultFeatures | checkOnSave_noDefaultFeatures: Option<bool>         = None,
-        /// Override the command rust-analyzer uses instead of `cargo check` for
-        /// diagnostics on save. The command is required to output json and
-        /// should therefore include `--message-format=json` or a similar option
-        /// (if your client supports the `colorDiagnosticOutput` experimental
-        /// capability, you can use `--message-format=json-diagnostic-rendered-ansi`).
-        ///
-        /// If you're changing this because you're using some tool wrapping
-        /// Cargo, you might also want to change
-        /// `#rust-analyzer.cargo.buildScripts.overrideCommand#`.
-        ///
-        /// If there are multiple linked projects/workspaces, this command is invoked for
-        /// each of them, with the working directory being the workspace root
-        /// (i.e., the folder containing the `Cargo.toml`). This can be overwritten
-        /// by changing `#rust-analyzer.check.invocationStrategy#`.
-        ///
-        /// If `$saved_file` is part of the command, rust-analyzer will pass
-        /// the absolute path of the saved file to the provided command. This is
-        /// intended to be used with non-Cargo build systems.
-        /// Note that `$saved_file` is experimental and may be removed in the future.
-        ///
-        /// An example command would be:
-        ///
-        /// ```bash
-        /// cargo check --workspace --message-format=json --all-targets
-        /// ```
-        ///
-        /// Note: The option must be specified as an array of command line arguments, with
-        /// the first argument being the name of the command to run.
-        check_overrideCommand | checkOnSave_overrideCommand: Option<Vec<String>>             = None,
-        /// Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.
-        ///
-        /// Can be a single target, e.g. `"x86_64-unknown-linux-gnu"` or a list of targets, e.g.
-        /// `["aarch64-apple-darwin", "x86_64-apple-darwin"]`.
-        ///
-        /// Aliased as `"checkOnSave.targets"`.
-        check_targets | checkOnSave_targets | checkOnSave_target: Option<CheckOnSaveTargets> = None,
-        /// Whether `--workspace` should be passed to `cargo check`.
-        /// If false, `-p <package>` will be passed instead if applicable. In case it is not, no
-        /// check will be performed.
-        check_workspace: bool = true,
-
-        /// Exclude all locals from document symbol search.
-        document_symbol_search_excludeLocals: bool = true,
-
-        /// These proc-macros will be ignored when trying to expand them.
-        ///
-        /// This config takes a map of crate names with the exported proc-macro names to ignore as values.
-        procMacro_ignored: FxHashMap<Box<str>, Box<[Box<str>]>>          = FxHashMap::default(),
-
-        /// Command to be executed instead of 'cargo' for runnables.
-        runnables_command: Option<String> = None,
-        /// Additional arguments to be passed to cargo for runnables such as
-        /// tests or binaries. For example, it may be `--release`.
-        runnables_extraArgs: Vec<String>   = vec![],
-        /// Additional arguments to be passed through Cargo to launched tests, benchmarks, or
-        /// doc-tests.
-        ///
-        /// Unless the launched target uses a
-        /// [custom test harness](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field),
-        /// they will end up being interpreted as options to
-        /// [`rustc`’s built-in test harness (“libtest”)](https://doc.rust-lang.org/rustc/tests/index.html#cli-arguments).
-        runnables_extraTestBinaryArgs: Vec<String> = vec!["--nocapture".to_owned()],
-
-        /// Path to the Cargo.toml of the rust compiler workspace, for usage in rustc_private
-        /// projects, or "discover" to try to automatically find it if the `rustc-dev` component
-        /// is installed.
-        ///
-        /// Any project which uses rust-analyzer with the rustcPrivate
-        /// crates must set `[package.metadata.rust-analyzer] rustc_private=true` to use it.
-        ///
-        /// This option does not take effect until rust-analyzer is restarted.
-        rustc_source: Option<String> = None,
-
-        /// Additional arguments to `rustfmt`.
-        rustfmt_extraArgs: Vec<String>               = vec![],
-        /// Advanced option, fully override the command rust-analyzer uses for
-        /// formatting. This should be the equivalent of `rustfmt` here, and
-        /// not that of `cargo fmt`. The file contents will be passed on the
-        /// standard input and the formatted result will be read from the
-        /// standard output.
-        ///
-        /// Note: The option must be specified as an array of command line arguments, with
-        /// the first argument being the name of the command to run.
-        rustfmt_overrideCommand: Option<Vec<String>> = None,
-        /// Enables the use of rustfmt's unstable range formatting command for the
-        /// `textDocument/rangeFormatting` request. The rustfmt option is unstable and only
-        /// available on a nightly build.
-        rustfmt_rangeFormatting_enable: bool = false,
-
-        /// Additional paths to include in the VFS. Generally for code that is
-        /// generated or otherwise managed by a build system outside of Cargo,
-        /// though Cargo might be the eventual consumer.
-        vfs_extraIncludes: Vec<String> = vec![],
-
-        /// Exclude all imports from workspace symbol search.
-        ///
-        /// In addition to regular imports (which are always excluded),
-        /// this option removes public imports (better known as re-exports)
-        /// and removes imports that rename the imported symbol.
-        workspace_symbol_search_excludeImports: bool = false,
-        /// Workspace symbol search kind.
-        workspace_symbol_search_kind: WorkspaceSymbolSearchKindDef = WorkspaceSymbolSearchKindDef::OnlyTypes,
-        /// Limits the number of items returned from a workspace symbol search (Defaults to 128).
-        /// Some clients like vs-code issue new searches on result filtering and don't require all results to be returned in the initial search.
-        /// Other clients requires all results upfront and might require a higher limit.
-        workspace_symbol_search_limit: usize = 128,
-        /// Workspace symbol search scope.
-        workspace_symbol_search_scope: WorkspaceSymbolSearchScopeDef = WorkspaceSymbolSearchScopeDef::Workspace,
-    }
-}
-
-config_data! {
-    /// Configs that only make sense when they are set by a client. As such they can only be defined
-    /// by setting them using client's settings (e.g `settings.json` on VS Code).
-    client: struct ClientDefaultConfigData <- ClientConfigInput -> {
-
-        /// Controls file watching implementation.
-        files_watcher: FilesWatcherDef = FilesWatcherDef::Client,
-
-
-    }
-}
-
+/// Configs that apply on a workspace-wide scope. There are 2 levels on which a global
+/// configuration can be configured
+///
+/// 1. `rust-analyzer.toml` file under user's config directory (e.g
+///    ~/.config/rust-analyzer/rust-analyzer.toml)
+/// 2. Client's own configurations (e.g `settings.json` on VS Code)
+///
+/// A config is searched for by traversing a "config tree" in a bottom up fashion. It is chosen
+/// by the nearest first principle.
+/// Warm up caches on project load.
+/// How many worker threads to handle priming caches. The default `0` means to pick
+/// automatically.
+/// Custom completion snippets.
+/// List of files to ignore
+///
+/// These paths (file/directories) will be ignored by rust-analyzer. They are relative to
+/// the workspace root, and globs are not supported. You may also need to add the folders to
+/// Code's `files.watcherExclude`.
+/// If this is `true`, when "Goto Implementations" and in "Implementations" lens, are triggered on a `struct` or `enum` or `union`, we filter out trait implementations that originate from `derive`s above the type.
+/// Highlight related return values while the cursor is on any `match`, `if`, or match arm
+/// arrow (`=>`).
+/// Highlight related references while the cursor is on `break`, `loop`, `while`, or `for`
+/// keywords.
+/// Highlight all captures of a closure while the cursor is on the `|` or move keyword of a closure.
+/// Highlight all exit points while the cursor is on any `return`, `?`, `fn`, or return type
+/// arrow (`->`).
+/// Highlight related references while the cursor is on any identifier.
+/// Highlight all break points for a loop or block context while the cursor is on any
+/// `async` or `await` keywords.
+/// Show `Debug` action. Only applies when `#rust-analyzer.hover.actions.enable#` is set.
+/// Show HoverActions in Rust files.
+/// Show `Go to Type Definition` action. Only applies when
+/// `#rust-analyzer.hover.actions.enable#` is set.
+/// Show `Implementations` action. Only applies when `#rust-analyzer.hover.actions.enable#`
+/// is set.
+/// Show `References` action. Only applies when `#rust-analyzer.hover.actions.enable#` is
+/// set.
+/// Show `Run` action. Only applies when `#rust-analyzer.hover.actions.enable#` is set.
+/// Show `Update Test` action. Only applies when `#rust-analyzer.hover.actions.enable#` and
+/// `#rust-analyzer.hover.actions.run.enable#` are set.
+/// Show documentation on hover.
+/// Show keyword hover popups. Only applies when
+/// `#rust-analyzer.hover.documentation.enable#` is set.
+/// Show drop glue information on hover.
+/// Use markdown syntax for links on hover.
+/// Show what types are used as generic arguments in calls etc. on hover, and limit the max
+/// length to show such types, beyond which they will be shown with ellipsis.
+///
+/// This can take three values: `null` means "unlimited", the string `"hide"` means to not
+/// show generic substitutions at all, and a number means to limit them to X characters.
+///
+/// The default is 20 characters.
+/// How to render the align information in a memory layout hover.
+/// Show memory layout data on hover.
+/// How to render the niche information in a memory layout hover.
+/// How to render the offset information in a memory layout hover.
+/// How to render the padding information in a memory layout hover.
+/// How to render the size information in a memory layout hover.
+/// How many variants of an enum to display when hovering on. Show none if empty.
+/// How many fields of a struct, variant or union to display when hovering on. Show none if
+/// empty.
+/// How many associated items of a trait to display when hovering a trait.
+/// Show inlay type hints for binding modes.
+/// Show inlay type hints for method chains.
+/// Show inlay hints after a closing `}` to indicate what item it belongs to.
+/// Minimum number of lines required before the `}` until the hint is shown (set to 0 or 1
+/// to always show them).
+/// Show inlay hints for closure captures.
+/// Show inlay type hints for return types of closures.
+/// Closure notation in type and chaining inlay hints.
+/// Show enum variant discriminant hints.
+/// Disable reborrows in expression adjustments inlay hints.
+///
+/// Reborrows are a pair of a builtin deref then borrow, i.e. `&*`. They are inserted by the compiler but are mostly useless to the programmer.
+///
+/// Note: if the deref is not builtin (an overloaded deref), or the borrow is `&raw const`/`&raw mut`, they are not removed.
+/// Show inlay hints for type adjustments.
+/// Hide inlay hints for type adjustments outside of `unsafe` blocks.
+/// Show inlay hints as postfix ops (`.*` instead of `*`, etc).
+/// Show const generic parameter name inlay hints.
+/// Show generic lifetime parameter name inlay hints.
+/// Show generic type parameter name inlay hints.
+/// Show implicit drop hints.
+/// Show inlay hints for the implied type parameter `Sized` bound.
+/// Show inlay type hints for elided lifetimes in function signatures.
+/// Prefer using parameter names as the name for elided lifetime hints if possible.
+/// Maximum length for inlay hints. Set to null to have an unlimited length.
+///
+/// **Note:** This is mostly a hint, and we don't guarantee to strictly follow the limit.
+/// Show function parameter name inlay hints at the call site.
+/// Show exclusive range inlay hints.
+/// Show inlay hints for compiler inserted reborrows.
+///
+/// This setting is deprecated in favor of
+/// #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.
+/// Whether to render leading colons for type hints, and trailing colons for parameter hints.
+/// Show inlay type hints for variables.
+/// Hide inlay type hints for `let` statements that initialize to a closure.
+///
+/// Only applies to closures with blocks, same as
+/// `#rust-analyzer.inlayHints.closureReturnTypeHints.enable#`.
+/// Hide inlay parameter type hints for closures.
+/// Hide inlay type hints for constructors.
+/// Enable the experimental support for interpreting tests.
+/// Join lines merges consecutive declaration and initialization of an assignment.
+/// Join lines inserts else between consecutive ifs.
+/// Join lines removes trailing commas.
+/// Join lines unwraps trivial blocks.
+/// Show `Debug` lens. Only applies when `#rust-analyzer.lens.enable#` is set.
+/// Show CodeLens in Rust files.
+/// Show `Implementations` lens. Only applies when `#rust-analyzer.lens.enable#` is set.
+/// Where to render annotations.
+/// Show `References` lens for Struct, Enum, and Union. Only applies when
+/// `#rust-analyzer.lens.enable#` is set.
+/// Show `References` lens for Enum Variants. Only applies when
+/// `#rust-analyzer.lens.enable#` is set.
+/// Show `Method References` lens. Only applies when `#rust-analyzer.lens.enable#` is set.
+/// Show `References` lens for Trait. Only applies when `#rust-analyzer.lens.enable#` is
+/// set.
+/// Show `Run` lens. Only applies when `#rust-analyzer.lens.enable#` is set.
+/// Show `Update Test` lens. Only applies when `#rust-analyzer.lens.enable#` and
+/// `#rust-analyzer.lens.run.enable#` are set.
+/// Disable project auto-discovery in favor of explicitly specified set of projects.
+///
+/// Elements must be paths pointing to `Cargo.toml`, `rust-project.json`, `.rs` files (which
+/// will be treated as standalone files) or JSON objects in `rust-project.json` format.
+/// Number of syntax trees rust-analyzer keeps in memory. Defaults to 128.
+/// The LRU capacity of the specified queries.
+/// Show `can't find Cargo.toml` error message.
+/// The number of worker threads in the main loop. The default `null` means to pick
+/// automatically.
+/// Expand attribute macros. Requires `#rust-analyzer.procMacro.enable#` to be set.
+/// Enable support for procedural macros, implies `#rust-analyzer.cargo.buildScripts.enable#`.
+/// Internal config, path to proc-macro server executable.
+/// The path where to save memory profiling output.
+///
+/// **Note:** Memory profiling is not enabled by default in rust-analyzer builds, you need to build
+/// from source for it.
+/// Exclude imports from find-all-references.
+/// Exclude tests from find-all-references and call-hierarchy.
+/// Use semantic tokens for comments.
+///
+/// In some editors (e.g. vscode) semantic tokens override other highlighting grammars.
+/// By disabling semantic tokens for comments, other grammars can be used to highlight
+/// their contents.
+/// Inject additional highlighting into doc comments.
+///
+/// When enabled, rust-analyzer will highlight rust source in doc comments as well as intra
+/// doc links.
+/// Emit non-standard tokens and modifiers
+///
+/// When enabled, rust-analyzer will emit tokens and modifiers that are not part of the
+/// standard set of semantic tokens.
+/// Use semantic tokens for operators.
+///
+/// When disabled, rust-analyzer will emit semantic tokens only for operator tokens when
+/// they are tagged with modifiers.
+/// Use specialized semantic tokens for operators.
+///
+/// When enabled, rust-analyzer will emit special token types for operator tokens instead
+/// of the generic `operator` token type.
+/// Use semantic tokens for punctuation.
+///
+/// When disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when
+/// they are tagged with modifiers or have a special role.
+/// When enabled, rust-analyzer will emit a punctuation semantic token for the `!` of macro
+/// calls.
+/// Use specialized semantic tokens for punctuation.
+///
+/// When enabled, rust-analyzer will emit special token types for punctuation tokens instead
+/// of the generic `punctuation` token type.
+/// Use semantic tokens for strings.
+///
+/// In some editors (e.g. vscode) semantic tokens override other highlighting grammars.
+/// By disabling semantic tokens for strings, other grammars can be used to highlight
+/// their contents.
+/// Show full signature of the callable. Only shows parameters if disabled.
+/// Show documentation.
+/// Specify the characters allowed to invoke special on typing triggers.
+///
+/// - typing `=` after `let` tries to smartly add `;` if `=` is followed by an existing
+///   expression
+/// - typing `=` between two expressions adds `;` when in statement position
+/// - typing `=` to turn an assignment into an equality comparison removes `;` when in
+///   expression position
+/// - typing `.` in a chain method call auto-indents
+/// - typing `{` or `(` in front of an expression inserts a closing `}` or `)` after the
+///   expression
+/// - typing `{` in a use item adds a closing `}` in the right place
+/// - typing `>` to complete a return type `->` will insert a whitespace after it
+/// - typing `<` in a path or type position inserts a closing `>` after the path or type.
+/// Enables automatic discovery of projects using [`DiscoverWorkspaceConfig::command`].
+///
+/// [`DiscoverWorkspaceConfig`] also requires setting `progress_label` and `files_to_watch`.
+/// `progress_label` is used for the title in progress indicators, whereas `files_to_watch`
+/// is used to determine which build system-specific files should be watched in order to
+/// reload rust-analyzer.
+///
+/// Below is an example of a valid configuration:
+/// ```json
+/// "rust-analyzer.workspace.discoverConfig": {
+///     "command": [
+///         "rust-project",
+///         "develop-json"
+///     ],
+///     "progressLabel": "rust-analyzer",
+///     "filesToWatch": [
+///         "BUCK"
+///     ]
+/// }
+/// ```
+///
+/// ## On `DiscoverWorkspaceConfig::command`
+///
+/// **Warning**: This format is provisional and subject to change.
+///
+/// [`DiscoverWorkspaceConfig::command`] *must* return a JSON object corresponding to
+/// `DiscoverProjectData::Finished`:
+///
+/// ```norun
+/// #[derive(Debug, Clone, Deserialize, Serialize)]
+/// #[serde(tag = "kind")]
+/// #[serde(rename_all = "snake_case")]
+/// enum DiscoverProjectData {
+///     Finished { buildfile: Utf8PathBuf, project: ProjectJsonData },
+///     Error { error: String, source: Option<String> },
+///     Progress { message: String },
+/// }
+/// ```
+///
+/// As JSON, `DiscoverProjectData::Finished` is:
+///
+/// ```json
+/// {
+///     // the internally-tagged representation of the enum.
+///     "kind": "finished",
+///     // the file used by a non-Cargo build system to define
+///     // a package or target.
+///     "buildfile": "rust-analyzer/BUILD",
+///     // the contents of a rust-project.json, elided for brevity
+///     "project": {
+///         "sysroot": "foo",
+///         "crates": []
+///     }
+/// }
+/// ```
+///
+/// It is encouraged, but not required, to use the other variants on `DiscoverProjectData`
+/// to provide a more polished end-user experience.
+///
+/// `DiscoverWorkspaceConfig::command` may *optionally* include an `{arg}`, which will be
+/// substituted with the JSON-serialized form of the following enum:
+///
+/// ```norun
+/// #[derive(PartialEq, Clone, Debug, Serialize)]
+/// #[serde(rename_all = "camelCase")]
+/// pub enum DiscoverArgument {
+///    Path(AbsPathBuf),
+///    Buildfile(AbsPathBuf),
+/// }
+/// ```
+///
+/// The JSON representation of `DiscoverArgument::Path` is:
+///
+/// ```json
+/// {
+///     "path": "src/main.rs"
+/// }
+/// ```
+///
+/// Similarly, the JSON representation of `DiscoverArgument::Buildfile` is:
+///
+/// ```json
+/// {
+///     "buildfile": "BUILD"
+/// }
+/// ```
+///
+/// `DiscoverArgument::Path` is used to find and generate a `rust-project.json`, and
+/// therefore, a workspace, whereas `DiscoverArgument::buildfile` is used to to update an
+/// existing workspace. As a reference for implementors, buck2's `rust-project` will likely
+/// be useful: https://github.com/facebook/buck2/tree/main/integrations/rust-project.
+/// Local configurations can be defined per `SourceRoot`. This almost always corresponds to a `Crate`.
+/// Insert #[must_use] when generating `as_` methods for enum variants.
+/// Placeholder expression to use for missing expressions in assists.
+/// Prefer to use `Self` over the type name when inserting a type (e.g. in "fill match arms" assist).
+/// Enable borrow checking for term search code assists. If set to false, also there will be
+/// more suggestions, but some of them may not borrow-check.
+/// Term search fuel in "units of work" for assists (Defaults to 1800).
+/// Automatically add a semicolon when completing unit-returning functions.
+///
+/// In `match` arms it completes a comma instead.
+/// Show method calls and field accesses completions with `await` prefixed to them when
+/// completing on a future.
+/// Show method call completions with `iter()` or `into_iter()` prefixed to them when
+/// completing on a type that has them.
+/// Show completions that automatically add imports when completed.
+///
+/// Note that your client must specify the `additionalTextEdits` LSP client capability to
+/// truly have this feature enabled.
+/// A list of full paths to items to exclude from auto-importing completions.
+///
+/// Traits in this list won't have their methods suggested in completions unless the trait
+/// is in scope.
+///
+/// You can either specify a string path which defaults to type "always" or use the more
+/// verbose form `{ "path": "path::to::item", type: "always" }`.
+///
+/// For traits the type "methods" can be used to only exclude the methods but not the trait
+/// itself.
+///
+/// This setting also inherits `#rust-analyzer.completion.excludeTraits#`.
+/// Show method calls and field access completions with `self` prefixed to them when
+/// inside a method.
+/// Add parenthesis and argument snippets when completing function.
+/// A list of full paths to traits whose methods to exclude from completion.
+///
+/// Methods from these traits won't be completed, even if the trait is in scope. However,
+/// they will still be suggested on expressions whose type is `dyn Trait`, `impl Trait` or
+/// `T where T: Trait`.
+///
+/// Note that the trait themselves can still be completed.
+/// Show full function / method signatures in completion docs.
+/// Omit deprecated items from completions. By default they are marked as deprecated but not
+/// hidden.
+/// Maximum number of completions to return. If `None`, the limit is infinite.
+/// Show postfix snippets like `dbg`, `if`, `not`, etc.
+/// Show completions of private items and fields that are defined in the current workspace
+/// even if they are not visible at the current position.
+/// Enable term search based snippets like `Some(foo.bar().baz())`.
+/// Term search fuel in "units of work" for autocompletion (Defaults to 1000).
+/// List of rust-analyzer diagnostics to disable.
+/// Show native rust-analyzer diagnostics.
+/// Show experimental rust-analyzer diagnostics that might have more false positives than
+/// usual.
+/// Map of prefixes to be substituted when parsing diagnostic file paths. This should be the
+/// reverse mapping of what is passed to `rustc` as `--remap-path-prefix`.
+/// Run additional style lints.
+/// List of warnings that should be displayed with hint severity.
+///
+/// The warnings will be indicated by faded text or three dots in code and will not show up
+/// in the `Problems Panel`.
+/// List of warnings that should be displayed with info severity.
+///
+/// The warnings will be indicated by a blue squiggly underline in code and a blue icon in
+/// the `Problems Panel`.
+/// Enforce the import granularity setting for all files. If set to false rust-analyzer will
+/// try to keep import styles consistent per file.
+/// How imports should be grouped into use statements.
+/// Group inserted imports by the [following
+/// order](https://rust-analyzer.github.io/book/features.html#auto-import). Groups are
+/// separated by newlines.
+/// Allow import insertion to merge new imports into single path glob imports like `use
+/// std::fmt::*;`.
+/// Prefer to unconditionally use imports of the core and alloc crate, over the std crate.
+/// Prefer import paths containing a `prelude` module.
+/// The path structure for newly inserted paths to use.
+/// Prefix external (including std, core) crate imports with `::`.
+///
+/// E.g. `use ::std::io::Read;`.
+/// Pass `--all-targets` to cargo invocation.
+/// Automatically refresh project info via `cargo metadata` on
+/// `Cargo.toml` or `.cargo/config.toml` changes.
+/// Run build scripts (`build.rs`) for more precise code analysis.
+/// Specifies the invocation strategy to use when running the build scripts command.
+/// If `per_workspace` is set, the command will be executed for each Rust workspace with the
+/// workspace as the working directory.
+/// If `once` is set, the command will be executed once with the opened project as the
+/// working directory.
+/// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`
+/// is set.
+/// Override the command rust-analyzer uses to run build scripts and
+/// build procedural macros. The command is required to output json
+/// and should therefore include `--message-format=json` or a similar
+/// option.
+///
+/// If there are multiple linked projects/workspaces, this command is invoked for
+/// each of them, with the working directory being the workspace root
+/// (i.e., the folder containing the `Cargo.toml`). This can be overwritten
+/// by changing `#rust-analyzer.cargo.buildScripts.invocationStrategy#`.
+///
+/// By default, a cargo invocation will be constructed for the configured
+/// targets and features, with the following base command line:
+///
+/// ```bash
+/// cargo check --quiet --workspace --message-format=json --all-targets --keep-going
+/// ```
+///
+/// Note: The option must be specified as an array of command line arguments, with
+/// the first argument being the name of the command to run.
+/// Rerun proc-macros building/build-scripts running when proc-macro
+/// or build-script sources change and are saved.
+/// Use `RUSTC_WRAPPER=rust-analyzer` when running build scripts to
+/// avoid checking unnecessary things.
+/// List of cfg options to enable with the given values.
+///
+/// To enable a name without a value, use `"key"`.
+/// To enable a name with a value, use `"key=value"`.
+/// To disable, prefix the entry with a `!`.
+/// Extra arguments that are passed to every cargo invocation.
+/// Extra environment variables that will be set when running cargo, rustc
+/// or other commands within the workspace. Useful for setting RUSTFLAGS.
+/// List of features to activate.
+///
+/// Set this to `"all"` to pass `--all-features` to cargo.
+/// Whether to pass `--no-default-features` to cargo.
+/// Whether to skip fetching dependencies. If set to "true", the analysis is performed
+/// entirely offline, and Cargo metadata for dependencies is not fetched.
+/// Relative path to the sysroot, or "discover" to try to automatically find it via
+/// "rustc --print sysroot".
+///
+/// Unsetting this disables sysroot loading.
+///
+/// This option does not take effect until rust-analyzer is restarted.
+/// Relative path to the sysroot library sources. If left unset, this will default to
+/// `{cargo.sysroot}/lib/rustlib/src/rust/library`.
+///
+/// This option does not take effect until rust-analyzer is restarted.
+/// Compilation target override (target tuple).
+// FIXME(@poliorcetics): move to multiple targets here too, but this will need more work
+// than `checkOnSave_target`
+/// Optional path to a rust-analyzer specific target directory.
+/// This prevents rust-analyzer's `cargo check` and initial build-script and proc-macro
+/// building from locking the `Cargo.lock` at the expense of duplicating build artifacts.
+///
+/// Set to `true` to use a subdirectory of the existing target directory or
+/// set to a path relative to the workspace to use that path.
+/// Set `cfg(test)` for local crates. Defaults to true.
+/// Run the check command for diagnostics on save.
+/// Check all targets and tests (`--all-targets`). Defaults to
+/// `#rust-analyzer.cargo.allTargets#`.
+/// Cargo command to use for `cargo check`.
+/// Extra arguments for `cargo check`.
+/// Extra environment variables that will be set when running `cargo check`.
+/// Extends `#rust-analyzer.cargo.extraEnv#`.
+/// List of features to activate. Defaults to
+/// `#rust-analyzer.cargo.features#`.
+///
+/// Set to `"all"` to pass `--all-features` to Cargo.
+/// List of `cargo check` (or other command specified in `check.command`) diagnostics to ignore.
+///
+/// For example for `cargo check`: `dead_code`, `unused_imports`, `unused_variables`,...
+/// Specifies the invocation strategy to use when running the check command.
+/// If `per_workspace` is set, the command will be executed for each workspace.
+/// If `once` is set, the command will be executed once.
+/// This config only has an effect when `#rust-analyzer.check.overrideCommand#`
+/// is set.
+/// Whether to pass `--no-default-features` to Cargo. Defaults to
+/// `#rust-analyzer.cargo.noDefaultFeatures#`.
+/// Override the command rust-analyzer uses instead of `cargo check` for
+/// diagnostics on save. The command is required to output json and
+/// should therefore include `--message-format=json` or a similar option
+/// (if your client supports the `colorDiagnosticOutput` experimental
+/// capability, you can use `--message-format=json-diagnostic-rendered-ansi`).
+///
+/// If you're changing this because you're using some tool wrapping
+/// Cargo, you might also want to change
+/// `#rust-analyzer.cargo.buildScripts.overrideCommand#`.
+///
+/// If there are multiple linked projects/workspaces, this command is invoked for
+/// each of them, with the working directory being the workspace root
+/// (i.e., the folder containing the `Cargo.toml`). This can be overwritten
+/// by changing `#rust-analyzer.check.invocationStrategy#`.
+///
+/// If `$saved_file` is part of the command, rust-analyzer will pass
+/// the absolute path of the saved file to the provided command. This is
+/// intended to be used with non-Cargo build systems.
+/// Note that `$saved_file` is experimental and may be removed in the future.
+///
+/// An example command would be:
+///
+/// ```bash
+/// cargo check --workspace --message-format=json --all-targets
+/// ```
+///
+/// Note: The option must be specified as an array of command line arguments, with
+/// the first argument being the name of the command to run.
+/// Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.
+///
+/// Can be a single target, e.g. `"x86_64-unknown-linux-gnu"` or a list of targets, e.g.
+/// `["aarch64-apple-darwin", "x86_64-apple-darwin"]`.
+///
+/// Aliased as `"checkOnSave.targets"`.
+/// Whether `--workspace` should be passed to `cargo check`.
+/// If false, `-p <package>` will be passed instead if applicable. In case it is not, no
+/// check will be performed.
+/// Exclude all locals from document symbol search.
+/// These proc-macros will be ignored when trying to expand them.
+///
+/// This config takes a map of crate names with the exported proc-macro names to ignore as values.
+/// Command to be executed instead of 'cargo' for runnables.
+/// Additional arguments to be passed to cargo for runnables such as
+/// tests or binaries. For example, it may be `--release`.
+/// Additional arguments to be passed through Cargo to launched tests, benchmarks, or
+/// doc-tests.
+///
+/// Unless the launched target uses a
+/// [custom test harness](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field),
+/// they will end up being interpreted as options to
+/// [`rustc`’s built-in test harness (“libtest”)](https://doc.rust-lang.org/rustc/tests/index.html#cli-arguments).
+/// Path to the Cargo.toml of the rust compiler workspace, for usage in rustc_private
+/// projects, or "discover" to try to automatically find it if the `rustc-dev` component
+/// is installed.
+///
+/// Any project which uses rust-analyzer with the rustcPrivate
+/// crates must set `[package.metadata.rust-analyzer] rustc_private=true` to use it.
+///
+/// This option does not take effect until rust-analyzer is restarted.
+/// Additional arguments to `rustfmt`.
+/// Advanced option, fully override the command rust-analyzer uses for
+/// formatting. This should be the equivalent of `rustfmt` here, and
+/// not that of `cargo fmt`. The file contents will be passed on the
+/// standard input and the formatted result will be read from the
+/// standard output.
+///
+/// Note: The option must be specified as an array of command line arguments, with
+/// the first argument being the name of the command to run.
+/// Enables the use of rustfmt's unstable range formatting command for the
+/// `textDocument/rangeFormatting` request. The rustfmt option is unstable and only
+/// available on a nightly build.
+/// Additional paths to include in the VFS. Generally for code that is
+/// generated or otherwise managed by a build system outside of Cargo,
+/// though Cargo might be the eventual consumer.
+/// Exclude all imports from workspace symbol search.
+///
+/// In addition to regular imports (which are always excluded),
+/// this option removes public imports (better known as re-exports)
+/// and removes imports that rename the imported symbol.
+/// Workspace symbol search kind.
+/// Limits the number of items returned from a workspace symbol search (Defaults to 128).
+/// Some clients like vs-code issue new searches on result filtering and don't require all results to be returned in the initial search.
+/// Other clients requires all results upfront and might require a higher limit.
+/// Workspace symbol search scope.
+/// Configs that only make sense when they are set by a client. As such they can only be defined
+/// by setting them using client's settings (e.g `settings.json` on VS Code).
+/// Controls file watching implementation.
 #[derive(Debug)]
 pub enum RatomlFileKind {
     Workspace,
     root_path: AbsPathBuf,
     snippets: Vec<Snippet>,
     client_info: Option<ClientInfo>,
-
     default_config: &'static DefaultConfigData,
     /// Config node that obtains its initial value during the server initialization and
     /// by receiving a `lsp_types::notification::DidChangeConfiguration`.
     client_config: (FullConfigInput, ConfigErrors),
-
     /// Config node whose values apply to **every** Rust project.
     user_config: Option<(GlobalWorkspaceLocalConfigInput, ConfigErrors)>,
-
     ratoml_file: FxHashMap<SourceRootId, (RatomlFile, ConfigErrors)>,
-
     /// Clone of the value that is stored inside a `GlobalState`.
     source_root_parent_map: Arc<FxHashMap<SourceRootId, SourceRootId>>,
-
     /// Use case : It is an error to have an empty value for `check_command`.
     /// Since it is a `global` command at the moment, its final value can only be determined by
     /// traversing through `global` configs and the `client` config. However the non-null value constraint
     /// is config level agnostic, so this requires an independent error storage
     validation_errors: ConfigErrors,
-
     detached_files: Vec<AbsPathBuf>,
 }
 
     }
 }
 
-// Delegate capability fetching methods
 impl std::ops::Deref for Config {
     type Target = ClientCapabilities;
 
         Arc::ptr_eq(&self.source_root_parent_map, other)
     }
 
-    // FIXME @alibektas : Server's health uses error sink but in other places it is not used atm.
     /// Changes made to client and global configurations will partially not be reflected even after `.apply_change()` was called.
     /// The return tuple's bool component signals whether the `GlobalState` should call its `update_configuration()` method.
     fn apply_change_with_sink(&self, change: ConfigChange) -> (Config, bool) {
 pub struct ConfigChange {
     user_config_change: Option<Arc<str>>,
     client_config_change: Option<serde_json::Value>,
-    ratoml_file_change:
-        Option<FxHashMap<SourceRootId, (RatomlFileKind, VfsPath, Option<Arc<str>>)>>,
+    ratoml_file_change: Option<FxHashMap<SourceRootId, (RatomlFileKind, VfsPath, Option<Arc<str>>)>>,
     source_map_change: Option<Arc<FxHashMap<SourceRootId, SourceRootId>>>,
 }
 
     }
 
     pub fn change_user_config(&mut self, content: Option<Arc<str>>) {
-        assert!(self.user_config_change.is_none()); // Otherwise it is a double write.
+        assert!(self.user_config_change.is_none());
+        // Otherwise it is a double write.
         self.user_config_change = content;
     }
 
 
 #[derive(Clone, Debug, PartialEq, Eq)]
 pub struct LensConfig {
-    // runnables
     pub run: bool,
     pub debug: bool,
     pub update_test: bool,
     pub interpret: bool,
-
-    // implementations
     pub implementations: bool,
-
-    // references
     pub method_refs: bool,
-    pub refs_adt: bool,   // for Struct, Enum, Union and Trait
-    pub refs_trait: bool, // for Struct, Enum, Union and Trait
+    pub refs_adt: bool,
+    pub refs_trait: bool,
     pub enum_variant_refs: bool,
-
-    // annotations
     pub location: AnnotationLocation,
     pub filter_adjacent_derive_implementations: bool,
 }
 
 #[derive(Debug, Clone)]
 pub enum RustfmtConfig {
-    Rustfmt { extra_args: Vec<String>, enable_range_formatting: bool },
-    CustomCommand { command: String, args: Vec<String> },
+    Rustfmt {
+        extra_args: Vec<String>,
+        enable_range_formatting: bool,
+    },
+    CustomCommand {
+        command: String,
+        args: Vec<String>,
+    },
 }
 
 /// Configuration for runnable items, such as `main` function or tests.
     /// How many items are returned at most.
     pub search_limit: usize,
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub struct ClientCommandsConfig {
     pub run_single: bool,
 
 #[derive(Debug)]
 pub enum ConfigErrorInner {
-    Json { config_key: String, error: serde_json::Error },
-    Toml { config_key: String, error: toml::de::Error },
-    ParseError { reason: String },
+    Json {
+        config_key: String,
+        error: serde_json::Error,
+    },
+    Toml {
+        config_key: String,
+        error: toml::de::Error,
+    },
+    ParseError {
+        reason: String,
+    },
 }
 
 #[derive(Clone, Debug, Default)]
     }
 }
 
-impl std::error::Error for ConfigErrors {}
+impl std::error::Error for ConfigErrors {
+}
 
 impl Config {
     pub fn new(
         DiagnosticsConfig {
             enabled: true,
             disable_experimental: false,
-            ..self.diagnostics(source_root)
         }
     }
 
         self.typing_triggerChars().as_deref().unwrap_or_default()
     }
 
-    // VSCode is our reference implementation, so we allow ourselves to work around issues by
-    // special casing certain versions
     pub fn visual_studio_code_version(&self) -> Option<&Version> {
         self.client_info
             .as_ref()
         self.client_info.as_ref().map(|it| it.name == "Neovim").unwrap_or_default()
     }
 }
-// Deserialization definitions
 
+// Deserialization definitions
 macro_rules! create_bool_or_string_serde {
     ($ident:ident<$bool:literal, $string:literal>) => {
         mod $ident {
         }
     };
 }
-create_bool_or_string_serde!(true_or_always<true, "always">);
-create_bool_or_string_serde!(false_or_never<false, "never">);
-
 #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq)]
 #[serde(rename_all = "snake_case")]
 #[derive(Default)]
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     prefix: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     postfix: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     body: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     requires: Vec<String>,
-
     #[serde(skip_serializing_if = "Option::is_none")]
     description: Option<String>,
-
     scope: SnippetScopeDef,
 }
 
 mod single_or_array {
     use serde::{Deserialize, Serialize};
-
     pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Vec<String>, D::Error>
     where
         D: serde::Deserializer<'de>,
 
         deserializer.deserialize_any(SingleOrVec)
     }
-
     pub(super) fn serialize<S>(vec: &[String], serializer: S) -> Result<S::Ok, S::Error>
     where
         S: serde::Serializer,
 #[serde(rename_all = "snake_case")]
 pub enum AutoImportExclusion {
     Path(String),
-    Verbose { path: String, r#type: AutoImportExclusionType },
+    Verbose {
+        path: String,
+        r#type: AutoImportExclusionType,
+    },
 }
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
 }
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
-struct CheckOnSaveTargets(#[serde(with = "single_or_array")] Vec<String>);
+struct CheckOnSaveTargets(Vec<String>);
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
 #[serde(rename_all = "snake_case")]
         default_
     }};
 }
-use _default_val as default_val;
 
 macro_rules! _default_str {
     ($default:expr, $ty:ty) => {{
         serde_json::to_string_pretty(&val).unwrap()
     }};
 }
-use _default_str as default_str;
 
 macro_rules! _impl_for_config_data {
     (local, $(
         }
     };
 }
-use _impl_for_config_data as impl_for_config_data;
 
 macro_rules! _config_data {
     // modname is for the tests
         }
     };
 }
-use _config_data as config_data;
 
 #[derive(Default, Debug, Clone)]
 struct DefaultConfigData {
 }
 
 impl GlobalWorkspaceLocalConfigInput {
-    const FIELDS: &'static [&'static [&'static str]] =
-        &[GlobalConfigInput::FIELDS, LocalConfigInput::FIELDS];
+    const FIELDS: &'static [&'static [&'static str]] = &[GlobalConfigInput::FIELDS, LocalConfigInput::FIELDS];
+
     fn from_toml(
         toml: toml::Table,
         error_sink: &mut Vec<(String, toml::de::Error)>,
 
 impl WorkspaceLocalConfigInput {
     #[allow(dead_code)]
-    const FIELDS: &'static [&'static [&'static str]] =
-        &[WorkspaceConfigInput::FIELDS, LocalConfigInput::FIELDS];
+    const FIELDS: &'static [&'static [&'static str]] = &[WorkspaceConfigInput::FIELDS, LocalConfigInput::FIELDS];
+
     fn from_toml(toml: toml::Table, error_sink: &mut Vec<(String, toml::de::Error)>) -> Self {
         Self {
             workspace: WorkspaceConfigInput::from_toml(&toml, error_sink),
 #[cfg(test)]
 mod tests {
     use std::{borrow::Cow, fs};
-
     use test_utils::{ensure_file_contents, project_root};
-
     use super::*;
-
     #[test]
     fn generate_package_json_config() {
         let s = Config::json_schema();
         schema.push_str(",\n");
 
         // Transform the asciidoc form link to markdown style.
+
         //
+
         // https://link[text] => [text](https://link)
         let url_matches = schema.match_indices("https://");
         let mut url_offsets = url_matches.map(|(idx, _)| idx).collect::<Vec<usize>>();
             ensure_file_contents(package_json_path.as_std_path(), &package_json)
         }
     }
-
     #[test]
     fn generate_config_documentation() {
         let docs_path = project_root().join("docs/book/src/configuration_generated.md");
         let expected = FullConfigInput::manual();
         ensure_file_contents(docs_path.as_std_path(), &expected);
     }
-
     fn remove_ws(text: &str) -> String {
         text.replace(char::is_whitespace, "")
     }
-
     #[test]
     fn proc_macro_srv_null() {
         let mut config =
         (config, _, _) = config.apply_change(change);
         assert_eq!(config.proc_macro_srv(), None);
     }
-
     #[test]
     fn proc_macro_srv_abs() {
         let mut config =
         (config, _, _) = config.apply_change(change);
         assert_eq!(config.proc_macro_srv(), Some(AbsPathBuf::assert(project_root())));
     }
-
     #[test]
     fn proc_macro_srv_rel() {
         let mut config =
             Some(AbsPathBuf::try_from(project_root().join("./server")).unwrap())
         );
     }
-
     #[test]
     fn cargo_target_dir_unset() {
         let mut config =
             }
         ));
     }
-
     #[test]
     fn cargo_target_dir_subdir() {
         let mut config =
                 == Some(ws_target_dir.join("rust-analyzer"))
         ));
     }
-
     #[test]
     fn cargo_target_dir_relative_dir() {
         let mut config =