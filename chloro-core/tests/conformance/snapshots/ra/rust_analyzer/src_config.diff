COMPARISON DIFF
============================================================

Original size: 167117 bytes
Chloro size:   166432 bytes
Rustfmt size:  167117 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Config used by the language server.
 //!
 //! Of particular interest is the `feature_flags` hash map: while other fields
 //! configure the server itself, feature flags are passed into analysis, and
 //! tweak things like automatic insertion of `()` in completions.
+
+mod patch_old_style;
+
 use std::{env, fmt, iter, ops::Not, sync::OnceLock};
 
 use cfg::{CfgAtom, CfgDiff};
     MemoryLayoutHoverRenderKind, RenameConfig, Snippet, SnippetScope, SourceRootId,
 };
 use ide_db::{
-    MiniCore, SnippetCap,
     assists::ExprFillDefaultMode,
     imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},
+    MiniCore, SnippetCap,
 };
 use itertools::{Either, Itertools};
 use paths::{Utf8Path, Utf8PathBuf};
 use rustc_hash::{FxHashMap, FxHashSet};
 use semver::Version;
 use serde::{
-    Deserialize, Serialize,
     de::{DeserializeOwned, Error},
+    Deserialize, Serialize,
 };
 use stdx::format_to_acc;
 use triomphe::Arc;
 use vfs::{AbsPath, AbsPathBuf, VfsPath};
+use _config_data as config_data;
+use _default_str as default_str;
+use _default_val as default_val;
+use _impl_for_config_data as impl_for_config_data;
 
 use crate::{
     diagnostics::DiagnosticsMapConfig,
 
 type FxIndexMap<K, V> = indexmap::IndexMap<K, V, rustc_hash::FxBuildHasher>;
 
-mod patch_old_style;
-
 // Conventions for configuration keys to preserve maximal extendability without breakage:
-//  - Toggles (be it binary true/false or with more options in-between) should almost always suffix as `_enable`
-//    This has the benefit of namespaces being extensible, and if the suffix doesn't fit later it can be changed without breakage.
-//  - In general be wary of using the namespace of something verbatim, it prevents us from adding subkeys in the future
-//  - Don't use abbreviations unless really necessary
-//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command
 
+//  - Toggles (be it binary true/false or with more options in-between) should almost always suffix as `_enable`
+
+//    This has the benefit of namespaces being extensible, and if the suffix doesn't fit later it can be changed without breakage.
+
+//  - In general be wary of using the namespace of something verbatim, it prevents us from adding subkeys in the future
+
+//  - Don't use abbreviations unless really necessary
+
+//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command
 #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
 #[serde(rename_all = "camelCase")]
 pub enum MaxSubstitutionLength {
     Limit(usize),
 }
 
-// Defines the server-side configuration of the rust-analyzer. We generate *parts* of VS Code's
-// `package.json` config from this. Run `cargo test` to re-generate that file.
-//
-// However, editor specific config, which the server doesn't know about, should be specified
-// directly in `package.json`.
-//
-// To deprecate an option by replacing it with another name use `new_name` | `old_name` so that we
-// keep parsing the old name.
 config_data! {
     /// Configs that apply on a workspace-wide scope. There are 2 levels on which a global
     /// configuration can be configured
     root_path: AbsPathBuf,
     snippets: Vec<Snippet>,
     client_info: Option<ClientInfo>,
-
     default_config: &'static DefaultConfigData,
     /// Config node that obtains its initial value during the server initialization and
     /// by receiving a `lsp_types::notification::DidChangeConfiguration`.
     client_config: (FullConfigInput, ConfigErrors),
-
     /// Config node whose values apply to **every** Rust project.
     user_config: Option<(GlobalWorkspaceLocalConfigInput, ConfigErrors)>,
-
     ratoml_file: FxHashMap<SourceRootId, (RatomlFile, ConfigErrors)>,
-
     /// Clone of the value that is stored inside a `GlobalState`.
     source_root_parent_map: Arc<FxHashMap<SourceRootId, SourceRootId>>,
-
     /// Use case : It is an error to have an empty value for `check_command`.
     /// Since it is a `global` command at the moment, its final value can only be determined by
     /// traversing through `global` configs and the `client` config. However the non-null value constraint
     /// is config level agnostic, so this requires an independent error storage
     validation_errors: ConfigErrors,
-
     detached_files: Vec<AbsPathBuf>,
 }
 
     }
 }
 
-// Delegate capability fetching methods
 impl std::ops::Deref for Config {
     type Target = ClientCapabilities;
 
         Arc::ptr_eq(&self.source_root_parent_map, other)
     }
 
-    // FIXME @alibektas : Server's health uses error sink but in other places it is not used atm.
     /// Changes made to client and global configurations will partially not be reflected even after `.apply_change()` was called.
     /// The return tuple's bool component signals whether the `GlobalState` should call its `update_configuration()` method.
     fn apply_change_with_sink(&self, change: ConfigChange) -> (Config, bool) {
 pub struct ConfigChange {
     user_config_change: Option<Arc<str>>,
     client_config_change: Option<serde_json::Value>,
-    ratoml_file_change:
-        Option<FxHashMap<SourceRootId, (RatomlFileKind, VfsPath, Option<Arc<str>>)>>,
+    ratoml_file_change: Option<FxHashMap<SourceRootId, (RatomlFileKind, VfsPath, Option<Arc<str>>)>>,
     source_map_change: Option<Arc<FxHashMap<SourceRootId, SourceRootId>>>,
 }
 
     }
 
     pub fn change_user_config(&mut self, content: Option<Arc<str>>) {
-        assert!(self.user_config_change.is_none()); // Otherwise it is a double write.
+        assert!(self.user_config_change.is_none());
+        // Otherwise it is a double write.
         self.user_config_change = content;
     }
 
     pub debug: bool,
     pub update_test: bool,
     pub interpret: bool,
-
     // implementations
     pub implementations: bool,
-
     // references
     pub method_refs: bool,
-    pub refs_adt: bool,   // for Struct, Enum, Union and Trait
-    pub refs_trait: bool, // for Struct, Enum, Union and Trait
+    pub refs_adt: bool,
+    // for Struct, Enum, Union and Trait
+    pub refs_trait: bool,
+    // for Struct, Enum, Union and Trait
     pub enum_variant_refs: bool,
-
     // annotations
     pub location: AnnotationLocation,
     pub filter_adjacent_derive_implementations: bool,
 
 #[derive(Debug, Clone)]
 pub enum RustfmtConfig {
-    Rustfmt { extra_args: Vec<String>, enable_range_formatting: bool },
-    CustomCommand { command: String, args: Vec<String> },
+    Rustfmt {
+        extra_args: Vec<String>,
+        enable_range_formatting: bool,
+    },
+    CustomCommand {
+        command: String,
+        args: Vec<String>,
+    },
 }
 
 /// Configuration for runnable items, such as `main` function or tests.
     /// How many items are returned at most.
     pub search_limit: usize,
 }
+
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub struct ClientCommandsConfig {
     pub run_single: bool,
 
 #[derive(Debug)]
 pub enum ConfigErrorInner {
-    Json { config_key: String, error: serde_json::Error },
-    Toml { config_key: String, error: toml::de::Error },
-    ParseError { reason: String },
+    Json {
+        config_key: String,
+        error: serde_json::Error,
+    },
+    Toml {
+        config_key: String,
+        error: toml::de::Error,
+    },
+    ParseError {
+        reason: String,
+    },
 }
 
 #[derive(Clone, Debug, Default)]
 
 impl fmt::Display for ConfigErrors {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        let errors = self.0.iter().format_with("\n", |inner, f| {
+        let errors = self.0
+            .iter()
+            .format_with("\n", |inner, f| {
             match &**inner {
                 ConfigErrorInner::Json { config_key: key, error: e } => {
                     f(key)?;
     }
 }
 
-impl std::error::Error for ConfigErrors {}
+impl std::error::Error for ConfigErrors {
+}
 
 impl Config {
     pub fn new(
         DiagnosticsConfig {
             enabled: true,
             disable_experimental: false,
-            ..self.diagnostics(source_root)
         }
     }
 
     }
 
     fn discovered_projects(&self) -> Vec<ManifestOrProjectJson> {
-        let exclude_dirs: Vec<_> =
-            self.files_exclude().iter().map(|p| self.root_path.join(p)).collect();
+        let exclude_dirs: Vec<_> = self.files_exclude().iter().map(|p| self.root_path.join(p)).collect();
 
         let mut projects = vec![];
         for fs_proj in &self.discovered_projects_from_filesystem {
     }
 
     pub fn cargo(&self, source_root: Option<SourceRootId>) -> CargoConfig {
-        let rustc_source = self.rustc_source(source_root).as_ref().map(|rustc_src| {
+        let rustc_source = self
+            .rustc_source(source_root)
+            .as_ref()
+            .map(|rustc_src| {
             if rustc_src == "discover" {
                 RustLibSource::Discover
             } else {
                 RustLibSource::Path(self.root_path.join(rustc_src))
             }
         });
-        let sysroot = self.cargo_sysroot(source_root).as_ref().map(|sysroot| {
+        let sysroot = self
+            .cargo_sysroot(source_root)
+            .as_ref()
+            .map(|sysroot| {
             if sysroot == "discover" {
                 RustLibSource::Discover
             } else {
                 RustLibSource::Path(self.root_path.join(sysroot))
             }
         });
-        let sysroot_src =
-            self.cargo_sysrootSrc(source_root).as_ref().map(|sysroot| self.root_path.join(sysroot));
+        let sysroot_src = self.cargo_sysrootSrc(source_root).as_ref().map(|sysroot| self.root_path.join(sysroot));
         let extra_includes = self
             .vfs_extraIncludes(source_root)
             .iter()
         self.typing_triggerChars().as_deref().unwrap_or_default()
     }
 
-    // VSCode is our reference implementation, so we allow ourselves to work around issues by
-    // special casing certain versions
     pub fn visual_studio_code_version(&self) -> Option<&Version> {
         self.client_info
             .as_ref()
         self.client_info.as_ref().map(|it| it.name == "Neovim").unwrap_or_default()
     }
 }
-// Deserialization definitions
 
+// Deserialization definitions
 macro_rules! create_bool_or_string_serde {
     ($ident:ident<$bool:literal, $string:literal>) => {
         mod $ident {
         }
     };
 }
+
 create_bool_or_string_serde!(true_or_always<true, "always">);
+
 create_bool_or_string_serde!(false_or_never<false, "never">);
 
 #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq)]
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     prefix: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     postfix: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     body: Vec<String>,
-
     #[serde(with = "single_or_array")]
     #[serde(skip_serializing_if = "Vec::is_empty")]
     requires: Vec<String>,
-
     #[serde(skip_serializing_if = "Option::is_none")]
     description: Option<String>,
-
     scope: SnippetScopeDef,
 }
 
 mod single_or_array {
     use serde::{Deserialize, Serialize};
-
     pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Vec<String>, D::Error>
     where
         D: serde::Deserializer<'de>,
 
         deserializer.deserialize_any(SingleOrVec)
     }
-
     pub(super) fn serialize<S>(vec: &[String], serializer: S) -> Result<S::Ok, S::Error>
     where
         S: serde::Serializer,
 #[serde(rename_all = "snake_case")]
 pub enum AutoImportExclusion {
     Path(String),
-    Verbose { path: String, r#type: AutoImportExclusionType },
+    Verbose {
+        path: String,
+        r#type: AutoImportExclusionType,
+    },
 }
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
 }
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
-struct CheckOnSaveTargets(#[serde(with = "single_or_array")] Vec<String>);
+struct CheckOnSaveTargets(Vec<String>);
 
 #[derive(Serialize, Deserialize, Debug, Clone)]
 #[serde(rename_all = "snake_case")]
         default_
     }};
 }
-use _default_val as default_val;
 
 macro_rules! _default_str {
     ($default:expr, $ty:ty) => {{
         serde_json::to_string_pretty(&val).unwrap()
     }};
 }
-use _default_str as default_str;
 
 macro_rules! _impl_for_config_data {
     (local, $(
         }
     };
 }
-use _impl_for_config_data as impl_for_config_data;
 
 macro_rules! _config_data {
     // modname is for the tests
         }
     };
 }
-use _config_data as config_data;
 
 #[derive(Default, Debug, Clone)]
 struct DefaultConfigData {
 }
 
 impl GlobalWorkspaceLocalConfigInput {
-    const FIELDS: &'static [&'static [&'static str]] =
-        &[GlobalConfigInput::FIELDS, LocalConfigInput::FIELDS];
+    const FIELDS: &'static [&'static [&'static str]] = &[GlobalConfigInput::FIELDS, LocalConfigInput::FIELDS];
+
     fn from_toml(
         toml: toml::Table,
         error_sink: &mut Vec<(String, toml::de::Error)>,
 
 impl WorkspaceLocalConfigInput {
     #[allow(dead_code)]
-    const FIELDS: &'static [&'static [&'static str]] =
-        &[WorkspaceConfigInput::FIELDS, LocalConfigInput::FIELDS];
+    const FIELDS: &'static [&'static [&'static str]] = &[WorkspaceConfigInput::FIELDS, LocalConfigInput::FIELDS];
+
     fn from_toml(toml: toml::Table, error_sink: &mut Vec<(String, toml::de::Error)>) -> Self {
         Self {
             workspace: WorkspaceConfigInput::from_toml(&toml, error_sink),
                 }
             })
         })
-        .collect::<Vec<_>>();
+        .collect();
     map.into()
 }
 
         doc.ends_with('.') && doc.starts_with(char::is_uppercase),
         "bad docs for {field}: {doc:?}"
     );
-    let default = default.parse::<serde_json::Value>().unwrap();
+    let default = default.parse().unwrap();
 
     let mut map = serde_json::Map::default();
     macro_rules! set {
 #[cfg(test)]
 mod tests {
     use std::{borrow::Cow, fs};
-
     use test_utils::{ensure_file_contents, project_root};
-
     use super::*;
-
     #[test]
     fn generate_package_json_config() {
         let s = Config::json_schema();
         schema.push_str(",\n");
 
         // Transform the asciidoc form link to markdown style.
+
         //
+
         // https://link[text] => [text](https://link)
         let url_matches = schema.match_indices("https://");
-        let mut url_offsets = url_matches.map(|(idx, _)| idx).collect::<Vec<usize>>();
+        let mut url_offsets = url_matches.map(|(idx, _)| idx).collect();
         url_offsets.reverse();
         for idx in url_offsets {
             let link = &schema[idx..];
         let package_json_path = project_root().join("editors/code/package.json");
         let mut package_json = fs::read_to_string(&package_json_path).unwrap();
 
-        let start_marker =
-            "            {\n                \"title\": \"$generated-start\"\n            },\n";
-        let end_marker =
-            "            {\n                \"title\": \"$generated-end\"\n            }\n";
+        let start_marker = "            {\n                \"title\": \"$generated-start\"\n            },\n";
+        let end_marker = "            {\n                \"title\": \"$generated-end\"\n            }\n";
 
         let start = package_json.find(start_marker).unwrap() + start_marker.len();
         let end = package_json.find(end_marker).unwrap();
             ensure_file_contents(package_json_path.as_std_path(), &package_json)
         }
     }
-
     #[test]
     fn generate_config_documentation() {
         let docs_path = project_root().join("docs/book/src/configuration_generated.md");
         let expected = FullConfigInput::manual();
         ensure_file_contents(docs_path.as_std_path(), &expected);
     }
-
     fn remove_ws(text: &str) -> String {
         text.replace(char::is_whitespace, "")
     }
-
     #[test]
     fn proc_macro_srv_null() {
-        let mut config =
-            Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
+        let mut config = Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
 
         let mut change = ConfigChange::default();
-        change.change_client_config(serde_json::json!({
+        change
+            .change_client_config(serde_json::json!({
             "procMacro" : {
                 "server": null,
         }}));
         (config, _, _) = config.apply_change(change);
         assert_eq!(config.proc_macro_srv(), None);
     }
-
     #[test]
     fn proc_macro_srv_abs() {
-        let mut config =
-            Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
+        let mut config = Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
         let mut change = ConfigChange::default();
-        change.change_client_config(serde_json::json!({
+        change
+            .change_client_config(serde_json::json!({
         "procMacro" : {
             "server": project_root().to_string(),
         }}));
         (config, _, _) = config.apply_change(change);
         assert_eq!(config.proc_macro_srv(), Some(AbsPathBuf::assert(project_root())));
     }
-
     #[test]
     fn proc_macro_srv_rel() {
-        let mut config =
-            Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
+        let mut config = Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
 
         let mut change = ConfigChange::default();
 
-        change.change_client_config(serde_json::json!({
+        change
+            .change_client_config(serde_json::json!({
         "procMacro" : {
             "server": "./server"
         }}));
             Some(AbsPathBuf::try_from(project_root().join("./server")).unwrap())
         );
     }
-
     #[test]
     fn cargo_target_dir_unset() {
-        let mut config =
-            Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
+        let mut config = Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
 
         let mut change = ConfigChange::default();
 
-        change.change_client_config(serde_json::json!({
+        change
+            .change_client_config(serde_json::json!({
             "rust" : { "analyzerTargetDir" : null }
         }));
 
             }
         ));
     }
-
     #[test]
     fn cargo_target_dir_subdir() {
-        let mut config =
-            Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
+        let mut config = Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
 
         let mut change = ConfigChange::default();
-        change.change_client_config(serde_json::json!({
+        change
+            .change_client_config(serde_json::json!({
             "rust" : { "analyzerTargetDir" : true }
         }));
 
         (config, _, _) = config.apply_change(change);
 
         assert_eq!(config.cargo_targetDir(None), &Some(TargetDirectory::UseSubdirectory(true)));
-        let ws_target_dir =
-            Utf8PathBuf::from(std::env::var("CARGO_TARGET_DIR").unwrap_or("target".to_owned()));
+        let ws_target_dir = Utf8PathBuf::from(std::env::var("CARGO_TARGET_DIR").unwrap_or("target".to_owned()));
         assert!(matches!(
             config.flycheck(None),
             FlycheckConfig::CargoCommand {
                 == Some(ws_target_dir.join("rust-analyzer"))
         ));
     }
-
     #[test]
     fn cargo_target_dir_relative_dir() {
-        let mut config =
-            Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
+        let mut config = Config::new(AbsPathBuf::assert(project_root()), Default::default(), vec![], None);
 
         let mut change = ConfigChange::default();
-        change.change_client_config(serde_json::json!({
+        change
+            .change_client_config(serde_json::json!({
             "rust" : { "analyzerTargetDir" : "other_folder" }
         }));
 