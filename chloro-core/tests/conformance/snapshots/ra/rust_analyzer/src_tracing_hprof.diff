COMPARISON DIFF
============================================================

Original size: 7455 bytes
Chloro size:   7677 bytes
Rustfmt size:  7718 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use rustc_hash::FxHashSet;
 use tracing::{
+    Event, Id, Level, Subscriber,
     field::{Field, Visit},
     span::Attributes,
-    Event, Id, Level, Subscriber,
 };
 use tracing_subscriber::{
-    filter,
-    layer::{Context, SubscriberExt},
-    registry::LookupSpan,
-    Layer, Registry,
+    filter, layer::{Context, registry::LookupSpan, Layer, Registry, SubscriberExt},
 };
 
 pub fn init(spec: &str) -> tracing::subscriber::DefaultGuard {
 
 impl<S> SpanTree<S>
 where
-    S: Subscriber + for<'span> tracing_subscriber::registry::LookupSpan<'span>,
-{
+    S: Subscriber + for<'span> tracing_subscriber::registry::LookupSpan<'span>, {
     pub(crate) fn new(spec: &str) -> impl Layer<S> {
         let (write_filter, allowed_names) = WriteFilter::from_spec(spec);
-
         // this filter the first pass for `tracing`: these are all the "profiling" spans, but things like
         // span depth or duration are not filtered here: that only occurs at write time.
         let profile_filter = filter::filter_fn(move |metadata| {
                 && metadata.name() != "compute_exhaustiveness_and_usefulness"
                 && !metadata.target().starts_with("chalk")
         });
-
-        Self {
-            aggregate: true,
-            write_filter,
-            _inner: PhantomData,
-        }
-        .with_filter(profile_filter)
+        Self { aggregate: true, write_filter, _inner: PhantomData }.with_filter(profile_filter)
     }
 }
 
 
 impl Data {
     fn new(attrs: &Attributes<'_>) -> Self {
-        let mut data = Self {
-            start: Instant::now(),
-            children: Vec::new(),
-            fields: String::new(),
-        };
-
-        let mut visitor = DataVisitor {
-            string: &mut data.fields,
-        };
+        let mut data = Self { start: Instant::now(), children: Vec::new(), fields: String::new() };
+        let mut visitor = DataVisitor { string: &mut data.fields };
         attrs.record(&mut visitor);
         data
     }
 
-    fn into_node(self, name: &'static str) -> Node {
+    fn into_node(
+        self,
+        name: &'static str,
+    ) -> Node {
         Node {
             name,
             fields: self.fields,
 }
 
 impl Visit for DataVisitor<'_> {
-    fn record_debug(&mut self, field: &Field, value: &dyn std::fmt::Debug) {
+    fn record_debug(
+        &mut self,
+        field: &Field,
+        value: &dyn std::fmt::Debug,
+    ) {
         write!(self.string, "{} = {:?} ", field.name(), value).unwrap();
     }
 }
 
 impl<S> Layer<S> for SpanTree<S>
 where
-    S: Subscriber + for<'span> LookupSpan<'span>,
-{
-    fn on_new_span(&self, attrs: &Attributes<'_>, id: &Id, ctx: Context<'_, S>) {
+    S: Subscriber + for<'span> LookupSpan<'span>, {
+    fn on_new_span(
+        &self,
+        attrs: &Attributes<'_>,
+        id: &Id,
+        ctx: Context<'_, S>,
+    ) {
         let span = ctx.span(id).unwrap();
-
         let data = Data::new(attrs);
         span.extensions_mut().insert(data);
     }
 
-    fn on_event(&self, _event: &Event<'_>, _ctx: Context<'_, S>) {}
+    fn on_event(
+        &self,
+        _event: &Event<'_>,
+        _ctx: Context<'_, S>,
+    ) {
+    }
 
-    fn on_close(&self, id: Id, ctx: Context<'_, S>) {
+    fn on_close(
+        &self,
+        id: Id,
+        ctx: Context<'_, S>,
+    ) {
         let span = ctx.span(&id).unwrap();
         let data = span.extensions_mut().remove::<Data>().unwrap();
         let mut node = data.into_node(span.name());
-
         match span.parent() {
             Some(parent_span) => {
-                parent_span
-                    .extensions_mut()
-                    .get_mut::<Data>()
-                    .unwrap()
-                    .children
-                    .push(node);
+                parent_span.extensions_mut().get_mut::<Data>().unwrap().children.push(node);
             }
             None => {
                 if self.aggregate {
 }
 
 impl Node {
-    fn print(&self, filter: &WriteFilter) {
+    fn print(
+        &self,
+        filter: &WriteFilter,
+    ) {
         self.go(0, filter)
     }
 
     #[allow(clippy::print_stderr)]
-    fn go(&self, level: usize, filter: &WriteFilter) {
+    fn go(
+        &self,
+        level: usize,
+        filter: &WriteFilter,
+    ) {
         if self.duration > filter.longer_than && level < filter.depth {
             let duration = ms(self.duration);
             let current_indent = level * 2;
         if self.children.is_empty() {
             return;
         }
-
         self.children.sort_by_key(|it| it.name);
         let mut idx = 0;
         for i in 1..self.children.len() {
 impl WriteFilter {
     pub(crate) fn from_spec(mut spec: &str) -> (WriteFilter, Option<FxHashSet<String>>) {
         let longer_than = if let Some(idx) = spec.rfind('>') {
-            let longer_than = spec[idx + 1..]
-                .parse()
-                .expect("invalid profile longer_than");
+            let longer_than = spec[idx + 1..].parse().expect("invalid profile longer_than");
             spec = &spec[..idx];
             Duration::from_millis(longer_than)
         } else {
             Duration::new(0, 0)
         };
-
         let depth = if let Some(idx) = spec.rfind('@') {
             let depth: usize = spec[idx + 1..].parse().expect("invalid profile depth");
             spec = &spec[..idx];
 struct ms(Duration);
 
 impl std::fmt::Display for ms {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut std::fmt::Formatter<'_>,
+    ) -> std::fmt::Result {
         let n = self.0.as_millis();
         write!(f, "{n:5}ms")
     }