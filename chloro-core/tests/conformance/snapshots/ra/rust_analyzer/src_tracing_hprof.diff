COMPARISON DIFF
============================================================

Original size: 7455 bytes
Chloro size:   7456 bytes
Rustfmt size:  7718 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use rustc_hash::FxHashSet;
 use tracing::{
+    Event, Id, Level, Subscriber,
     field::{Field, Visit},
     span::Attributes,
-    Event, Id, Level, Subscriber,
 };
 use tracing_subscriber::{
-    filter,
+    Layer, Registry, filter,
     layer::{Context, SubscriberExt},
     registry::LookupSpan,
-    Layer, Registry,
 };
 
 pub fn init(spec: &str) -> tracing::subscriber::DefaultGuard {
         let (write_filter, allowed_names) = WriteFilter::from_spec(spec);
 
         // this filter the first pass for `tracing`: these are all the "profiling" spans, but things like
+
         // span depth or duration are not filtered here: that only occurs at write time.
         let profile_filter = filter::filter_fn(move |metadata| {
             let allowed = match &allowed_names {
                 && !metadata.target().starts_with("chalk")
         });
 
-        Self {
-            aggregate: true,
-            write_filter,
-            _inner: PhantomData,
-        }
-        .with_filter(profile_filter)
+        Self { aggregate: true, write_filter, _inner: PhantomData }.with_filter(profile_filter)
     }
 }
 
 
 impl Data {
     fn new(attrs: &Attributes<'_>) -> Self {
-        let mut data = Self {
-            start: Instant::now(),
-            children: Vec::new(),
-            fields: String::new(),
-        };
+        let mut data = Self { start: Instant::now(), children: Vec::new(), fields: String::new() };
 
-        let mut visitor = DataVisitor {
-            string: &mut data.fields,
-        };
+        let mut visitor = DataVisitor { string: &mut data.fields };
         attrs.record(&mut visitor);
         data
     }
         span.extensions_mut().insert(data);
     }
 
-    fn on_event(&self, _event: &Event<'_>, _ctx: Context<'_, S>) {}
+    fn on_event(&self, _event: &Event<'_>, _ctx: Context<'_, S>) {
+    }
 
     fn on_close(&self, id: Id, ctx: Context<'_, S>) {
         let span = ctx.span(&id).unwrap();
 
         match span.parent() {
             Some(parent_span) => {
-                parent_span
-                    .extensions_mut()
-                    .get_mut::<Data>()
-                    .unwrap()
-                    .children
-                    .push(node);
+                parent_span.extensions_mut().get_mut::<Data>().unwrap().children.push(node);
             }
             None => {
                 if self.aggregate {
         if self.duration > filter.longer_than && level < filter.depth {
             let duration = ms(self.duration);
             let current_indent = level * 2;
-
             let mut out = String::new();
             let _ = write!(out, "{:current_indent$}   {duration} {:<6}", "", self.name);
-
             if !self.fields.is_empty() {
                 let _ = write!(out, " @ {}", self.fields);
             }
-
             if self.count > 1 {
                 let _ = write!(out, " ({} calls)", self.count);
             }
-
             eprintln!("{out}");
-
             for child in &self.children {
                 child.go(level + 1, filter)
             }
 impl WriteFilter {
     pub(crate) fn from_spec(mut spec: &str) -> (WriteFilter, Option<FxHashSet<String>>) {
         let longer_than = if let Some(idx) = spec.rfind('>') {
-            let longer_than = spec[idx + 1..]
-                .parse()
-                .expect("invalid profile longer_than");
+            let longer_than = spec[idx + 1..].parse().expect("invalid profile longer_than");
             spec = &spec[..idx];
             Duration::from_millis(longer_than)
         } else {