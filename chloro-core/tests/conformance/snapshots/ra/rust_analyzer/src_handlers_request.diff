COMPARISON DIFF
============================================================

Original size: 101181 bytes
Chloro size:   100527 bytes
Rustfmt size:  101181 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use anyhow::Context;
 
 use base64::{Engine, prelude::BASE64_STANDARD};
+use ide_db::{FxHashMap, SymbolKind};
 use ide::{
     AssistKind, AssistResolveStrategy, Cancellable, CompletionFieldsToResolve, FilePosition,
     FileRange, FileStructureConfig, FindAllRefsConfig, HoverAction, HoverGotoTypeData,
     InlayFieldsToResolve, Query, RangeInfo, ReferenceCategory, Runnable, RunnableKind,
     SingleResolve, SourceChange, TextEdit,
 };
-use ide_db::{FxHashMap, SymbolKind};
 use itertools::Itertools;
 use lsp_server::ErrorCode;
 use lsp_types::{
     diagnostics::convert_diagnostic,
     global_state::{FetchWorkspaceRequest, GlobalState, GlobalStateSnapshot},
     line_index::LineEndings,
+    lsp_ext::{
+        self, CrateInfoResult, ExternalDocsPair, ExternalDocsResponse, FetchDependencyListParams,
+        FetchDependencyListResult, PositionOrRange, ViewCrateGraphParams, WorkspaceSymbolParams,
+    },
     lsp::{
         LspError, completion_item_hash,
         ext::{
             InternalTestingFetchConfigOption, InternalTestingFetchConfigParams,
             InternalTestingFetchConfigResponse,
         },
-        from_proto, to_proto,
-        utils::{all_edits_are_disjoint, invalid_params_error},
-    },
-    lsp_ext::{
-        self, CrateInfoResult, ExternalDocsPair, ExternalDocsResponse, FetchDependencyListParams,
-        FetchDependencyListResult, PositionOrRange, ViewCrateGraphParams, WorkspaceSymbolParams,
+        from_proto, to_proto, utils::{all_edits_are_disjoint, invalid_params_error},
     },
     target_spec::{CargoTargetSpec, TargetSpec},
     test_runner::{CargoTestHandle, TestTarget},
             when building from source, or pass `--enable-profiling` to `cargo xtask`."
         ))
     }
-    #[cfg(feature = "dhat")]
-    {
+    #[cfg(feature = "dhat")] {
         if let Some(dhat_output_file) = _state.config.dhat_output_file() {
+            // Need to drop the old profiler before creating a new one.
             let mut profiler = crate::DHAT_PROFILER.lock().unwrap();
             let old_profiler = profiler.take();
-            // Need to drop the old profiler before creating a new one.
             drop(old_profiler);
             *profiler = Some(dhat::Profiler::builder().file_name(&dhat_output_file).build());
             Ok(format!(
     Ok(res)
 }
 
-// cargo test requires:
-// - the package is a member of the workspace
-// - the target in the package is not a build script (custom-build)
-// - the package name - the root of the test identifier supplied to this handler can be
-//   a package or a target inside a package.
-// - the target name - if the test identifier is a target, it's needed in addition to the
-//   package name to run the right test
-// - real names - the test identifier uses the namespace form where hyphens are replaced with
-//   underscores. cargo test requires the real name.
-// - the target kind e.g. bin or lib
 fn all_test_targets(cargo: &CargoWorkspace) -> impl Iterator<Item = TestTarget> {
     cargo.packages().filter(|p| cargo[*p].is_member).flat_map(|p| {
         let package = &cargo[p];
     let line_index = snap.file_line_index(position.file_id)?;
 
     // in `ide`, the `on_type` invariant is that
+
     // `text.char_at(position) == typed_char`.
+
     position.offset -= TextSize::of('.');
 
     let text = snap.analysis.file_text(position.file_id)?;
     };
 
     // This should be a single-file edit
+
     let (_, (text_edit, snippet_edit)) = edit.source_file_edits.into_iter().next().unwrap();
     stdx::always!(snippet_edit.is_none(), "on type formatting shouldn't use structured snippets");
 
 }
 
 pub(crate) fn empty_diagnostic_report() -> lsp_types::DocumentDiagnosticReportResult {
-    lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(
-        lsp_types::RelatedFullDocumentDiagnosticReport {
-            related_documents: None,
-            full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
-                result_id: Some("rust-analyzer".to_owned()),
-                items: vec![],
-            },
+    lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
+        related_documents: None,
+        full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
+            result_id: Some("rust-analyzer".to_owned()),
+            items: vec![],
         },
-    ))
+    }))
 }
 
 pub(crate) fn handle_document_diagnostics(
             }
             None
         });
-    Ok(lsp_types::DocumentDiagnosticReportResult::Report(
-        lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
-            full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
-                result_id: Some("rust-analyzer".to_owned()),
-                items: diagnostics.collect(),
-            },
-            related_documents: related_documents.is_empty().not().then(|| {
+    Ok(lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
+        full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
+            result_id: Some("rust-analyzer".to_owned()),
+            items: diagnostics.collect(),
+        },
+        related_documents: related_documents.is_empty().not().then(|| {
                 related_documents
                     .into_iter()
                     .map(|(id, (items, _))| {
                     })
                     .collect()
             }),
-        }),
-    ))
+    })))
 }
 
 pub(crate) fn handle_document_symbol(
     }
 
     // Builds hierarchy from a flat list, in reverse order (so that the indices make sense)
+
     let document_symbols = {
         let mut acc = Vec::new();
         while let Some((mut symbol, parent_idx)) = symbols.pop() {
         .collect();
 
     // Drop file system edits since we're just renaming things on the same level
+
     let mut source_changes = source_changes.into_iter();
     let mut source_change = source_changes.next().unwrap_or_default();
     source_change.file_system_edits.clear();
     }
 
     // locate parent module by semantics
+
     let position = try_default!(from_proto::file_position(&snap, params)?);
     let navs = snap.analysis.parent_module(position)?;
     let res = to_proto::goto_definition_response(&snap, None, navs)?;
     }
 
     // Add `cargo check` and `cargo test` for all targets of the whole package
+
     let config = snap.config.runnables(source_root);
     match target_spec {
         Some(TargetSpec::Cargo(spec)) => {
         .map_err(to_proto::rename_error)?;
 
     // this is kind of a hack to prevent double edits from happening when moving files
+
     // When a module gets renamed by renaming the mod declaration this causes the file to move
+
     // which in turn will trigger a WillRenameFiles request to the server for which we reply with a
+
     // a second identical set of renames, the client will then apply both edits causing incorrect edits
+
     // with this we only emit source_file_edits in the WillRenameFiles response which will do the rename instead
+
     // See https://github.com/microsoft/vscode-languageserver-node/issues/752 for more info
+
     if !change.file_system_edits.is_empty() && snap.config.will_rename() {
         change.source_file_edits.clear();
     }
     }
 
     // Fixes from `cargo check`.
+
     for fix in snap
         .check_fixes
         .iter()
     );
 
     // Unconditionally cache the tokens
+
     snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens.clone());
 
     Ok(Some(semantic_tokens.into()))
     }
 
     // Clone first to keep the lock short
+
     let semantic_tokens_clone = semantic_tokens.clone();
     snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens_clone);
 
     let file = snap.analysis.file_text(file_id)?;
 
     // Determine the edition of the crate the file belongs to (if there's multiple, we pick the
+
     // highest edition).
+
     let Ok(editions) = snap
         .analysis
         .relevant_crates_for(file_id)?
     let source_root_id = snap.analysis.source_root_id(file_id).ok();
 
     // try to chdir to the file so we can respect `rustfmt.toml`
+
     // FIXME: use `rustfmt --config-path` once
+
     // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed
+
     let current_dir = match text_document.uri.to_file_path() {
         Ok(mut path) => {
             // pop off file name