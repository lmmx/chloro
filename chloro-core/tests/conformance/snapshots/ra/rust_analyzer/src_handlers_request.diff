COMPARISON DIFF
============================================================

Original size: 101181 bytes
Chloro size:   100517 bytes
Rustfmt size:  101181 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is responsible for implementing handlers for Language Server
 //! Protocol. This module specifically handles requests.
 
 use std::{fs, io::Write as _, ops::Not, process::Stdio};
 
 use anyhow::Context;
-
-use base64::{Engine, prelude::BASE64_STANDARD};
+use base64::{prelude::BASE64_STANDARD, Engine};
 use ide::{
     AssistKind, AssistResolveStrategy, Cancellable, CompletionFieldsToResolve, FilePosition,
     FileRange, FileStructureConfig, FindAllRefsConfig, HoverAction, HoverGotoTypeData,
     global_state::{FetchWorkspaceRequest, GlobalState, GlobalStateSnapshot},
     line_index::LineEndings,
     lsp::{
-        LspError, completion_item_hash,
+        completion_item_hash,
         ext::{
             InternalTestingFetchConfigOption, InternalTestingFetchConfigParams,
             InternalTestingFetchConfigResponse,
         },
-        from_proto, to_proto,
-        utils::{all_edits_are_disjoint, invalid_params_error},
+        from_proto, to_proto, utils::{all_edits_are_disjoint, invalid_params_error}, LspError,
     },
     lsp_ext::{
         self, CrateInfoResult, ExternalDocsPair, ExternalDocsResponse, FetchDependencyListParams,
         );
     }
     buf.push_str("\nAnalysis:\n");
-    buf.push_str(
+    buf
+        .push_str(
         &snap
             .analysis
             .status(file_id)
     Ok(res)
 }
 
-// cargo test requires:
-// - the package is a member of the workspace
-// - the target in the package is not a build script (custom-build)
-// - the package name - the root of the test identifier supplied to this handler can be
-//   a package or a target inside a package.
-// - the target name - if the test identifier is a target, it's needed in addition to the
-//   package name to run the right test
-// - real names - the test identifier uses the namespace form where hyphens are replaced with
-//   underscores. cargo test requires the real name.
-// - the target kind e.g. bin or lib
 fn all_test_targets(cargo: &CargoWorkspace) -> impl Iterator<Item = TestTarget> {
     cargo.packages().filter(|p| cargo[*p].is_member).flat_map(|p| {
         let package = &cargo[p];
         return Ok(None);
     }
 
-    let mut position =
-        try_default!(from_proto::file_position(&snap, params.text_document_position)?);
+    let mut position = try_default!(from_proto::file_position(&snap, params.text_document_position)?);
     let line_index = snap.file_line_index(position.file_id)?;
 
     // in `ide`, the `on_type` invariant is that
+
     // `text.char_at(position) == typed_char`.
     position.offset -= TextSize::of('.');
 
     params: lsp_types::GotoDefinitionParams,
 ) -> anyhow::Result<Option<lsp_types::GotoDefinitionResponse>> {
     let _p = tracing::info_span!("handle_goto_definition").entered();
-    let position =
-        try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
+    let position = try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     let config = snap.config.goto_definition(snap.minicore());
     let nav_info = match snap.analysis.goto_definition(position, &config)? {
         None => return Ok(None),
     params: lsp_types::request::GotoImplementationParams,
 ) -> anyhow::Result<Option<lsp_types::request::GotoImplementationResponse>> {
     let _p = tracing::info_span!("handle_goto_implementation").entered();
-    let position =
-        try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
-    let nav_info =
-        match snap.analysis.goto_implementation(&snap.config.goto_implementation(), position)? {
+    let position = try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
+    let nav_info = match snap.analysis.goto_implementation(&snap.config.goto_implementation(), position)? {
             None => return Ok(None),
             Some(it) => it,
         };
     params: lsp_types::request::GotoTypeDefinitionParams,
 ) -> anyhow::Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {
     let _p = tracing::info_span!("handle_goto_type_definition").entered();
-    let position =
-        try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
+    let position = try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     let nav_info = match snap.analysis.goto_type_definition(position)? {
         None => return Ok(None),
         Some(it) => it,
     }: lsp_types::CompletionParams,
 ) -> anyhow::Result<Option<lsp_types::CompletionResponse>> {
     let _p = tracing::info_span!("handle_completion").entered();
-    let mut position =
-        try_default!(from_proto::file_position(&snap, text_document_position.clone())?);
+    let mut position = try_default!(from_proto::file_position(&snap, text_document_position.clone())?);
     let line_index = snap.file_line_index(position.file_id)?;
-    let completion_trigger_character =
-        context.and_then(|ctx| ctx.trigger_character).and_then(|s| s.chars().next());
+    let completion_trigger_character = context.and_then(|ctx| ctx.trigger_character).and_then(|s| s.chars().next());
 
     let source_root = snap.analysis.source_root_id(position.file_id)?;
     let completion_config = &snap.config.completion(Some(source_root), snap.minicore());
     };
     let source_root = snap.analysis.source_root_id(file_id)?;
 
-    let mut forced_resolve_completions_config =
-        snap.config.completion(Some(source_root), snap.minicore());
+    let mut forced_resolve_completions_config = snap.config.completion(Some(source_root), snap.minicore());
     forced_resolve_completions_config.fields_to_resolve = CompletionFieldsToResolve::empty();
 
     let position = FilePosition { file_id, offset };
     params: lsp_types::SignatureHelpParams,
 ) -> anyhow::Result<Option<lsp_types::SignatureHelp>> {
     let _p = tracing::info_span!("handle_signature_help").entered();
-    let position =
-        try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
+    let position = try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     let help = match snap.analysis.signature_help(position)? {
         Some(it) => it,
         None => return Ok(None),
         .map_err(to_proto::rename_error)?;
 
     // this is kind of a hack to prevent double edits from happening when moving files
+
     // When a module gets renamed by renaming the mod declaration this causes the file to move
+
     // which in turn will trigger a WillRenameFiles request to the server for which we reply with a
+
     // a second identical set of renames, the client will then apply both edits causing incorrect edits
+
     // with this we only emit source_file_edits in the WillRenameFiles response which will do the rename instead
+
     // See https://github.com/microsoft/vscode-languageserver-node/issues/752 for more info
     if !change.file_system_edits.is_empty() && snap.config.will_rename() {
         change.source_file_edits.clear();
 }
 
 fn parse_action_id(action_id: &str) -> anyhow::Result<(usize, SingleResolve), String> {
-    let id_parts = action_id.split(':').collect::<Vec<_>>();
+    let id_parts = action_id.split(':').collect();
     match id_parts.as_slice() {
         [assist_id_string, assist_kind_string, index_string, subtype_str] => {
             let assist_kind: AssistKind = assist_kind_string.parse()?;
     params: lsp_types::DocumentHighlightParams,
 ) -> anyhow::Result<Option<Vec<lsp_types::DocumentHighlight>>> {
     let _p = tracing::info_span!("handle_document_highlight").entered();
-    let position =
-        try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
+    let position = try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
     let line_index = snap.file_line_index(position.file_id)?;
     let source_root = snap.analysis.source_root_id(position.file_id)?;
 
     params: CallHierarchyPrepareParams,
 ) -> anyhow::Result<Option<Vec<CallHierarchyItem>>> {
     let _p = tracing::info_span!("handle_call_hierarchy_prepare").entered();
-    let position =
-        try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
+    let position = try_default!(from_proto::file_position(&snap, params.text_document_position_params)?);
 
     let config = snap.config.call_hierarchy(snap.minicore());
     let nav_info = match snap.analysis.call_hierarchy(position, &config)? {
     let _p = tracing::info_span!("handle_open_docs").entered();
     let position = try_default!(from_proto::file_position(&snap, params)?);
 
-    let ws_and_sysroot = snap.workspaces.iter().find_map(|ws| match &ws.kind {
+    let ws_and_sysroot = snap.workspaces
+        .iter()
+        .find_map(|ws| match &ws.kind {
         ProjectWorkspaceKind::Cargo { cargo, .. }
         | ProjectWorkspaceKind::DetachedFile { cargo: Some((cargo, _, _)), .. } => {
             Some((cargo, &ws.sysroot))
     };
 
     let cargo_toml_url = to_proto::url_from_abs_path(&cargo_spec.cargo_toml);
-    let res: lsp_types::GotoDefinitionResponse =
-        Location::new(cargo_toml_url, Range::default()).into();
+    let res: lsp_types::GotoDefinitionResponse = Location::new(cargo_toml_url, Range::default()).into();
     Ok(Some(res))
 }
 
     let file = snap.analysis.file_text(file_id)?;
 
     // Determine the edition of the crate the file belongs to (if there's multiple, we pick the
+
     // highest edition).
     let Ok(editions) = snap
         .analysis
     let source_root_id = snap.analysis.source_root_id(file_id).ok();
 
     // try to chdir to the file so we can respect `rustfmt.toml`
+
     // FIXME: use `rustfmt --config-path` once
+
     // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed
     let current_dir = match text_document.uri.to_file_path() {
         Ok(mut path) => {