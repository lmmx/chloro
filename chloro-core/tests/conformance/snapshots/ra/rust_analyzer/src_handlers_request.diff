COMPARISON DIFF
============================================================

Original size: 101181 bytes
Chloro size:   100133 bytes
Rustfmt size:  101181 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is responsible for implementing handlers for Language Server
 //! Protocol. This module specifically handles requests.
 
 use std::{fs, io::Write as _, ops::Not, process::Stdio};
 
 use anyhow::Context;
-
-use base64::{Engine, prelude::BASE64_STANDARD};
+use base64::{prelude::BASE64_STANDARD, Engine};
 use ide::{
     AssistKind, AssistResolveStrategy, Cancellable, CompletionFieldsToResolve, FilePosition,
     FileRange, FileStructureConfig, FindAllRefsConfig, HoverAction, HoverGotoTypeData,
     global_state::{FetchWorkspaceRequest, GlobalState, GlobalStateSnapshot},
     line_index::LineEndings,
     lsp::{
-        LspError, completion_item_hash,
+        completion_item_hash,
         ext::{
             InternalTestingFetchConfigOption, InternalTestingFetchConfigParams,
             InternalTestingFetchConfigResponse,
         },
-        from_proto, to_proto,
-        utils::{all_edits_are_disjoint, invalid_params_error},
+        from_proto, to_proto, utils::{all_edits_are_disjoint, invalid_params_error}, LspError,
     },
     lsp_ext::{
         self, CrateInfoResult, ExternalDocsPair, ExternalDocsResponse, FetchDependencyListParams,
             when building from source, or pass `--enable-profiling` to `cargo xtask`."
         ))
     }
-    #[cfg(feature = "dhat")]
-    {
+    #[cfg(feature = "dhat")] {
         if let Some(dhat_output_file) = _state.config.dhat_output_file() {
             let mut profiler = crate::DHAT_PROFILER.lock().unwrap();
             let old_profiler = profiler.take();
-            // Need to drop the old profiler before creating a new one.
             drop(old_profiler);
             *profiler = Some(dhat::Profiler::builder().file_name(&dhat_output_file).build());
             Ok(format!(
     Ok(res)
 }
 
-// cargo test requires:
-// - the package is a member of the workspace
-// - the target in the package is not a build script (custom-build)
-// - the package name - the root of the test identifier supplied to this handler can be
-//   a package or a target inside a package.
-// - the target name - if the test identifier is a target, it's needed in addition to the
-//   package name to run the right test
-// - real names - the test identifier uses the namespace form where hyphens are replaced with
-//   underscores. cargo test requires the real name.
-// - the target kind e.g. bin or lib
 fn all_test_targets(cargo: &CargoWorkspace) -> impl Iterator<Item = TestTarget> {
     cargo.packages().filter(|p| cargo[*p].is_member).flat_map(|p| {
         let package = &cargo[p];
     let line_index = snap.file_line_index(position.file_id)?;
 
     // in `ide`, the `on_type` invariant is that
+
     // `text.char_at(position) == typed_char`.
     position.offset -= TextSize::of('.');
 
 }
 
 pub(crate) fn empty_diagnostic_report() -> lsp_types::DocumentDiagnosticReportResult {
-    lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(
-        lsp_types::RelatedFullDocumentDiagnosticReport {
-            related_documents: None,
-            full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
-                result_id: Some("rust-analyzer".to_owned()),
-                items: vec![],
-            },
+    lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
+        related_documents: None,
+        full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
+            result_id: Some("rust-analyzer".to_owned()),
+            items: vec![],
         },
-    ))
+    }))
 }
 
 pub(crate) fn handle_document_diagnostics(
             }
             None
         });
-    Ok(lsp_types::DocumentDiagnosticReportResult::Report(
-        lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
-            full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
-                result_id: Some("rust-analyzer".to_owned()),
-                items: diagnostics.collect(),
-            },
-            related_documents: related_documents.is_empty().not().then(|| {
+    Ok(lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
+        full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
+            result_id: Some("rust-analyzer".to_owned()),
+            items: diagnostics.collect(),
+        },
+        related_documents: related_documents.is_empty().not().then(|| {
                 related_documents
                     .into_iter()
                     .map(|(id, (items, _))| {
                     })
                     .collect()
             }),
-        }),
-    ))
+    })))
 }
 
 pub(crate) fn handle_document_symbol(
         .map_err(to_proto::rename_error)?;
 
     // this is kind of a hack to prevent double edits from happening when moving files
+
     // When a module gets renamed by renaming the mod declaration this causes the file to move
+
     // which in turn will trigger a WillRenameFiles request to the server for which we reply with a
+
     // a second identical set of renames, the client will then apply both edits causing incorrect edits
+
     // with this we only emit source_file_edits in the WillRenameFiles response which will do the rename instead
+
     // See https://github.com/microsoft/vscode-languageserver-node/issues/752 for more info
     if !change.file_system_edits.is_empty() && snap.config.will_rename() {
         change.source_file_edits.clear();
 fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&TargetSpec>) -> bool {
     match runnable.kind {
         RunnableKind::Bin => {
-            // Do not suggest binary run on other target than binary
             match &cargo_spec {
                 Some(spec) => !matches!(
                     spec.target_kind(),
     let file = snap.analysis.file_text(file_id)?;
 
     // Determine the edition of the crate the file belongs to (if there's multiple, we pick the
+
     // highest edition).
     let Ok(editions) = snap
         .analysis
     let source_root_id = snap.analysis.source_root_id(file_id).ok();
 
     // try to chdir to the file so we can respect `rustfmt.toml`
+
     // FIXME: use `rustfmt --config-path` once
+
     // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed
     let current_dir = match text_document.uri.to_file_path() {
         Ok(mut path) => {
     let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);
 
     if line_index.endings != new_line_endings {
-        // If line endings are different, send the entire file.
-        // Diffing would not work here, as the line endings might be the only
-        // difference.
         Ok(Some(to_proto::text_edit_vec(
             &line_index,
             TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),
         )))
     } else if *file == new_text {
-        // The document is already formatted correctly -- no edits needed.
         Ok(None)
     } else {
         Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))