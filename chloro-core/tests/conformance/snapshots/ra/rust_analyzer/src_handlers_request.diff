COMPARISON DIFF
============================================================

Original size: 101181 bytes
Chloro size:   99682 bytes
Rustfmt size:  101181 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! This module is responsible for implementing handlers for Language Server
 //! Protocol. This module specifically handles requests.
 
 use std::{fs, io::Write as _, ops::Not, process::Stdio};
 
 use anyhow::Context;
-
-use base64::{Engine, prelude::BASE64_STANDARD};
+use base64::{prelude::BASE64_STANDARD, Engine};
 use ide::{
     AssistKind, AssistResolveStrategy, Cancellable, CompletionFieldsToResolve, FilePosition,
     FileRange, FileStructureConfig, FindAllRefsConfig, HoverAction, HoverGotoTypeData,
     global_state::{FetchWorkspaceRequest, GlobalState, GlobalStateSnapshot},
     line_index::LineEndings,
     lsp::{
-        LspError, completion_item_hash,
+        completion_item_hash,
         ext::{
             InternalTestingFetchConfigOption, InternalTestingFetchConfigParams,
             InternalTestingFetchConfigResponse,
         },
-        from_proto, to_proto,
-        utils::{all_edits_are_disjoint, invalid_params_error},
+        from_proto, to_proto, utils::{all_edits_are_disjoint, invalid_params_error}, LspError,
     },
     lsp_ext::{
         self, CrateInfoResult, ExternalDocsPair, ExternalDocsResponse, FetchDependencyListParams,
             when building from source, or pass `--enable-profiling` to `cargo xtask`."
         ))
     }
-    #[cfg(feature = "dhat")]
-    {
+    #[cfg(feature = "dhat")] {
         if let Some(dhat_output_file) = _state.config.dhat_output_file() {
             let mut profiler = crate::DHAT_PROFILER.lock().unwrap();
             let old_profiler = profiler.take();
-            // Need to drop the old profiler before creating a new one.
             drop(old_profiler);
             *profiler = Some(dhat::Profiler::builder().file_name(&dhat_output_file).build());
             Ok(format!(
     Ok(res)
 }
 
-// cargo test requires:
-// - the package is a member of the workspace
-// - the target in the package is not a build script (custom-build)
-// - the package name - the root of the test identifier supplied to this handler can be
-//   a package or a target inside a package.
-// - the target name - if the test identifier is a target, it's needed in addition to the
-//   package name to run the right test
-// - real names - the test identifier uses the namespace form where hyphens are replaced with
-//   underscores. cargo test requires the real name.
-// - the target kind e.g. bin or lib
 fn all_test_targets(cargo: &CargoWorkspace) -> impl Iterator<Item = TestTarget> {
     cargo.packages().filter(|p| cargo[*p].is_member).flat_map(|p| {
         let package = &cargo[p];
     let offset = from_proto::offset(&line_index, params.position)?;
 
     let res = snap.analysis.expand_macro(FilePosition { file_id, offset })?;
-    Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))
+    Ok(res.map(|it| lsp_ext::ExpandedMacro {
+        name: it.name,
+        expansion: it.expansion,
+    }))
 }
 
 pub(crate) fn handle_selection_range(
     let _p = tracing::info_span!("handle_matching_brace").entered();
     let file_id = try_default!(from_proto::file_id(&snap, &params.text_document.uri)?);
     let line_index = snap.file_line_index(file_id)?;
-    params
-        .positions
-        .into_iter()
-        .map(|position| {
-            let offset = from_proto::offset(&line_index, position);
-            offset.map(|offset| {
-                let offset = match snap.analysis.matching_brace(FilePosition { file_id, offset }) {
+    params.positions.into_iter().map(|position| {
+        let offset = from_proto::offset(&line_index, position);
+        offset.map(|offset| {
+            let offset = match snap.analysis.matching_brace(FilePosition { file_id, offset }) {
                     Ok(Some(matching_brace_offset)) => matching_brace_offset,
                     Err(_) | Ok(None) => offset,
                 };
-                to_proto::position(&line_index, offset)
-            })
+            to_proto::position(&line_index, offset)
         })
-        .collect()
+    }).collect(
+    )
 }
 
 pub(crate) fn handle_join_lines(
     let line_index = snap.file_line_index(position.file_id)?;
 
     // in `ide`, the `on_type` invariant is that
+
     // `text.char_at(position) == typed_char`.
     position.offset -= TextSize::of('.');
 
 }
 
 pub(crate) fn empty_diagnostic_report() -> lsp_types::DocumentDiagnosticReportResult {
-    lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(
-        lsp_types::RelatedFullDocumentDiagnosticReport {
-            related_documents: None,
-            full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
-                result_id: Some("rust-analyzer".to_owned()),
-                items: vec![],
-            },
+    lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
+        related_documents: None,
+        full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
+            result_id: Some("rust-analyzer".to_owned()),
+            items: vec![],
         },
-    ))
+    }))
 }
 
 pub(crate) fn handle_document_diagnostics(
             }
             None
         });
-    Ok(lsp_types::DocumentDiagnosticReportResult::Report(
-        lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
-            full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
-                result_id: Some("rust-analyzer".to_owned()),
-                items: diagnostics.collect(),
-            },
-            related_documents: related_documents.is_empty().not().then(|| {
-                related_documents
-                    .into_iter()
-                    .map(|(id, (items, _))| {
-                        (
+    Ok(lsp_types::DocumentDiagnosticReportResult::Report(lsp_types::DocumentDiagnosticReport::Full(lsp_types::RelatedFullDocumentDiagnosticReport {
+        full_document_diagnostic_report: lsp_types::FullDocumentDiagnosticReport {
+            result_id: Some("rust-analyzer".to_owned()),
+            items: diagnostics.collect(),
+        },
+        related_documents: related_documents.is_empty().not().then(|| {
+            related_documents.into_iter().map(|(id, (items, _))| {
+                (
                             to_proto::url(&snap, id),
                             lsp_types::DocumentDiagnosticReportKind::Full(
                                 lsp_types::FullDocumentDiagnosticReport {
                                 },
                             ),
                         )
-                    })
-                    .collect()
-            }),
+            }).collect(
+            )
         }),
-    ))
+    })))
 }
 
 pub(crate) fn handle_document_symbol(
         .map_err(to_proto::rename_error)?;
 
     // this is kind of a hack to prevent double edits from happening when moving files
+
     // When a module gets renamed by renaming the mod declaration this causes the file to move
+
     // which in turn will trigger a WillRenameFiles request to the server for which we reply with a
+
     // a second identical set of renames, the client will then apply both edits causing incorrect edits
+
     // with this we only emit source_file_edits in the WillRenameFiles response which will do the rename instead
+
     // See https://github.com/microsoft/vscode-languageserver-node/issues/752 for more info
     if !change.file_system_edits.is_empty() && snap.config.will_rename() {
         change.source_file_edits.clear();
                     assist_subtype,
                 },
             ))
-        }
+        },
         _ => Err("Action id contains incorrect number of segments".to_owned()),
     }
 }
     );
 
     let inlay_hints_config = snap.config.inlay_hints(snap.minicore());
-    Ok(Some(
-        snap.analysis
-            .inlay_hints(&inlay_hints_config, file_id, Some(range))?
-            .into_iter()
-            .map(|it| {
-                to_proto::inlay_hint(
-                    &snap,
-                    &inlay_hints_config.fields_to_resolve,
-                    &line_index,
-                    file_id,
-                    it,
-                )
-            })
-            .collect::<Cancellable<Vec<_>>>()?,
-    ))
+    Ok(Some(snap.analysis.inlay_hints(&inlay_hints_config, file_id, Some(range))?.into_iter().map(|it| {
+        to_proto::inlay_hint(&snap, &inlay_hints_config.fields_to_resolve, &line_index, file_id, it)
+    }).collect::<Cancellable<Vec<_>>>(
+    )?))
 }
 
 pub(crate) fn handle_inlay_hints_resolve(
         },
     )?;
 
-    Ok(resolve_hints
-        .and_then(|it| {
-            to_proto::inlay_hint(
-                &snap,
-                &forced_resolve_inlay_hints_config.fields_to_resolve,
-                &line_index,
-                file_id,
-                it,
-            )
-            .ok()
-        })
-        .filter(|hint| hint.position == original_hint.position)
-        .filter(|hint| hint.kind == original_hint.kind)
-        .unwrap_or(original_hint))
+    Ok(resolve_hints.and_then(|it| {
+        to_proto::inlay_hint(
+            &snap,
+            &forced_resolve_inlay_hints_config.fields_to_resolve,
+            &line_index,
+            file_id,
+            it,
+        ).ok(
+        )
+    }).filter(
+        |hint| hint.position == original_hint.position,
+    ).filter(
+        |hint| hint.kind == original_hint.kind,
+    ).unwrap_or(
+        original_hint,
+    ))
 }
 
 pub(crate) fn handle_call_hierarchy_prepare(
                 text_edit,
                 snap.config.change_annotation_support(),
             ))
-        }
+        },
         None => Ok(vec![]),
     }
 }
 
     Some(lsp_ext::CommandLinkGroup {
         title: Some("Go to ".into()),
-        commands: nav_targets
-            .iter()
-            .filter_map(|it| {
-                to_proto::command::goto_location(snap, &it.nav)
-                    .map(|cmd| to_command_link(cmd, it.mod_path.clone()))
-            })
-            .collect(),
+        commands: nav_targets.iter().filter_map(|it| {
+            to_proto::command::goto_location(snap, &it.nav).map(
+                |cmd| to_command_link(cmd, it.mod_path.clone()),
+            )
+        }).collect(
+        ),
     })
 }
 
 ) -> Vec<lsp_ext::CommandLinkGroup> {
     let hover_actions = snap.config.hover_actions();
     let client_commands = snap.config.client_commands();
-    actions
-        .iter()
-        .filter_map(|it| match it {
-            HoverAction::Implementation(position) => show_impl_command_link(
-                snap,
-                position,
-                hover_actions.implementations,
-                client_commands.show_reference,
-            ),
-            HoverAction::Reference(position) => show_ref_command_link(
-                snap,
-                position,
-                hover_actions.references,
-                client_commands.show_reference,
-            ),
-            HoverAction::Runnable(r) => {
-                runnable_action_links(snap, r.clone(), &hover_actions, &client_commands)
-            }
-            HoverAction::GoToType(targets) => {
-                goto_type_action_links(snap, targets, &hover_actions, &client_commands)
-            }
-        })
-        .collect()
+    actions.iter().filter_map(|it| match it {
+        HoverAction::Implementation(position) => show_impl_command_link(
+            snap,
+            position,
+            hover_actions.implementations,
+            client_commands.show_reference,
+        ),
+        HoverAction::Reference(position) => show_ref_command_link(
+            snap,
+            position,
+            hover_actions.references,
+            client_commands.show_reference,
+        ),
+        HoverAction::Runnable(r) => {
+            runnable_action_links(snap, r.clone(), &hover_actions, &client_commands)
+        },
+        HoverAction::GoToType(targets) => {
+            goto_type_action_links(snap, targets, &hover_actions, &client_commands)
+        },
+    }).collect(
+    )
 }
 
 fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&TargetSpec>) -> bool {
     match runnable.kind {
         RunnableKind::Bin => {
-            // Do not suggest binary run on other target than binary
             match &cargo_spec {
                 Some(spec) => !matches!(
                     spec.target_kind(),
                 ),
                 None => true,
             }
-        }
+        },
         _ => false,
     }
 }
     let file = snap.analysis.file_text(file_id)?;
 
     // Determine the edition of the crate the file belongs to (if there's multiple, we pick the
+
     // highest edition).
     let Ok(editions) = snap
         .analysis
     let source_root_id = snap.analysis.source_root_id(file_id).ok();
 
     // try to chdir to the file so we can respect `rustfmt.toml`
+
     // FIXME: use `rustfmt --config-path` once
+
     // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed
     let current_dir = match text_document.uri.to_file_path() {
         Ok(mut path) => {
     let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);
 
     if line_index.endings != new_line_endings {
-        // If line endings are different, send the entire file.
-        // Diffing would not work here, as the line endings might be the only
-        // difference.
         Ok(Some(to_proto::text_edit_vec(
             &line_index,
             TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),
         )))
     } else if *file == new_text {
-        // The document is already formatted correctly -- no edits needed.
         Ok(None)
     } else {
         Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))
             InternalTestingFetchConfigResponse::AssistEmitMustUse(
                 state.config.assist(source_root).assist_emit_must_use,
             )
-        }
+        },
         InternalTestingFetchConfigOption::CheckWorkspace => {
             InternalTestingFetchConfigResponse::CheckWorkspace(
                 state.config.flycheck_workspace(source_root),
             )
-        }
+        },
     }))
 }
 