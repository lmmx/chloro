COMPARISON DIFF
============================================================

Original size: 6105 bytes
Chloro size:   6116 bytes
Rustfmt size:  6316 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Reports references in code that the IDE layer cannot resolve.
+
 use hir::{db::HirDatabase, sym, AnyDiagnostic, Crate, Module, Semantics};
 use ide::{AnalysisHost, RootDatabase, TextRange};
 use ide_db::{
-    base_db::SourceDatabase, defs::NameRefClass, EditionedFileId, FxHashSet, LineIndexDatabase as _,
+    base_db::SourceDatabase, defs::NameRefClass, EditionedFileId, FxHashSet,
+    LineIndexDatabase as _,
 };
 use load_cargo::{load_workspace_at, LoadCargoConfig, ProcMacroServerChoice};
 use parser::SyntaxKind;
             stdx::thread::ThreadIntent::LatencySensitive,
             "BIG_STACK_THREAD",
         )
-        .stack_size(STACK_SIZE)
-        .spawn(|| self.run_())
-        .unwrap();
+            .stack_size(STACK_SIZE)
+            .spawn(|| self.run_())
+            .unwrap();
 
         handle.join()
     }
 
     fn run_(self) -> anyhow::Result<()> {
-        let root =
-            vfs::AbsPathBuf::assert_utf8(std::env::current_dir()?.join(&self.path)).normalize();
+        let root = vfs::AbsPathBuf::assert_utf8(std::env::current_dir()?.join(&self.path)).normalize();
         let config = crate::config::Config::new(
             root,
             lsp_types::ClientCapabilities::default(),
             with_proc_macro_server,
             prefill_caches: false,
         };
-        let (db, vfs, _proc_macro) =
-            load_workspace_at(&self.path, &cargo_config, &load_cargo_config, &|_| {})?;
+        let (db, vfs, _proc_macro) = load_workspace_at(&self.path, &cargo_config, &load_cargo_config, &|_| {})?;
         let host = AnalysisHost::with_database(db);
         let db = host.raw_database();
         let sema = Semantics::new(db);
 
         let mut visited_files = FxHashSet::default();
 
-        let work = all_modules(db).into_iter().filter(|module| {
+        let work = all_modules(db)
+            .into_iter()
+            .filter(|module| {
             let file_id = module.definition_source_file_id(db).original_file(db);
             let source_root = db.file_source_root(file_id.file_id(db)).source_root_id(db);
             let source_root = db.source_root(source_root).source_root(db);
             let file_id = module.definition_source_file_id(db).original_file(db);
             let file_id = file_id.file_id(db);
             if !visited_files.contains(&file_id) {
-                let crate_name = module
-                    .krate()
-                    .display_name(db)
-                    .as_deref()
-                    .unwrap_or(&sym::unknown)
-                    .to_owned();
+                let crate_name =
+                    module.krate().display_name(db).as_deref().unwrap_or(&sym::unknown).to_owned();
                 let file_path = vfs.file_path(file_id);
                 eprintln!("processing crate: {crate_name}, module: {file_path}",);
 
 }
 
 fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {
-    let mut worklist: Vec<_> = Crate::all(db)
-        .into_iter()
-        .map(|krate| krate.root_module())
-        .collect();
+    let mut worklist: Vec<_> = Crate::all(db).into_iter().map(|krate| krate.root_module()).collect();
     let mut modules = Vec::new();
 
     while let Some(module) = worklist.pop() {
         };
 
         let node = inactive_code.node;
-        let range = node
-            .map(|it| it.text_range())
-            .original_node_file_range_rooted(db);
+        let range = node.map(|it| it.text_range()).original_node_file_range_rooted(db);
 
         if range.file_id.file_id(db) != file_id {
             continue;
             continue;
         };
         let Some(descended_name_ref) = name_ref.syntax().first_token().and_then(|tok| {
-            sema.descend_into_macros_single_exact(tok)
-                .parent()
-                .and_then(ast::NameRef::cast)
+            sema.descend_into_macros_single_exact(tok).parent().and_then(ast::NameRef::cast)
         }) else {
             continue;
         };
         }
 
         // if we couldn't classify it, but it's in an attr, ignore it. See #10935
-        if descended_name_ref
-            .syntax()
-            .ancestors()
-            .any(|it| it.kind() == SyntaxKind::ATTR)
-        {
+        if descended_name_ref.syntax().ancestors().any(|it| it.kind() == SyntaxKind::ATTR) {
             continue;
         }
 