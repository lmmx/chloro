COMPARISON DIFF
============================================================

Original size: 6105 bytes
Chloro size:   6110 bytes
Rustfmt size:  6316 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Reports references in code that the IDE layer cannot resolve.
-use hir::{db::HirDatabase, sym, AnyDiagnostic, Crate, Module, Semantics};
-use ide::{AnalysisHost, RootDatabase, TextRange};
+
+use hir::{AnyDiagnostic, Crate, Module, Semantics, db::HirDatabase, sym};
 use ide_db::{
-    base_db::SourceDatabase, defs::NameRefClass, EditionedFileId, FxHashSet, LineIndexDatabase as _,
+    EditionedFileId, FxHashSet, LineIndexDatabase as _, base_db::SourceDatabase,
+    defs::NameRefClass,
 };
-use load_cargo::{load_workspace_at, LoadCargoConfig, ProcMacroServerChoice};
+use ide::{AnalysisHost, RootDatabase, TextRange};
+use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
 use parser::SyntaxKind;
-use syntax::{ast, AstNode, WalkEvent};
+use syntax::{AstNode, WalkEvent, ast};
 use vfs::FileId;
 
 use crate::cli::flags;
             let file_id = module.definition_source_file_id(db).original_file(db);
             let file_id = file_id.file_id(db);
             if !visited_files.contains(&file_id) {
-                let crate_name = module
-                    .krate()
-                    .display_name(db)
-                    .as_deref()
-                    .unwrap_or(&sym::unknown)
-                    .to_owned();
+                let crate_name =
+                    module.krate().display_name(db).as_deref().unwrap_or(&sym::unknown).to_owned();
                 let file_path = vfs.file_path(file_id);
                 eprintln!("processing crate: {crate_name}, module: {file_path}",);
 
 }
 
 fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {
-    let mut worklist: Vec<_> = Crate::all(db)
-        .into_iter()
-        .map(|krate| krate.root_module())
-        .collect();
+    let mut worklist: Vec<_> =
+        Crate::all(db).into_iter().map(|krate| krate.root_module()).collect();
     let mut modules = Vec::new();
 
     while let Some(module) = worklist.pop() {
         };
 
         let node = inactive_code.node;
-        let range = node
-            .map(|it| it.text_range())
-            .original_node_file_range_rooted(db);
+        let range = node.map(|it| it.text_range()).original_node_file_range_rooted(db);
 
         if range.file_id.file_id(db) != file_id {
             continue;
             continue;
         };
         let Some(descended_name_ref) = name_ref.syntax().first_token().and_then(|tok| {
-            sema.descend_into_macros_single_exact(tok)
-                .parent()
-                .and_then(ast::NameRef::cast)
+            sema.descend_into_macros_single_exact(tok).parent().and_then(ast::NameRef::cast)
         }) else {
             continue;
         };
         }
 
         // if we couldn't classify it, but it's in an attr, ignore it. See #10935
-        if descended_name_ref
-            .syntax()
-            .ancestors()
-            .any(|it| it.kind() == SyntaxKind::ATTR)
-        {
+        if descended_name_ref.syntax().ancestors().any(|it| it.kind() == SyntaxKind::ATTR) {
             continue;
         }
 