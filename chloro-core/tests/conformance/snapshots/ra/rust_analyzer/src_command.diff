COMPARISON DIFF
============================================================

Original size: 6953 bytes
Chloro size:   6895 bytes
Rustfmt size:  7231 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 /// Cargo output is structured as one JSON per line. This trait abstracts parsing one line of
 /// cargo output into a Rust data type
-pub(crate) trait CargoParser<T>: Send + 'static {
+pub(crate) trait CargoParser<T> {
     fn from_line(&self, line: &str, error: &mut String) -> Option<T>;
+
     fn from_eof(&self) -> Option<T>;
 }
 
         stderr: ChildStderr,
     ) -> Self {
         let parser = Box::new(parser);
-        CargoActor {
-            parser,
-            sender,
-            stdout,
-            stderr,
-        }
+        CargoActor { parser, sender, stdout, stderr }
     }
 }
 
         // Because cargo only outputs one JSON object per line, we can
         // simply skip a line if it doesn't parse, which just ignores any
         // erroneous output.
-
-        let mut stdout = outfile.as_ref().and_then(|path| {
+        let mut stdout = outfile
+            .as_ref()
+            .and_then(|path| {
             _ = std::fs::create_dir_all(path);
-            Some(BufWriter::new(
-                std::fs::File::create(path.join("stdout")).ok()?,
-            ))
+            Some(BufWriter::new(std::fs::File::create(path.join("stdout")).ok()?))
         });
-        let mut stderr = outfile.as_ref().and_then(|path| {
+        let mut stderr = outfile
+            .as_ref()
+            .and_then(|path| {
             _ = std::fs::create_dir_all(path);
-            Some(BufWriter::new(
-                std::fs::File::create(path.join("stderr")).ok()?,
-            ))
+            Some(BufWriter::new(std::fs::File::create(path.join("stderr")).ok()?))
         });
 
         let mut stdout_errors = String::new();
             },
         );
 
-        let read_at_least_one_message =
-            read_at_least_one_stdout_message || read_at_least_one_stderr_message;
+        let read_at_least_one_message = read_at_least_one_stdout_message || read_at_least_one_stderr_message;
         let mut error = stdout_errors;
         error.push_str(&stderr_errors);
         match output {
         sender: Sender<T>,
         out_file: Option<Utf8PathBuf>,
     ) -> std::io::Result<Self> {
-        command
-            .stdout(Stdio::piped())
-            .stderr(Stdio::piped())
-            .stdin(Stdio::null());
+        command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());
 
         let program = command.get_program().into();
-        let arguments = command
-            .get_args()
-            .map(|arg| arg.into())
-            .collect::<Vec<OsString>>();
+        let arguments = command.get_args().map(|arg| arg.into()).collect();
         let current_dir = command.get_current_dir().map(|arg| arg.to_path_buf());
 
         let mut child = StdCommandWrap::from(command);
-        #[cfg(unix)]
         child.wrap(process_wrap::std::ProcessSession);
-        #[cfg(windows)]
         child.wrap(process_wrap::std::JobObject);
         let mut child = child.spawn().map(JodGroupChild)?;
 
         let stderr = child.0.stderr().take().unwrap();
 
         let actor = CargoActor::<T>::new(parser, sender, stdout, stderr);
-        let thread =
-            stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker, "CommandHandle")
-                .spawn(move || actor.run(out_file))
-                .expect("failed to spawn thread");
-        Ok(CommandHandle {
-            program,
-            arguments,
-            current_dir,
-            child,
-            thread,
-            _phantom: PhantomData,
-        })
+        let thread = stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker, "CommandHandle")
+            .spawn(move || actor.run(out_file))
+            .expect("failed to spawn thread");
+        Ok(CommandHandle { program, arguments, current_dir, child, thread, _phantom: PhantomData })
     }
 
     pub(crate) fn cancel(mut self) {