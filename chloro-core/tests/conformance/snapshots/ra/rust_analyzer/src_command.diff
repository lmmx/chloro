COMPARISON DIFF
============================================================

Original size: 6953 bytes
Chloro size:   7008 bytes
Rustfmt size:  7231 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 /// Cargo output is structured as one JSON per line. This trait abstracts parsing one line of
 /// cargo output into a Rust data type
-pub(crate) trait CargoParser<T>: Send + 'static {
-    fn from_line(&self, line: &str, error: &mut String) -> Option<T>;
+pub(crate) trait CargoParser<T> {
+    fn from_line(
+        &self,
+        line: &str,
+        error: &mut String,
+    ) -> Option<T>;
+
     fn from_eof(&self) -> Option<T>;
 }
 
         stderr: ChildStderr,
     ) -> Self {
         let parser = Box::new(parser);
-        CargoActor {
-            parser,
-            sender,
-            stdout,
-            stderr,
-        }
+        CargoActor { parser, sender, stdout, stderr }
     }
 }
 
 impl<T: Sized + Send + 'static> CargoActor<T> {
-    fn run(self, outfile: Option<Utf8PathBuf>) -> io::Result<(bool, String)> {
+    fn run(
+        self,
+        outfile: Option<Utf8PathBuf>,
+    ) -> io::Result<(bool, String)> {
         // We manually read a line at a time, instead of using serde's
         // stream deserializers, because the deserializer cannot recover
         // from an error, resulting in it getting stuck, because we try to
         // Because cargo only outputs one JSON object per line, we can
         // simply skip a line if it doesn't parse, which just ignores any
         // erroneous output.
-
         let mut stdout = outfile.as_ref().and_then(|path| {
             _ = std::fs::create_dir_all(path);
-            Some(BufWriter::new(
-                std::fs::File::create(path.join("stdout")).ok()?,
-            ))
+            Some(BufWriter::new(std::fs::File::create(path.join("stdout")).ok()?))
         });
         let mut stderr = outfile.as_ref().and_then(|path| {
             _ = std::fs::create_dir_all(path);
-            Some(BufWriter::new(
-                std::fs::File::create(path.join("stderr")).ok()?,
-            ))
+            Some(BufWriter::new(std::fs::File::create(path.join("stderr")).ok()?))
         });
-
         let mut stdout_errors = String::new();
         let mut stderr_errors = String::new();
         let mut read_at_least_one_stdout_message = false;
                 }
             },
         );
-
         let read_at_least_one_message =
             read_at_least_one_stdout_message || read_at_least_one_stderr_message;
         let mut error = stdout_errors;
 }
 
 impl<T> fmt::Debug for CommandHandle<T> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("CommandHandle")
             .field("program", &self.program)
             .field("arguments", &self.arguments)
         sender: Sender<T>,
         out_file: Option<Utf8PathBuf>,
     ) -> std::io::Result<Self> {
-        command
-            .stdout(Stdio::piped())
-            .stderr(Stdio::piped())
-            .stdin(Stdio::null());
-
+        command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());
         let program = command.get_program().into();
-        let arguments = command
-            .get_args()
-            .map(|arg| arg.into())
-            .collect::<Vec<OsString>>();
+        let arguments = command.get_args().map(|arg| arg.into()).collect::<Vec<OsString>>();
         let current_dir = command.get_current_dir().map(|arg| arg.to_path_buf());
-
         let mut child = StdCommandWrap::from(command);
         #[cfg(unix)]
         child.wrap(process_wrap::std::ProcessSession);
         #[cfg(windows)]
         child.wrap(process_wrap::std::JobObject);
         let mut child = child.spawn().map(JodGroupChild)?;
-
         let stdout = child.0.stdout().take().unwrap();
         let stderr = child.0.stderr().take().unwrap();
-
         let actor = CargoActor::<T>::new(parser, sender, stdout, stderr);
         let thread =
             stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker, "CommandHandle")
                 .spawn(move || actor.run(out_file))
                 .expect("failed to spawn thread");
-        Ok(CommandHandle {
-            program,
-            arguments,
-            current_dir,
-            child,
-            thread,
-            _phantom: PhantomData,
-        })
+        Ok(CommandHandle { program, arguments, current_dir, child, thread, _phantom: PhantomData })
     }
 
     pub(crate) fn cancel(mut self) {