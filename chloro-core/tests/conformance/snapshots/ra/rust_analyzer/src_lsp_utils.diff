COMPARISON DIFF
============================================================

Original size: 17448 bytes
Chloro size:   17429 bytes
Rustfmt size:  17677 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Utilities for LSP-related boilerplate code.
+
 use std::{mem, ops::Range};
 
 use lsp_server::Notification;
 use crate::{
     global_state::GlobalState,
     line_index::{LineEndings, LineIndex, PositionEncoding},
-    lsp::{from_proto, LspError},
+    lsp::{LspError, from_proto},
     lsp_ext,
 };
 
 pub(crate) fn invalid_params_error(message: String) -> LspError {
-    LspError {
-        code: lsp_server::ErrorCode::InvalidParams as i32,
-        message,
-    }
+    LspError { code: lsp_server::ErrorCode::InvalidParams as i32, message }
 }
 
 pub(crate) fn notification_is<N: lsp_types::notification::Notification>(
             None => {
                 tracing::error!("{message}");
                 self.send_notification::<lsp_types::notification::ShowMessage>(
-                    lsp_types::ShowMessageParams {
-                        typ: lsp_types::MessageType::ERROR,
-                        message,
-                    },
+                    lsp_types::ShowMessageParams { typ: lsp_types::MessageType::ERROR, message },
                 );
             }
         }
         let work_done_progress = match state {
             Progress::Begin => {
                 self.send_request::<lsp_types::request::WorkDoneProgressCreate>(
-                    lsp_types::WorkDoneProgressCreateParams {
-                        token: token.clone(),
-                    },
+                    lsp_types::WorkDoneProgressCreateParams { token: token.clone() },
                     |_, _| (),
                 );
 
 ) -> String {
     // If at least one of the changes is a full document change, use the last
     // of them as the starting point and ignore all previous changes.
-    let (mut text, content_changes) = match content_changes
-        .iter()
-        .rposition(|change| change.range.is_none())
-    {
-        Some(idx) => {
-            let text = mem::take(&mut content_changes[idx].text);
-            (text, &content_changes[idx + 1..])
-        }
-        None => (file_contents.to_owned(), &content_changes[..]),
-    };
+    let (mut text, content_changes) =
+        match content_changes.iter().rposition(|change| change.range.is_none()) {
+            Some(idx) => {
+                let text = mem::take(&mut content_changes[idx].text);
+                (text, &content_changes[idx + 1..])
+            }
+            None => (file_contents.to_owned(), &content_changes[..]),
+        };
     if content_changes.is_empty() {
         return text;
     }
-
     let mut line_index = LineIndex {
         // the index will be overwritten in the bottom loop's first iteration
         index: Arc::new(ide::LineIndex::new(&text)),
         endings: LineEndings::Unix,
         encoding,
     };
-
     // The changes we got must be applied sequentially, but can cross lines so we
     // have to keep our line index updated.
     // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we
         CompletionItem, CompletionTextEdit, InsertReplaceEdit, Position, Range,
         TextDocumentContentChangeEvent,
     };
-
     use super::*;
-
     #[test]
     fn test_apply_document_changes() {
         macro_rules! c {
                 }),+]
             };
         }
-
         let encoding = PositionEncoding::Wide(WideEncoding::Utf16);
         let text = apply_document_changes(encoding, "", vec![]);
         assert_eq!(text, "");
         assert_eq!(text, "the");
         let text = apply_document_changes(encoding, &text, c![0, 3; 0, 3 => " quick"]);
         assert_eq!(text, "the quick");
-        let text = apply_document_changes(
-            encoding,
-            &text,
-            c![0, 0; 0, 4 => "", 0, 5; 0, 5 => " foxes"],
-        );
+        let text =
+            apply_document_changes(encoding, &text, c![0, 0; 0, 4 => "", 0, 5; 0, 5 => " foxes"]);
         assert_eq!(text, "quick foxes");
         let text = apply_document_changes(encoding, &text, c![0, 11; 0, 11 => "\ndream"]);
         assert_eq!(text, "quick foxes\ndream");
             c![0, 0; 0, 0 => "the ", 1, 4; 1, 4 => " quiet", 1, 16; 1, 16 => "s\n"],
         );
         assert_eq!(text, "the quick foxes\nhave quiet dreams\n");
-        let text = apply_document_changes(
-            encoding,
-            &text,
-            c![0, 15; 0, 15 => "\n", 2, 17; 2, 17 => "\n"],
-        );
+        let text =
+            apply_document_changes(encoding, &text, c![0, 15; 0, 15 => "\n", 2, 17; 2, 17 => "\n"]);
         assert_eq!(text, "the quick foxes\n\nhave quiet dreams\n\n");
         let text = apply_document_changes(
             encoding,
             &text,
             c![1, 0; 1, 0 => "DREAM", 2, 0; 2, 0 => "they ", 3, 0; 3, 0 => "DON'T THEY?"],
         );
-        assert_eq!(
-            text,
-            "the quick foxes\nDREAM\nthey have quiet dreams\nDON'T THEY?\n"
-        );
+        assert_eq!(text, "the quick foxes\nDREAM\nthey have quiet dreams\nDON'T THEY?\n");
         let text =
             apply_document_changes(encoding, &text, c![0, 10; 1, 5 => "", 2, 0; 2, 12 => ""]);
         assert_eq!(text, "the quick \nthey have quiet dreams\n");
-
         let text = String::from("❤️");
         let text = apply_document_changes(encoding, &text, c![0, 0; 0, 0 => "a"]);
         assert_eq!(text, "a❤️");
-
         let text = String::from("a\nb");
         let text =
             apply_document_changes(encoding, &text, c![0, 1; 1, 0 => "\nțc", 0, 1; 1, 1 => "d"]);
         assert_eq!(text, "adcb");
-
         let text = String::from("a\nb");
         let text =
             apply_document_changes(encoding, &text, c![0, 1; 1, 0 => "ț\nc", 0, 2; 0, 2 => "c"]);
         assert_eq!(text, "ațc\ncb");
     }
-
     #[test]
     fn empty_completion_disjoint_tests() {
         let empty_completion = CompletionItem::new_simple("label".to_owned(), "detail".to_owned());
-
         let disjoint_edit_1 = lsp_types::TextEdit::new(
             Range::new(Position::new(2, 2), Position::new(3, 3)),
             "new_text".to_owned(),
             Range::new(Position::new(3, 3), Position::new(4, 4)),
             "new_text".to_owned(),
         );
-
         let joint_edit = lsp_types::TextEdit::new(
             Range::new(Position::new(1, 1), Position::new(5, 5)),
             "new_text".to_owned(),
         );
-
         assert!(
             all_edits_are_disjoint(&empty_completion, &[]),
             "Empty completion has all its edits disjoint"
             ),
             "Empty completion is disjoint to whatever disjoint extra edits added"
         );
-
         assert!(
             !all_edits_are_disjoint(
                 &empty_completion,
             "Empty completion does not prevent joint extra edits from failing the validation"
         );
     }
-
     #[test]
     fn completion_with_joint_edits_disjoint_tests() {
         let disjoint_edit = lsp_types::TextEdit::new(
             Range::new(Position::new(1, 1), Position::new(5, 5)),
             "new_text".to_owned(),
         );
-
         let mut completion_with_joint_edits =
             CompletionItem::new_simple("label".to_owned(), "detail".to_owned());
         completion_with_joint_edits.additional_text_edits =
             !all_edits_are_disjoint(&completion_with_joint_edits, &[]),
             "Completion with disjoint edits fails the validation even with empty extra edits"
         );
-
         completion_with_joint_edits.text_edit =
             Some(CompletionTextEdit::Edit(disjoint_edit.clone()));
         completion_with_joint_edits.additional_text_edits = Some(vec![joint_edit.clone()]);
             !all_edits_are_disjoint(&completion_with_joint_edits, &[]),
             "Completion with disjoint edits fails the validation even with empty extra edits"
         );
-
         completion_with_joint_edits.text_edit =
             Some(CompletionTextEdit::InsertAndReplace(InsertReplaceEdit {
                 new_text: "new_text".to_owned(),
             "Completion with disjoint edits fails the validation even with empty extra edits"
         );
     }
-
     #[test]
     fn completion_with_disjoint_edits_disjoint_tests() {
         let disjoint_edit = lsp_types::TextEdit::new(
             Range::new(Position::new(1, 1), Position::new(5, 5)),
             "new_text".to_owned(),
         );
-
         let mut completion_with_disjoint_edits =
             CompletionItem::new_simple("label".to_owned(), "detail".to_owned());
         completion_with_disjoint_edits.text_edit = Some(CompletionTextEdit::Edit(disjoint_edit));
         let completion_with_disjoint_edits = completion_with_disjoint_edits;
-
         assert!(
             all_edits_are_disjoint(&completion_with_disjoint_edits, &[]),
             "Completion with disjoint edits is valid"