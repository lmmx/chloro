COMPARISON DIFF
============================================================

Original size: 16250 bytes
Chloro size:   16161 bytes
Rustfmt size:  16896 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Completion for (built-in) attributes, derives and lints.
 //!
 //! This module uses a bit of static metadata to provide completions for builtin-in attributes and lints.
 
+mod cfg;
+mod derive;
+mod diagnostic;
+mod lint;
+mod macro_use;
+mod repr;
+
 use std::sync::LazyLock;
 
 use ide_db::{
     item::CompletionItem,
     Completions,
 };
-
-mod cfg;
-mod derive;
-mod diagnostic;
-mod lint;
-mod macro_use;
-mod repr;
-
 pub(crate) use self::derive::complete_derive_path;
 
 /// Complete inputs to known builtin attributes as well as derive attributes
 ) -> Option<()> {
     let attribute = fake_attribute_under_caret;
     let path = attribute.path()?;
-    let segments = path
-        .segments()
-        .map(|s| s.name_ref())
-        .collect::<Option<Vec<_>>>()?;
+    let segments = path.segments().map(|s| s.name_ref()).collect::<Option<Vec<_>>>()?;
     let segments = segments.iter().map(|n| n.text()).collect::<Vec<_>>();
     let segments = segments.iter().map(|t| t.as_str()).collect::<Vec<_>>();
     let tt = attribute.token_tree()?;
     acc: &mut Completions,
     ctx: &CompletionContext<'_>,
     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx<'_>,
-    &AttrCtx {
-        kind,
-        annotated_item_kind,
-        ref derive_helpers,
-    }: &AttrCtx,
+    &AttrCtx { kind, annotated_item_kind, ref derive_helpers }: &AttrCtx,
 ) {
     let is_inner = kind == AttrKind::Inner;
 
         }
         Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}
     }
-    let qualifier_path = if let Qualified::With { path, .. } = qualified {
-        Some(path)
-    } else {
-        None
-    };
+    let qualifier_path =
+        if let Qualified::With { path, .. } = qualified { Some(path) } else { None };
 
     let attributes = annotated_item_kind.and_then(|kind| {
         if ast::Expr::can_cast(kind) {
         // add the missing parts to the label and snippet
         let mut label = attr_completion.label.to_owned();
         let mut snippet = attr_completion.snippet.map(|s| s.to_owned());
-        let segments = qualifier_path
-            .iter()
-            .flat_map(|q| q.segments())
-            .collect::<Vec<_>>();
+        let segments = qualifier_path.iter().flat_map(|q| q.segments()).collect::<Vec<_>>();
         let qualifiers = attr_completion.qualifiers;
         let matching_qualifiers = segments
             .iter()
             }
         }
 
-        let mut item = CompletionItem::new(
-            SymbolKind::Attribute,
-            ctx.source_range(),
-            label,
-            ctx.edition,
-        );
+        let mut item =
+            CompletionItem::new(SymbolKind::Attribute, ctx.source_range(), label, ctx.edition);
 
         if let Some(lookup) = attr_completion.lookup {
             item.lookup_by(lookup);
     };
 
     match attributes {
-        Some(applicable) => applicable
-            .iter()
-            .flat_map(|name| {
-                ATTRIBUTES
-                    .binary_search_by(|attr| attr.key().cmp(name))
-                    .ok()
-            })
-            .flat_map(|idx| ATTRIBUTES.get(idx))
-            .for_each(add_completion),
+        Some(applicable) => applicable.iter().flat_map(
+            |name| ATTRIBUTES.binary_search_by(|attr| attr.key().cmp(name)).ok(),
+        ).flat_map(
+            |idx| ATTRIBUTES.get(idx),
+        ).for_each(
+            add_completion,
+        ),
         None if is_inner => ATTRIBUTES.iter().for_each(add_completion),
-        None => ATTRIBUTES
-            .iter()
-            .filter(|compl| !compl.prefer_inner)
-            .for_each(add_completion),
+        None => ATTRIBUTES.iter().filter(|compl| !compl.prefer_inner).for_each(add_completion),
     }
 }
 
     }
 
     const fn prefer_inner(self) -> AttrCompletion {
-        AttrCompletion {
-            prefer_inner: true,
-            ..self
-        }
+        AttrCompletion { prefer_inner: true, ..self }
     }
 }
 
     lookup: Option<&'static str>,
     snippet: Option<&'static str>,
 ) -> AttrCompletion {
-    AttrCompletion {
-        label,
-        lookup,
-        snippet,
-        qualifiers: &[],
-        prefer_inner: false,
-    }
+    AttrCompletion { label, lookup, snippet, qualifiers: &[], prefer_inner: false }
 }
 
 macro_rules! attrs {
     .into_iter()
     .collect()
 });
+
 const EXPR_ATTRIBUTES: &[&str] = attrs!();
 
 /// <https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index>
-// Keep these sorted for the binary search!
 const ATTRIBUTES: &[AttrCompletion] = &[
     attr("allow(…)", Some("allow"), Some("allow(${0:lint})")),
     attr("automatically_derived", None, None),
     attr("cfg(…)", Some("cfg"), Some("cfg(${0:predicate})")),
-    attr(
-        "cfg_attr(…)",
-        Some("cfg_attr"),
-        Some("cfg_attr(${1:predicate}, ${0:attr})"),
-    ),
+    attr("cfg_attr(…)", Some("cfg_attr"), Some("cfg_attr(${1:predicate}, ${0:attr})")),
     attr("cold", None, None),
-    attr(
-        r#"crate_name = """#,
-        Some("crate_name"),
-        Some(r#"crate_name = "${0:crate_name}""#),
-    )
-    .prefer_inner(),
+    attr(r#"crate_name = """#, Some("crate_name"), Some(r#"crate_name = "${0:crate_name}""#))
+        .prefer_inner(),
     attr("deny(…)", Some("deny"), Some("deny(${0:lint})")),
     attr(r#"deprecated"#, Some("deprecated"), Some(r#"deprecated"#)),
     attr("derive(…)", Some("derive"), Some(r#"derive(${0:Debug})"#)),
-    attr(
-        "do_not_recommend",
-        Some("diagnostic::do_not_recommend"),
-        None,
-    )
-    .qualifiers(&["diagnostic"]),
+    attr("do_not_recommend", Some("diagnostic::do_not_recommend"), None)
+        .qualifiers(&["diagnostic"]),
     attr(
         "on_unimplemented",
         Some("diagnostic::on_unimplemented"),
     )
     .qualifiers(&["diagnostic"]),
     attr(r#"doc = "…""#, Some("doc"), Some(r#"doc = "${0:docs}""#)),
-    attr(
-        r#"doc(alias = "…")"#,
-        Some("docalias"),
-        Some(r#"doc(alias = "${0:docs}")"#),
-    ),
+    attr(r#"doc(alias = "…")"#, Some("docalias"), Some(r#"doc(alias = "${0:docs}")"#)),
     attr(r#"doc(hidden)"#, Some("dochidden"), Some(r#"doc(hidden)"#)),
-    attr(
-        r#"doc = include_str!("…")"#,
-        Some("docinclude"),
-        Some(r#"doc = include_str!("$0")"#),
-    ),
+    attr(r#"doc = include_str!("…")"#, Some("docinclude"), Some(r#"doc = include_str!("$0")"#)),
     attr("expect(…)", Some("expect"), Some("expect(${0:lint})")),
     attr(
         r#"export_name = "…""#,
     attr("feature(…)", Some("feature"), Some("feature(${0:flag})")).prefer_inner(),
     attr("forbid(…)", Some("forbid"), Some("forbid(${0:lint})")),
     attr("global_allocator", None, None),
-    attr(
-        r#"ignore = "…""#,
-        Some("ignore"),
-        Some(r#"ignore = "${0:reason}""#),
-    ),
+    attr(r#"ignore = "…""#, Some("ignore"), Some(r#"ignore = "${0:reason}""#)),
     attr("inline", Some("inline"), Some("inline")),
     attr("link", None, None),
-    attr(
-        r#"link_name = "…""#,
-        Some("link_name"),
-        Some(r#"link_name = "${0:symbol_name}""#),
-    ),
+    attr(r#"link_name = "…""#, Some("link_name"), Some(r#"link_name = "${0:symbol_name}""#)),
     attr(
         r#"link_section = "…""#,
         Some("link_section"),
     attr(r#"path = "…""#, Some("path"), Some(r#"path ="${0:path}""#)),
     attr("proc_macro", None, None),
     attr("proc_macro_attribute", None, None),
-    attr(
-        "proc_macro_derive(…)",
-        Some("proc_macro_derive"),
-        Some("proc_macro_derive(${0:Trait})"),
-    ),
+    attr("proc_macro_derive(…)", Some("proc_macro_derive"), Some("proc_macro_derive(${0:Trait})")),
     attr(
         r#"recursion_limit = "…""#,
         Some("recursion_limit"),
     )
     .prefer_inner(),
     attr("repr(…)", Some("repr"), Some("repr(${0:C})")),
-    attr(
-        "should_panic",
-        Some("should_panic"),
-        Some(r#"should_panic"#),
-    ),
+    attr("should_panic", Some("should_panic"), Some(r#"should_panic"#)),
     attr(
         r#"target_feature(enable = "…")"#,
         Some("target_feature"),
     ),
     attr("test", None, None),
     attr("track_caller", None, None),
-    attr(
-        "type_length_limit = …",
-        Some("type_length_limit"),
-        Some("type_length_limit = ${0:128}"),
-    )
-    .prefer_inner(),
+    attr("type_length_limit = …", Some("type_length_limit"), Some("type_length_limit = ${0:128}"))
+        .prefer_inner(),
     attr("used", None, None),
     attr("warn(…)", Some("warn"), Some("warn(${0:lint})")),
     attr(
         .skip(1)
         .take_while(|it| it.as_token() != Some(&r_paren));
     let input_expressions = tokens.chunk_by(|tok| tok.kind() == T![,]);
-    Some(
-        input_expressions
-            .into_iter()
-            .filter_map(|(is_sep, group)| (!is_sep).then_some(group))
-            .filter_map(|mut tokens| {
+    Some(input_expressions.into_iter().filter_map(|(is_sep, group)| (!is_sep).then_some(group)).filter_map(|mut tokens| {
                 syntax::hacks::parse_expr_from_str(&tokens.join(""), Edition::CURRENT)
-            })
-            .collect::<Vec<ast::Expr>>(),
-    )
+            }).collect::<Vec<ast::Expr>>(
+    ))
 }
 
 #[test]