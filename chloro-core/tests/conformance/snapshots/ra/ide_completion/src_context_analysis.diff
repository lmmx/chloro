COMPARISON DIFF
============================================================

Original size: 89146 bytes
Chloro size:   89150 bytes
Rustfmt size:  89146 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Module responsible for analyzing the code surrounding the cursor for completion.
+
 use std::iter;
 
 use hir::{ExpandResult, InFile, Semantics, Type, TypeInfo, Variant};
-use ide_db::{RootDatabase, active_parameter::ActiveParameter};
+use ide_db::{active_parameter::ActiveParameter, RootDatabase};
 use itertools::Either;
 use stdx::always;
 use syntax::{
-    AstNode, AstToken, Direction, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken,
-    T, TextRange, TextSize,
     algo::{
         self, ancestors_at_offset, find_node_at_offset, non_trivia_sibling,
         previous_non_trivia_token,
         self, AttrKind, HasArgList, HasGenericArgs, HasGenericParams, HasLoopBody, HasName,
         NameOrNameRef,
     },
-    match_ast,
+    match_ast, AstNode, AstToken, Direction, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode,
+    SyntaxToken, TextRange, TextSize, T,
 };
 
 use crate::{
     completions::postfix::is_in_condition,
     context::{
-        AttrCtx, BreakableKind, COMPLETION_MARKER, CompletionAnalysis, DotAccess, DotAccessExprCtx,
-        DotAccessKind, ItemListKind, LifetimeContext, LifetimeKind, NameContext, NameKind,
-        NameRefContext, NameRefKind, ParamContext, ParamKind, PathCompletionCtx, PathExprCtx,
-        PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx,
-        TypeAscriptionTarget, TypeLocation,
+        AttrCtx, BreakableKind, CompletionAnalysis, DotAccess, DotAccessExprCtx, DotAccessKind,
+        ItemListKind, LifetimeContext, LifetimeKind, NameContext, NameKind, NameRefContext,
+        NameRefKind, ParamContext, ParamKind, PathCompletionCtx, PathExprCtx, PathKind,
+        PatternContext, PatternRefutability, Qualified, QualifierCtx, TypeAscriptionTarget,
+        TypeLocation, COMPLETION_MARKER,
     },
 };
 
     }
 
     // We can't check whether the fake expansion is inside macro call, because that requires semantic info.
+
     // But hopefully checking just the real one should be enough.
     if token_at_offset_ignore_whitespace(&original_file.value, original_offset + relative_offset)
         .is_some_and(|original_token| {
     expansion_result: ExpansionResult,
     original_token: &SyntaxToken,
     self_token: &SyntaxToken,
-) -> Option<(CompletionAnalysis<'db>, (Option<Type<'db>>, Option<ast::NameOrNameRef>), QualifierCtx)>
-{
+) -> Option<(CompletionAnalysis<'db>, (Option<Type<'db>>, Option<ast::NameOrNameRef>), QualifierCtx)> {
     let _p = tracing::info_span!("CompletionContext::analyze").entered();
     let ExpansionResult {
         original_file,
     };
 
     // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.
+
     // ex. trait Foo $0 {}
+
     // in these cases parser recovery usually kicks in for our inserted identifier, causing it
+
     // to either be parsed as an ExprStmt or a ItemRecovery, depending on whether it is in a block
+
     // expression or an item list.
+
     // The following code checks if the body is missing, if it is we either cut off the body
+
     // from the item or it was missing in the first place
     let inbetween_body_and_decl_check = |node: SyntaxNode| {
         if let Some(NodeOrToken::Node(n)) =