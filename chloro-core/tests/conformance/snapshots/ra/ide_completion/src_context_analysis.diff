COMPARISON DIFF
============================================================

Original size: 89146 bytes
Chloro size:   89132 bytes
Rustfmt size:  89146 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Module responsible for analyzing the code surrounding the cursor for completion.
+
 use std::iter;
 
 use hir::{ExpandResult, InFile, Semantics, Type, TypeInfo, Variant};
 use crate::{
     completions::postfix::is_in_condition,
     context::{
-        AttrCtx, BreakableKind, COMPLETION_MARKER, CompletionAnalysis, DotAccess, DotAccessExprCtx,
-        DotAccessKind, ItemListKind, LifetimeContext, LifetimeKind, NameContext, NameKind,
-        NameRefContext, NameRefKind, ParamContext, ParamKind, PathCompletionCtx, PathExprCtx,
-        PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx,
+        AttrCtx, BreakableKind, COMPLETION_MARKER, CompletionAnalysis, DotAccess,
+        DotAccessExprCtx, DotAccessKind, ItemListKind, LifetimeContext, LifetimeKind, NameContext,
+        NameKind, NameRefContext, NameRefKind, ParamContext, ParamKind, PathCompletionCtx,
+        PathExprCtx, PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx,
         TypeAscriptionTarget, TypeLocation,
     },
 };
     let original_offset = expansion.original_offset + relative_offset;
     let token = expansion.original_file.token_at_offset(original_offset).left_biased()?;
 
-    hir::attach_db(sema.db, || analyze(sema, expansion, original_token, &token)).map(
-        |(analysis, expected, qualifier_ctx)| AnalysisResult {
+    hir::attach_db(sema.db, || analyze(sema, expansion, original_token, &token)).map(|(analysis, expected, qualifier_ctx)| AnalysisResult {
             analysis,
             expected,
             qualifier_ctx,
             token,
             original_offset,
-        },
-    )
+        })
 }
 
 fn token_at_offset_ignore_whitespace(file: &SyntaxNode, offset: TextSize) -> Option<SyntaxToken> {
     }
 
     // We can't check whether the fake expansion is inside macro call, because that requires semantic info.
+
     // But hopefully checking just the real one should be enough.
-    if token_at_offset_ignore_whitespace(&original_file.value, original_offset + relative_offset)
-        .is_some_and(|original_token| {
+    if token_at_offset_ignore_whitespace(&original_file.value, original_offset + relative_offset).is_some_and(|original_token| {
             !sema.is_inside_macro_call(original_file.with_value(&original_token))
-        })
-    {
+        }) {
         // Recursion base case.
         Some(ExpansionResult {
             original_file: original_file.value,
     expansion_result: ExpansionResult,
     original_token: &SyntaxToken,
     self_token: &SyntaxToken,
-) -> Option<(CompletionAnalysis<'db>, (Option<Type<'db>>, Option<ast::NameOrNameRef>), QualifierCtx)>
-{
+) -> Option<(CompletionAnalysis<'db>, (Option<Type<'db>>, Option<ast::NameOrNameRef>), QualifierCtx)> {
     let _p = tracing::info_span!("CompletionContext::analyze").entered();
     let ExpansionResult {
         original_file,
     };
 
     // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.
+
     // ex. trait Foo $0 {}
+
     // in these cases parser recovery usually kicks in for our inserted identifier, causing it
+
     // to either be parsed as an ExprStmt or a ItemRecovery, depending on whether it is in a block
+
     // expression or an item list.
+
     // The following code checks if the body is missing, if it is we either cut off the body
+
     // from the item or it was missing in the first place
     let inbetween_body_and_decl_check = |node: SyntaxNode| {
         if let Some(NodeOrToken::Node(n)) =
                 t.text_range().start() == path.syntax().text_range().start()
             }
         })
-    })()
-    .unwrap_or(false)
+    })().unwrap_or(
+        false,
+    )
 }
 
 fn is_in_breakable(node: &SyntaxNode) -> Option<(BreakableKind, SyntaxNode)> {
             .ancestors()
             .take_while(|it| it.text_range().start() == node.text_range().start())
             .filter_map(Either::<ast::ExprStmt, ast::Expr>::cast)
-            .last()
-    {
+            .last() {
         stmt_like.syntax().parent().and_then(ast::StmtList::cast).is_some()
     } else {
         false