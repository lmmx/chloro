COMPARISON DIFF
============================================================

Original size: 89146 bytes
Chloro size:   89130 bytes
Rustfmt size:  89146 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Module responsible for analyzing the code surrounding the cursor for completion.
+
 use std::iter;
 
 use hir::{ExpandResult, InFile, Semantics, Type, TypeInfo, Variant};
-use ide_db::{RootDatabase, active_parameter::ActiveParameter};
+use ide_db::{active_parameter::ActiveParameter, RootDatabase};
 use itertools::Either;
 use stdx::always;
 use syntax::{
-    AstNode, AstToken, Direction, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken,
-    T, TextRange, TextSize,
     algo::{
         self, ancestors_at_offset, find_node_at_offset, non_trivia_sibling,
         previous_non_trivia_token,
         self, AttrKind, HasArgList, HasGenericArgs, HasGenericParams, HasLoopBody, HasName,
         NameOrNameRef,
     },
-    match_ast,
+    match_ast, AstNode, AstToken, Direction, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode,
+    SyntaxToken, TextRange, TextSize, T,
 };
 
 use crate::{
     completions::postfix::is_in_condition,
     context::{
-        AttrCtx, BreakableKind, COMPLETION_MARKER, CompletionAnalysis, DotAccess, DotAccessExprCtx,
-        DotAccessKind, ItemListKind, LifetimeContext, LifetimeKind, NameContext, NameKind,
-        NameRefContext, NameRefKind, ParamContext, ParamKind, PathCompletionCtx, PathExprCtx,
-        PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx,
-        TypeAscriptionTarget, TypeLocation,
+        AttrCtx, BreakableKind, CompletionAnalysis, DotAccess, DotAccessExprCtx, DotAccessKind,
+        ItemListKind, LifetimeContext, LifetimeKind, NameContext, NameKind, NameRefContext,
+        NameRefKind, ParamContext, ParamKind, PathCompletionCtx, PathExprCtx, PathKind,
+        PatternContext, PatternRefutability, Qualified, QualifierCtx, TypeAscriptionTarget,
+        TypeLocation, COMPLETION_MARKER,
     },
 };
 
         fake_ident_token.clone(),
         relative_offset,
     )
-    .unwrap_or(ExpansionResult {
+        .unwrap_or(ExpansionResult {
         original_file: original_file.value,
         speculative_file,
         original_offset: offset,
     }
 
     // We can't check whether the fake expansion is inside macro call, because that requires semantic info.
+
     // But hopefully checking just the real one should be enough.
     if token_at_offset_ignore_whitespace(&original_file.value, original_offset + relative_offset)
         .is_some_and(|original_token| {
 ) -> Option<ExpansionResult> {
     let _p = tracing::info_span!("CompletionContext::expand").entered();
 
-    let parent_item =
-        |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);
+    let parent_item = |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);
     let original_node = token_at_offset_ignore_whitespace(&original_file.value, original_offset)
         .and_then(|token| token.parent_ancestors().find_map(ast::Item::cast));
     let ancestor_items = iter::successors(
     expansion_result: ExpansionResult,
     original_token: &SyntaxToken,
     self_token: &SyntaxToken,
-) -> Option<(CompletionAnalysis<'db>, (Option<Type<'db>>, Option<ast::NameOrNameRef>), QualifierCtx)>
-{
+) -> Option<(CompletionAnalysis<'db>, (Option<Type<'db>>, Option<ast::NameOrNameRef>), QualifierCtx)> {
     let _p = tracing::info_span!("CompletionContext::analyze").entered();
     let ExpansionResult {
         original_file,
         return None;
     }
 
-    let lifetime =
-        find_node_at_offset::<ast::Lifetime>(original_file, lifetime.syntax().text_range().start());
+    let lifetime = find_node_at_offset::<ast::Lifetime>(original_file, lifetime.syntax().text_range().start());
     let kind = match_ast! {
         match parent {
             ast::LifetimeParam(_) => LifetimeKind::LifetimeParam,
     };
 
     // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.
+
     // ex. trait Foo $0 {}
+
     // in these cases parser recovery usually kicks in for our inserted identifier, causing it
+
     // to either be parsed as an ExprStmt or a ItemRecovery, depending on whether it is in a block
+
     // expression or an item list.
+
     // The following code checks if the body is missing, if it is we either cut off the body
+
     // from the item or it was missing in the first place
     let inbetween_body_and_decl_check = |node: SyntaxNode| {
         if let Some(NodeOrToken::Node(n)) =
 
     let mut missing_variants = vec![];
 
-    let (refutability, has_type_ascription) =
-    pat
+    let (refutability, has_type_ascription) = pat
         .syntax()
         .ancestors()
         .find(|it| !ast::Pat::can_cast(it.kind()))
         Some(stmt) => stmt.syntax().clone(),
         None => node,
     };
-    let prev_sibling =
-        non_trivia_sibling(node.into(), Direction::Prev).and_then(NodeOrToken::into_node);
+    let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev).and_then(NodeOrToken::into_node);
     iter::successors(prev_sibling, |it| it.last_child_or_token()?.into_node())
         .find_map(ast::IfExpr::cast)
         .is_some()
         SyntaxElement::Node(n) => n.last_token()?,
         SyntaxElement::Token(t) => t,
     }
-    .next_token();
+        .next_token();
     while let Some(inner) = token {
         if !inner.kind().is_trivia() {
             return Some(inner);