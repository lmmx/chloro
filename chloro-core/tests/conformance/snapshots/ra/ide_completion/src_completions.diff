COMPARISON DIFF
============================================================

Original size: 25726 bytes
Chloro size:   26042 bytes
Rustfmt size:  25726 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::{SmolStr, ToSmolStr, ast};
 
 use crate::{
-    CompletionContext, CompletionItem, CompletionItemKind,
     context::{
         DotAccess, ItemListKind, NameContext, NameKind, NameRefContext, NameRefKind,
         PathCompletionCtx, PathKind, PatternContext, TypeLocation, Visible,
         type_alias::{render_type_alias, render_type_alias_with_eq},
         union_literal::render_union_literal,
     },
+    CompletionContext, CompletionItem, CompletionItemKind,
 };
 
 /// Represents an in-progress set of completions being built.
 impl Builder {
     /// Convenience method, which allows to add a freshly created completion into accumulator
     /// without binding it to the variable.
-    pub(crate) fn add_to(self, acc: &mut Completions, db: &RootDatabase) {
+    pub(crate) fn add_to(
+        self,
+        acc: &mut Completions,
+        db: &RootDatabase,
+    ) {
         acc.add(self.build(db))
     }
 }
 
 impl Completions {
-    fn add(&mut self, item: CompletionItem) {
+    fn add(
+        &mut self,
+        item: CompletionItem,
+    ) {
         self.buf.push(item)
     }
 
-    fn add_many(&mut self, items: impl IntoIterator<Item = CompletionItem>) {
+    fn add_many(
+        &mut self,
+        items: impl IntoIterator<Item = CompletionItem>,
+    ) {
         self.buf.extend(items)
     }
 
-    fn add_opt(&mut self, item: Option<CompletionItem>) {
+    fn add_opt(
+        &mut self,
+        item: Option<CompletionItem>,
+    ) {
         if let Some(item) = item {
             self.buf.push(item)
         }
     }
 
-    pub(crate) fn add_keyword(&mut self, ctx: &CompletionContext<'_>, keyword: &'static str) {
+    pub(crate) fn add_keyword(
+        &mut self,
+        ctx: &CompletionContext<'_>,
+        keyword: &'static str,
+    ) {
         let item = CompletionItem::new(
             CompletionItemKind::Keyword,
             ctx.source_range(),
         item.add_to(self, ctx.db);
     }
 
-    pub(crate) fn add_nameref_keywords_with_colon(&mut self, ctx: &CompletionContext<'_>) {
+    pub(crate) fn add_nameref_keywords_with_colon(
+        &mut self,
+        ctx: &CompletionContext<'_>,
+    ) {
         ["self::", "crate::"].into_iter().for_each(|kw| self.add_keyword(ctx, kw));
-
         if ctx.depth_from_crate_root > 0 {
             self.add_keyword(ctx, "super::");
         }
     }
 
-    pub(crate) fn add_nameref_keywords(&mut self, ctx: &CompletionContext<'_>) {
+    pub(crate) fn add_nameref_keywords(
+        &mut self,
+        ctx: &CompletionContext<'_>,
+    ) {
         ["self", "crate"].into_iter().for_each(|kw| self.add_keyword(ctx, kw));
-
         if ctx.depth_from_crate_root > 0 {
             self.add_keyword(ctx, "super");
         }
     }
 
-    pub(crate) fn add_type_keywords(&mut self, ctx: &CompletionContext<'_>) {
+    pub(crate) fn add_type_keywords(
+        &mut self,
+        ctx: &CompletionContext<'_>,
+    ) {
         self.add_keyword_snippet(ctx, "fn", "fn($1)");
         self.add_keyword_snippet(ctx, "dyn", "dyn $0");
         self.add_keyword_snippet(ctx, "impl", "impl $0");
     ) {
         let mut item =
             CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw, ctx.edition);
-
         match ctx.config.snippet_cap {
             Some(cap) => {
                 if incomplete_let && snippet.ends_with('}') {
     ) {
         let mut item =
             CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw, ctx.edition);
-
         match ctx.config.snippet_cap {
             Some(cap) => item.insert_snippet(cap, snippet),
             None => item.insert_text(if snippet.contains('$') { kw } else { snippet }),
         );
     }
 
-    pub(crate) fn add_const(&mut self, ctx: &CompletionContext<'_>, konst: hir::Const) {
+    pub(crate) fn add_const(
+        &mut self,
+        ctx: &CompletionContext<'_>,
+        konst: hir::Const,
+    ) {
         let is_private_editable = match ctx.is_visible(&konst) {
             Visible::Yes => false,
             Visible::Editable => true,
             self.add_variant_pat(ctx, pat_ctx, Some(path_ctx), variant, local_name);
             return;
         }
-
         if let Some(builder) =
             render_variant_lit(RenderContext::new(ctx), path_ctx, local_name, variant, None)
         {
         self.add(item);
     }
 
-    pub(crate) fn add_lifetime(&mut self, ctx: &CompletionContext<'_>, name: hir::Name) {
+    pub(crate) fn add_lifetime(
+        &mut self,
+        ctx: &CompletionContext<'_>,
+        name: hir::Name,
+    ) {
         CompletionItem::new(
             SymbolKind::LifetimeParam,
             ctx.source_range(),
         .add_to(self, ctx.db)
     }
 
-    pub(crate) fn add_label(&mut self, ctx: &CompletionContext<'_>, name: hir::Name) {
+    pub(crate) fn add_label(
+        &mut self,
+        ctx: &CompletionContext<'_>,
+        name: hir::Name,
+    ) {
         CompletionItem::new(
             SymbolKind::Label,
             ctx.source_range(),
         ));
     }
 
-    pub(crate) fn suggest_name(&mut self, ctx: &CompletionContext<'_>, name: &str) {
+    pub(crate) fn suggest_name(
+        &mut self,
+        ctx: &CompletionContext<'_>,
+        name: &str,
+    ) {
         let item = CompletionItem::new(
             CompletionItemKind::Binding,
             ctx.source_range(),
 
         cb(acc, ctx, variant, self_path);
     };
-
     let variants = enum_.variants(ctx.db);
-
     if let Some(impl_) = impl_.and_then(|impl_| ctx.sema.to_def(impl_))
         && impl_.self_ty(ctx.db).as_adt() == Some(hir::Adt::Enum(enum_))
     {
         variants.iter().for_each(|variant| process_variant(*variant));
     }
-
     for variant in variants {
         if let Some(path) = ctx.module.find_path(
             ctx.db,