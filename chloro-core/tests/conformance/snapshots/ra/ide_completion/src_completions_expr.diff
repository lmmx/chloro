COMPARISON DIFF
============================================================

Original size: 20947 bytes
Chloro size:   20947 bytes
Rustfmt size:  21861 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Completion of names from the current scope in expression position.
 
 use std::ops::ControlFlow;
 
-use hir::{sym, Complete, Name, PathCandidateCallback, ScopeDef};
+use hir::{Complete, Name, PathCandidateCallback, ScopeDef, sym};
 use ide_db::FxHashSet;
 use syntax::ast;
 
 
     let (has_raw_token, has_const_token, has_mut_token) = ref_expr_parent
         .as_ref()
-        .map(|it| {
-            (
-                it.raw_token().is_some(),
-                it.const_token().is_some(),
-                it.mut_token().is_some(),
-            )
-        })
+        .map(|it| (it.raw_token().is_some(), it.const_token().is_some(), it.mut_token().is_some()))
         .unwrap_or((false, false, false));
 
     let wants_raw_token = ref_expr_parent.is_some() && !has_raw_token && after_amp;
     let wants_const_token =
         ref_expr_parent.is_some() && has_raw_token && !has_const_token && !has_mut_token;
     let wants_mut_token = if ref_expr_parent.is_some() {
-        if has_raw_token {
-            !has_const_token && !has_mut_token
-        } else {
-            !has_mut_token
-        }
+        if has_raw_token { !has_const_token && !has_mut_token } else { !has_mut_token }
     } else {
         false
     };
     match qualified {
         // We exclude associated types/consts of excluded traits here together with methods,
         // even though we don't exclude them when completing in type position, because it's easier.
-        Qualified::TypeAnchor {
-            ty: None,
-            trait_: None,
-        } => ctx
+        Qualified::TypeAnchor { ty: None, trait_: None } => ctx
             .traits_in_scope()
             .iter()
             .copied()
             })
             .flat_map(|it| it.items(ctx.sema.db))
             .for_each(|item| add_assoc_item(acc, item)),
-        Qualified::TypeAnchor {
-            trait_: Some(trait_),
-            ..
-        } => {
+        Qualified::TypeAnchor { trait_: Some(trait_), .. } => {
             // Don't filter excluded traits here, user requested this specific trait.
-            trait_
-                .items(ctx.sema.db)
-                .into_iter()
-                .for_each(|item| add_assoc_item(acc, item))
+            trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))
         }
-        Qualified::TypeAnchor {
-            ty: Some(ty),
-            trait_: None,
-        } => {
+        Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {
             if let Some(hir::Adt::Enum(e)) = ty.as_adt() {
                 cov_mark::hit!(completes_variant_through_alias);
                 acc.add_enum_variants(ctx, path_ctx, e);
                 &ctx.traits_in_scope(),
                 Some(ctx.module),
                 None,
-                PathCallback {
-                    ctx,
-                    acc,
-                    add_assoc_item,
-                    seen: FxHashSet::default(),
-                },
+                PathCallback { ctx, acc, add_assoc_item, seen: FxHashSet::default() },
             );
 
             // Iterate assoc types separately
                 None::<()>
             });
         }
-        Qualified::With {
-            resolution: None, ..
-        } => {}
-        Qualified::With {
-            resolution: Some(resolution),
-            ..
-        } => {
+        Qualified::With { resolution: None, .. } => {}
+        Qualified::With { resolution: Some(resolution), .. } => {
             // Add associated types on type parameters and `Self`.
-            ctx.scope
-                .assoc_type_shorthand_candidates(resolution, |alias| {
-                    acc.add_type_alias(ctx, alias);
-                });
+            ctx.scope.assoc_type_shorthand_candidates(resolution, |alias| {
+                acc.add_type_alias(ctx, alias);
+            });
             match resolution {
                 hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {
                     let visible_from = if ctx.config.enable_private_editable {
                         &ctx.traits_in_scope(),
                         Some(ctx.module),
                         None,
-                        PathCallback {
-                            ctx,
-                            acc,
-                            add_assoc_item,
-                            seen: FxHashSet::default(),
-                        },
+                        PathCallback { ctx, acc, add_assoc_item, seen: FxHashSet::default() },
                     );
 
                     // Iterate assoc types separately
                         &ctx.traits_in_scope(),
                         Some(ctx.module),
                         None,
-                        PathCallback {
-                            ctx,
-                            acc,
-                            add_assoc_item,
-                            seen: FxHashSet::default(),
-                        },
+                        PathCallback { ctx, acc, add_assoc_item, seen: FxHashSet::default() },
                     );
                 }
                 _ => (),
         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),
         Qualified::No => {
             acc.add_nameref_keywords_with_colon(ctx);
-            if let Some(adt) = ctx
-                .expected_type
-                .as_ref()
-                .and_then(|ty| ty.strip_references().as_adt())
+            if let Some(adt) =
+                ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())
             {
                 let self_ty = (|| ctx.sema.to_def(impl_.as_ref()?)?.self_ty(ctx.db).as_adt())();
                 let complete_self = self_ty == Some(adt);
 
             match is_func_update {
                 Some(record_expr) => {
-                    let ty = ctx
-                        .sema
-                        .type_of_expr(&ast::Expr::RecordExpr(record_expr.clone()));
+                    let ty = ctx.sema.type_of_expr(&ast::Expr::RecordExpr(record_expr.clone()));
 
                     match ty.as_ref().and_then(|t| t.original.as_adt()) {
                         Some(hir::Adt::Union(_)) => (),
         for expr in exprs {
             // Expand method calls
             match expr {
-                hir::term_search::Expr::Method {
-                    func,
-                    generics,
-                    target,
-                    params,
-                } if target.is_many() => {
+                hir::term_search::Expr::Method { func, generics, target, params }
+                    if target.is_many() =>
+                {
                     let target_ty = target.ty(ctx.db);
-                    let term_search_ctx = hir::term_search::TermSearchCtx {
-                        goal: target_ty,
-                        ..term_search_ctx
-                    };
+                    let term_search_ctx =
+                        hir::term_search::TermSearchCtx { goal: target_ty, ..term_search_ctx };
                     let target_exprs = hir::term_search::term_search(&term_search_ctx);
 
                     for expr in target_exprs {