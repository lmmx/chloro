COMPARISON DIFF
============================================================

Original size: 20947 bytes
Chloro size:   20995 bytes
Rustfmt size:  21861 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Completion of names from the current scope in expression position.
 
 use std::ops::ControlFlow;
 
-use hir::{sym, Complete, Name, PathCandidateCallback, ScopeDef};
+use hir::{Complete, Name, PathCandidateCallback, ScopeDef, sym};
 use ide_db::FxHashSet;
 use syntax::ast;
 
 
 impl<F> PathCandidateCallback for PathCallback<'_, F>
 where
-    F: FnMut(&mut Completions, hir::AssocItem),
-{
-    fn on_inherent_item(&mut self, item: hir::AssocItem) -> ControlFlow<()> {
+    F: FnMut(&mut Completions, hir::AssocItem), {
+    fn on_inherent_item(
+        &mut self,
+        item: hir::AssocItem,
+    ) -> ControlFlow<()> {
         if self.seen.insert(item) {
             (self.add_assoc_item)(self.acc, item);
         }
         ControlFlow::Continue(())
     }
 
-    fn on_trait_item(&mut self, item: hir::AssocItem) -> ControlFlow<()> {
+    fn on_trait_item(
+        &mut self,
+        item: hir::AssocItem,
+    ) -> ControlFlow<()> {
         // The excluded check needs to come before the `seen` test, so that if we see the same method twice,
         // once as inherent and once not, we will include it.
         if item.container_trait(self.ctx.db).is_none_or(|trait_| {
     if !ctx.qualifier_ctx.none() {
         return;
     }
-
     let &PathExprCtx {
         in_block_expr,
         after_if_expr,
         in_match_guard,
         ..
     } = expr_ctx;
-
     let (has_raw_token, has_const_token, has_mut_token) = ref_expr_parent
         .as_ref()
-        .map(|it| {
-            (
-                it.raw_token().is_some(),
-                it.const_token().is_some(),
-                it.mut_token().is_some(),
-            )
-        })
+        .map(|it| (it.raw_token().is_some(), it.const_token().is_some(), it.mut_token().is_some()))
         .unwrap_or((false, false, false));
-
     let wants_raw_token = ref_expr_parent.is_some() && !has_raw_token && after_amp;
     let wants_const_token =
         ref_expr_parent.is_some() && has_raw_token && !has_const_token && !has_mut_token;
     let wants_mut_token = if ref_expr_parent.is_some() {
-        if has_raw_token {
-            !has_const_token && !has_mut_token
-        } else {
-            !has_mut_token
-        }
+        if has_raw_token { !has_const_token && !has_mut_token } else { !has_mut_token }
     } else {
         false
     };
-
     let scope_def_applicable = |def| match def {
         ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) | ScopeDef::Label(_) => false,
         ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),
         _ => true,
     };
-
     let add_assoc_item = |acc: &mut Completions, item| match item {
         hir::AssocItem::Function(func) => acc.add_function(ctx, path_ctx, func, None),
         hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),
         hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),
     };
-
     match qualified {
         // We exclude associated types/consts of excluded traits here together with methods,
         // even though we don't exclude them when completing in type position, because it's easier.
-        Qualified::TypeAnchor {
-            ty: None,
-            trait_: None,
-        } => ctx
+        Qualified::TypeAnchor { ty: None, trait_: None } => ctx
             .traits_in_scope()
             .iter()
             .copied()
             })
             .flat_map(|it| it.items(ctx.sema.db))
             .for_each(|item| add_assoc_item(acc, item)),
-        Qualified::TypeAnchor {
-            trait_: Some(trait_),
-            ..
-        } => {
+        Qualified::TypeAnchor { trait_: Some(trait_), .. } => {
             // Don't filter excluded traits here, user requested this specific trait.
-            trait_
-                .items(ctx.sema.db)
-                .into_iter()
-                .for_each(|item| add_assoc_item(acc, item))
+            trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))
         }
-        Qualified::TypeAnchor {
-            ty: Some(ty),
-            trait_: None,
-        } => {
+        Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {
             if let Some(hir::Adt::Enum(e)) = ty.as_adt() {
                 cov_mark::hit!(completes_variant_through_alias);
                 acc.add_enum_variants(ctx, path_ctx, e);
                 &ctx.traits_in_scope(),
                 Some(ctx.module),
                 None,
-                PathCallback {
-                    ctx,
-                    acc,
-                    add_assoc_item,
-                    seen: FxHashSet::default(),
-                },
+                PathCallback { ctx, acc, add_assoc_item, seen: FxHashSet::default() },
             );
 
             // Iterate assoc types separately
                 None::<()>
             });
         }
-        Qualified::With {
-            resolution: None, ..
-        } => {}
-        Qualified::With {
-            resolution: Some(resolution),
-            ..
-        } => {
+        Qualified::With { resolution: None, .. } => {}
+        Qualified::With { resolution: Some(resolution), .. } => {
             // Add associated types on type parameters and `Self`.
-            ctx.scope
-                .assoc_type_shorthand_candidates(resolution, |alias| {
-                    acc.add_type_alias(ctx, alias);
-                });
+            ctx.scope.assoc_type_shorthand_candidates(resolution, |alias| {
+                acc.add_type_alias(ctx, alias);
+            });
             match resolution {
                 hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {
                     let visible_from = if ctx.config.enable_private_editable {
                         &ctx.traits_in_scope(),
                         Some(ctx.module),
                         None,
-                        PathCallback {
-                            ctx,
-                            acc,
-                            add_assoc_item,
-                            seen: FxHashSet::default(),
-                        },
+                        PathCallback { ctx, acc, add_assoc_item, seen: FxHashSet::default() },
                     );
 
                     // Iterate assoc types separately
                         &ctx.traits_in_scope(),
                         Some(ctx.module),
                         None,
-                        PathCallback {
-                            ctx,
-                            acc,
-                            add_assoc_item,
-                            seen: FxHashSet::default(),
-                        },
+                        PathCallback { ctx, acc, add_assoc_item, seen: FxHashSet::default() },
                     );
                 }
                 _ => (),
         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),
         Qualified::No => {
             acc.add_nameref_keywords_with_colon(ctx);
-            if let Some(adt) = ctx
-                .expected_type
-                .as_ref()
-                .and_then(|ty| ty.strip_references().as_adt())
+            if let Some(adt) =
+                ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())
             {
                 let self_ty = (|| ctx.sema.to_def(impl_.as_ref()?)?.self_ty(ctx.db).as_adt())();
                 let complete_self = self_ty == Some(adt);
 
             match is_func_update {
                 Some(record_expr) => {
-                    let ty = ctx
-                        .sema
-                        .type_of_expr(&ast::Expr::RecordExpr(record_expr.clone()));
+                    let ty = ctx.sema.type_of_expr(&ast::Expr::RecordExpr(record_expr.clone()));
 
                     match ty.as_ref().and_then(|t| t.original.as_adt()) {
                         Some(hir::Adt::Union(_)) => (),
     }
 }
 
-pub(crate) fn complete_expr(acc: &mut Completions, ctx: &CompletionContext<'_>) {
+pub(crate) fn complete_expr(
+    acc: &mut Completions,
+    ctx: &CompletionContext<'_>,
+) {
     let _p = tracing::info_span!("complete_expr").entered();
-
     if !ctx.config.enable_term_search {
         return;
     }
-
     if !ctx.qualifier_ctx.none() {
         return;
     }
-
     if let Some(ty) = &ctx.expected_type {
         // Ignore unit types as they are not very interesting
         if ty.is_unit() || ty.is_unknown() {
         for expr in exprs {
             // Expand method calls
             match expr {
-                hir::term_search::Expr::Method {
-                    func,
-                    generics,
-                    target,
-                    params,
-                } if target.is_many() => {
+                hir::term_search::Expr::Method { func, generics, target, params }
+                    if target.is_many() =>
+                {
                     let target_ty = target.ty(ctx.db);
-                    let term_search_ctx = hir::term_search::TermSearchCtx {
-                        goal: target_ty,
-                        ..term_search_ctx
-                    };
+                    let term_search_ctx =
+                        hir::term_search::TermSearchCtx { goal: target_ty, ..term_search_ctx };
                     let target_exprs = hir::term_search::term_search(&term_search_ctx);
 
                     for expr in target_exprs {