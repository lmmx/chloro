COMPARISON DIFF
============================================================

Original size: 30787 bytes
Chloro size:   30815 bytes
Rustfmt size:  31005 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     ScopeDef, Semantics, SemanticsScope, Symbol, Type, TypeInfo,
 };
 use ide_db::{
-    famous_defs::FamousDefs, helpers::is_editable_crate, FilePosition, FxHashMap, FxHashSet,
-    RootDatabase,
+    FilePosition, FxHashMap, FxHashSet, RootDatabase, famous_defs::FamousDefs,
+    helpers::is_editable_crate,
 };
 use itertools::Either;
 use syntax::{
-    ast::{self, AttrKind, NameOrNameRef},
-    match_ast, AstNode, Edition, SmolStr,
+    AstNode, Edition, SmolStr,
     SyntaxKind::{self, *},
-    SyntaxToken, TextRange, TextSize, T,
+    SyntaxToken, T, TextRange, TextSize,
+    ast::{self, AttrKind, NameOrNameRef},
+    match_ast,
 };
 
 use crate::{
-    config::AutoImportExclusionType,
-    context::analysis::{expand_and_analyze, AnalysisResult},
     CompletionConfig,
+    config::AutoImportExclusionType,
+    context::analysis::{AnalysisResult, expand_and_analyze},
 };
 
 const COMPLETION_MARKER: &str = "raCompletionMarker";
     pub(crate) qualified: Qualified<'db>,
     /// The parent of the path we are completing.
     pub(crate) parent: Option<ast::Path>,
-    #[allow(dead_code)]
     /// The path of which we are completing the segment
+    #[allow(dead_code)]
     pub(crate) path: ast::Path,
     /// The path of which we are completing the segment in the original file
     pub(crate) original_path: Option<ast::Path>,
 
     pub(crate) fn complete_types(&self) -> bool {
         match self {
-            TypeLocation::GenericArg {
-                corresponding_param: Some(param),
-                ..
-            } => {
+            TypeLocation::GenericArg { corresponding_param: Some(param), .. } => {
                 matches!(param, ast::GenericParam::TypeParam(_))
             }
             TypeLocation::AssocConstEq => false,
     Impl,
     TraitImpl(Option<ast::Impl>),
     Trait,
-    ExternBlock { is_unsafe: bool },
+    ExternBlock {
+        is_unsafe: bool,
+    },
 }
 
 #[derive(Debug)]
 
 /// The state of the lifetime we are completing.
 #[derive(Debug)]
-pub(crate) struct LifetimeContext {
-    pub(crate) kind: LifetimeKind,
-}
+pub(crate) struct LifetimeContext { pub(crate) kind: LifetimeKind }
 
 /// The kind of lifetime we are completing.
 #[derive(Debug)]
     pub(crate) db: &'a RootDatabase,
     pub(crate) config: &'a CompletionConfig<'a>,
     pub(crate) position: FilePosition,
-
     pub(crate) trigger_character: Option<char>,
     /// The token before the cursor, in the original file.
     pub(crate) original_token: SyntaxToken,
     pub(crate) containing_function: Option<hir::Function>,
     /// Whether nightly toolchain is used. Cached since this is looked up a lot.
     pub(crate) is_nightly: bool,
-    /// The edition of the current crate
     // FIXME: This should probably be the crate of the current token?
+    /// The edition of the current crate
     pub(crate) edition: Edition,
-
     /// The expected name of what we are completing.
     /// This is usually the parameter name of the function argument we are completing.
     pub(crate) expected_name: Option<NameOrNameRef>,
     /// The expected type of what we are completing.
     pub(crate) expected_type: Option<Type<'a>>,
-
     pub(crate) qualifier_ctx: QualifierCtx,
-
     pub(crate) locals: FxHashMap<Name, Local>,
-
     /// The module depth of the current module of the cursor position.
     /// - crate-root
     ///  - mod foo
     ///
     /// Here depth will be 2
     pub(crate) depth_from_crate_root: usize,
-
     /// Traits whose methods will be excluded from flyimport. Flyimport should not suggest
     /// importing those traits.
     ///
     ///
     /// Note the trait *themselves* are not excluded, only their methods are.
     pub(crate) exclude_traits: FxHashSet<hir::Trait>,
-
     /// Whether and how to complete semicolon for unit-returning functions.
     pub(crate) complete_semicolon: CompleteSemicolon,
 }
     }
 }
 
-// CompletionContext construction
 impl<'db> CompletionContext<'db> {
     pub(crate) fn new(
         db: &'db RootDatabase,
         let file_with_fake_ident = {
             let (_, edition) = editioned_file_id.unpack(db);
             let parse = db.parse(editioned_file_id);
-            parse
-                .reparse(TextRange::empty(offset), COMPLETION_MARKER, edition)
-                .tree()
+            parse.reparse(TextRange::empty(offset), COMPLETION_MARKER, edition).tree()
         };
 
         // always pick the token to the immediate left of the cursor, as that is what we are actually
         // completing on
-        let original_token = original_file
-            .syntax()
-            .token_at_offset(offset)
-            .left_biased()?;
+        let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;
 
         // try to skip completions on path with invalid colons
         // this approach works in normal path and inside token tree
                     .map(|it| (it.into_module_def(), *kind))
             })
             .collect();
-        exclude_flyimport.extend(
-            exclude_traits
-                .iter()
-                .map(|&t| (t.into(), AutoImportExclusionType::Always)),
-        );
+        exclude_flyimport
+            .extend(exclude_traits.iter().map(|&t| (t.into(), AutoImportExclusionType::Always)));
 
         // FIXME: This should be part of `CompletionAnalysis` / `expand_and_analyze`
         let complete_semicolon = if config.add_semicolon_to_unit {