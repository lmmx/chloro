COMPARISON DIFF
============================================================

Original size: 30787 bytes
Chloro size:   30947 bytes
Rustfmt size:  31005 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     ScopeDef, Semantics, SemanticsScope, Symbol, Type, TypeInfo,
 };
 use ide_db::{
-    famous_defs::FamousDefs, helpers::is_editable_crate, FilePosition, FxHashMap, FxHashSet,
-    RootDatabase,
+    FilePosition, FxHashMap, FxHashSet, RootDatabase, famous_defs::FamousDefs,
+    helpers::is_editable_crate,
 };
 use itertools::Either;
 use syntax::{
-    ast::{self, AttrKind, NameOrNameRef},
-    match_ast, AstNode, Edition, SmolStr,
+    AstNode, Edition, SmolStr,
     SyntaxKind::{self, *},
-    SyntaxToken, TextRange, TextSize, T,
+    SyntaxToken, T, TextRange, TextSize,
+    ast::{self, AttrKind, NameOrNameRef},
+    match_ast,
 };
 
 use crate::{
-    config::AutoImportExclusionType,
-    context::analysis::{expand_and_analyze, AnalysisResult},
     CompletionConfig,
+    config::AutoImportExclusionType,
+    context::analysis::{AnalysisResult, expand_and_analyze},
 };
 
 const COMPLETION_MARKER: &str = "raCompletionMarker";
 /// Existing qualifiers for the thing we are currently completing.
 #[derive(Debug, Default)]
 pub(crate) struct QualifierCtx {
-    // TODO: Add try_tok and default_tok
     pub(crate) async_tok: Option<SyntaxToken>,
     pub(crate) unsafe_tok: Option<SyntaxToken>,
     pub(crate) safe_tok: Option<SyntaxToken>,
     pub(crate) qualified: Qualified<'db>,
     /// The parent of the path we are completing.
     pub(crate) parent: Option<ast::Path>,
-    #[allow(dead_code)]
     /// The path of which we are completing the segment
+    #[allow(dead_code)]
     pub(crate) path: ast::Path,
     /// The path of which we are completing the segment in the original file
     pub(crate) original_path: Option<ast::Path>,
 
     pub(crate) fn complete_types(&self) -> bool {
         match self {
-            TypeLocation::GenericArg {
-                corresponding_param: Some(param),
-                ..
-            } => {
+            TypeLocation::GenericArg { corresponding_param: Some(param), .. } => {
                 matches!(param, ast::GenericParam::TypeParam(_))
             }
             TypeLocation::AssocConstEq => false,
     Impl,
     TraitImpl(Option<ast::Impl>),
     Trait,
-    ExternBlock { is_unsafe: bool },
+    ExternBlock {
+        is_unsafe: bool,
+    },
 }
 
 #[derive(Debug)]
     pub(crate) db: &'a RootDatabase,
     pub(crate) config: &'a CompletionConfig<'a>,
     pub(crate) position: FilePosition,
-
     pub(crate) trigger_character: Option<char>,
     /// The token before the cursor, in the original file.
     pub(crate) original_token: SyntaxToken,
     /// Whether nightly toolchain is used. Cached since this is looked up a lot.
     pub(crate) is_nightly: bool,
     /// The edition of the current crate
-    // FIXME: This should probably be the crate of the current token?
     pub(crate) edition: Edition,
-
     /// The expected name of what we are completing.
     /// This is usually the parameter name of the function argument we are completing.
     pub(crate) expected_name: Option<NameOrNameRef>,
     /// The expected type of what we are completing.
     pub(crate) expected_type: Option<Type<'a>>,
-
     pub(crate) qualifier_ctx: QualifierCtx,
-
     pub(crate) locals: FxHashMap<Name, Local>,
-
     /// The module depth of the current module of the cursor position.
     /// - crate-root
     ///  - mod foo
     ///
     /// Here depth will be 2
     pub(crate) depth_from_crate_root: usize,
-
     /// Traits whose methods will be excluded from flyimport. Flyimport should not suggest
     /// importing those traits.
     ///
     ///
     /// Note the trait *themselves* are not excluded, only their methods are.
     pub(crate) exclude_traits: FxHashSet<hir::Trait>,
-
     /// Whether and how to complete semicolon for unit-returning functions.
     pub(crate) complete_semicolon: CompleteSemicolon,
 }
     }
 
     /// Checks if an item is visible and not `doc(hidden)` at the completion site.
-    pub(crate) fn def_is_visible(&self, item: &ScopeDef) -> Visible {
+    pub(crate) fn def_is_visible(
+        &self,
+        item: &ScopeDef,
+    ) -> Visible {
         match item {
             ScopeDef::ModuleDef(def) => match def {
                 hir::ModuleDef::Module(it) => self.is_visible(it),
     }
 
     /// Checks if an item is visible, not `doc(hidden)` and stable at the completion site.
-    pub(crate) fn is_visible<I>(&self, item: &I) -> Visible
+    pub(crate) fn is_visible<I>(
+        &self,
+        item: &I,
+    ) -> Visible
     where
-        I: hir::HasVisibility + hir::HasAttrs + hir::HasCrate + Copy,
-    {
+        I: hir::HasVisibility + hir::HasAttrs + hir::HasCrate + Copy, {
         let vis = item.visibility(self.db);
         let attrs = item.attrs(self.db);
         self.is_visible_impl(&vis, &attrs, item.krate(self.db))
     }
 
-    pub(crate) fn doc_aliases<I>(&self, item: &I) -> Vec<SmolStr>
+    pub(crate) fn doc_aliases<I>(
+        &self,
+        item: &I,
+    ) -> Vec<SmolStr>
     where
-        I: hir::HasAttrs + Copy,
-    {
+        I: hir::HasAttrs + Copy, {
         let attrs = item.attrs(self.db);
         attrs.doc_aliases().map(|it| it.as_str().into()).collect()
     }
 
     /// Check if an item is `#[doc(hidden)]`.
-    pub(crate) fn is_item_hidden(&self, item: &hir::ItemInNs) -> bool {
+    pub(crate) fn is_item_hidden(
+        &self,
+        item: &hir::ItemInNs,
+    ) -> bool {
         let attrs = item.attrs(self.db);
         let krate = item.krate(self.db);
         match (attrs, krate) {
     }
 
     /// Checks whether this item should be listed in regards to stability. Returns `true` if we should.
-    pub(crate) fn check_stability(&self, attrs: Option<&hir::Attrs>) -> bool {
+    pub(crate) fn check_stability(
+        &self,
+        attrs: Option<&hir::Attrs>,
+    ) -> bool {
         let Some(attrs) = attrs else {
             return true;
         };
         !attrs.is_unstable() || self.is_nightly
     }
 
-    pub(crate) fn check_stability_and_hidden<I>(&self, item: I) -> bool
+    pub(crate) fn check_stability_and_hidden<I>(
+        &self,
+        item: I,
+    ) -> bool
     where
-        I: hir::HasAttrs + hir::HasCrate,
-    {
+        I: hir::HasAttrs + hir::HasCrate, {
         let defining_crate = item.krate(self.db);
         let attrs = item.attrs(self.db);
         self.check_stability(Some(&attrs)) && !self.is_doc_hidden(&attrs, defining_crate)
     }
 
     /// Whether the given trait is an operator trait or not.
-    pub(crate) fn is_ops_trait(&self, trait_: hir::Trait) -> bool {
+    pub(crate) fn is_ops_trait(
+        &self,
+        trait_: hir::Trait,
+    ) -> bool {
         match trait_.attrs(self.db).lang() {
             Some(lang) => OP_TRAIT_LANG_NAMES.contains(&lang.as_str()),
             None => false,
     }
 
     /// Whether the given trait has `#[doc(notable_trait)]`
-    pub(crate) fn is_doc_notable_trait(&self, trait_: hir::Trait) -> bool {
+    pub(crate) fn is_doc_notable_trait(
+        &self,
+        trait_: hir::Trait,
+    ) -> bool {
         trait_.attrs(self.db).has_doc_notable_trait()
     }
 
 
     /// A version of [`SemanticsScope::process_all_names`] that filters out `#[doc(hidden)]` items and
     /// passes all doc-aliases along, to funnel it into [`Completions::add_path_resolution`].
-    pub(crate) fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef, Vec<SmolStr>)) {
+    pub(crate) fn process_all_names(
+        &self,
+        f: &mut dyn FnMut(Name, ScopeDef, Vec<SmolStr>),
+    ) {
         let _p = tracing::info_span!("CompletionContext::process_all_names").entered();
         self.scope.process_all_names(&mut |name, def| {
             if self.is_scope_def_hidden(def) {
         });
     }
 
-    pub(crate) fn process_all_names_raw(&self, f: &mut dyn FnMut(Name, ScopeDef)) {
+    pub(crate) fn process_all_names_raw(
+        &self,
+        f: &mut dyn FnMut(Name, ScopeDef),
+    ) {
         let _p = tracing::info_span!("CompletionContext::process_all_names_raw").entered();
         self.scope.process_all_names(f);
     }
 
-    fn is_scope_def_hidden(&self, scope_def: ScopeDef) -> bool {
+    fn is_scope_def_hidden(
+        &self,
+        scope_def: ScopeDef,
+    ) -> bool {
         if let (Some(attrs), Some(krate)) = (scope_def.attrs(self.db), scope_def.krate(self.db)) {
             return self.is_doc_hidden(&attrs, krate);
         }
-
         false
     }
 
         if !self.check_stability(Some(attrs)) {
             return Visible::No;
         }
-
         if !vis.is_visible_from(self.db, self.module.into()) {
             if !self.config.enable_private_editable {
                 return Visible::No;
                 Visible::No
             };
         }
-
-        if self.is_doc_hidden(attrs, defining_crate) {
-            Visible::No
-        } else {
-            Visible::Yes
-        }
+        if self.is_doc_hidden(attrs, defining_crate) { Visible::No } else { Visible::Yes }
     }
 
-    pub(crate) fn is_doc_hidden(&self, attrs: &hir::Attrs, defining_crate: hir::Crate) -> bool {
+    pub(crate) fn is_doc_hidden(
+        &self,
+        attrs: &hir::Attrs,
+        defining_crate: hir::Crate,
+    ) -> bool {
         // `doc(hidden)` items are only completed within the defining crate.
         self.krate != defining_crate && attrs.has_doc_hidden()
     }
 
-    pub(crate) fn doc_aliases_in_scope(&self, scope_def: ScopeDef) -> Vec<SmolStr> {
+    pub(crate) fn doc_aliases_in_scope(
+        &self,
+        scope_def: ScopeDef,
+    ) -> Vec<SmolStr> {
         if let Some(attrs) = scope_def.attrs(self.db) {
             attrs.doc_aliases().map(|it| it.as_str().into()).collect()
         } else {
     }
 }
 
-// CompletionContext construction
 impl<'db> CompletionContext<'db> {
     pub(crate) fn new(
         db: &'db RootDatabase,
     ) -> Option<(CompletionContext<'db>, CompletionAnalysis<'db>)> {
         let _p = tracing::info_span!("CompletionContext::new").entered();
         let sema = Semantics::new(db);
-
         let editioned_file_id = sema.attach_first_edition(file_id)?;
         let original_file = sema.parse(editioned_file_id);
-
         // Insert a fake ident to get a valid parse tree. We will use this file
         // to determine context, though the original_file will be used for
         // actual completion.
         let file_with_fake_ident = {
             let (_, edition) = editioned_file_id.unpack(db);
             let parse = db.parse(editioned_file_id);
-            parse
-                .reparse(TextRange::empty(offset), COMPLETION_MARKER, edition)
-                .tree()
+            parse.reparse(TextRange::empty(offset), COMPLETION_MARKER, edition).tree()
         };
-
         // always pick the token to the immediate left of the cursor, as that is what we are actually
         // completing on
-        let original_token = original_file
-            .syntax()
-            .token_at_offset(offset)
-            .left_biased()?;
-
+        let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;
         // try to skip completions on path with invalid colons
         // this approach works in normal path and inside token tree
         if original_token.kind() == T![:] {
                 return None;
             }
         }
-
         let AnalysisResult {
             analysis,
             expected: (expected_type, expected_name),
             offset,
             &original_token,
         )?;
-
         // adjust for macro input, this still fails if there is no token written yet
         let scope = sema.scope_at_offset(&token.parent()?, original_offset)?;
-
         let krate = scope.krate();
         let module = scope.module();
         let containing_function = scope.containing_function();
         let edition = krate.edition(db);
-
         let toolchain = db.toolchain_channel(krate.into());
         // `toolchain == None` means we're in some detached files. Since we have no information on
         // the toolchain being used, let's just allow unstable items to be listed.
         let is_nightly = matches!(toolchain, Some(base_db::ReleaseChannel::Nightly) | None);
-
         let mut locals = FxHashMap::default();
         scope.process_all_names(&mut |name, scope| {
             if let ScopeDef::Local(local) = scope {
                 locals.insert(name, local);
             }
         });
-
         let depth_from_crate_root = iter::successors(Some(module), |m| m.parent(db))
             // `BlockExpr` modules do not count towards module depth
             .filter(|m| !matches!(m.definition_source(db).value, ModuleSource::BlockExpr(_)))
             .count()
             // exclude `m` itself
             .saturating_sub(1);
-
         let exclude_traits: FxHashSet<_> = config
             .exclude_traits
             .iter()
                 )
             })
             .collect();
-
         let mut exclude_flyimport: FxHashMap<_, _> = config
             .exclude_flyimport
             .iter()
                     .map(|it| (it.into_module_def(), *kind))
             })
             .collect();
-        exclude_flyimport.extend(
-            exclude_traits
-                .iter()
-                .map(|&t| (t.into(), AutoImportExclusionType::Always)),
-        );
-
+        exclude_flyimport
+            .extend(exclude_traits.iter().map(|&t| (t.into(), AutoImportExclusionType::Always)));
         // FIXME: This should be part of `CompletionAnalysis` / `expand_and_analyze`
         let complete_semicolon = if config.add_semicolon_to_unit {
             let inside_closure_ret = token.parent_ancestors().try_for_each(|ancestor| {
         } else {
             CompleteSemicolon::DoNotComplete
         };
-
         let display_target = krate.to_display_target(db);
         let ctx = CompletionContext {
             sema,