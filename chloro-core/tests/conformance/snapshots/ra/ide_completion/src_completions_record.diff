COMPARISON DIFF
============================================================

Original size: 11037 bytes
Chloro size:   10751 bytes
Rustfmt size:  11348 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Complete fields in record literals and patterns.
+
 use ide_db::SymbolKind;
 use syntax::{
     ast::{self, Expr},
     ctx: &CompletionContext<'_>,
     pattern_ctx: &PatternContext,
 ) {
-    if let PatternContext {
-        record_pat: Some(record_pat),
-        ..
-    } = pattern_ctx
-    {
-        let ty = ctx
-            .sema
-            .type_of_pat(&ast::Pat::RecordPat(record_pat.clone()));
+    if let PatternContext { record_pat: Some(record_pat), .. } = pattern_ctx {
+        let ty = ctx.sema.type_of_pat(&ast::Pat::RecordPat(record_pat.clone()));
         let missing_fields = match ty.as_ref().and_then(|t| t.original.as_adt()) {
             Some(hir::Adt::Union(un)) => {
                 // ctx.sema.record_pat_missing_fields will always return
                 // an empty Vec on a union literal. This is normally
                 // reasonable, but here we'd like to present the full list
                 // of fields if the literal is empty.
-                let were_fields_specified = record_pat
-                    .record_pat_field_list()
-                    .and_then(|fl| fl.fields().next())
-                    .is_some();
+                let were_fields_specified =
+                    record_pat.record_pat_field_list().and_then(|fl| fl.fields().next()).is_some();
 
                 match were_fields_specified {
                     false => un
     record_expr: &ast::RecordExpr,
     &dot_prefix: &bool,
 ) {
-    let ty = ctx
-        .sema
-        .type_of_expr(&Expr::RecordExpr(record_expr.clone()));
+    let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));
 
     let missing_fields = match ty.as_ref().and_then(|t| t.original.as_adt()) {
         Some(hir::Adt::Union(un)) => {
             // an empty Vec on a union literal. This is normally
             // reasonable, but here we'd like to present the full list
             // of fields if the literal is empty.
-            let were_fields_specified = record_expr
-                .record_expr_field_list()
-                .and_then(|fl| fl.fields().next())
-                .is_some();
+            let were_fields_specified =
+                record_expr.record_expr_field_list().and_then(|fl| fl.fields().next()).is_some();
 
             match were_fields_specified {
                 false => un
         .zip(ty.as_ref())
         .is_some_and(|(default_trait, ty)| ty.original.impls_trait(ctx.db, default_trait, &[]));
     if impls_default_trait {
-        // FIXME: This should make use of scope_def like completions so we get all the other goodies
-        // that is we should handle this like actually completing the default function
         let completion_text = "..Default::default()";
         let mut item = CompletionItem::new(
             SymbolKind::Field,
             SmolStr::new_static(completion_text),
             ctx.edition,
         );
-        let completion_text = completion_text
-            .strip_prefix(ctx.token.text())
-            .unwrap_or(completion_text);
-        item.insert_text(completion_text)
-            .set_relevance(CompletionRelevance {
-                postfix_match: Some(CompletionRelevancePostfixMatch::Exact),
-                ..Default::default()
-            });
+        let completion_text =
+            completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);
+        item.insert_text(completion_text).set_relevance(CompletionRelevance {
+            postfix_match: Some(CompletionRelevancePostfixMatch::Exact),
+            ..Default::default()
+        });
         item.add_to(acc, ctx.db);
     }
 }
     missing_fields: Vec<(hir::Field, hir::Type<'_>)>,
 ) {
     for (field, ty) in missing_fields {
-        // This should call something else, we shouldn't be synthesizing a DotAccess here
         acc.add_field(
             ctx,
             &DotAccess {
                 receiver: None,
                 receiver_ty: None,
-                kind: DotAccessKind::Field {
-                    receiver_is_ambiguous_float_literal: false,
-                },
-                ctx: DotAccessExprCtx {
-                    in_block_expr: false,
-                    in_breakable: None,
-                },
+                kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal: false },
+                ctx: DotAccessExprCtx { in_block_expr: false, in_breakable: None },
             },
             None,
             field,
 #[cfg(test)]
 mod tests {
     use ide_db::SnippetCap;
-
     use crate::{
         tests::{check_edit, check_edit_with_config, TEST_CONFIG},
         CompletionConfig,
     };
-
     #[test]
     fn literal_struct_completion_edit() {
         check_edit(
             "#,
         )
     }
-
     #[test]
     fn literal_struct_completion_shorthand() {
         check_edit(
             "#,
         )
     }
-
     #[test]
     fn enum_variant_no_snippets() {
-        let conf = CompletionConfig {
-            snippet_cap: SnippetCap::new(false),
-            ..TEST_CONFIG
-        };
+        let conf = CompletionConfig { snippet_cap: SnippetCap::new(false), ..TEST_CONFIG };
         // tuple variant
         check_edit_with_config(
             conf.clone(),
 "#,
         )
     }
-
     #[test]
     fn literal_struct_impl_self_completion() {
         check_edit(
             "#,
         )
     }
-
     #[test]
     fn literal_struct_completion_from_sub_modules() {
         check_edit(
             "#,
         )
     }
-
     #[test]
     fn literal_struct_complexion_module() {
         check_edit(
             "#,
         );
     }
-
     #[test]
     fn default_completion_edit() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn callable_field_struct_init() {
         check_edit(