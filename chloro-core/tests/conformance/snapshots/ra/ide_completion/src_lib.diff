COMPARISON DIFF
============================================================

Original size: 11494 bytes
Chloro size:   11556 bytes
Rustfmt size:  11494 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 mod context;
 mod item;
 mod render;
-
 mod snippet;
 #[cfg(test)]
 mod tests;
 
 use ide_db::{
-    FilePosition, FxHashSet, RootDatabase,
     imports::insert_use::{self, ImportScope},
     syntax_helpers::tree_diff::diff,
     text_edit::TextEdit,
+    FilePosition, FxHashSet, RootDatabase,
 };
 use syntax::ast::make;
 
         PathKind,
     },
 };
-
 pub use crate::{
     config::{AutoImportExclusionType, CallableSnippets, CompletionConfig},
     item::{
 //FIXME: split the following feature into fine-grained features.
 
 // Feature: Magic Completions
-//
-// In addition to usual reference completion, rust-analyzer provides some ✨magic✨
-// completions as well:
-//
-// Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor
-// is placed at the appropriate position. Even though `if` is easy to type, you
-// still want to complete it, to get ` { }` for free! `return` is inserted with a
-// space or `;` depending on the return type of the function.
-//
-// When completing a function call, `()` are automatically inserted. If a function
-// takes arguments, the cursor is positioned inside the parenthesis.
-//
-// There are postfix completions, which can be triggered by typing something like
-// `foo().if`. The word after `.` determines postfix completion. Possible variants are:
-//
-// - `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`
-// - `expr.match` -> `match expr {}`
-// - `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`
-// - `expr.ref` -> `&expr`
-// - `expr.refm` -> `&mut expr`
-// - `expr.let` -> `let $0 = expr;`
-// - `expr.lete` -> `let $1 = expr else { $0 };`
-// - `expr.letm` -> `let mut $0 = expr;`
-// - `expr.not` -> `!expr`
-// - `expr.dbg` -> `dbg!(expr)`
-// - `expr.dbgr` -> `dbg!(&expr)`
-// - `expr.call` -> `(expr)`
-//
-// There also snippet completions:
-//
-// #### Expressions
-//
-// - `pd` -> `eprintln!(" = {:?}", );`
-// - `ppd` -> `eprintln!(" = {:#?}", );`
-//
-// #### Items
-//
-// - `tfn` -> `#[test] fn feature(){}`
-// - `tmod` ->
-// ```rust
-// #[cfg(test)]
-// mod tests {
-//     use super::*;
-//
-//     #[test]
-//     fn test_name() {}
-// }
-// ```
-//
-// And the auto import completions, enabled with the `rust-analyzer.completion.autoimport.enable` setting and the corresponding LSP client capabilities.
-// Those are the additional completion options with automatic `use` import and options from all project importable items,
-// fuzzy matched against the completion input.
-//
-// ![Magic Completions](https://user-images.githubusercontent.com/48062697/113020667-b72ab880-917a-11eb-8778-716cf26a0eb3.gif)
 
+//
+
+// In addition to usual reference completion, rust-analyzer provides some ✨magic✨
+
+// completions as well:
+
+//
+
+// Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor
+
+// is placed at the appropriate position. Even though `if` is easy to type, you
+
+// still want to complete it, to get ` { }` for free! `return` is inserted with a
+
+// space or `;` depending on the return type of the function.
+
+//
+
+// When completing a function call, `()` are automatically inserted. If a function
+
+// takes arguments, the cursor is positioned inside the parenthesis.
+
+//
+
+// There are postfix completions, which can be triggered by typing something like
+
+// `foo().if`. The word after `.` determines postfix completion. Possible variants are:
+
+//
+
+// - `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`
+
+// - `expr.match` -> `match expr {}`
+
+// - `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`
+
+// - `expr.ref` -> `&expr`
+
+// - `expr.refm` -> `&mut expr`
+
+// - `expr.let` -> `let $0 = expr;`
+
+// - `expr.lete` -> `let $1 = expr else { $0 };`
+
+// - `expr.letm` -> `let mut $0 = expr;`
+
+// - `expr.not` -> `!expr`
+
+// - `expr.dbg` -> `dbg!(expr)`
+
+// - `expr.dbgr` -> `dbg!(&expr)`
+
+// - `expr.call` -> `(expr)`
+
+//
+
+// There also snippet completions:
+
+//
+
+// #### Expressions
+
+//
+
+// - `pd` -> `eprintln!(" = {:?}", );`
+
+// - `ppd` -> `eprintln!(" = {:#?}", );`
+
+//
+
+// #### Items
+
+//
+
+// - `tfn` -> `#[test] fn feature(){}`
+
+// - `tmod` ->
+
+// ```rust
+
+// #[cfg(test)]
+
+// mod tests {
+
+//     use super::*;
+
+//
+
+//     #[test]
+
+//     fn test_name() {}
+
+// }
+
+// ```
+
+//
+
+// And the auto import completions, enabled with the `rust-analyzer.completion.autoimport.enable` setting and the corresponding LSP client capabilities.
+
+// Those are the additional completion options with automatic `use` import and options from all project importable items,
+
+// fuzzy matched against the completion input.
+
+//
+
+// ![Magic Completions](https://user-images.githubusercontent.com/48062697/113020667-b72ab880-917a-11eb-8778-716cf26a0eb3.gif)
 /// Main entry point for completion. We run completion as a two-phase process.
 ///
 /// First, we look at the position and collect a so-called `CompletionContext`.
     }
 
     // when the user types a bare `_` (that is it does not belong to an identifier)
+
     // the user might just wanted to type a `_` for type inference or pattern discarding
+
     // so try to suppress completions in those cases
     if trigger_character == Some('_')
         && ctx.original_token.kind() == syntax::SyntaxKind::UNDERSCORE
     let new_ast = scope.clone_for_update();
     let mut import_insert = TextEdit::builder();
 
-    imports.into_iter().for_each(|full_import_path| {
+    imports.into_iter()
+        .for_each(|full_import_path| {
         insert_use::insert_use(
             &new_ast,
             make::path_from_text_with_edition(&full_import_path, current_edition),