COMPARISON DIFF
============================================================

Original size: 27860 bytes
Chloro size:   27829 bytes
Rustfmt size:  27860 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::Mutability;
 use ide_db::text_edit::TextEdit;
 use ide_db::{
-    RootDatabase, SnippetCap, SymbolKind, documentation::Documentation,
+    documentation::Documentation,
     imports::import_assets::LocatedImport,
+    RootDatabase, SnippetCap, SymbolKind,
 };
 use itertools::Itertools;
 use macros::UpmapFromRaFixture;
 pub struct CompletionItem {
     /// Label in the completion pop up which identifies completion.
     pub label: CompletionItemLabel,
-
     /// Range of identifier that is being completed.
     ///
     /// It should be used primarily for UI, but we also use this to convert
     /// Typically, replaces `source_range` with new identifier.
     pub text_edit: TextEdit,
     pub is_snippet: bool,
-
     /// What item (struct, function, etc) are we completing.
     pub kind: CompletionItemKind,
-
     /// Lookup is used to check if completion item indeed can complete current
     /// ident.
     ///
     /// That is, in `foo.bar$0` lookup of `abracadabra` will be accepted (it
     /// contains `bar` sub sequence), and `quux` will rejected.
     pub lookup: SmolStr,
-
     /// Additional info to show in the UI pop up.
     pub detail: Option<String>,
     pub documentation: Option<Documentation>,
-
     /// Whether this item is marked as deprecated
     pub deprecated: bool,
-
     /// If completing a function call, ask the editor to show parameter popup
     /// after completion.
     pub trigger_call_info: bool,
-
     /// We use this to sort completion. Relevance records facts like "do the
     /// types align precisely?". We can't sort by relevances directly, they are
     /// only partially ordered.
     /// all possible items, and then separately build an ordered completion list
     /// based on relevance and fuzzy matching with the already typed identifier.
     pub relevance: CompletionRelevance,
-
     /// Indicates that a reference or mutable reference to this variable is a
     /// possible match.
-    // FIXME: We shouldn't expose Mutability here (that is HIR types at all), its fine for now though
-    // until we have more splitting completions in which case we should think about
-    // generalizing this. See https://github.com/rust-lang/rust-analyzer/issues/12571
     pub ref_match: Option<(CompletionItemRefMode, TextSize)>,
-
     /// The import data to add to completion's edits.
     pub import_to_add: SmallVec<[String; 1]>,
 }
     /// The right detail for the completion item, usually rendered right aligned at the end of the completion item.
     pub detail_right: Option<String>,
 }
-// We use custom debug for CompletionItem to make snapshot tests more readable.
+
 impl fmt::Debug for CompletionItem {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         let mut s = f.debug_struct("CompletionItem");
         s.field("label", &self.label.primary)
             .field("detail_left", &self.label.detail_left)
         if self.deprecated {
             s.field("deprecated", &true);
         }
-
         if self.relevance != CompletionRelevance::default() {
             s.field("relevance", &self.relevance);
         }
-
         if let Some((ref_mode, offset)) = self.ref_match {
             let prefix = match ref_mode {
                 CompletionItemRefMode::Reference(mutability) => match mutability {
     /// true when there is an `await.method()` or `iter().method()` completion.
     pub is_skipping_completion: bool,
 }
+
 #[derive(Debug, Clone, Copy, Eq, PartialEq)]
 pub struct CompletionRelevanceTraitInfo {
     /// The trait this item is from is a `#[doc(notable_trait)]`
             function,
             is_skipping_completion,
         } = self;
-
         // only applicable for completions within use items
         // lower rank for conflicting import names
         if is_name_already_imported {
         if is_local {
             score += 1;
         }
-
         // lower rank private things
         if !is_private_editable {
             score += 1;
         }
-
         if let Some(trait_) = trait_ {
             // lower rank trait methods unless its notable
             if !trait_.notable_trait {
                 score -= 5;
             }
         }
-
         // Lower rank for completions that skip `await` and `iter()`.
         if is_skipping_completion {
             score -= 7;
         }
-
         // lower rank for items that need an import
         if requires_import {
             score -= 1;
 
             score += fn_score;
         };
-
         score
     }
 
     UnresolvedReference,
     Expression,
 }
-
-impl_from!(SymbolKind for CompletionItemKind);
-
 impl CompletionItemKind {
     pub fn tag(self) -> &'static str {
         match self {
         // is only set if there is an exact type match.
         let mut relevance = self.relevance;
         relevance.type_match = Some(CompletionRelevanceTypeMatch::Exact);
-
         self.ref_match.map(|(mode, offset)| {
             let prefix = match mode {
                 CompletionItemRefMode::Reference(Mutability::Shared) => "&",
         )
     }
 
-    pub(crate) fn build(self, db: &RootDatabase) -> CompletionItem {
+    pub(crate) fn build(
+        self,
+        db: &RootDatabase,
+    ) -> CompletionItem {
         let _p = tracing::info_span!("item::Builder::build").entered();
-
         let label = self.label;
         let mut lookup = self.lookup.unwrap_or_else(|| label.clone());
         let insert_text = self.insert_text.unwrap_or_else(|| label.to_string());
-
         let mut detail_left = None;
         if !self.doc_aliases.is_empty() {
             let doc_aliases = self.doc_aliases.iter().join(", ");
                 if detail_left.is_empty() { "" } else { " " },
             );
         }
-
         let text_edit = match self.text_edit {
             Some(it) => it,
             None => TextEdit::replace(self.source_range, insert_text),
         };
-
         let import_to_add = self
             .imports_to_add
             .into_iter()
             .map(|import| import.import_path.display(db, self.edition).to_string())
             .collect();
-
         CompletionItem {
             source_range: self.source_range,
             label: CompletionItemLabel {
             import_to_add,
         }
     }
-    pub(crate) fn lookup_by(&mut self, lookup: impl Into<SmolStr>) -> &mut Builder {
+
+    pub(crate) fn lookup_by(
+        &mut self,
+        lookup: impl Into<SmolStr>,
+    ) -> &mut Builder {
         self.lookup = Some(lookup.into());
         self
     }
-    pub(crate) fn label(&mut self, label: impl Into<SmolStr>) -> &mut Builder {
+
+    pub(crate) fn label(
+        &mut self,
+        label: impl Into<SmolStr>,
+    ) -> &mut Builder {
         self.label = label.into();
         self
     }
-    pub(crate) fn trait_name(&mut self, trait_name: SmolStr) -> &mut Builder {
+
+    pub(crate) fn trait_name(
+        &mut self,
+        trait_name: SmolStr,
+    ) -> &mut Builder {
         self.trait_name = Some(trait_name);
         self
     }
-    pub(crate) fn doc_aliases(&mut self, doc_aliases: Vec<SmolStr>) -> &mut Builder {
+
+    pub(crate) fn doc_aliases(
+        &mut self,
+        doc_aliases: Vec<SmolStr>,
+    ) -> &mut Builder {
         self.doc_aliases = doc_aliases;
         self
     }
-    pub(crate) fn insert_text(&mut self, insert_text: impl Into<String>) -> &mut Builder {
+
+    pub(crate) fn insert_text(
+        &mut self,
+        insert_text: impl Into<String>,
+    ) -> &mut Builder {
         self.insert_text = Some(insert_text.into());
         self
     }
+
     pub(crate) fn insert_snippet(
         &mut self,
         cap: SnippetCap,
         self.is_snippet = true;
         self.insert_text(snippet)
     }
-    pub(crate) fn text_edit(&mut self, edit: TextEdit) -> &mut Builder {
+
+    pub(crate) fn text_edit(
+        &mut self,
+        edit: TextEdit,
+    ) -> &mut Builder {
         self.text_edit = Some(edit);
         self
     }
-    pub(crate) fn snippet_edit(&mut self, _cap: SnippetCap, edit: TextEdit) -> &mut Builder {
+
+    pub(crate) fn snippet_edit(
+        &mut self,
+        _cap: SnippetCap,
+        edit: TextEdit,
+    ) -> &mut Builder {
         self.is_snippet = true;
         self.text_edit(edit)
     }
-    pub(crate) fn detail(&mut self, detail: impl Into<String>) -> &mut Builder {
+
+    pub(crate) fn detail(
+        &mut self,
+        detail: impl Into<String>,
+    ) -> &mut Builder {
         self.set_detail(Some(detail))
     }
-    pub(crate) fn set_detail(&mut self, detail: Option<impl Into<String>>) -> &mut Builder {
+
+    pub(crate) fn set_detail(
+        &mut self,
+        detail: Option<impl Into<String>>,
+    ) -> &mut Builder {
         self.detail = detail.map(Into::into);
         if let Some(detail) = &self.detail
             && never!(detail.contains('\n'), "multiline detail:\n{}", detail)
         }
         self
     }
+
     #[allow(unused)]
-    pub(crate) fn documentation(&mut self, docs: Documentation) -> &mut Builder {
+    pub(crate) fn documentation(
+        &mut self,
+        docs: Documentation,
+    ) -> &mut Builder {
         self.set_documentation(Some(docs))
     }
-    pub(crate) fn set_documentation(&mut self, docs: Option<Documentation>) -> &mut Builder {
+
+    pub(crate) fn set_documentation(
+        &mut self,
+        docs: Option<Documentation>,
+    ) -> &mut Builder {
         self.documentation = docs;
         self
     }
-    pub(crate) fn set_deprecated(&mut self, deprecated: bool) -> &mut Builder {
+
+    pub(crate) fn set_deprecated(
+        &mut self,
+        deprecated: bool,
+    ) -> &mut Builder {
         self.deprecated = deprecated;
         self
     }
-    pub(crate) fn set_relevance(&mut self, relevance: CompletionRelevance) -> &mut Builder {
+
+    pub(crate) fn set_relevance(
+        &mut self,
+        relevance: CompletionRelevance,
+    ) -> &mut Builder {
         self.relevance = relevance;
         self
     }
+
     pub(crate) fn with_relevance(
         &mut self,
         relevance: impl FnOnce(CompletionRelevance) -> CompletionRelevance,
         self.relevance = relevance(mem::take(&mut self.relevance));
         self
     }
+
     pub(crate) fn trigger_call_info(&mut self) -> &mut Builder {
         self.trigger_call_info = true;
         self
     }
-    pub(crate) fn add_import(&mut self, import_to_add: LocatedImport) -> &mut Builder {
+
+    pub(crate) fn add_import(
+        &mut self,
+        import_to_add: LocatedImport,
+    ) -> &mut Builder {
         self.imports_to_add.push(import_to_add);
         self
     }
+
     pub(crate) fn ref_match(
         &mut self,
         ref_mode: CompletionItemRefMode,
 mod tests {
     use itertools::Itertools;
     use test_utils::assert_eq_text;
-
     use super::{
         CompletionRelevance, CompletionRelevancePostfixMatch, CompletionRelevanceTypeMatch,
     };
-
     /// Check that these are CompletionRelevance are sorted in ascending order
     /// by their relevance score.
     ///
     ///     a.score < b.score == c.score < d.score
     fn check_relevance_score_ordered(expected_relevance_order: Vec<Vec<CompletionRelevance>>) {
         let expected = format!("{expected_relevance_order:#?}");
-
         let actual_relevance_order = expected_relevance_order
             .into_iter()
             .flatten()
                 },
             )
             .1;
-
         let actual = format!("{actual_relevance_order:#?}");
-
         assert_eq_text!(&expected, &actual);
     }
-
     #[test]
     fn relevance_score() {
         use CompletionRelevance as Cr;
             }],
             vec![Cr { postfix_match: Some(CompletionRelevancePostfixMatch::Exact), ..default }],
         ];
-
         check_relevance_score_ordered(expected_relevance_order);
     }
 }