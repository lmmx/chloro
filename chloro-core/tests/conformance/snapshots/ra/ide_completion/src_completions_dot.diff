COMPARISON DIFF
============================================================

Original size: 35861 bytes
Chloro size:   35785 bytes
Rustfmt size:  36179 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     dot_access: &DotAccess<'_>,
 ) {
     let receiver_ty = match dot_access {
-        DotAccess {
-            receiver_ty: Some(receiver_ty),
-            ..
-        } => &receiver_ty.original,
+        DotAccess { receiver_ty: Some(receiver_ty), .. } => &receiver_ty.original,
         _ => return,
     };
 
         if ctx.config.enable_auto_await {
             // Completions that skip `.await`, e.g. `.await.foo()`.
             let dot_access_kind = match &dot_access.kind {
-                DotAccessKind::Field {
-                    receiver_is_ambiguous_float_literal: _,
-                } => DotAccessKind::Field {
-                    receiver_is_ambiguous_float_literal: false,
-                },
+                DotAccessKind::Field { receiver_is_ambiguous_float_literal: _ } => {
+                    DotAccessKind::Field { receiver_is_ambiguous_float_literal: false }
+                }
                 it @ DotAccessKind::Method => *it,
             };
             let dot_access = DotAccess {
         if let Some((iter, iter_sym)) = iter.or_else(into_iter) {
             // Skip iterators, e.g. complete `.iter().filter_map()`.
             let dot_access_kind = match &dot_access.kind {
-                DotAccessKind::Field {
-                    receiver_is_ambiguous_float_literal: _,
-                } => DotAccessKind::Field {
-                    receiver_is_ambiguous_float_literal: false,
-                },
+                DotAccessKind::Field { receiver_is_ambiguous_float_literal: _ } => {
+                    DotAccessKind::Field { receiver_is_ambiguous_float_literal: false }
+                }
                 it @ DotAccessKind::Method => *it,
             };
             let dot_access = DotAccess {
                 receiver: dot_access.receiver.clone(),
-                receiver_ty: Some(hir::TypeInfo {
-                    original: iter.clone(),
-                    adjusted: None,
-                }),
+                receiver_ty: Some(hir::TypeInfo { original: iter.clone(), adjusted: None }),
                 kind: dot_access_kind,
                 ctx: dot_access.ctx,
             };
         return;
     }
     let self_param = match expr_ctx {
-        PathExprCtx {
-            self_param: Some(self_param),
-            ..
-        } => self_param,
+        PathExprCtx { self_param: Some(self_param), .. } => self_param,
         _ => return,
     };
 
                 &DotAccess {
                     receiver: None,
                     receiver_ty: None,
-                    kind: DotAccessKind::Field {
-                        receiver_is_ambiguous_float_literal: false,
-                    },
+                    kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal: false },
                     ctx: DotAccessExprCtx {
                         in_block_expr: expr_ctx.in_block_expr,
                         in_breakable: expr_ctx.in_breakable,
             &DotAccess {
                 receiver: None,
                 receiver_ty: None,
-                kind: DotAccessKind::Field {
-                    receiver_is_ambiguous_float_literal: false,
-                },
+                kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal: false },
                 ctx: DotAccessExprCtx {
                     in_block_expr: expr_ctx.in_block_expr,
                     in_breakable: expr_ctx.in_breakable,
         for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {
             // Tuples are always the last type in a deref chain, so just check if the name is
             // already seen without inserting into the hashset.
-            if !seen_names.contains(&hir::Name::new_tuple_field(i))
-                && (!has_parens || ty.is_fn() || ty.is_closure())
-            {
+            if !seen_names.contains(&hir::Name::new_tuple_field(i)) && (!has_parens || ty.is_fn() || ty.is_closure()) {
                 // Tuple fields are always public (tuple struct fields are handled above).
                 tuple_index(acc, i, ty);
             }
         traits_in_scope,
         Some(ctx.module),
         None,
-        Callback {
-            ctx,
-            f,
-            seen_methods: FxHashSet::default(),
-        },
+        Callback { ctx, f, seen_methods: FxHashSet::default() },
     );
 }
 
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::tests::{check_edit, check_no_kw, check_with_private_editable};
-
     #[test]
     fn test_struct_field_and_method_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn no_unstable_method_on_stable() {
         check_no_kw(
             expect![""],
         );
     }
-
     #[test]
     fn unstable_method_on_nightly() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_field_completion_self() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn test_struct_field_completion_autoderef() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn test_no_struct_field_completion_for_method_call() {
         check_no_kw(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn test_visibility_filtering() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_visibility_filtering_with_private_editable_enabled() {
         check_with_private_editable(
             "#]],
         );
     }
-
     #[test]
     fn test_local_impls() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_doc_hidden_filtering() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn test_union_field_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_method_completion_only_fitting_impls() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn test_trait_method_completion() {
         check_no_kw(
 "#,
         );
     }
-
     #[test]
     fn test_trait_method_completion_deduplicated() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn completes_trait_method_from_other_module() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_no_non_self_method() {
         check_no_kw(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn test_tuple_field_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_struct_field_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_field_inference() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_field_no_same_name() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_field_no_same_index() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_struct_deref_to_tuple_no_same_index() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_completion_works_in_consts() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn works_in_simple_macro_1() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn works_in_simple_macro_2() {
         // this doesn't work yet because the macro doesn't expand without the token -- maybe it can be fixed with better recovery
             "#]],
         );
     }
-
     #[test]
     fn works_in_simple_macro_recursive_1() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn macro_expansion_resilient() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_method_completion_issue_3547() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn completes_method_call_when_receiver_is_a_macro_call() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn completes_after_macro_call_in_submodule() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn issue_8931() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn completes_bare_fields_and_methods_in_methods() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn macro_completion_after_dot() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn completes_method_call_when_receiver_type_has_errors_issue_10297() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn postfix_drop_completion() {
         cov_mark::check!(postfix_drop_completion);
 ",
         )
     }
-
     #[test]
     fn issue_12484() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn only_consider_same_type_once() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn no_inference_var_in_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn assoc_impl_1() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn assoc_impl_2() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_function_field_completion() {
         check_no_kw(
 "#,
         );
     }
-
     #[test]
     fn test_tuple_function_field_completion() {
         check_no_kw(
 "#,
         )
     }
-
     #[test]
     fn test_fn_field_dot_access_method_has_parens_false() {
         check_no_kw(
 "#,
         );
     }
-
     #[test]
     fn skip_iter() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn skip_await() {
         check_no_kw(
 "#,
         );
     }
-
     #[test]
     fn receiver_without_deref_impl_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn no_iter_suggestion_on_iterator() {
         check_no_kw(