COMPARISON DIFF
============================================================

Original size: 35861 bytes
Chloro size:   35785 bytes
Rustfmt size:  35861 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::SmolStr;
 
 use crate::{
-    CompletionItem, CompletionItemKind, Completions,
     context::{
         CompletionContext, DotAccess, DotAccessExprCtx, DotAccessKind, PathCompletionCtx,
         PathExprCtx, Qualified,
     },
+    CompletionItem, CompletionItemKind, Completions,
 };
 
 /// Complete dot accesses, i.e. fields or methods.
         // Checking for the existence of `iter()` is complicated in our setup, because we need to substitute
         // its return type, so we instead check for `<&Self as IntoIterator>::IntoIter`.
         // Does <&receiver_ty as IntoIterator>::IntoIter` exist? Assume `iter` is valid
+        // Does <receiver_ty as IntoIterator>::IntoIter` exist?
         let iter = receiver_ty
             .strip_references()
             .add_reference(hir::Mutability::Shared)
             .into_iterator_iter(ctx.db)
             .map(|ty| (ty, SmolStr::new_static("iter()")));
-        // Does <receiver_ty as IntoIterator>::IntoIter` exist?
         let into_iter = || {
             receiver_ty
                 .clone()
         for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {
             // Tuples are always the last type in a deref chain, so just check if the name is
             // already seen without inserting into the hashset.
-            if !seen_names.contains(&hir::Name::new_tuple_field(i))
-                && (!has_parens || ty.is_fn() || ty.is_closure())
-            {
+            if !seen_names.contains(&hir::Name::new_tuple_field(i)) && (!has_parens || ty.is_fn() || ty.is_closure()) {
                 // Tuple fields are always public (tuple struct fields are handled above).
                 tuple_index(acc, i, ty);
             }
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::tests::{check_edit, check_no_kw, check_with_private_editable};
-
     #[test]
     fn test_struct_field_and_method_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn no_unstable_method_on_stable() {
         check_no_kw(
             expect![""],
         );
     }
-
     #[test]
     fn unstable_method_on_nightly() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_field_completion_self() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn test_struct_field_completion_autoderef() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn test_no_struct_field_completion_for_method_call() {
         check_no_kw(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn test_visibility_filtering() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_visibility_filtering_with_private_editable_enabled() {
         check_with_private_editable(
             "#]],
         );
     }
-
     #[test]
     fn test_local_impls() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_doc_hidden_filtering() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn test_union_field_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_method_completion_only_fitting_impls() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn test_trait_method_completion() {
         check_no_kw(
 "#,
         );
     }
-
     #[test]
     fn test_trait_method_completion_deduplicated() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn completes_trait_method_from_other_module() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_no_non_self_method() {
         check_no_kw(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn test_tuple_field_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_struct_field_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_field_inference() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_field_no_same_name() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_field_no_same_index() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_tuple_struct_deref_to_tuple_no_same_index() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_completion_works_in_consts() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn works_in_simple_macro_1() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn works_in_simple_macro_2() {
         // this doesn't work yet because the macro doesn't expand without the token -- maybe it can be fixed with better recovery
             "#]],
         );
     }
-
     #[test]
     fn works_in_simple_macro_recursive_1() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn macro_expansion_resilient() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_method_completion_issue_3547() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn completes_method_call_when_receiver_is_a_macro_call() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn completes_after_macro_call_in_submodule() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn issue_8931() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn completes_bare_fields_and_methods_in_methods() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn macro_completion_after_dot() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn completes_method_call_when_receiver_type_has_errors_issue_10297() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn postfix_drop_completion() {
         cov_mark::check!(postfix_drop_completion);
 ",
         )
     }
-
     #[test]
     fn issue_12484() {
         check_no_kw(
             "#]],
         )
     }
-
     #[test]
     fn only_consider_same_type_once() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn no_inference_var_in_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn assoc_impl_1() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn assoc_impl_2() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn test_struct_function_field_completion() {
         check_no_kw(
 "#,
         );
     }
-
     #[test]
     fn test_tuple_function_field_completion() {
         check_no_kw(
 "#,
         )
     }
-
     #[test]
     fn test_fn_field_dot_access_method_has_parens_false() {
         check_no_kw(
 "#,
         );
     }
-
     #[test]
     fn skip_iter() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn skip_await() {
         check_no_kw(
 "#,
         );
     }
-
     #[test]
     fn receiver_without_deref_impl_completion() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn no_iter_suggestion_on_iterator() {
         check_no_kw(