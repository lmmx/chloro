COMPARISON DIFF
============================================================

Original size: 11756 bytes
Chloro size:   11587 bytes
Rustfmt size:  11841 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
     // filter out all but one built-in type completion for smaller test outputs
     let items = get_all_items(config, ra_fixture, trigger_character);
-    items
-        .into_iter()
-        .filter(|it| it.kind != CompletionItemKind::BuiltinType || it.label.primary == "u32")
-        .filter(|it| include_keywords || it.kind != CompletionItemKind::Keyword)
-        .filter(|it| include_keywords || it.kind != CompletionItemKind::Snippet)
-        .sorted_by_key(|it| {
-            (
-                it.kind,
-                it.label.primary.clone(),
-                it.label.detail_left.as_ref().map(ToOwned::to_owned),
-            )
-        })
-        .collect()
+    items.into_iter().filter(
+        |it| it.kind != CompletionItemKind::BuiltinType || it.label.primary == "u32",
+    ).filter(
+        |it| include_keywords || it.kind != CompletionItemKind::Keyword,
+    ).filter(
+        |it| include_keywords || it.kind != CompletionItemKind::Snippet,
+    ).sorted_by_key(|it| {
+        (it.kind, it.label.primary.clone(), it.label.detail_left.as_ref().map(ToOwned::to_owned))
+    }).collect(
+    )
 }
 
 fn completion_list_with_config(
     include_keywords: bool,
     trigger_character: Option<char>,
 ) -> String {
-    render_completion_list(completion_list_with_config_raw(
-        config,
-        ra_fixture,
-        include_keywords,
-        trigger_character,
-    ))
+    render_completion_list(
+        completion_list_with_config_raw(config, ra_fixture, include_keywords, trigger_character),
+    )
 }
 
 /// Creates analysis from a multi-file fixture, returns positions marked with $0.
     let change_fixture = ChangeFixture::parse(&database, ra_fixture);
     database.enable_proc_attr_macros();
     database.apply_change(change_fixture.change);
-    let (file_id, range_or_offset) = change_fixture
-        .file_position
-        .expect("expected a marker ($0)");
+    let (file_id, range_or_offset) = change_fixture.file_position.expect("expected a marker ($0)");
     let offset = range_or_offset.expect_offset();
-    let position = FilePosition {
-        file_id: file_id.file_id(&database),
-        offset,
-    };
+    let position = FilePosition { file_id: file_id.file_id(&database), offset };
     (database, position)
 }
 
     code: &str,
     kind: CompletionItemKind,
 ) -> Vec<CompletionItem> {
-    get_all_items(config, code, None)
-        .into_iter()
-        .filter(|c| c.kind == kind)
-        .sorted_by(|l, r| l.label.cmp(&r.label))
-        .collect()
+    get_all_items(config, code, None).into_iter().filter(|c| c.kind == kind).sorted_by(
+        |l, r| l.label.cmp(&r.label),
+    ).collect(
+    )
 }
 
 fn render_completion_list(completions: Vec<CompletionItem>) -> String {
         })
         .max()
         .unwrap_or_default();
-    completions
-        .into_iter()
-        .map(|it| {
-            let tag = it.kind.tag();
-            let mut buf = format!("{tag} {}", it.label.primary);
-            if let Some(label_detail) = &it.label.detail_left {
+    completions.into_iter().map(|it| {
+        let tag = it.kind.tag();
+        let mut buf = format!("{tag} {}", it.label.primary);
+        if let Some(label_detail) = &it.label.detail_left {
                 format_to!(buf, " {label_detail}");
             }
-            if let Some(detail_right) = it.label.detail_right {
+        if let Some(detail_right) = it.label.detail_right {
                 let pad_with = label_width.saturating_sub(
                     monospace_width(&it.label.primary)
                         + monospace_width(it.label.detail_left.as_deref().unwrap_or_default())
                 );
                 format_to!(buf, "{:pad_with$}{detail_right}", "",);
             }
-            if it.deprecated {
+        if it.deprecated {
                 format_to!(buf, " DEPRECATED");
             }
-            format_to!(buf, "\n");
-            buf
-        })
-        .collect()
+        format_to!(buf, "\n");
+        buf
+    }).collect(
+    )
 }
 
 #[track_caller]
 ) {
     let ra_fixture_after = trim_indent(ra_fixture_after);
     let (db, position) = position(ra_fixture_before);
-    let completions: Vec<CompletionItem> = hir::attach_db(&db, || {
-        crate::completions(&db, &config, position, None).unwrap()
-    });
-    let Some((completion,)) = completions
-        .iter()
-        .filter(|it| it.lookup() == what)
-        .collect_tuple()
+    let completions: Vec<CompletionItem> =
+        hir::attach_db(&db, || crate::completions(&db, &config, position, None).unwrap());
+    let Some((completion,)) = completions.iter().filter(|it| it.lookup() == what).collect_tuple()
     else {
         panic!("can't find {what:?} completion in {completions:#?}")
     };
 
     let mut combined_edit = completion.text_edit.clone();
 
-    resolve_completion_edits(
-        &db,
-        &config,
-        position,
-        completion.import_to_add.iter().cloned(),
-    )
-    .into_iter()
-    .flatten()
-    .for_each(|text_edit| {
-        combined_edit.union(text_edit).expect(
-            "Failed to apply completion resolve changes: change ranges overlap, but should not",
-        )
-    });
+    resolve_completion_edits(&db, &config, position, completion.import_to_add.iter().cloned())
+        .into_iter()
+        .flatten()
+        .for_each(|text_edit| {
+            combined_edit.union(text_edit).expect(
+                "Failed to apply completion resolve changes: change ranges overlap, but should not",
+            )
+        });
 
     combined_edit.apply(&mut actual);
     assert_eq_text!(&ra_fixture_after, &actual)