COMPARISON DIFF
============================================================

Original size: 6052 bytes
Chloro size:   6053 bytes
Rustfmt size:  6074 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Completion of paths and keywords at item list position.
 
 use crate::{
-    context::{ItemListKind, PathCompletionCtx, PathExprCtx, Qualified},
     CompletionContext, Completions,
+    context::{ItemListKind, PathCompletionCtx, PathExprCtx, Qualified},
 };
 
 pub(crate) mod trait_impl;
     let _p = tracing::info_span!("complete_item_list").entered();
 
     // We handle completions for trait-impls in [`item_list::trait_impl`]
+
     if path_ctx.is_trivial_path() && !matches!(kind, ItemListKind::TraitImpl(_)) {
         add_keywords(acc, ctx, Some(kind));
     }
                     _ => (),
                 }
             }
-
             acc.add_super_keyword(ctx, *super_chain_len);
         }
         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),
 fn add_keywords(acc: &mut Completions, ctx: &CompletionContext<'_>, kind: Option<&ItemListKind>) {
     let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);
 
-    let in_item_list = matches!(
-        kind,
-        Some(ItemListKind::SourceFile | ItemListKind::Module) | None
-    );
+    let in_item_list = matches!(kind, Some(ItemListKind::SourceFile | ItemListKind::Module) | None);
     let in_assoc_non_trait_impl = matches!(kind, Some(ItemListKind::Impl | ItemListKind::Trait));
 
     let in_extern_block = matches!(kind, Some(ItemListKind::ExternBlock { .. }));
     let has_safe_kw = ctx.qualifier_ctx.safe_tok.is_some();
 
     // Some keywords are invalid after non-vis qualifiers, so we handle them first.
+
     if (has_unsafe_kw || has_safe_kw) && in_extern_block {
         add_keyword("fn", "fn $1($2);");
         add_keyword("static", "static $1: $2;");
     // ...and the rest deals with cases without any non-vis qualifiers.
 
     // Visibility qualifiers
+
     if !in_trait && !in_block && no_vis_qualifiers {
         add_keyword("pub(crate)", "pub(crate) $0");
         add_keyword("pub(super)", "pub(super) $0");
     }
 
     // Keywords that are valid in `item_list`
+
     if in_item_list {
         add_keyword("enum", "enum $1 {\n    $0\n}");
         add_keyword("mod", "mod $0");
         if in_unsafe_extern_block {
             add_keyword("safe", "safe $0");
         }
-
         add_keyword("fn", "fn $1($2);");
         add_keyword("static", "static $1: $2;");
     } else {
             }
             add_keyword("type", "type $0");
         }
-
         add_keyword("fn", "fn $1($2) {\n    $0\n}");
         add_keyword("unsafe", "unsafe $0");
         add_keyword("const", "const $0");