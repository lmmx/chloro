COMPARISON DIFF
============================================================

Original size: 21606 bytes
Chloro size:   21599 bytes
Rustfmt size:  22297 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     CallableSnippets,
     context::{
-        CompleteSemicolon, CompletionContext, DotAccess, DotAccessKind, PathCompletionCtx, PathKind,
+        CompleteSemicolon, CompletionContext, DotAccess, DotAccessKind, PathCompletionCtx,
+        PathKind,
     },
     item::{
         Builder, CompletionItem, CompletionItemKind, CompletionRelevance, CompletionRelevanceFn,
         CompletionRelevanceReturnType, CompletionRelevanceTraitInfo,
     },
     render::{
-        RenderContext, compute_exact_name_match, compute_ref_match, compute_type_match, match_types,
+        RenderContext, compute_exact_name_match, compute_ref_match, compute_type_match,
+        match_types,
     },
 };
 
     func: hir::Function,
 ) -> Builder {
     let _p = tracing::info_span!("render_method").entered();
-    render(
-        ctx,
-        local_name,
-        func,
-        FuncKind::Method(dot_access, receiver),
-    )
+    render(ctx, local_name, func, FuncKind::Method(dot_access, receiver))
 }
 
 fn render(
     let (call, escaped_call) = match &func_kind {
         FuncKind::Method(_, Some(receiver)) => (
             format_smolstr!("{}.{}", receiver, name.as_str()),
-            format_smolstr!(
-                "{}.{}",
-                receiver,
-                name.display(ctx.db(), completion.edition)
-            ),
-        ),
-        _ => (
-            name.as_str().to_smolstr(),
-            name.display(db, completion.edition).to_smolstr(),
+            format_smolstr!("{}.{}", receiver, name.display(ctx.db(), completion.edition)),
         ),
+        _ => (name.as_str().to_smolstr(), name.display(db, completion.edition).to_smolstr()),
     };
     let has_self_param = func.self_param(db).is_some();
     let mut item = CompletionItem::new(
     let ret_type = func.ret_type(db);
     let assoc_item = func.as_assoc_item(db);
 
-    let trait_info = assoc_item
-        .and_then(|trait_| trait_.container_or_implemented_trait(db))
-        .map(|trait_| CompletionRelevanceTraitInfo {
-            notable_trait: completion.is_doc_notable_trait(trait_),
-            is_op_method: completion.is_ops_trait(trait_),
+    let trait_info =
+        assoc_item.and_then(|trait_| trait_.container_or_implemented_trait(db)).map(|trait_| {
+            CompletionRelevanceTraitInfo {
+                notable_trait: completion.is_doc_notable_trait(trait_),
+                is_op_method: completion.is_ops_trait(trait_),
+            }
         });
 
     let (has_dot_receiver, has_call_parens, cap) = match func_kind {
             has_call_parens,
             ..
         }) => (false, has_call_parens, ctx.completion.config.snippet_cap),
-        FuncKind::Method(
-            &DotAccess {
-                kind: DotAccessKind::Method,
-                ..
-            },
-            _,
-        ) => (true, true, ctx.completion.config.snippet_cap),
-        FuncKind::Method(
-            DotAccess {
-                kind: DotAccessKind::Field { .. },
-                ..
-            },
-            _,
-        ) => (true, false, ctx.completion.config.snippet_cap),
+        FuncKind::Method(&DotAccess { kind: DotAccessKind::Method, .. }, _) => {
+            (true, true, ctx.completion.config.snippet_cap)
+        }
+        FuncKind::Method(DotAccess { kind: DotAccessKind::Field { .. }, .. }, _) => {
+            (true, false, ctx.completion.config.snippet_cap)
+        }
         _ => (false, false, None),
     };
-    let complete_call_parens = cap.filter(|_| !has_call_parens).and_then(|cap| {
-        Some((
-            cap,
-            params(ctx.completion, func, &func_kind, has_dot_receiver)?,
-        ))
-    });
+    let complete_call_parens = cap
+        .filter(|_| !has_call_parens)
+        .and_then(|cap| Some((cap, params(ctx.completion, func, &func_kind, has_dot_receiver)?)));
 
     let function = assoc_item
         .and_then(|assoc_item| assoc_item.implementing_ty(db))
         FuncKind::Function(path_ctx) => {
             super::path_ref_match(completion, path_ctx, &ret_type, &mut item);
         }
-        FuncKind::Method(
-            DotAccess {
-                receiver: Some(receiver),
-                ..
-            },
-            _,
-        ) => {
+        FuncKind::Method(DotAccess { receiver: Some(receiver), .. }, _) => {
             if let Some(original_expr) = completion.sema.original_ast_node(receiver.clone())
                 && let Some(ref_mode) = compute_ref_match(completion, &ret_type)
             {
             if let Some(actm) = assoc_item
                 && let Some(trt) = actm.container_or_implemented_trait(db)
             {
-                item.trait_name(
-                    trt.name(db)
-                        .display_no_db(ctx.completion.edition)
-                        .to_smolstr(),
-                );
+                item.trait_name(trt.name(db).display_no_db(ctx.completion.edition).to_smolstr());
             }
         }
     }
         CompletionRelevanceReturnType::DirectConstructor
     } else if ret_type
         .type_arguments()
-        .any(|ret_type_arg| match_types(ctx.completion, &self_type, &ret_type_arg).is_some())
-    {
+        .any(|ret_type_arg| match_types(ctx.completion, &self_type, &ret_type_arg).is_some()) {
         // fn([..]) -> Result<Self, E> OR Wrapped<Foo, Self>
         CompletionRelevanceReturnType::Constructor
     } else if ret_type
         .as_adt()
         .map(|adt| adt.name(db).as_str().ends_with("Builder"))
-        .unwrap_or(false)
-    {
+        .unwrap_or(false) {
         // fn([..]) -> [..]Builder
         CompletionRelevanceReturnType::Builder
     } else {
         let snippet = if let Some(CallableSnippets::FillArguments) = ctx.config.callable {
             let offset = if self_param.is_some() { 2 } else { 1 };
             let function_params_snippet =
-                params
-                    .iter()
-                    .enumerate()
-                    .format_with(", ", |(index, param), f| match param.name(ctx.db) {
+                params.iter().enumerate().format_with(", ", |(index, param), f| {
+                    match param.name(ctx.db) {
                         Some(n) => {
                             let smol_str = n.display_no_db(ctx.edition).to_smolstr();
                             let text = smol_str.as_str().trim_start_matches('_');
                             };
                             f(&format_args!("${{{}:{name}}}", index + offset))
                         }
-                    });
+                    }
+                });
             match self_param {
                 Some(self_param) => {
                     format!(
             }
         }
     }
-    builder
-        .label(SmolStr::from_iter([&name, label_suffix]))
-        .insert_snippet(cap, snippet)
+    builder.label(SmolStr::from_iter([&name, label_suffix])).insert_snippet(cap, snippet)
 }
 
 fn ref_of_param(ctx: &CompletionContext<'_>, arg: &str, ty: &hir::Type<'_>) -> &'static str {
         for (name, local) in ctx.locals.iter().sorted_by_key(|&(k, _)| k.clone()) {
             if name.as_str() == arg {
                 return if local.ty(ctx.db) == derefed_ty {
-                    if ty.is_mutable_reference() {
-                        "&mut "
-                    } else {
-                        "&"
-                    }
+                    if ty.is_mutable_reference() { "&mut " } else { "&" }
                 } else {
                     ""
                 };
         format_to!(
             detail,
             "{}",
-            assoc_fn_params
-                .iter()
-                .map(|p| p.ty().display(ctx.db, ctx.display_target))
-                .format(", ")
+            assoc_fn_params.iter().map(|p| p.ty().display(ctx.db, ctx.display_target)).format(", ")
         );
     }
 
         CallableSnippets, CompletionConfig,
         tests::{TEST_CONFIG, check_edit, check_edit_with_config},
     };
-
     #[test]
     fn inserts_parens_for_function_calls() {
         cov_mark::check!(inserts_parens_for_function_calls);
 "#,
         );
     }
-
     #[test]
     fn parens_for_method_call_as_assoc_fn() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn suppress_arg_snippets() {
         cov_mark::check!(suppress_arg_snippets);
         check_edit_with_config(
-            CompletionConfig {
-                callable: Some(CallableSnippets::AddParentheses),
-                ..TEST_CONFIG
-            },
+            CompletionConfig { callable: Some(CallableSnippets::AddParentheses), ..TEST_CONFIG },
             "with_args",
             r#"
 fn with_args(x: i32, y: String) {}
 "#,
         );
     }
-
     #[test]
     fn strips_underscores_from_args() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_ref_when_matching_local_in_scope() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_mut_ref_when_matching_local_in_scope() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_ref_when_matching_local_in_scope_for_method() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn trim_mut_keyword_in_func_completion() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_pattern_args_with_type_name_if_adt() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_fn_param() {
         // has mut kw
 "#,
         );
     }
-
     #[test]
     fn complete_fn_mut_param_add_comma() {
         // add leading and trailing comma
 "#,
         );
     }
-
     #[test]
     fn complete_fn_mut_param_has_attribute() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_semicolon_for_unit() {
         cov_mark::check!(complete_semicolon);
 "#,
         );
         check_edit_with_config(
-            CompletionConfig {
-                add_semicolon_to_unit: false,
-                ..TEST_CONFIG
-            },
+            CompletionConfig { add_semicolon_to_unit: false, ..TEST_CONFIG },
             r#"foo"#,
             r#"
 fn foo(a: i32) {}
 "#,
         );
     }
-
     #[test]
     fn complete_comma_for_unit_match_arm() {
         cov_mark::check!(complete_semicolon);
 "#,
         );
     }
-
     #[test]
     fn no_semicolon_in_closure_ret() {
         check_edit(