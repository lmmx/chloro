COMPARISON DIFF
============================================================

Original size: 21606 bytes
Chloro size:   21601 bytes
Rustfmt size:  21606 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use crate::{
     CallableSnippets,
     context::{
-        CompleteSemicolon, CompletionContext, DotAccess, DotAccessKind, PathCompletionCtx, PathKind,
+        CompleteSemicolon, CompletionContext, DotAccess, DotAccessKind, PathCompletionCtx,
+        PathKind,
     },
     item::{
         Builder, CompletionItem, CompletionItemKind, CompletionRelevance, CompletionRelevanceFn,
         CompletionRelevanceReturnType, CompletionRelevanceTraitInfo,
     },
     render::{
-        RenderContext, compute_exact_name_match, compute_ref_match, compute_type_match, match_types,
+        RenderContext, compute_exact_name_match, compute_ref_match, compute_type_match,
+        match_types,
     },
 };
 
         CompletionRelevanceReturnType::DirectConstructor
     } else if ret_type
         .type_arguments()
-        .any(|ret_type_arg| match_types(ctx.completion, &self_type, &ret_type_arg).is_some())
-    {
+        .any(|ret_type_arg| match_types(ctx.completion, &self_type, &ret_type_arg).is_some()) {
         // fn([..]) -> Result<Self, E> OR Wrapped<Foo, Self>
         CompletionRelevanceReturnType::Constructor
     } else if ret_type
         .as_adt()
         .map(|adt| adt.name(db).as_str().ends_with("Builder"))
-        .unwrap_or(false)
-    {
+        .unwrap_or(false) {
         // fn([..]) -> [..]Builder
         CompletionRelevanceReturnType::Builder
     } else {
     ctx.config.callable.as_ref()?;
 
     // Don't add parentheses if the expected type is a function reference with the same signature.
+
     if let Some(expected) = ctx.expected_type.as_ref().filter(|e| e.is_fn())
         && let Some(expected) = expected.as_callable(ctx.db)
         && let Some(completed) = func.ty(ctx.db).as_callable(ctx.db)
         CallableSnippets, CompletionConfig,
         tests::{TEST_CONFIG, check_edit, check_edit_with_config},
     };
-
     #[test]
     fn inserts_parens_for_function_calls() {
         cov_mark::check!(inserts_parens_for_function_calls);
 "#,
         );
     }
-
     #[test]
     fn parens_for_method_call_as_assoc_fn() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn suppress_arg_snippets() {
         cov_mark::check!(suppress_arg_snippets);
 "#,
         );
     }
-
     #[test]
     fn strips_underscores_from_args() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_ref_when_matching_local_in_scope() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_mut_ref_when_matching_local_in_scope() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_ref_when_matching_local_in_scope_for_method() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn trim_mut_keyword_in_func_completion() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_pattern_args_with_type_name_if_adt() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_fn_param() {
         // has mut kw
         );
 
         // has type param
+
         check_edit(
             "mut bar: u32",
             r#"
 "#,
         );
     }
-
     #[test]
     fn complete_fn_mut_param_add_comma() {
         // add leading and trailing comma
 "#,
         );
     }
-
     #[test]
     fn complete_fn_mut_param_has_attribute() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_semicolon_for_unit() {
         cov_mark::check!(complete_semicolon);
 "#,
         );
     }
-
     #[test]
     fn complete_comma_for_unit_match_arm() {
         cov_mark::check!(complete_semicolon);
 "#,
         );
     }
-
     #[test]
     fn no_semicolon_in_closure_ret() {
         check_edit(