COMPARISON DIFF
============================================================

Original size: 5785 bytes
Chloro size:   5782 bytes
Rustfmt size:  5785 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 ) {
     match qualified {
         Qualified::With { path, resolution: Some(resolution), super_chain_len } => {
-            acc.add_super_keyword(ctx, *super_chain_len);
-
             // only show `self` in a new use-tree when the qualifier doesn't end in self
+            acc.add_super_keyword(ctx, *super_chain_len);
             let not_preceded_by_self = *use_tree_parent
                 && !matches!(
                     path.segment().and_then(|it| it.kind()),
             if not_preceded_by_self {
                 acc.add_keyword(ctx, "self");
             }
-
             let mut already_imported_names = FxHashSet::default();
             if let Some(list) = ctx.token.parent_ancestors().find_map(ast::UseTreeList::cast) {
                 let use_tree = list.parent_use_tree();
                     }
                 }
             }
-
             match resolution {
                 hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {
                     let module_scope = module.scope(ctx.db, Some(ctx.module));
                         }
                         let is_name_already_imported =
                             already_imported_names.contains(name.as_str());
-
                         let add_resolution = match def {
                             ScopeDef::Unknown if unknown_is_current(&name) => {
                                 // for `use self::foo$0`, don't suggest `foo` as a completion
                             ScopeDef::ModuleDef(_) | ScopeDef::Unknown => true,
                             _ => false,
                         };
-
                         if add_resolution {
                             let mut builder = Builder::from_resolution(ctx, path_ctx, name, def);
                             builder.with_relevance(|r| CompletionRelevance {
                     cov_mark::hit!(enum_plain_qualified_use_tree);
                     acc.add_enum_variants(ctx, path_ctx, *e);
                 }
-                _ => {}
+                _ => {},
             }
         }
         // fresh use tree with leading colon2, only show crate roots
             });
             acc.add_nameref_keywords_with_colon(ctx);
         }
-        Qualified::TypeAnchor { .. } | Qualified::With { resolution: None, .. } => {}
+        Qualified::TypeAnchor { .. } | Qualified::With { resolution: None, .. } => {},
     }
 }