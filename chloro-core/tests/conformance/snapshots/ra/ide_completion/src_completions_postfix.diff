COMPARISON DIFF
============================================================

Original size: 32377 bytes
Chloro size:   32363 bytes
Rustfmt size:  32377 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     postfix_snippet("deref", "*expr", &format!("*{receiver_text}")).add_to(acc, ctx.db);
 
     // The rest of the postfix completions create an expression that moves an argument,
-    // so it's better to consider references now to avoid breaking the compilation
 
+    // so it's better to consider references now to avoid breaking the compilation
     let (dot_receiver_including_refs, prefix) = include_references(dot_receiver);
     let mut receiver_text =
         get_receiver_text(&ctx.sema, dot_receiver, receiver_is_ambiguous_float_literal);
 
     postfix_snippet("box", "Box::new(expr)", &format!("Box::new({receiver_text})"))
         .add_to(acc, ctx.db);
-    postfix_snippet("dbg", "dbg!(expr)", &format!("dbg!({receiver_text})")).add_to(acc, ctx.db); // fixme
+    postfix_snippet("dbg", "dbg!(expr)", &format!("dbg!({receiver_text})")).add_to(acc, ctx.db);
+    // fixme
     postfix_snippet("dbgr", "dbg!(&expr)", &format!("dbg!(&{receiver_text})")).add_to(acc, ctx.db);
     postfix_snippet("call", "function(expr)", &format!("${{1}}({receiver_text})"))
         .add_to(acc, ctx.db);
     let mut text = file_text.text(sema.db)[range.range].to_owned();
 
     // The receiver texts should be interpreted as-is, as they are expected to be
+
     // normal Rust expressions.
     escape_snippet_bits(&mut text);
     text
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::{
         CompletionConfig, Snippet,
         tests::{TEST_CONFIG, check, check_edit, check_edit_with_config},
     };
-
     #[test]
     fn postfix_completion_works_for_trivial_path_expression() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn postfix_completion_works_for_function_calln() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn postfix_type_filtering() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn let_middle_block() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn option_iflet() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn option_iflet_cond() {
         check(
 "#,
         );
     }
-
     #[test]
     fn option_letelse() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn result_match() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_works_for_ambiguous_float_literal() {
         check_edit("refm", r#"fn main() { 42.$0 }"#, r#"fn main() { &mut 42 }"#)
     }
-
     #[test]
     fn works_in_simple_macro() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_for_references() {
         check_edit("dbg", r#"fn main() { &&42.$0 }"#, r#"fn main() { dbg!(&&42) }"#);
 "#,
         )
     }
-
     #[test]
     fn postfix_completion_for_unsafe() {
         postfix_completion_for_block("unsafe");
     }
-
     #[test]
     fn postfix_completion_for_const() {
         postfix_completion_for_block("const");
     }
-
     fn postfix_completion_for_block(kind: &str) {
         check_edit(kind, r#"fn main() { foo.$0 }"#, &format!("fn main() {{ {kind} {{ foo }} }}"));
         check_edit(
             &format!("fn main() {{ let x = true else {{panic!()}}.{kind} $0}}"),
         );
     }
-
     #[test]
     fn custom_postfix_completion() {
         let config = CompletionConfig {
         );
 
         // The receiver texts should be escaped, see comments in `get_receiver_text()`
+
         // for detail.
+
         //
+
         // Note that the last argument is what *lsp clients would see* rather than
+
         // what users would see. Unescaping happens thereafter.
         check_edit_with_config(
             config.clone(),
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_for_format_like_strings() {
         check_edit(
             r#"fn main() { log::error!("{}", 2+2) }"#,
         );
     }
-
     #[test]
     fn postfix_custom_snippets_completion_for_references() {
         // https://github.com/rust-lang/rust-analyzer/issues/7929
-
         let snippet = Snippet::new(
             &[],
             &["ok".into()],
             "#,
         );
     }
-
     #[test]
     fn no_postfix_completions_in_if_block_that_has_an_else() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn mut_ref_consuming() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn deref_consuming() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn inside_macro() {
         check_edit(