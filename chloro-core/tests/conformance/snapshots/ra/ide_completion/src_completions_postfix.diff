COMPARISON DIFF
============================================================

Original size: 32377 bytes
Chloro size:   32374 bytes
Rustfmt size:  32377 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use base_db::SourceDatabase;
 use hir::{ItemInNs, Semantics};
 use ide_db::{
-    RootDatabase, SnippetCap,
     documentation::{Documentation, HasDocs},
     imports::insert_use::ImportScope,
     text_edit::TextEdit,
     ty_filter::TryEnum,
+    RootDatabase, SnippetCap,
 };
 use stdx::never;
 use syntax::{
-    SyntaxKind::{EXPR_STMT, STMT_LIST},
-    T, TextRange, TextSize,
     ast::{self, AstNode, AstToken},
     match_ast,
+    SyntaxKind::{EXPR_STMT, STMT_LIST},
+    TextRange, TextSize, T,
 };
 
 use crate::{
-    CompletionItem, CompletionItemKind, CompletionRelevance, Completions, SnippetScope,
     completions::postfix::format_like::add_format_like_completions,
     context::{BreakableKind, CompletionContext, DotAccess, DotAccessKind},
     item::{Builder, CompletionRelevancePostfixMatch},
+    CompletionItem, CompletionItemKind, CompletionRelevance, Completions, SnippetScope,
 };
 
 pub(crate) fn complete_postfix(
     };
     let expr_ctx = &dot_access.ctx;
 
-    let receiver_text =
-        get_receiver_text(&ctx.sema, dot_receiver, receiver_is_ambiguous_float_literal);
+    let receiver_text = get_receiver_text(&ctx.sema, dot_receiver, receiver_is_ambiguous_float_literal);
 
     let cap = match ctx.config.snippet_cap {
         Some(it) => it,
     postfix_snippet("deref", "*expr", &format!("*{receiver_text}")).add_to(acc, ctx.db);
 
     // The rest of the postfix completions create an expression that moves an argument,
-    // so it's better to consider references now to avoid breaking the compilation
 
+    // so it's better to consider references now to avoid breaking the compilation
     let (dot_receiver_including_refs, prefix) = include_references(dot_receiver);
-    let mut receiver_text =
-        get_receiver_text(&ctx.sema, dot_receiver, receiver_is_ambiguous_float_literal);
+    let mut receiver_text = get_receiver_text(&ctx.sema, dot_receiver, receiver_is_ambiguous_float_literal);
     receiver_text.insert_str(0, &prefix);
-    let postfix_snippet =
-        match build_postfix_snippet_builder(ctx, cap, &dot_receiver_including_refs) {
+    let postfix_snippet = match build_postfix_snippet_builder(ctx, cap, &dot_receiver_including_refs) {
             Some(it) => it,
             None => return,
         };
 
     postfix_snippet("box", "Box::new(expr)", &format!("Box::new({receiver_text})"))
         .add_to(acc, ctx.db);
-    postfix_snippet("dbg", "dbg!(expr)", &format!("dbg!({receiver_text})")).add_to(acc, ctx.db); // fixme
+    postfix_snippet("dbg", "dbg!(expr)", &format!("dbg!({receiver_text})")).add_to(acc, ctx.db);
+    // fixme
     postfix_snippet("dbgr", "dbg!(&expr)", &format!("dbg!(&{receiver_text})")).add_to(acc, ctx.db);
     postfix_snippet("call", "function(expr)", &format!("${{1}}({receiver_text})"))
         .add_to(acc, ctx.db);
             semi = if expr_ctx.in_block_expr { ";" } else { "" }
         ),
     )
-    .add_to(acc, ctx.db);
+        .add_to(acc, ctx.db);
 
     if let Some(BreakableKind::Block | BreakableKind::Loop) = expr_ctx.in_breakable {
         postfix_snippet(
     let mut text = file_text.text(sema.db)[range.range].to_owned();
 
     // The receiver texts should be interpreted as-is, as they are expected to be
+
     // normal Rust expressions.
     escape_snippet_bits(&mut text);
     text
     receiver_text: &str,
 ) -> Option<()> {
     ImportScope::find_insert_use_container(&ctx.token.parent()?, &ctx.sema)?;
-    ctx.config.postfix_snippets().filter(|(_, snip)| snip.scope == SnippetScope::Expr).for_each(
+    ctx.config
+        .postfix_snippets()
+        .filter(|(_, snip)| snip.scope == SnippetScope::Expr)
+        .for_each(
         |(trigger, snippet)| {
             let imports = match snippet.imports(ctx) {
                 Some(imports) => imports,
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::{
+        tests::{check, check_edit, check_edit_with_config, TEST_CONFIG},
         CompletionConfig, Snippet,
-        tests::{TEST_CONFIG, check, check_edit, check_edit_with_config},
     };
-
     #[test]
     fn postfix_completion_works_for_trivial_path_expression() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn postfix_completion_works_for_function_calln() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn postfix_type_filtering() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn let_middle_block() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn option_iflet() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn option_iflet_cond() {
         check(
 "#,
         );
     }
-
     #[test]
     fn option_letelse() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn result_match() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_works_for_ambiguous_float_literal() {
         check_edit("refm", r#"fn main() { 42.$0 }"#, r#"fn main() { &mut 42 }"#)
     }
-
     #[test]
     fn works_in_simple_macro() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_for_references() {
         check_edit("dbg", r#"fn main() { &&42.$0 }"#, r#"fn main() { dbg!(&&42) }"#);
 "#,
         )
     }
-
     #[test]
     fn postfix_completion_for_unsafe() {
         postfix_completion_for_block("unsafe");
     }
-
     #[test]
     fn postfix_completion_for_const() {
         postfix_completion_for_block("const");
     }
-
     fn postfix_completion_for_block(kind: &str) {
         check_edit(kind, r#"fn main() { foo.$0 }"#, &format!("fn main() {{ {kind} {{ foo }} }}"));
         check_edit(
             &format!("fn main() {{ let x = true else {{panic!()}}.{kind} $0}}"),
         );
     }
-
     #[test]
     fn custom_postfix_completion() {
         let config = CompletionConfig {
         );
 
         // The receiver texts should be escaped, see comments in `get_receiver_text()`
+
         // for detail.
+
         //
+
         // Note that the last argument is what *lsp clients would see* rather than
+
         // what users would see. Unescaping happens thereafter.
         check_edit_with_config(
             config.clone(),
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_for_format_like_strings() {
         check_edit(
             r#"fn main() { log::error!("{}", 2+2) }"#,
         );
     }
-
     #[test]
     fn postfix_custom_snippets_completion_for_references() {
         // https://github.com/rust-lang/rust-analyzer/issues/7929
-
         let snippet = Snippet::new(
             &[],
             &["ok".into()],
             &[],
             crate::SnippetScope::Expr,
         )
-        .unwrap();
+            .unwrap();
 
         check_edit_with_config(
             CompletionConfig { snippets: vec![snippet.clone()], ..TEST_CONFIG },
             "#,
         );
     }
-
     #[test]
     fn no_postfix_completions_in_if_block_that_has_an_else() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn mut_ref_consuming() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn deref_consuming() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn inside_macro() {
         check_edit(