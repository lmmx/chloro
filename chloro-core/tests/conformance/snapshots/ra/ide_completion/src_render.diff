COMPARISON DIFF
============================================================

Original size: 98473 bytes
Chloro size:   98334 bytes
Rustfmt size:  99223 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     context::{DotAccess, DotAccessKind, PathCompletionCtx, PathKind, PatternContext},
     item::{Builder, CompletionRelevanceTypeMatch},
     render::{
-        function::render_fn,
-        literal::render_variant_lit,
+        function::render_fn, literal::render_variant_lit,
         macro_::{render_macro, render_macro_pat},
     },
 };
         CompletionRelevance {
             is_private_editable: self.is_private_editable,
             requires_import: self.import_to_add.is_some(),
-            ..Default::default()
         }
     }
 
     fn is_immediately_after_macro_bang(&self) -> bool {
         self.completion.token.kind() == SyntaxKind::BANG
-            && self
-                .completion
-                .token
-                .parent()
-                .is_some_and(|it| it.kind() == SyntaxKind::MACRO_CALL)
+            && self.completion.token.parent().is_some_and(|it| it.kind() == SyntaxKind::MACRO_CALL)
     }
 
     fn is_deprecated(&self, def: impl HasAttrs) -> bool {
     let db = ctx.db();
     let is_deprecated = ctx.is_deprecated(field);
     let name = field.name(db);
-    let (name, escaped_name) = (
-        name.as_str().to_smolstr(),
-        name.display_no_db(ctx.completion.edition).to_smolstr(),
-    );
+    let (name, escaped_name) =
+        (name.as_str().to_smolstr(), name.display_no_db(ctx.completion.edition).to_smolstr());
     let mut item = CompletionItem::new(
         SymbolKind::Field,
         ctx.source_range(),
             field_with_receiver(receiver.as_deref(), &escaped_name).into(),
         );
 
-        let expected_fn_type = ctx
-            .completion
-            .expected_type
-            .as_ref()
-            .is_some_and(|ty| ty.is_fn() || ty.is_closure());
+        let expected_fn_type =
+            ctx.completion.expected_type.as_ref().is_some_and(|ty| ty.is_fn() || ty.is_closure());
 
         if !expected_fn_type
             && let Some(receiver) = &dot_access.receiver
         field_with_receiver(receiver.as_deref(), &field.to_string()),
         ctx.completion.edition,
     );
-    item.detail(
-        ty.display(ctx.db(), ctx.completion.display_target)
-            .to_string(),
-    )
-    .lookup_by(field.to_string());
+    item.detail(ty.display(ctx.db(), ctx.completion.display_target).to_string())
+        .lookup_by(field.to_string());
     item.set_relevance(CompletionRelevance {
         is_skipping_completion: receiver.is_some(),
         ..ctx.completion_relevance()
     // This now just renders the alias text, but we need to find the aliases earlier and call this with the alias instead.
     let doc_aliases = ctx.completion.doc_aliases_in_scope(resolution);
     let ctx = ctx.doc_aliases(doc_aliases);
-    Some(render_resolution_path(
-        ctx,
-        path_ctx,
-        local_name,
-        Some(import_edit),
-        resolution,
-    ))
+    Some(render_resolution_path(ctx, path_ctx, local_name, Some(import_edit), resolution))
 }
 
 pub(crate) fn render_resolution_with_import_pat(
 ) -> Option<Builder> {
     let resolution = ScopeDef::from(import_edit.original_item);
     let local_name = get_import_name(resolution, &ctx, &import_edit)?;
-    Some(render_resolution_pat(
-        ctx,
-        pattern_ctx,
-        local_name,
-        Some(import_edit),
-        resolution,
-    ))
+    Some(render_resolution_pat(ctx, pattern_ctx, local_name, Some(import_edit), resolution))
 }
 
 pub(crate) fn render_expr(
 
     let cfg = ctx.config.find_path_config(ctx.is_nightly);
 
-    let label = expr
-        .gen_source_code(&ctx.scope, &mut label_formatter, cfg, ctx.display_target)
-        .ok()?;
+    let label =
+        expr.gen_source_code(&ctx.scope, &mut label_formatter, cfg, ctx.display_target).ok()?;
 
     let source_range = match ctx.original_token.parent() {
         Some(node) => match node.ancestors().find_map(ast::Path::cast) {
         None => ctx.source_range(),
     };
 
-    let mut item = CompletionItem::new(
-        CompletionItemKind::Expression,
-        source_range,
-        label,
-        ctx.edition,
-    );
+    let mut item =
+        CompletionItem::new(CompletionItemKind::Expression, source_range, label, ctx.edition);
 
     let snippet = format!(
         "{}$0",
-        expr.gen_source_code(&ctx.scope, &mut snippet_formatter, cfg, ctx.display_target)
-            .ok()?
+        expr.gen_source_code(&ctx.scope, &mut snippet_formatter, cfg, ctx.display_target).ok()?
     );
     let edit = TextEdit::replace(source_range, snippet);
     item.snippet_edit(ctx.config.snippet_cap?, edit);
-    item.documentation(Documentation::new(String::from(
-        "Autogenerated expression by term search",
-    )));
+    item.documentation(Documentation::new(String::from("Autogenerated expression by term search")));
     item.set_relevance(crate::CompletionRelevance {
         type_match: compute_type_match(ctx, &expr.ty(ctx.db)),
         ..Default::default()
             continue;
         };
 
-        item.add_import(LocatedImport::new_no_completion(
-            path, trait_item, trait_item,
-        ));
+        item.add_import(LocatedImport::new_no_completion(path, trait_item, trait_item));
     }
 
     Some(item)
     // FIXME: Temporary workaround for handling aliased import.
     // This should be removed after we have proper support for importing alias.
     // <https://github.com/rust-lang/rust-analyzer/issues/14079>
-
     // If `item_to_import` matches `original_item`, we are importing the item itself (not its parent module).
     // In this case, we can use the last segment of `import_path`, as it accounts for the aliased name.
     if import_edit.item_to_import == import_edit.original_item {
     let config = completion.config;
     let requires_import = import_to_add.is_some();
 
-    let name = local_name
-        .display_no_db(ctx.completion.edition)
-        .to_smolstr();
+    let name = local_name.display_no_db(ctx.completion.edition).to_smolstr();
     let mut item = render_resolution_simple_(ctx, &local_name, import_to_add, resolution);
     if local_name.needs_escape(completion.edition) {
         item.insert_text(local_name.display_no_db(completion.edition).to_smolstr());
     // Add `<>` for generic types
     let type_path_no_ty_args = matches!(
         path_ctx,
-        PathCompletionCtx {
-            kind: PathKind::Type { .. },
-            has_type_args: false,
-            ..
-        }
+        PathCompletionCtx { kind: PathKind::Type { .. }, has_type_args: false, .. }
     ) && config.callable.is_some();
     if type_path_no_ty_args && let Some(cap) = cap {
         let has_non_default_type_params = match resolution {
             item.lookup_by(name.clone())
                 .label(SmolStr::from_iter([&name, "<…>"]))
                 .trigger_call_info()
-                .insert_snippet(
-                    cap,
-                    format!("{}<$0>", local_name.display(db, completion.edition)),
-                );
+                .insert_snippet(cap, format!("{}<$0>", local_name.display(db, completion.edition)));
         }
     }
 
 }
 
 fn compute_exact_name_match(ctx: &CompletionContext<'_>, completion_name: &str) -> bool {
-    ctx.expected_name
-        .as_ref()
-        .is_some_and(|name| name.text() == completion_name)
+    ctx.expected_name.as_ref().is_some_and(|name| name.text() == completion_name)
 }
 
 fn compute_ref_match(
         return None;
     }
     if let Some(expected_without_ref) = &expected_without_ref
-        && completion_ty
-            .autoderef(ctx.db)
-            .any(|ty| ty == *expected_without_ref)
+        && completion_ty.autoderef(ctx.db).any(|ty| ty == *expected_without_ref)
     {
         cov_mark::hit!(suggest_ref);
         let mutability = if expected_type.is_mutable_reference() {
     if let Some(original_path) = &path_ctx.original_path {
         // At least one char was typed by the user already, in that case look for the original path
         if let Some(original_path) = completion.sema.original_ast_node(original_path.clone())
-            && let Some(ref_mode) = compute_ref_match(completion, ty)
-        {
+            && let Some(ref_mode) = compute_ref_match(completion, ty) {
             item.ref_match(ref_mode, original_path.syntax().text_range().start());
         }
     } else {
 #[cfg(test)]
 mod tests {
     use std::cmp;
-
     use expect_test::{Expect, expect};
     use ide_db::SymbolKind;
     use itertools::Itertools;
-
     use crate::{
         CompletionItem, CompletionItemKind, CompletionRelevance, CompletionRelevancePostfixMatch,
         item::CompletionRelevanceTypeMatch,
         tests::{TEST_CONFIG, check_edit, do_completion, get_all_items},
     };
-
     #[track_caller]
     fn check(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let actual = do_completion(ra_fixture, kind.into());
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_kinds(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         kinds: &[CompletionItemKind],
         expect: Expect,
     ) {
-        let actual: Vec<_> = kinds
-            .iter()
-            .flat_map(|&kind| do_completion(ra_fixture, kind))
-            .collect();
+        let actual: Vec<_> =
+            kinds.iter().flat_map(|&kind| do_completion(ra_fixture, kind)).collect();
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_function_relevance(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
-        let actual: Vec<_> = do_completion(
-            ra_fixture,
-            CompletionItemKind::SymbolKind(SymbolKind::Method),
-        )
-        .into_iter()
-        .map(|item| (item.detail.unwrap_or_default(), item.relevance.function))
-        .collect();
+        let actual: Vec<_> =
+            do_completion(ra_fixture, CompletionItemKind::SymbolKind(SymbolKind::Method))
+                .into_iter()
+                .map(|item| (item.detail.unwrap_or_default(), item.relevance.function))
+                .collect();
 
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_relevance_for_kinds(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         actual.sort_by_key(|it| (cmp::Reverse(it.relevance.score()), it.label.primary.clone()));
         check_relevance_(actual, expect);
     }
-
     #[track_caller]
     fn check_relevance(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);
         actual.sort_by_key(|it| (cmp::Reverse(it.relevance.score()), it.label.primary.clone()));
         check_relevance_(actual, expect);
     }
-
     #[track_caller]
     fn check_relevance_(actual: Vec<CompletionItem>, expect: Expect) {
         let actual = actual
 
         fn display_relevance(relevance: CompletionRelevance) -> String {
             let relevance_factors = vec![
-                (
-                    relevance.type_match == Some(CompletionRelevanceTypeMatch::Exact),
-                    "type",
-                ),
+                (relevance.type_match == Some(CompletionRelevanceTypeMatch::Exact), "type"),
                 (
                     relevance.type_match == Some(CompletionRelevanceTypeMatch::CouldUnify),
                     "type_could_unify",
                     relevance.postfix_match == Some(CompletionRelevancePostfixMatch::Exact),
                     "snippet",
                 ),
-                (
-                    relevance.trait_.is_some_and(|it| it.is_op_method),
-                    "op_method",
-                ),
+                (relevance.trait_.is_some_and(|it| it.is_op_method), "op_method"),
                 (relevance.requires_import, "requires_import"),
             ]
             .into_iter()
             format!("[{relevance_factors}]")
         }
     }
-
     #[test]
     fn set_struct_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_union_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_enum_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_enum_variant_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_fn_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_const_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_static_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_self_type_completion_info_with_params() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_self_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_builtin_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_includes_record_fields() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_includes_tuple_fields() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_detail_includes_args_and_return_type() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_detail_includes_variadics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_just_name_for_unit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn lookup_enums_by_two_qualifiers() {
         check_kinds(
 fn main() { let _: m::Spam = S$0 }
 "#,
             &[
-                CompletionItemKind::SymbolKind(SymbolKind::Function),
-                CompletionItemKind::SymbolKind(SymbolKind::Module),
-                CompletionItemKind::SymbolKind(SymbolKind::Variant),
-            ],
+            CompletionItemKind::SymbolKind(SymbolKind::Function),
+            CompletionItemKind::SymbolKind(SymbolKind::Module),
+            CompletionItemKind::SymbolKind(SymbolKind::Variant),
+        ],
             expect![[r#"
                 [
                     CompletionItem {
             "#]],
         )
     }
-
     #[test]
     fn sets_deprecated_flag_in_items() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn renders_docs() {
         check_kinds(
 use self::E::*;
 "#,
             &[
-                CompletionItemKind::SymbolKind(SymbolKind::Module),
-                CompletionItemKind::SymbolKind(SymbolKind::Variant),
-                CompletionItemKind::SymbolKind(SymbolKind::Enum),
-            ],
+            CompletionItemKind::SymbolKind(SymbolKind::Module),
+            CompletionItemKind::SymbolKind(SymbolKind::Variant),
+            CompletionItemKind::SymbolKind(SymbolKind::Enum),
+        ],
             expect![[r#"
                 [
                     CompletionItem {
             "#]],
         )
     }
-
     #[test]
     fn dont_render_attrs() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn no_call_parens_if_fn_ptr_needed() {
         cov_mark::check!(no_call_parens_if_fn_ptr_needed);
 "#,
         );
     }
-
     #[test]
     fn no_parens_in_use_item() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn no_parens_in_call() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn inserts_angle_brackets_for_generics() {
         cov_mark::check!(inserts_angle_brackets_for_generics);
 "#,
         );
     }
-
     #[test]
     fn active_param_relevance() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn record_field_relevances() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn tuple_field_detail() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_field_and_call_relevances() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn prioritize_exact_ref_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn too_many_arguments() {
         cov_mark::check!(too_many_arguments);
             "#]],
         );
     }
-
     #[test]
     fn score_fn_type_and_name_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn score_method_type_and_name_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn score_method_name_match_only() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn test_avoid_redundant_suggestion() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn suggest_ref_mut() {
         cov_mark::check!(suggest_ref);
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_copy() {
         cov_mark::check!(suggest_deref);
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_trait() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn suggest_deref_mut() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn locals() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_owned() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_ref() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_fn_ret() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn op_function_relevances() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_simple() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_kind() {
         check_function_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_relevance() {
         check_relevance(
 
         //
     }
-
     #[test]
     fn function_relevance_generic_1() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn function_relevance_generic_2() {
         // Generic 2
             "#]],
         );
     }
-
     #[test]
     fn struct_field_method_ref() {
         check_kinds(
             "#]],
         );
     }
-
     #[test]
     fn expected_fn_type_ref() {
         check_kinds(
             "#]],
         )
     }
-
     #[test]
     fn qualified_path_ref() {
         check_kinds(
             "#]],
         );
     }
-
     #[test]
     fn generic_enum() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn postfix_exact_match_is_high_priority() {
         cov_mark::check!(postfix_exact_match_is_high_priority);
     let _: bool = (9 > 2).not$0;
 }
     "#,
-            &[
-                CompletionItemKind::Snippet,
-                CompletionItemKind::SymbolKind(SymbolKind::Method),
-            ],
+            &[CompletionItemKind::Snippet, CompletionItemKind::SymbolKind(SymbolKind::Method)],
             expect![[r#"
                 sn not !expr [snippet]
                 sn box Box::new(expr) []
             "#]],
         );
     }
-
     #[test]
     fn postfix_inexact_match_is_low_priority() {
         cov_mark::check!(postfix_inexact_match_is_low_priority);
     S.$0
 }
     "#,
-            &[
-                CompletionItemKind::Snippet,
-                CompletionItemKind::SymbolKind(SymbolKind::Method),
-            ],
+            &[CompletionItemKind::Snippet, CompletionItemKind::SymbolKind(SymbolKind::Method)],
             expect![[r#"
                 me f() fn(&self) []
                 sn box Box::new(expr) []
             "#]],
         );
     }
-
     #[test]
     fn flyimport_reduced_relevance() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn completes_struct_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_fn_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_macro_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_variant_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_field_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_const_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_type_alias_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn field_access_includes_self() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn notable_traits_method_relevance() {
         check_kinds(