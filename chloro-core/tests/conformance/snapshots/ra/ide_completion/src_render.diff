COMPARISON DIFF
============================================================

Original size: 98473 bytes
Chloro size:   98236 bytes
Rustfmt size:  98473 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 pub(crate) mod union_literal;
 pub(crate) mod variant;
 
-use hir::{AsAssocItem, HasAttrs, HirDisplay, ModuleDef, ScopeDef, Type, sym};
+use hir::{sym, AsAssocItem, HasAttrs, HirDisplay, ModuleDef, ScopeDef, Type};
 use ide_db::text_edit::TextEdit;
 use ide_db::{
-    RootDatabase, SnippetCap, SymbolKind,
     documentation::{Documentation, HasDocs},
     helpers::item_name,
     imports::import_assets::LocatedImport,
+    RootDatabase, SnippetCap, SymbolKind,
 };
-use syntax::{AstNode, SmolStr, SyntaxKind, TextRange, ToSmolStr, ast, format_smolstr};
+use syntax::{ast, format_smolstr, AstNode, SmolStr, SyntaxKind, TextRange, ToSmolStr};
 
 use crate::{
-    CompletionContext, CompletionItem, CompletionItemKind, CompletionItemRefMode,
-    CompletionRelevance,
     context::{DotAccess, DotAccessKind, PathCompletionCtx, PathKind, PatternContext},
     item::{Builder, CompletionRelevanceTypeMatch},
     render::{
-        function::render_fn,
-        literal::render_variant_lit,
+        function::render_fn, literal::render_variant_lit,
         macro_::{render_macro, render_macro_pat},
     },
+    CompletionContext, CompletionItem, CompletionItemKind, CompletionItemRefMode,
+    CompletionRelevance,
 };
+
 /// Interface for data and methods required for items rendering.
 #[derive(Debug, Clone)]
 pub(crate) struct RenderContext<'a> {
         CompletionRelevance {
             is_private_editable: self.is_private_editable,
             requires_import: self.import_to_add.is_some(),
-            ..Default::default()
         }
     }
 
                 .unwrap_or(false)
     }
 
-    // FIXME: remove this
     fn docs(&self, def: impl HasDocs) -> Option<Documentation> {
         def.docs(self.db())
     }
     let db = ctx.db();
     let is_deprecated = ctx.is_deprecated(field);
     let name = field.name(db);
-    let (name, escaped_name) =
-        (name.as_str().to_smolstr(), name.display_no_db(ctx.completion.edition).to_smolstr());
+    let (name, escaped_name) = (name.as_str().to_smolstr(), name.display_no_db(ctx.completion.edition).to_smolstr());
     let mut item = CompletionItem::new(
         SymbolKind::Field,
         ctx.source_range(),
         field_with_receiver(receiver.as_deref(), &name),
         ctx.completion.edition,
     );
-    item.set_relevance(CompletionRelevance {
+    item
+        .set_relevance(CompletionRelevance {
         type_match: compute_type_match(ctx.completion, ty),
         exact_name_match: compute_exact_name_match(ctx.completion, &name),
         is_skipping_completion: receiver.is_some(),
         ..CompletionRelevance::default()
     });
-    item.detail(ty.display(db, ctx.completion.display_target).to_string())
+    item
+        .detail(ty.display(db, ctx.completion.display_target).to_string())
         .set_documentation(field.docs(db))
         .set_deprecated(is_deprecated)
         .lookup_by(name);
         field_with_receiver(receiver.as_deref(), &field.to_string()),
         ctx.completion.edition,
     );
-    item.detail(ty.display(ctx.db(), ctx.completion.display_target).to_string())
+    item
+        .detail(ty.display(ctx.db(), ctx.completion.display_target).to_string())
         .lookup_by(field.to_string());
-    item.set_relevance(CompletionRelevance {
+    item
+        .set_relevance(CompletionRelevance {
         is_skipping_completion: receiver.is_some(),
         ..ctx.completion_relevance()
     });
         ty_string,
         ctx.edition,
     );
-    builder.set_relevance(CompletionRelevance {
+    builder
+        .set_relevance(CompletionRelevance {
         type_match: Some(CompletionRelevanceTypeMatch::Exact),
         exact_name_match: true,
         ..Default::default()
 
     let cfg = ctx.config.find_path_config(ctx.is_nightly);
 
-    let label =
-        expr.gen_source_code(&ctx.scope, &mut label_formatter, cfg, ctx.display_target).ok()?;
+    let label = expr.gen_source_code(&ctx.scope, &mut label_formatter, cfg, ctx.display_target).ok()?;
 
     let source_range = match ctx.original_token.parent() {
         Some(node) => match node.ancestors().find_map(ast::Path::cast) {
         None => ctx.source_range(),
     };
 
-    let mut item =
-        CompletionItem::new(CompletionItemKind::Expression, source_range, label, ctx.edition);
+    let mut item = CompletionItem::new(CompletionItemKind::Expression, source_range, label, ctx.edition);
 
     let snippet = format!(
         "{}$0",
     let edit = TextEdit::replace(source_range, snippet);
     item.snippet_edit(ctx.config.snippet_cap?, edit);
     item.documentation(Documentation::new(String::from("Autogenerated expression by term search")));
-    item.set_relevance(crate::CompletionRelevance {
+    item
+        .set_relevance(crate::CompletionRelevance {
         type_match: compute_type_match(ctx, &expr.ty(ctx.db)),
         ..Default::default()
     });
     // <https://github.com/rust-lang/rust-analyzer/issues/14079>
 
     // If `item_to_import` matches `original_item`, we are importing the item itself (not its parent module).
+
     // In this case, we can use the last segment of `import_path`, as it accounts for the aliased name.
     if import_edit.item_to_import == import_edit.original_item {
         import_edit.import_path.segments().last().cloned()
         local_name.as_str().to_smolstr(),
         ctx.completion.edition,
     );
-    item.set_relevance(ctx.completion_relevance())
+    item
+        .set_relevance(ctx.completion_relevance())
         .set_documentation(scope_def_docs(db, resolution))
         .set_deprecated(scope_def_is_deprecated(&ctx, resolution));
 
     }
 }
 
-// FIXME: This checks types without possible coercions which some completions might want to do
 fn match_types(
     ctx: &CompletionContext<'_>,
     ty1: &hir::Type<'_>,
     let expected_type = ctx.expected_type.as_ref()?;
 
     // We don't ever consider unit type to be an exact type match, since
+
     // nearly always this is not meaningful to the user.
     if expected_type.is_unit() {
         return None;
 #[cfg(test)]
 mod tests {
     use std::cmp;
-
-    use expect_test::{Expect, expect};
+    use expect_test::{expect, Expect};
     use ide_db::SymbolKind;
     use itertools::Itertools;
-
     use crate::{
-        CompletionItem, CompletionItemKind, CompletionRelevance, CompletionRelevancePostfixMatch,
         item::CompletionRelevanceTypeMatch,
-        tests::{TEST_CONFIG, check_edit, do_completion, get_all_items},
+        tests::{check_edit, do_completion, get_all_items, TEST_CONFIG},
+        CompletionItem, CompletionItemKind, CompletionRelevance, CompletionRelevancePostfixMatch,
     };
-
     #[track_caller]
     fn check(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let actual = do_completion(ra_fixture, kind.into());
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_kinds(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         kinds: &[CompletionItemKind],
         expect: Expect,
     ) {
-        let actual: Vec<_> =
-            kinds.iter().flat_map(|&kind| do_completion(ra_fixture, kind)).collect();
+        let actual: Vec<_> = kinds.iter().flat_map(|&kind| do_completion(ra_fixture, kind)).collect();
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_function_relevance(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
-        let actual: Vec<_> =
-            do_completion(ra_fixture, CompletionItemKind::SymbolKind(SymbolKind::Method))
-                .into_iter()
-                .map(|item| (item.detail.unwrap_or_default(), item.relevance.function))
-                .collect();
+        let actual: Vec<_> = do_completion(ra_fixture, CompletionItemKind::SymbolKind(SymbolKind::Method))
+            .into_iter()
+            .map(|item| (item.detail.unwrap_or_default(), item.relevance.function))
+            .collect();
 
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_relevance_for_kinds(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         actual.sort_by_key(|it| (cmp::Reverse(it.relevance.score()), it.label.primary.clone()));
         check_relevance_(actual, expect);
     }
-
     #[track_caller]
     fn check_relevance(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);
         actual.sort_by_key(|it| (cmp::Reverse(it.relevance.score()), it.label.primary.clone()));
         check_relevance_(actual, expect);
     }
-
     #[track_caller]
     fn check_relevance_(actual: Vec<CompletionItem>, expect: Expect) {
         let actual = actual
 
                 items
             })
-            .collect::<String>();
+            .collect();
 
         expect.assert_eq(&actual);
 
             format!("[{relevance_factors}]")
         }
     }
-
     #[test]
     fn set_struct_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_union_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_enum_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_enum_variant_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_fn_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_const_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_static_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_self_type_completion_info_with_params() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_self_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_builtin_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_includes_record_fields() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_includes_tuple_fields() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_detail_includes_args_and_return_type() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_detail_includes_variadics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_just_name_for_unit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn lookup_enums_by_two_qualifiers() {
         check_kinds(
             "#]],
         )
     }
-
     #[test]
     fn sets_deprecated_flag_in_items() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn renders_docs() {
         check_kinds(
             "#]],
         )
     }
-
     #[test]
     fn dont_render_attrs() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn no_call_parens_if_fn_ptr_needed() {
         cov_mark::check!(no_call_parens_if_fn_ptr_needed);
 "#,
         );
     }
-
     #[test]
     fn no_parens_in_use_item() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn no_parens_in_call() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn inserts_angle_brackets_for_generics() {
         cov_mark::check!(inserts_angle_brackets_for_generics);
 "#,
         );
     }
-
     #[test]
     fn active_param_relevance() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn record_field_relevances() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn tuple_field_detail() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_field_and_call_relevances() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn prioritize_exact_ref_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn too_many_arguments() {
         cov_mark::check!(too_many_arguments);
             "#]],
         );
     }
-
     #[test]
     fn score_fn_type_and_name_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn score_method_type_and_name_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn score_method_name_match_only() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn test_avoid_redundant_suggestion() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn suggest_ref_mut() {
         cov_mark::check!(suggest_ref);
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_copy() {
         cov_mark::check!(suggest_deref);
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_trait() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn suggest_deref_mut() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn locals() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_owned() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_ref() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_fn_ret() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn op_function_relevances() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_simple() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_kind() {
         check_function_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_relevance() {
         check_relevance(
 
         //
     }
-
     #[test]
     fn function_relevance_generic_1() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn function_relevance_generic_2() {
         // Generic 2
             "#]],
         );
     }
-
     #[test]
     fn struct_field_method_ref() {
         check_kinds(
             "#]],
         );
     }
-
     #[test]
     fn expected_fn_type_ref() {
         check_kinds(
             "#]],
         )
     }
-
     #[test]
     fn qualified_path_ref() {
         check_kinds(
             "#]],
         );
     }
-
     #[test]
     fn generic_enum() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn postfix_exact_match_is_high_priority() {
         cov_mark::check!(postfix_exact_match_is_high_priority);
             "#]],
         );
     }
-
     #[test]
     fn postfix_inexact_match_is_low_priority() {
         cov_mark::check!(postfix_inexact_match_is_low_priority);
             "#]],
         );
     }
-
     #[test]
     fn flyimport_reduced_relevance() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn completes_struct_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_fn_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_macro_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_variant_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_field_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_const_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_type_alias_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn field_access_includes_self() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn notable_traits_method_relevance() {
         check_kinds(