COMPARISON DIFF
============================================================

Original size: 98473 bytes
Chloro size:   98217 bytes
Rustfmt size:  98473 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 pub(crate) mod union_literal;
 pub(crate) mod variant;
 
-use hir::{AsAssocItem, HasAttrs, HirDisplay, ModuleDef, ScopeDef, Type, sym};
+use hir::{sym, AsAssocItem, HasAttrs, HirDisplay, ModuleDef, ScopeDef, Type};
 use ide_db::text_edit::TextEdit;
 use ide_db::{
-    RootDatabase, SnippetCap, SymbolKind,
     documentation::{Documentation, HasDocs},
     helpers::item_name,
     imports::import_assets::LocatedImport,
+    RootDatabase, SnippetCap, SymbolKind,
 };
-use syntax::{AstNode, SmolStr, SyntaxKind, TextRange, ToSmolStr, ast, format_smolstr};
+use syntax::{ast, format_smolstr, AstNode, SmolStr, SyntaxKind, TextRange, ToSmolStr};
 
 use crate::{
-    CompletionContext, CompletionItem, CompletionItemKind, CompletionItemRefMode,
-    CompletionRelevance,
     context::{DotAccess, DotAccessKind, PathCompletionCtx, PathKind, PatternContext},
     item::{Builder, CompletionRelevanceTypeMatch},
     render::{
-        function::render_fn,
-        literal::render_variant_lit,
+        function::render_fn, literal::render_variant_lit,
         macro_::{render_macro, render_macro_pat},
     },
+    CompletionContext, CompletionItem, CompletionItemKind, CompletionItemRefMode,
+    CompletionRelevance,
 };
+
 /// Interface for data and methods required for items rendering.
 #[derive(Debug, Clone)]
 pub(crate) struct RenderContext<'a> {
         CompletionRelevance {
             is_private_editable: self.is_private_editable,
             requires_import: self.import_to_add.is_some(),
-            ..Default::default()
         }
     }
 
                 .unwrap_or(false)
     }
 
-    // FIXME: remove this
     fn docs(&self, def: impl HasDocs) -> Option<Documentation> {
         def.docs(self.db())
     }
 }
 
 fn field_with_receiver(receiver: Option<&str>, field_name: &str) -> SmolStr {
-    receiver
-        .map_or_else(|| field_name.into(), |receiver| format_smolstr!("{}.{field_name}", receiver))
+    receiver.map_or_else(
+        || field_name.into(),
+        |receiver| format_smolstr!("{}.{field_name}", receiver),
+    )
 }
 
 pub(crate) fn render_tuple_field(
     // <https://github.com/rust-lang/rust-analyzer/issues/14079>
 
     // If `item_to_import` matches `original_item`, we are importing the item itself (not its parent module).
+
     // In this case, we can use the last segment of `import_path`, as it accounts for the aliased name.
     if import_edit.item_to_import == import_edit.original_item {
         import_edit.import_path.segments().last().cloned()
     }
 }
 
-// FIXME: This checks types without possible coercions which some completions might want to do
 fn match_types(
     ctx: &CompletionContext<'_>,
     ty1: &hir::Type<'_>,
     let expected_type = ctx.expected_type.as_ref()?;
 
     // We don't ever consider unit type to be an exact type match, since
+
     // nearly always this is not meaningful to the user.
     if expected_type.is_unit() {
         return None;
     if let Some(original_path) = &path_ctx.original_path {
         // At least one char was typed by the user already, in that case look for the original path
         if let Some(original_path) = completion.sema.original_ast_node(original_path.clone())
-            && let Some(ref_mode) = compute_ref_match(completion, ty)
-        {
+            && let Some(ref_mode) = compute_ref_match(completion, ty) {
             item.ref_match(ref_mode, original_path.syntax().text_range().start());
         }
     } else {
 #[cfg(test)]
 mod tests {
     use std::cmp;
-
-    use expect_test::{Expect, expect};
+    use expect_test::{expect, Expect};
     use ide_db::SymbolKind;
     use itertools::Itertools;
-
     use crate::{
-        CompletionItem, CompletionItemKind, CompletionRelevance, CompletionRelevancePostfixMatch,
         item::CompletionRelevanceTypeMatch,
-        tests::{TEST_CONFIG, check_edit, do_completion, get_all_items},
+        tests::{check_edit, do_completion, get_all_items, TEST_CONFIG},
+        CompletionItem, CompletionItemKind, CompletionRelevance, CompletionRelevancePostfixMatch,
     };
-
     #[track_caller]
     fn check(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         let actual = do_completion(ra_fixture, kind.into());
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_kinds(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
             kinds.iter().flat_map(|&kind| do_completion(ra_fixture, kind)).collect();
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_function_relevance(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let actual: Vec<_> =
 
         expect.assert_debug_eq(&actual);
     }
-
     #[track_caller]
     fn check_relevance_for_kinds(
         #[rust_analyzer::rust_fixture] ra_fixture: &str,
         actual.sort_by_key(|it| (cmp::Reverse(it.relevance.score()), it.label.primary.clone()));
         check_relevance_(actual, expect);
     }
-
     #[track_caller]
     fn check_relevance(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);
         actual.sort_by_key(|it| (cmp::Reverse(it.relevance.score()), it.label.primary.clone()));
         check_relevance_(actual, expect);
     }
-
     #[track_caller]
     fn check_relevance_(actual: Vec<CompletionItem>, expect: Expect) {
         let actual = actual
             format!("[{relevance_factors}]")
         }
     }
-
     #[test]
     fn set_struct_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_union_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_enum_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_enum_variant_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_fn_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_const_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_static_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_self_type_completion_info_with_params() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_self_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn set_builtin_type_completion_info() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_includes_record_fields() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_includes_tuple_fields() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_detail_includes_args_and_return_type() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn fn_detail_includes_variadics() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn enum_detail_just_name_for_unit() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn lookup_enums_by_two_qualifiers() {
         check_kinds(
 fn main() { let _: m::Spam = S$0 }
 "#,
             &[
-                CompletionItemKind::SymbolKind(SymbolKind::Function),
-                CompletionItemKind::SymbolKind(SymbolKind::Module),
-                CompletionItemKind::SymbolKind(SymbolKind::Variant),
-            ],
+            CompletionItemKind::SymbolKind(SymbolKind::Function),
+            CompletionItemKind::SymbolKind(SymbolKind::Module),
+            CompletionItemKind::SymbolKind(SymbolKind::Variant),
+        ],
             expect![[r#"
                 [
                     CompletionItem {
             "#]],
         )
     }
-
     #[test]
     fn sets_deprecated_flag_in_items() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn renders_docs() {
         check_kinds(
 use self::E::*;
 "#,
             &[
-                CompletionItemKind::SymbolKind(SymbolKind::Module),
-                CompletionItemKind::SymbolKind(SymbolKind::Variant),
-                CompletionItemKind::SymbolKind(SymbolKind::Enum),
-            ],
+            CompletionItemKind::SymbolKind(SymbolKind::Module),
+            CompletionItemKind::SymbolKind(SymbolKind::Variant),
+            CompletionItemKind::SymbolKind(SymbolKind::Enum),
+        ],
             expect![[r#"
                 [
                     CompletionItem {
             "#]],
         )
     }
-
     #[test]
     fn dont_render_attrs() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn no_call_parens_if_fn_ptr_needed() {
         cov_mark::check!(no_call_parens_if_fn_ptr_needed);
 "#,
         );
     }
-
     #[test]
     fn no_parens_in_use_item() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn no_parens_in_call() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn inserts_angle_brackets_for_generics() {
         cov_mark::check!(inserts_angle_brackets_for_generics);
 "#,
         );
     }
-
     #[test]
     fn active_param_relevance() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn record_field_relevances() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn tuple_field_detail() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn record_field_and_call_relevances() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn prioritize_exact_ref_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn too_many_arguments() {
         cov_mark::check!(too_many_arguments);
             "#]],
         );
     }
-
     #[test]
     fn score_fn_type_and_name_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn score_method_type_and_name_match() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn score_method_name_match_only() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn test_avoid_redundant_suggestion() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn suggest_ref_mut() {
         cov_mark::check!(suggest_ref);
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_copy() {
         cov_mark::check!(suggest_deref);
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_trait() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn suggest_deref_mut() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn locals() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_owned() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn enum_ref() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn suggest_deref_fn_ret() {
         check_relevance(
             "#]],
         )
     }
-
     #[test]
     fn op_function_relevances() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_simple() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_kind() {
         check_function_relevance(
             "#]],
         );
     }
-
     #[test]
     fn constructor_order_relevance() {
         check_relevance(
 
         //
     }
-
     #[test]
     fn function_relevance_generic_1() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn function_relevance_generic_2() {
         // Generic 2
             "#]],
         );
     }
-
     #[test]
     fn struct_field_method_ref() {
         check_kinds(
             "#]],
         );
     }
-
     #[test]
     fn expected_fn_type_ref() {
         check_kinds(
             "#]],
         )
     }
-
     #[test]
     fn qualified_path_ref() {
         check_kinds(
             "#]],
         );
     }
-
     #[test]
     fn generic_enum() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn postfix_exact_match_is_high_priority() {
         cov_mark::check!(postfix_exact_match_is_high_priority);
             "#]],
         );
     }
-
     #[test]
     fn postfix_inexact_match_is_low_priority() {
         cov_mark::check!(postfix_inexact_match_is_low_priority);
             "#]],
         );
     }
-
     #[test]
     fn flyimport_reduced_relevance() {
         check_relevance(
             "#]],
         );
     }
-
     #[test]
     fn completes_struct_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_fn_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_macro_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_variant_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_field_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_const_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn completes_type_alias_with_raw_identifier() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn field_access_includes_self() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn notable_traits_method_relevance() {
         check_kinds(