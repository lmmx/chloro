COMPARISON DIFF
============================================================

Original size: 9425 bytes
Chloro size:   9414 bytes
Rustfmt size:  9638 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     // For `mod $0`, `ctx.module` is its parent, but for `mod f$0`, it's `mod f` itself, but we're
     // interested in its parent.
     if ctx.original_token.kind() == SyntaxKind::IDENT
-        && let Some(module) = ctx
-            .original_token
-            .parent_ancestors()
-            .nth(1)
-            .and_then(ast::Module::cast)
+        && let Some(module) =
+            ctx.original_token.parent_ancestors().nth(1).and_then(ast::Module::cast)
     {
         match ctx.sema.to_def(&module) {
             Some(module) if module == current_module => {
         }
     }
 
-    let module_definition_file = current_module
-        .definition_source_file_id(ctx.db)
-        .original_file(ctx.db);
-    let source_root_id = ctx
-        .db
-        .file_source_root(module_definition_file.file_id(ctx.db))
-        .source_root_id(ctx.db);
+    let module_definition_file =
+        current_module.definition_source_file_id(ctx.db).original_file(ctx.db);
+    let source_root_id =
+        ctx.db.file_source_root(module_definition_file.file_id(ctx.db)).source_root_id(ctx.db);
     let source_root = ctx.db.source_root(source_root_id).source_root(ctx.db);
 
     let directory_to_look_for_submodules = directory_to_look_for_submodules(
 
     let existing_mod_declarations = current_module
         .children(ctx.db)
-        .filter_map(|module| {
-            Some(
-                module
-                    .name(ctx.db)?
-                    .display(ctx.db, ctx.edition)
-                    .to_string(),
-            )
-        })
+        .filter_map(|module| Some(module.name(ctx.db)?.display(ctx.db, ctx.edition).to_string()))
         .filter(|module| module != ctx.original_token.text())
         .collect::<FxHashSet<_>>();
 
     let module_declaration_file =
-        current_module
-            .declaration_source_range(ctx.db)
-            .map(|module_declaration_source_file| {
-                module_declaration_source_file.file_id.original_file(ctx.db)
-            });
+        current_module.declaration_source_range(ctx.db).map(|module_declaration_source_file| {
+            module_declaration_source_file.file_id.original_file(ctx.db)
+        });
 
     source_root
         .iter()
     current_module: Module,
     db: &RootDatabase,
 ) -> Vec<Module> {
-    let mut path = iter::successors(Some(current_module), |current_module| {
-        current_module.parent(db)
-    })
-    .take_while(|current_module| current_module.is_inline(db))
-    .collect::<Vec<_>>();
+    let mut path =
+        iter::successors(Some(current_module), |current_module| current_module.parent(db))
+            .take_while(|current_module| current_module.is_inline(db))
+            .collect::<Vec<_>>();
     path.reverse();
     path
 }
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::tests::check;
-
     #[test]
     fn lib_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn no_module_completion_with_module_body() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn main_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn main_test_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn directly_nested_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn nested_in_source_module_completion() {
         check(
             "#]],
         );
     }
-
     // FIXME binary modules are not supported in tests properly
     // Binary modules are a bit special, they allow importing the modules from `/src/bin`
     // and that's why are good to test two things:
     //         "#]],foo
     //     );
     // }
-
     #[test]
     fn already_declared_bin_module_completion_omitted() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn name_partially_typed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn semi_colon_completion() {
         check(