COMPARISON DIFF
============================================================

Original size: 9425 bytes
Chloro size:   9366 bytes
Rustfmt size:  9425 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Completes mod declarations.
 
 use std::iter;
 
 use hir::Module;
 use ide_db::{
-    FxHashSet, RootDatabase, SymbolKind,
     base_db::{SourceDatabase, VfsPath},
+    FxHashSet, RootDatabase, SymbolKind,
 };
-use syntax::{AstNode, SyntaxKind, ast};
+use syntax::{ast, AstNode, SyntaxKind};
 
-use crate::{CompletionItem, Completions, context::CompletionContext};
+use crate::{context::CompletionContext, CompletionItem, Completions};
 
 /// Complete mod declaration, i.e. `mod $0;`
 pub(crate) fn complete_mod(
         }
     }
 
-    let module_definition_file =
-        current_module.definition_source_file_id(ctx.db).original_file(ctx.db);
-    let source_root_id =
-        ctx.db.file_source_root(module_definition_file.file_id(ctx.db)).source_root_id(ctx.db);
+    let module_definition_file = current_module.definition_source_file_id(ctx.db).original_file(ctx.db);
+    let source_root_id = ctx.db.file_source_root(module_definition_file.file_id(ctx.db)).source_root_id(ctx.db);
     let source_root = ctx.db.source_root(source_root_id).source_root(ctx.db);
 
     let directory_to_look_for_submodules = directory_to_look_for_submodules(
         .children(ctx.db)
         .filter_map(|module| Some(module.name(ctx.db)?.display(ctx.db, ctx.edition).to_string()))
         .filter(|module| module != ctx.original_token.text())
-        .collect::<FxHashSet<_>>();
+        .collect();
 
-    let module_declaration_file =
-        current_module.declaration_source_range(ctx.db).map(|module_declaration_source_file| {
+    let module_declaration_file = current_module
+        .declaration_source_range(ctx.db)
+        .map(|module_declaration_source_file| {
             module_declaration_source_file.file_id.original_file(ctx.db)
         });
 
     current_module: Module,
     db: &RootDatabase,
 ) -> Vec<Module> {
-    let mut path =
-        iter::successors(Some(current_module), |current_module| current_module.parent(db))
-            .take_while(|current_module| current_module.is_inline(db))
-            .collect::<Vec<_>>();
+    let mut path = iter::successors(Some(current_module), |current_module| current_module.parent(db))
+        .take_while(|current_module| current_module.is_inline(db))
+        .collect();
     path.reverse();
     path
 }
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::tests::check;
-
     #[test]
     fn lib_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn no_module_completion_with_module_body() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn main_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn main_test_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn directly_nested_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn nested_in_source_module_completion() {
         check(
             "#]],
         );
     }
-
     // FIXME binary modules are not supported in tests properly
     // Binary modules are a bit special, they allow importing the modules from `/src/bin`
     // and that's why are good to test two things:
     //         "#]],foo
     //     );
     // }
-
     #[test]
     fn already_declared_bin_module_completion_omitted() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn name_partially_typed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn semi_colon_completion() {
         check(