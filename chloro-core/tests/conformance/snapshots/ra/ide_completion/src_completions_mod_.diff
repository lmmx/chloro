COMPARISON DIFF
============================================================

Original size: 9425 bytes
Chloro size:   9405 bytes
Rustfmt size:  9425 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     if mod_under_caret.item_list().is_some() {
         return None;
     }
-
     let _p = tracing::info_span!("completion::complete_mod").entered();
-
     let mut current_module = ctx.module;
     // For `mod $0`, `ctx.module` is its parent, but for `mod f$0`, it's `mod f` itself, but we're
     // interested in its parent.
             _ => {}
         }
     }
-
     let module_definition_file =
         current_module.definition_source_file_id(ctx.db).original_file(ctx.db);
     let source_root_id =
         ctx.db.file_source_root(module_definition_file.file_id(ctx.db)).source_root_id(ctx.db);
     let source_root = ctx.db.source_root(source_root_id).source_root(ctx.db);
-
     let directory_to_look_for_submodules = directory_to_look_for_submodules(
         current_module,
         ctx.db,
         source_root.path_for_file(&module_definition_file.file_id(ctx.db))?,
     )?;
-
     let existing_mod_declarations = current_module
         .children(ctx.db)
         .filter_map(|module| Some(module.name(ctx.db)?.display(ctx.db, ctx.edition).to_string()))
         .filter(|module| module != ctx.original_token.text())
         .collect::<FxHashSet<_>>();
-
     let module_declaration_file =
         current_module.declaration_source_range(ctx.db).map(|module_declaration_source_file| {
             module_declaration_source_file.file_id.original_file(ctx.db)
         });
-
     source_root
         .iter()
         .filter(|&submodule_candidate_file| {
                 CompletionItem::new(SymbolKind::Module, ctx.source_range(), &label, ctx.edition);
             item.add_to(acc, ctx.db)
         });
-
     Some(())
 }
 
             }
         }
     }?;
-
     module_chain_to_containing_module_file(module, db)
         .into_iter()
         .filter_map(|module| module.name(db))
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::tests::check;
-
     #[test]
     fn lib_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn no_module_completion_with_module_body() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn main_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn main_test_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn directly_nested_module_completion() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn nested_in_source_module_completion() {
         check(
             "#]],
         );
     }
-
     // FIXME binary modules are not supported in tests properly
     // Binary modules are a bit special, they allow importing the modules from `/src/bin`
     // and that's why are good to test two things:
     //         "#]],foo
     //     );
     // }
-
     #[test]
     fn already_declared_bin_module_completion_omitted() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn name_partially_typed() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn semi_colon_completion() {
         check(