COMPARISON DIFF
============================================================

Original size: 36630 bytes
Chloro size:   36558 bytes
Rustfmt size:  37006 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         &[AsyncSugaring::Plain]
     };
     for &sugaring in sugar {
-        add_function_impl_(
-            acc,
-            ctx,
-            replacement_range,
-            func,
-            impl_def,
-            fn_name,
-            sugaring,
-        );
+        add_function_impl_(acc, ctx, replacement_range, func, impl_def, fn_name, sugaring);
     }
 }
 
         "{}fn {}({})",
         async_,
         fn_name.display(ctx.db, ctx.edition),
-        if func.assoc_fn_params(ctx.db).is_empty() {
-            ""
-        } else {
-            ".."
-        }
+        if func.assoc_fn_params(ctx.db).is_empty() { "" } else { ".." }
     );
 
     let completion_kind = CompletionItemKind::SymbolKind(if func.has_self_param(ctx.db) {
     });
 
     let mut item = CompletionItem::new(completion_kind, replacement_range, label, ctx.edition);
-    item.lookup_by(format!(
-        "{}fn {}",
-        async_,
-        fn_name.display(ctx.db, ctx.edition)
-    ))
-    .set_documentation(func.docs(ctx.db))
-    .set_relevance(CompletionRelevance {
-        exact_name_match: true,
-        ..Default::default()
-    });
+    item.lookup_by(format!("{}fn {}", async_, fn_name.display(ctx.db, ctx.edition)))
+        .set_documentation(func.docs(ctx.db))
+        .set_relevance(CompletionRelevance { exact_name_match: true, ..Default::default() });
 
     if let Some(source) = ctx.sema.source(func)
-        && let Some(transformed_fn) =
-            get_transformed_fn(ctx, source.value, impl_def, async_sugaring)
+        && let Some(transformed_fn) = get_transformed_fn(ctx, source.value, impl_def, async_sugaring)
     {
         let function_decl = function_declaration(ctx, &transformed_fn, source.file_id.macro_file());
         match ctx.config.snippet_cap {
         CompletionItem::new(SymbolKind::TypeAlias, replacement_range, label, ctx.edition);
     item.lookup_by(format!("type {alias_name}"))
         .set_documentation(type_alias.docs(ctx.db))
-        .set_relevance(CompletionRelevance {
-            exact_name_match: true,
-            ..Default::default()
-        });
+        .set_relevance(CompletionRelevance { exact_name_match: true, ..Default::default() });
 
     if let Some(source) = ctx.sema.source(type_alias) {
         let assoc_item = ast::AssocItem::TypeAlias(source.value);
 
             let start = transformed_ty.syntax().text_range().start();
 
-            let end = if let Some(end) = transformed_ty
-                .colon_token()
-                .map(|tok| tok.text_range().start())
+            let end = if let Some(end) =
+                transformed_ty.colon_token().map(|tok| tok.text_range().start())
             {
                 end
-            } else if let Some(end) = transformed_ty
-                .eq_token()
-                .map(|tok| tok.text_range().start())
+            } else if let Some(end) = transformed_ty.eq_token().map(|tok| tok.text_range().start())
             {
                 end
             } else if let Some(end) = transformed_ty
                 .map(|tok| tok.text_range().start())
             {
                 end
-            } else if let Some(end) = transformed_ty
-                .semicolon_token()
-                .map(|tok| tok.text_range().start())
+            } else if let Some(end) =
+                transformed_ty.semicolon_token().map(|tok| tok.text_range().start())
             {
                 end
             } else {
     const_: hir::Const,
     impl_def: hir::Impl,
 ) {
-    let const_name = const_
-        .name(ctx.db)
-        .map(|n| n.display_no_db(ctx.edition).to_smolstr());
+    let const_name = const_.name(ctx.db).map(|n| n.display_no_db(ctx.edition).to_smolstr());
 
     if let Some(const_name) = const_name
         && let Some(source) = ctx.sema.source(const_)
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::tests::{check, check_edit, check_no_kw};
-
     #[test]
     fn no_completion_inside_fn() {
         check_no_kw(
             "#]],
         );
     }
-
     #[test]
     fn no_completion_inside_const() {
         check_no_kw(
             expect![[""]],
         );
     }
-
     #[test]
     fn no_completion_inside_type() {
         check_no_kw(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn name_ref_single_function() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn single_function() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn generic_fn() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn associated_type() {
         check_edit(
 ",
         );
     }
-
     #[test]
     fn associated_const() {
         check_edit(
 ",
         );
     }
-
     #[test]
     fn fn_with_lifetimes() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_without_name() {
         let test = |completion: &str, hint: &str, completed: &str, next_sibling: &str| {
         // Enumerate some possible next siblings.
         for next_sibling in [
             "",
-            "fn other_fn() {}", // `const $0 fn` -> `const fn`
+            "fn other_fn() {}",
             "type OtherType = i32;",
             "const OTHER_CONST: i32 = 0;",
             "async fn other_fn() {}",
         ] {
             test("fn bar", "fn $0", "fn bar() {\n    $0\n}", next_sibling);
             test("type Foo", "type $0", "type Foo = $0;", next_sibling);
-            test(
-                "const CONST",
-                "const $0",
-                "const CONST: u16 = $0;",
-                next_sibling,
-            );
+            test("const CONST", "const $0", "const CONST: u16 = $0;", next_sibling);
         }
     }
-
     #[test]
     fn snippet_does_not_overwrite_comment_or_attr() {
         let test = |completion: &str, hint: &str, completed: &str| {
         test("type Type", "type T$0", "type Type = $0;");
         test("const CONST", "const C$0", "const CONST: i32 = $0;");
     }
-
     #[test]
     fn generics_are_inlined_in_return_type() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn generics_are_inlined_in_parameter() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn generics_are_inlined_when_part_of_other_types() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn generics_are_inlined_complex() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn generics_are_inlined_in_associated_const() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn generics_are_inlined_in_where_clause() {
         check_edit(
 "#,
         )
     }
-
     #[test]
     fn works_directly_in_impl() {
         check_no_kw(
         "#]],
         );
     }
-
     #[test]
     fn fixes_up_macro_generated() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn macro_generated_assoc_item() {
         check_edit(
 "#,
         );
     }
-
     // FIXME: `T` in `ty!(T)` should be replaced by `PathTransform`.
     #[test]
     fn macro_generated_assoc_item2() {
 "#,
         );
     }
-
     #[test]
     fn includes_gat_generics() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn strips_comments() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn impl_fut() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn impl_fut_resugared() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn async_desugared() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn async_() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn within_attr_macro() {
         check(