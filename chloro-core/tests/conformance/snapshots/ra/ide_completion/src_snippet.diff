COMPARISON DIFF
============================================================

Original size: 7279 bytes
Chloro size:   7333 bytes
Rustfmt size:  7507 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! User (postfix)-snippet definitions.
 //!
 //! Actual logic is implemented in [`crate::completions::postfix`] and [`crate::completions::snippet`] respectively.
-
 // Feature: User Snippet Completions
 //
 // rust-analyzer allows the user to define custom (postfix)-snippets that may depend on items to be accessible for the current scope to be applicable.
 // * `description` is an optional description of the snippet, if unset the snippet name will be used.
 //
 // * `requires` is an optional list of item paths that have to be resolvable in the current crate where the completion is rendered.
-
 // On failure of resolution the snippet won't be applicable, otherwise the snippet will insert an import for the items on insertion if
 // the items aren't yet in scope.
 //
         }
         let (requires, snippet, description) = validate_snippet(snippet, description, requires)?;
         Some(Snippet {
-            postfix_triggers: postfix_triggers
-                .iter()
-                .map(String::as_str)
-                .map(Into::into)
-                .collect(),
-            prefix_triggers: prefix_triggers
-                .iter()
-                .map(String::as_str)
-                .map(Into::into)
-                .collect(),
+            postfix_triggers: postfix_triggers.iter().map(String::as_str).map(Into::into).collect(),
+            prefix_triggers: prefix_triggers.iter().map(String::as_str).map(Into::into).collect(),
             scope,
             snippet,
             description,
     }
 
     /// Returns [`None`] if the required items do not resolve.
-    pub(crate) fn imports(&self, ctx: &CompletionContext<'_>) -> Option<Vec<LocatedImport>> {
+    pub(crate) fn imports(
+        &self,
+        ctx: &CompletionContext<'_>,
+    ) -> Option<Vec<LocatedImport>> {
         import_edits(ctx, &self.requires)
     }
 
         self.snippet.replace("${receiver}", "$0")
     }
 
-    pub fn postfix_snippet(&self, receiver: &str) -> String {
+    pub fn postfix_snippet(
+        &self,
+        receiver: &str,
+    ) -> String {
         self.snippet.replace("${receiver}", receiver)
     }
 }
 
-fn import_edits(ctx: &CompletionContext<'_>, requires: &[ModPath]) -> Option<Vec<LocatedImport>> {
+fn import_edits(
+    ctx: &CompletionContext<'_>,
+    requires: &[ModPath],
+) -> Option<Vec<LocatedImport>> {
     let import_cfg = ctx.config.find_path_config(ctx.is_nightly);
-
     let resolve = |import| {
         let item = ctx.scope.resolve_mod_path(import).next()?;
         let path = ctx.module.find_use_path(
     for path in requires.iter() {
         let use_path = ModPath::from_segments(
             hir::PathKind::Plain,
-            path.split("::")
-                .map(Symbol::intern)
-                .map(Name::new_symbol_root),
+            path.split("::").map(Symbol::intern).map(Name::new_symbol_root),
         );
         imports.push(use_path);
     }
     let snippet = snippet.iter().join("\n");
     let description = (!description.is_empty())
-        .then(|| {
-            description
-                .split_once('\n')
-                .map_or(description, |(it, _)| it)
-        })
+        .then(|| description.split_once('\n').map_or(description, |(it, _)| it))
         .map(ToOwned::to_owned)
         .map(Into::into);
     Some((imports.into_boxed_slice(), snippet, description))