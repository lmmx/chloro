COMPARISON DIFF
============================================================

Original size: 7279 bytes
Chloro size:   7300 bytes
Rustfmt size:  7507 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 // * `description` is an optional description of the snippet, if unset the snippet name will be used.
 //
 // * `requires` is an optional list of item paths that have to be resolvable in the current crate where the completion is rendered.
-
 // On failure of resolution the snippet won't be applicable, otherwise the snippet will insert an import for the items on insertion if
 // the items aren't yet in scope.
 //
 //     }
 // }
 // ````
-
 use hir::{ModPath, Name, Symbol};
 use ide_db::imports::import_assets::LocatedImport;
 use itertools::Itertools;
             return None;
         }
         let (requires, snippet, description) = validate_snippet(snippet, description, requires)?;
-        Some(Snippet {
-            postfix_triggers: postfix_triggers
-                .iter()
-                .map(String::as_str)
-                .map(Into::into)
-                .collect(),
-            prefix_triggers: prefix_triggers
-                .iter()
-                .map(String::as_str)
-                .map(Into::into)
-                .collect(),
+        Some(
+            Snippet {
+            postfix_triggers: postfix_triggers.iter().map(String::as_str).map(Into::into).collect(),
+            prefix_triggers: prefix_triggers.iter().map(String::as_str).map(Into::into).collect(),
             scope,
             snippet,
             description,
             requires,
-        })
+        },
+        )
     }
 
     /// Returns [`None`] if the required items do not resolve.
     for path in requires.iter() {
         let use_path = ModPath::from_segments(
             hir::PathKind::Plain,
-            path.split("::")
-                .map(Symbol::intern)
-                .map(Name::new_symbol_root),
+            path.split("::").map(Symbol::intern).map(Name::new_symbol_root),
         );
         imports.push(use_path);
     }
     let snippet = snippet.iter().join("\n");
     let description = (!description.is_empty())
-        .then(|| {
-            description
-                .split_once('\n')
-                .map_or(description, |(it, _)| it)
-        })
+        .then(|| description.split_once('\n').map_or(description, |(it, _)| it))
         .map(ToOwned::to_owned)
         .map(Into::into);
     Some((imports.into_boxed_slice(), snippet, description))