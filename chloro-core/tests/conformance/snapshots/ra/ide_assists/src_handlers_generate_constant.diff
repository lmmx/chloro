COMPARISON DIFF
============================================================

Original size: 7755 bytes
Chloro size:   7808 bytes
Rustfmt size:  8317 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use crate::assist_context::{AssistContext, Assists};
 use hir::{HasVisibility, HirDisplay, Module};
 use ide_db::{
     assists::AssistId,
     AstNode, Direction, SyntaxKind, TextSize,
 };
 
+use crate::assist_context::{AssistContext, Assists};
+
+
 // Assist: generate_constant
+
 //
+
 // Generate a named constant.
+
 //
-// ```
-// struct S { i: usize }
-// impl S { pub fn new(n: usize) {} }
-// fn main() {
-//     let v = S::new(CAPA$0CITY);
-// }
-// ```
-// ->
-// ```
-// struct S { i: usize }
-// impl S { pub fn new(n: usize) {} }
-// fn main() {
-//     const CAPACITY: usize = $0;
-//     let v = S::new(CAPACITY);
-// }
+
 // ```
 
+// struct S { i: usize }
+
+// impl S { pub fn new(n: usize) {} }
+
+// fn main() {
+
+//     let v = S::new(CAPA$0CITY);
+
+// }
+
+// ```
+
+// ->
+
+// ```
+
+// struct S { i: usize }
+
+// impl S { pub fn new(n: usize) {} }
+
+// fn main() {
+
+//     const CAPACITY: usize = $0;
+
+//     let v = S::new(CAPACITY);
+
+// }
+
+// ```
 pub(crate) fn generate_constant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let constant_token = ctx.find_node_at_offset::<ast::NameRef>()?;
-    if constant_token
-        .to_string()
-        .chars()
-        .any(|it| !(it.is_uppercase() || it == '_'))
-    {
+    if constant_token.to_string().chars().any(|it| !(it.is_uppercase() || it == '_')) {
         cov_mark::hit!(not_constant_name);
         return None;
     }
         cov_mark::hit!(already_defined);
         return None;
     }
-    let expr = constant_token
-        .syntax()
-        .ancestors()
-        .find_map(ast::Expr::cast)?;
+    let expr = constant_token.syntax().ancestors().find_map(ast::Expr::cast)?;
     let statement = expr.syntax().ancestors().find_map(ast::Stmt::cast)?;
     let ty = ctx.sema.type_of_expr(&expr)?;
     let scope = ctx.sema.scope(statement.syntax())?;
     let constant_module = scope.module();
-    let type_name = ty
-        .original()
-        .display_source_code(ctx.db(), constant_module.into(), false)
-        .ok()?;
+    let type_name =
+        ty.original().display_source_code(ctx.db(), constant_module.into(), false).ok()?;
     let target = statement.syntax().parent()?.text_range();
-    let path = constant_token
-        .syntax()
-        .ancestors()
-        .find_map(ast::Path::cast)?;
+    let path = constant_token.syntax().ancestors().find_map(ast::Path::cast)?;
     if path.parent_path().is_some() {
         cov_mark::hit!(not_last_path_segment);
         return None;
         let name_ref_class = NameRefClass::classify(&ctx.sema, &name_ref_value);
         match name_ref_class {
             Some(NameRefClass::Definition(Definition::Module(m), _)) => {
-                if !m
-                    .visibility(ctx.sema.db)
-                    .is_visible_from(ctx.sema.db, constant_module.into())
-                {
+                if !m.visibility(ctx.sema.db).is_visible_from(ctx.sema.db, constant_module.into()) {
                     return None;
                 }
                 outer_exists = true;
         target_data_for_generate_constant(ctx, current_module, constant_module).unwrap_or_else(
             || {
                 let indent = IndentLevel::from_node(statement.syntax());
-                (
-                    statement.syntax().text_range().start(),
-                    indent,
-                    None,
-                    format!("\n{indent}"),
-                )
+                (statement.syntax().text_range().start(), indent, None, format!("\n{indent}"))
             },
         );
 
         "Generate constant",
         target,
         |builder| {
-            if let Some(file_id) = file_id {
-                builder.edit_file(file_id);
-            }
-            builder.insert(offset, format!("{text}{post_string}"));
-        },
+        if let Some(file_id) = file_id {
+            builder.edit_file(file_id);
+        }
+        builder.insert(offset, format!("{text}{post_string}"));
+    },
     )
 }
 
     type_name: String,
 ) -> Option<String> {
     let constant_token = not_exist_name_ref.pop()?;
-    let vis = if not_exist_name_ref.is_empty() && !outer_exists {
-        ""
-    } else {
-        "\npub "
-    };
+    let vis = if not_exist_name_ref.is_empty() && !outer_exists { "" } else { "\npub " };
     let mut text = format!("{vis}const {constant_token}: {type_name} = $0;");
     while let Some(name_ref) = not_exist_name_ref.pop() {
-        let vis = if not_exist_name_ref.is_empty() && !outer_exists {
-            ""
-        } else {
-            "\npub "
-        };
+        let vis = if not_exist_name_ref.is_empty() && !outer_exists { "" } else { "\npub " };
         text = text.replace('\n', "\n    ");
         text = format!("{vis}mod {name_ref} {{{text}\n}}");
     }
             let indent = IndentLevel::from_node(module_node.syntax());
             let l_curly_token = module_node.item_list()?.l_curly_token()?;
             let offset = l_curly_token.text_range().end();
-
             let siblings_has_newline = l_curly_token
                 .siblings_with_tokens(Direction::Next)
                 .any(|it| it.kind() == SyntaxKind::WHITESPACE && it.to_string().contains('\n'));
-            let post_string = if siblings_has_newline {
-                format!("{indent}")
-            } else {
-                format!("\n{indent}")
-            };
-            Some((
-                offset,
-                indent + 1,
-                Some(file_id.file_id(ctx.db())),
-                post_string,
-            ))
+            let post_string =
+                if siblings_has_newline { format!("{indent}") } else { format!("\n{indent}") };
+            Some((offset, indent + 1, Some(file_id.file_id(ctx.db())), post_string))
         }
-        _ => Some((
-            TextSize::from(0),
-            0.into(),
-            Some(file_id.file_id(ctx.db())),
-            "\n".into(),
-        )),
+        _ => Some((TextSize::from(0), 0.into(), Some(file_id.file_id(ctx.db())), "\n".into())),
     }
 }
 
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn test_trivial() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_constant_with_path() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_constant_with_longer_path() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_constant_with_not_exist_longer_path() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_wont_apply_when_not_last_path_segment() {
         cov_mark::check!(not_last_path_segment);