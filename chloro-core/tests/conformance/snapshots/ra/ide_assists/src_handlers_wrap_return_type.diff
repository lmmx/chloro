COMPARISON DIFF
============================================================

Original size: 53059 bytes
Chloro size:   52837 bytes
Rustfmt size:  53059 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     syntax_helpers::node_ext::{for_each_tail_expr, walk_expr},
 };
 use syntax::{
-    AstNode,
-    ast::{self, Expr, HasGenericArgs, HasGenericParams, syntax_factory::SyntaxFactory},
-    match_ast,
+    ast::{self, syntax_factory::SyntaxFactory, Expr, HasGenericArgs, HasGenericParams},
+    match_ast, AstNode,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
+
 // Assist: wrap_return_type_in_option
+
 //
+
 // Wrap the function's return type into Option.
+
 //
+
 // ```
+
 // # //- minicore: option
+
 // fn foo() -> i32$0 { 42i32 }
+
 // ```
+
 // ->
+
 // ```
+
 // fn foo() -> Option<i32> { Some(42i32) }
+
 // ```
 
 // Assist: wrap_return_type_in_result
+
 //
+
 // Wrap the function's return type into Result.
+
 //
-// ```
-// # //- minicore: result
-// fn foo() -> i32$0 { 42i32 }
-// ```
-// ->
-// ```
-// fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }
+
 // ```
 
+// # //- minicore: result
+
+// fn foo() -> i32$0 { 42i32 }
+
+// ```
+
+// ->
+
+// ```
+
+// fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }
+
+// ```
 pub(crate) fn wrap_return_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;
     let parent = ret_type.syntax().parent()?;
     }
 }
 
-// Try to find an wrapper type alias in the current scope (shadowing the default).
 fn wrapper_alias<'db>(
     ctx: &AssistContext<'db>,
     make: &SyntaxFactory,
             hir::ModuleDef::TypeAlias(alias) => {
                 let enum_ty = alias.ty(ctx.db()).as_adt()?.as_enum()?;
                 (enum_ty == core_wrapper).then_some((alias, enum_ty))
-            }
+            },
             _ => None,
-        })
-        .find_map(|(alias, enum_ty)| {
+        }).find_map(|(alias, enum_ty)| {
             let mut inserted_ret_type = false;
             let generic_args =
                 alias.source(ctx.db())?.value.generic_param_list()?.generic_params().map(|param| {
                         _ => make.type_arg(make.ty_infer().into()).into(),
                     }
                 });
-
             let name = alias.name(ctx.db());
             let generic_arg_list = make.generic_arg_list(generic_args, false);
             let path = make.path_unqualified(
                 make.path_segment_generics(make.name_ref(name.as_str()), generic_arg_list),
             );
-
             let new_ty =
                 hir::Adt::from(enum_ty).ty_with_args(ctx.db(), [semantic_ret_type.clone()]);
-
             Some((make.ty_path(path), new_ty))
         })
     })
             if let Some(break_expr_arg) = break_expr.expr() {
                 for_each_tail_expr(&break_expr_arg, &mut |e| tail_cb_impl(acc, e))
             }
-        }
+        },
         Expr::ReturnExpr(_) => {
-            // all return expressions have already been handled by the walk loop
-        }
+        },
         e => acc.push(e.clone()),
     }
 }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist_by_label, check_assist_not_applicable_by_label};
-
     use super::*;
-
     #[test]
     fn wrap_return_type_in_option_simple() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_break_split_tail() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_closure() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_bad_cursor() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_bad_cursor_closure() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_closure_non_block() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_already_option_std() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_already_option() {
         cov_mark::check!(wrap_return_type_simple_return_type_already_wrapped);
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_already_option_closure() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_cursor() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_closure() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_only() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_without_block_closure() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_nested_if() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_await() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_array() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_cast() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like_match() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_loop_with_tail() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_loop_in_let_stmt() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like_match_return_expr() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like_match_deeper() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like_early_return() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_in_option_tail_position() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_closure() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_weird_forms() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_option_type() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_imported_local_option_type() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_option_type_from_function_body() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_option_type_already_using_alias() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_break_split_tail() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_closure() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_bad_cursor() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_bad_cursor_closure() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_closure_non_block() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_already_result_std() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_already_result() {
         cov_mark::check!(wrap_return_type_simple_return_type_already_wrapped);
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_already_result_closure() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_cursor() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_closure() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_only() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_without_block_closure() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_nested_if() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_await() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_array() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_cast() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like_match() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_loop_with_tail() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_loop_in_let_stmt() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like_match_return_expr() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like_match_deeper() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like_early_return() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_in_result_tail_position() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_closure() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_weird_forms() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_result_type() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_imported_local_result_type() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_result_type_from_function_body() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_result_type_already_using_alias() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_result_type_multiple_generics() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn already_wrapped() {
         check_assist_by_label(