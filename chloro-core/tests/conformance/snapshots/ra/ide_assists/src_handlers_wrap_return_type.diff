COMPARISON DIFF
============================================================

Original size: 53059 bytes
Chloro size:   52992 bytes
Rustfmt size:  53380 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
                 let alias = wrapper_alias(ctx, &make, core_wrapper, type_ref, &ty, kind.symbol());
                 let (ast_new_return_ty, semantic_new_return_ty) = alias.unwrap_or_else(|| {
                     let (ast_ty, ty_constructor) = match kind {
-                        WrapperKind::Option => (
-                            make.ty_option(type_ref.clone()),
-                            famous_defs.core_option_Option(),
-                        ),
+                        WrapperKind::Option => {
+                            (make.ty_option(type_ref.clone()), famous_defs.core_option_Option())
+                        }
                         WrapperKind::Result => (
                             make.ty_result(type_ref.clone(), make.ty_infer().into()),
                             famous_defs.core_result_Result(),
 
                 for ret_expr_arg in exprs_to_wrap {
                     if let Some(ty) = ctx.sema.type_of_expr(&ret_expr_arg)
-                        && ty
-                            .adjusted()
-                            .could_unify_with(ctx.db(), &semantic_new_return_ty)
+                        && ty.adjusted().could_unify_with(ctx.db(), &semantic_new_return_ty)
                     {
                         // The type is already correct, don't wrap it.
                         // We deliberately don't use `could_unify_with_deeply()`, because as long as the outer
         iter::once(hir::Name::new_symbol_root(wrapper)),
     );
 
-    ctx.sema
-        .resolve_mod_path(ast_ret_type.syntax(), &wrapper_path)
-        .and_then(|def| {
-            def.filter_map(|def| match def.into_module_def() {
-                hir::ModuleDef::TypeAlias(alias) => {
-                    let enum_ty = alias.ty(ctx.db()).as_adt()?.as_enum()?;
-                    (enum_ty == core_wrapper).then_some((alias, enum_ty))
-                }
-                _ => None,
-            })
-            .find_map(|(alias, enum_ty)| {
-                let mut inserted_ret_type = false;
-                let generic_args = alias
-                    .source(ctx.db())?
-                    .value
-                    .generic_param_list()?
-                    .generic_params()
-                    .map(|param| {
-                        match param {
-                            // Replace the very first type parameter with the function's return type.
-                            ast::GenericParam::TypeParam(_) if !inserted_ret_type => {
-                                inserted_ret_type = true;
-                                make.type_arg(ast_ret_type.clone()).into()
-                            }
-                            ast::GenericParam::LifetimeParam(_) => {
-                                make.lifetime_arg(make.lifetime("'_")).into()
-                            }
-                            _ => make.type_arg(make.ty_infer().into()).into(),
-                        }
-                    });
-
-                let name = alias.name(ctx.db());
-                let generic_arg_list = make.generic_arg_list(generic_args, false);
-                let path = make.path_unqualified(
-                    make.path_segment_generics(make.name_ref(name.as_str()), generic_arg_list),
-                );
-
-                let new_ty =
-                    hir::Adt::from(enum_ty).ty_with_args(ctx.db(), [semantic_ret_type.clone()]);
-
-                Some((make.ty_path(path), new_ty))
-            })
+    ctx.sema.resolve_mod_path(ast_ret_type.syntax(), &wrapper_path).and_then(|def| {
+        def.filter_map(|def| match def.into_module_def() {
+            hir::ModuleDef::TypeAlias(alias) => {
+                let enum_ty = alias.ty(ctx.db()).as_adt()?.as_enum()?;
+                (enum_ty == core_wrapper).then_some((alias, enum_ty))
+            }
+            _ => None,
         })
+        .find_map(|(alias, enum_ty)| {
+            let mut inserted_ret_type = false;
+            let generic_args =
+                alias.source(ctx.db())?.value.generic_param_list()?.generic_params().map(|param| {
+                    match param {
+                        // Replace the very first type parameter with the function's return type.
+                        ast::GenericParam::TypeParam(_) if !inserted_ret_type => {
+                            inserted_ret_type = true;
+                            make.type_arg(ast_ret_type.clone()).into()
+                        }
+                        ast::GenericParam::LifetimeParam(_) => {
+                            make.lifetime_arg(make.lifetime("'_")).into()
+                        }
+                        _ => make.type_arg(make.ty_infer().into()).into(),
+                    }
+                });
+
+            let name = alias.name(ctx.db());
+            let generic_arg_list = make.generic_arg_list(generic_args, false);
+            let path = make.path_unqualified(
+                make.path_segment_generics(make.name_ref(name.as_str()), generic_arg_list),
+            );
+
+            let new_ty =
+                hir::Adt::from(enum_ty).ty_with_args(ctx.db(), [semantic_ret_type.clone()]);
+
+            Some((make.ty_path(path), new_ty))
+        })
+    })
 }
 
 fn tail_cb_impl(acc: &mut Vec<ast::Expr>, e: &ast::Expr) {
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist_by_label, check_assist_not_applicable_by_label};
-
     use super::*;
-
     #[test]
     fn wrap_return_type_in_option_simple() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_break_split_tail() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_closure() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_bad_cursor() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_bad_cursor_closure() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_closure_non_block() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_already_option_std() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_already_option() {
         cov_mark::check!(wrap_return_type_simple_return_type_already_wrapped);
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_return_type_already_option_closure() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_cursor() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_closure() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_only() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_without_block_closure() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_nested_if() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_await() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_array() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_cast() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like_match() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_loop_with_tail() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_loop_in_let_stmt() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like_match_return_expr() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like_match_deeper() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_tail_block_like_early_return() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_in_option_tail_position() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_closure() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_option_simple_with_weird_forms() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_option_type() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_imported_local_option_type() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_option_type_from_function_body() {
         check_assist_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_option_type_already_using_alias() {
         check_assist_not_applicable_by_label(
             WrapperKind::Option.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_break_split_tail() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_closure() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_bad_cursor() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_bad_cursor_closure() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_closure_non_block() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_already_result_std() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_already_result() {
         cov_mark::check!(wrap_return_type_simple_return_type_already_wrapped);
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_return_type_already_result_closure() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_cursor() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_closure() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_only() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_without_block_closure() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_nested_if() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_await() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_array() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_cast() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like_match() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_loop_with_tail() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_loop_in_let_stmt() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like_match_return_expr() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like_match_deeper() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_tail_block_like_early_return() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_in_result_tail_position() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_closure() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_result_simple_with_weird_forms() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_result_type() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_imported_local_result_type() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_result_type_from_function_body() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_result_type_already_using_alias() {
         check_assist_not_applicable_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn wrap_return_type_in_local_result_type_multiple_generics() {
         check_assist_by_label(
             WrapperKind::Result.label(),
         );
     }
-
     #[test]
     fn already_wrapped() {
         check_assist_by_label(