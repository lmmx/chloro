COMPARISON DIFF
============================================================

Original size: 10526 bytes
Chloro size:   10264 bytes
Rustfmt size:  10803 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use ide_db::{defs::Definition, search::FileReference, EditionedFileId};
+use ide_db::{EditionedFileId, defs::Definition, search::FileReference};
 use syntax::{
+    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,
     algo::{find_node_at_range, least_common_ancestor_element},
     ast::{self, HasArgList},
     syntax_editor::Element,
-    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, T,
+    T,
 };
 
 use SyntaxKind::WHITESPACE;
 
 use crate::{
-    assist_context::SourceChangeBuilder, utils::next_prev, AssistContext, AssistId, Assists,
+    AssistContext, AssistId, Assists, assist_context::SourceChangeBuilder, utils::next_prev,
 };
 
-// Assist: remove_unused_param
-//
-// Removes unused function parameter.
-//
-// ```
-// fn frobnicate(x: i32$0) {}
-//
-// fn main() {
-//     frobnicate(92);
-// }
-// ```
-// ->
-// ```
-// fn frobnicate() {}
-//
-// fn main() {
-//     frobnicate();
-// }
-// ```
 pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let param: ast::Param = ctx.find_node_at_offset()?;
     let ident_pat = match param.pat()? {
         _ => return None,
     };
     let func = param.syntax().ancestors().find_map(ast::Fn::cast)?;
-    let is_self_present = param
-        .syntax()
-        .parent()?
-        .children()
-        .find_map(ast::SelfParam::cast)
-        .is_some();
+    let is_self_present =
+        param.syntax().parent()?.children().find_map(ast::SelfParam::cast).is_some();
 
     // check if fn is in impl Trait for ..
     if func
                 editor.delete(element);
             }
             for (file_id, references) in fn_def.usages(&ctx.sema).all() {
-                process_usages(
-                    ctx,
-                    builder,
-                    file_id,
-                    references,
-                    param_position,
-                    is_self_present,
-                );
+                process_usages(ctx, builder, file_id, references, param_position, is_self_present);
             }
             builder.add_file_edits(ctx.vfs_file_id(), editor);
         },
         .filter_map(|usage| process_usage(&source_file, usage, arg_to_remove, is_self_present));
 
     for element_range in possible_ranges {
-        let Some(SyntaxElement::Node(parent)) = element_range.iter().cloned().reduce(|a, b| {
-            least_common_ancestor_element(&a, &b)
-                .unwrap()
-                .syntax_element()
-        }) else {
+        let Some(SyntaxElement::Node(parent)) = element_range
+            .iter()
+            .cloned()
+            .reduce(|a, b| least_common_ancestor_element(&a, &b).unwrap().syntax_element())
+        else {
             continue;
         };
         let mut editor = builder.make_editor(&parent);
         for element in element_range {
             editor.delete(element);
         }
-
         builder.add_file_edits(file_id, editor);
     }
 }
     });
     if let Some((dir, token)) = up_to_comma {
         let after = token.siblings_with_tokens(dir).nth(1).unwrap();
-        let mut result: Vec<_> = node
-            .siblings_with_tokens(dir)
-            .take_while(|it| it != &after)
-            .collect();
+        let mut result: Vec<_> =
+            node.siblings_with_tokens(dir).take_while(|it| it != &after).collect();
         if node.next_sibling().is_some() {
             result.extend(
-                token
-                    .siblings_with_tokens(dir)
-                    .skip(1)
-                    .take_while(|it| it.kind() == WHITESPACE),
+                token.siblings_with_tokens(dir).skip(1).take_while(|it| it.kind() == WHITESPACE),
             );
         }
-
         result
     } else {
         vec![node.syntax_element()]
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn remove_unused() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_first_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_single_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_surrounded_by_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_qualified_call() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_turbofished_func() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn remove_unused_generic_unused_param_func() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn keep_used() {
         cov_mark::check!(keep_used);
 "#,
         );
     }
-
     #[test]
     fn trait_impl() {
         cov_mark::check!(trait_impl);
 "#,
         );
     }
-
     #[test]
     fn remove_across_files() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_remove_method_param() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn nested_call() {
         check_assist(