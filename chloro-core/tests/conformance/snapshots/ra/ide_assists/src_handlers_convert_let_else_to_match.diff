COMPARISON DIFF
============================================================

Original size: 14334 bytes
Chloro size:   13955 bytes
Rustfmt size:  14420 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
+use syntax::T;
+use syntax::ast::RangeItem;
 use syntax::ast::edit::IndentLevel;
 use syntax::ast::edit_in_place::Indent;
 use syntax::ast::syntax_factory::SyntaxFactory;
-use syntax::ast::RangeItem;
 use syntax::ast::{self, AstNode, HasName, LetStmt, Pat};
-use syntax::T;
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: convert_let_else_to_match
-//
-// Converts let-else statement to let statement and match expression.
-//
-// ```
-// fn main() {
-//     let Ok(mut x) = f() else$0 { return };
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let mut x = match f() {
-//         Ok(x) => x,
-//         _ => return,
-//     };
-// }
-// ```
 pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // Should focus on the `else` token to trigger
     let let_stmt = ctx
         .filter_map(|ref pat| {
             // Identifiers which resolve to constants are not bindings
             if ctx.sema.resolve_bind_pat_to_const(pat).is_none() {
-                Some((
-                    pat.name()?,
-                    pat.ref_token().is_none() && pat.mut_token().is_some(),
-                ))
+                Some((pat.name()?, pat.ref_token().is_none() && pat.mut_token().is_some()))
             } else {
                 None
             }
             }
             non_mut_pat.into()
         }
-        ast::Pat::BoxPat(p) => make
-            .box_pat(remove_mut_and_collect_idents(make, &p.pat()?, acc)?)
-            .into(),
+        ast::Pat::BoxPat(p) => {
+            make.box_pat(remove_mut_and_collect_idents(make, &p.pat()?, acc)?).into()
+        }
         ast::Pat::OrPat(p) => make
             .or_pat(
                 p.pats()
                 p.leading_pipe().is_some(),
             )
             .into(),
-        ast::Pat::ParenPat(p) => make
-            .paren_pat(remove_mut_and_collect_idents(make, &p.pat()?, acc)?)
-            .into(),
+        ast::Pat::ParenPat(p) => {
+            make.paren_pat(remove_mut_and_collect_idents(make, &p.pat()?, acc)?).into()
+        }
         ast::Pat::RangePat(p) => make
             .range_pat(
                 if let Some(start) = p.start() {
                 acc.push(ident);
                 p.clone_for_update().into()
             } else {
-                make.ref_pat(remove_mut_and_collect_idents(make, &inner, acc)?)
-                    .into()
+                make.ref_pat(remove_mut_and_collect_idents(make, &inner, acc)?).into()
             }
         }
         ast::Pat::SlicePat(p) => make
         | ast::Pat::PathPat(_)
         | ast::Pat::WildcardPat(_)
         | ast::Pat::ConstBlockPat(_) => pat.clone(),
-        // don't support macro pat yet
         ast::Pat::MacroPat(_) => return None,
     })
 }
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     #[test]
     fn convert_let_else_to_match_no_type_let() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_on_else() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_no_macropat() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_target() {
         check_assist_target(
             "let Ok(x) = f() else { continue };",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_basic() {
         check_assist(
 }",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_const_ref() {
         check_assist(
 }",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_const_ref_const() {
         check_assist(
 }",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_mut() {
         check_assist(
 }",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_multi_binders() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_slice() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_struct() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_struct_ident_pat() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_no_binder() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_range() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_refpat() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_refmut() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_atpat() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_complex_init() {
         check_assist(