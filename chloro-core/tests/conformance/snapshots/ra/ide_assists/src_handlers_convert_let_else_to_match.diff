COMPARISON DIFF
============================================================

Original size: 14334 bytes
Chloro size:   13273 bytes
Rustfmt size:  14420 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
+use syntax::T;
+use syntax::ast::RangeItem;
 use syntax::ast::edit::IndentLevel;
 use syntax::ast::edit_in_place::Indent;
 use syntax::ast::syntax_factory::SyntaxFactory;
-use syntax::ast::RangeItem;
 use syntax::ast::{self, AstNode, HasName, LetStmt, Pat};
-use syntax::T;
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: convert_let_else_to_match
-//
-// Converts let-else statement to let statement and match expression.
-//
-// ```
-// fn main() {
-//     let Ok(mut x) = f() else$0 { return };
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let mut x = match f() {
-//         Ok(x) => x,
-//         _ => return,
-//     };
-// }
-// ```
 pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // Should focus on the `else` token to trigger
     let let_stmt = ctx
         .filter_map(|ref pat| {
             // Identifiers which resolve to constants are not bindings
             if ctx.sema.resolve_bind_pat_to_const(pat).is_none() {
-                Some((
-                    pat.name()?,
-                    pat.ref_token().is_none() && pat.mut_token().is_some(),
-                ))
+                Some((pat.name()?, pat.ref_token().is_none() && pat.mut_token().is_some()))
             } else {
                 None
             }
     acc.add(
         AssistId::refactor_rewrite("convert_let_else_to_match"),
         if bindings.is_empty() {
-            "Convert let-else to match"
-        } else {
-            "Convert let-else to let and match"
-        },
+        "Convert let-else to match"
+    } else {
+        "Convert let-else to let and match"
+    },
         let_stmt.syntax().text_range(),
         |builder| {
-            let mut editor = builder.make_editor(let_stmt.syntax());
-
-            let binding_paths = bindings
+        let mut editor = builder.make_editor(let_stmt.syntax());
+        let binding_paths = bindings
                 .iter()
                 .map(|(name, _)| make.expr_path(make.ident_path(&name.to_string())))
                 .collect::<Vec<_>>();
-
-            let binding_arm = make.match_arm(
+        let binding_arm = make.match_arm(
                 pat_without_mut,
                 None,
                 // There are three possible cases:
                     _ => make.expr_tuple(binding_paths).into(),
                 },
             );
-            let else_arm = make.match_arm(make.wildcard_pat().into(), None, else_expr);
-            let match_ = make.expr_match(init, make.match_arm_list([binding_arm, else_arm]));
-            match_.reindent_to(IndentLevel::from_node(let_stmt.syntax()));
-
-            if bindings.is_empty() {
+        let else_arm = make.match_arm(make.wildcard_pat().into(), None, else_expr);
+        let match_ = make.expr_match(init, make.match_arm_list([binding_arm, else_arm]));
+        match_.reindent_to(IndentLevel::from_node(let_stmt.syntax()));
+        if bindings.is_empty() {
                 editor.replace(let_stmt.syntax(), match_.syntax());
             } else {
                 let ident_pats = bindings
                 );
                 editor.replace(let_stmt.syntax(), new_let_stmt.syntax());
             }
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
                 non_mut_pat.set_pat(remove_mut_and_collect_idents(make, &inner, acc));
             }
             non_mut_pat.into()
-        }
-        ast::Pat::BoxPat(p) => make
-            .box_pat(remove_mut_and_collect_idents(make, &p.pat()?, acc)?)
-            .into(),
-        ast::Pat::OrPat(p) => make
-            .or_pat(
-                p.pats()
-                    .map(|pat| remove_mut_and_collect_idents(make, &pat, acc))
-                    .collect::<Option<Vec<_>>>()?,
-                p.leading_pipe().is_some(),
-            )
-            .into(),
-        ast::Pat::ParenPat(p) => make
-            .paren_pat(remove_mut_and_collect_idents(make, &p.pat()?, acc)?)
-            .into(),
-        ast::Pat::RangePat(p) => make
-            .range_pat(
-                if let Some(start) = p.start() {
-                    Some(remove_mut_and_collect_idents(make, &start, acc)?)
+        },
+        ast::Pat::BoxPat(p) => {
+            make.box_pat(remove_mut_and_collect_idents(make, &p.pat()?, acc)?).into()
+        },
+        ast::Pat::OrPat(p) => make.or_pat(
+            p.pats().map(|pat| remove_mut_and_collect_idents(make, &pat, acc)).collect::<Option<Vec<_>>>(
+        )?,
+            p.leading_pipe().is_some(),
+        ).into(
+        ),
+        ast::Pat::ParenPat(p) => {
+            make.paren_pat(remove_mut_and_collect_idents(make, &p.pat()?, acc)?).into()
+        },
+        ast::Pat::RangePat(p) => make.range_pat(
+            if let Some(start) = p.start() {
+            Some(remove_mut_and_collect_idents(make, &start, acc)?)
+        } else {
+            None
+        },
+            if let Some(end) = p.end() {
+            Some(remove_mut_and_collect_idents(make, &end, acc)?)
+        } else {
+            None
+        },
+        ).into(
+        ),
+        ast::Pat::RecordPat(p) => make.record_pat_with_fields(
+            p.path()?,
+            make.record_pat_field_list(
+            p.record_pat_field_list()?.fields().map(|field| {
+            remove_mut_and_collect_idents(make, &field.pat()?, acc).map(|pat| {
+                if let Some(name_ref) = field.name_ref() {
+                    make.record_pat_field(name_ref, pat)
                 } else {
-                    None
-                },
-                if let Some(end) = p.end() {
-                    Some(remove_mut_and_collect_idents(make, &end, acc)?)
-                } else {
-                    None
-                },
-            )
-            .into(),
-        ast::Pat::RecordPat(p) => make
-            .record_pat_with_fields(
-                p.path()?,
-                make.record_pat_field_list(
-                    p.record_pat_field_list()?
-                        .fields()
-                        .map(|field| {
-                            remove_mut_and_collect_idents(make, &field.pat()?, acc).map(|pat| {
-                                if let Some(name_ref) = field.name_ref() {
-                                    make.record_pat_field(name_ref, pat)
-                                } else {
-                                    make.record_pat_field_shorthand(pat)
-                                }
-                            })
-                        })
-                        .collect::<Option<Vec<_>>>()?,
-                    p.record_pat_field_list()?.rest_pat(),
-                ),
-            )
-            .into(),
+                    make.record_pat_field_shorthand(pat)
+                }
+            })
+        }).collect::<Option<Vec<_>>>(
+        )?,
+            p.record_pat_field_list()?.rest_pat(),
+        ),
+        ).into(
+        ),
         ast::Pat::RefPat(p) => {
             let inner = p.pat()?;
             if let ast::Pat::IdentPat(ident) = inner {
                 acc.push(ident);
                 p.clone_for_update().into()
             } else {
-                make.ref_pat(remove_mut_and_collect_idents(make, &inner, acc)?)
-                    .into()
+                make.ref_pat(remove_mut_and_collect_idents(make, &inner, acc)?).into()
             }
-        }
-        ast::Pat::SlicePat(p) => make
-            .slice_pat(
-                p.pats()
-                    .map(|pat| remove_mut_and_collect_idents(make, &pat, acc))
-                    .collect::<Option<Vec<_>>>()?,
-            )
-            .into(),
-        ast::Pat::TuplePat(p) => make
-            .tuple_pat(
-                p.fields()
-                    .map(|field| remove_mut_and_collect_idents(make, &field, acc))
-                    .collect::<Option<Vec<_>>>()?,
-            )
-            .into(),
-        ast::Pat::TupleStructPat(p) => make
-            .tuple_struct_pat(
-                p.path()?,
-                p.fields()
-                    .map(|field| remove_mut_and_collect_idents(make, &field, acc))
-                    .collect::<Option<Vec<_>>>()?,
-            )
-            .into(),
+        },
+        ast::Pat::SlicePat(p) => make.slice_pat(p.pats().map(|pat| remove_mut_and_collect_idents(make, &pat, acc)).collect::<Option<Vec<_>>>(
+        )?).into(
+        ),
+        ast::Pat::TuplePat(p) => make.tuple_pat(p.fields().map(|field| remove_mut_and_collect_idents(make, &field, acc)).collect::<Option<Vec<_>>>(
+        )?).into(
+        ),
+        ast::Pat::TupleStructPat(p) => make.tuple_struct_pat(
+            p.path()?,
+            p.fields().map(|field| remove_mut_and_collect_idents(make, &field, acc)).collect::<Option<Vec<_>>>(
+        )?,
+        ).into(
+        ),
         ast::Pat::RestPat(_)
         | ast::Pat::LiteralPat(_)
         | ast::Pat::PathPat(_)
         | ast::Pat::WildcardPat(_)
         | ast::Pat::ConstBlockPat(_) => pat.clone(),
-        // don't support macro pat yet
         ast::Pat::MacroPat(_) => return None,
     })
 }
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     #[test]
     fn convert_let_else_to_match_no_type_let() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_on_else() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_no_macropat() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_target() {
         check_assist_target(
             "let Ok(x) = f() else { continue };",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_basic() {
         check_assist(
 }",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_const_ref() {
         check_assist(
 }",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_const_ref_const() {
         check_assist(
 }",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_mut() {
         check_assist(
 }",
         );
     }
-
     #[test]
     fn convert_let_else_to_match_multi_binders() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_slice() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_struct() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_struct_ident_pat() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_no_binder() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_range() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_refpat() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_refmut() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_atpat() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_let_else_to_match_complex_init() {
         check_assist(