COMPARISON DIFF
============================================================

Original size: 9020 bytes
Chloro size:   8621 bytes
Rustfmt size:  9083 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::fmt::Display;
 
 use hir::{ModPath, ModuleDef};
-use ide_db::{famous_defs::FamousDefs, RootDatabase};
+use ide_db::{RootDatabase, famous_defs::FamousDefs};
 use syntax::{
-    ast::{self, HasName},
     AstNode, Edition, SyntaxNode,
+    ast::{self, HasName},
 };
 
 use crate::{
     AssistId,
 };
 
-// Assist: generate_deref
-//
-// Generate `Deref` impl using the given struct field.
-//
-// ```
-// # //- minicore: deref, deref_mut
-// struct A;
-// struct B {
-//    $0a: A
-// }
-// ```
-// ->
-// ```
-// struct A;
-// struct B {
-//    a: A
-// }
-//
-// impl core::ops::Deref for B {
-//     type Target = A;
-//
-//     fn deref(&self) -> &Self::Target {
-//         &self.a
-//     }
-// }
-// ```
 pub(crate) fn generate_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_record_deref(acc, ctx).or_else(|| generate_tuple_deref(acc, ctx))
 }
 fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;
     let field = ctx.find_node_at_offset::<ast::RecordField>()?;
-
     let deref_type_to_generate = match existing_deref_impl(&ctx.sema, &strukt) {
         None => DerefType::Deref,
         Some(DerefType::Deref) => DerefType::DerefMut,
             return None;
         }
     };
-
     let module = ctx.sema.to_def(&strukt)?.module(ctx.db());
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(module.krate()));
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
     let trait_ = deref_type_to_generate.to_trait(&ctx.sema, module.krate())?;
     let trait_path = module.find_path(ctx.db(), ModuleDef::Trait(trait_), cfg)?;
-
     let field_type = field.ty()?;
     let field_name = field.name()?;
     let target = field.syntax().text_range();
     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;
     let field = ctx.find_node_at_offset::<ast::TupleField>()?;
     let field_list = ctx.find_node_at_offset::<ast::TupleFieldList>()?;
-    let field_list_index = field_list
-        .syntax()
-        .children()
-        .position(|s| &s == field.syntax())?;
-
+    let field_list_index = field_list.syntax().children().position(|s| &s == field.syntax())?;
     let deref_type_to_generate = match existing_deref_impl(&ctx.sema, &strukt) {
         None => DerefType::Deref,
         Some(DerefType::Deref) => DerefType::DerefMut,
             return None;
         }
     };
-
     let module = ctx.sema.to_def(&strukt)?.module(ctx.db());
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(module.krate()));
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
     let trait_ = deref_type_to_generate.to_trait(&ctx.sema, module.krate())?;
     let trait_path = module.find_path(ctx.db(), ModuleDef::Trait(trait_), cfg)?;
-
     let field_type = field.ty()?;
     let target = field.syntax().text_range();
     acc.add(
 ) -> Option<DerefType> {
     let strukt = sema.to_def(strukt)?;
     let krate = strukt.module(sema.db).krate();
-
     let deref_trait = FamousDefs(sema, krate).core_ops_Deref()?;
     let deref_mut_trait = FamousDefs(sema, krate).core_ops_DerefMut()?;
     let strukt_type = strukt.ty(sema.db);
-
     if strukt_type.impls_trait(sema.db, deref_trait, &[]) {
         if strukt_type.impls_trait(sema.db, deref_mut_trait, &[]) {
             Some(DerefType::DerefMut)
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_generate_record_deref() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_record_deref_with_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_record_deref_short_path() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_field_deref_idx_0() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generates_derefmut_when_deref_present() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_record_deref_not_applicable_if_already_impl() {
         cov_mark::check!(test_add_record_deref_impl_already_exists);
 "#,
         )
     }
-
     #[test]
     fn test_generate_field_deref_not_applicable_if_already_impl() {
         cov_mark::check!(test_add_field_deref_impl_already_exists);