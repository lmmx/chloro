COMPARISON DIFF
============================================================

Original size: 17832 bytes
Chloro size:   17632 bytes
Rustfmt size:  18165 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use ide_db::imports::{
     insert_use::{ImportGranularity, InsertUseConfig},
-    merge_imports::{try_merge_imports, try_merge_trees, MergeBehavior},
+    merge_imports::{MergeBehavior, try_merge_imports, try_merge_trees},
 };
 use syntax::{
+    AstNode, SyntaxElement, SyntaxNode,
     algo::neighbor,
     ast::{self, syntax_factory::SyntaxFactory},
     match_ast,
     syntax_editor::Removable,
-    AstNode, SyntaxElement, SyntaxNode,
 };
 
 use crate::{
+    AssistId,
     assist_context::{AssistContext, Assists},
     utils::next_prev,
-    AssistId,
 };
 
 use Edit::*;
 
-// Assist: merge_imports
-//
-// Merges neighbor imports with a common prefix.
-//
-// ```
-// use std::$0fmt::Formatter;
-// use std::io;
-// ```
-// ->
-// ```
-// use std::{fmt::Formatter, io};
-// ```
 pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let (target, edits) = if ctx.has_empty_selection() {
         // Merge a neighbor
         let target = tree.syntax().text_range();
 
         let use_item = tree.syntax().parent().and_then(ast::Use::cast)?;
-        let mut neighbor = next_prev()
-            .find_map(|dir| neighbor(&use_item, dir))
-            .into_iter();
+        let mut neighbor = next_prev().find_map(|dir| neighbor(&use_item, dir)).into_iter();
         let edits = use_item.try_merge_from(&mut neighbor, &ctx.config.insert_use);
         (target, edits?)
     } else {
             SyntaxElement::Node(n) => n,
             SyntaxElement::Token(t) => t.parent()?,
         };
-        let mut selected_nodes = parent_node
-            .children()
-            .filter(|it| selection_range.contains_range(it.text_range()));
+        let mut selected_nodes =
+            parent_node.children().filter(|it| selection_range.contains_range(it.text_range()));
 
         let first_selected = selected_nodes.next()?;
         let edits = match_ast! {
         "Merge imports",
         target,
         |builder| {
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = builder.make_editor(&parent_node);
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = builder.make_editor(&parent_node);
 
-            for edit in edits {
-                match edit {
-                    Remove(it) => {
-                        let node = it.as_ref();
-                        if let Some(left) = node.left() {
-                            left.remove(&mut editor);
-                        } else if let Some(right) = node.right() {
-                            right.remove(&mut editor);
-                        }
-                    }
-                    Replace(old, new) => {
-                        editor.replace(old, &new);
+        for edit in edits {
+            match edit {
+                Remove(it) => {
+                    let node = it.as_ref();
+                    if let Some(left) = node.left() {
+                        left.remove(&mut editor);
+                    } else if let Some(right) = node.right() {
+                        right.remove(&mut editor);
                     }
                 }
+                Replace(old, new) => {
+                    editor.replace(old, &new);
+                }
             }
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        }
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
-trait Merge: AstNode + Clone {
+trait Merge {
     fn try_merge_from(
         self,
         items: &mut dyn Iterator<Item = Self>,
             None
         }
     }
+
     fn try_merge(&self, other: &Self, cfg: &InsertUseConfig) -> Option<Self>;
+
     fn into_either(self) -> Either<ast::Use, ast::UseTree>;
 }
 
         };
         try_merge_imports(self, other, mb)
     }
+
     fn into_either(self) -> Either<ast::Use, ast::UseTree> {
         Either::Left(self)
     }
     fn try_merge(&self, other: &Self, _: &InsertUseConfig) -> Option<Self> {
         try_merge_trees(self, other, MergeBehavior::Crate)
     }
+
     fn into_either(self) -> Either<ast::Use, ast::UseTree> {
         Either::Right(self)
     }
         check_assist, check_assist_import_one, check_assist_not_applicable,
         check_assist_not_applicable_for_import_one,
     };
-
     use super::*;
-
     macro_rules! check_assist_import_one_variations {
         ($first: literal, $second: literal, $expected: literal) => {
             check_assist_import_one(
             );
             check_assist_import_one(
                 merge_imports,
-                concat!(
-                    concat!("use {", $first, "};"),
-                    concat!("use ", $second, ";")
-                ),
+                concat!(concat!("use {", $first, "};"), concat!("use ", $second, ";")),
                 $expected,
             );
             check_assist_import_one(
                 merge_imports,
-                concat!(
-                    concat!("use ", $first, ";"),
-                    concat!("use {", $second, "};")
-                ),
+                concat!(concat!("use ", $first, ";"), concat!("use {", $second, "};")),
                 $expected,
             );
             check_assist_import_one(
                 merge_imports,
-                concat!(
-                    concat!("use {", $first, "};"),
-                    concat!("use {", $second, "};")
-                ),
+                concat!(concat!("use {", $first, "};"), concat!("use {", $second, "};")),
                 $expected,
             );
         };
     }
-
     #[test]
     fn test_merge_equal() {
         cov_mark::check!(merge_with_use_item_neighbors);
         );
 
         // The assist macro below calls `check_assist_import_one` 4 times with different input
+
         // use item variations based on the first 2 input parameters.
         cov_mark::check_count!(merge_with_use_item_neighbors, 4);
         check_assist_import_one_variations!(
             "use {std::fmt::{Debug, Display}};"
         );
     }
-
     #[test]
     fn test_merge_first() {
         check_assist(
             "use {std::fmt::{Debug, Display}};"
         );
     }
-
     #[test]
     fn test_merge_second() {
         check_assist(
             "use {std::fmt::{Debug, Display}};"
         );
     }
-
     #[test]
     fn merge_self() {
         check_assist(
             "use {std::fmt::{self, Display}};"
         );
     }
-
     #[test]
     fn not_applicable_to_single_import() {
         check_assist_not_applicable(merge_imports, "use std::{fmt, $0fmt::Display};");
             "use {std::{fmt, $0fmt::Display}};",
         );
     }
-
     #[test]
     fn skip_pub1() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn skip_pub_last() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn skip_pub_crate_pub() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn skip_pub_pub_crate() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn merge_pub() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn merge_pub_crate() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn merge_pub_in_path_crate() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn test_merge_nested() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn test_merge_nested2() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn test_merge_with_nested_self_item() {
         check_assist(
             "use {std::fmt::{self, Debug, Display, Write}};"
         );
     }
-
     #[test]
     fn test_merge_with_nested_self_item2() {
         check_assist(
             "use {std::fmt::{self, Debug, Display, Write}};"
         );
     }
-
     #[test]
     fn test_merge_nested_self_and_empty() {
         check_assist(
             "use {foo::bar};"
         );
     }
-
     #[test]
     fn test_merge_nested_empty_and_self() {
         check_assist(
             "use {foo::bar};"
         );
     }
-
     #[test]
     fn test_merge_nested_empty_and_self_with_other() {
         check_assist(
             "use {foo::bar::{self, other}};"
         );
     }
-
     #[test]
     fn test_merge_nested_list_self_and_glob() {
         check_assist(
             "use {std::fmt::{self, Display, *}};"
         );
     }
-
     #[test]
     fn test_merge_single_wildcard_diff_prefixes() {
         check_assist(
             "use {std::{cell::*, str}};"
         );
     }
-
     #[test]
     fn test_merge_both_wildcard_diff_prefixes() {
         check_assist(
             "use {std::{cell::*, str::*}};"
         );
     }
-
     #[test]
     fn removes_just_enough_whitespace() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn works_with_trailing_comma() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn test_double_comma() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn test_empty_use() {
         check_assist_not_applicable(
 fn main() {}",
         );
     }
-
     #[test]
     fn split_glob() {
         check_assist(
             "use {foo::{bar::Baz, *}};"
         );
     }
-
     #[test]
     fn merge_selection_uses() {
         cov_mark::check!(merge_with_selected_use_item_neighbors);
 ",
         );
     }
-
     #[test]
     fn merge_selection_use_trees() {
         cov_mark::check!(merge_with_selected_use_tree_neighbors);
             r"use std::{fmt::{Debug, Display}};",
         );
     }
-
     #[test]
     fn test_merge_with_synonymous_imports_1() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn test_merge_with_synonymous_imports_2() {
         check_assist(