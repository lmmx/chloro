COMPARISON DIFF
============================================================

Original size: 141954 bytes
Chloro size:   140300 bytes
Rustfmt size:  141954 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     TypeInfo, TypeParam,
 };
 use ide_db::{
-    FxIndexSet, RootDatabase,
     assists::GroupLabel,
     defs::{Definition, NameRefClass},
     famous_defs::FamousDefs,
     helpers::mod_path_to_ast,
-    imports::insert_use::{ImportScope, insert_use},
+    imports::insert_use::{insert_use, ImportScope},
     search::{FileReference, ReferenceCategory, SearchScope},
     source_change::SourceChangeBuilder,
     syntax_helpers::node_ext::{
         for_each_tail_expr, preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr,
     },
+    FxIndexSet, RootDatabase,
 };
 use itertools::Itertools;
 use syntax::{
-    Edition, SyntaxElement,
-    SyntaxKind::{self, COMMENT},
-    SyntaxNode, SyntaxToken, T, TextRange, TextSize, TokenAtOffset, WalkEvent,
     ast::{
-        self, AstNode, AstToken, HasGenericParams, HasName, edit::IndentLevel,
-        edit_in_place::Indent,
+        self, edit::IndentLevel, edit_in_place::Indent, AstNode, AstToken, HasGenericParams,
+        HasName,
     },
-    match_ast, ted,
+    match_ast, ted, Edition, SyntaxElement,
+    SyntaxKind::{self, COMMENT},
+    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,
 };
 
 use crate::{
-    AssistId,
     assist_context::{AssistContext, Assists, TreeMutator},
     utils::generate_impl,
+    AssistId,
 };
 
-// Assist: extract_function
-//
-// Extracts selected statements and comments into new function.
-//
-// ```
-// fn main() {
-//     let n = 1;
-//     $0let m = n + 2;
-//     // calculate
-//     let k = m + n;$0
-//     let g = 3;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let n = 1;
-//     fun_name(n);
-//     let g = 3;
-// }
-//
-// fn $0fun_name(n: i32) {
-//     let m = n + 2;
-//     // calculate
-//     let k = m + n;
-// }
-// ```
 pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let range = ctx.selection_trimmed();
     if range.is_empty() {
         "Extract into function",
         target_range,
         move |builder| {
-            let outliving_locals: Vec<_> = ret_values.collect();
-            if stdx::never!(!outliving_locals.is_empty() && !ret_ty.is_unit()) {
+        let outliving_locals: Vec<_> = ret_values.collect();
+        if stdx::never!(!outliving_locals.is_empty() && !ret_ty.is_unit()) {
                 // We should not have variables that outlive body if we have expression block
                 return;
             }
-
-            let params = body.extracted_function_params(ctx, &container_info, locals_used);
-
-            let name = make_function_name(&semantics_scope);
-
-            let fun = Function {
+        let params = body.extracted_function_params(ctx, &container_info, locals_used);
+        let name = make_function_name(&semantics_scope);
+        let fun = Function {
                 name,
                 self_param,
                 params,
                 contains_tail_expr,
                 mods: container_info,
             };
-
-            let new_indent = IndentLevel::from_node(&insert_after);
-            let old_indent = fun.body.indent_level();
-
-            let insert_after = builder.make_syntax_mut(insert_after);
-
-            let call_expr = make_call(ctx, &fun, old_indent);
-
-            // Map the element range to replace into the mutable version
-            let elements = match &fun.body {
+        let new_indent = IndentLevel::from_node(&insert_after);
+        let old_indent = fun.body.indent_level();
+        let insert_after = builder.make_syntax_mut(insert_after);
+        let call_expr = make_call(ctx, &fun, old_indent);
+        let elements = match &fun.body {
                 FunctionBody::Expr(expr) => {
                     // expr itself becomes the replacement target
                     let expr = &builder.make_mut(expr.clone());
                     start..=end
                 }
             };
-
-            let has_impl_wrapper =
+        let has_impl_wrapper =
                 insert_after.ancestors().any(|a| a.kind() == SyntaxKind::IMPL && a != insert_after);
-
-            let fn_def = format_function(ctx, module, &fun, old_indent).clone_for_update();
-
-            if let Some(cap) = ctx.config.snippet_cap
+        let fn_def = format_function(ctx, module, &fun, old_indent).clone_for_update();
+        if let Some(cap) = ctx.config.snippet_cap
                 && let Some(name) = fn_def.name()
             {
                 builder.add_tabstop_before(cap, name);
             }
-
-            let fn_def = match fun.self_param_adt(ctx) {
+        let fn_def = match fun.self_param_adt(ctx) {
                 Some(adt) if anchor == Anchor::Method && !has_impl_wrapper => {
                     fn_def.indent(1.into());
 
                     fn_def.syntax().clone()
                 }
             };
-
-            // There are external control flows
-            if fun
+        if fun
                 .control_flow
                 .kind
                 .is_some_and(|kind| matches!(kind, FlowKind::Break(_, _) | FlowKind::Continue(_)))
                     }
                 }
             }
-
-            // Replace the call site with the call to the new function
-            fixup_call_site(builder, &fun.body);
-            ted::replace_all(elements, vec![call_expr.into()]);
-
-            // Insert the newly extracted function (or impl)
-            ted::insert_all_raw(
+        fixup_call_site(builder, &fun.body);
+        ted::replace_all(elements, vec![call_expr.into()]);
+        ted::insert_all_raw(
                 ted::Position::after(insert_after),
                 vec![make::tokens::whitespace(&format!("\n\n{new_indent}")).into(), fn_def.into()],
             );
-        },
+    },
     )
 }
 
     Method,
 }
 
-// FIXME: ControlFlow and ContainerInfo both track some function modifiers, feels like these two should
-// probably be merged somehow.
 #[derive(Debug)]
 struct ControlFlow<'db> {
     kind: Option<FlowKind<'db>>,
 #[derive(Debug, Clone)]
 enum TryKind<'db> {
     Option,
-    Result { ty: hir::Type<'db> },
+    Result {
+        ty: hir::Type<'db>,
+    },
 }
 
 #[derive(Debug)]
 #[derive(Debug)]
 enum FunctionBody {
     Expr(ast::Expr),
-    Span { parent: ast::StmtList, elements: RangeInclusive<SyntaxElement>, text_range: TextRange },
+    Span {
+        parent: ast::StmtList,
+        elements: RangeInclusive<SyntaxElement>,
+        text_range: TextRange,
+    },
 }
 
 #[derive(Debug)]
 
 impl LocalUsages {
     fn find_local_usages(ctx: &AssistContext<'_>, var: Local) -> Self {
-        Self(
-            Definition::Local(var)
-                .usages(&ctx.sema)
-                .in_scope(&SearchScope::single_file(ctx.file_id()))
-                .all(),
-        )
+        Self(Definition::Local(var).usages(&ctx.sema).in_scope(&SearchScope::single_file(ctx.file_id())).all(
+        ))
     }
 
     fn iter(&self) -> impl Iterator<Item = &FileReference> + '_ {
                 vars => {
                     let types = vars.iter().map(|v| v.local.ty(ctx.db())).collect();
                     FunType::Tuple(types)
-                }
+                },
             },
         }
     }
             FlowKind::Try { .. } => {
                 stdx::never!("cannot have result handler with try");
                 expr.unwrap_or_else(|| make::expr_return(None))
-            }
+            },
             FlowKind::Continue(label) => {
                 stdx::always!(expr.is_none(), "continue with value is not possible");
                 make::expr_continue(label.clone())
-            }
+            },
         }
     }
 
         match self {
             FlowKind::Return(Some(expr)) | FlowKind::Break(_, Some(expr)) => {
                 ctx.sema.type_of_expr(expr).map(TypeInfo::adjusted)
-            }
+            },
             FlowKind::Try { .. } => {
                 stdx::never!("try does not have defined expr_ty");
                 None
-            }
+            },
             _ => None,
         }
     }
         let first_element = stmts_in_selection.next();
 
         // If the tail expr is part of the selection too, make that the last element
+
         // Otherwise use the last stmt
         let last_element = if let Some(tail_expr) =
             parent.tail_expr().filter(|it| selected.intersect(it.syntax().text_range()).is_some())
             FunctionBody::Span { parent, text_range, .. } => {
                 let tail_expr = parent.tail_expr()?;
                 text_range.contains_range(tail_expr.syntax().text_range()).then_some(tail_expr)
-            }
+            },
         }
     }
 
                         ast::Stmt::LetStmt(stmt) => stmt.initializer(),
                     })
                     .for_each(|expr| walk_expr(&expr, cb));
-                if let Some(expr) = parent
-                    .tail_expr()
-                    .filter(|it| text_range.contains_range(it.syntax().text_range()))
-                {
+                if let Some(expr) = parent.tail_expr().filter(|it| text_range.contains_range(it.syntax().text_range())) {
                     walk_expr(&expr, cb);
                 }
-            }
+            },
         }
     }
 
                         ast::Stmt::LetStmt(stmt) => stmt.initializer(),
                     })
                     .for_each(|expr| preorder_expr(&expr, cb));
-                if let Some(expr) = parent
-                    .tail_expr()
-                    .filter(|it| text_range.contains_range(it.syntax().text_range()))
-                {
+                if let Some(expr) = parent.tail_expr().filter(|it| text_range.contains_range(it.syntax().text_range())) {
                     preorder_expr(&expr, cb);
                 }
-            }
+            },
         }
     }
 
                             }
                         }
                     });
-                if let Some(expr) = parent
-                    .tail_expr()
-                    .filter(|it| text_range.contains_range(it.syntax().text_range()))
-                {
+                if let Some(expr) = parent.tail_expr().filter(|it| text_range.contains_range(it.syntax().text_range())) {
                     walk_patterns_in_expr(&expr, cb);
                 }
-            }
+            },
         }
     }
 
     ) -> impl Iterator<Item = OutlivedLocal> + 'a {
         let parent = parent.clone();
         let range = self.text_range();
-        locals_defined_in_body(&ctx.sema, self)
-            .into_iter()
-            .filter_map(move |local| local_outlives_body(ctx, range, local, &parent))
+        locals_defined_in_body(&ctx.sema, self).into_iter().filter_map(
+            move |local| local_outlives_body(ctx, range, local, &parent),
+        )
     }
 
     /// Analyses the function body for external control flow.
         container_info: &ContainerInfo<'db>,
         locals: FxIndexSet<Local>,
     ) -> Vec<Param<'db>> {
-        locals
-            .into_iter()
-            .sorted()
-            .map(|local| (local, local.primary_source(ctx.db())))
-            .filter(|(_, src)| is_defined_outside_of_body(ctx, self, src))
-            .filter_map(|(local, src)| match src.into_ident_pat() {
-                Some(src) => Some((local, src)),
-                None => {
-                    stdx::never!(false, "Local::is_self returned false, but source is SelfParam");
-                    None
-                }
-            })
-            .map(|(var, src)| {
-                let usages = LocalUsages::find_local_usages(ctx, var);
-                let ty = var.ty(ctx.db());
-
-                let defined_outside_parent_loop = container_info
+        locals.into_iter().sorted().map(|local| (local, local.primary_source(ctx.db()))).filter(
+            |(_, src)| is_defined_outside_of_body(ctx, self, src),
+        ).filter_map(|(local, src)| match src.into_ident_pat() {
+            Some(src) => Some((local, src)),
+            None => {
+                stdx::never!(false, "Local::is_self returned false, but source is SelfParam");
+                None
+            },
+        }).map(|(var, src)| {
+            let usages = LocalUsages::find_local_usages(ctx, var);
+            let ty = var.ty(ctx.db());
+            let defined_outside_parent_loop = container_info
                     .parent_loop
                     .as_ref()
                     .is_none_or(|it| it.text_range().contains_range(src.syntax().text_range()));
-
-                let is_copy = ty.is_copy(ctx.db());
-                let has_usages = self.has_usages_after_body(&usages);
-                let requires_mut =
+            let is_copy = ty.is_copy(ctx.db());
+            let has_usages = self.has_usages_after_body(&usages);
+            let requires_mut =
                     !ty.is_mutable_reference() && has_exclusive_usages(ctx, &usages, self);
-                // We can move the value into the function call if it's not used after the call,
-                // if the var is not used but defined outside a loop we are extracting from we can't move it either
-                // as the function will reuse it in the next iteration.
-                let move_local = (!has_usages && defined_outside_parent_loop) || ty.is_reference();
-                Param { var, ty, move_local, requires_mut, is_copy }
-            })
-            .collect()
+            let move_local = (!has_usages && defined_outside_parent_loop) || ty.is_reference();
+            Param { var, ty, move_local, requires_mut, is_copy }
+        }).collect(
+        )
     }
 
     fn has_usages_after_body(&self, usages: &LocalUsages) -> bool {
     usages: &LocalUsages,
     body: &FunctionBody,
 ) -> bool {
-    usages
-        .iter()
-        .filter(|reference| body.contains_range(reference.range))
-        .any(|reference| reference_is_exclusive(reference, body, ctx))
+    usages.iter().filter(|reference| body.contains_range(reference.range)).any(
+        |reference| reference_is_exclusive(reference, body, ctx),
+    )
 }
 
 /// checks if this reference requires `&mut` access inside node
                         } else {
                             TokenAtOffset::None
                         }
-                    }
+                    },
                     TokenAtOffset::Between(a, b) => {
                         match (
                             text_range.contains_range(a.text_range()),
                             (false, true) => TokenAtOffset::Single(b),
                             (false, false) => TokenAtOffset::None,
                         }
-                    }
+                    },
                 }
-            }
+            },
         }
     }
 }
     let impl_type = Some(impl_type_name(&as_impl)?);
 
     let siblings = trait_impl.parent()?.children();
-    siblings
-        .filter_map(ast::Impl::cast)
-        .find(|s| impl_type_name(s) == impl_type && !is_trait_impl(s))
+    siblings.filter_map(ast::Impl::cast).find(
+        |s| impl_type_name(s) == impl_type && !is_trait_impl(s),
+    )
 }
 
 fn last_impl_member(impl_node: &ast::Impl) -> Option<SyntaxNode> {
 fn fixup_call_site(builder: &mut SourceChangeBuilder, body: &FunctionBody) {
     let parent_match_arm = body.parent().and_then(ast::MatchArm::cast);
 
-    if let Some(parent_match_arm) = parent_match_arm
-        && parent_match_arm.comma_token().is_none()
-    {
+    if let Some(parent_match_arm) = parent_match_arm && parent_match_arm.comma_token().is_none() {
         let parent_match_arm = builder.make_mut(parent_match_arm);
         ted::append_child_raw(parent_match_arm.syntax(), make::token(T![,]));
     }
     let parent_match_arm = fun.body.parent().and_then(ast::MatchArm::cast);
 
     if let Some(bindings) = outliving_bindings {
-        // with bindings that outlive it
         make::let_stmt(bindings, None, Some(expr)).syntax().clone_for_update()
     } else if parent_match_arm.as_ref().is_some() {
-        // as a tail expr for a match arm
         expr.syntax().clone()
-    } else if parent_match_arm.as_ref().is_none()
-        && fun.ret_ty.is_unit()
-        && (!fun.outliving_locals.is_empty() || !expr.is_block_like())
-    {
-        // as an expr stmt
+    } else if parent_match_arm.as_ref().is_none() && fun.ret_ty.is_unit() && (!fun.outliving_locals.is_empty() || !expr.is_block_like()) {
         make::expr_stmt(expr).syntax().clone_for_update()
     } else {
-        // as a tail expr, or a block
         expr.syntax().clone()
     }
 }
 
 enum FlowHandler<'db> {
     None,
-    Try { kind: TryKind<'db> },
-    If { action: FlowKind<'db> },
-    IfOption { action: FlowKind<'db> },
-    MatchOption { none: FlowKind<'db> },
-    MatchResult { err: FlowKind<'db> },
+    Try {
+        kind: TryKind<'db>,
+    },
+    If {
+        action: FlowKind<'db>,
+    },
+    IfOption {
+        action: FlowKind<'db>,
+    },
+    MatchOption {
+        none: FlowKind<'db>,
+    },
+    MatchResult {
+        err: FlowKind<'db>,
+    },
 }
 
 impl<'db> FlowHandler<'db> {
             match action {
                 FlowKind::Return(None) | FlowKind::Break(_, None) | FlowKind::Continue(_) => {
                     FlowHandler::If { action }
-                }
+                },
                 FlowKind::Return(_) | FlowKind::Break(_, _) => FlowHandler::IfOption { action },
                 FlowKind::Try { kind } => FlowHandler::Try { kind },
             }
             match action {
                 FlowKind::Return(None) | FlowKind::Break(_, None) | FlowKind::Continue(_) => {
                     FlowHandler::MatchOption { none: action }
-                }
+                },
                 FlowKind::Return(_) | FlowKind::Break(_, _) => {
                     FlowHandler::MatchResult { err: action }
-                }
+                },
                 FlowKind::Try { kind } => FlowHandler::Try { kind },
             }
         }
                     call_expr,
                 );
                 make::expr_if(condition.into(), block, None).into()
-            }
+            },
             FlowHandler::IfOption { action } => {
                 let path = make::ext::ident_path("Some");
                 let value_pat = make::ext::simple_ident_pat(make::name("value"));
                 let action_stmt = make::expr_stmt(action_expr);
                 let then = make::block_expr(iter::once(action_stmt.into()), None);
                 make::expr_if(cond.into(), then, None).into()
-            }
+            },
             FlowHandler::MatchOption { none } => {
                 let some_name = "value";
-
                 let some_arm = {
                     let path = make::ext::ident_path("Some");
                     let value_pat = make::ext::simple_ident_pat(make::name(some_name));
                 };
                 let arms = make::match_arm_list(vec![some_arm, none_arm]);
                 make::expr_match(call_expr, arms).into()
-            }
+            },
             FlowHandler::MatchResult { err } => {
                 let ok_name = "value";
                 let err_name = "value";
-
                 let ok_arm = {
                     let path = make::ext::ident_path("Ok");
                     let value_pat = make::ext::simple_ident_pat(make::name(ok_name));
                 };
                 let arms = make::match_arm_list(vec![ok_arm, err_arm]);
                 make::expr_match(call_expr, arms).into()
-            }
+            },
         }
     }
 }
         })
         .peekable();
 
-    if predicates.peek().is_some() { Some(make::where_clause(predicates)) } else { None }
+    if predicates.peek().is_some() {
+        Some(make::where_clause(predicates))
+    } else {
+        None
+    }
 }
 
 fn pred_is_required(
                 [] => {
                     stdx::never!("tuple type with 0 elements");
                     make::ty_unit()
-                }
+                },
                 [ty] => {
                     stdx::never!("tuple type with 1 element");
                     make_ty(ty, ctx, module)
-                }
+                },
                 types => {
                     let types = types.iter().map(|ty| make_ty(ty, ctx, module));
                     make::ty_tuple(types)
-                }
+                },
             },
         }
     }
         FlowHandler::None => block,
         FlowHandler::Try { kind } => {
             let block = with_default_tail_expr(block, make::ext::expr_unit());
-            map_tail_expr(block, |tail_expr| {
+            map_tail_expr(
+                block,
+                |tail_expr| {
                 let constructor = match kind {
                     TryKind::Option => "Some",
                     TryKind::Result { .. } => "Ok",
                 let func = make::expr_path(make::ext::ident_path(constructor));
                 let args = make::arg_list(iter::once(tail_expr));
                 make::expr_call(func, args).into()
-            })
-        }
+            },
+            )
+        },
         FlowHandler::If { .. } => {
             let controlflow_continue = make::expr_call(
                 make::expr_path(make::path_from_text("ControlFlow::Continue")),
             )
             .into();
             with_tail_expr(block, controlflow_continue)
-        }
+        },
         FlowHandler::IfOption { .. } => {
             let none = make::expr_path(make::ext::ident_path("None"));
             with_tail_expr(block, none)
-        }
-        FlowHandler::MatchOption { .. } => map_tail_expr(block, |tail_expr| {
+        },
+        FlowHandler::MatchOption { .. } => map_tail_expr(
+            block,
+            |tail_expr| {
             let some = make::expr_path(make::ext::ident_path("Some"));
             let args = make::arg_list(iter::once(tail_expr));
             make::expr_call(some, args).into()
-        }),
-        FlowHandler::MatchResult { .. } => map_tail_expr(block, |tail_expr| {
+        },
+        ),
+        FlowHandler::MatchResult { .. } => map_tail_expr(
+            block,
+            |tail_expr| {
             let ok = make::expr_path(make::ext::ident_path("Ok"));
             let args = make::arg_list(iter::once(tail_expr));
             make::expr_call(ok, args).into()
-        }),
+        },
+        ),
     }
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn no_args_from_binary_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_binary_expr_in_module() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_binary_expr_indented() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_stmt_with_last_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_stmt_unit() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_if() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_if_else() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_if_let_else() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_match() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_while() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_for() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_loop_unit() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_loop_with_return() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_match() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_partial_block_single_line() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_partial_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn argument_form_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn argument_used_twice_form_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn two_arguments_form_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn argument_and_locals() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn in_comment_is_not_applicable() {
         cov_mark::check!(extract_function_in_comment_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn main() { 1 + /* $0comment$0 */ 1; }");
     }
-
     #[test]
     fn empty_selection_is_not_applicable() {
         cov_mark::check!(extract_function_empty_selection_is_not_applicable);
 }"#,
         );
     }
-
     #[test]
     fn part_of_expr_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_from_nested() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_from_closure() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_return_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn does_not_add_extra_whitespace() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_cast() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn return_not_applicable() {
         check_assist_not_applicable(extract_function, r"fn foo() { $0return$0; } ");
     }
-
     #[test]
     fn method_to_freestanding() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_with_reference() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_with_mut() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn variable_defined_inside_and_used_after_no_ret() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn variable_defined_inside_and_used_after_mutably_no_ret() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn two_variables_defined_inside_and_used_after_no_ret() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn multi_variables_defined_inside_and_used_after_mutably_no_ret() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn nontrivial_patterns_define_variables() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_with_two_fields_pattern_define_variables() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_var_from_outer_scope() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_field_from_outer_scope() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_nested_field_from_outer_scope() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_param_many_usages_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_param_many_usages_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_param_by_value() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn mut_param_because_of_mut_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_param_by_value_because_of_mut_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_method_call() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn shared_method_call() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn mut_method_call_with_other_receiver() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn non_copy_without_usages_after() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn non_copy_used_after() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn copy_used_after() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn copy_custom_used_after() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn indented_stmts() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn indented_stmts_inside_mod() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn return_to_parent() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_and_continue() {
         cov_mark::check!(external_control_flow_break_and_continue);
 "#,
         );
     }
-
     #[test]
     fn return_and_break() {
         cov_mark::check!(external_control_flow_return_and_bc);
 "#,
         );
     }
-
     #[test]
     fn break_loop_with_if() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_loop_nested() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_loop_nested_labeled() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn continue_loop_nested_labeled() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn return_from_nested_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_from_nested_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_from_nested_and_outer_loops() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn return_from_nested_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_with_value() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_with_value_and_label() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_with_value_and_return() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_option_unit() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_option_with_return() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_result_with_return() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_and_break() {
         cov_mark::check!(external_control_flow_try_and_bc);
 "#,
         );
     }
-
     #[test]
     fn try_and_return_ok() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_usage_in_macro() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_usage_in_macro_with_nested_tt() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn param_usage_in_macro_with_nested_tt_2() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_with_await() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_with_await_and_result_not_producing_match_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_with_await_and_result_producing_match_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_with_await_in_args() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_does_not_extract_standalone_blocks() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn extract_adds_comma_for_match_arm() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_does_not_tear_comments_apart() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_does_not_tear_body_apart() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_does_not_wrap_res_in_res() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_knows_const() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_does_not_move_outer_loop_vars() {
         check_assist(
 "#,
         );
     }
-
-    // regression test for #9822
     #[test]
     fn extract_mut_ref_param_has_no_mut_binding_in_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_with_macro_arg() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn unresolvable_types_default_to_placeholder() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn reference_mutable_param_with_further_usages() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn reference_mutable_param_without_further_usages() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_copies_comment_at_start() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_copies_comment_in_between() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_copies_comment_at_end() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_copies_comment_indented() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_does_preserve_whitespace() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_long_form_comment() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn it_should_not_generate_duplicate_function_names() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn should_increment_suffix_until_it_finds_space() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_method_from_trait_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_method_from_trait_with_existing_non_empty_impl_block() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_function_from_trait_with_existing_non_empty_impl_block() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_method_from_trait_with_multiple_existing_impl_blocks() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_method_from_trait_with_multiple_existing_trait_impl_blocks() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn closure_arguments() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn preserve_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn dont_emit_type_with_hidden_lifetime_parameter() {
         // FIXME: We should emit a `<T: Debug>` generic argument for the generated function
 "#,
         );
     }
-
     #[test]
     fn preserve_generics_from_body() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn filter_unused_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn empty_generic_param_list() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn preserve_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn filter_unused_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn nested_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn filters_unused_nested_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn nested_where_clauses() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn filters_unused_nested_where_clauses() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn tail_expr_no_extra_control_flow() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn non_tail_expr_of_tail_expr_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn non_tail_expr_of_tail_if_block() {
         // FIXME: double semicolon
 "#,
         );
     }
-
     #[test]
     fn tail_expr_of_tail_block_nested() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn non_tail_expr_with_comment_of_tail_expr_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn comments_in_block_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn sort_params_in_order() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn fmt_macro_argument() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn in_left_curly_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo() { $0}$0");
     }
-
     #[test]
     fn in_right_curly_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo() $0{$0 }");
     }
-
     #[test]
     fn in_left_paren_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo( $0)$0 { }");
     }
-
     #[test]
     fn in_right_paren_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo $0($0 ) { }");
     }
-
     #[test]
     fn in_left_brack_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo(arr: &mut [i32$0]$0) {}");
     }
-
     #[test]
     fn in_right_brack_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);