COMPARISON DIFF
============================================================

Original size: 141954 bytes
Chloro size:   141876 bytes
Rustfmt size:  143880 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     SyntaxKind::{self, COMMENT},
     SyntaxNode, SyntaxToken, T, TextRange, TextSize, TokenAtOffset, WalkEvent,
     ast::{
-        self, AstNode, AstToken, HasGenericParams, HasName, edit::IndentLevel,
-        edit_in_place::Indent,
+        self, AstNode, AstToken, HasGenericParams, HasName, edit_in_place::Indent,
+        edit::IndentLevel,
     },
     match_ast, ted,
 };
     }
 
     let node = ctx.covering_element();
-    if matches!(
-        node.kind(),
-        T!['{'] | T!['}'] | T!['('] | T![')'] | T!['['] | T![']']
-    ) {
+    if matches!(node.kind(), T!['{'] | T!['}'] | T!['('] | T![')'] | T!['['] | T![']']) {
         cov_mark::hit!(extract_function_in_braces_is_not_applicable);
         return None;
     }
 
     let (locals_used, self_param) = body.analyze(&ctx.sema);
 
-    let anchor = if self_param.is_some() {
-        Anchor::Method
-    } else {
-        Anchor::Freestanding
-    };
+    let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };
     let insert_after = node_to_insert_after(&body, anchor)?;
     let semantics_scope = ctx.sema.scope(&insert_after)?;
     let module = semantics_scope.module();
 
                     node.clone()..=node
                 }
-                FunctionBody::Span {
-                    parent, elements, ..
-                } => {
+                FunctionBody::Span { parent, elements, .. } => {
                     // Map the element range into the mutable versions
                     let parent = builder.make_mut(parent.clone());
 
                 }
             };
 
-            let has_impl_wrapper = insert_after
-                .ancestors()
-                .any(|a| a.kind() == SyntaxKind::IMPL && a != insert_after);
+            let has_impl_wrapper =
+                insert_after.ancestors().any(|a| a.kind() == SyntaxKind::IMPL && a != insert_after);
 
             let fn_def = format_function(ctx, module, &fun, old_indent).clone_for_update();
 
 
                     let impl_ = generate_impl(&adt);
                     impl_.indent(new_indent);
-                    impl_
-                        .get_or_create_assoc_item_list()
-                        .add_item(fn_def.into());
+                    impl_.get_or_create_assoc_item_list().add_item(fn_def.into());
 
                     impl_.syntax().clone()
                 }
                     FamousDefs(&ctx.sema, module.krate()).core_ops_ControlFlow();
 
                 if let Some(control_flow_enum) = control_flow_enum {
-                    let cfg = ctx
-                        .config
-                        .find_path_config(ctx.sema.is_nightly(module.krate()));
+                    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
                     let mod_path = module.find_use_path(
                         ctx.sema.db,
                         ModuleDef::from(control_flow_enum),
             // Insert the newly extracted function (or impl)
             ted::insert_all_raw(
                 ted::Position::after(insert_after),
-                vec![
-                    make::tokens::whitespace(&format!("\n\n{new_indent}")).into(),
-                    fn_def.into(),
-                ],
+                vec![make::tokens::whitespace(&format!("\n\n{new_indent}")).into(), fn_def.into()],
             );
         },
     )
     let mut names_in_scope = vec![];
     semantics_scope.process_all_names(&mut |name, _| {
         names_in_scope.push(
-            name.display(
-                semantics_scope.db,
-                semantics_scope.krate().edition(semantics_scope.db),
-            )
-            .to_string(),
+            name.display(semantics_scope.db, semantics_scope.krate().edition(semantics_scope.db))
+                .to_string(),
         )
     });
 
         return FunctionBody::from_expr(expr);
     }
 
-    node.ancestors()
-        .find_map(ast::Expr::cast)
-        .and_then(FunctionBody::from_expr)
+    node.ancestors().find_map(ast::Expr::cast).and_then(FunctionBody::from_expr)
 }
 
 #[derive(Debug)]
     Method,
 }
 
-// FIXME: ControlFlow and ContainerInfo both track some function modifiers, feels like these two should
-// probably be merged somehow.
 #[derive(Debug)]
 struct ControlFlow<'db> {
     kind: Option<FlowKind<'db>>,
 #[derive(Debug, Clone)]
 enum TryKind<'db> {
     Option,
-    Result { ty: hir::Type<'db> },
+    Result {
+        ty: hir::Type<'db>,
+    },
 }
 
 #[derive(Debug)]
         module: hir::Module,
         edition: Edition,
     ) -> ast::Param {
-        let var = self
-            .var
-            .name(ctx.db())
-            .display(ctx.db(), edition)
-            .to_string();
+        let var = self.var.name(ctx.db()).display(ctx.db(), edition).to_string();
         let var_name = make::name(&var);
         let pat = match self.kind() {
             ParamKind::MutValue => make::ident_pat(false, true, var_name),
         // Get all of the elements intersecting with the selection
         let mut stmts_in_selection = full_body
             .filter(|it| ast::Stmt::can_cast(it.kind()) || it.kind() == COMMENT)
-            .filter(|it| {
-                selected
-                    .intersect(it.text_range())
-                    .filter(|it| !it.is_empty())
-                    .is_some()
-            });
+            .filter(|it| selected.intersect(it.text_range()).filter(|it| !it.is_empty()).is_some());
 
         let first_element = stmts_in_selection.next();
 
         // If the tail expr is part of the selection too, make that the last element
         // Otherwise use the last stmt
-        let last_element = if let Some(tail_expr) = parent
-            .tail_expr()
-            .filter(|it| selected.intersect(it.syntax().text_range()).is_some())
+        let last_element = if let Some(tail_expr) =
+            parent.tail_expr().filter(|it| selected.intersect(it.syntax().text_range()).is_some())
         {
             Some(tail_expr.syntax().clone().into())
         } else {
             (Some(first), Some(last)) => first..=last,
         };
 
-        let text_range = elements
-            .start()
-            .text_range()
-            .cover(elements.end().text_range());
+        let text_range = elements.start().text_range().cover(elements.end().text_range());
 
-        Some(Self::Span {
-            parent,
-            elements,
-            text_range,
-        })
+        Some(Self::Span { parent, elements, text_range })
     }
 
     fn indent_level(&self) -> IndentLevel {
     fn tail_expr(&self) -> Option<ast::Expr> {
         match &self {
             FunctionBody::Expr(expr) => Some(expr.clone()),
-            FunctionBody::Span {
-                parent, text_range, ..
-            } => {
+            FunctionBody::Span { parent, text_range, .. } => {
                 let tail_expr = parent.tail_expr()?;
-                text_range
-                    .contains_range(tail_expr.syntax().text_range())
-                    .then_some(tail_expr)
+                text_range.contains_range(tail_expr.syntax().text_range()).then_some(tail_expr)
             }
         }
     }
     fn walk_expr(&self, cb: &mut dyn FnMut(ast::Expr)) {
         match self {
             FunctionBody::Expr(expr) => walk_expr(expr, cb),
-            FunctionBody::Span {
-                parent, text_range, ..
-            } => {
+            FunctionBody::Span { parent, text_range, .. } => {
                 parent
                     .statements()
                     .filter(|stmt| text_range.contains_range(stmt.syntax().text_range()))
                     .for_each(|expr| walk_expr(&expr, cb));
                 if let Some(expr) = parent
                     .tail_expr()
-                    .filter(|it| text_range.contains_range(it.syntax().text_range()))
-                {
+                    .filter(|it| text_range.contains_range(it.syntax().text_range())) {
                     walk_expr(&expr, cb);
                 }
             }
     fn preorder_expr(&self, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {
         match self {
             FunctionBody::Expr(expr) => preorder_expr(expr, cb),
-            FunctionBody::Span {
-                parent, text_range, ..
-            } => {
+            FunctionBody::Span { parent, text_range, .. } => {
                 parent
                     .statements()
                     .filter(|stmt| text_range.contains_range(stmt.syntax().text_range()))
                     .for_each(|expr| preorder_expr(&expr, cb));
                 if let Some(expr) = parent
                     .tail_expr()
-                    .filter(|it| text_range.contains_range(it.syntax().text_range()))
-                {
+                    .filter(|it| text_range.contains_range(it.syntax().text_range())) {
                     preorder_expr(&expr, cb);
                 }
             }
     fn walk_pat(&self, cb: &mut dyn FnMut(ast::Pat)) {
         match self {
             FunctionBody::Expr(expr) => walk_patterns_in_expr(expr, cb),
-            FunctionBody::Span {
-                parent, text_range, ..
-            } => {
+            FunctionBody::Span { parent, text_range, .. } => {
                 parent
                     .statements()
                     .filter(|stmt| text_range.contains_range(stmt.syntax().text_range()))
                     });
                 if let Some(expr) = parent
                     .tail_expr()
-                    .filter(|it| text_range.contains_range(it.syntax().text_range()))
-                {
+                    .filter(|it| text_range.contains_range(it.syntax().text_range())) {
                     walk_patterns_in_expr(&expr, cb);
                 }
             }
             match NameRefClass::classify(sema, &name_ref) {
                 Some(
                     NameRefClass::Definition(Definition::Local(local_ref), _)
-                    | NameRefClass::FieldShorthand {
-                        local_ref,
-                        field_ref: _,
-                        adt_subst: _,
-                    },
+                    | NameRefClass::FieldShorthand { local_ref, field_ref: _, adt_subst: _ },
                 ) => Some(local_ref),
                 _ => None,
             }
 
         let parent = self.parent()?;
         let parents = generic_parents(&parent);
-        let generic_param_lists = parents
-            .iter()
-            .filter_map(|it| it.generic_param_list())
-            .collect();
+        let generic_param_lists = parents.iter().filter_map(|it| it.generic_param_list()).collect();
         let where_clauses = parents.iter().filter_map(|it| it.where_clause()).collect();
 
         Some((
 
     fn return_ty<'db>(&self, ctx: &AssistContext<'db>) -> Option<RetType<'db>> {
         match self.tail_expr() {
-            Some(expr) => ctx
-                .sema
-                .type_of_expr(&expr)
-                .map(TypeInfo::original)
-                .map(RetType::Expr),
+            Some(expr) => ctx.sema.type_of_expr(&expr).map(TypeInfo::original).map(RetType::Expr),
             None => Some(RetType::Stmt),
         }
     }
             (None, None, None, None) => None,
         };
 
-        Some(ControlFlow {
-            kind,
-            is_async,
-            is_unsafe: _is_unsafe,
-        })
+        Some(ControlFlow { kind, is_async, is_unsafe: _is_unsafe })
     }
 
     /// find variables that should be extracted as params
             .filter_map(|(local, src)| match src.into_ident_pat() {
                 Some(src) => Some((local, src)),
                 None => {
-                    stdx::never!(
-                        false,
-                        "Local::is_self returned false, but source is SelfParam"
-                    );
+                    stdx::never!(false, "Local::is_self returned false, but source is SelfParam");
                     None
                 }
             })
                 // if the var is not used but defined outside a loop we are extracting from we can't move it either
                 // as the function will reuse it in the next iteration.
                 let move_local = (!has_usages && defined_outside_parent_loop) || ty.is_reference();
-                Param {
-                    var,
-                    ty,
-                    move_local,
-                    requires_mut,
-                    is_copy,
-                }
+                Param { var, ty, move_local, requires_mut, is_copy }
             })
             .collect()
     }
 
     fn has_usages_after_body(&self, usages: &LocalUsages) -> bool {
-        usages
-            .iter()
-            .any(|reference| self.precedes_range(reference.range))
+        usages.iter().any(|reference| self.precedes_range(reference.range))
     }
 }
 
     if let Some(parent_item) = parent.ancestors().find_map(ast::Item::cast)
         && let ast::Item::Fn(ref fn_) = parent_item
     {
-        if let Some(parent_parent) = parent_item
-            .syntax()
-            .parent()
-            .and_then(|it| it.parent())
-            .and_then(ast::Item::cast)
+        if let Some(parent_parent) =
+            parent_item.syntax().parent().and_then(|it| it.parent()).and_then(ast::Item::cast)
         {
             match parent_parent {
                 ast::Item::Impl(impl_) => list.push(GenericParent::Impl(impl_)),
     // but doesn't necessary fully reflect all the intricacies of the underlying language semantics
     // The correct approach here would be to expose this entire analysis as a method on some hir
     // type. Something like `body.free_variables(statement_range)`.
-
     // we directly modify variable with set: `n = 0`, `n += 1`
     if reference.category.contains(ReferenceCategory::WRITE) {
         return true;
     fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {
         match self {
             FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),
-            FunctionBody::Span {
-                parent, text_range, ..
-            } => match parent.syntax().token_at_offset(offset) {
-                TokenAtOffset::None => TokenAtOffset::None,
-                TokenAtOffset::Single(t) => {
-                    if text_range.contains_range(t.text_range()) {
-                        TokenAtOffset::Single(t)
-                    } else {
-                        TokenAtOffset::None
+            FunctionBody::Span { parent, text_range, .. } => {
+                match parent.syntax().token_at_offset(offset) {
+                    TokenAtOffset::None => TokenAtOffset::None,
+                    TokenAtOffset::Single(t) => {
+                        if text_range.contains_range(t.text_range()) {
+                            TokenAtOffset::Single(t)
+                        } else {
+                            TokenAtOffset::None
+                        }
+                    }
+                    TokenAtOffset::Between(a, b) => {
+                        match (
+                            text_range.contains_range(a.text_range()),
+                            text_range.contains_range(b.text_range()),
+                        ) {
+                            (true, true) => TokenAtOffset::Between(a, b),
+                            (true, false) => TokenAtOffset::Single(a),
+                            (false, true) => TokenAtOffset::Single(b),
+                            (false, false) => TokenAtOffset::None,
+                        }
                     }
                 }
-                TokenAtOffset::Between(a, b) => {
-                    match (
-                        text_range.contains_range(a.text_range()),
-                        text_range.contains_range(b.text_range()),
-                    ) {
-                        (true, true) => TokenAtOffset::Between(a, b),
-                        (true, false) => TokenAtOffset::Single(a),
-                        (false, true) => TokenAtOffset::Single(b),
-                        (false, false) => TokenAtOffset::None,
-                    }
-                }
-            },
+            }
         }
     }
 }
     node: &dyn HasTokenAtOffset,
     reference: &FileReference,
 ) -> Option<ast::Expr> {
-    let token = node
-        .token_at_offset(reference.range.start())
-        .right_biased()
-        .or_else(|| {
-            stdx::never!(
-                false,
-                "cannot find token at variable usage: {:?}",
-                reference
-            );
-            None
-        })?;
-    let path = token
-        .parent_ancestors()
-        .find_map(ast::Expr::cast)
-        .or_else(|| {
-            stdx::never!(
-                false,
-                "cannot find path parent of variable usage: {:?}",
-                token
-            );
-            None
-        })?;
+    let token = node.token_at_offset(reference.range.start()).right_biased().or_else(|| {
+        stdx::never!(false, "cannot find token at variable usage: {:?}", reference);
+        None
+    })?;
+    let path = token.parent_ancestors().find_map(ast::Expr::cast).or_else(|| {
+        stdx::never!(false, "cannot find path parent of variable usage: {:?}", token);
+        None
+    })?;
     stdx::always!(
         matches!(path, ast::Expr::PathExpr(_) | ast::Expr::MacroExpr(_)),
         "unexpected expression type for variable usage: {:?}",
     if !any_outlives {
         return None;
     }
-    Some(OutlivedLocal {
-        local,
-        mut_usage_outside_body: has_mut_usages,
-    })
+    Some(OutlivedLocal { local, mut_usage_outside_body: has_mut_usages })
 }
 
 /// checks if the relevant local was defined before(outside of) body
 fn make_call(ctx: &AssistContext<'_>, fun: &Function<'_>, indent: IndentLevel) -> SyntaxNode {
     let ret_ty = fun.return_type(ctx);
 
-    let args = make::arg_list(
-        fun.params
-            .iter()
-            .map(|param| param.to_arg(ctx, fun.mods.edition)),
-    );
+    let args = make::arg_list(fun.params.iter().map(|param| param.to_arg(ctx, fun.mods.edition)));
     let name = fun.name.clone();
     let mut call_expr = if fun.self_param.is_some() {
         let self_arg = make::expr_path(make::ext::ident_path("self"));
         [var] => {
             let name = var.local.name(ctx.db());
             let name = make::name(&name.display(ctx.db(), fun.mods.edition).to_string());
-            Some(ast::Pat::IdentPat(make::ident_pat(
-                false,
-                var.mut_usage_outside_body,
-                name,
-            )))
+            Some(ast::Pat::IdentPat(make::ident_pat(false, var.mut_usage_outside_body, name)))
         }
         vars => {
             let binding_pats = vars.iter().map(|var| {
 
     if let Some(bindings) = outliving_bindings {
         // with bindings that outlive it
-        make::let_stmt(bindings, None, Some(expr))
-            .syntax()
-            .clone_for_update()
+        make::let_stmt(bindings, None, Some(expr)).syntax().clone_for_update()
     } else if parent_match_arm.as_ref().is_some() {
         // as a tail expr for a match arm
         expr.syntax().clone()
     } else if parent_match_arm.as_ref().is_none()
         && fun.ret_ty.is_unit()
-        && (!fun.outliving_locals.is_empty() || !expr.is_block_like())
-    {
+        && (!fun.outliving_locals.is_empty() || !expr.is_block_like()) {
         // as an expr stmt
         make::expr_stmt(expr).syntax().clone_for_update()
     } else {
 
 enum FlowHandler<'db> {
     None,
-    Try { kind: TryKind<'db> },
-    If { action: FlowKind<'db> },
-    IfOption { action: FlowKind<'db> },
-    MatchOption { none: FlowKind<'db> },
-    MatchResult { err: FlowKind<'db> },
+    Try {
+        kind: TryKind<'db>,
+    },
+    If {
+        action: FlowKind<'db>,
+    },
+    IfOption {
+        action: FlowKind<'db>,
+    },
+    MatchOption {
+        none: FlowKind<'db>,
+    },
+    MatchResult {
+        err: FlowKind<'db>,
+    },
 }
 
 impl<'db> FlowHandler<'db> {
     /// Collect all the `TypeParam`s used in the `body` and `params`.
     fn type_params(&self, ctx: &AssistContext<'db>) -> Vec<TypeParam> {
         let type_params_in_descendant_paths =
-            self.body
-                .descendant_paths()
-                .filter_map(|it| match ctx.sema.resolve_path(&it) {
-                    Some(PathResolution::TypeParam(type_param)) => Some(type_param),
-                    _ => None,
-                });
-        let type_params_in_params = self
-            .params
-            .iter()
-            .filter_map(|p| p.ty.as_type_param(ctx.db()));
-        type_params_in_descendant_paths
-            .chain(type_params_in_params)
-            .collect()
+            self.body.descendant_paths().filter_map(|it| match ctx.sema.resolve_path(&it) {
+                Some(PathResolution::TypeParam(type_param)) => Some(type_param),
+                _ => None,
+            });
+        let type_params_in_params = self.params.iter().filter_map(|p| p.ty.as_type_param(ctx.db()));
+        type_params_in_descendant_paths.chain(type_params_in_params).collect()
     }
 
     fn make_param_list(
         edition: Edition,
     ) -> ast::ParamList {
         let self_param = self.self_param.clone();
-        let params = self
-            .params
-            .iter()
-            .map(|param| param.to_param(ctx, module, edition));
+        let params = self.params.iter().map(|param| param.to_param(ctx, module, edition));
         make::param_list(self_param, params)
     }
 
                 }
                 fun_ty.make_ty(ctx, module)
             }
-            FlowHandler::Try {
-                kind: TryKind::Option,
-            } => make::ext::ty_option(fun_ty.make_ty(ctx, module)),
-            FlowHandler::Try {
-                kind: TryKind::Result { ty: parent_ret_ty },
-            } => {
+            FlowHandler::Try { kind: TryKind::Option } => {
+                make::ext::ty_option(fun_ty.make_ty(ctx, module))
+            }
+            FlowHandler::Try { kind: TryKind::Result { ty: parent_ret_ty } } => {
                 let handler_ty = parent_ret_ty
                     .type_arguments()
                     .nth(1)
                 }
             }
         }
-        FunctionBody::Span {
-            parent, text_range, ..
-        } => {
+        FunctionBody::Span { parent, text_range, .. } => {
             let mut elements: Vec<_> = parent
                 .syntax()
                 .children_with_tokens()
         FlowHandler::None => block,
         FlowHandler::Try { kind } => {
             let block = with_default_tail_expr(block, make::ext::expr_unit());
-            map_tail_expr(block, |tail_expr| {
+            map_tail_expr(
+                block,
+                |tail_expr| {
                 let constructor = match kind {
                     TryKind::Option => "Some",
                     TryKind::Result { .. } => "Ok",
                 let func = make::expr_path(make::ext::ident_path(constructor));
                 let args = make::arg_list(iter::once(tail_expr));
                 make::expr_call(func, args).into()
-            })
+            },
+            )
         }
         FlowHandler::If { .. } => {
             let controlflow_continue = make::expr_call(
             let none = make::expr_path(make::ext::ident_path("None"));
             with_tail_expr(block, none)
         }
-        FlowHandler::MatchOption { .. } => map_tail_expr(block, |tail_expr| {
+        FlowHandler::MatchOption { .. } => map_tail_expr(
+            block,
+            |tail_expr| {
             let some = make::expr_path(make::ext::ident_path("Some"));
             let args = make::arg_list(iter::once(tail_expr));
             make::expr_call(some, args).into()
-        }),
-        FlowHandler::MatchResult { .. } => map_tail_expr(block, |tail_expr| {
+        },
+        ),
+        FlowHandler::MatchResult { .. } => map_tail_expr(
+            block,
+            |tail_expr| {
             let ok = make::expr_path(make::ext::ident_path("Ok"));
             let args = make::arg_list(iter::once(tail_expr));
             make::expr_call(ok, args).into()
-        }),
+        },
+        ),
     }
 }
 
     });
 
     if let Some(stmt_list) = block.stmt_list() {
-        stmt_list
-            .syntax()
-            .children_with_tokens()
-            .for_each(|node_or_token| {
-                if let syntax::NodeOrToken::Token(_) = &node_or_token {
-                    elements.push(node_or_token)
-                };
-            });
+        stmt_list.syntax().children_with_tokens().for_each(|node_or_token| {
+            if let syntax::NodeOrToken::Token(_) = &node_or_token {
+                elements.push(node_or_token)
+            };
+        });
     }
 
     if let Some(stmt_tail) = stmt_tail_opt {
 }
 
 fn format_type(ty: &hir::Type<'_>, ctx: &AssistContext<'_>, module: hir::Module) -> String {
-    ty.display_source_code(ctx.db(), module.into(), true)
-        .ok()
-        .unwrap_or_else(|| "_".to_owned())
+    ty.display_source_code(ctx.db(), module.into(), true).ok().unwrap_or_else(|| "_".to_owned())
 }
 
 fn make_ty(ty: &hir::Type<'_>, ctx: &AssistContext<'_>, module: hir::Module) -> ast::Type {
                 {
                     ted::replace(
                         node.syntax(),
-                        node.expr()
-                            .expect("RefExpr::expr() cannot be None")
-                            .syntax(),
+                        node.expr().expect("RefExpr::expr() cannot be None").syntax(),
                     );
                 }
                 Some(ast::Expr::RefExpr(node))
                 {
                     ted::replace(
                         node.syntax(),
-                        node.expr()
-                            .expect("RefExpr::expr() cannot be None")
-                            .syntax(),
+                        node.expr().expect("RefExpr::expr() cannot be None").syntax(),
                     );
                 }
                 Some(_) | None => {
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn no_args_from_binary_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_binary_expr_in_module() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_binary_expr_indented() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_stmt_with_last_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_stmt_unit() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_if() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_if_else() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_if_let_else() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_match() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_while() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_for() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_loop_unit() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_loop_with_return() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_args_from_match() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_partial_block_single_line() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_partial_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn argument_form_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn argument_used_twice_form_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn two_arguments_form_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn argument_and_locals() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn in_comment_is_not_applicable() {
         cov_mark::check!(extract_function_in_comment_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn main() { 1 + /* $0comment$0 */ 1; }");
     }
-
     #[test]
     fn empty_selection_is_not_applicable() {
         cov_mark::check!(extract_function_empty_selection_is_not_applicable);
 }"#,
         );
     }
-
     #[test]
     fn part_of_expr_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_from_nested() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_from_closure() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_return_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn does_not_add_extra_whitespace() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_cast() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn return_not_applicable() {
         check_assist_not_applicable(extract_function, r"fn foo() { $0return$0; } ");
     }
-
     #[test]
     fn method_to_freestanding() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_with_reference() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_with_mut() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn variable_defined_inside_and_used_after_no_ret() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn variable_defined_inside_and_used_after_mutably_no_ret() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn two_variables_defined_inside_and_used_after_no_ret() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn multi_variables_defined_inside_and_used_after_mutably_no_ret() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn nontrivial_patterns_define_variables() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_with_two_fields_pattern_define_variables() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_var_from_outer_scope() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_field_from_outer_scope() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_nested_field_from_outer_scope() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_param_many_usages_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_param_many_usages_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_param_by_value() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn mut_param_because_of_mut_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_param_by_value_because_of_mut_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn mut_method_call() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn shared_method_call() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn mut_method_call_with_other_receiver() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn non_copy_without_usages_after() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn non_copy_used_after() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn copy_used_after() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn copy_custom_used_after() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn indented_stmts() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn indented_stmts_inside_mod() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn return_to_parent() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_and_continue() {
         cov_mark::check!(external_control_flow_break_and_continue);
 "#,
         );
     }
-
     #[test]
     fn return_and_break() {
         cov_mark::check!(external_control_flow_return_and_bc);
 "#,
         );
     }
-
     #[test]
     fn break_loop_with_if() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_loop_nested() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_loop_nested_labeled() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn continue_loop_nested_labeled() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn return_from_nested_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_from_nested_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_from_nested_and_outer_loops() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn return_from_nested_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_with_value() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_with_value_and_label() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn break_with_value_and_return() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_option_unit() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_option_with_return() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_result_with_return() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn try_and_break() {
         cov_mark::check!(external_control_flow_try_and_bc);
 "#,
         );
     }
-
     #[test]
     fn try_and_return_ok() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_usage_in_macro() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_usage_in_macro_with_nested_tt() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn param_usage_in_macro_with_nested_tt_2() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_with_await() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_with_await_and_result_not_producing_match_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_with_await_and_result_producing_match_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_with_await_in_args() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_does_not_extract_standalone_blocks() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn extract_adds_comma_for_match_arm() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_does_not_tear_comments_apart() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_does_not_tear_body_apart() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_does_not_wrap_res_in_res() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_knows_const() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_does_not_move_outer_loop_vars() {
         check_assist(
 "#,
         );
     }
-
     // regression test for #9822
     #[test]
     fn extract_mut_ref_param_has_no_mut_binding_in_loop() {
 "#,
         );
     }
-
     #[test]
     fn extract_with_macro_arg() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn unresolvable_types_default_to_placeholder() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn reference_mutable_param_with_further_usages() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn reference_mutable_param_without_further_usages() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_copies_comment_at_start() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_copies_comment_in_between() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_copies_comment_at_end() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_copies_comment_indented() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_does_preserve_whitespace() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_function_long_form_comment() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn it_should_not_generate_duplicate_function_names() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn should_increment_suffix_until_it_finds_space() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_method_from_trait_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_method_from_trait_with_existing_non_empty_impl_block() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_function_from_trait_with_existing_non_empty_impl_block() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_method_from_trait_with_multiple_existing_impl_blocks() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_method_from_trait_with_multiple_existing_trait_impl_blocks() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn closure_arguments() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn preserve_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn dont_emit_type_with_hidden_lifetime_parameter() {
         // FIXME: We should emit a `<T: Debug>` generic argument for the generated function
 "#,
         );
     }
-
     #[test]
     fn preserve_generics_from_body() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn filter_unused_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn empty_generic_param_list() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn preserve_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn filter_unused_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn nested_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn filters_unused_nested_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn nested_where_clauses() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn filters_unused_nested_where_clauses() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn tail_expr_no_extra_control_flow() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn non_tail_expr_of_tail_expr_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn non_tail_expr_of_tail_if_block() {
         // FIXME: double semicolon
 "#,
         );
     }
-
     #[test]
     fn tail_expr_of_tail_block_nested() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn non_tail_expr_with_comment_of_tail_expr_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn comments_in_block_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn sort_params_in_order() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn fmt_macro_argument() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn in_left_curly_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo() { $0}$0");
     }
-
     #[test]
     fn in_right_curly_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo() $0{$0 }");
     }
-
     #[test]
     fn in_left_paren_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo( $0)$0 { }");
     }
-
     #[test]
     fn in_right_paren_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo $0($0 ) { }");
     }
-
     #[test]
     fn in_left_brack_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);
         check_assist_not_applicable(extract_function, r"fn foo(arr: &mut [i32$0]$0) {}");
     }
-
     #[test]
     fn in_right_brack_is_not_applicable() {
         cov_mark::check!(extract_function_in_braces_is_not_applicable);