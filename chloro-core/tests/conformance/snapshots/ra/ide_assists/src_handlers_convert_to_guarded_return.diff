COMPARISON DIFF
============================================================

Original size: 22391 bytes
Chloro size:   22330 bytes
Rustfmt size:  22662 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     AstNode,
     SyntaxKind::{CLOSURE_EXPR, FN, FOR_EXPR, LOOP_EXPR, WHILE_EXPR, WHITESPACE},
     SyntaxNode, T,
-    ast::{
-        self,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
-    },
+    ast::{self, edit::{AstNodeEdit, IndentLevel}, make},
 };
 
 use crate::{
     let if_token_range = if_expr.if_token()?.text_range();
     let if_cond_range = cond.syntax().text_range();
 
-    let cursor_in_range = if_token_range
-        .cover(if_cond_range)
-        .contains_range(ctx.selection_trimmed());
+    let cursor_in_range =
+        if_token_range.cover(if_cond_range).contains_range(ctx.selection_trimmed());
     if !cursor_in_range {
         return None;
     }
     let then_branch = if_expr.then_branch()?;
     let then_block = then_branch.stmt_list()?;
 
-    let parent_block = if_expr
-        .syntax()
-        .parent()?
-        .ancestors()
-        .find_map(ast::BlockExpr::cast)?;
+    let parent_block = if_expr.syntax().parent()?.ancestors().find_map(ast::BlockExpr::cast)?;
 
     if parent_block.tail_expr()? != if_expr.clone().into() {
         return None;
         })?
         .reset_indent();
 
-    then_block
-        .syntax()
-        .first_child_or_token()
-        .map(|t| t.kind() == T!['{'])?;
+    then_block.syntax().first_child_or_token().map(|t| t.kind() == T!['{'])?;
 
-    then_block
-        .syntax()
-        .last_child_or_token()
-        .filter(|t| t.kind() == T!['}'])?;
+    then_block.syntax().last_child_or_token().filter(|t| t.kind() == T!['}'])?;
 
     let then_block_items = then_block.dedent(IndentLevel(1));
 
 
     let let_token_range = let_stmt.let_token()?.text_range();
     let let_pattern_range = pat.syntax().text_range();
-    let cursor_in_range = let_token_range
-        .cover(let_pattern_range)
-        .contains_range(ctx.selection_trimmed());
+    let cursor_in_range =
+        let_token_range.cover(let_pattern_range).contains_range(ctx.selection_trimmed());
 
     if !cursor_in_range || let_stmt.let_else().is_some() {
         return None;
     }
 
-    let try_enum = ctx
-        .sema
-        .type_of_expr(&expr)
-        .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty.adjusted()))?;
+    let try_enum =
+        ctx.sema.type_of_expr(&expr).and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty.adjusted()))?;
 
     let happy_pattern = try_enum.happy_pattern(pat);
     let target = let_stmt.syntax().text_range();
 
     let early_expression: ast::Expr = {
-        let parent_block = let_stmt
-            .syntax()
-            .parent()?
-            .ancestors()
-            .find_map(ast::BlockExpr::cast)?;
+        let parent_block =
+            let_stmt.syntax().parent()?.ancestors().find_map(ast::BlockExpr::cast)?;
         let parent_container = parent_block.syntax().parent()?;
 
         early_expression(parent_container, &ctx.sema)?
         if !matches!(rhs, ast::Expr::LetExpr(_))
             && let Some(last) = chains.pop_if(|last| !matches!(last, ast::Expr::LetExpr(_)))
         {
-            chains.push(make::expr_bin_op(
-                rhs,
-                ast::BinaryOp::LogicOp(ast::LogicOp::And),
-                last,
-            ));
+            chains.push(make::expr_bin_op(rhs, ast::BinaryOp::LogicOp(ast::LogicOp::And), last));
         } else {
             chains.push(rhs);
         }
         _ => None,
     };
     then_block.tail_expr().is_some_and(is_early_expr)
-        || then_block
-            .statements()
-            .filter_map(into_expr)
-            .any(is_early_expr)
+        || then_block.statements().filter_map(into_expr).any(is_early_expr)
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn convert_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_fn_return_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_closure() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_has_never_type_else_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_result_inside_let() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_chain_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_mut_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_ref_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_while() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_while() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_for() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_fn_return_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_arbitrary_if_let_patterns() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn ignore_already_converted_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_already_converted_loop() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_return() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_else_branch() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_let_else_branch() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_statements_after_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_statements_inside_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_inside_if_stmt() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_inside_let_initializer() {
         check_assist_not_applicable(