COMPARISON DIFF
============================================================

Original size: 22391 bytes
Chloro size:   22000 bytes
Rustfmt size:  22391 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::iter::once;
 
 use either::Either;
 use hir::{Semantics, TypeInfo};
 use ide_db::{RootDatabase, ty_filter::TryEnum};
 use syntax::{
-    AstNode,
-    SyntaxKind::{CLOSURE_EXPR, FN, FOR_EXPR, LOOP_EXPR, WHILE_EXPR, WHITESPACE},
-    SyntaxNode, T,
     ast::{
-        self,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
-    },
+        self, edit::{AstNodeEdit, make, AstNode, IndentLevel},
+    SyntaxKind::{CLOSURE_EXPR, SyntaxNode, FN, FOR_EXPR, LOOP_EXPR, T, WHILE_EXPR, WHITESPACE}, },
 };
 
 use crate::{
-    AssistId,
-    assist_context::{AssistContext, Assists},
-    utils::{invert_boolean_expression_legacy, is_never_block},
+    assist_context::{AssistContext, is_never_block}, utils::{invert_boolean_expression_legacy,
+    AssistId, Assists},
 };
 
-// Assist: convert_to_guarded_return
-//
-// Replace a large conditional with a guarded return.
-//
-// ```
-// fn main() {
-//     $0if cond {
-//         foo();
-//         bar();
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     if !cond {
-//         return;
-//     }
-//     foo();
-//     bar();
-// }
-// ```
-pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn convert_to_guarded_return(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     match ctx.find_node_at_offset::<Either<ast::LetStmt, ast::IfExpr>>()? {
         Either::Left(let_stmt) => let_stmt_to_guarded_return(let_stmt, acc, ctx),
         Either::Right(if_expr) => if_expr_to_guarded_return(if_expr, acc, ctx),
         Some(_) => return None,
         _ => None,
     };
-
     let cond = if_expr.condition()?;
-
     let if_token_range = if_expr.if_token()?.text_range();
     let if_cond_range = cond.syntax().text_range();
-
     let cursor_in_range =
         if_token_range.cover(if_cond_range).contains_range(ctx.selection_trimmed());
     if !cursor_in_range {
         return None;
     }
-
     let let_chains = flat_let_chain(cond);
-
     let then_branch = if_expr.then_branch()?;
     let then_block = then_branch.stmt_list()?;
-
     let parent_block = if_expr.syntax().parent()?.ancestors().find_map(ast::BlockExpr::cast)?;
-
     if parent_block.tail_expr()? != if_expr.clone().into() {
         return None;
     }
-
     // check for early return and continue
     if is_early_block(&then_block) || is_never_block(&ctx.sema, &then_branch) {
         return None;
     }
-
     let parent_container = parent_block.syntax().parent()?;
-
     let early_expression = else_block
         .or_else(|| {
             early_expression(parent_container, &ctx.sema).map(ast::make::tail_only_block_expr)
         })?
         .reset_indent();
-
     then_block.syntax().first_child_or_token().map(|t| t.kind() == T!['{'])?;
-
     then_block.syntax().last_child_or_token().filter(|t| t.kind() == T!['}'])?;
-
     let then_block_items = then_block.dedent(IndentLevel(1));
-
     let end_of_then = then_block_items.syntax().last_child_or_token()?;
     let end_of_then = if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {
         end_of_then.prev_sibling_or_token()?
     } else {
         end_of_then
     };
-
     let target = if_expr.syntax().text_range();
     acc.add(
         AssistId::refactor_rewrite("convert_to_guarded_return"),
 ) -> Option<()> {
     let pat = let_stmt.pat()?;
     let expr = let_stmt.initializer()?;
-
     let let_token_range = let_stmt.let_token()?.text_range();
     let let_pattern_range = pat.syntax().text_range();
     let cursor_in_range =
         let_token_range.cover(let_pattern_range).contains_range(ctx.selection_trimmed());
-
     if !cursor_in_range || let_stmt.let_else().is_some() {
         return None;
     }
-
     let try_enum =
         ctx.sema.type_of_expr(&expr).and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty.adjusted()))?;
-
     let happy_pattern = try_enum.happy_pattern(pat);
     let target = let_stmt.syntax().text_range();
-
     let early_expression: ast::Expr = {
         let parent_block =
             let_stmt.syntax().parent()?.ancestors().find_map(ast::BlockExpr::cast)?;
 
         early_expression(parent_container, &ctx.sema)?
     };
-
     acc.add(
         AssistId::refactor_rewrite("convert_to_guarded_return"),
         "Convert to guarded return",
     {
         return Some(return_none_expr());
     }
-
     Some(match parent_container.kind() {
         WHILE_EXPR | LOOP_EXPR | FOR_EXPR => make::expr_continue(None),
         FN | CLOSURE_EXPR => make::expr_return(None),
             chains.push(rhs);
         }
     };
-
     while let ast::Expr::BinExpr(bin_expr) = &expr
         && bin_expr.op_kind() == Some(ast::BinaryOp::LogicOp(ast::LogicOp::And))
         && let (Some(lhs), Some(rhs)) = (bin_expr.lhs(), bin_expr.rhs())
         reduce_cond(rhs);
         expr = lhs;
     }
-
     reduce_cond(expr);
     chains.reverse();
     chains
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn convert_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_fn_return_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_closure() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_has_never_type_else_block() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             convert_to_guarded_return,
             r#"
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_result_inside_let() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_chain_result() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             convert_to_guarded_return,
             r#"
 }
 "#,
         );
-
         check_assist(
             convert_to_guarded_return,
             r#"
 }
 "#,
         );
-
         check_assist(
             convert_to_guarded_return,
             r#"
 }
 "#,
         );
-
         check_assist(
             convert_to_guarded_return,
             r#"
 "#,
         );
     }
-
     #[test]
     fn convert_let_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_mut_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_ref_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_while() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_while() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_for() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_fn_return_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_arbitrary_if_let_patterns() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             convert_to_guarded_return,
             r#"
 }
 "#,
         );
-
         check_assist(
             convert_to_guarded_return,
             r#"
 "#,
         );
     }
-
     #[test]
     fn ignore_already_converted_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_already_converted_loop() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_return() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_else_branch() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_let_else_branch() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_statements_after_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_statements_inside_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_inside_if_stmt() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_inside_let_initializer() {
         check_assist_not_applicable(