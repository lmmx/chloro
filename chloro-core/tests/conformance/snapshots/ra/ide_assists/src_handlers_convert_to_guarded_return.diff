COMPARISON DIFF
============================================================

Original size: 22391 bytes
Chloro size:   21935 bytes
Rustfmt size:  22391 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::iter::once;
 
 use either::Either;
 use hir::{Semantics, TypeInfo};
-use ide_db::{RootDatabase, ty_filter::TryEnum};
+use ide_db::{ty_filter::TryEnum, RootDatabase};
 use syntax::{
+    ast::{self, edit::{AstNodeEdit, IndentLevel}, make},
     AstNode,
     SyntaxKind::{CLOSURE_EXPR, FN, FOR_EXPR, LOOP_EXPR, WHILE_EXPR, WHITESPACE},
     SyntaxNode, T,
-    ast::{
-        self,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
-    },
 };
 
 use crate::{
-    AssistId,
     assist_context::{AssistContext, Assists},
     utils::{invert_boolean_expression_legacy, is_never_block},
+    AssistId,
 };
 
-// Assist: convert_to_guarded_return
-//
-// Replace a large conditional with a guarded return.
-//
-// ```
-// fn main() {
-//     $0if cond {
-//         foo();
-//         bar();
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     if !cond {
-//         return;
-//     }
-//     foo();
-//     bar();
-// }
-// ```
 pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     match ctx.find_node_at_offset::<Either<ast::LetStmt, ast::IfExpr>>()? {
         Either::Left(let_stmt) => let_stmt_to_guarded_return(let_stmt, acc, ctx),
         "Convert to guarded return",
         target,
         |edit| {
-            let if_indent_level = IndentLevel::from_node(if_expr.syntax());
-            let replacement = let_chains.into_iter().map(|expr| {
+        let if_indent_level = IndentLevel::from_node(if_expr.syntax());
+        let replacement = let_chains.into_iter().map(|expr| {
                 if let ast::Expr::LetExpr(let_expr) = &expr
                     && let (Some(pat), Some(expr)) = (let_expr.pat(), let_expr.expr())
                 {
                     new_expr.syntax().clone()
                 }
             });
-
-            let newline = &format!("\n{if_indent_level}");
-            let then_statements = replacement
+        let newline = &format!("\n{if_indent_level}");
+        let then_statements = replacement
                 .enumerate()
                 .flat_map(|(i, node)| {
                     (i != 0)
                         .take_while(|i| *i != end_of_then),
                 )
                 .collect();
-            let mut editor = edit.make_editor(if_expr.syntax());
-            editor.replace_with_many(if_expr.syntax(), then_statements);
-            edit.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        let mut editor = edit.make_editor(if_expr.syntax());
+        editor.replace_with_many(if_expr.syntax(), then_statements);
+        edit.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
         "Convert to guarded return",
         target,
         |edit| {
-            let let_indent_level = IndentLevel::from_node(let_stmt.syntax());
-
-            let replacement = {
+        let let_indent_level = IndentLevel::from_node(let_stmt.syntax());
+        let replacement = {
                 let let_else_stmt = make::let_else_stmt(
                     happy_pattern,
                     let_stmt.ty(),
                 let let_else_stmt = let_else_stmt.indent(let_indent_level);
                 let_else_stmt.syntax().clone()
             };
-            let mut editor = edit.make_editor(let_stmt.syntax());
-            editor.replace(let_stmt.syntax(), replacement);
-            edit.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        let mut editor = edit.make_editor(let_stmt.syntax());
+        editor.replace(let_stmt.syntax(), replacement);
+        edit.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
 }
 
 fn clean_stmt_block(block: &ast::BlockExpr) -> ast::BlockExpr {
-    if block.statements().next().is_none()
-        && let Some(tail_expr) = block.tail_expr()
-        && block.modifier().is_none()
-    {
+    if block.statements().next().is_none() && let Some(tail_expr) = block.tail_expr() && block.modifier().is_none() {
         make::block_expr(once(make::expr_stmt(tail_expr).into()), None)
     } else {
         block.clone()
         ast::Stmt::ExprStmt(expr_stmt) => expr_stmt.expr(),
         _ => None,
     };
-    then_block.tail_expr().is_some_and(is_early_expr)
-        || then_block.statements().filter_map(into_expr).any(is_early_expr)
+    then_block.tail_expr().is_some_and(is_early_expr) || then_block.statements().filter_map(into_expr).any(is_early_expr)
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn convert_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_fn_return_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_closure() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_has_never_type_else_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_result_inside_let() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_if_let_chain_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_mut_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_ref_ok_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_while() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_while() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_inside_for() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_fn_return_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_let_stmt_inside_loop() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_arbitrary_if_let_patterns() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn ignore_already_converted_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_already_converted_loop() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_return() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_else_branch() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_let_else_branch() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_statements_after_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_statements_inside_if() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_inside_if_stmt() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn ignore_inside_let_initializer() {
         check_assist_not_applicable(