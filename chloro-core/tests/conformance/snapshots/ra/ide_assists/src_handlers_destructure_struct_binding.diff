COMPARISON DIFF
============================================================

Original size: 23187 bytes
Chloro size:   22717 bytes
Rustfmt size:  23470 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     utils::ref_field_expr::determine_ref_and_parens,
 };
 
-// Assist: destructure_struct_binding
-//
-// Destructures a struct binding in place.
-//
-// ```
-// struct Foo {
-//     bar: i32,
-//     baz: i32,
-// }
-// fn main() {
-//     let $0foo = Foo { bar: 1, baz: 2 };
-//     let bar2 = foo.bar;
-//     let baz2 = &foo.baz;
-// }
-// ```
-// ->
-// ```
-// struct Foo {
-//     bar: i32,
-//     baz: i32,
-// }
-// fn main() {
-//     let Foo { bar, baz } = Foo { bar: 1, baz: 2 };
-//     let bar2 = bar;
-//     let baz2 = &baz;
-// }
-// ```
-pub(crate) fn destructure_struct_binding(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn destructure_struct_binding(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let ident_pat = ctx.find_node_at_offset::<ast::IdentPat>()?;
     let data = collect_data(ident_pat, ctx)?;
 
 
 fn collect_data(ident_pat: ast::IdentPat, ctx: &AssistContext<'_>) -> Option<StructEditData> {
     let ty = ctx.sema.type_of_binding_in_pat(&ident_pat)?;
-    let hir::Adt::Struct(struct_type) = ty.strip_references().as_adt()? else {
-        return None;
-    };
+    let hir::Adt::Struct(struct_type) = ty.strip_references().as_adt()? else { return None };
 
     let module = ctx.sema.scope(ident_pat.syntax())?.module();
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(module.krate()));
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
     let struct_def = hir::ModuleDef::from(struct_type);
     let kind = struct_type.kind(ctx.db());
     let struct_def_path = module.find_path(ctx.db(), struct_def, cfg)?;
 
-    let is_non_exhaustive = struct_def
-        .attrs(ctx.db())?
-        .by_key(sym::non_exhaustive)
-        .exists();
-    let is_foreign_crate = struct_def
-        .module(ctx.db())
-        .is_some_and(|m| m.krate() != module.krate());
+    let is_non_exhaustive = struct_def.attrs(ctx.db())?.by_key(sym::non_exhaustive).exists();
+    let is_foreign_crate = struct_def.module(ctx.db()).is_some_and(|m| m.krate() != module.krate());
 
     let fields = struct_type.fields(ctx.db());
     let n_fields = fields.len();
 
-    let visible_fields = fields
-        .into_iter()
-        .filter(|field| field.is_visible_from(ctx.db(), module))
-        .collect_vec();
+    let visible_fields =
+        fields.into_iter().filter(|field| field.is_visible_from(ctx.db(), module)).collect_vec();
 
     if visible_fields.is_empty() {
         return None;
     }
 
     // If available, find names visible to the last usage of the binding
+
     // else, find names visible to the binding itself
     let last_usage = last_usage(usages);
     let node = last_usage.as_ref().unwrap_or(ident_pat.syntax());
     };
 
     // If the binding is nested inside a record, we need to wrap the new
+
     // destructured pattern in a non-shorthand record field
     let destructured_pat = if data.need_record_field_name {
-        make.record_pat_field(make.name_ref(&name.to_string()), new_pat)
-            .syntax()
-            .clone()
+        make.record_pat_field(make.name_ref(&name.to_string()), new_pat).syntax().clone()
     } else {
         new_pat.syntax().clone()
     };
     editor.replace(data.ident_pat.syntax(), destructured_pat);
 }
 
-fn generate_field_names(ctx: &AssistContext<'_>, data: &StructEditData) -> Vec<(SmolStr, SmolStr)> {
+fn generate_field_names(
+    ctx: &AssistContext<'_>,
+    data: &StructEditData,
+) -> Vec<(SmolStr, SmolStr)> {
     match data.kind {
         hir::StructKind::Tuple => data
             .visible_fields
             .visible_fields
             .iter()
             .map(|field| {
-                let field_name = field
-                    .name(ctx.db())
-                    .display_no_db(data.edition)
-                    .to_smolstr();
+                let field_name = field.name(ctx.db()).display_no_db(data.edition).to_smolstr();
                 let new_name = new_field_name(field_name.clone(), &data.names_in_scope);
                 (field_name, new_name)
             })
     usage: &FileReference,
     field_names: &FxHashMap<SmolStr, SmolStr>,
 ) -> Option<(SyntaxNode, SyntaxNode)> {
-    match usage
-        .name
-        .syntax()
-        .ancestors()
-        .find_map(ast::FieldExpr::cast)
-    {
+    match usage.name.syntax().ancestors().find_map(ast::FieldExpr::cast) {
         Some(field_expr) => Some({
             let field_name: SmolStr = field_expr.name_ref()?.to_string().into();
             let new_field_name = field_names.get(&field_name)?;
                     ref_data.wrap_expr(new_expr).syntax().clone_for_update(),
                 )
             } else {
-                (
-                    field_expr.syntax().clone(),
-                    new_expr.syntax().clone_for_update(),
-                )
+                (field_expr.syntax().clone(), new_expr.syntax().clone_for_update())
             }
         }),
         None => Some((
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn record_struct() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn tuple_struct() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn unit_struct() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn in_foreign_crate() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn non_exhaustive_record_appends_rest() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn non_exhaustive_tuple_not_applicable() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn non_exhaustive_unit_not_applicable() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn record_private_fields_appends_rest() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn tuple_private_fields_not_applicable() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn nested_inside_record() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn nested_inside_tuple() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn mut_record() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn mut_record_field() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn ref_record_field() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn ref_mut_record_field() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn ref_mut_record_renamed_field() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn mut_ref() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn ref_not_add_parenthesis_and_deref_record() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn ref_not_add_parenthesis_and_deref_tuple() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn record_struct_name_collision() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn tuple_struct_name_collision() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn record_struct_name_collision_nested_scope() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn record_struct_no_public_members() {
         check_assist_not_applicable(