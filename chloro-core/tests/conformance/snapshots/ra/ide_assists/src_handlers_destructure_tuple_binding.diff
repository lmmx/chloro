COMPARISON DIFF
============================================================

Original size: 44220 bytes
Chloro size:   43344 bytes
Rustfmt size:  44620 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
     acc.add(
         AssistId::refactor_rewrite("destructure_tuple_binding"),
-        if with_sub_pattern {
-            "Destructure tuple in place"
-        } else {
-            "Destructure tuple"
-        },
+        if with_sub_pattern { "Destructure tuple in place" } else { "Destructure tuple" },
         data.ident_pat.syntax().text_range(),
         |edit| destructure_tuple_edit_impl(ctx, edit, &data, false),
     );
 
     assignment_edit.apply();
     if let Some(usages_edit) = current_file_usages_edit {
-        usages_edit
-            .into_iter()
-            .for_each(|usage_edit| usage_edit.apply(edit))
+        usages_edit.into_iter().for_each(|usage_edit| usage_edit.apply(edit))
     }
 }
 
         })
         .collect::<Vec<_>>();
 
-    Some(TupleData {
-        ident_pat,
-        ref_type,
-        field_names,
-        usages,
-    })
+    Some(TupleData { ident_pat, ref_type, field_names, usages })
 }
 
 enum RefType {
     ReadOnly,
     Mutable,
 }
+
 struct TupleData {
     ident_pat: IdentPat,
     ref_type: Option<RefType>,
     field_names: Vec<String>,
     usages: Option<Vec<FileReference>>,
 }
+
 fn edit_tuple_assignment(
     ctx: &AssistContext<'_>,
     edit: &mut SourceChangeBuilder,
         if let Some(ast::Pat::IdentPat(first_pat)) = tuple_pat.fields().next() {
             edit.add_tabstop_before(
                 cap,
-                first_pat
-                    .name()
-                    .expect("first ident pattern should have a name"),
+                first_pat.name().expect("first ident pattern should have a name"),
             )
         }
     }
 
-    AssignmentEdit {
-        ident_pat,
-        tuple_pat,
-        in_sub_pattern,
-        is_shorthand_field,
-    }
+    AssignmentEdit { ident_pat, tuple_pat, in_sub_pattern, is_shorthand_field }
 }
+
 struct AssignmentEdit {
     ident_pat: ast::IdentPat,
     tuple_pat: ast::TuplePat,
         if self.in_sub_pattern {
             self.ident_pat.set_pat(Some(self.tuple_pat.into()))
         } else if self.is_shorthand_field {
-            ted::insert(
-                ted::Position::after(self.ident_pat.syntax()),
-                self.tuple_pat.syntax(),
-            );
-            ted::insert_raw(
-                ted::Position::after(self.ident_pat.syntax()),
-                make::token(T![:]),
-            );
+            ted::insert(ted::Position::after(self.ident_pat.syntax()), self.tuple_pat.syntax());
+            ted::insert_raw(ted::Position::after(self.ident_pat.syntax()), make::token(T![:]));
         } else {
             ted::replace(self.ident_pat.syntax(), self.tuple_pat.syntax())
         }
     // We also defer editing usages in the current file first since
     // tree mutation in the same file breaks when `builder.edit_file`
     // is called
-
     let edits = data
         .usages
         .as_ref()?
 
     Some(edits)
 }
+
 fn edit_tuple_usage(
     ctx: &AssistContext<'_>,
     builder: &mut SourceChangeBuilder,
         EditTupleUsage::ReplaceExpr(field_expr.into(), field_name)
     }
 }
+
 enum EditTupleUsage {
     /// no index access -> make invalid -> requires handling by user
     /// -> put usage in block comment
                 edit.insert(range.start(), "/*");
                 edit.insert(range.end(), "*/");
             }
-            EditTupleUsage::ReplaceExpr(target_expr, replace_with) => ted::replace(
-                target_expr.syntax(),
-                replace_with.clone_for_update().syntax(),
-            ),
+            EditTupleUsage::ReplaceExpr(target_expr, replace_with) => {
+                ted::replace(target_expr.syntax(), replace_with.clone_for_update().syntax())
+            }
         }
     }
 }
     index: usize,
     field_expr: FieldExpr,
 }
+
 fn detect_tuple_index(usage: &FileReference, data: &TupleData) -> Option<TupleIndex> {
     // usage is IDENT
     // IDENT
     //     PATH_EXPR
     //      PAREN_EXRP*
     //       FIELD_EXPR
-
     let node = usage
         .name
         .syntax()
         let idx = field_expr.name_ref()?.as_tuple_field()?;
         if idx < data.field_names.len() {
             // special case: in macro call -> range of `field_expr` in applied macro, NOT range in actual file!
-            if field_expr
-                .syntax()
-                .ancestors()
-                .any(|a| ast::MacroStmts::can_cast(a.kind()))
-            {
+            if field_expr.syntax().ancestors().any(|a| ast::MacroStmts::can_cast(a.kind())) {
                 cov_mark::hit!(destructure_tuple_macro_call);
 
                 // issue: cannot differentiate between tuple index passed into macro or tuple index as result of macro:
                 return None;
             }
 
-            Some(TupleIndex {
-                index: idx,
-                field_expr,
-            })
+            Some(TupleIndex { index: idx, field_expr })
         } else {
             // tuple index out of range
             None
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     // Tests for direct tuple destructure:
     // `let $0t = (1,2);` -> `let (_0, _1) = (1,2);`
-
     fn assist(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
         destructure_tuple_binding_impl(acc, ctx, false)
     }
-
     #[test]
     fn dont_trigger_on_unit() {
         cov_mark::check!(destructure_tuple_no_tuple);
-        check_assist_not_applicable(
-            assist,
-            r#"
+        check_assist_not_applicable(assist, r#"
 fn main() {
 let $0v = ();
 }
-            "#,
-        )
+            "#)
     }
     #[test]
     fn dont_trigger_on_number() {
         cov_mark::check!(destructure_tuple_no_tuple);
-        check_assist_not_applicable(
-            assist,
-            r#"
+        check_assist_not_applicable(assist, r#"
 fn main() {
 let $0v = 32;
 }
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn destructure_3_tuple() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn replace_usage_in_parentheses() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn handle_function_call() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn handle_invalid_index() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn dont_replace_variable_with_same_name_as_tuple() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn keep_function_call_in_tuple_item() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn keep_type() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn destructure_reference() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn destructure_multiple_reference() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn keep_reference() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn with_ref() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn with_mut() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn with_ref_mut() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn dont_trigger_for_non_tuple_reference() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn dont_trigger_on_static_tuple() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn dont_trigger_on_wildcard() {
-        check_assist_not_applicable(
-            assist,
-            r#"
+        check_assist_not_applicable(assist, r#"
 fn main() {
     let $0_ = (1,2);
 }
-            "#,
-        )
+            "#)
     }
-
     #[test]
     fn dont_trigger_in_struct() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn dont_trigger_in_struct_creation() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn dont_trigger_on_tuple_struct() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn dont_trigger_when_subpattern_exists() {
         // sub-pattern is only allowed with IdentPat (name), not other patterns (like TuplePat)
             "#,
         )
     }
-
     #[test]
     fn in_subpattern() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_record_shorthand_field() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_record_field() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_nested_tuple() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_closure() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_closure_args() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_function_args() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_if_let() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_match() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn in_for() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn not_applicable_on_tuple_usage() {
         //Improvement: might be reasonable to allow & implement
             "#,
         )
     }
-
     #[test]
     fn replace_all() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn non_trivial_tuple_assignment() {
         check_assist(
             "#,
         )
     }
-
     mod assist {
         use super::*;
         use crate::tests::check_assist_by_label;
-
         fn assist(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
             destructure_tuple_binding_impl(acc, ctx, true)
         }
         fn in_place_assist(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
             destructure_tuple_binding_impl(acc, ctx, false)
         }
-
         pub(crate) fn check_in_place_assist(
             #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
             #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
                 "Destructure tuple",
             );
         }
-
         pub(crate) fn check_sub_pattern_assist(
             #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
             #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
                 "Destructure tuple in sub-pattern",
             );
         }
-
         pub(crate) fn check_both_assists(
             ra_fixture_before: &str,
             ra_fixture_after_in_place: &str,
             check_sub_pattern_assist(ra_fixture_before, ra_fixture_after_in_sub_pattern);
         }
     }
-
     /// Tests for destructure of tuple in sub-pattern:
     /// `let $0t = (1,2);` -> `let t @ (_0, _1) = (1,2);`
     mod sub_pattern {
         use super::assist::*;
         use super::*;
         use crate::tests::check_assist_by_label;
-
         #[test]
         fn destructure_in_sub_pattern() {
             check_sub_pattern_assist(
                 "#,
             )
         }
-
         #[test]
         fn trigger_both_destructure_tuple_assists() {
             fn assist(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
                 "Destructure tuple in sub-pattern",
             );
         }
-
         #[test]
         fn replace_indices() {
             check_sub_pattern_assist(
                 "#,
             )
         }
-
         #[test]
         fn keep_function_call() {
             cov_mark::check!(destructure_tuple_call_with_subpattern);
                 "#,
             )
         }
-
         #[test]
         fn keep_type() {
             check_sub_pattern_assist(
                 "#,
             )
         }
-
         #[test]
         fn in_function_args() {
             check_sub_pattern_assist(
                 "#,
             )
         }
-
         #[test]
         fn with_ref() {
             check_sub_pattern_assist(
             )
         }
     }
-
     /// Tests for tuple usage in macro call:
     /// `println!("{}", t.0)`
     mod in_macro_call {
         use super::assist::*;
-
         #[test]
         fn detect_macro_call() {
             cov_mark::check!(destructure_tuple_macro_call);
                 "#,
             )
         }
-
         #[test]
         fn tuple_usage() {
             check_both_assists(
-                // leading `"foo"` to ensure `$e` doesn't start at position `0`
                 r#"
 macro_rules! m {
     ($e:expr) => { "foo"; $e };
                 "#,
             )
         }
-
         #[test]
         fn tuple_function_usage() {
             check_both_assists(
                 "#,
             )
         }
-
         #[test]
         fn tuple_index_usage() {
             check_both_assists(
     m!(t.0);
 }
                 "#,
-                // FIXME: replace `t.0` with `_0` (cannot detect range of tuple index in macro call)
                 r#"
 macro_rules! m {
     ($e:expr) => { "foo"; $e };
     m!(/*t*/.0);
 }
                 "#,
-                // FIXME: replace `t.0` with `_0`
                 r#"
 macro_rules! m {
     ($e:expr) => { "foo"; $e };
                 "#,
             )
         }
-
         #[test]
         fn tuple_in_parentheses_index_usage() {
             check_both_assists(
     m!((t).0);
 }
                 "#,
-                // FIXME: replace `(t).0` with `_0`
                 r#"
 macro_rules! m {
     ($e:expr) => { "foo"; $e };
     m!((/*t*/).0);
 }
                 "#,
-                // FIXME: replace `(t).0` with `_0`
                 r#"
 macro_rules! m {
     ($e:expr) => { "foo"; $e };
                 "#,
             )
         }
-
         #[test]
         fn empty_macro() {
             check_in_place_assist(
     m!(t);
 }
                 "#,
-                // FIXME: macro allows no arg -> is valid. But assist should result in invalid code
                 r#"
 macro_rules! m {
     () => { "foo" };
                 "#,
             )
         }
-
         #[test]
         fn tuple_index_in_macro() {
             check_both_assists(
     m!(t, t.0);
 }
                 "#,
-                // FIXME: replace `t.0` in macro call (not IN macro) with `_0`
                 r#"
 macro_rules! m {
     ($t:expr, $i:expr) => { $t.0 + $i };
     m!(/*t*/, /*t*/.0);
 }
                 "#,
-                // FIXME: replace `t.0` in macro call with `_0`
                 r#"
 macro_rules! m {
     ($t:expr, $i:expr) => { $t.0 + $i };
             )
         }
     }
-
     mod refs {
         use super::assist::*;
-
         #[test]
         fn no_ref() {
             check_in_place_assist(
                 "#,
             )
         }
-
         #[test]
         fn deref_and_parentheses() {
             // Operator/Expressions with higher precedence than deref (`*`):
                 "#,
             )
         }
-
         // ---------
         // auto-ref/deref
-
         #[test]
         fn self_auto_ref_doesnt_need_deref() {
             check_in_place_assist(
                 "#,
             )
         }
-
         #[test]
         fn self_owned_requires_deref() {
             check_in_place_assist(
                 "#,
             )
         }
-
         #[test]
         fn self_auto_ref_in_trait_call_doesnt_require_deref() {
             check_in_place_assist(
     let s = t.0.f();
 }
                 "#,
-                // FIXME: doesn't need deref * parens. But `ctx.sema.resolve_method_call` doesn't resolve trait implementations
                 r#"
 trait T {
     fn f(self);
                 "#,
             )
         }
-
         #[test]
         fn no_outer_parens_when_ref_deref() {
             check_in_place_assist(
                 "#,
             )
         }
-
         #[test]
         fn auto_ref_deref() {
             check_in_place_assist(
                 "#,
             )
         }
-
         #[test]
         fn mutable() {
             check_in_place_assist(
                 "#,
             )
         }
-
         #[test]
         fn with_ref_keyword() {
             check_in_place_assist(