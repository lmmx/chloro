COMPARISON DIFF
============================================================

Original size: 18779 bytes
Chloro size:   18798 bytes
Rustfmt size:  19207 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 // ```
 
 enum WrapUnwrapOption {
-    WrapDerive { derive: TextRange, attr: ast::Attr },
+    WrapDerive {
+        derive: TextRange,
+        attr: ast::Attr,
+    },
     WrapAttr(ast::Attr),
 }
 
                     derive = derive.cover(prev.text_range());
                 }
 
-                Some(WrapUnwrapOption::WrapDerive {
-                    derive,
-                    attr: attr.clone(),
-                })
+                Some(WrapUnwrapOption::WrapDerive { derive, attr: attr.clone() })
             } else {
                 let mut consumed_comma = false;
                 // Collect the path
                     }
                     following = next_token.next_sibling_or_token()?.into_token()?;
                 }
-                Some(WrapUnwrapOption::WrapDerive {
-                    derive,
-                    attr: attr.clone(),
-                })
+                Some(WrapUnwrapOption::WrapDerive { derive, attr: attr.clone() })
             }
         }
     };
     if ident.parent().and_then(ast::TokenTree::cast).is_none()
-        || !attr
-            .simple_name()
-            .map(|v| v.eq("derive"))
-            .unwrap_or_default()
-    {
+        || !attr.simple_name().map(|v| v.eq("derive")).unwrap_or_default() {
         WrapUnwrapOption::WrapAttr(attr)
     } else {
         attempt_attr().unwrap_or(WrapUnwrapOption::WrapAttr(attr))
     }
 }
+
 pub(crate) fn wrap_unwrap_cfg_attr(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let option = if ctx.has_empty_selection() {
         let ident = ctx.find_token_syntax_at_offset(T![ident]);
         let attr = ctx.find_node_at_offset::<ast::Attr>();
         match (attr, ident) {
             (Some(attr), Some(ident))
-                if attr
-                    .simple_name()
-                    .map(|v| v.eq("derive"))
-                    .unwrap_or_default() =>
+                if attr.simple_name().map(|v| v.eq("derive")).unwrap_or_default() =>
             {
                 Some(attempt_get_derive(attr, ident))
             }
     let handle_source_change = |edit: &mut SourceChangeBuilder| {
         let make = SyntaxFactory::with_mappings();
         let mut editor = edit.make_editor(attr.syntax());
-        let new_derive = make.attr_outer(make.meta_token_tree(
-            make.ident_path("derive"),
-            make.token_tree(T!['('], new_derive),
-        ));
+        let new_derive = make.attr_outer(
+            make.meta_token_tree(make.ident_path("derive"), make.token_tree(T!['('], new_derive)),
+        );
         let meta = make.meta_token_tree(
             make.ident_path("cfg_attr"),
             make.token_tree(
         );
 
         if let Some(snippet_cap) = ctx.config.snippet_cap
-            && let Some(first_meta) = cfg_attr
-                .meta()
-                .and_then(|meta| meta.token_tree())
-                .and_then(|tt| tt.l_paren_token())
+            && let Some(first_meta) =
+                cfg_attr.meta().and_then(|meta| meta.token_tree()).and_then(|tt| tt.l_paren_token())
         {
             let tabstop = edit.make_tabstop_after(snippet_cap);
             editor.add_annotation(first_meta, tabstop);
     );
     Some(())
 }
+
 fn wrap_cfg_attr(acc: &mut Assists, ctx: &AssistContext<'_>, attr: ast::Attr) -> Option<()> {
     let range = attr.syntax().text_range();
     let path = attr.path()?;
     let handle_source_change = |edit: &mut SourceChangeBuilder| {
         let make = SyntaxFactory::with_mappings();
         let mut editor = edit.make_editor(attr.syntax());
-        let mut raw_tokens = vec![
-            NodeOrToken::Token(make.token(T![,])),
-            NodeOrToken::Token(make.whitespace(" ")),
-        ];
+        let mut raw_tokens =
+            vec![NodeOrToken::Token(make.token(T![,])), NodeOrToken::Token(make.whitespace(" "))];
         path.syntax().descendants_with_tokens().for_each(|it| {
             if let NodeOrToken::Token(token) = it {
                 raw_tokens.push(NodeOrToken::Token(token));
                 raw_tokens.extend(tt.token_trees_and_tokens());
             }
         }
-        let meta = make.meta_token_tree(
-            make.ident_path("cfg_attr"),
-            make.token_tree(T!['('], raw_tokens),
-        );
-        let cfg_attr = if attr.excl_token().is_some() {
-            make.attr_inner(meta)
-        } else {
-            make.attr_outer(meta)
-        };
+        let meta =
+            make.meta_token_tree(make.ident_path("cfg_attr"), make.token_tree(T!['('], raw_tokens));
+        let cfg_attr =
+            if attr.excl_token().is_some() { make.attr_inner(meta) } else { make.attr_outer(meta) };
 
         editor.replace(attr.syntax(), cfg_attr.syntax());
 
         if let Some(snippet_cap) = ctx.config.snippet_cap
-            && let Some(first_meta) = cfg_attr
-                .meta()
-                .and_then(|meta| meta.token_tree())
-                .and_then(|tt| tt.l_paren_token())
+            && let Some(first_meta) =
+                cfg_attr.meta().and_then(|meta| meta.token_tree()).and_then(|tt| tt.l_paren_token())
         {
             let tabstop = edit.make_tabstop_after(snippet_cap);
             editor.add_annotation(first_meta, tabstop);
     );
     Some(())
 }
+
 fn unwrap_cfg_attr(acc: &mut Assists, attr: ast::Attr) -> Option<()> {
     let range = attr.syntax().text_range();
     let meta = attr.meta()?;
             continue;
         }
         let Some(attr_name) = tt.into_token().and_then(|token| {
-            if token.kind() == T![ident] {
-                Some(make::ext::ident_path(token.text()))
-            } else {
-                None
-            }
+            if token.kind() == T![ident] { Some(make::ext::ident_path(token.text())) } else { None }
         }) else {
             continue;
         };
     );
     Some(())
 }
+
 #[cfg(test)]
 mod tests {
     use crate::tests::check_assist;
-
     use super::*;
-
     #[test]
     fn test_basic_to_from_cfg_attr() {
         check_assist(