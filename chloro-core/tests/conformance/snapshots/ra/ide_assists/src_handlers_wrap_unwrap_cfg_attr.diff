COMPARISON DIFF
============================================================

Original size: 18779 bytes
Chloro size:   18499 bytes
Rustfmt size:  18779 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::source_change::SourceChangeBuilder;
 use itertools::Itertools;
 use syntax::{
-    NodeOrToken, SyntaxToken, T, TextRange, algo,
-    ast::{self, AstNode, make, syntax_factory::SyntaxFactory},
+    algo,
+    ast::{make, self, syntax_factory::SyntaxFactory, AstNode},
+    NodeOrToken, SyntaxToken, TextRange, T,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: wrap_unwrap_cfg_attr
-//
-// Wraps an attribute to a cfg_attr attribute or unwraps a cfg_attr attribute to the inner attributes.
-//
-// ```
-// #[derive$0(Debug)]
-// struct S {
-//    field: i32
-// }
-// ```
-// ->
-// ```
-// #[cfg_attr($0, derive(Debug))]
-// struct S {
-//    field: i32
-// }
-// ```
-
 enum WrapUnwrapOption {
-    WrapDerive { derive: TextRange, attr: ast::Attr },
+    WrapDerive {
+        derive: TextRange,
+        attr: ast::Attr,
+    },
     WrapAttr(ast::Attr),
 }
 
         attempt_attr().unwrap_or(WrapUnwrapOption::WrapAttr(attr))
     }
 }
+
 pub(crate) fn wrap_unwrap_cfg_attr(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let option = if ctx.has_empty_selection() {
         let ident = ctx.find_token_syntax_at_offset(T![ident]);
     let range = attr.syntax().text_range();
     let token_tree = attr.token_tree()?;
     let mut path_text = String::new();
-
     let mut cfg_derive_tokens = Vec::new();
     let mut new_derive = Vec::new();
-
     for tt in token_tree.token_trees_and_tokens() {
         let NodeOrToken::Token(token) = tt else {
             continue;
         editor.add_mappings(make.finish_with_mappings());
         edit.add_file_edits(ctx.vfs_file_id(), editor);
     };
-
     acc.add(
         AssistId::refactor("wrap_unwrap_cfg_attr"),
         format!("Wrap #[derive({path_text})] in `cfg_attr`",),
     );
     Some(())
 }
+
 fn wrap_cfg_attr(acc: &mut Assists, ctx: &AssistContext<'_>, attr: ast::Attr) -> Option<()> {
     let range = attr.syntax().text_range();
     let path = attr.path()?;
     );
     Some(())
 }
+
 fn unwrap_cfg_attr(acc: &mut Assists, attr: ast::Attr) -> Option<()> {
     let range = attr.syntax().text_range();
     let meta = attr.meta()?;
     );
     Some(())
 }
+
 #[cfg(test)]
 mod tests {
     use crate::tests::check_assist;
-
     use super::*;
-
     #[test]
     fn test_basic_to_from_cfg_attr() {
         check_assist(