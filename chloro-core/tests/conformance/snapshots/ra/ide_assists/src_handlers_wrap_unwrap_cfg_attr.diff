COMPARISON DIFF
============================================================

Original size: 18779 bytes
Chloro size:   18811 bytes
Rustfmt size:  18779 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::source_change::SourceChangeBuilder;
 use itertools::Itertools;
 use syntax::{
-    NodeOrToken, SyntaxToken, T, TextRange, algo,
-    ast::{self, AstNode, make, syntax_factory::SyntaxFactory},
+    algo,
+    ast::{self, make, syntax_factory::SyntaxFactory, AstNode},
+    NodeOrToken, SyntaxToken, TextRange, T,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
+
 // Assist: wrap_unwrap_cfg_attr
+
 //
+
 // Wraps an attribute to a cfg_attr attribute or unwraps a cfg_attr attribute to the inner attributes.
+
 //
-// ```
-// #[derive$0(Debug)]
-// struct S {
-//    field: i32
-// }
-// ```
-// ->
-// ```
-// #[cfg_attr($0, derive(Debug))]
-// struct S {
-//    field: i32
-// }
+
 // ```
 
+// #[derive$0(Debug)]
+
+// struct S {
+
+//    field: i32
+
+// }
+
+// ```
+
+// ->
+
+// ```
+
+// #[cfg_attr($0, derive(Debug))]
+
+// struct S {
+
+//    field: i32
+
+// }
+
+// ```
 enum WrapUnwrapOption {
-    WrapDerive { derive: TextRange, attr: ast::Attr },
+    WrapDerive {
+        derive: TextRange,
+        attr: ast::Attr,
+    },
     WrapAttr(ast::Attr),
 }
 
             }
         }
     };
-    if ident.parent().and_then(ast::TokenTree::cast).is_none()
-        || !attr.simple_name().map(|v| v.eq("derive")).unwrap_or_default()
-    {
+    if ident.parent().and_then(ast::TokenTree::cast).is_none() || !attr.simple_name().map(|v| v.eq("derive")).unwrap_or_default() {
         WrapUnwrapOption::WrapAttr(attr)
     } else {
         attempt_attr().unwrap_or(WrapUnwrapOption::WrapAttr(attr))
     }
 }
+
 pub(crate) fn wrap_unwrap_cfg_attr(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let option = if ctx.has_empty_selection() {
         let ident = ctx.find_token_syntax_at_offset(T![ident]);
     match option {
         WrapUnwrapOption::WrapAttr(attr) if attr.simple_name().as_deref() == Some("cfg_attr") => {
             unwrap_cfg_attr(acc, attr)
-        }
+        },
         WrapUnwrapOption::WrapAttr(attr) => wrap_cfg_attr(acc, ctx, attr),
         WrapUnwrapOption::WrapDerive { derive, attr } => wrap_derive(acc, ctx, attr, derive),
     }
     );
     Some(())
 }
+
 fn wrap_cfg_attr(acc: &mut Assists, ctx: &AssistContext<'_>, attr: ast::Attr) -> Option<()> {
     let range = attr.syntax().text_range();
     let path = attr.path()?;
     );
     Some(())
 }
+
 fn unwrap_cfg_attr(acc: &mut Assists, attr: ast::Attr) -> Option<()> {
     let range = attr.syntax().text_range();
     let meta = attr.meta()?;
     );
     Some(())
 }
+
 #[cfg(test)]
 mod tests {
     use crate::tests::check_assist;
-
     use super::*;
-
     #[test]
     fn test_basic_to_from_cfg_attr() {
         check_assist(