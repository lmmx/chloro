COMPARISON DIFF
============================================================

Original size: 12008 bytes
Chloro size:   11662 bytes
Rustfmt size:  12073 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     AssistId,
 };
 
-// Assist: add_turbo_fish
-//
-// Adds `::<_>` to a call of a generic method or function.
-//
-// ```
-// fn make<T>() -> T { todo!() }
-// fn main() {
-//     let x = make$0();
-// }
-// ```
-// ->
-// ```
-// fn make<T>() -> T { todo!() }
-// fn main() {
-//     let x = make::<${0:_}>();
-// }
-// ```
 pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
-    let turbofish_target = ctx
-        .find_node_at_offset::<ast::PathSegment>()
-        .map(Either::Left)
-        .or_else(|| {
+    let turbofish_target =
+        ctx.find_node_at_offset::<ast::PathSegment>().map(Either::Left).or_else(|| {
             let callable_expr = ctx.find_node_at_offset::<ast::CallableExpr>()?;
 
             if callable_expr.arg_list()?.args().next().is_some() {
     let number_of_arguments = generics
         .iter()
         .filter(|param| {
-            matches!(
-                param,
-                hir::GenericParam::TypeParam(_) | hir::GenericParam::ConstParam(_)
-            )
+            matches!(param, hir::GenericParam::TypeParam(_) | hir::GenericParam::ConstParam(_))
         })
         .count();
 
         "Add `::<>`",
         ident.text_range(),
         |builder| {
-            builder.trigger_parameter_hints();
-
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = match &turbofish_target {
+        builder.trigger_parameter_hints();
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = match &turbofish_target {
                 Either::Left(it) => builder.make_editor(it.syntax()),
                 Either::Right(it) => builder.make_editor(it.syntax()),
             };
-
-            let fish_head = get_fish_head(&make, number_of_arguments);
-
-            match turbofish_target {
+        let fish_head = get_fish_head(&make, number_of_arguments);
+        match turbofish_target {
                 Either::Left(path_segment) => {
                     if let Some(generic_arg_list) = path_segment.generic_arg_list() {
                         editor.replace(generic_arg_list.syntax(), fish_head.syntax());
                     }
                 }
             };
-
-            if let Some(cap) = ctx.config.snippet_cap {
+        if let Some(cap) = ctx.config.snippet_cap {
                 for arg in fish_head.generic_args() {
                     editor.add_annotation(arg.syntax(), builder.make_placeholder_snippet(cap));
                 }
             }
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
         check_assist, check_assist_by_label, check_assist_not_applicable,
         check_assist_not_applicable_by_label,
     };
-
     use super::*;
-
     #[test]
     fn add_turbo_fish_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_function_multiple_generic_types() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_function_many_generic_types() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_after_call() {
         cov_mark::check!(add_turbo_fish_after_call);
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_method() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_one_fish_is_enough() {
         cov_mark::check!(add_turbo_fish_one_fish_is_enough);
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_non_generic() {
         cov_mark::check!(add_turbo_fish_non_generic);
 "#,
         );
     }
-
     #[test]
     fn add_type_ascription_function() {
         check_assist_by_label(
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_type_ascription_after_call() {
         cov_mark::check!(add_type_ascription_after_call);
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_type_ascription_method() {
         check_assist_by_label(
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_type_ascription_already_typed() {
         cov_mark::check!(add_type_ascription_already_typed);
 "#,
         );
     }
-
     #[test]
     fn add_type_ascription_append_semicolon() {
         check_assist_by_label(
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_type_ascription_missing_pattern() {
         check_assist_not_applicable_by_label(
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_turbo_fish_function_lifetime_parameter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_function_const_parameter() {
         check_assist(