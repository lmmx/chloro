COMPARISON DIFF
============================================================

Original size: 12008 bytes
Chloro size:   11714 bytes
Rustfmt size:  12073 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use ide_db::defs::{Definition, NameRefClass};
 use syntax::{
-    ast::{self, make, syntax_factory::SyntaxFactory, HasArgList, HasGenericArgs},
-    syntax_editor::Position,
-    AstNode,
+    ast::{self, HasArgList, HasGenericArgs, make, syntax_factory::SyntaxFactory},
+    syntax_editor::Position, AstNode,
 };
 
 use crate::{
-    assist_context::{AssistContext, Assists},
     AssistId,
+    assist_context::{AssistContext, Assists},
 };
 
-// Assist: add_turbo_fish
-//
-// Adds `::<_>` to a call of a generic method or function.
-//
-// ```
-// fn make<T>() -> T { todo!() }
-// fn main() {
-//     let x = make$0();
-// }
-// ```
-// ->
-// ```
-// fn make<T>() -> T { todo!() }
-// fn main() {
-//     let x = make::<${0:_}>();
-// }
-// ```
-pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
-    let turbofish_target = ctx
-        .find_node_at_offset::<ast::PathSegment>()
-        .map(Either::Left)
-        .or_else(|| {
+pub(crate) fn add_turbo_fish(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
+    let turbofish_target =
+        ctx.find_node_at_offset::<ast::PathSegment>().map(Either::Left).or_else(|| {
             let callable_expr = ctx.find_node_at_offset::<ast::CallableExpr>()?;
 
             if callable_expr.arg_list()?.args().next().is_some() {
                 ast::CallableExpr::MethodCall(it) => Some(Either::Right(it)),
             }
         })?;
-
     let already_has_turbofish = match &turbofish_target {
         Either::Left(path_segment) => path_segment.generic_arg_list().is_some(),
         Either::Right(method_call) => method_call.generic_arg_list().is_some(),
     };
-
     if already_has_turbofish {
         cov_mark::hit!(add_turbo_fish_one_fish_is_enough);
         return None;
     }
-
     let name_ref = match &turbofish_target {
         Either::Left(path_segment) => path_segment.name_ref()?,
         Either::Right(method_call) => method_call.name_ref()?,
     };
     let ident = name_ref.ident_token()?;
-
     let def = match NameRefClass::classify(&ctx.sema, &name_ref)? {
         NameRefClass::Definition(def, _) => def,
         NameRefClass::FieldShorthand { .. } | NameRefClass::ExternCrateShorthand { .. } => {
         cov_mark::hit!(add_turbo_fish_non_generic);
         return None;
     }
-
     if let Some(let_stmt) = ctx.find_node_at_offset::<ast::LetStmt>() {
         if let_stmt.colon_token().is_none() {
             let_stmt.pat()?;
             cov_mark::hit!(add_type_ascription_already_typed);
         }
     }
-
     let number_of_arguments = generics
         .iter()
         .filter(|param| {
-            matches!(
-                param,
-                hir::GenericParam::TypeParam(_) | hir::GenericParam::ConstParam(_)
-            )
+            matches!(param, hir::GenericParam::TypeParam(_) | hir::GenericParam::ConstParam(_))
         })
         .count();
-
     acc.add(
         AssistId::refactor_rewrite("add_turbo_fish"),
         "Add `::<>`",
 }
 
 /// This will create a turbofish generic arg list corresponding to the number of arguments
-fn get_fish_head(make: &SyntaxFactory, number_of_arguments: usize) -> ast::GenericArgList {
+fn get_fish_head(
+    make: &SyntaxFactory,
+    number_of_arguments: usize,
+) -> ast::GenericArgList {
     let args = (0..number_of_arguments).map(|_| make::type_arg(make::ty_placeholder()).into());
     make.generic_arg_list(args, true)
 }
         check_assist, check_assist_by_label, check_assist_not_applicable,
         check_assist_not_applicable_by_label,
     };
-
     use super::*;
-
     #[test]
     fn add_turbo_fish_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_function_multiple_generic_types() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_function_many_generic_types() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_after_call() {
         cov_mark::check!(add_turbo_fish_after_call);
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_method() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_one_fish_is_enough() {
         cov_mark::check!(add_turbo_fish_one_fish_is_enough);
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_non_generic() {
         cov_mark::check!(add_turbo_fish_non_generic);
 "#,
         );
     }
-
     #[test]
     fn add_type_ascription_function() {
         check_assist_by_label(
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_type_ascription_after_call() {
         cov_mark::check!(add_type_ascription_after_call);
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_type_ascription_method() {
         check_assist_by_label(
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_type_ascription_already_typed() {
         cov_mark::check!(add_type_ascription_already_typed);
 "#,
         );
     }
-
     #[test]
     fn add_type_ascription_append_semicolon() {
         check_assist_by_label(
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_type_ascription_missing_pattern() {
         check_assist_not_applicable_by_label(
             "Add `: _` before assignment operator",
         );
     }
-
     #[test]
     fn add_turbo_fish_function_lifetime_parameter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_turbo_fish_function_const_parameter() {
         check_assist(