COMPARISON DIFF
============================================================

Original size: 14570 bytes
Chloro size:   14347 bytes
Rustfmt size:  14570 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use itertools::Itertools;
 use syntax::{
-    Edition, NodeOrToken, SyntaxNode, SyntaxToken, T,
-    ast::{self, AstNode, make},
+    ast::{make, self, AstNode},
     match_ast,
     syntax_editor::{Position, SyntaxEditor},
+    Edition, NodeOrToken, SyntaxNode, SyntaxToken, T,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: remove_dbg
-//
-// Removes `dbg!()` macro call.
-//
-// ```
-// fn main() {
-//     let x = $0dbg!(42 * dbg!(4 + 2));$0
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x = 42 * (4 + 2);
-// }
-// ```
 pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let macro_calls = if ctx.has_empty_selection() {
         vec![ctx.find_node_at_offset::<ast::MacroExpr>()?]
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     fn check(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
             &format!("fn main() {{\n{ra_fixture_after}\n}}"),
         );
     }
-
     #[test]
     fn test_remove_dbg() {
         check("$0dbg!(1 + 1)", "1 + 1");
         check("dbg![$01 + 1]", "1 + 1");
         check("dbg!{$01 + 1}", "1 + 1");
     }
-
     #[test]
     fn test_remove_simple_dbg_statement() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_remove_trailing_comma_dbg() {
         check("$0dbg!(1 + 1,)", "1 + 1");
         check("$0dbg!(1 + 1, 2 + 3, )", "(1 + 1, 2 + 3)");
         check("$0dbg!(1 + 1, 2 + 3 ,)", "(1 + 1, 2 + 3)");
     }
-
     #[test]
     fn test_remove_dbg_not_applicable() {
         check_assist_not_applicable(remove_dbg, "fn main() {$0vec![1, 2, 3]}");
         check_assist_not_applicable(remove_dbg, "fn main() {$0dbg(5, 6, 7)}");
         check_assist_not_applicable(remove_dbg, "fn main() {$0dbg!(5, 6, 7}");
     }
-
     #[test]
     fn test_remove_dbg_keep_semicolon_in_let() {
         // https://github.com/rust-lang/rust-analyzer/issues/5129#issuecomment-651399779
             r#"let res = (1, 2); // needless comment"#,
         );
     }
-
     #[test]
     fn test_remove_dbg_cast_cast() {
         check(r#"let res = $0dbg!(x as u32) as u32;"#, r#"let res = x as u32 as u32;"#);
     }
-
     #[test]
     fn test_remove_dbg_prefix() {
         check(r#"let res = $0dbg!(&result).foo();"#, r#"let res = (&result).foo();"#);
         check(r#"let res = &$0dbg!(&result);"#, r#"let res = &&result;"#);
         check(r#"let res = $0dbg!(!result) && true;"#, r#"let res = !result && true;"#);
     }
-
     #[test]
     fn test_remove_dbg_post_expr() {
         check(r#"let res = $0dbg!(fut.await).foo();"#, r#"let res = fut.await.foo();"#);
         check(r#"let res = $0dbg!(array[3]).foo();"#, r#"let res = array[3].foo();"#);
         check(r#"let res = $0dbg!(tuple.3).foo();"#, r#"let res = tuple.3.foo();"#);
     }
-
     #[test]
     fn test_remove_dbg_range_expr() {
         check(r#"let res = $0dbg!(foo..bar).foo();"#, r#"let res = (foo..bar).foo();"#);
         check(r#"let res = $0dbg!(foo..=bar).foo();"#, r#"let res = (foo..=bar).foo();"#);
     }
-
     #[test]
     fn test_remove_empty_dbg() {
         check_assist(remove_dbg, r#"fn foo() { $0dbg!(); }"#, r#"fn foo() { }"#);
 }"#,
         );
     }
-
     #[test]
     fn test_remove_multi_dbg() {
         check(r#"$0dbg!(0, 1)"#, r#"(0, 1)"#);
         check(r#"$0dbg!(0, (1, 2))"#, r#"(0, (1, 2))"#);
     }
-
     #[test]
     fn test_range() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_range_partial() {
         check_assist_not_applicable(remove_dbg, r#"$0dbg$0!(0)"#);
         check_assist_not_applicable(remove_dbg, r#"$0dbg!(0$0)"#);
     }
-
     #[test]
     fn test_nested_dbg() {
         check(
         );
         check(r#"$0dbg!(10, dbg!(), dbg!(20, 30))$0"#, r#"(10, (), (20, 30))"#);
     }
-
     #[test]
     fn test_multiple_nested_dbg() {
         check(