COMPARISON DIFF
============================================================

Original size: 14570 bytes
Chloro size:   14338 bytes
Rustfmt size:  14570 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use itertools::Itertools;
 use syntax::{
-    Edition, NodeOrToken, SyntaxNode, SyntaxToken, T,
-    ast::{self, AstNode, make},
-    match_ast,
-    syntax_editor::{Position, SyntaxEditor},
+    ast::{self, AstNode, make}, match_ast, syntax_editor::{Position, SyntaxEditor}, Edition,
+    NodeOrToken, SyntaxNode, SyntaxToken, T,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: remove_dbg
-//
-// Removes `dbg!()` macro call.
-//
-// ```
-// fn main() {
-//     let x = $0dbg!(42 * dbg!(4 + 2));$0
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x = 42 * (4 + 2);
-// }
-// ```
-pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn remove_dbg(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let macro_calls = if ctx.has_empty_selection() {
         vec![ctx.find_node_at_offset::<ast::MacroExpr>()?]
     } else {
             .filter_map(|it| it.syntax().parent().and_then(ast::MacroExpr::cast))
             .collect()
     };
-
     let replacements =
         macro_calls.into_iter().filter_map(compute_dbg_replacement).collect::<Vec<_>>();
     let target = replacements
 /// - (`macro_expr` has no parent - is that possible?)
 ///
 /// Returns `Some(_, None)` when the macro call should just be removed.
-fn compute_dbg_replacement(
-    macro_expr: ast::MacroExpr,
-) -> Option<(Vec<NodeOrToken<SyntaxNode, SyntaxToken>>, Option<ast::Expr>)> {
+fn compute_dbg_replacement(macro_expr: ast::MacroExpr) -> Option<(Vec<NodeOrToken<SyntaxNode, SyntaxToken>>, Option<ast::Expr>)> {
     let macro_call = macro_expr.macro_call()?;
     let tt = macro_call.token_tree()?;
     let r_delim = NodeOrToken::Token(tt.right_delimiter_token()?);
     {
         return None;
     }
-
     let mac_input = tt.syntax().children_with_tokens().skip(1).take_while(|it| *it != r_delim);
     let input_expressions = mac_input.chunk_by(|tok| tok.kind() == T![,]);
     let input_expressions = input_expressions
         .filter(|tokens| !tokens.iter().all(|it| it.kind().is_trivia()))
         .map(|tokens| syntax::hacks::parse_expr_from_str(&tokens.iter().join(""), Edition::CURRENT))
         .collect::<Option<Vec<ast::Expr>>>()?;
-
     let parent = macro_expr.syntax().parent()?;
     Some(match &*input_expressions {
         // dbg!()
 
         return replaced;
     }
-
     let expanded = expanded.clone_subtree();
     let mut editor = SyntaxEditor::new(expanded.syntax().clone());
     // We need to collect to avoid mutation during traversal.
     let macro_exprs: Vec<_> =
         expanded.syntax().descendants().filter_map(ast::MacroExpr::cast).collect();
-
     for mac in macro_exprs {
         let expr_opt = match compute_dbg_replacement(mac.clone()) {
             Some((_, expr)) => expr,
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     fn check(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
             &format!("fn main() {{\n{ra_fixture_after}\n}}"),
         );
     }
-
     #[test]
     fn test_remove_dbg() {
         check("$0dbg!(1 + 1)", "1 + 1");
         check("dbg![$01 + 1]", "1 + 1");
         check("dbg!{$01 + 1}", "1 + 1");
     }
-
     #[test]
     fn test_remove_simple_dbg_statement() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_remove_trailing_comma_dbg() {
         check("$0dbg!(1 + 1,)", "1 + 1");
         check("$0dbg!(1 + 1, 2 + 3, )", "(1 + 1, 2 + 3)");
         check("$0dbg!(1 + 1, 2 + 3 ,)", "(1 + 1, 2 + 3)");
     }
-
     #[test]
     fn test_remove_dbg_not_applicable() {
         check_assist_not_applicable(remove_dbg, "fn main() {$0vec![1, 2, 3]}");
         check_assist_not_applicable(remove_dbg, "fn main() {$0dbg(5, 6, 7)}");
         check_assist_not_applicable(remove_dbg, "fn main() {$0dbg!(5, 6, 7}");
     }
-
     #[test]
     fn test_remove_dbg_keep_semicolon_in_let() {
         // https://github.com/rust-lang/rust-analyzer/issues/5129#issuecomment-651399779
             r#"let res = (1, 2); // needless comment"#,
         );
     }
-
     #[test]
     fn test_remove_dbg_cast_cast() {
         check(r#"let res = $0dbg!(x as u32) as u32;"#, r#"let res = x as u32 as u32;"#);
     }
-
     #[test]
     fn test_remove_dbg_prefix() {
         check(r#"let res = $0dbg!(&result).foo();"#, r#"let res = (&result).foo();"#);
         check(r#"let res = &$0dbg!(&result);"#, r#"let res = &&result;"#);
         check(r#"let res = $0dbg!(!result) && true;"#, r#"let res = !result && true;"#);
     }
-
     #[test]
     fn test_remove_dbg_post_expr() {
         check(r#"let res = $0dbg!(fut.await).foo();"#, r#"let res = fut.await.foo();"#);
         check(r#"let res = $0dbg!(array[3]).foo();"#, r#"let res = array[3].foo();"#);
         check(r#"let res = $0dbg!(tuple.3).foo();"#, r#"let res = tuple.3.foo();"#);
     }
-
     #[test]
     fn test_remove_dbg_range_expr() {
         check(r#"let res = $0dbg!(foo..bar).foo();"#, r#"let res = (foo..bar).foo();"#);
         check(r#"let res = $0dbg!(foo..=bar).foo();"#, r#"let res = (foo..=bar).foo();"#);
     }
-
     #[test]
     fn test_remove_empty_dbg() {
         check_assist(remove_dbg, r#"fn foo() { $0dbg!(); }"#, r#"fn foo() { }"#);
 }"#,
         );
     }
-
     #[test]
     fn test_remove_multi_dbg() {
         check(r#"$0dbg!(0, 1)"#, r#"(0, 1)"#);
         check(r#"$0dbg!(0, (1, 2))"#, r#"(0, (1, 2))"#);
     }
-
     #[test]
     fn test_range() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_range_partial() {
         check_assist_not_applicable(remove_dbg, r#"$0dbg$0!(0)"#);
         check_assist_not_applicable(remove_dbg, r#"$0dbg!(0$0)"#);
     }
-
     #[test]
     fn test_nested_dbg() {
         check(
         );
         check(r#"$0dbg!(10, dbg!(), dbg!(20, 30))$0"#, r#"(10, (), (20, 30))"#);
     }
-
     #[test]
     fn test_multiple_nested_dbg() {
         check(