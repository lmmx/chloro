COMPARISON DIFF
============================================================

Original size: 14570 bytes
Chloro size:   14241 bytes
Rustfmt size:  14570 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use itertools::Itertools;
 use syntax::{
-    Edition, NodeOrToken, SyntaxNode, SyntaxToken, T,
-    ast::{self, AstNode, make},
+    ast::{self, make, AstNode},
     match_ast,
     syntax_editor::{Position, SyntaxEditor},
+    Edition, NodeOrToken, SyntaxNode, SyntaxToken, T,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: remove_dbg
-//
-// Removes `dbg!()` macro call.
-//
-// ```
-// fn main() {
-//     let x = $0dbg!(42 * dbg!(4 + 2));$0
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x = 42 * (4 + 2);
-// }
-// ```
 pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let macro_calls = if ctx.has_empty_selection() {
         vec![ctx.find_node_at_offset::<ast::MacroExpr>()?]
         .flat_map(|(node_or_token, _)| node_or_token.iter())
         .map(|t| t.text_range())
         .reduce(|acc, range| acc.cover(range))?;
-    acc.add(AssistId::quick_fix("remove_dbg"), "Remove dbg!()", target, |builder| {
+    acc.add(
+        AssistId::quick_fix("remove_dbg"),
+        "Remove dbg!()",
+        target,
+        |builder| {
         let mut editor = builder.make_editor(ctx.source_file().syntax());
         for (range, expr) in replacements {
             if let Some(expr) = expr {
             }
         }
         builder.add_file_edits(ctx.vfs_file_id(), editor);
-    })
+    },
+    )
 }
 
 /// Returns `None` when either
 
     let parent = macro_expr.syntax().parent()?;
     Some(match &*input_expressions {
-        // dbg!()
         [] => {
             match_ast! {
                 match parent {
                     _ => (vec![macro_call.syntax().clone().into()], Some(make::ext::expr_unit())),
                 }
             }
-        }
-        // dbg!(2, 'x', &x, x, ...);
+        },
         exprs if ast::ExprStmt::can_cast(parent.kind()) && exprs.iter().all(pure_expr) => {
             let mut replace = vec![parent.clone().into()];
             if let Some(prev_sibling) = parent.prev_sibling_or_token()
                 replace.push(prev_sibling);
             }
             (replace, None)
-        }
-        // dbg!(expr0)
+        },
         [expr] => {
-            // dbg!(expr, &parent);
             let wrap = match ast::Expr::cast(parent) {
                 Some(parent) => match (expr, parent) {
                     (ast::Expr::CastExpr(_), ast::Expr::CastExpr(_)) => false,
             let expr = replace_nested_dbgs(expr.clone());
             let expr = if wrap { make::expr_paren(expr).into() } else { expr.clone_subtree() };
             (vec![macro_call.syntax().clone().into()], Some(expr))
-        }
-        // dbg!(expr0, expr1, ...)
+        },
         exprs => {
             let exprs = exprs.iter().cloned().map(replace_nested_dbgs);
             let expr = make::expr_tuple(exprs);
             (vec![macro_call.syntax().clone().into()], Some(expr.into()))
-        }
+        },
     })
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     fn check(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
             &format!("fn main() {{\n{ra_fixture_after}\n}}"),
         );
     }
-
     #[test]
     fn test_remove_dbg() {
         check("$0dbg!(1 + 1)", "1 + 1");
         check("dbg![$01 + 1]", "1 + 1");
         check("dbg!{$01 + 1}", "1 + 1");
     }
-
     #[test]
     fn test_remove_simple_dbg_statement() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_remove_trailing_comma_dbg() {
         check("$0dbg!(1 + 1,)", "1 + 1");
         check("$0dbg!(1 + 1, 2 + 3, )", "(1 + 1, 2 + 3)");
         check("$0dbg!(1 + 1, 2 + 3 ,)", "(1 + 1, 2 + 3)");
     }
-
     #[test]
     fn test_remove_dbg_not_applicable() {
         check_assist_not_applicable(remove_dbg, "fn main() {$0vec![1, 2, 3]}");
         check_assist_not_applicable(remove_dbg, "fn main() {$0dbg(5, 6, 7)}");
         check_assist_not_applicable(remove_dbg, "fn main() {$0dbg!(5, 6, 7}");
     }
-
     #[test]
     fn test_remove_dbg_keep_semicolon_in_let() {
         // https://github.com/rust-lang/rust-analyzer/issues/5129#issuecomment-651399779
             r#"let res = (1, 2); // needless comment"#,
         );
     }
-
     #[test]
     fn test_remove_dbg_cast_cast() {
         check(r#"let res = $0dbg!(x as u32) as u32;"#, r#"let res = x as u32 as u32;"#);
     }
-
     #[test]
     fn test_remove_dbg_prefix() {
         check(r#"let res = $0dbg!(&result).foo();"#, r#"let res = (&result).foo();"#);
         check(r#"let res = &$0dbg!(&result);"#, r#"let res = &&result;"#);
         check(r#"let res = $0dbg!(!result) && true;"#, r#"let res = !result && true;"#);
     }
-
     #[test]
     fn test_remove_dbg_post_expr() {
         check(r#"let res = $0dbg!(fut.await).foo();"#, r#"let res = fut.await.foo();"#);
         check(r#"let res = $0dbg!(array[3]).foo();"#, r#"let res = array[3].foo();"#);
         check(r#"let res = $0dbg!(tuple.3).foo();"#, r#"let res = tuple.3.foo();"#);
     }
-
     #[test]
     fn test_remove_dbg_range_expr() {
         check(r#"let res = $0dbg!(foo..bar).foo();"#, r#"let res = (foo..bar).foo();"#);
         check(r#"let res = $0dbg!(foo..=bar).foo();"#, r#"let res = (foo..=bar).foo();"#);
     }
-
     #[test]
     fn test_remove_empty_dbg() {
         check_assist(remove_dbg, r#"fn foo() { $0dbg!(); }"#, r#"fn foo() { }"#);
 }"#,
         );
     }
-
     #[test]
     fn test_remove_multi_dbg() {
         check(r#"$0dbg!(0, 1)"#, r#"(0, 1)"#);
         check(r#"$0dbg!(0, (1, 2))"#, r#"(0, (1, 2))"#);
     }
-
     #[test]
     fn test_range() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_range_partial() {
         check_assist_not_applicable(remove_dbg, r#"$0dbg$0!(0)"#);
         check_assist_not_applicable(remove_dbg, r#"$0dbg!(0$0)"#);
     }
-
     #[test]
     fn test_nested_dbg() {
         check(
         );
         check(r#"$0dbg!(10, dbg!(), dbg!(20, 30))$0"#, r#"(10, (), (20, 30))"#);
     }
-
     #[test]
     fn test_multiple_nested_dbg() {
         check(