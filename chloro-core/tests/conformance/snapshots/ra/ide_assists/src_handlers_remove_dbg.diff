COMPARISON DIFF
============================================================

Original size: 14570 bytes
Chloro size:   14592 bytes
Rustfmt size:  15283 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
             .collect()
     };
 
-    let replacements = macro_calls
-        .into_iter()
-        .filter_map(compute_dbg_replacement)
-        .collect::<Vec<_>>();
+    let replacements =
+        macro_calls.into_iter().filter_map(compute_dbg_replacement).collect::<Vec<_>>();
     let target = replacements
         .iter()
         .flat_map(|(node_or_token, _)| node_or_token.iter())
         "Remove dbg!()",
         target,
         |builder| {
-            let mut editor = builder.make_editor(ctx.source_file().syntax());
-            for (range, expr) in replacements {
-                if let Some(expr) = expr {
-                    editor.insert(
-                        Position::before(range[0].clone()),
-                        expr.syntax().clone_for_update(),
-                    );
-                }
-                for node_or_token in range {
-                    editor.delete(node_or_token);
-                }
+        let mut editor = builder.make_editor(ctx.source_file().syntax());
+        for (range, expr) in replacements {
+            if let Some(expr) = expr {
+                editor.insert(Position::before(range[0].clone()), expr.syntax().clone_for_update());
             }
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+            for node_or_token in range {
+                editor.delete(node_or_token);
+            }
+        }
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
         return None;
     }
 
-    let mac_input = tt
-        .syntax()
-        .children_with_tokens()
-        .skip(1)
-        .take_while(|it| *it != r_delim);
+    let mac_input = tt.syntax().children_with_tokens().skip(1).take_while(|it| *it != r_delim);
     let input_expressions = mac_input.chunk_by(|tok| tok.kind() == T![,]);
     let input_expressions = input_expressions
         .into_iter()
                 None => false,
             };
             let expr = replace_nested_dbgs(expr.clone());
-            let expr = if wrap {
-                make::expr_paren(expr).into()
-            } else {
-                expr.clone_subtree()
-            };
+            let expr = if wrap { make::expr_paren(expr).into() } else { expr.clone_subtree() };
             (vec![macro_call.syntax().clone().into()], Some(expr))
         }
         // dbg!(expr0, expr1, ...)
     let expanded = expanded.clone_subtree();
     let mut editor = SyntaxEditor::new(expanded.syntax().clone());
     // We need to collect to avoid mutation during traversal.
-    let macro_exprs: Vec<_> = expanded
-        .syntax()
-        .descendants()
-        .filter_map(ast::MacroExpr::cast)
-        .collect();
+    let macro_exprs: Vec<_> =
+        expanded.syntax().descendants().filter_map(ast::MacroExpr::cast).collect();
 
     for mac in macro_exprs {
         let expr_opt = match compute_dbg_replacement(mac.clone()) {
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     fn check(
         #[rust_analyzer::rust_fixture] ra_fixture_before: &str,
         #[rust_analyzer::rust_fixture] ra_fixture_after: &str,
             &format!("fn main() {{\n{ra_fixture_after}\n}}"),
         );
     }
-
     #[test]
     fn test_remove_dbg() {
         check("$0dbg!(1 + 1)", "1 + 1");
         check("dbg![$01 + 1]", "1 + 1");
         check("dbg!{$01 + 1}", "1 + 1");
     }
-
     #[test]
     fn test_remove_simple_dbg_statement() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_remove_trailing_comma_dbg() {
         check("$0dbg!(1 + 1,)", "1 + 1");
         check("$0dbg!(1 + 1, 2 + 3, )", "(1 + 1, 2 + 3)");
         check("$0dbg!(1 + 1, 2 + 3 ,)", "(1 + 1, 2 + 3)");
     }
-
     #[test]
     fn test_remove_dbg_not_applicable() {
         check_assist_not_applicable(remove_dbg, "fn main() {$0vec![1, 2, 3]}");
         check_assist_not_applicable(remove_dbg, "fn main() {$0dbg(5, 6, 7)}");
         check_assist_not_applicable(remove_dbg, "fn main() {$0dbg!(5, 6, 7}");
     }
-
     #[test]
     fn test_remove_dbg_keep_semicolon_in_let() {
         // https://github.com/rust-lang/rust-analyzer/issues/5129#issuecomment-651399779
             r#"let res = $0dbg!(1 * 20); // needless comment"#,
             r#"let res = 1 * 20; // needless comment"#,
         );
-        check(
-            r#"let res = $0dbg!(); // needless comment"#,
-            r#"let res = (); // needless comment"#,
-        );
+        check(r#"let res = $0dbg!(); // needless comment"#, r#"let res = (); // needless comment"#);
         check(
             r#"let res = $0dbg!(1, 2); // needless comment"#,
             r#"let res = (1, 2); // needless comment"#,
         );
     }
-
     #[test]
     fn test_remove_dbg_cast_cast() {
-        check(
-            r#"let res = $0dbg!(x as u32) as u32;"#,
-            r#"let res = x as u32 as u32;"#,
-        );
+        check(r#"let res = $0dbg!(x as u32) as u32;"#, r#"let res = x as u32 as u32;"#);
     }
-
     #[test]
     fn test_remove_dbg_prefix() {
-        check(
-            r#"let res = $0dbg!(&result).foo();"#,
-            r#"let res = (&result).foo();"#,
-        );
+        check(r#"let res = $0dbg!(&result).foo();"#, r#"let res = (&result).foo();"#);
         check(r#"let res = &$0dbg!(&result);"#, r#"let res = &&result;"#);
-        check(
-            r#"let res = $0dbg!(!result) && true;"#,
-            r#"let res = !result && true;"#,
-        );
+        check(r#"let res = $0dbg!(!result) && true;"#, r#"let res = !result && true;"#);
     }
-
     #[test]
     fn test_remove_dbg_post_expr() {
-        check(
-            r#"let res = $0dbg!(fut.await).foo();"#,
-            r#"let res = fut.await.foo();"#,
-        );
-        check(
-            r#"let res = $0dbg!(result?).foo();"#,
-            r#"let res = result?.foo();"#,
-        );
-        check(
-            r#"let res = $0dbg!(foo as u32).foo();"#,
-            r#"let res = (foo as u32).foo();"#,
-        );
-        check(
-            r#"let res = $0dbg!(array[3]).foo();"#,
-            r#"let res = array[3].foo();"#,
-        );
-        check(
-            r#"let res = $0dbg!(tuple.3).foo();"#,
-            r#"let res = tuple.3.foo();"#,
-        );
+        check(r#"let res = $0dbg!(fut.await).foo();"#, r#"let res = fut.await.foo();"#);
+        check(r#"let res = $0dbg!(result?).foo();"#, r#"let res = result?.foo();"#);
+        check(r#"let res = $0dbg!(foo as u32).foo();"#, r#"let res = (foo as u32).foo();"#);
+        check(r#"let res = $0dbg!(array[3]).foo();"#, r#"let res = array[3].foo();"#);
+        check(r#"let res = $0dbg!(tuple.3).foo();"#, r#"let res = tuple.3.foo();"#);
     }
-
     #[test]
     fn test_remove_dbg_range_expr() {
-        check(
-            r#"let res = $0dbg!(foo..bar).foo();"#,
-            r#"let res = (foo..bar).foo();"#,
-        );
-        check(
-            r#"let res = $0dbg!(foo..=bar).foo();"#,
-            r#"let res = (foo..=bar).foo();"#,
-        );
+        check(r#"let res = $0dbg!(foo..bar).foo();"#, r#"let res = (foo..bar).foo();"#);
+        check(r#"let res = $0dbg!(foo..=bar).foo();"#, r#"let res = (foo..=bar).foo();"#);
     }
-
     #[test]
     fn test_remove_empty_dbg() {
         check_assist(remove_dbg, r#"fn foo() { $0dbg!(); }"#, r#"fn foo() { }"#);
 }"#,
         );
     }
-
     #[test]
     fn test_remove_multi_dbg() {
         check(r#"$0dbg!(0, 1)"#, r#"(0, 1)"#);
         check(r#"$0dbg!(0, (1, 2))"#, r#"(0, (1, 2))"#);
     }
-
     #[test]
     fn test_range() {
         check(
 "#,
         );
     }
-
     #[test]
     fn test_range_partial() {
         check_assist_not_applicable(remove_dbg, r#"$0dbg$0!(0)"#);
         check_assist_not_applicable(remove_dbg, r#"$0dbg!(0$0)"#);
     }
-
     #[test]
     fn test_nested_dbg() {
         check(
             r#"$0let x = dbg!(dbg!(dbg!(dbg!(0 + 1)) * 2) + dbg!(3));$0"#,
             r#"let x = ((0 + 1) * 2) + 3;"#,
         );
-        check(
-            r#"$0dbg!(10, dbg!(), dbg!(20, 30))$0"#,
-            r#"(10, (), (20, 30))"#,
-        );
+        check(r#"$0dbg!(10, dbg!(), dbg!(20, 30))$0"#, r#"(10, (), (20, 30))"#);
     }
-
     #[test]
     fn test_multiple_nested_dbg() {
         check(