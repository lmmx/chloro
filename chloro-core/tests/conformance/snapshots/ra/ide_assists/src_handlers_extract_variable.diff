COMPARISON DIFF
============================================================

Original size: 52351 bytes
Chloro size:   52238 bytes
Rustfmt size:  52647 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::{
     NodeOrToken, SyntaxKind, SyntaxNode, T,
     algo::ancestors_at_offset,
-    ast::{
-        self, AstNode,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
-        syntax_factory::SyntaxFactory,
-    },
+    ast::{self, AstNode, edit::{AstNodeEdit, IndentLevel}, make, syntax_factory::SyntaxFactory},
     syntax_editor::Position,
 };
 
             .next()
             .and_then(ast::Expr::cast)
         {
-            expr.syntax()
-                .ancestors()
-                .find_map(valid_target_expr)?
-                .syntax()
-                .clone()
+            expr.syntax().ancestors().find_map(valid_target_expr)?.syntax().clone()
         } else {
             return None;
         }
         }
     };
 
-    let node = node
-        .ancestors()
-        .take_while(|anc| anc.text_range() == node.text_range())
-        .last()?;
+    let node = node.ancestors().take_while(|anc| anc.text_range() == node.text_range()).last()?;
     let range = node.text_range();
 
     let to_extract = node
                 let new_stmt: ast::Stmt = match kind {
                     ExtractionKind::Variable => {
                         let ident_pat = make.ident_pat(false, needs_mut, pat_name);
-                        make.let_stmt(ident_pat.into(), None, Some(initializer))
-                            .into()
+                        make.let_stmt(ident_pat.into(), None, Some(initializer)).into()
                     }
                     ExtractionKind::Constant => {
                         let ast_ty = make.ty(&ty_string);
 
 fn peel_parens(mut expr: ast::Expr) -> ast::Expr {
     while let ast::Expr::ParenExpr(parens) = &expr {
-        let Some(expr_inside) = parens.expr() else {
-            break;
-        };
+        let Some(expr_inside) = parens.expr() else { break };
         expr = expr_inside;
     }
     expr
         SyntaxKind::PATH_EXPR | SyntaxKind::LOOP_EXPR | SyntaxKind::LET_EXPR => None,
         SyntaxKind::BREAK_EXPR => ast::BreakExpr::cast(node).and_then(|e| e.expr()),
         SyntaxKind::RETURN_EXPR => ast::ReturnExpr::cast(node).and_then(|e| e.expr()),
-        SyntaxKind::BLOCK_EXPR => ast::BlockExpr::cast(node)
-            .filter(|it| it.is_standalone())
-            .map(ast::Expr::from),
+        SyntaxKind::BLOCK_EXPR => {
+            ast::BlockExpr::cast(node).filter(|it| it.is_standalone()).map(ast::Expr::from)
+        }
         _ => ast::Expr::cast(node),
     }
 }
 }
 
 impl ExtractionKind {
-    const ALL: &'static [ExtractionKind] = &[
-        ExtractionKind::Variable,
-        ExtractionKind::Constant,
-        ExtractionKind::Static,
-    ];
+    const ALL: &'static [ExtractionKind] = &[ExtractionKind::Variable, ExtractionKind::Constant, ExtractionKind::Static];
 
     fn assist_id(&self) -> AssistId {
         let s = match self {
                 if ast::MacroCall::can_cast(node.kind()) {
                     return None;
                 }
-                if let Some(expr) = node
-                    .parent()
-                    .and_then(ast::StmtList::cast)
-                    .and_then(|it| it.tail_expr())
+                if let Some(expr) =
+                    node.parent().and_then(ast::StmtList::cast).and_then(|it| it.tail_expr())
                     && expr.syntax() == &node
                 {
                     cov_mark::hit!(test_extract_var_last_expr);
         check_assist_by_label, check_assist_not_applicable, check_assist_not_applicable_by_label,
         check_assist_target,
     };
-
     use super::*;
-
     #[test]
     fn extract_var_simple_without_select() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_const_simple_without_select() {
         check_assist_by_label(
             "Extract into constant",
         );
     }
-
     #[test]
     fn extract_static_simple_without_select() {
         check_assist_by_label(
             "Extract into static",
         );
     }
-
     #[test]
     fn dont_extract_unit_expr_without_select() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn extract_var_simple() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_const_simple() {
         check_assist_by_label(
             "Extract into constant",
         );
     }
-
     #[test]
     fn extract_static_simple() {
         check_assist_by_label(
             "Extract into static",
         );
     }
-
     #[test]
     fn dont_extract_in_comment() {
         cov_mark::check!(extract_var_in_comment_is_not_applicable);
-        check_assist_not_applicable(
-            extract_variable,
-            r#"fn main() { 1 + /* $0comment$0 */ 1; }"#,
-        );
+        check_assist_not_applicable(extract_variable, r#"fn main() { 1 + /* $0comment$0 */ 1; }"#);
     }
-
     #[test]
     fn extract_var_expr_stmt() {
         cov_mark::check!(test_extract_var_expr_stmt);
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_const_expr_stmt() {
         cov_mark::check!(test_extract_var_expr_stmt);
             "Extract into constant",
         );
     }
-
     #[test]
     fn extract_static_expr_stmt() {
         cov_mark::check!(test_extract_var_expr_stmt);
             "Extract into static",
         );
     }
-
     #[test]
     fn extract_var_part_of_expr_stmt() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_const_part_of_expr_stmt() {
         check_assist_by_label(
             "Extract into constant",
         );
     }
-
     #[test]
     fn extract_static_part_of_expr_stmt() {
         check_assist_by_label(
             "Extract into static",
         );
     }
-
     #[test]
     fn extract_var_last_expr() {
         cov_mark::check!(test_extract_var_last_expr);
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_const_last_expr() {
         cov_mark::check!(test_extract_var_last_expr);
             "Extract into constant",
         )
     }
-
     #[test]
     fn extract_static_last_expr() {
         cov_mark::check!(test_extract_var_last_expr);
             "Extract into static",
         )
     }
-
     #[test]
     fn extract_var_in_match_arm_no_block() {
         cov_mark::check!(test_extract_var_in_match_arm_no_block);
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_in_match_arm_with_block() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_in_match_guard() {
         cov_mark::check!(test_extract_var_in_match_guard);
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_in_closure_no_block() {
         cov_mark::check!(test_extract_var_in_closure_no_block);
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_in_closure_with_block() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_path_simple() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_path_method() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_return() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_does_not_add_extra_whitespace() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_break() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_let_expr() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_for_cast() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_field_shorthand() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_var_name_from_type() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_var_name_from_parameter() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_var_parameter_name_has_precedence_over_type() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_var_name_from_function() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_var_name_from_method() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_var_name_from_method_param() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_var_name_from_ufcs_method_param() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_var_parameter_name_has_precedence_over_function() {
         check_assist_by_label(
             "Extract into variable",
         )
     }
-
     #[test]
     fn extract_macro_call() {
         check_assist_by_label(
             "Extract into static",
         );
     }
-
     #[test]
     fn extract_var_for_return_not_applicable() {
         check_assist_not_applicable(extract_variable, "fn foo() { $0return$0; } ");
     }
-
     #[test]
     fn extract_var_for_break_not_applicable() {
         check_assist_not_applicable(extract_variable, "fn main() { loop { $0break$0; }; }");
     }
-
     #[test]
     fn extract_var_for_let_expr_not_applicable() {
         check_assist_not_applicable(
             "fn main() { if $0let Some(x) = Some(2+2) {} }",
         );
     }
-
     #[test]
     fn extract_var_unit_expr_not_applicable() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     // FIXME: This is not quite correct, but good enough(tm) for the sorting heuristic
     #[test]
     fn extract_var_target() {
-        check_assist_target(
-            extract_variable,
-            r#"fn foo() -> u32 { $0return 2 + 2$0; }"#,
-            "2 + 2",
-        );
+        check_assist_target(extract_variable, r#"fn foo() -> u32 { $0return 2 + 2$0; }"#, "2 + 2");
 
         check_assist_target(
             extract_variable,
             "2 + 2",
         );
     }
-
     #[test]
     fn extract_var_no_block_body() {
         check_assist_not_applicable_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_const_no_block_body() {
         check_assist_by_label(
             "Extract into constant",
         );
     }
-
     #[test]
     fn extract_static_no_block_body() {
         check_assist_by_label(
             "Extract into static",
         );
     }
-
     #[test]
     fn extract_var_mutable_reference_parameter() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn dont_extract_const_mutable_reference_parameter() {
         check_assist_not_applicable_by_label(
             "Extract into constant",
         );
     }
-
     #[test]
     fn dont_extract_static_mutable_reference_parameter() {
         check_assist_not_applicable_by_label(
             "Extract into static",
         );
     }
-
     #[test]
     fn extract_var_mutable_reference_parameter_deep_nesting() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_reference_parameter() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_index_deref() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_reference_parameter_deep_nesting() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_regular_parameter() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_mutable_reference_local() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_reference_local() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_var_for_mutable_borrow() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn dont_extract_const_for_mutable_borrow() {
         check_assist_not_applicable_by_label(
             "Extract into constant",
         );
     }
-
     #[test]
     fn dont_extract_static_for_mutable_borrow() {
         check_assist_not_applicable_by_label(
             "Extract into static",
         );
     }
-
     #[test]
     fn generates_no_ref_on_calls() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn generates_no_ref_for_deref() {
         check_assist_by_label(
             "Extract into variable",
         );
     }
-
     #[test]
     fn extract_string_literal() {
         check_assist_by_label(
             "Extract into static",
         );
     }
-
     #[test]
     fn extract_variable_string_literal_use_field_shorthand() {
         // When field shorthand is available, it should
             "Extract into static",
         );
     }
-
     #[test]
     fn extract_variable_name_conflicts() {
         check_assist_by_label(