COMPARISON DIFF
============================================================

Original size: 11085 bytes
Chloro size:   11156 bytes
Rustfmt size:  11546 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::FxHashSet;
 use syntax::{
-    ast::{self, edit_in_place::GenericParamsOwnerEdit, make, HasGenericParams},
-    ted::{self, Position},
     AstNode, TextRange,
+    ast::{self, HasGenericParams, edit_in_place::GenericParamsOwnerEdit, make},
+    ted::{self, Position},
 };
 
-use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, Assists};
+use crate::{AssistContext, AssistId, Assists, assist_context::SourceChangeBuilder};
 
 static ASSIST_NAME: &str = "introduce_named_lifetime";
+
 static ASSIST_LABEL: &str = "Introduce named lifetime";
 
 // Assist: introduce_named_lifetime
 pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // FIXME: How can we handle renaming any one of multiple anonymous lifetimes?
     // FIXME: should also add support for the case fun(f: &Foo) -> &$0Foo
-    let lifetime = ctx
-        .find_node_at_offset::<ast::Lifetime>()
-        .filter(|lifetime| lifetime.text() == "'_")?;
+    let lifetime =
+        ctx.find_node_at_offset::<ast::Lifetime>().filter(|lifetime| lifetime.text() == "'_")?;
     let lifetime_loc = lifetime.lifetime_ident_token()?.text_range();
 
     if let Some(fn_def) = lifetime.syntax().ancestors().find_map(ast::Fn::cast) {
         ASSIST_LABEL,
         lifetime_loc,
         |builder| {
-            let fn_def = builder.make_mut(fn_def);
-            let lifetime = builder.make_mut(lifetime);
-            let loc_needing_lifetime =
-                loc_needing_lifetime.and_then(|it| it.make_mut(builder).to_position());
+        let fn_def = builder.make_mut(fn_def);
+        let lifetime = builder.make_mut(lifetime);
+        let loc_needing_lifetime =
+            loc_needing_lifetime.and_then(|it| it.make_mut(builder).to_position());
 
-            fn_def.get_or_create_generic_param_list().add_generic_param(
-                make::lifetime_param(new_lifetime_param.clone())
-                    .clone_for_update()
-                    .into(),
-            );
-            ted::replace(
-                lifetime.syntax(),
-                new_lifetime_param.clone_for_update().syntax(),
-            );
-            if let Some(position) = loc_needing_lifetime {
-                ted::insert(position, new_lifetime_param.clone_for_update().syntax());
-            }
-        },
+        fn_def.get_or_create_generic_param_list().add_generic_param(
+            make::lifetime_param(new_lifetime_param.clone()).clone_for_update().into(),
+        );
+        ted::replace(lifetime.syntax(), new_lifetime_param.clone_for_update().syntax());
+        if let Some(position) = loc_needing_lifetime {
+            ted::insert(position, new_lifetime_param.clone_for_update().syntax());
+        }
+    },
     )
 }
 
         ASSIST_LABEL,
         lifetime_loc,
         |builder| {
-            let impl_def = builder.make_mut(impl_def);
-            let lifetime = builder.make_mut(lifetime);
+        let impl_def = builder.make_mut(impl_def);
+        let lifetime = builder.make_mut(lifetime);
 
-            impl_def
-                .get_or_create_generic_param_list()
-                .add_generic_param(
-                    make::lifetime_param(new_lifetime_param.clone())
-                        .clone_for_update()
-                        .into(),
-                );
-            ted::replace(
-                lifetime.syntax(),
-                new_lifetime_param.clone_for_update().syntax(),
-            );
-        },
+        impl_def.get_or_create_generic_param_list().add_generic_param(
+            make::lifetime_param(new_lifetime_param.clone()).clone_for_update().into(),
+        );
+        ted::replace(lifetime.syntax(), new_lifetime_param.clone_for_update().syntax());
+    },
     )
 }
 
 ) -> Option<ast::Lifetime> {
     match existing_type_param_list {
         Some(type_params) => {
-            let used_lifetime_params: FxHashSet<_> = type_params
-                .lifetime_params()
-                .map(|p| p.syntax().text().to_string())
-                .collect();
-            ('a'..='z')
-                .map(|it| format!("'{it}"))
-                .find(|it| !used_lifetime_params.contains(it))
+            let used_lifetime_params: FxHashSet<_> =
+                type_params.lifetime_params().map(|p| p.syntax().text().to_string()).collect();
+            ('a'..='z').map(|it| format!("'{it}")).find(|it| !used_lifetime_params.contains(it))
         }
         None => Some("'a".to_owned()),
-    }
-    .map(|it| make::lifetime(&it))
+    }.map(
+        |it| make::lifetime(&it),
+    )
 }
 
 enum NeedsLifetime {
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn test_example_case() {
         check_assist(
             }"#,
         );
     }
-
     #[test]
     fn test_example_case_simplified() {
         check_assist(
             r#"impl<'a> Cursor<'a> {"#,
         );
     }
-
     #[test]
     fn test_example_case_cursor_after_tick() {
         check_assist(
             r#"impl<'a> Cursor<'a> {"#,
         );
     }
-
     #[test]
     fn test_impl_with_other_type_param() {
         check_assist(
         {",
         )
     }
-
     #[test]
     fn test_example_case_cursor_before_tick() {
         check_assist(
             r#"impl<'a> Cursor<'a> {"#,
         );
     }
-
     #[test]
     fn test_not_applicable_cursor_position() {
         check_assist_not_applicable(introduce_named_lifetime, r#"impl Cursor<'_>$0 {"#);
         check_assist_not_applicable(introduce_named_lifetime, r#"impl Cursor$0<'_> {"#);
     }
-
     #[test]
     fn test_not_applicable_lifetime_already_name() {
         check_assist_not_applicable(introduce_named_lifetime, r#"impl Cursor<'a$0> {"#);
         check_assist_not_applicable(introduce_named_lifetime, r#"fn my_fun<'a>() -> X<'a$0>"#);
     }
-
     #[test]
     fn test_with_type_parameter() {
         check_assist(
             r#"impl<T, 'a> Cursor<T, 'a>"#,
         );
     }
-
     #[test]
     fn test_with_existing_lifetime_name_conflict() {
         check_assist(
             r#"impl<'a, 'b, 'c> Cursor<'a, 'b, 'c>"#,
         );
     }
-
     #[test]
     fn test_function_return_value_anon_lifetime_param() {
         check_assist(
             r#"fn my_fun<'a>() -> X<'a>"#,
         );
     }
-
     #[test]
     fn test_function_return_value_anon_reference_lifetime() {
         check_assist(
             r#"fn my_fun<'a>() -> &'a X"#,
         );
     }
-
     #[test]
     fn test_function_param_anon_lifetime() {
         check_assist(
             r#"fn my_fun<'a>(x: X<'a>)"#,
         );
     }
-
     #[test]
     fn test_function_add_lifetime_to_params() {
         check_assist(
             r#"fn my_fun<'a>(f: &'a Foo) -> X<'a>"#,
         );
     }
-
     #[test]
     fn test_function_add_lifetime_to_params_in_presence_of_other_lifetime() {
         check_assist(
             r#"fn my_fun<'other, 'a>(f: &'a Foo, b: &'other Bar) -> X<'a>"#,
         );
     }
-
     #[test]
     fn test_function_not_applicable_without_self_and_multiple_unnamed_param_lifetimes() {
         // this is not permitted under lifetime elision rules
             r#"fn my_fun(f: &Foo, b: &Bar) -> X<'_$0>"#,
         );
     }
-
     #[test]
     fn test_function_add_lifetime_to_self_ref_param() {
         check_assist(
             r#"fn my_fun<'other, 'a>(&'a self, f: &Foo, b: &'other Bar) -> X<'a>"#,
         );
     }
-
     #[test]
     fn test_function_add_lifetime_to_param_with_non_ref_self() {
         check_assist(
             r#"fn my_fun<'other, 'a>(self, f: &'a Foo, b: &'other Bar) -> X<'a>"#,
         );
     }
-
     #[test]
     fn test_function_add_lifetime_to_self_ref_mut() {
         check_assist(