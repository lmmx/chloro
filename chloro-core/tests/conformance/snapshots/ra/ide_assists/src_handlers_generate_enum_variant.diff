COMPARISON DIFF
============================================================

Original size: 10157 bytes
Chloro size:   9827 bytes
Rustfmt size:  10267 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{HasSource, HirDisplay, InRealFile};
 use ide_db::assists::AssistId;
 use syntax::{
-    ast::{self, syntax_factory::SyntaxFactory, HasArgList},
-    match_ast, AstNode, SyntaxNode,
+    AstNode, SyntaxNode,
+    ast::{self, HasArgList, syntax_factory::SyntaxFactory},
+    match_ast,
 };
 
 use crate::assist_context::{AssistContext, Assists};
 
-// Assist: generate_enum_variant
-//
-// Adds a variant to an enum.
-//
-// ```
-// enum Countries {
-//     Ghana,
-// }
-//
-// fn main() {
-//     let country = Countries::Lesotho$0;
-// }
-// ```
-// ->
-// ```
-// enum Countries {
-//     Ghana,
-//     Lesotho,
-// }
-//
-// fn main() {
-//     let country = Countries::Lesotho;
-// }
-// ```
-pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn generate_enum_variant(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let path: ast::Path = ctx.find_node_at_offset()?;
     let parent = PathParent::new(&path)?;
-
     if ctx.sema.resolve_path(&path).is_some() {
         // No need to generate anything if the path resolves
         return None;
     }
-
     let name_ref = path.segment()?.name_ref()?;
     if name_ref.text().starts_with(char::is_lowercase) {
         // Don't suggest generating variant if the name starts with a lowercase letter
         return None;
     }
-
     let Some(hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e)))) =
         ctx.sema.resolve_path(&path.qualifier()?)
     else {
         return None;
     };
-
     let target = path.syntax().text_range();
     let name_ref: &ast::NameRef = &name_ref;
     let db = ctx.db();
-    let InRealFile {
-        file_id,
-        value: enum_node,
-    } = e.source(db)?.original_ast_node_rooted(db)?;
-
-    acc.add(
-        AssistId::generate("generate_enum_variant"),
-        "Generate variant",
-        target,
-        |builder| {
-            let mut editor = builder.make_editor(enum_node.syntax());
-            let make = SyntaxFactory::with_mappings();
-            let field_list = parent.make_field_list(ctx, &make);
-            let variant = make.variant(None, make.name(&name_ref.text()), field_list, None);
-            if let Some(it) = enum_node.variant_list() {
-                it.add_variant(&mut editor, &variant);
-            }
-            builder.add_file_edits(file_id.file_id(ctx.db()), editor);
-        },
-    )
+    let InRealFile { file_id, value: enum_node } = e.source(db)?.original_ast_node_rooted(db)?;
+    acc.add(AssistId::generate("generate_enum_variant"), "Generate variant", target, |builder| {
+        let mut editor = builder.make_editor(enum_node.syntax());
+        let make = SyntaxFactory::with_mappings();
+        let field_list = parent.make_field_list(ctx, &make);
+        let variant = make.variant(None, make.name(&name_ref.text()), field_list, None);
+        if let Some(it) = enum_node.variant_list() {
+            it.add_variant(&mut editor, &variant);
+        }
+        builder.add_file_edits(file_id.file_id(ctx.db()), editor);
+    })
 }
 
 #[derive(Debug)]
 impl PathParent {
     fn new(path: &ast::Path) -> Option<Self> {
         let parent = path.syntax().parent()?;
-
         match_ast! {
             match parent {
                 ast::PathExpr(it) => Some(PathParent::PathExpr(it)),
         make: &SyntaxFactory,
     ) -> Option<ast::FieldList> {
         let scope = ctx.sema.scope(self.syntax())?;
-
         match self {
             PathParent::PathExpr(it) => {
                 let call_expr = ast::CallExpr::cast(it.syntax().parent()?)?;
     }
 }
 
-fn name_from_field(make: &SyntaxFactory, field: &ast::RecordExprField) -> ast::Name {
+fn name_from_field(
+    make: &SyntaxFactory,
+    field: &ast::RecordExprField,
+) -> ast::Name {
     let text = match field.name_ref() {
         Some(it) => it.to_string(),
         None => name_from_field_shorthand(field).unwrap_or("unknown".to_owned()),
     scope: &hir::SemanticsScope<'_>,
 ) -> Option<ast::Type> {
     let ty = ctx.sema.type_of_expr(&arg).map(|it| it.adjusted())?;
-    let text = ty
-        .display_source_code(ctx.db(), scope.module().into(), false)
-        .ok()?;
+    let text = ty.display_source_code(ctx.db(), scope.module().into(), false).ok()?;
     Some(make.ty(&text))
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn generate_basic_enum_variant_in_empty_enum() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generate_basic_enum_variant_in_non_empty_enum() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generate_basic_enum_variant_in_different_file() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn not_applicable_for_existing_variant() {
         check_assist_not_applicable(
 ",
         )
     }
-
     #[test]
     fn not_applicable_for_lowercase() {
         check_assist_not_applicable(
 ",
         )
     }
-
     #[test]
     fn indentation_level_is_correct() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn associated_single_element_tuple() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn associated_single_element_tuple_unknown_type() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn associated_multi_element_tuple() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn associated_record() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn associated_record_unknown_type() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn associated_record_field_shorthand() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn associated_record_field_shorthand_unknown_type() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn associated_record_field_multiple_fields() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn use_tree() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn not_applicable_for_path_type() {
         check_assist_not_applicable(
 ",
         )
     }
-
     #[test]
     fn path_pat() {
         check_assist(