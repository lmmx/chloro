COMPARISON DIFF
============================================================

Original size: 11413 bytes
Chloro size:   10390 bytes
Rustfmt size:  11741 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::{famous_defs::FamousDefs, traits::resolve_target_trait};
 use syntax::{
+    AstNode, T,
     ast::{self, edit_in_place::Indent, make},
-    ted, AstNode, T,
+    ted,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// FIXME: Generate proper `index_mut` method body refer to `index` method body may impossible due to the unpredictable case [#15581].
-// Here just leave the `index_mut` method body be same as `index` method body, user can modify it manually to meet their need.
-
-// Assist: generate_mut_trait_impl
-//
-// Adds a IndexMut impl from the `Index` trait.
-//
-// ```
-// # //- minicore: index
-// pub enum Axis { X = 0, Y = 1, Z = 2 }
-//
-// impl<T> core::ops::Index$0<Axis> for [T; 3] {
-//     type Output = T;
-//
-//     fn index(&self, index: Axis) -> &Self::Output {
-//         &self[index as usize]
-//     }
-// }
-// ```
-// ->
-// ```
-// pub enum Axis { X = 0, Y = 1, Z = 2 }
-//
-// $0impl<T> core::ops::IndexMut<Axis> for [T; 3] {
-//     fn index_mut(&mut self, index: Axis) -> &mut Self::Output {
-//         &mut self[index as usize]
-//     }
-// }
-//
-// impl<T> core::ops::Index<Axis> for [T; 3] {
-//     type Output = T;
-//
-//     fn index(&self, index: Axis) -> &Self::Output {
-//         &self[index as usize]
-//     }
-// }
-// ```
-pub(crate) fn generate_mut_trait_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn generate_mut_trait_impl(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let impl_def = ctx.find_node_at_offset::<ast::Impl>()?.clone_for_update();
     let indent = impl_def.indent_level();
-
     let ast::Type::PathType(path) = impl_def.trait_()? else {
         return None;
     };
     let trait_name = path.path()?.segment()?.name_ref()?;
-
     let scope = ctx.sema.scope(impl_def.trait_()?.syntax())?;
     let famous = FamousDefs(&ctx.sema, scope.krate());
-
     let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;
     let trait_new = get_trait_mut(&trait_, famous)?;
-
     // Index -> IndexMut
-    ted::replace(
-        trait_name.syntax(),
-        make::name_ref(trait_new).clone_for_update().syntax(),
-    );
-
+    ted::replace(trait_name.syntax(), make::name_ref(trait_new).clone_for_update().syntax());
     // index -> index_mut
     let (trait_method_name, new_trait_method_name) = impl_def
         .syntax()
         .find_map(process_method_name)?;
     ted::replace(
         trait_method_name.syntax(),
-        make::name(new_trait_method_name)
-            .clone_for_update()
-            .syntax(),
+        make::name(new_trait_method_name).clone_for_update().syntax(),
     );
-
-    if let Some(type_alias) = impl_def
-        .syntax()
-        .descendants()
-        .find_map(ast::TypeAlias::cast)
-    {
+    if let Some(type_alias) = impl_def.syntax().descendants().find_map(ast::TypeAlias::cast) {
         ted::remove(type_alias.syntax());
     }
-
     // &self -> &mut self
     let mut_self_param = make::mut_self_param();
-    let self_param: ast::SelfParam = impl_def
-        .syntax()
-        .descendants()
-        .find_map(ast::SelfParam::cast)?;
-    ted::replace(
-        self_param.syntax(),
-        mut_self_param.clone_for_update().syntax(),
-    );
-
+    let self_param: ast::SelfParam =
+        impl_def.syntax().descendants().find_map(ast::SelfParam::cast)?;
+    ted::replace(self_param.syntax(), mut_self_param.clone_for_update().syntax());
     // &Self::Output -> &mut Self::Output
-    let ret_type = impl_def
-        .syntax()
-        .descendants()
-        .find_map(ast::RetType::cast)?;
+    let ret_type = impl_def.syntax().descendants().find_map(ast::RetType::cast)?;
     let new_ret_type = process_ret_type(&ret_type)?;
-    ted::replace(
-        ret_type.syntax(),
-        make::ret_type(new_ret_type).clone_for_update().syntax(),
-    );
-
-    let fn_ = impl_def
-        .assoc_item_list()?
-        .assoc_items()
-        .find_map(|it| match it {
-            ast::AssocItem::Fn(f) => Some(f),
-            _ => None,
-        })?;
+    ted::replace(ret_type.syntax(), make::ret_type(new_ret_type).clone_for_update().syntax());
+    let fn_ = impl_def.assoc_item_list()?.assoc_items().find_map(|it| match it {
+        ast::AssocItem::Fn(f) => Some(f),
+        _ => None,
+    })?;
     let _ = process_ref_mut(&fn_);
-
     let assoc_list = make::assoc_item_list(None).clone_for_update();
     ted::replace(impl_def.assoc_item_list()?.syntax(), assoc_list.syntax());
-    impl_def
-        .get_or_create_assoc_item_list()
-        .add_item(syntax::ast::AssocItem::Fn(fn_));
-
+    impl_def.get_or_create_assoc_item_list().add_item(syntax::ast::AssocItem::Fn(fn_));
     let target = impl_def.syntax().text_range();
     acc.add(
         AssistId::generate("generate_mut_trait_impl"),
         ast::Expr::RefExpr(ref_expr) if ref_expr.mut_token().is_none() => {
             ted::insert_all_raw(
                 ted::Position::after(ref_expr.amp_token()?),
-                vec![
-                    make::token(T![mut]).into(),
-                    make::tokens::whitespace(" ").into(),
-                ],
+                vec![make::token(T![mut]).into(), make::tokens::whitespace(" ").into()],
             );
         }
         _ => {}
     None
 }
 
-fn get_trait_mut(apply_trait: &hir::Trait, famous: FamousDefs<'_, '_>) -> Option<&'static str> {
+fn get_trait_mut(
+    apply_trait: &hir::Trait,
+    famous: FamousDefs<'_, '_>,
+) -> Option<&'static str> {
     let trait_ = Some(apply_trait);
     if trait_ == famous.core_convert_Index().as_ref() {
         return Some("IndexMut");
 #[cfg(test)]
 mod tests {
     use crate::{
-        tests::{check_assist, check_assist_not_applicable, check_assist_with_config, TEST_CONFIG},
+        check_assist, check_assist_not_applicable, check_assist_with_config}, tests::{TEST_CONFIG,
         AssistConfig,
     };
-
     use super::*;
-
     #[test]
     fn test_generate_mut_trait_impl() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             generate_mut_trait_impl,
             r#"
 }
 "#,
         );
-
         check_assist(
             generate_mut_trait_impl,
             r#"
 }
 "#,
         );
-
         check_assist(
             generate_mut_trait_impl,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_generate_mut_trait_impl_non_zero_indent() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             generate_mut_trait_impl,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_generate_mut_trait_impl_not_applicable() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn no_snippets() {
         check_assist_with_config(
             generate_mut_trait_impl,
-            AssistConfig {
-                snippet_cap: None,
-                ..TEST_CONFIG
-            },
+            AssistConfig { snippet_cap: None, ..TEST_CONFIG },
             r#"
 //- minicore: index
 pub enum Axis { X = 0, Y = 1, Z = 2 }