COMPARISON DIFF
============================================================

Original size: 7893 bytes
Chloro size:   7883 bytes
Rustfmt size:  8000 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 // ```
 pub(crate) fn unqualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let call = ctx.find_node_at_offset::<ast::CallExpr>()?;
-    let ast::Expr::PathExpr(path_expr) = call.expr()? else {
-        return None;
-    };
+    let ast::Expr::PathExpr(path_expr) = call.expr()? else { return None };
     let path = path_expr.path()?;
 
-    let cursor_in_range = path
-        .syntax()
-        .text_range()
-        .contains_range(ctx.selection_trimmed());
+    let cursor_in_range = path.syntax().text_range().contains_range(ctx.selection_trimmed());
     if !cursor_in_range {
         return None;
     }
 
     let scope = ctx.sema.scope(path.syntax())?;
     let res = ctx.sema.resolve_path(&path)?;
-    let hir::PathResolution::Def(hir::ModuleDef::Function(fun)) = res else {
-        return None;
-    };
+    let hir::PathResolution::Def(hir::ModuleDef::Function(fun)) = res else { return None };
     if !fun.has_self_param(ctx.sema.db) {
         return None;
     }
 
     // `core::ops::Add::add(` -> ``
-    let delete_path = TextRange::new(
-        path.syntax().text_range().start(),
-        l_paren.text_range().end(),
-    );
+    let delete_path =
+        TextRange::new(path.syntax().text_range().start(), l_paren.text_range().end());
 
     // Parens around `expr` if needed
-    let parens = first_arg
-        .precedence()
-        .needs_parentheses_in(ExprPrecedence::Postfix)
-        .then(|| {
-            let range = first_arg.syntax().text_range();
-            (range.start(), range.end())
-        });
+    let parens = first_arg.precedence().needs_parentheses_in(ExprPrecedence::Postfix).then(|| {
+        let range = first_arg.syntax().text_range();
+        (range.start(), range.end())
+    });
 
     // `, ` -> `.add(`
     let replace_comma = TextRange::new(
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn unqualify_method_call_simple() {
         check_assist(
 fn f() { S.f(S); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_trait() {
         check_assist(
 fn f() { 2.add(2); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_single_arg() {
         check_assist(
         fn f() { S.f(); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_parens() {
         check_assist(
 fn f() { (&S).deref(); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_doesnt_apply_with_cursor_not_on_path() {
         check_assist_not_applicable(
 fn f() { core::ops::Add::add(2,$0 2); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_doesnt_apply_with_no_self() {
         check_assist_not_applicable(
 fn f() { S::assoc$0(S, S); }"#,
         );
     }
-
     #[test]
     fn inherent_method() {
         check_assist(
         "#,
         );
     }
-
     #[test]
     fn trait_method_in_impl() {
         check_assist(
         "#,
         );
     }
-
     #[test]
     fn trait_method_already_imported() {
         check_assist(