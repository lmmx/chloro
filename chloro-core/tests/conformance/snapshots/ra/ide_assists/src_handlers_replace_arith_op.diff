COMPARISON DIFF
============================================================

Original size: 6386 bytes
Chloro size:   5654 bytes
Rustfmt size:  6494 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::assists::{AssistId, GroupLabel};
 use syntax::{
-    ast::{self, syntax_factory::SyntaxFactory, ArithOp, BinaryOp},
     AstNode,
+    ast::{self, ArithOp, BinaryOp, syntax_factory::SyntaxFactory},
 };
 
 use crate::assist_context::{AssistContext, Assists};
 
-// Assist: replace_arith_with_checked
-//
-// Replaces arithmetic on integers with the `checked_*` equivalent.
-//
-// ```
-// fn main() {
-//   let x = 1 $0+ 2;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//   let x = 1.checked_add(2);
-// }
-// ```
-pub(crate) fn replace_arith_with_checked(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn replace_arith_with_checked(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     replace_arith(acc, ctx, ArithKind::Checked)
 }
 
-// Assist: replace_arith_with_saturating
-//
-// Replaces arithmetic on integers with the `saturating_*` equivalent.
-//
-// ```
-// fn main() {
-//   let x = 1 $0+ 2;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//   let x = 1.saturating_add(2);
-// }
-// ```
 pub(crate) fn replace_arith_with_saturating(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     replace_arith(acc, ctx, ArithKind::Saturating)
 }
 
-// Assist: replace_arith_with_wrapping
-//
-// Replaces arithmetic on integers with the `wrapping_*` equivalent.
-//
-// ```
-// fn main() {
-//   let x = 1 $0+ 2;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//   let x = 1.wrapping_add(2);
-// }
-// ```
 pub(crate) fn replace_arith_with_wrapping(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
 fn replace_arith(acc: &mut Assists, ctx: &AssistContext<'_>, kind: ArithKind) -> Option<()> {
     let (lhs, op, rhs) = parse_binary_op(ctx)?;
     let op_expr = lhs.syntax().parent()?;
-
     if !is_primitive_int(ctx, &lhs) || !is_primitive_int(ctx, &rhs) {
         return None;
     }
-
     acc.add_group(
         &GroupLabel("Replace arithmetic...".into()),
         kind.assist_id(),
             let make = SyntaxFactory::with_mappings();
             let method_name = kind.method_name(op);
 
-            let needs_parentheses = lhs
-                .precedence()
-                .needs_parentheses_in(ast::prec::ExprPrecedence::Postfix);
-            let receiver = if needs_parentheses {
-                make.expr_paren(lhs).into()
-            } else {
-                lhs
-            };
+            let needs_parentheses =
+                lhs.precedence().needs_parentheses_in(ast::prec::ExprPrecedence::Postfix);
+            let receiver = if needs_parentheses { make.expr_paren(lhs).into() } else { lhs };
             let arith_expr =
                 make.expr_method_call(receiver, make.name_ref(&method_name), make.arg_list([rhs]));
             edit.replace(op_expr, arith_expr.syntax());
         return None;
     }
     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;
-
     let op = match expr.op_kind() {
         Some(BinaryOp::ArithOp(ArithOp::Add)) => ArithOp::Add,
         Some(BinaryOp::ArithOp(ArithOp::Sub)) => ArithOp::Sub,
         Some(BinaryOp::ArithOp(ArithOp::Div)) => ArithOp::Div,
         _ => return None,
     };
-
     let lhs = expr.lhs()?;
     let rhs = expr.rhs()?;
-
     Some((lhs, op, rhs))
 }
 
             ArithKind::Checked => "replace_arith_with_checked",
             ArithKind::Wrapping => "replace_arith_with_wrapping",
         };
-
         AssistId::refactor_rewrite(s)
     }
 
             ArithKind::Wrapping => "wrapping_",
             ArithKind::Saturating => "saturating_",
         };
-
         let suffix = match op {
             ArithOp::Add => "add",
             ArithOp::Sub => "sub",
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn arith_kind_method_name() {
-        assert_eq!(
-            ArithKind::Saturating.method_name(ArithOp::Add),
-            "saturating_add"
-        );
+        assert_eq!(ArithKind::Saturating.method_name(ArithOp::Add), "saturating_add");
         assert_eq!(ArithKind::Checked.method_name(ArithOp::Sub), "checked_sub");
     }
-
     #[test]
     fn replace_arith_with_checked_add() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_arith_with_saturating_add() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_arith_with_wrapping_add() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_arith_with_wrapping_add_add_parenthesis() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_arith_not_applicable_with_non_empty_selection() {
         check_assist_not_applicable(