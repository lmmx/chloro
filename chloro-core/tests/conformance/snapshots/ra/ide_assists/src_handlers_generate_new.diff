COMPARISON DIFF
============================================================

Original size: 21912 bytes
Chloro size:   21637 bytes
Rustfmt size:  21912 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::{
     imports::import_assets::item_for_path_search, syntax_helpers::suggest_name::NameGenerator,
     use_trivial_constructor::use_trivial_constructor,
 };
 use syntax::{
-    ast::{self, AstNode, HasName, HasVisibility, StructKind, edit_in_place::Indent, make},
+    ast::{self, edit_in_place::Indent, make, AstNode, HasName, HasVisibility, StructKind},
     syntax_editor::Position,
 };
 
 use crate::{
-    AssistContext, AssistId, Assists,
     utils::{find_struct_impl, generate_impl_with_item},
+    AssistContext, AssistId, Assists,
 };
 
-// Assist: generate_new
-//
-// Adds a `fn new` for a type.
-//
-// ```
-// struct Ctx<T: Clone> {
-//      data: T,$0
-// }
-// ```
-// ->
-// ```
-// struct Ctx<T: Clone> {
-//      data: T,
-// }
-//
-// impl<T: Clone> Ctx<T> {
-//     fn $0new(data: T) -> Self {
-//         Self { data }
-//     }
-// }
-// ```
 pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;
 
     let current_module = ctx.sema.scope(strukt.syntax())?.module();
 
     let target = strukt.syntax().text_range();
-    acc.add(AssistId::generate("generate_new"), "Generate `new`", target, |builder| {
+    acc.add(
+        AssistId::generate("generate_new"),
+        "Generate `new`",
+        target,
+        |builder| {
         let trivial_constructors = field_list
             .iter()
             .map(|(name, ty)| {
         }
 
         builder.add_file_edits(ctx.vfs_file_id(), editor);
-    })
+    },
+    )
 }
 
 #[cfg(test)]
 mod record_tests {
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     use super::*;
-
     #[test]
     fn test_generate_new_with_zst_fields() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_new() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_that_visibility_modifiers_dont_get_brought_in() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_it_reuses_existing_impls() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn non_zero_indent() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_visibility_of_new_fn_based_on_struct() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generate_new_not_applicable_if_fn_exists() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn generate_new_target() {
         check_assist_target(
 struct Foo<'a, T: Foo<'a>> {}",
         );
     }
-
     #[test]
     fn test_unrelated_new() {
         check_assist(
 #[cfg(test)]
 mod tuple_tests {
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     use super::*;
-
     #[test]
     fn test_generate_new_with_zst_fields() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_new() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_that_visibility_modifiers_dont_get_brought_in() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generate_new_not_applicable_if_fn_exists() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn generate_new_target() {
         check_assist_target(
 struct Foo<'a, T: Foo<'a>>();",
         );
     }
-
     #[test]
     fn test_unrelated_new() {
         check_assist(