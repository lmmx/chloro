COMPARISON DIFF
============================================================

Original size: 21912 bytes
Chloro size:   21640 bytes
Rustfmt size:  21912 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     utils::{find_struct_impl, generate_impl_with_item},
 };
 
-// Assist: generate_new
-//
-// Adds a `fn new` for a type.
-//
-// ```
-// struct Ctx<T: Clone> {
-//      data: T,$0
-// }
-// ```
-// ->
-// ```
-// struct Ctx<T: Clone> {
-//      data: T,
-// }
-//
-// impl<T: Clone> Ctx<T> {
-//     fn $0new(data: T) -> Self {
-//         Self { data }
-//     }
-// }
-// ```
 pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;
 
     };
 
     // Return early if we've found an existing new fn
+
     let impl_def =
         find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &[String::from("new")])?;
 
     let current_module = ctx.sema.scope(strukt.syntax())?.module();
 
     let target = strukt.syntax().text_range();
-    acc.add(AssistId::generate("generate_new"), "Generate `new`", target, |builder| {
+    acc.add(
+        AssistId::generate("generate_new"),
+        "Generate `new`",
+        target,
+        |builder| {
         let trivial_constructors = field_list
             .iter()
             .map(|(name, ty)| {
         }
 
         builder.add_file_edits(ctx.vfs_file_id(), editor);
-    })
+    },
+    )
 }
 
 #[cfg(test)]
 mod record_tests {
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     use super::*;
-
     #[test]
     fn test_generate_new_with_zst_fields() {
         check_assist(
         );
 
         // make sure the assist only works on unit variants
+
         check_assist(
             generate_new,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_generate_new() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_that_visibility_modifiers_dont_get_brought_in() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_it_reuses_existing_impls() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn non_zero_indent() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_visibility_of_new_fn_based_on_struct() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generate_new_not_applicable_if_fn_exists() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn generate_new_target() {
         check_assist_target(
 struct Foo<'a, T: Foo<'a>> {}",
         );
     }
-
     #[test]
     fn test_unrelated_new() {
         check_assist(
 #[cfg(test)]
 mod tuple_tests {
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     use super::*;
-
     #[test]
     fn test_generate_new_with_zst_fields() {
         check_assist(
         );
 
         // make sure the assist only works on unit variants
+
         check_assist(
             generate_new,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_generate_new() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_that_visibility_modifiers_dont_get_brought_in() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generate_new_not_applicable_if_fn_exists() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn generate_new_target() {
         check_assist_target(
 struct Foo<'a, T: Foo<'a>>();",
         );
     }
-
     #[test]
     fn test_unrelated_new() {
         check_assist(