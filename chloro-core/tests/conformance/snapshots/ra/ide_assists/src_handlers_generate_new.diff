COMPARISON DIFF
============================================================

Original size: 21912 bytes
Chloro size:   21614 bytes
Rustfmt size:  21912 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::{
-    imports::import_assets::item_for_path_search, syntax_helpers::suggest_name::NameGenerator,
+    imports::import_assets::item_for_path_search,
+
+    syntax_helpers::suggest_name::NameGenerator,
+
     use_trivial_constructor::use_trivial_constructor,
 };
 use syntax::{
 };
 
 use crate::{
-    AssistContext, AssistId, Assists,
     utils::{find_struct_impl, generate_impl_with_item},
+    AssistContext,
+    AssistId,
+    Assists,
 };
 
-// Assist: generate_new
-//
-// Adds a `fn new` for a type.
-//
-// ```
-// struct Ctx<T: Clone> {
-//      data: T,$0
-// }
-// ```
-// ->
-// ```
-// struct Ctx<T: Clone> {
-//      data: T,
-// }
-//
-// impl<T: Clone> Ctx<T> {
-//     fn $0new(data: T) -> Self {
-//         Self { data }
-//     }
-// }
-// ```
-pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn generate_new(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;
-
     let field_list = match strukt.kind() {
         StructKind::Record(named) => {
             named.fields().filter_map(|f| Some((f.name()?, f.ty()?))).collect::<Vec<_>>()
         }
         StructKind::Unit => return None,
     };
-
     // Return early if we've found an existing new fn
     let impl_def =
         find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &[String::from("new")])?;
-
     let current_module = ctx.sema.scope(strukt.syntax())?.module();
-
     let target = strukt.syntax().text_range();
     acc.add(AssistId::generate("generate_new"), "Generate `new`", target, |builder| {
         let trivial_constructors = field_list
 #[cfg(test)]
 mod record_tests {
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     use super::*;
-
     #[test]
     fn test_generate_new_with_zst_fields() {
         check_assist(
 }
 "#,
         );
-
         // make sure the assist only works on unit variants
         check_assist(
             generate_new,
 "#,
         );
     }
-
     #[test]
     fn test_generate_new() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_that_visibility_modifiers_dont_get_brought_in() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_it_reuses_existing_impls() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             generate_new,
             r#"
 "#,
         );
     }
-
     #[test]
     fn non_zero_indent() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_visibility_of_new_fn_based_on_struct() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generate_new_not_applicable_if_fn_exists() {
         check_assist_not_applicable(
 }
 "#,
         );
-
         check_assist_not_applicable(
             generate_new,
             r#"
 "#,
         );
     }
-
     #[test]
     fn generate_new_target() {
         check_assist_target(
 struct Foo<'a, T: Foo<'a>> {}",
         );
     }
-
     #[test]
     fn test_unrelated_new() {
         check_assist(
 #[cfg(test)]
 mod tuple_tests {
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     use super::*;
-
     #[test]
     fn test_generate_new_with_zst_fields() {
         check_assist(
 }
 "#,
         );
-
         // make sure the assist only works on unit variants
         check_assist(
             generate_new,
 "#,
         );
     }
-
     #[test]
     fn test_generate_new() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn check_that_visibility_modifiers_dont_get_brought_in() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generate_new_not_applicable_if_fn_exists() {
         check_assist_not_applicable(
 }
 "#,
         );
-
         check_assist_not_applicable(
             generate_new,
             r#"
 "#,
         );
     }
-
     #[test]
     fn generate_new_target() {
         check_assist_target(
 struct Foo<'a, T: Foo<'a>>();",
         );
     }
-
     #[test]
     fn test_unrelated_new() {
         check_assist(