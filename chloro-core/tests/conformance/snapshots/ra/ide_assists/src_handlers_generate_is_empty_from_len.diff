COMPARISON DIFF
============================================================

Original size: 5772 bytes
Chloro size:   5214 bytes
Rustfmt size:  5772 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use hir::{sym, HasSource, Name};
+use hir::{HasSource, Name, sym};
 use syntax::{
     ast::{self, HasName},
     AstNode,
     AssistId,
 };
 
-// Assist: generate_is_empty_from_len
-//
-// Generates is_empty implementation from the len method.
-//
-// ```
-// struct MyStruct { data: Vec<String> }
-//
-// impl MyStruct {
-//     #[must_use]
-//     p$0ub fn len(&self) -> usize {
-//         self.data.len()
-//     }
-// }
-// ```
-// ->
-// ```
-// struct MyStruct { data: Vec<String> }
-//
-// impl MyStruct {
-//     #[must_use]
-//     pub fn len(&self) -> usize {
-//         self.data.len()
-//     }
-//
-//     #[must_use]
-//     pub fn is_empty(&self) -> bool {
-//         self.len() == 0
-//     }
-// }
-// ```
-pub(crate) fn generate_is_empty_from_len(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn generate_is_empty_from_len(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let fn_node = ctx.find_node_at_offset::<ast::Fn>()?;
     let fn_name = fn_node.name()?;
-
     if fn_name.text() != "len" {
         cov_mark::hit!(len_function_not_present);
         return None;
     }
-
     if fn_node.param_list()?.params().next().is_some() {
         cov_mark::hit!(len_function_with_parameters);
         return None;
     }
-
     let impl_ = fn_node.syntax().ancestors().find_map(ast::Impl::cast)?;
     let len_fn = get_impl_method(ctx, &impl_, &Name::new_symbol_root(sym::len))?;
     if !len_fn.ret_type(ctx.sema.db).is_usize() {
         cov_mark::hit!(len_fn_different_return_type);
         return None;
     }
-
     if get_impl_method(ctx, &impl_, &Name::new_symbol_root(sym::is_empty)).is_some() {
         cov_mark::hit!(is_empty_already_implemented);
         return None;
     }
-
     let node = len_fn.source(ctx.sema.db)?;
     let range = node.syntax().value.text_range();
-
     acc.add(
         AssistId::generate("generate_is_empty_from_len"),
         "Generate a is_empty impl from a len function",
 ) -> Option<hir::Function> {
     let db = ctx.sema.db;
     let impl_def: hir::Impl = ctx.sema.to_def(impl_)?;
-
     let scope = ctx.sema.scope(impl_.syntax())?;
     let ty = impl_def.self_ty(db);
     ty.iterate_method_candidates(db, &scope, None, Some(fn_name), Some)
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn len_function_not_present() {
         cov_mark::check!(len_function_not_present);
 "#,
         );
     }
-
     #[test]
     fn len_function_with_parameters() {
         cov_mark::check!(len_function_with_parameters);
 "#,
         );
     }
-
     #[test]
     fn is_empty_already_implemented() {
         cov_mark::check!(is_empty_already_implemented);
 "#,
         );
     }
-
     #[test]
     fn len_fn_different_return_type() {
         cov_mark::check!(len_fn_different_return_type);
 "#,
         );
     }
-
     #[test]
     fn generate_is_empty() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn multiple_functions_in_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn multiple_impls() {
         check_assist_not_applicable(