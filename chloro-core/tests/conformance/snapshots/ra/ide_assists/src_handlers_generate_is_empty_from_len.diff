COMPARISON DIFF
============================================================

Original size: 5772 bytes
Chloro size:   5221 bytes
Rustfmt size:  5772 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     AssistId,
 };
 
-// Assist: generate_is_empty_from_len
-//
-// Generates is_empty implementation from the len method.
-//
-// ```
-// struct MyStruct { data: Vec<String> }
-//
-// impl MyStruct {
-//     #[must_use]
-//     p$0ub fn len(&self) -> usize {
-//         self.data.len()
-//     }
-// }
-// ```
-// ->
-// ```
-// struct MyStruct { data: Vec<String> }
-//
-// impl MyStruct {
-//     #[must_use]
-//     pub fn len(&self) -> usize {
-//         self.data.len()
-//     }
-//
-//     #[must_use]
-//     pub fn is_empty(&self) -> bool {
-//         self.len() == 0
-//     }
-// }
-// ```
-pub(crate) fn generate_is_empty_from_len(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn generate_is_empty_from_len(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let fn_node = ctx.find_node_at_offset::<ast::Fn>()?;
     let fn_name = fn_node.name()?;
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn len_function_not_present() {
         cov_mark::check!(len_function_not_present);
 "#,
         );
     }
-
     #[test]
     fn len_function_with_parameters() {
         cov_mark::check!(len_function_with_parameters);
 "#,
         );
     }
-
     #[test]
     fn is_empty_already_implemented() {
         cov_mark::check!(is_empty_already_implemented);
 "#,
         );
     }
-
     #[test]
     fn len_fn_different_return_type() {
         cov_mark::check!(len_fn_different_return_type);
 "#,
         );
     }
-
     #[test]
     fn generate_is_empty() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn multiple_functions_in_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn multiple_impls() {
         check_assist_not_applicable(