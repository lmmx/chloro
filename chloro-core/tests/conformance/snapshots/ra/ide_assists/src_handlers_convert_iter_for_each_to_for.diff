COMPARISON DIFF
============================================================

Original size: 13249 bytes
Chloro size:   12326 bytes
Rustfmt size:  13343 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: convert_iter_for_each_to_for
-//
-// Converts an Iterator::for_each function into a for loop.
-//
-// ```
-// # //- minicore: iterators
-// # use core::iter;
-// fn main() {
-//     let iter = iter::repeat((9, 2));
-//     iter.for_each$0(|(x, y)| {
-//         println!("x: {}, y: {}", x, y);
-//     });
-// }
-// ```
-// ->
-// ```
-// # use core::iter;
-// fn main() {
-//     let iter = iter::repeat((9, 2));
-//     for (x, y) in iter {
-//         println!("x: {}, y: {}", x, y);
-//     }
-// }
-// ```
 pub(crate) fn convert_iter_for_each_to_for(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     let body = closure.body()?;
 
     let stmt = method.syntax().parent().and_then(ast::ExprStmt::cast);
-    let range = stmt
-        .as_ref()
-        .map_or(method.syntax(), AstNode::syntax)
-        .text_range();
+    let range = stmt.as_ref().map_or(method.syntax(), AstNode::syntax).text_range();
 
     acc.add(
         AssistId::refactor_rewrite("convert_iter_for_each_to_for"),
         "Replace this `Iterator::for_each` with a for loop",
         range,
         |builder| {
-            let indent = stmt
-                .as_ref()
-                .map_or_else(|| method.indent_level(), ast::ExprStmt::indent_level);
-
-            let block = match body {
+        let indent =
+                stmt.as_ref().map_or_else(|| method.indent_level(), ast::ExprStmt::indent_level);
+        let block = match body {
                 ast::Expr::BlockExpr(block) => block,
                 _ => make::block_expr(Vec::new(), Some(body)),
             }
             .clone_for_update();
-            block.reindent_to(indent);
-
-            let expr_for_loop = make::expr_for_loop(param, receiver, block);
-            builder.replace(range, expr_for_loop.to_string())
-        },
+        block.reindent_to(indent);
+        let expr_for_loop = make::expr_for_loop(param, receiver, block);
+        builder.replace(range, expr_for_loop.to_string())
+    },
     )
 }
 
-// Assist: convert_for_loop_with_for_each
-//
-// Converts a for loop into a for_each loop on the Iterator.
-//
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     for$0 v in x {
-//         let y = v * 2;
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     x.into_iter().for_each(|v| {
-//         let y = v * 2;
-//     });
-// }
-// ```
 pub(crate) fn convert_for_loop_with_for_each(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         "Replace this for loop with `Iterator::for_each`",
         for_loop.syntax().text_range(),
         |builder| {
-            let mut buf = String::new();
-
-            if let Some((expr_behind_ref, method, krate)) =
+        let mut buf = String::new();
+        if let Some((expr_behind_ref, method, krate)) =
                 is_ref_and_impls_iter_method(&ctx.sema, &iterable)
             {
                 // We have either "for x in &col" and col implements a method called iter
             } else {
                 format_to!(buf, "{iterable}.into_iter()");
             }
-
-            format_to!(buf, ".for_each(|{pat}| {body});");
-
-            builder.replace(for_loop.syntax().text_range(), buf)
-        },
+        format_to!(buf, ".for_each(|{pat}| {body});");
+        builder.replace(for_loop.syntax().text_range(), buf)
+    },
     )
 }
 
 fn impls_core_iter(sema: &hir::Semantics<'_, ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {
     (|| {
         let it_typ = sema.type_of_expr(iterable)?.adjusted();
-
         let module = sema.scope(iterable.syntax())?.module();
-
         let krate = module.krate();
         let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;
         cov_mark::hit!(test_already_impls_iterator);
         Some(it_typ.impls_trait(sema.db, iter_trait, &[]))
-    })()
-    .unwrap_or(false)
+    })(
+    ).unwrap_or(
+        false,
+    )
 }
 
 fn validate_method_call_expr(
     expr: ast::MethodCallExpr,
 ) -> Option<(ast::Expr, ast::Expr)> {
     let name_ref = expr.name_ref()?;
-    if !name_ref
-        .syntax()
-        .text_range()
-        .contains_range(ctx.selection_trimmed())
-    {
+    if !name_ref.syntax().text_range().contains_range(ctx.selection_trimmed()) {
         cov_mark::hit!(test_for_each_not_applicable_invalid_cursor_pos);
         return None;
     }
     let krate = module.krate();
 
     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;
-    it_type
-        .impls_trait(sema.db, iter_trait, &[])
-        .then_some((expr, receiver))
+    it_type.impls_trait(sema.db, iter_trait, &[]).then_some((expr, receiver))
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_for_each_in_method_stmt() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_for_each_in_method() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_for_each_without_braces_stmt() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_for_each_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_for_each_not_applicable_invalid_cursor_pos() {
         cov_mark::check!(test_for_each_not_applicable_invalid_cursor_pos);
 }"#,
         )
     }
-
     #[test]
     fn each_to_for_not_for() {
         check_assist_not_applicable(
         ",
         )
     }
-
     #[test]
     fn each_to_for_simple_for() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_in_range() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn each_to_for_not_available_in_body() {
         cov_mark::check!(not_available_in_body);
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_no_iter_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut_behind_var() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_already_impls_iterator() {
         cov_mark::check!(test_already_impls_iterator);