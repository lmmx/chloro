COMPARISON DIFF
============================================================

Original size: 22284 bytes
Chloro size:   20773 bytes
Rustfmt size:  22284 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::{famous_defs::FamousDefs, source_change::SourceChangeBuilder};
 use stdx::{format_to, to_lower_snake_case};
 use syntax::{
-    TextRange,
-    ast::{self, AstNode, HasName, HasVisibility, edit_in_place::Indent, make},
-    ted,
+    ast::{self, edit_in_place::Indent, make, AstNode, HasName, HasVisibility},
+    ted, TextRange,
 };
 
 use crate::{
-    AssistContext, AssistId, Assists, GroupLabel,
     utils::{convert_reference_type, find_struct_impl, generate_impl},
+    AssistContext, AssistId, Assists, GroupLabel,
 };
 
-// Assist: generate_setter
-//
-// Generate a setter method.
-//
-// ```
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0set_name(&mut self, name: String) {
-//         self.name = name;
-//     }
-// }
-// ```
 pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // This if condition denotes two modes this assist can work in:
     // - First is acting upon selection of record fields
     //
     // This is the only part where implementation diverges a bit,
     // subsequent code is generic for both of these modes
-
     let (strukt, info_of_record_fields, mut fn_names) = extract_and_parse(ctx, AssistType::Set)?;
 
     // No record fields to do work on :(
 
     let setter_info = AssistInfo { impl_def, strukt, assist_type: AssistType::Set };
 
-    acc.add_group(
+    acc
+        .add_group(
         &GroupLabel("Generate getter/setter".to_owned()),
         AssistId::generate("generate_setter"),
         "Generate a setter method",
     Some(())
 }
 
-// Assist: generate_getter
-//
-// Generate a getter method.
-//
-// ```
-// # //- minicore: as_ref, deref
-// # pub struct String;
-// # impl AsRef<str> for String {
-// #     fn as_ref(&self) -> &str {
-// #         ""
-// #     }
-// # }
-// #
-// # impl core::ops::Deref for String {
-// #     type Target = str;
-// #     fn deref(&self) -> &Self::Target {
-// #         ""
-// #     }
-// # }
-// #
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// # pub struct String;
-// # impl AsRef<str> for String {
-// #     fn as_ref(&self) -> &str {
-// #         ""
-// #     }
-// # }
-// #
-// # impl core::ops::Deref for String {
-// #     type Target = str;
-// #     fn deref(&self) -> &Self::Target {
-// #         ""
-// #     }
-// # }
-// #
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0name(&self) -> &str {
-//         &self.name
-//     }
-// }
-// ```
 pub(crate) fn generate_getter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_getter_impl(acc, ctx, false)
 }
 
-// Assist: generate_getter_mut
-//
-// Generate a mut getter method.
-//
-// ```
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0name_mut(&mut self) -> &mut String {
-//         &mut self.name
-//     }
-// }
-// ```
 pub(crate) fn generate_getter_mut(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_getter_impl(acc, ctx, true)
 }
     ctx: &AssistContext<'_>,
     mutable: bool,
 ) -> Option<()> {
-    let (strukt, info_of_record_fields, fn_names) =
-        extract_and_parse(ctx, if mutable { AssistType::MutGet } else { AssistType::Get })?;
+    let (strukt, info_of_record_fields, fn_names) = extract_and_parse(ctx, if mutable { AssistType::MutGet } else { AssistType::Get })?;
     // No record fields to do work on :(
     if info_of_record_fields.is_empty() {
         return None;
     let field_ty = &record_field_info.field_ty;
 
     // Make the param list
+
     // `(&mut self, $field_name: $field_ty)`
-    let field_param =
-        make::param(make::ident_pat(false, false, make::name(field_name)).into(), field_ty.clone());
+    let field_param = make::param(make::ident_pat(false, false, make::name(field_name)).into(), field_ty.clone());
     let params = make::param_list(Some(make::mut_self_param()), [field_param]);
 
     // Make the assignment body
+
     // `self.$field_name = $field_name`
     let self_expr = make::ext::expr_self();
     let lhs = make::expr_field(self_expr, field_name);
 #[cfg(test)]
 mod tests_getter {
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_generate_getter_from_field() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_already_implemented() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_with_visibility_marker() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_with_visibility_marker_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generate_getter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generate_getter_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_not_a_special_case() {
         cov_mark::check_count!(convert_reference_type, 0);
 "#,
         );
     }
-
     #[test]
     fn test_convert_reference_type() {
         cov_mark::check_count!(convert_reference_type, 6);
 "#,
         );
     }
-
     #[test]
     fn test_generate_multiple_getters_from_selection() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn test_generate_multiple_getters_from_selection_one_already_exists() {
         // As impl for one of the fields already exist, skip it
 #[cfg(test)]
 mod tests_setter {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     fn check_not_applicable(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_assist_not_applicable(generate_setter, ra_fixture)
     }
-
     #[test]
     fn test_generate_setter_from_field() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_setter_already_implemented() {
         check_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_setter_from_field_with_visibility_marker() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_multiple_generate_setter() {
         check_assist(