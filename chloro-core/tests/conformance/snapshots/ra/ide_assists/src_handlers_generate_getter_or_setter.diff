COMPARISON DIFF
============================================================

Original size: 22284 bytes
Chloro size:   20796 bytes
Rustfmt size:  22284 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     utils::{convert_reference_type, find_struct_impl, generate_impl},
 };
 
-// Assist: generate_setter
-//
-// Generate a setter method.
-//
-// ```
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0set_name(&mut self, name: String) {
-//         self.name = name;
-//     }
-// }
-// ```
 pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // This if condition denotes two modes this assist can work in:
     // - First is acting upon selection of record fields
     let (strukt, info_of_record_fields, mut fn_names) = extract_and_parse(ctx, AssistType::Set)?;
 
     // No record fields to do work on :(
+
     if info_of_record_fields.is_empty() {
         return None;
     }
 
     // Prepend set_ to fn names.
+
     fn_names.iter_mut().for_each(|name| *name = format!("set_{name}"));
 
     // Return early if we've found an existing fn
+
     let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &fn_names)?;
 
     // Computing collective text range of all record fields in selected region
+
     let target: TextRange = info_of_record_fields
         .iter()
         .map(|record_field_info| record_field_info.target)
     Some(())
 }
 
-// Assist: generate_getter
-//
-// Generate a getter method.
-//
-// ```
-// # //- minicore: as_ref, deref
-// # pub struct String;
-// # impl AsRef<str> for String {
-// #     fn as_ref(&self) -> &str {
-// #         ""
-// #     }
-// # }
-// #
-// # impl core::ops::Deref for String {
-// #     type Target = str;
-// #     fn deref(&self) -> &Self::Target {
-// #         ""
-// #     }
-// # }
-// #
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// # pub struct String;
-// # impl AsRef<str> for String {
-// #     fn as_ref(&self) -> &str {
-// #         ""
-// #     }
-// # }
-// #
-// # impl core::ops::Deref for String {
-// #     type Target = str;
-// #     fn deref(&self) -> &Self::Target {
-// #         ""
-// #     }
-// # }
-// #
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0name(&self) -> &str {
-//         &self.name
-//     }
-// }
-// ```
 pub(crate) fn generate_getter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_getter_impl(acc, ctx, false)
 }
 
-// Assist: generate_getter_mut
-//
-// Generate a mut getter method.
-//
-// ```
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0name_mut(&mut self) -> &mut String {
-//         &mut self.name
-//     }
-// }
-// ```
 pub(crate) fn generate_getter_mut(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_getter_impl(acc, ctx, true)
 }
     };
 
     // Computing collective text range of all record fields in selected region
+
     let target: TextRange = info_of_record_fields
         .iter()
         .map(|record_field_info| record_field_info.target)
     let field_ty = &record_field_info.field_ty;
 
     // Make the param list
+
     // `(&mut self, $field_name: $field_ty)`
+
     let field_param =
         make::param(make::ident_pat(false, false, make::name(field_name)).into(), field_ty.clone());
     let params = make::param_list(Some(make::mut_self_param()), [field_param]);
 
     // Make the assignment body
+
     // `self.$field_name = $field_name`
+
     let self_expr = make::ext::expr_self();
     let lhs = make::expr_field(self_expr, field_name);
     let rhs = make::expr_path(make::ext::ident_path(field_name));
     let body = make::block_expr([assign_stmt.into()], None);
 
     // Make the setter fn
+
     make::fn_(
         None,
         strukt.visibility(),
     }
 
     // Single Record Field mode
+
     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;
     let field = ctx.find_node_at_offset::<ast::RecordField>()?;
     let record_field_info = parse_record_field(field, &assist_type)?;
                     None
                 })
                 .collect::<Vec<RecordFieldInfo>>();
-
             if info_of_record_fields_in_selection.is_empty() {
                 return None;
             }
-
             Some((info_of_record_fields_in_selection, field_names))
         }
         ast::FieldList::TupleFieldList(_) => None,
 
     for (i, record_field_info) in info_of_record_fields.iter().enumerate() {
         // Make the new getter or setter fn
+        // Insert a tabstop only for last method we generate
         let new_fn = match assist_info.assist_type {
             AssistType::Set => generate_setter_from_info(&assist_info, record_field_info),
             _ => generate_getter_from_info(ctx, &assist_info, record_field_info),
         }
         .clone_for_update();
         new_fn.indent(1.into());
-
-        // Insert a tabstop only for last method we generate
         if i == record_fields_count - 1
             && let Some(cap) = ctx.config.snippet_cap
             && let Some(name) = new_fn.name()
         {
             builder.add_tabstop_before(cap, name);
         }
-
         assoc_item_list.add_item(new_fn.clone().into());
     }
 }
 #[cfg(test)]
 mod tests_getter {
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_generate_getter_from_field() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_already_implemented() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_with_visibility_marker() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_with_visibility_marker_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generate_getter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generate_getter_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_not_a_special_case() {
         cov_mark::check_count!(convert_reference_type, 0);
 "#,
         );
     }
-
     #[test]
     fn test_convert_reference_type() {
         cov_mark::check_count!(convert_reference_type, 6);
 
         // Copy
+
         check_assist(
             generate_getter,
             r#"
         );
 
         // AsRef<str>
+
         check_assist(
             generate_getter,
             r#"
         );
 
         // AsRef<T>
+
         check_assist(
             generate_getter,
             r#"
         );
 
         // AsRef<[T]>
+
         check_assist(
             generate_getter,
             r#"
         );
 
         // Option
+
         check_assist(
             generate_getter,
             r#"
         );
 
         // Result
+
         check_assist(
             generate_getter,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_generate_multiple_getters_from_selection() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn test_generate_multiple_getters_from_selection_one_already_exists() {
         // As impl for one of the fields already exist, skip it
 #[cfg(test)]
 mod tests_setter {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     fn check_not_applicable(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_assist_not_applicable(generate_setter, ra_fixture)
     }
-
     #[test]
     fn test_generate_setter_from_field() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_setter_already_implemented() {
         check_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_setter_from_field_with_visibility_marker() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_multiple_generate_setter() {
         check_assist(