COMPARISON DIFF
============================================================

Original size: 22284 bytes
Chloro size:   20779 bytes
Rustfmt size:  22284 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::{famous_defs::FamousDefs, source_change::SourceChangeBuilder};
 use stdx::{format_to, to_lower_snake_case};
 use syntax::{
-    TextRange,
-    ast::{self, AstNode, HasName, HasVisibility, edit_in_place::Indent, make},
-    ted,
+    ast::{edit_in_place::Indent, make, self, AstNode, HasName, HasVisibility},
+    ted, TextRange,
 };
 
 use crate::{
-    AssistContext, AssistId, Assists, GroupLabel,
     utils::{convert_reference_type, find_struct_impl, generate_impl},
+    AssistContext, AssistId, Assists, GroupLabel,
 };
 
-// Assist: generate_setter
-//
-// Generate a setter method.
-//
-// ```
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0set_name(&mut self, name: String) {
-//         self.name = name;
-//     }
-// }
-// ```
 pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // This if condition denotes two modes this assist can work in:
     // - First is acting upon selection of record fields
     // subsequent code is generic for both of these modes
 
     let (strukt, info_of_record_fields, mut fn_names) = extract_and_parse(ctx, AssistType::Set)?;
-
     // No record fields to do work on :(
+
     if info_of_record_fields.is_empty() {
         return None;
     }
-
     // Prepend set_ to fn names.
+
     fn_names.iter_mut().for_each(|name| *name = format!("set_{name}"));
-
     // Return early if we've found an existing fn
-    let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &fn_names)?;
 
+    let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), &fn_names)?;
     // Computing collective text range of all record fields in selected region
+
     let target: TextRange = info_of_record_fields
         .iter()
         .map(|record_field_info| record_field_info.target)
     Some(())
 }
 
-// Assist: generate_getter
-//
-// Generate a getter method.
-//
-// ```
-// # //- minicore: as_ref, deref
-// # pub struct String;
-// # impl AsRef<str> for String {
-// #     fn as_ref(&self) -> &str {
-// #         ""
-// #     }
-// # }
-// #
-// # impl core::ops::Deref for String {
-// #     type Target = str;
-// #     fn deref(&self) -> &Self::Target {
-// #         ""
-// #     }
-// # }
-// #
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// # pub struct String;
-// # impl AsRef<str> for String {
-// #     fn as_ref(&self) -> &str {
-// #         ""
-// #     }
-// # }
-// #
-// # impl core::ops::Deref for String {
-// #     type Target = str;
-// #     fn deref(&self) -> &Self::Target {
-// #         ""
-// #     }
-// # }
-// #
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0name(&self) -> &str {
-//         &self.name
-//     }
-// }
-// ```
 pub(crate) fn generate_getter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_getter_impl(acc, ctx, false)
 }
 
-// Assist: generate_getter_mut
-//
-// Generate a mut getter method.
-//
-// ```
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0name_mut(&mut self) -> &mut String {
-//         &mut self.name
-//     }
-// }
-// ```
 pub(crate) fn generate_getter_mut(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_getter_impl(acc, ctx, true)
 }
     } else {
         ("generate_getter", "Generate a getter method")
     };
-
     // Computing collective text range of all record fields in selected region
+
     let target: TextRange = info_of_record_fields
         .iter()
         .map(|record_field_info| record_field_info.target)
     let field_name = &record_field_info.fn_name;
     let fn_name = make::name(&format!("set_{field_name}"));
     let field_ty = &record_field_info.field_ty;
-
     // Make the param list
     // `(&mut self, $field_name: $field_ty)`
+
     let field_param =
         make::param(make::ident_pat(false, false, make::name(field_name)).into(), field_ty.clone());
     let params = make::param_list(Some(make::mut_self_param()), [field_param]);
-
     // Make the assignment body
     // `self.$field_name = $field_name`
+
     let self_expr = make::ext::expr_self();
     let lhs = make::expr_field(self_expr, field_name);
     let rhs = make::expr_path(make::ext::ident_path(field_name));
     let assign_stmt = make::expr_stmt(make::expr_assignment(lhs, rhs).into());
     let body = make::block_expr([assign_stmt.into()], None);
-
     // Make the setter fn
+
     make::fn_(
         None,
         strukt.visibility(),
 
         return Some((parent_struct, info_of_record_fields, field_names));
     }
-
     // Single Record Field mode
+
     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;
     let field = ctx.find_node_at_offset::<ast::RecordField>()?;
     let record_field_info = parse_record_field(field, &assist_type)?;
 #[cfg(test)]
 mod tests_getter {
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_generate_getter_from_field() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_already_implemented() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_with_visibility_marker() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_with_visibility_marker_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generate_getter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generate_getter_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_not_a_special_case() {
         cov_mark::check_count!(convert_reference_type, 0);
 "#,
         );
     }
-
     #[test]
     fn test_convert_reference_type() {
         cov_mark::check_count!(convert_reference_type, 6);
-
         // Copy
+
         check_assist(
             generate_getter,
             r#"
 }
 "#,
         );
-
         // AsRef<str>
+
         check_assist(
             generate_getter,
             r#"
 }
 "#,
         );
-
         // AsRef<T>
+
         check_assist(
             generate_getter,
             r#"
 }
 "#,
         );
-
         // AsRef<[T]>
+
         check_assist(
             generate_getter,
             r#"
 }
 "#,
         );
-
         // Option
+
         check_assist(
             generate_getter,
             r#"
 }
 "#,
         );
-
         // Result
+
         check_assist(
             generate_getter,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_generate_multiple_getters_from_selection() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn test_generate_multiple_getters_from_selection_one_already_exists() {
         // As impl for one of the fields already exist, skip it
 #[cfg(test)]
 mod tests_setter {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     fn check_not_applicable(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_assist_not_applicable(generate_setter, ra_fixture)
     }
-
     #[test]
     fn test_generate_setter_from_field() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_setter_already_implemented() {
         check_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_setter_from_field_with_visibility_marker() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_multiple_generate_setter() {
         check_assist(