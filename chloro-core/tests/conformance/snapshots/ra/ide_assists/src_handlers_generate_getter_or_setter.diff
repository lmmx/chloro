COMPARISON DIFF
============================================================

Original size: 22284 bytes
Chloro size:   20672 bytes
Rustfmt size:  22284 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::{famous_defs::FamousDefs, source_change::SourceChangeBuilder};
 use stdx::{format_to, to_lower_snake_case};
 use syntax::{
-    TextRange,
-    ast::{self, AstNode, HasName, HasVisibility, edit_in_place::Indent, make},
-    ted,
+    ast::{self, edit_in_place::Indent, make, AstNode, HasName, HasVisibility},
+    ted, TextRange,
 };
 
 use crate::{
-    AssistContext, AssistId, Assists, GroupLabel,
     utils::{convert_reference_type, find_struct_impl, generate_impl},
+    AssistContext, AssistId, Assists, GroupLabel,
 };
 
-// Assist: generate_setter
-//
-// Generate a setter method.
-//
-// ```
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0set_name(&mut self, name: String) {
-//         self.name = name;
-//     }
-// }
-// ```
 pub(crate) fn generate_setter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // This if condition denotes two modes this assist can work in:
     // - First is acting upon selection of record fields
     //
     // This is the only part where implementation diverges a bit,
     // subsequent code is generic for both of these modes
-
     let (strukt, info_of_record_fields, mut fn_names) = extract_and_parse(ctx, AssistType::Set)?;
 
     // No record fields to do work on :(
     Some(())
 }
 
-// Assist: generate_getter
-//
-// Generate a getter method.
-//
-// ```
-// # //- minicore: as_ref, deref
-// # pub struct String;
-// # impl AsRef<str> for String {
-// #     fn as_ref(&self) -> &str {
-// #         ""
-// #     }
-// # }
-// #
-// # impl core::ops::Deref for String {
-// #     type Target = str;
-// #     fn deref(&self) -> &Self::Target {
-// #         ""
-// #     }
-// # }
-// #
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// # pub struct String;
-// # impl AsRef<str> for String {
-// #     fn as_ref(&self) -> &str {
-// #         ""
-// #     }
-// # }
-// #
-// # impl core::ops::Deref for String {
-// #     type Target = str;
-// #     fn deref(&self) -> &Self::Target {
-// #         ""
-// #     }
-// # }
-// #
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0name(&self) -> &str {
-//         &self.name
-//     }
-// }
-// ```
 pub(crate) fn generate_getter(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_getter_impl(acc, ctx, false)
 }
 
-// Assist: generate_getter_mut
-//
-// Generate a mut getter method.
-//
-// ```
-// struct Person {
-//     nam$0e: String,
-// }
-// ```
-// ->
-// ```
-// struct Person {
-//     name: String,
-// }
-//
-// impl Person {
-//     fn $0name_mut(&mut self) -> &mut String {
-//         &mut self.name
-//     }
-// }
-// ```
 pub(crate) fn generate_getter_mut(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_getter_impl(acc, ctx, true)
 }
     let field_ty = &record_field_info.field_ty;
 
     // Make the param list
+
     // `(&mut self, $field_name: $field_ty)`
     let field_param =
         make::param(make::ident_pat(false, false, make::name(field_name)).into(), field_ty.clone());
     let params = make::param_list(Some(make::mut_self_param()), [field_param]);
 
     // Make the assignment body
+
     // `self.$field_name = $field_name`
     let self_expr = make::ext::expr_self();
     let lhs = make::expr_field(self_expr, field_name);
                     None
                 })
                 .collect::<Vec<RecordFieldInfo>>();
-
             if info_of_record_fields_in_selection.is_empty() {
                 return None;
             }
-
             Some((info_of_record_fields_in_selection, field_names))
-        }
+        },
         ast::FieldList::TupleFieldList(_) => None,
     }
 }
     let assoc_item_list = impl_def.get_or_create_assoc_item_list();
 
     for (i, record_field_info) in info_of_record_fields.iter().enumerate() {
-        // Make the new getter or setter fn
         let new_fn = match assist_info.assist_type {
             AssistType::Set => generate_setter_from_info(&assist_info, record_field_info),
             _ => generate_getter_from_info(ctx, &assist_info, record_field_info),
         }
         .clone_for_update();
         new_fn.indent(1.into());
-
-        // Insert a tabstop only for last method we generate
         if i == record_fields_count - 1
             && let Some(cap) = ctx.config.snippet_cap
             && let Some(name) = new_fn.name()
         {
             builder.add_tabstop_before(cap, name);
         }
-
         assoc_item_list.add_item(new_fn.clone().into());
     }
 }
 #[cfg(test)]
 mod tests_getter {
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_generate_getter_from_field() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_already_implemented() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_with_visibility_marker() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generate_getter_from_field_with_visibility_marker_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generate_getter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generate_getter_no_snippet_cap() {
         check_assist_no_snippet_cap(
 "#,
         );
     }
-
     #[test]
     fn test_not_a_special_case() {
         cov_mark::check_count!(convert_reference_type, 0);
 "#,
         );
     }
-
     #[test]
     fn test_convert_reference_type() {
         cov_mark::check_count!(convert_reference_type, 6);
 "#,
         );
     }
-
     #[test]
     fn test_generate_multiple_getters_from_selection() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn test_generate_multiple_getters_from_selection_one_already_exists() {
         // As impl for one of the fields already exist, skip it
 #[cfg(test)]
 mod tests_setter {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     fn check_not_applicable(#[rust_analyzer::rust_fixture] ra_fixture: &str) {
         check_assist_not_applicable(generate_setter, ra_fixture)
     }
-
     #[test]
     fn test_generate_setter_from_field() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_setter_already_implemented() {
         check_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_setter_from_field_with_visibility_marker() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_multiple_generate_setter() {
         check_assist(