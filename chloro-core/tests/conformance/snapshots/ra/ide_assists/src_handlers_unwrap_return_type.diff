COMPARISON DIFF
============================================================

Original size: 45712 bytes
Chloro size:   45651 bytes
Rustfmt size:  46102 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
     let happy_type = extract_wrapped_type(type_ref)?;
 
-    acc.add(
-        kind.assist_id(),
-        kind.label(),
-        type_ref.syntax().text_range(),
-        |builder| {
-            let mut editor = builder.make_editor(&parent);
-            let make = SyntaxFactory::with_mappings();
+    acc.add(kind.assist_id(), kind.label(), type_ref.syntax().text_range(), |builder| {
+        let mut editor = builder.make_editor(&parent);
+        let make = SyntaxFactory::with_mappings();
 
-            let mut exprs_to_unwrap = Vec::new();
-            let tail_cb = &mut |e: &_| tail_cb_impl(&mut exprs_to_unwrap, e);
-            walk_expr(&body_expr, &mut |expr| {
-                if let ast::Expr::ReturnExpr(ret_expr) = expr
-                    && let Some(ret_expr_arg) = &ret_expr.expr()
-                {
-                    for_each_tail_expr(ret_expr_arg, tail_cb);
-                }
-            });
-            for_each_tail_expr(&body_expr, tail_cb);
-
-            let is_unit_type = is_unit_type(&happy_type);
-            if is_unit_type {
-                if let Some(NodeOrToken::Token(token)) = ret_type.syntax().next_sibling_or_token()
-                    && token.kind() == SyntaxKind::WHITESPACE
-                {
-                    editor.delete(token);
-                }
-
-                editor.delete(ret_type.syntax());
-            } else {
-                editor.replace(type_ref.syntax(), happy_type.syntax());
-            }
-
-            let mut final_placeholder = None;
-            for tail_expr in exprs_to_unwrap {
-                match &tail_expr {
-                    ast::Expr::CallExpr(call_expr) => {
-                        let ast::Expr::PathExpr(path_expr) = call_expr.expr().unwrap() else {
-                            continue;
-                        };
-
-                        let path_str = path_expr.path().unwrap().to_string();
-                        let needs_replacing = match kind {
-                            UnwrapperKind::Option => path_str == "Some",
-                            UnwrapperKind::Result => path_str == "Ok" || path_str == "Err",
-                        };
-
-                        if !needs_replacing {
-                            continue;
-                        }
-
-                        let arg_list = call_expr.arg_list().unwrap();
-                        if is_unit_type {
-                            let tail_parent = tail_expr
-                                .syntax()
-                                .parent()
-                                .and_then(Either::<ast::ReturnExpr, ast::StmtList>::cast)
-                                .unwrap();
-                            match tail_parent {
-                                Either::Left(ret_expr) => editor
-                                    .replace(ret_expr.syntax(), make.expr_return(None).syntax()),
-                                Either::Right(stmt_list) => {
-                                    let new_block = if stmt_list.statements().next().is_none() {
-                                        make.expr_empty_block()
-                                    } else {
-                                        make.block_expr(stmt_list.statements(), None)
-                                    };
-                                    editor.replace(
-                                        stmt_list.syntax(),
-                                        new_block.stmt_list().unwrap().syntax(),
-                                    );
-                                }
-                            }
-                        } else if let Some(first_arg) = arg_list.args().next() {
-                            editor.replace(tail_expr.syntax(), first_arg.syntax());
-                        }
-                    }
-                    ast::Expr::PathExpr(path_expr) => {
-                        let UnwrapperKind::Option = kind else {
-                            continue;
-                        };
-
-                        if path_expr.path().unwrap().to_string() != "None" {
-                            continue;
-                        }
-
-                        let new_tail_expr = make.expr_unit();
-                        editor.replace(path_expr.syntax(), new_tail_expr.syntax());
-                        if let Some(cap) = ctx.config.snippet_cap {
-                            editor.add_annotation(
-                                new_tail_expr.syntax(),
-                                builder.make_placeholder_snippet(cap),
-                            );
-
-                            final_placeholder = Some(new_tail_expr);
-                        }
-                    }
-                    _ => (),
-                }
-            }
-
-            if let Some(cap) = ctx.config.snippet_cap
-                && let Some(final_placeholder) = final_placeholder
+        let mut exprs_to_unwrap = Vec::new();
+        let tail_cb = &mut |e: &_| tail_cb_impl(&mut exprs_to_unwrap, e);
+        walk_expr(&body_expr, &mut |expr| {
+            if let ast::Expr::ReturnExpr(ret_expr) = expr
+                && let Some(ret_expr_arg) = &ret_expr.expr()
             {
-                editor.add_annotation(final_placeholder.syntax(), builder.make_tabstop_after(cap));
+                for_each_tail_expr(ret_expr_arg, tail_cb);
+            }
+        });
+        for_each_tail_expr(&body_expr, tail_cb);
+
+        let is_unit_type = is_unit_type(&happy_type);
+        if is_unit_type {
+            if let Some(NodeOrToken::Token(token)) = ret_type.syntax().next_sibling_or_token()
+                && token.kind() == SyntaxKind::WHITESPACE
+            {
+                editor.delete(token);
             }
 
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
-    )
+            editor.delete(ret_type.syntax());
+        } else {
+            editor.replace(type_ref.syntax(), happy_type.syntax());
+        }
+
+        let mut final_placeholder = None;
+        for tail_expr in exprs_to_unwrap {
+            match &tail_expr {
+                ast::Expr::CallExpr(call_expr) => {
+                    let ast::Expr::PathExpr(path_expr) = call_expr.expr().unwrap() else {
+                        continue;
+                    };
+
+                    let path_str = path_expr.path().unwrap().to_string();
+                    let needs_replacing = match kind {
+                        UnwrapperKind::Option => path_str == "Some",
+                        UnwrapperKind::Result => path_str == "Ok" || path_str == "Err",
+                    };
+
+                    if !needs_replacing {
+                        continue;
+                    }
+
+                    let arg_list = call_expr.arg_list().unwrap();
+                    if is_unit_type {
+                        let tail_parent = tail_expr
+                            .syntax()
+                            .parent()
+                            .and_then(Either::<ast::ReturnExpr, ast::StmtList>::cast)
+                            .unwrap();
+                        match tail_parent {
+                            Either::Left(ret_expr) => {
+                                editor.replace(ret_expr.syntax(), make.expr_return(None).syntax())
+                            }
+                            Either::Right(stmt_list) => {
+                                let new_block = if stmt_list.statements().next().is_none() {
+                                    make.expr_empty_block()
+                                } else {
+                                    make.block_expr(stmt_list.statements(), None)
+                                };
+                                editor.replace(
+                                    stmt_list.syntax(),
+                                    new_block.stmt_list().unwrap().syntax(),
+                                );
+                            }
+                        }
+                    } else if let Some(first_arg) = arg_list.args().next() {
+                        editor.replace(tail_expr.syntax(), first_arg.syntax());
+                    }
+                }
+                ast::Expr::PathExpr(path_expr) => {
+                    let UnwrapperKind::Option = kind else {
+                        continue;
+                    };
+
+                    if path_expr.path().unwrap().to_string() != "None" {
+                        continue;
+                    }
+
+                    let new_tail_expr = make.expr_unit();
+                    editor.replace(path_expr.syntax(), new_tail_expr.syntax());
+                    if let Some(cap) = ctx.config.snippet_cap {
+                        editor.add_annotation(
+                            new_tail_expr.syntax(),
+                            builder.make_placeholder_snippet(cap),
+                        );
+
+                        final_placeholder = Some(new_tail_expr);
+                    }
+                }
+                _ => (),
+            }
+        }
+
+        if let Some(cap) = ctx.config.snippet_cap
+            && let Some(final_placeholder) = final_placeholder
+        {
+            editor.add_annotation(final_placeholder.syntax(), builder.make_tabstop_after(cap));
+        }
+
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    })
 }
 
 enum UnwrapperKind {
 }
 
 fn is_unit_type(ty: &ast::Type) -> bool {
-    let ast::Type::TupleType(tuple) = ty else {
-        return false;
-    };
+    let ast::Type::TupleType(tuple) = ty else { return false };
     tuple.fields().next().is_none()
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist_by_label, check_assist_not_applicable_by_label};
-
     use super::*;
-
     #[test]
     fn unwrap_option_return_type_simple() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_unit_type() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_none() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_multi_none() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_ending_with_parent() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_break_split_tail() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_closure() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_return_type_bad_cursor() {
         check_assist_not_applicable_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_return_type_bad_cursor_closure() {
         check_assist_not_applicable_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_closure_non_block() {
         check_assist_not_applicable_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_return_type_already_not_option_std() {
         check_assist_not_applicable_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_return_type_already_not_option_closure() {
         check_assist_not_applicable_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_tail() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_tail_closure() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_tail_only() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_tail_block_like() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_without_block_closure() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_nested_if() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_await() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_array() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_cast() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_tail_block_like_match() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_loop_with_tail() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_loop_in_let_stmt() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_tail_block_like_match_return_expr() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_tail_block_like_match_deeper() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_tail_block_like_early_return() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_in_tail_position() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_closure() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_simple_with_weird_forms() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_option_return_type_nested_type() {
         check_assist_by_label(
             "Unwrap Option return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_unit_type() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_ending_with_parent() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_break_split_tail() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_closure() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_return_type_bad_cursor() {
         check_assist_not_applicable_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_return_type_bad_cursor_closure() {
         check_assist_not_applicable_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_closure_non_block() {
         check_assist_not_applicable_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_return_type_already_not_result_std() {
         check_assist_not_applicable_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_return_type_already_not_result_closure() {
         check_assist_not_applicable_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_tail() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_tail_closure() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_tail_only() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_tail_block_like() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_without_block_closure() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_nested_if() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_await() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_array() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_cast() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_tail_block_like_match() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_loop_with_tail() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_loop_in_let_stmt() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_tail_block_like_match_return_expr() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_tail_block_like_match_deeper() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_tail_block_like_early_return() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_in_tail_position() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_closure() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_simple_with_weird_forms() {
         check_assist_by_label(
             "Unwrap Result return type",
         );
     }
-
     #[test]
     fn unwrap_result_return_type_nested_type() {
         check_assist_by_label(