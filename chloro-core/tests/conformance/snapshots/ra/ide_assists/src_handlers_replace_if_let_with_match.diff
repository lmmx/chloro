COMPARISON DIFF
============================================================

Original size: 49350 bytes
Chloro size:   48219 bytes
Rustfmt size:  49350 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     utils::{does_pat_match_variant, does_pat_variant_nested_or_literal, unwrap_trivial_block},
 };
 
-// Assist: replace_if_let_with_match
-//
-// Replaces a `if let` expression with a `match` expression.
-//
-// ```
-// enum Action { Move { distance: u32 }, Stop }
-//
-// fn handle(action: Action) {
-//     $0if let Action::Move { distance } = action {
-//         foo(distance)
-//     } else {
-//         bar()
-//     }
-// }
-// ```
-// ->
-// ```
-// enum Action { Move { distance: u32 }, Stop }
-//
-// fn handle(action: Action) {
-//     match action {
-//         Action::Move { distance } => foo(distance),
-//         _ => bar(),
-//     }
-// }
-// ```
-pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn replace_if_let_with_match(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;
     let available_range = TextRange::new(
         if_expr.syntax().text_range().start(),
         (Some(let_expr), _) => let_expr.expr()?,
         (None, cond) => cond?,
     };
-
     let mut pat_seen = false;
     let mut cond_bodies = Vec::new();
     for if_expr in if_exprs {
         body.indent(IndentLevel(1));
         cond_bodies.push((cond, guard, body));
     }
-
     if !pat_seen && cond_bodies.len() != 1 {
         // Don't offer turning an if (chain) without patterns into a match,
         // unless its a simple `if cond { .. } (else { .. })`
         return None;
     }
-
     let let_ = if pat_seen { " let" } else { "" };
-
     acc.add(
         AssistId::refactor_rewrite("replace_if_let_with_match"),
         format!("Replace if{let_} with match"),
     make.match_arm(pattern, None, expr)
 }
 
-// Assist: replace_match_with_if_let
-//
-// Replaces a binary `match` with a wildcard pattern with an `if let` expression.
-//
-// ```
-// enum Action { Move { distance: u32 }, Stop }
-//
-// fn handle(action: Action) {
-//     $0match action {
-//         Action::Move { distance } => foo(distance),
-//         _ => bar(),
-//     }
-// }
-// ```
-// ->
-// ```
-// enum Action { Move { distance: u32 }, Stop }
-//
-// fn handle(action: Action) {
-//     if let Action::Move { distance } = action {
-//         foo(distance)
-//     } else {
-//         bar()
-//     }
-// }
-// ```
-pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn replace_match_with_if_let(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let match_expr: ast::MatchExpr = ctx.find_node_at_offset()?;
     let match_arm_list = match_expr.match_arm_list()?;
     let available_range = TextRange::new(
     if !cursor_in_range {
         return None;
     }
-
     let mut arms = match_arm_list.arms();
     let (first_arm, second_arm) = (arms.next()?, arms.next()?);
     if arms.next().is_some() || second_arm.guard().is_some() {
     if first_arm.guard().is_some() && ctx.edition() < Edition::Edition2024 {
         return None;
     }
-
     let (if_let_pat, guard, then_expr, else_expr) = pick_pattern_and_expr_order(
         &ctx.sema,
         first_arm.pat()?,
     )?;
     let scrutinee = match_expr.expr()?;
     let guard = guard.and_then(|it| it.condition());
-
     let let_ = match &if_let_pat {
         ast::Pat::LiteralPat(p)
             if p.literal()
     }
 }
 
-fn binds_name(sema: &hir::Semantics<'_, RootDatabase>, pat: &ast::Pat) -> bool {
+fn binds_name(
+    sema: &hir::Semantics<'_, RootDatabase>,
+    pat: &ast::Pat,
+) -> bool {
     let binds_name_v = |pat| binds_name(sema, &pat);
     match pat {
         ast::Pat::IdentPat(pat) => !matches!(
     }
 }
 
-fn is_sad_pat(sema: &hir::Semantics<'_, RootDatabase>, pat: &ast::Pat) -> bool {
+fn is_sad_pat(
+    sema: &hir::Semantics<'_, RootDatabase>,
+    pat: &ast::Pat,
+) -> bool {
     sema.type_of_pat(pat)
         .and_then(|ty| TryEnum::from_ty(sema, &ty.adjusted()))
         .is_some_and(|it| does_pat_match_variant(pat, &it.sad_pattern()))
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     #[test]
     fn test_if_let_with_match_inapplicable_for_simple_ifs() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn test_if_with_match_no_else() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_if_with_match_with_else() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_if_with_match_comments() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_if_let_with_match_no_else() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_if_let_with_match_available_range_left() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn test_if_let_with_match_available_range_right() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn test_if_let_with_match_let_chain() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_let_chain_no_else() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_basic() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_if_let_with_match_on_tail_if_let() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn special_case_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn special_case_inverted_option() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn special_case_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn special_case_inverted_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn nested_indent() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         )
     }
-
     #[test]
     fn test_if_let_with_match_nested_tuple_struct() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_slice() {
         check_assist(
 }
         "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_literal() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_tuple() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_or() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_range() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_paren() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_macro() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_path() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_record() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_if_let_with_match_nested_ident() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 }
 "#,
         );
-
         check_assist(
             replace_if_let_with_match,
             r#"
 "#,
         );
     }
-
     #[test]
     fn test_replace_match_with_if_let_unwraps_simple_expressions() {
         check_assist(
 }           "#,
         )
     }
-
     #[test]
     fn test_replace_match_with_if_let_doesnt_unwrap_multiline_expressions() {
         check_assist(
 }           "#,
         )
     }
-
     #[test]
     fn replace_match_with_if_let_target() {
         check_assist_target(
         }"#,
         );
     }
-
     #[test]
     fn special_case_option_match_to_if_let() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn special_case_result_match_to_if_let() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn nested_indent_match_to_if_let() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             replace_match_with_if_let,
             r#"
 "#,
         );
     }
-
     #[test]
     fn replace_match_with_if_let_empty_wildcard_expr() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_match_with_if_let_number_body() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_match_with_if_let_exhaustive() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_match_with_if_let_prefer_name_bind() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn replace_match_with_if_let_prefer_nonempty_body() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn replace_match_with_if_let_rejects_double_name_bindings() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_replace_match_with_if_let_keeps_unsafe_block() {
         check_assist(
 }           "#,
         )
     }
-
     #[test]
     fn test_replace_match_with_if_let_forces_else() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_replace_match_with_if_bool() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_replace_match_with_if_let_chain() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_replace_match_with_if_let_not_applicable_pat2_is_ident_pat() {
         check_assist_not_applicable(