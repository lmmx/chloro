COMPARISON DIFF
============================================================

Original size: 7226 bytes
Chloro size:   6770 bytes
Rustfmt size:  7244 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::next_solver::{DbInterner, TypingMode};
 use ide_db::{famous_defs::FamousDefs, RootDatabase};
 use syntax::ast::{self, AstNode, HasName};
 
 use crate::{utils::generate_trait_impl_text_intransitive, AssistContext, AssistId, Assists};
 
-// Assist: generate_from_impl_for_enum
-//
-// Adds a From impl for this enum variant with one tuple field.
-//
-// ```
-// enum A { $0One(u32) }
-// ```
-// ->
-// ```
-// enum A { One(u32) }
-//
-// impl From<u32> for A {
-//     fn from(v: u32) -> Self {
-//         Self::One(v)
-//     }
-// }
-// ```
 pub(crate) fn generate_from_impl_for_enum(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         "Generate `From` impl for this enum variant",
         target,
         |edit| {
-            let start_offset = variant.parent_enum().syntax().text_range().end();
-            let from_trait = format!("From<{field_type}>");
-            let impl_code = if let Some(name) = field_name {
+        let start_offset = variant.parent_enum().syntax().text_range().end();
+        let from_trait = format!("From<{field_type}>");
+        let impl_code = if let Some(name) = field_name {
                 format!(
                     r#"    fn from({name}: {field_type}) -> Self {{
         Self::{variant_name} {{ {name} }}
     }}"#
                 )
             };
-            let from_impl = generate_trait_impl_text_intransitive(&enum_, &from_trait, &impl_code);
-            edit.insert(start_offset, from_impl);
-        },
+        let from_impl = generate_trait_impl_text_intransitive(&enum_, &from_trait, &impl_code);
+        edit.insert(start_offset, from_impl);
+    },
     )
 }
 
     let field_ty = variant.fields(sema.db).first()?.ty(sema.db);
     let enum_ty = enum_.ty(sema.db);
     tracing::debug!(?enum_, ?field_ty, ?enum_ty);
-    enum_ty
-        .impls_trait(infcx, from_trait, &[field_ty])
-        .then_some(())
+    enum_ty.impls_trait(infcx, from_trait, &[field_ty]).then_some(())
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_generate_from_impl_for_enum() {
         check_assist(
 "#,
         );
     }
-
-    // FIXME(next-solver): it would be nice to not be *required* to resolve the
-    // path in order to properly generate assists
     #[test]
     fn test_generate_from_impl_for_enum_complicated_path() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_add_from_impl_no_element() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_add_from_impl_more_than_one_element_in_tuple() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_add_from_impl_struct_variant() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_add_from_impl_already_exists() {
         cov_mark::check!(test_add_from_impl_already_exists);
 "#,
         );
     }
-
     #[test]
     fn test_add_from_impl_different_variant_impl_exists() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_add_from_impl_static_str() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_add_from_impl_generic_enum() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_add_from_impl_with_lifetime() {
         check_assist(