COMPARISON DIFF
============================================================

Original size: 36442 bytes
Chloro size:   35545 bytes
Rustfmt size:  36442 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir::{CaptureKind, ClosureCapture, FileRangeWrapper, HirDisplay};
 use ide_db::{
-    FxHashSet, assists::AssistId, base_db::SourceDatabase, defs::Definition,
-    search::FileReferenceNode, source_change::SourceChangeBuilder,
+    assists::AssistId, base_db::SourceDatabase, defs::Definition, search::FileReferenceNode,
+    source_change::SourceChangeBuilder, FxHashSet,
 };
 use stdx::format_to;
 use syntax::{
-    AstNode, Direction, SyntaxKind, SyntaxNode, T, TextSize, ToSmolStr,
     algo::{skip_trivia_token, skip_whitespace_token},
-    ast::{
-        self, HasArgList, HasGenericParams, HasName,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
-    },
+    ast::{self, edit::{AstNodeEdit, IndentLevel}, make, HasArgList, HasGenericParams, HasName},
     hacks::parse_expr_from_str,
-    ted,
+    ted, AstNode, Direction, SyntaxKind, SyntaxNode, TextSize, ToSmolStr, T,
 };
 
 use crate::assist_context::{AssistContext, Assists};
 
-// Assist: convert_closure_to_fn
-//
-// This converts a closure to a freestanding function, changing all captures to parameters.
-//
-// ```
-// # //- minicore: copy
-// # struct String;
-// # impl String {
-// #     fn new() -> Self {}
-// #     fn push_str(&mut self, s: &str) {}
-// # }
-// fn main() {
-//     let mut s = String::new();
-//     let closure = |$0a| s.push_str(a);
-//     closure("abc");
-// }
-// ```
-// ->
-// ```
-// # struct String;
-// # impl String {
-// #     fn new() -> Self {}
-// #     fn push_str(&mut self, s: &str) {}
-// # }
-// fn main() {
-//     let mut s = String::new();
-//     fn closure(a: &str, s: &mut String) {
-//         s.push_str(a)
-//     }
-//     closure("abc", &mut s);
-// }
-// ```
 pub(crate) fn convert_closure_to_fn(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let closure = ctx.find_node_at_offset::<ast::ClosureExpr>()?;
     if ctx.find_node_at_offset::<ast::Expr>() != Some(ast::Expr::ClosureExpr(closure.clone())) {
         .collect::<FxHashSet<_>>();
 
     // A fixpoint algorithm to detect (very roughly) if we need to include a generic parameter
+
     // by checking if it is mentioned by another parameter we need to include.
     let mut reached_fixpoint = false;
     let mut container_where_bounds_indices = Vec::new();
         (!include_where_bounds.is_empty()).then(|| make::where_clause(include_where_bounds));
 
     // FIXME: Consider generic parameters that do not appear in params/return type/captures but
+
     // written explicitly inside the closure.
     (Some(make::generic_param_list(include_params)), where_clause)
 }
     expr
 }
 
-// FIXME:
-// Somehow handle the case of `let Struct { field, .. } = capture`.
-// Replacing `capture` with `capture_field` won't work.
 fn expr_of_pat(pat: ast::Pat) -> Option<ast::Expr> {
     'find_expr: {
         for ancestor in pat.syntax().ancestors() {
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn handles_unique_captures() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn multiple_capture_usages() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn changes_names_of_place() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn self_with_fields_does_not_change_to_this() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn replaces_async_closure_with_async_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn replaces_async_block_with_async_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     #[ignore = "FIXME: we do not do type inference for gen blocks yet"]
     fn replaces_gen_block_with_gen_fn() {
 "#,
         );
     }
-
     #[test]
     fn leaves_block_in_place() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn wraps_in_block_if_needed() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn closure_in_closure() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn closure_in_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn finds_pat_for_expr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn with_existing_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn with_existing_params_newlines() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn with_existing_params_trailing_comma() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn closure_using_generic_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn closure_in_stmt() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn unique_and_imm() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn only_applicable_in_param_list() {
         check_assist_not_applicable(