COMPARISON DIFF
============================================================

Original size: 75023 bytes
Chloro size:   74253 bytes
Rustfmt size:  75023 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{
     Adt, AsAssocItem, HasSource, HirDisplay, Module, PathResolution, Semantics, StructKind, Type,
     TypeInfo,
 };
 use ide_db::{
-    FileId, FxHashMap, FxHashSet, RootDatabase, SnippetCap,
     assists::ExprFillDefaultMode,
     defs::{Definition, NameRefClass},
     famous_defs::FamousDefs,
     helpers::is_editable_crate,
     path_transform::PathTransform,
     source_change::SourceChangeBuilder,
+    FileId, FxHashMap, FxHashSet, RootDatabase, SnippetCap,
 };
 use itertools::Itertools;
 use stdx::to_lower_snake_case;
 use syntax::{
-    Edition, SyntaxKind, SyntaxNode, T, TextRange,
     ast::{
-        self, AstNode, BlockExpr, CallExpr, HasArgList, HasGenericParams, HasModuleItem,
-        HasTypeBounds, edit::IndentLevel, edit_in_place::Indent, make,
+        self, edit::IndentLevel, edit_in_place::Indent, make, AstNode, BlockExpr, CallExpr,
+        HasArgList, HasGenericParams, HasModuleItem, HasTypeBounds,
     },
-    ted,
+    ted, Edition, SyntaxKind, SyntaxNode, TextRange, T,
 };
 
 use crate::{
-    AssistContext, AssistId, Assists,
     utils::{convert_reference_type, find_struct_impl},
+    AssistContext, AssistId, Assists,
 };
 
-// Assist: generate_function
-//
-// Adds a stub function with a signature matching the function under the cursor.
-//
-// ```
-// struct Baz;
-// fn baz() -> Baz { Baz }
-// fn foo() {
-//     bar$0("", baz());
-// }
-//
-// ```
-// ->
-// ```
-// struct Baz;
-// fn baz() -> Baz { Baz }
-// fn foo() {
-//     bar("", baz());
-// }
-//
-// fn bar(arg: &'static str, baz: Baz) ${0:-> _} {
-//     todo!()
-// }
-//
-// ```
 pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     gen_fn(acc, ctx).or_else(|| gen_method(acc, ctx))
 }
     }
 
     let fn_name = &*name_ref.text();
-    let TargetInfo { target_module, adt_info, target, file } =
-        fn_target_info(ctx, path, &call, fn_name)?;
+    let TargetInfo { target_module, adt_info, target, file } = fn_target_info(ctx, path, &call, fn_name)?;
 
     if let Some(m) = target_module
         && !is_editable_crate(m.krate(), ctx.db())
         return None;
     }
 
-    let function_builder =
-        FunctionBuilder::from_call(ctx, &call, fn_name, target_module, target, &adt_info)?;
+    let function_builder = FunctionBuilder::from_call(ctx, &call, fn_name, target_module, target, &adt_info)?;
     let text_range = call.syntax().text_range();
     let label = format!("Generate {} function", function_builder.fn_name);
     add_func_to_accumulator(acc, ctx, text_range, function_builder, file, adt_info, label)
     let range = adt.source(ctx.sema.db)?.syntax().original_file_range_rooted(ctx.sema.db);
 
     let file = ctx.sema.parse(range.file_id);
-    let adt_source =
-        ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;
+    let adt_source = ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;
     find_struct_impl(ctx, &adt_source, &[fn_name.to_owned()])
         .map(|impl_| (impl_, range.file_id.file_id(ctx.db())))
 }
         target: GeneratedFunctionTarget,
         adt_info: &Option<AdtInfo>,
     ) -> Option<Self> {
-        let target_module =
-            target_module.or_else(|| ctx.sema.scope(target.syntax()).map(|it| it.module()))?;
+        let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).map(|it| it.module()))?;
         let target_edition = target_module.krate().edition(ctx.db());
 
         let current_module = ctx.sema.scope(call.syntax())?.module();
         let fn_body;
 
         // If generated function has the name "new" and is an associated function, we generate fn body
+
         // as a constructor and assume a "Self" return type.
         if let Some(body) =
             make_fn_body_as_new_function(ctx, &fn_name.text(), adt_info, target_edition)
             fn_body = make::block_expr(vec![], Some(placeholder_expr));
         };
 
-        let (generic_param_list, where_clause) =
-            fn_generic_params(ctx, necessary_generic_params, &target)?;
+        let (generic_param_list, where_clause) = fn_generic_params(ctx, necessary_generic_params, &target)?;
 
         Some(Self {
             target,
         let is_async = await_expr.is_some();
 
         let expr_for_ret_ty = await_expr.map_or_else(|| call.clone().into(), |it| it.into());
-        let (ret_type, should_focus_return_type) =
-            make_return_type(ctx, &expr_for_ret_ty, target_module, &mut necessary_generic_params);
+        let (ret_type, should_focus_return_type) = make_return_type(ctx, &expr_for_ret_ty, target_module, &mut necessary_generic_params);
 
-        let (generic_param_list, where_clause) =
-            fn_generic_params(ctx, necessary_generic_params, &target)?;
+        let (generic_param_list, where_clause) = fn_generic_params(ctx, necessary_generic_params, &target)?;
 
         let placeholder_expr = match ctx.config.expr_fill_default {
             ExprFillDefaultMode::Todo => make::ext::expr_todo(),
             Visibility::Crate => Some(make::visibility_pub_crate()),
             Visibility::Pub => Some(make::visibility_pub()),
         };
-        let type_params =
-            self.generic_param_list.filter(|list| list.generic_params().next().is_some());
+        let type_params = self.generic_param_list.filter(|list| list.generic_params().next().is_some());
         let fn_def = make::fn_(
             None,
             visibility,
             false,
             false,
         )
-        .clone_for_update();
+            .clone_for_update();
 
         let ret_type = fn_def.ret_type();
         // PANIC: we guarantee we always create a function body with a tail expr
         arg_types.push(fn_arg_type(ctx, target_module, &arg, necessary_generic_params));
     }
     deduplicate_arg_names(&mut arg_names);
-    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {
+    let params = arg_names
+        .into_iter()
+        .zip(arg_types)
+        .map(|(name, ty)| {
         make::param(make::ext::simple_ident_pat(make::name(&name)).into(), make::ty(&ty))
     });
 
     filter_unnecessary_bounds(&mut generic_params, &mut where_preds, necessary_params);
     filter_bounds_in_scope(&mut generic_params, &mut where_preds, ctx, target);
 
-    let generic_params: Vec<ast::GenericParam> =
-        generic_params.into_iter().map(|it| it.node.clone_for_update()).collect();
-    let where_preds: Vec<ast::WherePred> =
-        where_preds.into_iter().map(|it| it.node.clone_for_update()).collect();
+    let generic_params: Vec<ast::GenericParam> = generic_params.into_iter().map(|it| it.node.clone_for_update()).collect();
+    let where_preds: Vec<ast::WherePred> = where_preds.into_iter().map(|it| it.node.clone_for_update()).collect();
 
-    let (generic_params, where_preds): (Vec<ast::GenericParam>, Vec<ast::WherePred>) =
-        if let Some(param) = generic_params.first()
+    let (generic_params, where_preds): (Vec<ast::GenericParam>, Vec<ast::WherePred>) = if let Some(param) = generic_params.first()
             && let source_scope = ctx.sema.scope(param.syntax())?
             && let target_scope = ctx.sema.scope(&target.parent())?
             && source_scope.module() != target_scope.module()
         };
 
     let generic_param_list = make::generic_param_list(generic_params);
-    let where_clause =
-        if where_preds.is_empty() { None } else { Some(make::where_clause(where_preds)) };
+    let where_clause = if where_preds.is_empty() { None } else { Some(make::where_clause(where_preds)) };
 
     Some((Some(generic_param_list), where_clause))
 }
     let mut where_clauses = Vec::new();
 
     // There are two items where generic parameters currently in scope may be declared: the item
+
     // the cursor is at, and its parent (if any).
+
     //
+
     // We handle parent first so that their generic parameters appear first in the generic
+
     // parameter list of the function we're generating.
     let db = ctx.db();
     if let Some(parent) = body.as_assoc_item(db).map(|it| it.container(db)) {
     }
 
     // Other defs with body may inherit generic parameters from its parent, but never have their
+
     // own generic parameters.
     if let hir::DefWithBody::Function(it) = body {
         let (params, clauses) = get_bounds_in_scope(ctx, it);
     let self_ty = node.ty()?;
     let bound_list = node.type_bound_list()?;
 
-    let self_ty_params = self_ty
-        .syntax()
-        .descendants()
-        .filter_map(|node| filter_generic_params(ctx, node))
-        .collect();
+    let self_ty_params = self_ty.syntax().descendants().filter_map(|node| filter_generic_params(ctx, node)).collect();
 
     let other_params = bound_list
         .bounds()
     necessary_params: FxHashSet<hir::GenericParam>,
 ) {
     // All `self_ty_param` should be unique as they were collected from `ast::GenericParamList`s.
-    let param_map: FxHashMap<hir::GenericParam, usize> =
-        generic_params.iter().map(|it| it.self_ty_param).zip(0..).collect();
+    let param_map: FxHashMap<hir::GenericParam, usize> = generic_params.iter().map(|it| it.self_ty_param).zip(0..).collect();
     let param_count = param_map.len();
     let generic_params_upper_bound = param_count + generic_params.len();
     let node_count = generic_params_upper_bound + where_preds.len();
 
     // | node index range                        | what the node represents |
+
     // |-----------------------------------------|--------------------------|
+
     // | 0..param_count                          | generic parameter        |
+
     // | param_count..generic_params_upper_bound | `ast::GenericParam`      |
+
     // | generic_params_upper_bound..node_count  | `ast::WherePred`         |
     let mut graph = Graph::new(node_count);
     for (pred, pred_idx) in generic_params.iter().zip(param_count..) {
     }
 
     // Now we know every element that belongs to an impl would be in scope at `target`, we can
+
     // filter them out just by looking at their parent.
     generic_params.retain(|it| !matches!(it.self_ty_param.parent(), hir::GenericDef::Impl(_)));
-    where_preds.retain(|it| {
+    where_preds
+        .retain(|it| {
         it.node.syntax().parent().and_then(|it| it.parent()).and_then(ast::Impl::cast).is_none()
     });
 
     }
 }
 
-// This is never intended to be used as a generic graph structure. If there's ever another need of
-// graph algorithm, consider adding a library for that (and replace the following).
 /// Minimally implemented directed graph structure represented by adjacency list.
 struct Graph {
     edges: Vec<Vec<usize>>,
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn add_function_with_no_args() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_from_method() {
         // This ensures that the function is correctly generated
 ",
         )
     }
-
     #[test]
     fn add_function_directly_after_current_block() {
         // The new fn should not be created at the end of the file or module
 ",
         )
     }
-
     #[test]
     fn add_function_with_no_args_in_same_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_upper_camel_case_arg() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn add_function_with_upper_camel_case_arg_as_cast() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn add_function_with_function_call_arg() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn add_function_with_method_call_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_string_literal_arg() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_function_with_char_literal_arg() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_function_with_int_literal_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_cast_int_literal_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn name_of_cast_variable_is_used() {
         // Ensures that the name of the cast type isn't used
 ",
         )
     }
-
     #[test]
     fn add_function_with_variable_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_impl_trait_arg() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn borrowed_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_qualified_path_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generate_function_with_generic_param() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generate_function_with_parent_generic_param() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generic_param_in_receiver_type() {
         // FIXME: Generic parameter `T` should be part of impl, not method.
 ",
         )
     }
-
     #[test]
     fn generic_param_in_return_type() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generate_fn_with_bounds() {
         // FIXME: where predicates should be on next lines.
 ",
         )
     }
-
     #[test]
     fn include_transitive_param_dependency() {
         // FIXME: where predicates should be on next lines.
 ",
         )
     }
-
     #[test]
     fn irrelevant_bounds_are_filtered_out() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn params_in_trait_arg_are_not_dependency() {
         // Even though `bar` depends on `U` and `I`, we don't have to copy these bounds:
 ",
         )
     }
-
     #[test]
     fn dont_copy_bounds_already_in_scope() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_fn_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_closure_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn unresolvable_types_default_to_placeholder() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn arg_names_dont_overlap() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn arg_name_counters_start_at_1_per_name() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_function_in_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn qualified_path_uses_correct_scope() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn qualified_path_in_generic_bounds_uses_correct_scope() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_in_nested_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_in_another_file() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn add_function_with_return_type() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_not_applicable_if_function_already_exists() {
         check_assist_not_applicable(
 ",
         )
     }
-
     #[test]
     fn add_function_not_applicable_if_unresolved_variable_in_call_is_selected() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn create_method_with_no_args() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn create_method_with_unused_generics() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn create_function_with_async() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn return_type_for_async_fn() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn create_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_method_within_an_impl() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_method_from_different_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_method_from_descendant_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_method_with_cursor_anywhere_on_call_expression() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_async_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_async_static_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_generic_static_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method_within_an_impl() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method_from_different_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method_with_cursor_anywhere_on_call_expression() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method_within_an_impl_with_self_syntax() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn no_panic_on_invalid_global_path() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn handle_tuple_indexing() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_const_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_static_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_static_mut_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn not_applicable_for_enum_variant() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn applicable_for_enum_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn applicable_in_different_local_crate() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn applicable_in_different_local_crate_method() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn not_applicable_in_different_library_crate() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn not_applicable_in_different_library_crate_method() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn new_function_assume_self_type() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn new_function_assume_self_type_for_tuple_struct() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn new_function_assume_self_type_for_unit_struct() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn new_function_assume_self_type_for_enum() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn new_function_assume_self_type_with_args() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn no_generate_method_by_keyword() {
         check_assist_not_applicable(