COMPARISON DIFF
============================================================

Original size: 75023 bytes
Chloro size:   74155 bytes
Rustfmt size:  75023 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use itertools::Itertools;
 use stdx::to_lower_snake_case;
 use syntax::{
-    Edition, SyntaxKind, SyntaxNode, T, TextRange,
+    Edition, SyntaxKind, SyntaxNode, TextRange,
     ast::{
         self, AstNode, BlockExpr, CallExpr, HasArgList, HasGenericParams, HasModuleItem,
         HasTypeBounds, edit::IndentLevel, edit_in_place::Indent, make,
     },
-    ted,
+    ted, T,
 };
 
 use crate::{
     utils::{convert_reference_type, find_struct_impl},
 };
 
-// Assist: generate_function
-//
-// Adds a stub function with a signature matching the function under the cursor.
-//
-// ```
-// struct Baz;
-// fn baz() -> Baz { Baz }
-// fn foo() {
-//     bar$0("", baz());
-// }
-//
-// ```
-// ->
-// ```
-// struct Baz;
-// fn baz() -> Baz { Baz }
-// fn foo() {
-//     bar("", baz());
-// }
-//
-// fn bar(arg: &'static str, baz: Baz) ${0:-> _} {
-//     todo!()
-// }
-//
-// ```
 pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     gen_fn(acc, ctx).or_else(|| gen_method(acc, ctx))
 }
                         return None;
                     }
                 }
-
                 assoc_fn_target_info(ctx, call, adt, fn_name)
             }
             Some(hir::PathResolution::SelfType(impl_)) => {
     adt_info: Option<AdtInfo>,
     label: String,
 ) -> Option<()> {
-    acc.add(AssistId::generate("generate_function"), label, text_range, |edit| {
+    acc.add(
+        AssistId::generate("generate_function"),
+        label,
+        text_range,
+        |edit| {
         edit.edit_file(file);
 
         let target = function_builder.target.clone();
         } else {
             target.insert_fn_at(edit, func);
         }
-    })
+    },
+    )
 }
 
 fn get_adt_source(
     let file = ctx.sema.parse(range.file_id);
     let adt_source =
         ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;
-    find_struct_impl(ctx, &adt_source, &[fn_name.to_owned()])
-        .map(|impl_| (impl_, range.file_id.file_id(ctx.db())))
+    find_struct_impl(ctx, &adt_source, &[fn_name.to_owned()]).map(
+        |impl_| (impl_, range.file_id.file_id(ctx.db())),
+    )
 }
 
 struct FunctionBuilder {
         let fn_body;
 
         // If generated function has the name "new" and is an associated function, we generate fn body
+
         // as a constructor and assume a "Self" return type.
         if let Some(body) =
             make_fn_body_as_new_function(ctx, &fn_name.text(), adt_info, target_edition)
                 } else {
                     ted::Position::first_child_of(&item)
                 };
-
                 let indent = IndentLevel::from_node(&item);
                 let leading_ws = make::tokens::whitespace(&format!("\n{indent}"));
                 impl_.indent(indent);
-
                 ted::insert_all(position, vec![leading_ws.into(), impl_.syntax().clone().into()]);
             }
             GeneratedFunctionTarget::InEmptyItemList(item_list) => {
                     Some(child) => ted::Position::after(child),
                     None => ted::Position::first_child_of(&item_list),
                 };
-
                 let indent = IndentLevel::from_node(&item_list);
                 let leading_indent = indent + 1;
                 let leading_ws = make::tokens::whitespace(&format!("\n{leading_indent}"));
                 impl_.indent(indent);
-
                 ted::insert_all(position, vec![leading_ws.into(), impl_.syntax().clone().into()]);
             }
             GeneratedFunctionTarget::InImpl(_) => {
                 } else {
                     ted::Position::first_child_of(&item)
                 };
-
                 let indent = IndentLevel::from_node(&item);
                 let leading_ws = make::tokens::whitespace(&format!("\n\n{indent}"));
                 func.indent(indent);
-
                 ted::insert_all_raw(
                     position,
                     vec![leading_ws.into(), func.syntax().clone().into()],
                     Some(child) => ted::Position::after(child),
                     None => ted::Position::first_child_of(&item_list),
                 };
-
                 let indent = IndentLevel::from_node(&item_list);
                 let leading_indent = indent + 1;
                 let leading_ws = make::tokens::whitespace(&format!("\n{leading_indent}"));
                 let trailing_ws = make::tokens::whitespace(&format!("\n{indent}"));
                 func.indent(leading_indent);
-
                 ted::insert_all(
                     position,
                     vec![leading_ws.into(), func.syntax().clone().into(), trailing_ws.into()],
             }
             GeneratedFunctionTarget::InImpl(impl_) => {
                 let impl_ = edit.make_mut(impl_.clone());
-
                 let leading_indent = impl_.indent_level() + 1;
                 func.indent(leading_indent);
-
                 impl_.get_or_create_assoc_item_list().add_item(func.into());
             }
         }
 
     Some(make::param_list(
         match call {
-            ast::CallableExpr::Call(_) => None,
-            ast::CallableExpr::MethodCall(_) => Some(make::self_param()),
-        },
+        ast::CallableExpr::Call(_) => None,
+        ast::CallableExpr::MethodCall(_) => Some(make::self_param()),
+    },
         params,
     ))
 }
     let mut where_clauses = Vec::new();
 
     // There are two items where generic parameters currently in scope may be declared: the item
+
     // the cursor is at, and its parent (if any).
+
     //
+
     // We handle parent first so that their generic parameters appear first in the generic
+
     // parameter list of the function we're generating.
     let db = ctx.db();
     if let Some(parent) = body.as_assoc_item(db).map(|it| it.container(db)) {
     }
 
     // Other defs with body may inherit generic parameters from its parent, but never have their
+
     // own generic parameters.
     if let hir::DefWithBody::Function(it) = body {
         let (params, clauses) = get_bounds_in_scope(ctx, it);
     match &node {
         ast::GenericParam::TypeParam(ty) => {
             let self_ty_param = ctx.sema.to_def(ty)?.into();
-
             let other_params = ty
                 .type_bound_list()
                 .into_iter()
                 .flat_map(|bound| bound.syntax().descendants())
                 .filter_map(|node| filter_generic_params(ctx, node))
                 .collect();
-
             Some(ParamBoundWithParams { node, self_ty_param, other_params })
         }
         ast::GenericParam::ConstParam(ct) => {
     let node_count = generic_params_upper_bound + where_preds.len();
 
     // | node index range                        | what the node represents |
+
     // |-----------------------------------------|--------------------------|
+
     // | 0..param_count                          | generic parameter        |
+
     // | param_count..generic_params_upper_bound | `ast::GenericParam`      |
+
     // | generic_params_upper_bound..node_count  | `ast::WherePred`         |
     let mut graph = Graph::new(node_count);
     for (pred, pred_idx) in generic_params.iter().zip(param_count..) {
     }
 
     // Now we know every element that belongs to an impl would be in scope at `target`, we can
+
     // filter them out just by looking at their parent.
     generic_params.retain(|it| !matches!(it.self_ty_param.parent(), hir::GenericDef::Impl(_)));
     where_preds.retain(|it| {
         }
     }
 
-    maybe_displayed_type(ctx, target_module, fn_arg, generic_params)
-        .unwrap_or_else(|| String::from("_"))
+    maybe_displayed_type(ctx, target_module, fn_arg, generic_params).unwrap_or_else(
+        || String::from("_"),
+    )
 }
 
 /// Returns the position inside the current mod or file
     }
 }
 
-// This is never intended to be used as a generic graph structure. If there's ever another need of
-// graph algorithm, consider adding a library for that (and replace the following).
 /// Minimally implemented directed graph structure represented by adjacency list.
 struct Graph {
     edges: Vec<Vec<usize>>,
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn add_function_with_no_args() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_from_method() {
         // This ensures that the function is correctly generated
 ",
         )
     }
-
     #[test]
     fn add_function_directly_after_current_block() {
         // The new fn should not be created at the end of the file or module
 ",
         )
     }
-
     #[test]
     fn add_function_with_no_args_in_same_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_upper_camel_case_arg() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn add_function_with_upper_camel_case_arg_as_cast() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn add_function_with_function_call_arg() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn add_function_with_method_call_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_string_literal_arg() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_function_with_char_literal_arg() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_function_with_int_literal_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_cast_int_literal_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn name_of_cast_variable_is_used() {
         // Ensures that the name of the cast type isn't used
 ",
         )
     }
-
     #[test]
     fn add_function_with_variable_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_impl_trait_arg() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn borrowed_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_qualified_path_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generate_function_with_generic_param() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generate_function_with_parent_generic_param() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generic_param_in_receiver_type() {
         // FIXME: Generic parameter `T` should be part of impl, not method.
 ",
         )
     }
-
     #[test]
     fn generic_param_in_return_type() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn generate_fn_with_bounds() {
         // FIXME: where predicates should be on next lines.
 ",
         )
     }
-
     #[test]
     fn include_transitive_param_dependency() {
         // FIXME: where predicates should be on next lines.
 ",
         )
     }
-
     #[test]
     fn irrelevant_bounds_are_filtered_out() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn params_in_trait_arg_are_not_dependency() {
         // Even though `bar` depends on `U` and `I`, we don't have to copy these bounds:
 ",
         )
     }
-
     #[test]
     fn dont_copy_bounds_already_in_scope() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_fn_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_closure_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn unresolvable_types_default_to_placeholder() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn arg_names_dont_overlap() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn arg_name_counters_start_at_1_per_name() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_function_in_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn qualified_path_uses_correct_scope() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn qualified_path_in_generic_bounds_uses_correct_scope() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_in_nested_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_in_another_file() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn add_function_with_return_type() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_not_applicable_if_function_already_exists() {
-        check_assist_not_applicable(
-            generate_function,
-            r"
+        check_assist_not_applicable(generate_function, r"
 fn foo() {
     bar$0();
 }
 
 fn bar() {}
-",
-        )
+")
     }
-
     #[test]
     fn add_function_not_applicable_if_unresolved_variable_in_call_is_selected() {
         check_assist_not_applicable(
-            // bar is resolved, but baz isn't.
-            // The assist is only active if the cursor is on an unresolved path,
-            // but the assist should only be offered if the path is a function call.
             generate_function,
             r#"
 fn foo() {
 "#,
         )
     }
-
     #[test]
     fn create_method_with_no_args() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn create_method_with_unused_generics() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn create_function_with_async() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn return_type_for_async_fn() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn create_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_method_within_an_impl() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_method_from_different_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_method_from_descendant_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_method_with_cursor_anywhere_on_call_expression() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_async_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_async_static_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_generic_static_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method_within_an_impl() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method_from_different_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method_with_cursor_anywhere_on_call_expression() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn create_static_method_within_an_impl_with_self_syntax() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn no_panic_on_invalid_global_path() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn handle_tuple_indexing() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_const_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_static_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn add_function_with_static_mut_arg() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn not_applicable_for_enum_variant() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn applicable_for_enum_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn applicable_in_different_local_crate() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn applicable_in_different_local_crate_method() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn not_applicable_in_different_library_crate() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn not_applicable_in_different_library_crate_method() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn new_function_assume_self_type() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn new_function_assume_self_type_for_tuple_struct() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn new_function_assume_self_type_for_unit_struct() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn new_function_assume_self_type_for_enum() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn new_function_assume_self_type_with_args() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn no_generate_method_by_keyword() {
         check_assist_not_applicable(