COMPARISON DIFF
============================================================

Original size: 11998 bytes
Chloro size:   11991 bytes
Rustfmt size:  12025 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::HirDisplay;
-use syntax::{ast, match_ast, AstNode, SyntaxKind, SyntaxToken, TextRange, TextSize};
+use syntax::{AstNode, SyntaxKind, SyntaxToken, TextRange, TextSize, ast, match_ast};
 
 use crate::{AssistContext, AssistId, Assists};
 
 pub(crate) fn add_return_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let (fn_type, tail_expr, builder_edit_pos) = extract_tail(ctx)?;
     let module = ctx.sema.scope(tail_expr.syntax())?.module();
-    let ty = ctx
-        .sema
-        .type_of_expr(&peel_blocks(tail_expr.clone()))?
-        .adjusted();
+    let ty = ctx.sema.type_of_expr(&peel_blocks(tail_expr.clone()))?.adjusted();
     if ty.is_unit() {
         return None;
     }
 
 enum FnType {
     Function,
-    Closure { wrap_expr: bool },
+    Closure {
+        wrap_expr: bool,
+    },
 }
 
 /// If we're looking at a block that is supposed to return `()`, type inference
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn infer_return_type_specified_inferred() {
         cov_mark::check!(existing_infer_ret_type);
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_specified_inferred_closure() {
         cov_mark::check!(existing_infer_ret_type_closure);
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_cursor_at_return_type_pos() {
         cov_mark::check!(cursor_in_ret_position);
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_cursor_at_return_type_pos_closure() {
         cov_mark::check!(cursor_in_ret_position_closure);
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type() {
         cov_mark::check!(cursor_on_tail);
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_no_whitespace() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_nested() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_nested_match() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn not_applicable_ret_type_specified() {
         cov_mark::check!(existing_ret_type);
 }"#,
         );
     }
-
     #[test]
     fn not_applicable_non_tail_expr() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn not_applicable_unit_return_type() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_closure_block() {
         cov_mark::check!(cursor_on_tail_closure);
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_closure() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_closure_no_whitespace() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_closure_wrap() {
         cov_mark::check!(wrap_closure_non_block_expr);
 }"#,
         );
     }
-
     #[test]
     fn infer_return_type_nested_closure() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn infer_coerced_return_type_closure() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn not_applicable_ret_type_specified_closure() {
         cov_mark::check!(existing_ret_type_closure);
 }"#,
         );
     }
-
     #[test]
     fn not_applicable_non_tail_expr_closure() {
         check_assist_not_applicable(