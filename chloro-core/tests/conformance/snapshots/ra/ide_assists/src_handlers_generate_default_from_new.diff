COMPARISON DIFF
============================================================

Original size: 13010 bytes
Chloro size:   12429 bytes
Rustfmt size:  13024 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::famous_defs::FamousDefs;
 use stdx::format_to;
 use syntax::{
-    ast::{self, make, HasGenericParams, HasName, HasTypeBounds, Impl},
+    ast::{self, HasGenericParams, HasName, HasTypeBounds, Impl, make},
     AstNode,
 };
 
 use crate::{
-    assist_context::{AssistContext, Assists},
     AssistId,
+    assist_context::{AssistContext, Assists},
 };
 
-// Assist: generate_default_from_new
-//
-// Generates default implementation from new method.
-//
-// ```
-// # //- minicore: default
-// struct Example { _inner: () }
-//
-// impl Example {
-//     pub fn n$0ew() -> Self {
-//         Self { _inner: () }
-//     }
-// }
-// ```
-// ->
-// ```
-// struct Example { _inner: () }
-//
-// impl Example {
-//     pub fn new() -> Self {
-//         Self { _inner: () }
-//     }
-// }
-//
-// impl Default for Example {
-//     fn default() -> Self {
-//         Self::new()
-//     }
-// }
-// ```
-pub(crate) fn generate_default_from_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn generate_default_from_new(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let fn_node = ctx.find_node_at_offset::<ast::Fn>()?;
     let fn_name = fn_node.name()?;
-
     if fn_name.text() != "new" {
         cov_mark::hit!(other_function_than_new);
         return None;
     }
-
     if fn_node.param_list()?.params().next().is_some() {
         cov_mark::hit!(new_function_with_parameters);
         return None;
     }
-
     let impl_ = fn_node.syntax().ancestors().find_map(ast::Impl::cast)?;
     let self_ty = impl_.self_ty()?;
     if is_default_implemented(ctx, &impl_) {
         cov_mark::hit!(struct_in_module_with_default);
         return None;
     }
-
     let insert_location = impl_.syntax().text_range();
-
     acc.add(
         AssistId::generate("generate_default_from_new"),
         "Generate a Default impl from a new fn",
     )
 }
 
-// FIXME: based on from utils::generate_impl_text_inner
 fn generate_trait_impl_text_from_impl(
     impl_: &ast::Impl,
     self_ty: ast::Type,
     code: &str,
 ) -> String {
     let generic_params = impl_.generic_param_list().map(|generic_params| {
-        let lifetime_params = generic_params
-            .lifetime_params()
-            .map(ast::GenericParam::LifetimeParam);
+        let lifetime_params =
+            generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);
         let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {
             // remove defaults since they can't be specified in impls
             let param = match param {
 
         make::generic_param_list(itertools::chain(lifetime_params, ty_or_const_params))
     });
-
     let mut buf = String::with_capacity(code.len());
     buf.push_str("\n\n");
-
     // `impl{generic_params} {trait_text} for {impl_.self_ty()}`
     buf.push_str("impl");
     if let Some(generic_params) = &generic_params {
         format_to!(buf, "{generic_params}")
     }
     format_to!(buf, " {trait_text} for {self_ty}");
-
     match impl_.where_clause() {
         Some(where_clause) => {
             format_to!(buf, "\n{where_clause}\n{{\n{code}\n}}");
             format_to!(buf, " {{\n{code}\n}}");
         }
     }
-
     buf
 }
 
-fn is_default_implemented(ctx: &AssistContext<'_>, impl_: &Impl) -> bool {
+fn is_default_implemented(
+    ctx: &AssistContext<'_>,
+    impl_: &Impl,
+) -> bool {
     let db = ctx.sema.db;
     let impl_ = ctx.sema.to_def(impl_);
     let impl_def = match impl_ {
         Some(value) => value,
         None => return false,
     };
-
     let ty = impl_def.self_ty(db);
     let krate = impl_def.module(db).krate();
     let default = FamousDefs(&ctx.sema, krate).core_default_Default();
         // to impl `Default` when it's missing.
         None => return true,
     };
-
     ty.impls_trait(db, default_trait, &[])
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn generate_default() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generate_default2() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn new_function_with_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn new_function_with_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn new_function_with_generic_and_bound() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn new_function_with_generics_and_bounds() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn new_function_with_generic_and_where() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn new_function_with_generics_and_where() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn new_function_with_parameters() {
         cov_mark::check!(new_function_with_parameters);
 "#,
         );
     }
-
     #[test]
     fn other_function_than_new() {
         cov_mark::check!(other_function_than_new);
 "#,
         );
     }
-
     #[test]
     fn default_block_is_already_present() {
         cov_mark::check!(default_block_is_already_present);
 "#,
         );
     }
-
     #[test]
     fn standalone_new_function() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn multiple_struct_blocks() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn when_struct_is_after_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_in_module() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_in_module_with_default() {
         cov_mark::check!(struct_in_module_with_default);
 "#,
         );
     }
-
     #[test]
     fn not_applicable_when_default_lang_item_is_missing() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_for_missing_self_ty() {
         // Regression test for #15398.