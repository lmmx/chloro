COMPARISON DIFF
============================================================

Original size: 23406 bytes
Chloro size:   22002 bytes
Rustfmt size:  23406 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 };
 use stdx::never;
 use syntax::{
+    ast::{self, make, Use, UseTree, VisibilityKind},
     AstNode, Direction, SyntaxNode, SyntaxToken, T,
-    ast::{self, Use, UseTree, VisibilityKind, make},
 };
 
 use crate::{
-    AssistId,
     assist_context::{AssistContext, Assists},
+    AssistId,
 };
 
-// Assist: expand_glob_import
-//
-// Expands glob imports.
-//
-// ```
-// mod foo {
-//     pub struct Bar;
-//     pub struct Baz;
-// }
-//
-// use foo::*$0;
-//
-// fn qux(bar: Bar, baz: Baz) {}
-// ```
-// ->
-// ```
-// mod foo {
-//     pub struct Bar;
-//     pub struct Baz;
-// }
-//
-// use foo::{Bar, Baz};
-//
-// fn qux(bar: Bar, baz: Baz) {}
-// ```
 pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let star = ctx.find_token_syntax_at_offset(T![*])?;
     let use_tree = star.parent().and_then(ast::UseTree::cast)?;
         "Expand glob import",
         target.text_range(),
         |builder| {
-            build_expanded_import(
-                ctx,
-                builder,
-                use_tree,
-                use_item,
-                target_module,
-                current_module,
-                false,
-            )
-        },
+        build_expanded_import(
+            ctx,
+            builder,
+            use_tree,
+            use_item,
+            target_module,
+            current_module,
+            false,
+        )
+    },
     )
 }
 
-// Assist: expand_glob_reexport
-//
-// Expands non-private glob imports.
-//
-// ```
-// mod foo {
-//     pub struct Bar;
-//     pub struct Baz;
-// }
-//
-// pub use foo::*$0;
-// ```
-// ->
-// ```
-// mod foo {
-//     pub struct Bar;
-//     pub struct Baz;
-// }
-//
-// pub use foo::{Bar, Baz};
-// ```
 pub(crate) fn expand_glob_reexport(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let star = ctx.find_token_syntax_at_offset(T![*])?;
     let use_tree = star.parent().and_then(ast::UseTree::cast)?;
         "Expand glob reexport",
         target.text_range(),
         |builder| {
-            build_expanded_import(
-                ctx,
-                builder,
-                use_tree,
-                use_item,
-                target_module,
-                current_module,
-                true,
-            )
-        },
+        build_expanded_import(ctx, builder, use_tree, use_item, target_module, current_module, true)
+    },
     )
 }
 
             VisibilityKind::PubCrate => VisibilityKind::PubCrate,
             VisibilityKind::Pub => VisibilityKind::Pub,
             VisibilityKind::PubSelf => VisibilityKind::PubSelf,
-            // We don't handle pub(in ...) and pub(super) yet
             VisibilityKind::In(_) => VisibilityKind::PubSelf,
             VisibilityKind::PubSuper => VisibilityKind::PubSelf,
         },
 
 impl Refs {
     fn used_refs(&self, ctx: &AssistContext<'_>) -> Refs {
-        Refs(
-            self.0
-                .clone()
-                .into_iter()
-                .filter(|r| {
-                    if let Definition::Trait(tr) = r.def
+        Refs(self.0.clone().into_iter().filter(|r| {
+            if let Definition::Trait(tr) = r.def
                         && tr.items(ctx.db()).into_iter().any(|ai| {
                             if let AssocItem::Function(f) = ai {
                                 def_is_referenced_in(Definition::Function(f), ctx)
                     {
                         return true;
                     }
-
-                    def_is_referenced_in(r.def, ctx)
-                })
-                .collect(),
-        )
+            def_is_referenced_in(r.def, ctx)
+        }).collect(
+        ))
     }
 
     fn filter_out_by_defs(&self, defs: Vec<Definition>) -> Refs {
                 .filter(|r| !must_be_pub || r.is_pub)
                 .collect();
             Refs(refs)
-        }
-        Expandable::Enum(enm) => Refs(
-            enm.variants(ctx.db())
-                .into_iter()
-                .map(|v| Ref {
-                    visible_name: v.name(ctx.db()),
-                    def: Definition::Variant(v),
-                    is_pub: true,
-                })
-                .collect(),
-        ),
+        },
+        Expandable::Enum(enm) => Refs(enm.variants(ctx.db()).into_iter().map(|v| Ref {
+            visible_name: v.name(ctx.db()),
+            def: Definition::Variant(v),
+            is_pub: true,
+        }).collect(
+        )),
     }
 }
 
     match expandable {
         Expandable::Module(module) => match module.parent(ctx.db()) {
             Some(parent) => {
-                module.visibility(ctx.db()).is_visible_from(ctx.db(), from.into())
-                    && is_mod_visible_from(ctx, parent, from)
-            }
+                module.visibility(ctx.db()).is_visible_from(ctx.db(), from.into()) && is_mod_visible_from(ctx, parent, from)
+            },
             None => true,
         },
         Expandable::Enum(enm) => {
             let module = enm.module(ctx.db());
-            enm.visibility(ctx.db()).is_visible_from(ctx.db(), from.into())
-                && is_mod_visible_from(ctx, module, from)
-        }
+            enm.visibility(ctx.db()).is_visible_from(ctx.db(), from.into()) && is_mod_visible_from(ctx, module, from)
+        },
     }
 }
 
-// looks for name refs in parent use block's siblings
-//
-// mod bar {
-//     mod qux {
-//         struct Qux;
-//     }
-//
-//     pub use qux::Qux;
-// }
-//
-// ↓ ---------------
-// use foo::*$0;
-// use baz::Baz;
-// ↑ ---------------
 fn find_imported_defs(ctx: &AssistContext<'_>, use_item: Use) -> Vec<Definition> {
-    [Direction::Prev, Direction::Next]
-        .into_iter()
-        .flat_map(|dir| {
-            use_item.syntax().siblings(dir.to_owned()).filter(|n| ast::Use::can_cast(n.kind()))
-        })
-        .flat_map(|n| n.descendants().filter_map(ast::NameRef::cast))
-        .filter_map(|r| match NameRefClass::classify(&ctx.sema, &r)? {
-            NameRefClass::Definition(
+    [Direction::Prev, Direction::Next].into_iter().flat_map(|dir| {
+        use_item.syntax().siblings(dir.to_owned()).filter(|n| ast::Use::can_cast(n.kind()))
+    }).flat_map(
+        |n| n.descendants().filter_map(ast::NameRef::cast),
+    ).filter_map(|r| match NameRefClass::classify(&ctx.sema, &r)? {
+        NameRefClass::Definition(
                 def @ (Definition::Macro(_)
                 | Definition::Module(_)
                 | Definition::Function(_)
                 | Definition::TypeAlias(_)),
                 _,
             ) => Some(def),
-            _ => None,
-        })
-        .collect()
+        _ => None,
+    }).collect(
+    )
 }
 
 fn find_names_to_import(refs_in_target: Refs, imported_defs: Vec<Definition>) -> Vec<Name> {
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn expanding_glob_import() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_glob_import_unused() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_glob_import_with_existing_explicit_names() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_glob_import_with_existing_uses_in_same_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_nested_glob_import() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn expanding_glob_import_with_macro_defs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn expanding_glob_import_with_trait_method_uses() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn expanding_is_not_applicable_if_target_module_is_not_accessible_from_current_scope() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn expanding_is_not_applicable_if_cursor_is_not_in_star_token() {
         check_assist_not_applicable(
     ",
         )
     }
-
     #[test]
     fn expanding_glob_import_single_nested_glob_only() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn test_support_for_enums() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn test_expanding_multiple_variants_at_once() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn expanding_glob_reexport() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_recursive_glob_reexport() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_reexport_is_not_applicable_for_private_import() {
         check_assist_not_applicable(