COMPARISON DIFF
============================================================

Original size: 23406 bytes
Chloro size:   22525 bytes
Rustfmt size:  23406 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 };
 use stdx::never;
 use syntax::{
-    AstNode, Direction, SyntaxNode, SyntaxToken, T,
+    AstNode, Direction, SyntaxNode, SyntaxToken,
     ast::{self, Use, UseTree, VisibilityKind, make},
+    T,
 };
 
 use crate::{
     assist_context::{AssistContext, Assists},
 };
 
-// Assist: expand_glob_import
-//
-// Expands glob imports.
-//
-// ```
-// mod foo {
-//     pub struct Bar;
-//     pub struct Baz;
-// }
-//
-// use foo::*$0;
-//
-// fn qux(bar: Bar, baz: Baz) {}
-// ```
-// ->
-// ```
-// mod foo {
-//     pub struct Bar;
-//     pub struct Baz;
-// }
-//
-// use foo::{Bar, Baz};
-//
-// fn qux(bar: Bar, baz: Baz) {}
-// ```
 pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let star = ctx.find_token_syntax_at_offset(T![*])?;
     let use_tree = star.parent().and_then(ast::UseTree::cast)?;
     )
 }
 
-// Assist: expand_glob_reexport
-//
-// Expands non-private glob imports.
-//
-// ```
-// mod foo {
-//     pub struct Bar;
-//     pub struct Baz;
-// }
-//
-// pub use foo::*$0;
-// ```
-// ->
-// ```
-// mod foo {
-//     pub struct Bar;
-//     pub struct Baz;
-// }
-//
-// pub use foo::{Bar, Baz};
-// ```
 pub(crate) fn expand_glob_reexport(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let star = ctx.find_token_syntax_at_offset(T![*])?;
     let use_tree = star.parent().and_then(ast::UseTree::cast)?;
     }
 }
 
-// looks for name refs in parent use block's siblings
-//
-// mod bar {
-//     mod qux {
-//         struct Qux;
-//     }
-//
-//     pub use qux::Qux;
-// }
-//
-// ↓ ---------------
-// use foo::*$0;
-// use baz::Baz;
-// ↑ ---------------
 fn find_imported_defs(ctx: &AssistContext<'_>, use_item: Use) -> Vec<Definition> {
     [Direction::Prev, Direction::Next]
         .into_iter()
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn expanding_glob_import() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_glob_import_unused() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_glob_import_with_existing_explicit_names() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_glob_import_with_existing_uses_in_same_module() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_nested_glob_import() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn expanding_glob_import_with_macro_defs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn expanding_glob_import_with_trait_method_uses() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn expanding_is_not_applicable_if_target_module_is_not_accessible_from_current_scope() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn expanding_is_not_applicable_if_cursor_is_not_in_star_token() {
         check_assist_not_applicable(
     ",
         )
     }
-
     #[test]
     fn expanding_glob_import_single_nested_glob_only() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn test_support_for_enums() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn test_expanding_multiple_variants_at_once() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn expanding_glob_reexport() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_recursive_glob_reexport() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn expanding_reexport_is_not_applicable_for_private_import() {
         check_assist_not_applicable(