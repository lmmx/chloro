COMPARISON DIFF
============================================================

Original size: 8011 bytes
Chloro size:   7022 bytes
Rustfmt size:  8033 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     AssistContext, AssistId, Assists,
 };
 
-// Assist: generate_enum_try_into_method
-//
-// Generate a `try_into_` method for this enum variant.
-//
-// ```
-// enum Value {
-//  Number(i32),
-//  Text(String)$0,
-// }
-// ```
-// ->
-// ```
-// enum Value {
-//  Number(i32),
-//  Text(String),
-// }
-//
-// impl Value {
-//     fn try_into_text(self) -> Result<String, Self> {
-//         if let Self::Text(v) = self {
-//             Ok(v)
-//         } else {
-//             Err(self)
-//         }
-//     }
-// }
-// ```
 pub(crate) fn generate_enum_try_into_method(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         "generate_enum_try_into_method",
         "Generate a `try_into_` method for this enum variant",
         ProjectionProps {
-            fn_name_prefix: "try_into",
-            self_param: "self",
-            return_prefix: "Result<",
-            return_suffix: ", Self>",
-            happy_case: "Ok",
-            sad_case: "Err(self)",
-        },
+        fn_name_prefix: "try_into",
+        self_param: "self",
+        return_prefix: "Result<",
+        return_suffix: ", Self>",
+        happy_case: "Ok",
+        sad_case: "Err(self)",
+    },
     )
 }
 
-// Assist: generate_enum_as_method
-//
-// Generate an `as_` method for this enum variant.
-//
-// ```
-// enum Value {
-//  Number(i32),
-//  Text(String)$0,
-// }
-// ```
-// ->
-// ```
-// enum Value {
-//  Number(i32),
-//  Text(String),
-// }
-//
-// impl Value {
-//     fn as_text(&self) -> Option<&String> {
-//         if let Self::Text(v) = self {
-//             Some(v)
-//         } else {
-//             None
-//         }
-//     }
-// }
-// ```
 pub(crate) fn generate_enum_as_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     generate_enum_projection_method(
         acc,
         "generate_enum_as_method",
         "Generate an `as_` method for this enum variant",
         ProjectionProps {
-            fn_name_prefix: "as",
-            self_param: "&self",
-            return_prefix: "Option<&",
-            return_suffix: ">",
-            happy_case: "Some",
-            sad_case: "None",
-        },
+        fn_name_prefix: "as",
+        self_param: "&self",
+        return_prefix: "Option<&",
+        return_suffix: ">",
+        happy_case: "Some",
+        sad_case: "None",
+    },
     )
 }
 
         ast::StructKind::Unit => return None,
     };
 
-    let fn_name = format!(
-        "{fn_name_prefix}_{}",
-        &to_lower_snake_case(&variant_name.text())
-    );
+    let fn_name = format!("{fn_name_prefix}_{}", &to_lower_snake_case(&variant_name.text()));
 
     // Return early if we've found an existing new fn
     let impl_def = find_struct_impl(ctx, &parent_enum, slice::from_ref(&fn_name))?;
         assist_description,
         target,
         |builder| {
-            let vis = parent_enum.visibility().map_or(String::new(), |v| format!("{v} "));
-
-            let field_type_syntax = field_type.syntax();
-
-            let must_use = if ctx.config.assist_emit_must_use {
+        let vis = parent_enum.visibility().map_or(String::new(), |v| format!("{v} "));
+        let field_type_syntax = field_type.syntax();
+        let must_use = if ctx.config.assist_emit_must_use {
                 "#[must_use]\n    "
             } else {
                 ""
             };
-
-            let method = format!(
+        let method = format!(
                 "    {must_use}{vis}fn {fn_name}({self_param}) -> {return_prefix}{field_type_syntax}{return_suffix} {{
         if let Self::{variant_name}{pattern_suffix} = self {{
             {happy_case}({bound_name})
         }}
     }}"
             );
-
-            add_method_to_adt(builder, &parent_enum, impl_def, &method);
-        },
+        add_method_to_adt(builder, &parent_enum, impl_def, &method);
+    },
     )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_generate_enum_try_into_tuple_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_try_into_already_implemented() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_try_into_unit_variant() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_try_into_record_with_multiple_fields() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_try_into_tuple_with_multiple_fields() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_try_into_record_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_as_tuple_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_as_record_variant() {
         check_assist(