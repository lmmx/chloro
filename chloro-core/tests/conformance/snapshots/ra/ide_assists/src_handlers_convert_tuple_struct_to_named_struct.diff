COMPARISON DIFF
============================================================

Original size: 26763 bytes
Chloro size:   26011 bytes
Rustfmt size:  26763 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
+use std::ops::RangeInclusive;
+
 use either::Either;
 use hir::FileRangeWrapper;
 use ide_db::defs::{Definition, NameRefClass};
-use std::ops::RangeInclusive;
 use syntax::{
-    SyntaxElement, SyntaxKind, SyntaxNode, T, TextSize,
-    ast::{
-        self, AstNode, HasAttrs, HasGenericParams, HasVisibility, syntax_factory::SyntaxFactory,
-    },
+    ast::{self, syntax_factory::SyntaxFactory, AstNode, HasAttrs, HasGenericParams, HasVisibility},
     match_ast,
     syntax_editor::{Element, Position, SyntaxEditor},
+    SyntaxElement, SyntaxKind, SyntaxNode, TextSize, T,
 };
 
-use crate::{AssistContext, AssistId, Assists, assist_context::SourceChangeBuilder};
+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, Assists};
 
-// Assist: convert_tuple_struct_to_named_struct
-//
-// Converts tuple struct to struct with named fields, and analogously for tuple enum variants.
-//
-// ```
-// struct Point$0(f32, f32);
-//
-// impl Point {
-//     pub fn new(x: f32, y: f32) -> Self {
-//         Point(x, y)
-//     }
-//
-//     pub fn x(&self) -> f32 {
-//         self.0
-//     }
-//
-//     pub fn y(&self) -> f32 {
-//         self.1
-//     }
-// }
-// ```
-// ->
-// ```
-// struct Point { field1: f32, field2: f32 }
-//
-// impl Point {
-//     pub fn new(x: f32, y: f32) -> Self {
-//         Point { field1: x, field2: y }
-//     }
-//
-//     pub fn x(&self) -> f32 {
-//         self.field1
-//     }
-//
-//     pub fn y(&self) -> f32 {
-//         self.field2
-//     }
-// }
-// ```
 pub(crate) fn convert_tuple_struct_to_named_struct(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     tuple_fields: ast::TupleFieldList,
     names: Vec<ast::Name>,
 ) {
-    let record_fields = tuple_fields.fields().zip(names).filter_map(|(f, name)| {
+    let record_fields = tuple_fields
+        .fields()
+        .zip(names)
+        .filter_map(|(f, name)| {
         let field = ast::make::record_field(f.visibility(), name, f.ty()?);
         let mut field_editor = SyntaxEditor::new(field.syntax().clone());
         field_editor.insert_all(
     let pure_fields = pat.fields().filter(|p| !matches!(p, ast::Pat::RestPat(_)));
     let rest_len = names.len().saturating_sub(pure_fields.clone().count());
     let rest_pat = pat.fields().find_map(|p| ast::RestPat::cast(p.syntax().clone()));
-    let rest_idx =
-        pat.fields().position(|p| ast::RestPat::can_cast(p.syntax().kind())).unwrap_or(names.len());
+    let rest_idx = pat.fields().position(|p| ast::RestPat::can_cast(p.syntax().kind())).unwrap_or(names.len());
     let before_rest = pat.fields().zip(names).take(rest_idx);
     let after_rest = pure_fields.zip(names.iter().skip(rest_len)).skip(rest_idx);
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn not_applicable_other_than_tuple_struct() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn convert_simple_struct() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_and_rest_pat() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_simple_struct_cursor_on_struct_keyword() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_simple_struct_cursor_on_visibility_keyword() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_referenced_via_self_kw() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_destructured_struct() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_visibility() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_wrapped_references() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_multi_file_references() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_struct_with_where_clause() {
         check_assist(
             r#"enum Enum { Variant$0 }"#,
         );
     }
-
     #[test]
     fn convert_variant_in_macro_args() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_simple_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_referenced_via_self_kw() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_destructured_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_with_wrapped_references() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_with_multi_file_references() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_directly_used_variant() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn where_clause_with_trailing_comma() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn fields_with_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_in_macro_pattern_args() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_in_multi_file_macro_pattern_args() {
         check_assist(