COMPARISON DIFF
============================================================

Original size: 26763 bytes
Chloro size:   26725 bytes
Rustfmt size:  26943 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir::FileRangeWrapper;
 use ide_db::defs::{Definition, NameRefClass};
 use std::ops::RangeInclusive;
 use syntax::{
     SyntaxElement, SyntaxKind, SyntaxNode, T, TextSize,
-    ast::{
-        self, AstNode, HasAttrs, HasGenericParams, HasVisibility, syntax_factory::SyntaxFactory,
-    },
+    ast::{self, AstNode, HasAttrs, HasGenericParams, HasVisibility, syntax_factory::SyntaxFactory},
     match_ast,
     syntax_editor::{Element, Position, SyntaxEditor},
 };
         .find_node_at_offset::<ast::Struct>()
         .map(Either::Left)
         .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;
-    let field_list = strukt_or_variant
-        .as_ref()
-        .either(|s| s.field_list(), |v| v.field_list())?;
+    let field_list = strukt_or_variant.as_ref().either(|s| s.field_list(), |v| v.field_list())?;
 
     if ctx.offset() > field_list.syntax().text_range().start() {
         // Assist could be distracting after the braces
         Either::Left(s) => Either::Left(ctx.sema.to_def(s)?),
         Either::Right(v) => Either::Right(ctx.sema.to_def(v)?),
     };
-    let target = strukt_or_variant
-        .as_ref()
-        .either(|s| s.syntax(), |v| v.syntax())
-        .text_range();
-    let syntax = strukt_or_variant
-        .as_ref()
-        .either(|s| s.syntax(), |v| v.syntax());
+    let target = strukt_or_variant.as_ref().either(|s| s.syntax(), |v| v.syntax()).text_range();
+    let syntax = strukt_or_variant.as_ref().either(|s| s.syntax(), |v| v.syntax());
     acc.add(
         AssistId::refactor_rewrite("convert_tuple_struct_to_named_struct"),
         "Convert to named struct",
         let mut field_editor = SyntaxEditor::new(field.syntax().clone());
         field_editor.insert_all(
             Position::first_child_of(field.syntax()),
-            f.attrs()
-                .map(|attr| attr.syntax().clone_subtree().clone_for_update().into())
-                .collect(),
+            f.attrs().map(|attr| attr.syntax().clone_subtree().clone_for_update().into()).collect(),
         );
         ast::RecordField::cast(field_editor.finish().new_root().clone())
     });
             let mut insert_element = Vec::new();
             insert_element.push(ast::make::tokens::single_newline().syntax_element());
             insert_element.push(w.syntax().clone_for_update().syntax_element());
-            if w.syntax()
-                .last_token()
-                .is_none_or(|t| t.kind() != SyntaxKind::COMMA)
-            {
+            if w.syntax().last_token().is_none_or(|t| t.kind() != SyntaxKind::COMMA) {
                 insert_element.push(ast::make::token(T![,]).into());
             }
             insert_element.push(ast::make::tokens::single_newline().syntax_element());
 ) -> ast::RecordPatFieldList {
     let pure_fields = pat.fields().filter(|p| !matches!(p, ast::Pat::RestPat(_)));
     let rest_len = names.len().saturating_sub(pure_fields.clone().count());
-    let rest_pat = pat
-        .fields()
-        .find_map(|p| ast::RestPat::cast(p.syntax().clone()));
-    let rest_idx = pat
-        .fields()
-        .position(|p| ast::RestPat::can_cast(p.syntax().kind()))
-        .unwrap_or(names.len());
+    let rest_pat = pat.fields().find_map(|p| ast::RestPat::cast(p.syntax().clone()));
+    let rest_idx =
+        pat.fields().position(|p| ast::RestPat::can_cast(p.syntax().kind())).unwrap_or(names.len());
     let before_rest = pat.fields().zip(names).take(rest_idx);
     let after_rest = pure_fields.zip(names.iter().skip(rest_len)).skip(rest_idx);
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn not_applicable_other_than_tuple_struct() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn convert_simple_struct() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_and_rest_pat() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_simple_struct_cursor_on_struct_keyword() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_simple_struct_cursor_on_visibility_keyword() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_referenced_via_self_kw() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_destructured_struct() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_visibility() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_wrapped_references() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_multi_file_references() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_struct_with_where_clause() {
         check_assist(
             r#"enum Enum { Variant$0 }"#,
         );
     }
-
     #[test]
     fn convert_variant_in_macro_args() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_simple_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_referenced_via_self_kw() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_destructured_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_with_wrapped_references() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_with_multi_file_references() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_directly_used_variant() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn where_clause_with_trailing_comma() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn fields_with_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_in_macro_pattern_args() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_in_multi_file_macro_pattern_args() {
         check_assist(