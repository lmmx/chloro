COMPARISON DIFF
============================================================

Original size: 10705 bytes
Chloro size:   10341 bytes
Rustfmt size:  10723 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use hir::{db::HirDatabase, AsAssocItem, AssocItem, AssocItemContainer, ItemInNs, ModuleDef};
+use hir::{AsAssocItem, AssocItem, AssocItemContainer, ItemInNs, ModuleDef, db::HirDatabase};
 use ide_db::assists::AssistId;
-use syntax::{ast, AstNode};
+use syntax::{AstNode, ast};
 
 use crate::{
-    assist_context::{AssistContext, Assists},
-    handlers::qualify_path::QualifyCandidate,
+    assist_context::{AssistContext, Assists}, handlers::qualify_path::QualifyCandidate,
 };
 
-// Assist: qualify_method_call
-//
-// Replaces the method call with a qualified function call.
-//
-// ```
-// struct Foo;
-// impl Foo {
-//     fn foo(&self) {}
-// }
-// fn main() {
-//     let foo = Foo;
-//     foo.fo$0o();
-// }
-// ```
-// ->
-// ```
-// struct Foo;
-// impl Foo {
-//     fn foo(&self) {}
-// }
-// fn main() {
-//     let foo = Foo;
-//     Foo::foo(&foo);
-// }
-// ```
-pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn qualify_method_call(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let name: ast::NameRef = ctx.find_node_at_offset()?;
     let call = name.syntax().parent().and_then(ast::MethodCallExpr::cast)?;
-
     let ident = name.ident_token()?;
-
     let range = call.syntax().text_range();
     let resolved_call = ctx.sema.resolve_method_call(&call)?;
-
     let current_module = ctx.sema.scope(call.syntax())?.module();
     let current_edition = current_module.krate().edition(ctx.db());
     let target_module_def = ModuleDef::from(resolved_call);
     let item_in_ns = ItemInNs::from(target_module_def);
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(current_module.krate()));
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(current_module.krate()));
     let receiver_path = current_module.find_path(
         ctx.sema.db,
         item_for_path_search(ctx.sema.db, item_in_ns)?,
         cfg,
     )?;
-
     let qualify_candidate = QualifyCandidate::ImplMethod(ctx.sema.db, call, resolved_call);
-
     acc.add(
         AssistId::refactor_rewrite("qualify_method_call"),
         format!("Qualify `{ident}` method call"),
     Some(())
 }
 
-fn item_for_path_search(db: &dyn HirDatabase, item: ItemInNs) -> Option<ItemInNs> {
+fn item_for_path_search(
+    db: &dyn HirDatabase,
+    item: ItemInNs,
+) -> Option<ItemInNs> {
     Some(match item {
         ItemInNs::Types(_) | ItemInNs::Values(_) => match item_as_assoc(db, item) {
             Some(assoc_item) => match assoc_item.container(db) {
     })
 }
 
-fn item_as_assoc(db: &dyn HirDatabase, item: ItemInNs) -> Option<AssocItem> {
+fn item_as_assoc(
+    db: &dyn HirDatabase,
+    item: ItemInNs,
+) -> Option<AssocItem> {
     item.into_module_def().as_assoc_item(db)
 }
 
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn struct_method() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_method_multi_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_method_consume() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_method_exclusive() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_method_cross_crate() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_method_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method_multi_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method_consume() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method_exclusive() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method_cross_crate() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_method_over_struct_instance() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn trait_method_over_struct_instance() {
         check_assist_not_applicable(