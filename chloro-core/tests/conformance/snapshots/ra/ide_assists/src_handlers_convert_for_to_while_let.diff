COMPARISON DIFF
============================================================

Original size: 10170 bytes
Chloro size:   9749 bytes
Rustfmt size:  10229 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{
-    sym::{self},
     Name,
+    sym::{self},
 };
 use ide_db::{famous_defs::FamousDefs, syntax_helpers::suggest_name};
 use syntax::{
-    ast::{self, edit::IndentLevel, make, syntax_factory::SyntaxFactory, HasLoopBody},
+    ast::{edit::IndentLevel, make, self, syntax_factory::SyntaxFactory, HasLoopBody},
     syntax_editor::Position,
     AstNode,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: convert_for_loop_to_while_let
-//
-// Converts a for loop into a while let on the Iterator.
-//
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     for$0 v in x {
-//         let y = v * 2;
-//     };
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     let mut tmp = x.into_iter();
-//     while let Some(v) = tmp.next() {
-//         let y = v * 2;
-//     };
-// }
-// ```
 pub(crate) fn convert_for_loop_to_while_let(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         cov_mark::hit!(not_available_in_body);
         return None;
     }
-
     acc.add(
         AssistId::refactor_rewrite("convert_for_loop_to_while_let"),
         "Replace this for loop with `while let`",
             {
                 (expr, Some(make.name_ref(method.as_str())))
             } else if let ast::Expr::RefExpr(_) = iterable {
-                (
-                    make::expr_paren(iterable).into(),
-                    Some(make.name_ref("into_iter")),
-                )
+                (make::expr_paren(iterable).into(), Some(make.name_ref("into_iter")))
             } else {
                 (iterable, Some(make.name_ref("into_iter")))
             };
     let scope = sema.scope(iterable.syntax())?;
     let krate = scope.krate();
     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;
-
     let has_wanted_method = ty
         .iterate_method_candidates(sema.db, &scope, None, Some(&wanted_method), |func| {
             if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {
     if !has_wanted_method {
         return None;
     }
-
     Some((expr_behind_ref, wanted_method))
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn each_to_for_simple_for() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_in_range() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn each_to_for_not_available_in_body() {
         cov_mark::check!(not_available_in_body);
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_no_iter_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_no_iter_method_mut() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut_behind_var() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_already_impls_iterator() {
         cov_mark::check!(test_already_impls_iterator);