COMPARISON DIFF
============================================================

Original size: 10170 bytes
Chloro size:   9672 bytes
Rustfmt size:  10229 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use hir::{
-    sym::{self},
-    Name,
-};
+use hir::{sym::self, Name};
 use ide_db::{famous_defs::FamousDefs, syntax_helpers::suggest_name};
 use syntax::{
     ast::{self, edit::IndentLevel, make, syntax_factory::SyntaxFactory, HasLoopBody},
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: convert_for_loop_to_while_let
-//
-// Converts a for loop into a while let on the Iterator.
-//
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     for$0 v in x {
-//         let y = v * 2;
-//     };
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x = vec![1, 2, 3];
-//     let mut tmp = x.into_iter();
-//     while let Some(v) = tmp.next() {
-//         let y = v * 2;
-//     };
-// }
-// ```
 pub(crate) fn convert_for_loop_to_while_let(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         "Replace this for loop with `while let`",
         for_loop.syntax().text_range(),
         |builder| {
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = builder.make_editor(for_loop.syntax());
-
-            let (iterable, method) = if impls_core_iter(&ctx.sema, &iterable) {
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = builder.make_editor(for_loop.syntax());
+        let (iterable, method) = if impls_core_iter(&ctx.sema, &iterable) {
                 (iterable, None)
             } else if let Some((expr, method)) = is_ref_and_impls_iter_method(&ctx.sema, &iterable)
             {
                 (expr, Some(make.name_ref(method.as_str())))
             } else if let ast::Expr::RefExpr(_) = iterable {
-                (
-                    make::expr_paren(iterable).into(),
-                    Some(make.name_ref("into_iter")),
-                )
+                (make::expr_paren(iterable).into(), Some(make.name_ref("into_iter")))
             } else {
                 (iterable, Some(make.name_ref("into_iter")))
             };
-
-            let iterable = if let Some(method) = method {
+        let iterable = if let Some(method) = method {
                 make::expr_method_call(iterable, method, make::arg_list([])).into()
             } else {
                 iterable
             };
-
-            let mut new_name = suggest_name::NameGenerator::new_from_scope_locals(
+        let mut new_name = suggest_name::NameGenerator::new_from_scope_locals(
                 ctx.sema.scope(for_loop.syntax()),
             );
-            let tmp_var = new_name.suggest_name("tmp");
-
-            let mut_expr = make.let_stmt(
+        let tmp_var = new_name.suggest_name("tmp");
+        let mut_expr = make.let_stmt(
                 make.ident_pat(false, true, make.name(&tmp_var)).into(),
                 None,
                 Some(iterable),
             );
-            let indent = IndentLevel::from_node(for_loop.syntax());
-            editor.insert(
+        let indent = IndentLevel::from_node(for_loop.syntax());
+        editor.insert(
                 Position::before(for_loop.syntax()),
                 make::tokens::whitespace(format!("\n{indent}").as_str()),
             );
-            editor.insert(Position::before(for_loop.syntax()), mut_expr.syntax());
-
-            let opt_pat = make.tuple_struct_pat(make::ext::ident_path("Some"), [pat]);
-            let iter_next_expr = make.expr_method_call(
+        editor.insert(Position::before(for_loop.syntax()), mut_expr.syntax());
+        let opt_pat = make.tuple_struct_pat(make::ext::ident_path("Some"), [pat]);
+        let iter_next_expr = make.expr_method_call(
                 make.expr_path(make::ext::ident_path(&tmp_var)),
                 make.name_ref("next"),
                 make.arg_list([]),
             );
-            let cond = make.expr_let(opt_pat.into(), iter_next_expr.into());
-
-            let while_loop = make.expr_while_loop(cond.into(), body);
-
-            editor.replace(for_loop.syntax(), while_loop.syntax());
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        let cond = make.expr_let(opt_pat.into(), iter_next_expr.into());
+        let while_loop = make.expr_while_loop(cond.into(), body);
+        editor.replace(for_loop.syntax(), while_loop.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
 fn impls_core_iter(sema: &hir::Semantics<'_, ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {
     (|| {
         let it_typ = sema.type_of_expr(iterable)?.adjusted();
-
         let module = sema.scope(iterable.syntax())?.module();
-
         let krate = module.krate();
         let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;
         cov_mark::hit!(test_already_impls_iterator);
         Some(it_typ.impls_trait(sema.db, iter_trait, &[]))
-    })()
-    .unwrap_or(false)
+    })(
+    ).unwrap_or(
+        false,
+    )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn each_to_for_simple_for() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_in_range() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn each_to_for_not_available_in_body() {
         cov_mark::check!(not_available_in_body);
 }",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_no_iter_method() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_no_iter_method_mut() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn each_to_for_for_borrowed_mut_behind_var() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn each_to_for_already_impls_iterator() {
         cov_mark::check!(test_already_impls_iterator);