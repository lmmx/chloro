COMPARISON DIFF
============================================================

Original size: 12272 bytes
Chloro size:   11867 bytes
Rustfmt size:  12272 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use syntax::{
-    AstNode,
     algo::find_node_at_range,
     ast::{self, syntax_factory::SyntaxFactory},
     syntax_editor::SyntaxEditor,
+    AstNode,
 };
 
 use crate::{
-    AssistId,
     assist_context::{AssistContext, Assists},
+    AssistId,
 };
 
-// Assist: pull_assignment_up
-//
-// Extracts variable assignment to outside an if or match statement.
-//
-// ```
-// fn main() {
-//     let mut foo = 6;
-//
-//     if true {
-//         $0foo = 5;
-//     } else {
-//         foo = 4;
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let mut foo = 6;
-//
-//     foo = if true {
-//         5
-//     } else {
-//         4
-//     };
-// }
-// ```
 pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let assign_expr = ctx.find_node_at_offset::<ast::BinExpr>()?;
 
 
         Some(())
     }
+
     fn collect_if(&mut self, if_expr: &ast::IfExpr) -> Option<()> {
         let then_branch = if_expr.then_branch()?;
         self.collect_block(&then_branch)?;
             }
         }
     }
+
     fn collect_block(&mut self, block: &ast::BlockExpr) -> Option<()> {
         let last_expr = block.tail_expr().or_else(|| match block.statements().last()? {
             ast::Stmt::ExprStmt(stmt) => stmt.expr(),
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn test_pull_assignment_up_if() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_inner_if() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_match() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_match_in_if_expr() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_assignment_expressions() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_not_last_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_chained_if() {
         cov_mark::check!(test_pull_assignment_up_chained_if);
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_retains_stmts() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_let_stmt_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_if_missing_assignment_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_match_missing_assignment_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_field_assignment() {
         cov_mark::check!(test_pull_assignment_up_field_assignment);
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_deref() {
         cov_mark::check!(test_pull_assignment_up_deref);
 "#,
         )
     }
-
     #[test]
     fn test_cant_pull_non_assignments() {
         cov_mark::check!(test_cant_pull_non_assignments);