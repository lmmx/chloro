COMPARISON DIFF
============================================================

Original size: 12272 bytes
Chloro size:   11802 bytes
Rustfmt size:  12272 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use syntax::{
-    AstNode,
     algo::find_node_at_range,
     ast::{self, syntax_factory::SyntaxFactory},
     syntax_editor::SyntaxEditor,
+    AstNode,
 };
 
 use crate::{
-    AssistId,
     assist_context::{AssistContext, Assists},
+    AssistId,
 };
 
-// Assist: pull_assignment_up
-//
-// Extracts variable assignment to outside an if or match statement.
-//
-// ```
-// fn main() {
-//     let mut foo = 6;
-//
-//     if true {
-//         $0foo = 5;
-//     } else {
-//         foo = 4;
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let mut foo = 6;
-//
-//     foo = if true {
-//         5
-//     } else {
-//         4
-//     };
-// }
-// ```
 pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let assign_expr = ctx.find_node_at_offset::<ast::BinExpr>()?;
 
         "Pull assignment up",
         target,
         move |edit| {
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = edit.make_editor(tgt.syntax());
-            let assign_expr = make.expr_assignment(collector.common_lhs, new_tgt.clone());
-            let assign_stmt = make.expr_stmt(assign_expr.into());
-
-            editor.replace(tgt.syntax(), assign_stmt.syntax());
-            editor.add_mappings(make.finish_with_mappings());
-            edit.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = edit.make_editor(tgt.syntax());
+        let assign_expr = make.expr_assignment(collector.common_lhs, new_tgt.clone());
+        let assign_stmt = make.expr_stmt(assign_expr.into());
+        editor.replace(tgt.syntax(), assign_stmt.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        edit.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
 
         Some(())
     }
+
     fn collect_if(&mut self, if_expr: &ast::IfExpr) -> Option<()> {
         let then_branch = if_expr.then_branch()?;
         self.collect_block(&then_branch)?;
             ast::ElseBranch::IfExpr(expr) => {
                 cov_mark::hit!(test_pull_assignment_up_chained_if);
                 self.collect_if(&expr)
-            }
+            },
         }
     }
+
     fn collect_block(&mut self, block: &ast::BlockExpr) -> Option<()> {
         let last_expr = block.tail_expr().or_else(|| match block.statements().last()? {
             ast::Stmt::ExprStmt(stmt) => stmt.expr(),
         (ast::Expr::FieldExpr(field_expr0), ast::Expr::FieldExpr(field_expr1)) => {
             cov_mark::hit!(test_pull_assignment_up_field_assignment);
             sema.resolve_field(field_expr0) == sema.resolve_field(field_expr1)
-        }
+        },
         (ast::Expr::PathExpr(path0), ast::Expr::PathExpr(path1)) => {
             let path0 = path0.path();
             let path1 = path1.path();
             } else {
                 false
             }
-        }
-        (ast::Expr::PrefixExpr(prefix0), ast::Expr::PrefixExpr(prefix1))
-            if prefix0.op_kind() == Some(ast::UnaryOp::Deref)
-                && prefix1.op_kind() == Some(ast::UnaryOp::Deref) =>
-        {
+        },
+        (ast::Expr::PrefixExpr(prefix0), ast::Expr::PrefixExpr(prefix1)) if prefix0.op_kind() == Some(ast::UnaryOp::Deref) && prefix1.op_kind() == Some(ast::UnaryOp::Deref) => {
             cov_mark::hit!(test_pull_assignment_up_deref);
             if let (Some(prefix0), Some(prefix1)) = (prefix0.expr(), prefix1.expr()) {
                 is_equivalent(sema, &prefix0, &prefix1)
             } else {
                 false
             }
-        }
+        },
         _ => false,
     }
 }
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn test_pull_assignment_up_if() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_inner_if() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_match() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_match_in_if_expr() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_assignment_expressions() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_not_last_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_chained_if() {
         cov_mark::check!(test_pull_assignment_up_chained_if);
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_retains_stmts() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_let_stmt_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_if_missing_assignment_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_match_missing_assignment_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_field_assignment() {
         cov_mark::check!(test_pull_assignment_up_field_assignment);
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_deref() {
         cov_mark::check!(test_pull_assignment_up_deref);
 "#,
         )
     }
-
     #[test]
     fn test_cant_pull_non_assignments() {
         cov_mark::check!(test_cant_pull_non_assignments);