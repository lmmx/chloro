COMPARISON DIFF
============================================================

Original size: 12272 bytes
Chloro size:   11960 bytes
Rustfmt size:  12272 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use syntax::{
-    AstNode,
     algo::find_node_at_range,
     ast::{self, syntax_factory::SyntaxFactory},
     syntax_editor::SyntaxEditor,
+    AstNode,
 };
 
 use crate::{
     assist_context::{AssistContext, Assists},
 };
 
-// Assist: pull_assignment_up
-//
-// Extracts variable assignment to outside an if or match statement.
-//
-// ```
-// fn main() {
-//     let mut foo = 6;
-//
-//     if true {
-//         $0foo = 5;
-//     } else {
-//         foo = 4;
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let mut foo = 6;
-//
-//     foo = if true {
-//         5
-//     } else {
-//         4
-//     };
-// }
-// ```
-pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn pull_assignment_up(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let assign_expr = ctx.find_node_at_offset::<ast::BinExpr>()?;
-
     let op_kind = assign_expr.op_kind()?;
     if op_kind != (ast::BinaryOp::Assignment { op: None }) {
         cov_mark::hit!(test_cant_pull_non_assignments);
         return None;
     }
-
     let mut collector = AssignmentsCollector {
         sema: &ctx.sema,
         common_lhs: assign_expr.lhs()?,
         assignments: Vec::new(),
     };
-
     let node: Either<ast::IfExpr, ast::MatchExpr> = ctx.find_node_at_offset()?;
     let tgt: ast::Expr = if let Either::Left(if_expr) = node {
         let if_expr = std::iter::successors(Some(if_expr), |it| {
     } else {
         return None;
     };
-
     if let Some(parent) = tgt.syntax().parent()
         && matches!(parent.kind(), syntax::SyntaxKind::BIN_EXPR | syntax::SyntaxKind::LET_STMT)
     {
         return None;
     }
     let target = tgt.syntax().text_range();
-
     let edit_tgt = tgt.syntax().clone_subtree();
     let assignments: Vec<_> = collector
         .assignments
             ))
         })
         .collect();
-
     let mut editor = SyntaxEditor::new(edit_tgt);
     for (stmt, rhs) in assignments {
         let mut stmt = stmt.syntax().clone();
 }
 
 impl AssignmentsCollector<'_> {
-    fn collect_match(&mut self, match_expr: &ast::MatchExpr) -> Option<()> {
+    fn collect_match(
+        &mut self,
+        match_expr: &ast::MatchExpr,
+    ) -> Option<()> {
         for arm in match_expr.match_arm_list()?.arms() {
             match arm.expr()? {
                 ast::Expr::BlockExpr(block) => self.collect_block(&block)?,
                 _ => return None,
             }
         }
-
         Some(())
     }
-    fn collect_if(&mut self, if_expr: &ast::IfExpr) -> Option<()> {
+
+    fn collect_if(
+        &mut self,
+        if_expr: &ast::IfExpr,
+    ) -> Option<()> {
         let then_branch = if_expr.then_branch()?;
         self.collect_block(&then_branch)?;
-
         match if_expr.else_branch()? {
             ast::ElseBranch::Block(block) => self.collect_block(&block),
             ast::ElseBranch::IfExpr(expr) => {
             }
         }
     }
-    fn collect_block(&mut self, block: &ast::BlockExpr) -> Option<()> {
+
+    fn collect_block(
+        &mut self,
+        block: &ast::BlockExpr,
+    ) -> Option<()> {
         let last_expr = block.tail_expr().or_else(|| match block.statements().last()? {
             ast::Stmt::ExprStmt(stmt) => stmt.expr(),
             ast::Stmt::Item(_) | ast::Stmt::LetStmt(_) => None,
         })?;
-
         if let ast::Expr::BinExpr(expr) = last_expr {
             return self.collect_expr(&expr);
         }
-
         None
     }
 
-    fn collect_expr(&mut self, expr: &ast::BinExpr) -> Option<()> {
+    fn collect_expr(
+        &mut self,
+        expr: &ast::BinExpr,
+    ) -> Option<()> {
         if expr.op_kind()? == (ast::BinaryOp::Assignment { op: None })
             && is_equivalent(self.sema, &expr.lhs()?, &self.common_lhs)
         {
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn test_pull_assignment_up_if() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_inner_if() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_match() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_match_in_if_expr() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_assignment_expressions() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_not_last_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_chained_if() {
         cov_mark::check!(test_pull_assignment_up_chained_if);
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_retains_stmts() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_let_stmt_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_if_missing_assignment_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_match_missing_assignment_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_field_assignment() {
         cov_mark::check!(test_pull_assignment_up_field_assignment);
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_deref() {
         cov_mark::check!(test_pull_assignment_up_deref);
 "#,
         )
     }
-
     #[test]
     fn test_cant_pull_non_assignments() {
         cov_mark::check!(test_cant_pull_non_assignments);