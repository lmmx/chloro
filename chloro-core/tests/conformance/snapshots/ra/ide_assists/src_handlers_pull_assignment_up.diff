COMPARISON DIFF
============================================================

Original size: 12272 bytes
Chloro size:   12223 bytes
Rustfmt size:  12344 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     };
 
     if let Some(parent) = tgt.syntax().parent()
-        && matches!(
-            parent.kind(),
-            syntax::SyntaxKind::BIN_EXPR | syntax::SyntaxKind::LET_STMT
-        )
+        && matches!(parent.kind(), syntax::SyntaxKind::BIN_EXPR | syntax::SyntaxKind::LET_STMT)
     {
         return None;
     }
 
         Some(())
     }
+
     fn collect_if(&mut self, if_expr: &ast::IfExpr) -> Option<()> {
         let then_branch = if_expr.then_branch()?;
         self.collect_block(&then_branch)?;
             }
         }
     }
+
     fn collect_block(&mut self, block: &ast::BlockExpr) -> Option<()> {
-        let last_expr = block
-            .tail_expr()
-            .or_else(|| match block.statements().last()? {
-                ast::Stmt::ExprStmt(stmt) => stmt.expr(),
-                ast::Stmt::Item(_) | ast::Stmt::LetStmt(_) => None,
-            })?;
+        let last_expr = block.tail_expr().or_else(|| match block.statements().last()? {
+            ast::Stmt::ExprStmt(stmt) => stmt.expr(),
+            ast::Stmt::Item(_) | ast::Stmt::LetStmt(_) => None,
+        })?;
 
         if let ast::Expr::BinExpr(expr) = last_expr {
             return self.collect_expr(&expr);
                 false
             }
         }
-        (ast::Expr::PrefixExpr(prefix0), ast::Expr::PrefixExpr(prefix1))
-            if prefix0.op_kind() == Some(ast::UnaryOp::Deref)
-                && prefix1.op_kind() == Some(ast::UnaryOp::Deref) =>
-        {
+        (ast::Expr::PrefixExpr(prefix0), ast::Expr::PrefixExpr(prefix1)) if prefix0.op_kind() == Some(ast::UnaryOp::Deref) && prefix1.op_kind() == Some(ast::UnaryOp::Deref) => {
             cov_mark::hit!(test_pull_assignment_up_deref);
             if let (Some(prefix0), Some(prefix1)) = (prefix0.expr(), prefix1.expr()) {
                 is_equivalent(sema, &prefix0, &prefix1)
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn test_pull_assignment_up_if() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_inner_if() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_match() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_match_in_if_expr() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_assignment_expressions() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_not_last_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_chained_if() {
         cov_mark::check!(test_pull_assignment_up_chained_if);
 }"#,
         );
     }
-
     #[test]
     fn test_pull_assignment_up_retains_stmts() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_let_stmt_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_if_missing_assignment_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn pull_assignment_up_match_missing_assignment_not_applicable() {
         check_assist_not_applicable(
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_field_assignment() {
         cov_mark::check!(test_pull_assignment_up_field_assignment);
 }"#,
         )
     }
-
     #[test]
     fn test_pull_assignment_up_deref() {
         cov_mark::check!(test_pull_assignment_up_deref);
 "#,
         )
     }
-
     #[test]
     fn test_cant_pull_non_assignments() {
         cov_mark::check!(test_cant_pull_non_assignments);