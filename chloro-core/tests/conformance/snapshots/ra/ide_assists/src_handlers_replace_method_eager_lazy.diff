COMPARISON DIFF
============================================================

Original size: 7167 bytes
Chloro size:   6502 bytes
Rustfmt size:  7319 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::assists::AssistId;
 use syntax::{
-    ast::{self, make, Expr, HasArgList},
     AstNode,
+    ast::{self, Expr, HasArgList, make},
 };
 
 use crate::{AssistContext, Assists};
 
-// Assist: replace_with_lazy_method
-//
-// Replace `unwrap_or` with `unwrap_or_else` and `ok_or` with `ok_or_else`.
-//
-// ```
-// # //- minicore:option, fn
-// fn foo() {
-//     let a = Some(1);
-//     a.unwra$0p_or(2);
-// }
-// ```
-// ->
-// ```
-// fn foo() {
-//     let a = Some(1);
-//     a.unwrap_or_else(|| 2);
-// }
-// ```
 pub(crate) fn replace_with_lazy_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;
     let scope = ctx.sema.scope(call.syntax())?;
-
     let last_arg = call.arg_list()?.args().next()?;
     let method_name = call.name_ref()?;
-
     let callable = ctx.sema.resolve_method_call_as_callable(&call)?;
     let (_, receiver_ty) = callable.receiver_param(ctx.sema.db)?;
     let n_params = callable.n_params() + 1;
-
     let method_name_lazy = format!(
         "{method_name}{}",
-        if method_name.text().ends_with("or") {
-            "_else"
-        } else {
-            "_with"
-        }
+        if method_name.text().ends_with("or") { "_else" } else { "_with" }
     );
-
     receiver_ty.iterate_method_candidates_with_traits(
         ctx.sema.db,
         &scope,
             valid.then_some(func)
         },
     )?;
-
     acc.add(
         AssistId::refactor_rewrite("replace_with_lazy_method"),
         format!("Replace {method_name} with {method_name_lazy}"),
 fn into_closure(param: &Expr) -> Expr {
     (|| {
         if let ast::Expr::CallExpr(call) = param {
-            if call.arg_list()?.args().count() == 0 {
-                Some(call.expr()?)
-            } else {
-                None
-            }
+            if call.arg_list()?.args().count() == 0 { Some(call.expr()?) } else { None }
         } else {
             None
         }
     .unwrap_or_else(|| make::expr_closure(None, param.clone()).into())
 }
 
-// Assist: replace_with_eager_method
-//
-// Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.
-//
-// ```
-// # //- minicore:option, fn
-// fn foo() {
-//     let a = Some(1);
-//     a.unwra$0p_or_else(|| 2);
-// }
-// ```
-// ->
-// ```
-// fn foo() {
-//     let a = Some(1);
-//     a.unwrap_or(2);
-// }
-// ```
 pub(crate) fn replace_with_eager_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;
     let scope = ctx.sema.scope(call.syntax())?;
-
     let last_arg = call.arg_list()?.args().next()?;
     let method_name = call.name_ref()?;
-
     let callable = ctx.sema.resolve_method_call_as_callable(&call)?;
     let (_, receiver_ty) = callable.receiver_param(ctx.sema.db)?;
     let n_params = callable.n_params() + 1;
     let params = callable.params();
-
     // FIXME: Check that the arg is of the form `() -> T`
     if !params.first()?.ty().impls_fnonce(ctx.sema.db) {
         return None;
     }
-
     let method_name_text = method_name.text();
     let method_name_eager = method_name_text
         .strip_suffix("_else")
         .or_else(|| method_name_text.strip_suffix("_with"))?;
-
     receiver_ty.iterate_method_candidates_with_traits(
         ctx.sema.db,
         &scope,
             valid.then_some(func)
         },
     )?;
-
     acc.add(
         AssistId::refactor_rewrite("replace_with_eager_method"),
         format!("Replace {method_name} with {method_name_eager}"),
 fn into_call(param: &Expr) -> Expr {
     (|| {
         if let ast::Expr::ClosureExpr(closure) = param {
-            if closure.param_list()?.params().count() == 0 {
-                Some(closure.body()?)
-            } else {
-                None
-            }
+            if closure.param_list()?.params().count() == 0 { Some(closure.body()?) } else { None }
         } else {
             None
         }
 #[cfg(test)]
 mod tests {
     use crate::tests::check_assist;
-
     use super::*;
-
     #[test]
     fn replace_or_with_or_else_simple() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_with_or_else_call() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_with_or_else_block() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_else_with_or_simple() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_else_with_or_call() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_else_with_or_map() {
         check_assist(