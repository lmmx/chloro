COMPARISON DIFF
============================================================

Original size: 7167 bytes
Chloro size:   6534 bytes
Rustfmt size:  7319 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::assists::AssistId;
 use syntax::{
-    ast::{self, make, Expr, HasArgList},
     AstNode,
+    ast::{self, Expr, HasArgList, make},
 };
 
 use crate::{AssistContext, Assists};
 
-// Assist: replace_with_lazy_method
-//
-// Replace `unwrap_or` with `unwrap_or_else` and `ok_or` with `ok_or_else`.
-//
-// ```
-// # //- minicore:option, fn
-// fn foo() {
-//     let a = Some(1);
-//     a.unwra$0p_or(2);
-// }
-// ```
-// ->
-// ```
-// fn foo() {
-//     let a = Some(1);
-//     a.unwrap_or_else(|| 2);
-// }
-// ```
 pub(crate) fn replace_with_lazy_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;
     let scope = ctx.sema.scope(call.syntax())?;
 
     let method_name_lazy = format!(
         "{method_name}{}",
-        if method_name.text().ends_with("or") {
-            "_else"
-        } else {
-            "_with"
-        }
+        if method_name.text().ends_with("or") { "_else" } else { "_with" }
     );
 
     receiver_ty.iterate_method_candidates_with_traits(
 fn into_closure(param: &Expr) -> Expr {
     (|| {
         if let ast::Expr::CallExpr(call) = param {
-            if call.arg_list()?.args().count() == 0 {
-                Some(call.expr()?)
-            } else {
-                None
-            }
+            if call.arg_list()?.args().count() == 0 { Some(call.expr()?) } else { None }
         } else {
             None
         }
-    })()
-    .unwrap_or_else(|| make::expr_closure(None, param.clone()).into())
+    })().unwrap_or_else(
+        || make::expr_closure(None, param.clone()).into(),
+    )
 }
 
-// Assist: replace_with_eager_method
-//
-// Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.
-//
-// ```
-// # //- minicore:option, fn
-// fn foo() {
-//     let a = Some(1);
-//     a.unwra$0p_or_else(|| 2);
-// }
-// ```
-// ->
-// ```
-// fn foo() {
-//     let a = Some(1);
-//     a.unwrap_or(2);
-// }
-// ```
 pub(crate) fn replace_with_eager_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;
     let scope = ctx.sema.scope(call.syntax())?;
     let params = callable.params();
 
     // FIXME: Check that the arg is of the form `() -> T`
+
     if !params.first()?.ty().impls_fnonce(ctx.sema.db) {
         return None;
     }
 fn into_call(param: &Expr) -> Expr {
     (|| {
         if let ast::Expr::ClosureExpr(closure) = param {
-            if closure.param_list()?.params().count() == 0 {
-                Some(closure.body()?)
-            } else {
-                None
-            }
+            if closure.param_list()?.params().count() == 0 { Some(closure.body()?) } else { None }
         } else {
             None
         }
-    })()
-    .unwrap_or_else(|| make::expr_call(param.clone(), make::arg_list(Vec::new())).into())
+    })().unwrap_or_else(
+        || make::expr_call(param.clone(), make::arg_list(Vec::new())).into(),
+    )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::check_assist;
-
     use super::*;
-
     #[test]
     fn replace_or_with_or_else_simple() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_with_or_else_call() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_with_or_else_block() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_else_with_or_simple() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_else_with_or_call() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn replace_or_else_with_or_map() {
         check_assist(