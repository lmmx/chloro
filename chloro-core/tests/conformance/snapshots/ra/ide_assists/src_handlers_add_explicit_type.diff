COMPARISON DIFF
============================================================

Original size: 8388 bytes
Chloro size:   8181 bytes
Rustfmt size:  8479 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: add_explicit_type
-//
-// Specify type for a let binding.
-//
-// ```
-// fn main() {
-//     let x$0 = 92;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x: i32 = 92;
-// }
-// ```
 pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let syntax_node = ctx.find_node_at_offset::<Either<LetStmt, Param>>()?;
     let (ascribed_ty, expr, pat) = if let Either::Left(let_stmt) = syntax_node {
 
         (let_stmt.ty(), let_stmt.initializer(), let_stmt.pat()?)
     } else if let Either::Right(param) = syntax_node {
-        if param
-            .syntax()
-            .ancestors()
-            .nth(2)
-            .and_then(ast::ClosureExpr::cast)
-            .is_none()
-        {
+        if param.syntax().ancestors().nth(2).and_then(ast::ClosureExpr::cast).is_none() {
             cov_mark::hit!(add_explicit_type_not_applicable_in_fn_param);
             return None;
         }
         return None;
     }
 
-    let inferred_type = ty
-        .display_source_code(ctx.db(), module.into(), false)
-        .ok()?;
+    let inferred_type = ty.display_source_code(ctx.db(), module.into(), false).ok()?;
     acc.add(
         AssistId::refactor_rewrite("add_explicit_type"),
         format!("Insert explicit type `{inferred_type}`"),
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     #[test]
     fn add_explicit_type_target() {
         check_assist_target(add_explicit_type, r#"fn f() { let a$0 = 1; }"#, "a");
     }
-
     #[test]
     fn add_explicit_type_simple() {
         check_assist(
             r#"fn f() { let a: i32 = 1; }"#,
         );
     }
-
     #[test]
     fn add_explicit_type_simple_on_infer_ty() {
         check_assist(
             r#"fn f() { let a: i32 = 1; }"#,
         );
     }
-
     #[test]
     fn add_explicit_type_simple_nested_infer_ty() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_explicit_type_macro_call_expr() {
         check_assist(
             r"macro_rules! v { () => {0u64} } fn f() { let a: u64 = v!(); }",
         );
     }
-
     #[test]
     fn add_explicit_type_not_applicable_for_fully_unresolved() {
         cov_mark::check!(add_explicit_type_not_applicable_if_ty_not_inferred);
         check_assist_not_applicable(add_explicit_type, r#"fn f() { let a$0 = None; }"#);
     }
-
     #[test]
     fn add_explicit_type_applicable_for_partially_unresolved() {
         check_assist(
         fn f() { let a: Vec<_, Vec<_, i32>> = Vec::new(); }"#,
         );
     }
-
     #[test]
     fn add_explicit_type_not_applicable_closure_expr() {
         check_assist_not_applicable(add_explicit_type, r#"fn f() { let a$0 = || {}; }"#);
     }
-
     #[test]
     fn add_explicit_type_not_applicable_ty_already_specified() {
         cov_mark::check!(add_explicit_type_not_applicable_if_ty_already_specified);
         check_assist_not_applicable(add_explicit_type, r#"fn f() { let a$0: i32 = 1; }"#);
     }
-
     #[test]
     fn add_explicit_type_not_applicable_cursor_after_equals_of_let() {
         cov_mark::check!(add_explicit_type_not_applicable_if_cursor_after_equals);
             r#"fn f() {let a =$0 match 1 {2 => 3, 3 => 5};}"#,
         )
     }
-
     /// https://github.com/rust-lang/rust-analyzer/issues/2922
     #[test]
     fn regression_issue_2922() {
 "#,
         );
     }
-
     #[test]
     fn default_generics_should_not_be_added() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn type_should_be_added_after_pattern() {
         // LetStmt = Attr* 'let' Pat (':' Type)? '=' initializer:Expr ';'
 "#,
         );
     }
-
     #[test]
     fn add_explicit_type_inserts_coercions() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_explicit_type_not_applicable_fn_param() {
         cov_mark::check!(add_explicit_type_not_applicable_in_fn_param);
         check_assist_not_applicable(add_explicit_type, r#"fn f(x$0: ()) {}"#);
     }
-
     #[test]
     fn add_explicit_type_ascribes_closure_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_explicit_type_ascribes_closure_param_already_ascribed() {
         check_assist(