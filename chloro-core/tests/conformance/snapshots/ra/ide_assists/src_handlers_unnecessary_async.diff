COMPARISON DIFF
============================================================

Original size: 7946 bytes
Chloro size:   7039 bytes
Rustfmt size:  7946 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::{
-    EditionedFileId,
     assists::AssistId,
     defs::Definition,
     search::{FileReference, FileReferenceNode},
     syntax_helpers::node_ext::full_path_of_name_ref,
+    EditionedFileId,
 };
 use syntax::{
-    AstNode, SyntaxKind, TextRange,
     ast::{self, NameRef},
+    AstNode, SyntaxKind, TextRange,
 };
 
 use crate::{AssistContext, Assists};
 
-// FIXME: This ought to be a diagnostic lint.
 
-// Assist: unnecessary_async
-//
-// Removes the `async` mark from functions which have no `.await` in their body.
-// Looks for calls to the functions and removes the `.await` on the call site.
-//
-// ```
-// pub asy$0nc fn foo() {}
-// pub async fn bar() { foo().await }
-// ```
-// ->
-// ```
-// pub fn foo() {}
-// pub async fn bar() { foo() }
-// ```
+// FIXME: This ought to be a diagnostic lint.
 pub(crate) fn unnecessary_async(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let function: ast::Fn = ctx.find_node_at_offset()?;
 
         "Remove unnecessary async",
         async_range,
         |edit| {
-            // Remove async on the function definition.
-            edit.replace(async_range, "");
-
-            // Remove all `.await`s from calls to the function we remove `async` from.
-            if let Some(fn_def) = ctx.sema.to_def(&function) {
-                for await_expr in find_all_references(ctx, &Definition::Function(fn_def))
-                    // Keep only references that correspond NameRefs.
-                    .filter_map(|(_, reference)| match reference.name {
-                        FileReferenceNode::NameRef(nameref) => Some(nameref),
-                        _ => None,
-                    })
-                    // Keep only references that correspond to await expressions
-                    .filter_map(|nameref| find_await_expression(ctx, &nameref))
-                {
-                    if let Some(await_token) = &await_expr.await_token() {
+        edit.replace(async_range, "");
+        if let Some(fn_def) = ctx.sema.to_def(&function) {
+            for await_expr in find_all_references(ctx, &Definition::Function(fn_def)).filter_map(|(_, reference)| match reference.name {
+                FileReferenceNode::NameRef(nameref) => Some(nameref),
+                _ => None,
+            }).filter_map(
+                |nameref| find_await_expression(ctx, &nameref),
+            ) {
+                if let Some(await_token) = &await_expr.await_token() {
                         edit.replace(await_token.text_range(), "");
                     }
-                    if let Some(dot_token) = &await_expr.dot_token() {
-                        edit.replace(dot_token.text_range(), "");
-                    }
+                if let Some(dot_token) = &await_expr.dot_token() {
+                    edit.replace(dot_token.text_range(), "");
                 }
             }
-        },
+        }
+    },
     )
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn applies_on_empty_function() {
         check_assist(unnecessary_async, "pub asy$0nc fn f() {}", "pub fn f() {}")
     }
-
     #[test]
     fn applies_and_removes_whitespace() {
         check_assist(unnecessary_async, "pub async$0       fn f() {}", "pub fn f() {}")
     }
-
     #[test]
     fn applies_on_function_with_a_non_await_expr() {
         check_assist(unnecessary_async, "pub asy$0nc fn f() { f2() }", "pub fn f() { f2() }")
     }
-
     #[test]
     fn does_not_apply_on_function_with_an_await_expr() {
         check_assist_not_applicable(unnecessary_async, "pub asy$0nc fn f() { f2().await }")
     }
-
     #[test]
     fn applies_and_removes_await_on_reference() {
         check_assist(
 pub async fn f3() { f2() }"#,
         )
     }
-
     #[test]
     fn applies_and_removes_await_from_within_module() {
         check_assist(
 pub async fn f3() { a::f2() }"#,
         )
     }
-
     #[test]
     fn applies_and_removes_await_on_inner_await() {
         check_assist(
             unnecessary_async,
-            // Ensure that it is the first await on the 3rd line that is removed
             r#"
 pub async fn f() { f2().await }
 pub asy$0nc fn f2() -> i32 { 1 }
 pub async fn f4(i: i32) { }"#,
         )
     }
-
     #[test]
     fn applies_and_removes_await_on_outer_await() {
         check_assist(
             unnecessary_async,
-            // Ensure that it is the second await on the 3rd line that is removed
             r#"
 pub async fn f() { f2().await }
 pub async$0 fn f2(i: i32) { }
 pub async fn f4() -> i32 { 1 }"#,
         )
     }
-
     #[test]
     fn applies_on_method_call() {
         check_assist(
 pub async fn f(s: &S) { s.f2() }"#,
         )
     }
-
     #[test]
     fn does_not_apply_on_function_with_a_nested_await_expr() {
         check_assist_not_applicable(
             "async$0 fn f() { if true { loop { f2().await } } }",
         )
     }
-
     #[test]
     fn does_not_apply_when_not_on_async_token() {
         check_assist_not_applicable(unnecessary_async, "pub async fn$0 f() { f2() }")
     }
-
     #[test]
     fn does_not_apply_on_async_trait_method() {
         check_assist_not_applicable(