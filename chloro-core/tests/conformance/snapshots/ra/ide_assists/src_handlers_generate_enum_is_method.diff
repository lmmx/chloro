COMPARISON DIFF
============================================================

Original size: 6757 bytes
Chloro size:   6282 bytes
Rustfmt size:  6791 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::ast::{self, AstNode, HasName};
 
 use crate::{
-    utils::{add_method_to_adt, find_struct_impl},
+    find_struct_impl},
+
+    utils::{add_method_to_adt,
+
     AssistContext, AssistId, Assists,
 };
 
-// Assist: generate_enum_is_method
-//
-// Generate an `is_` method for this enum variant.
-//
-// ```
-// enum Version {
-//  Undefined,
-//  Minor$0,
-//  Major,
-// }
-// ```
-// ->
-// ```
-// enum Version {
-//  Undefined,
-//  Minor,
-//  Major,
-// }
-//
-// impl Version {
-//     /// Returns `true` if the version is [`Minor`].
-//     ///
-//     /// [`Minor`]: Version::Minor
-//     #[must_use]
-//     fn is_minor(&self) -> bool {
-//         matches!(self, Self::Minor)
-//     }
-// }
-// ```
-pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn generate_enum_is_method(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let variant = ctx.find_node_at_offset::<ast::Variant>()?;
     let variant_name = variant.name()?;
     let parent_enum = ast::Adt::Enum(variant.parent_enum());
         ast::StructKind::Tuple(_) => "(..)",
         ast::StructKind::Unit => "",
     };
-
     let enum_name = parent_enum.name()?;
     let enum_lowercase_name = to_lower_snake_case(&enum_name.to_string()).replace('_', " ");
     let fn_name = format!("is_{}", &to_lower_snake_case(&variant_name.text()));
-
     // Return early if we've found an existing new fn
     let impl_def = find_struct_impl(ctx, &parent_enum, slice::from_ref(&fn_name))?;
-
     let target = variant.syntax().text_range();
     acc.add_group(
         &GroupLabel("Generate an `is_`,`as_`, or `try_into_` for this enum variant".to_owned()),
         "Generate an `is_` method for this enum variant",
         target,
         |builder| {
-            let vis = parent_enum
-                .visibility()
-                .map_or(String::new(), |v| format!("{v} "));
+            let vis = parent_enum.visibility().map_or(String::new(), |v| format!("{v} "));
             let method = format!(
                 "    /// Returns `true` if the {enum_lowercase_name} is [`{variant_name}`].
     ///
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_generate_enum_is_from_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_is_already_implemented() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_is_from_tuple_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_is_from_record_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_is_from_variant_with_one_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_is_from_variant_with_visibility_marker() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_multiple_generate_enum_is_from_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_generate_enum_is_variant_names() {
         check_assist(