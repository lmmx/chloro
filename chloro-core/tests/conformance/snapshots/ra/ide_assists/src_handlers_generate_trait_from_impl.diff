COMPARISON DIFF
============================================================

Original size: 10188 bytes
Chloro size:   8837 bytes
Rustfmt size:  10188 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use crate::assist_context::{AssistContext, Assists};
 use ide_db::assists::AssistId;
 use syntax::{
-    AstNode, SyntaxKind, T,
-    ast::{self, HasGenericParams, HasName, HasVisibility, edit_in_place::Indent, make},
+    ast::{edit_in_place::Indent, make, self, HasGenericParams, HasName, HasVisibility},
     syntax_editor::{Position, SyntaxEditor},
+    AstNode, SyntaxKind, T,
 };
 
-// NOTES :
-// We generate erroneous code if a function is declared const (E0379)
-// This is left to the user to correct as our only option is to remove the
-// function completely which we should not be doing.
+use crate::assist_context::{AssistContext, Assists};
 
-// Assist: generate_trait_from_impl
-//
-// Generate trait for an already defined inherent impl and convert impl to a trait impl.
-//
-// ```
-// struct Foo<const N: usize>([i32; N]);
-//
-// macro_rules! const_maker {
-//     ($t:ty, $v:tt) => {
-//         const CONST: $t = $v;
-//     };
-// }
-//
-// impl<const N: usize> Fo$0o<N> {
-//     // Used as an associated constant.
-//     const CONST_ASSOC: usize = N * 4;
-//
-//     fn create() -> Option<()> {
-//         Some(())
-//     }
-//
-//     const_maker! {i32, 7}
-// }
-// ```
-// ->
-// ```
-// struct Foo<const N: usize>([i32; N]);
-//
-// macro_rules! const_maker {
-//     ($t:ty, $v:tt) => {
-//         const CONST: $t = $v;
-//     };
-// }
-//
-// trait ${0:NewTrait}<const N: usize> {
-//     // Used as an associated constant.
-//     const CONST_ASSOC: usize = N * 4;
-//
-//     fn create() -> Option<()>;
-//
-//     const_maker! {i32, 7}
-// }
-//
-// impl<const N: usize> ${0:NewTrait}<N> for Foo<N> {
-//     // Used as an associated constant.
-//     const CONST_ASSOC: usize = N * 4;
-//
-//     fn create() -> Option<()> {
-//         Some(())
-//     }
-//
-//     const_maker! {i32, 7}
-// }
-// ```
 pub(crate) fn generate_trait_from_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // Get AST Node
     let impl_ast = ctx.find_node_at_offset::<ast::Impl>()?;
-
     // Check if cursor is to the left of assoc item list's L_CURLY.
     // if no L_CURLY then return.
+
     let l_curly = impl_ast.assoc_item_list()?.l_curly_token()?;
 
     let cursor_offset = ctx.offset();
     if cursor_offset >= l_curly_offset.start() {
         return None;
     }
-
     // If impl is not inherent then we don't really need to go any further.
+
     if impl_ast.for_token().is_some() {
         return None;
     }
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     #[test]
     fn test_trigger_when_cursor_on_header() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_assoc_item_fn() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_assoc_item_macro() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_assoc_item_const() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_impl_with_generics() {
         check_assist_no_snippet_cap(
             "#,
         )
     }
-
     #[test]
     fn test_trait_items_should_not_have_vis() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_empty_inherent_impl() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn test_not_top_level_impl() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_snippet_cap_is_some() {
         check_assist(