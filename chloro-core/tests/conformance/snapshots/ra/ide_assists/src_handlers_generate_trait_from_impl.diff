COMPARISON DIFF
============================================================

Original size: 10188 bytes
Chloro size:   9014 bytes
Rustfmt size:  10188 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use crate::assist_context::{AssistContext, Assists};
 use ide_db::assists::AssistId;
 use syntax::{
     AstNode, SyntaxKind, T,
     ast::{self, HasGenericParams, HasName, HasVisibility, edit_in_place::Indent, make},
     syntax_editor::{Position, SyntaxEditor},
 };
+use crate::assist_context::{AssistContext, Assists};
 
 // NOTES :
-// We generate erroneous code if a function is declared const (E0379)
-// This is left to the user to correct as our only option is to remove the
-// function completely which we should not be doing.
 
-// Assist: generate_trait_from_impl
-//
-// Generate trait for an already defined inherent impl and convert impl to a trait impl.
-//
-// ```
-// struct Foo<const N: usize>([i32; N]);
-//
-// macro_rules! const_maker {
-//     ($t:ty, $v:tt) => {
-//         const CONST: $t = $v;
-//     };
-// }
-//
-// impl<const N: usize> Fo$0o<N> {
-//     // Used as an associated constant.
-//     const CONST_ASSOC: usize = N * 4;
-//
-//     fn create() -> Option<()> {
-//         Some(())
-//     }
-//
-//     const_maker! {i32, 7}
-// }
-// ```
-// ->
-// ```
-// struct Foo<const N: usize>([i32; N]);
-//
-// macro_rules! const_maker {
-//     ($t:ty, $v:tt) => {
-//         const CONST: $t = $v;
-//     };
-// }
-//
-// trait ${0:NewTrait}<const N: usize> {
-//     // Used as an associated constant.
-//     const CONST_ASSOC: usize = N * 4;
-//
-//     fn create() -> Option<()>;
-//
-//     const_maker! {i32, 7}
-// }
-//
-// impl<const N: usize> ${0:NewTrait}<N> for Foo<N> {
-//     // Used as an associated constant.
-//     const CONST_ASSOC: usize = N * 4;
-//
-//     fn create() -> Option<()> {
-//         Some(())
-//     }
-//
-//     const_maker! {i32, 7}
-// }
-// ```
+// We generate erroneous code if a function is declared const (E0379)
+
+// This is left to the user to correct as our only option is to remove the
+
+// function completely which we should not be doing.
 pub(crate) fn generate_trait_from_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // Get AST Node
     let impl_ast = ctx.find_node_at_offset::<ast::Impl>()?;
 
     // Check if cursor is to the left of assoc item list's L_CURLY.
+
     // if no L_CURLY then return.
     let l_curly = impl_ast.assoc_item_list()?.l_curly_token()?;
 
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     #[test]
     fn test_trigger_when_cursor_on_header() {
         check_assist_not_applicable(
 }"#,
         );
     }
-
     #[test]
     fn test_assoc_item_fn() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_assoc_item_macro() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_assoc_item_const() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_impl_with_generics() {
         check_assist_no_snippet_cap(
             "#,
         )
     }
-
     #[test]
     fn test_trait_items_should_not_have_vis() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_empty_inherent_impl() {
-        check_assist_not_applicable(
-            generate_trait_from_impl,
-            r#"
+        check_assist_not_applicable(generate_trait_from_impl, r#"
 impl Emp$0tyImpl{}
-"#,
-        )
+"#)
     }
-
     #[test]
     fn test_not_top_level_impl() {
         check_assist_no_snippet_cap(
 }"#,
         )
     }
-
     #[test]
     fn test_snippet_cap_is_some() {
         check_assist(