COMPARISON DIFF
============================================================

Original size: 46739 bytes
Chloro size:   45112 bytes
Rustfmt size:  47157 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::ops::Not;
 
-use crate::{
-    assist_context::{AssistContext, Assists},
-    utils::convert_param_list_to_arg_list,
-};
 use either::Either;
-use hir::{db::HirDatabase, HasVisibility};
+use hir::{HasVisibility, db::HirDatabase};
 use ide_db::{
     assists::{AssistId, GroupLabel},
     path_transform::PathTransform,
 use itertools::Itertools;
 use syntax::{
     ast::{
-        self,
-        edit::{self, AstNodeEdit},
-        make, AssocItem, GenericArgList, GenericParamList, HasAttrs, HasGenericArgs,
-        HasGenericParams, HasName, HasTypeBounds, HasVisibility as astHasVisibility, Path,
-        WherePred,
+        edit::{self, AstNodeEdit}, make, self, AssocItem, GenericArgList, GenericParamList,
+        HasAttrs, HasGenericArgs, HasGenericParams, HasName, HasTypeBounds,
+        HasVisibility as astHasVisibility, Path, WherePred,
     },
     ted::{self, Position},
     AstNode, Edition, NodeOrToken, SmolStr, SyntaxKind, ToSmolStr,
 };
 
-// Assist: generate_delegate_trait
-//
-// Generate delegate trait implementation for `StructField`s.
-//
-// ```
-// trait SomeTrait {
-//     type T;
-//     fn fn_(arg: u32) -> u32;
-//     fn method_(&mut self) -> bool;
-// }
-// struct A;
-// impl SomeTrait for A {
-//     type T = u32;
-//
-//     fn fn_(arg: u32) -> u32 {
-//         42
-//     }
-//
-//     fn method_(&mut self) -> bool {
-//         false
-//     }
-// }
-// struct B {
-//     a$0: A,
-// }
-// ```
-// ->
-// ```
-// trait SomeTrait {
-//     type T;
-//     fn fn_(arg: u32) -> u32;
-//     fn method_(&mut self) -> bool;
-// }
-// struct A;
-// impl SomeTrait for A {
-//     type T = u32;
-//
-//     fn fn_(arg: u32) -> u32 {
-//         42
-//     }
-//
-//     fn method_(&mut self) -> bool {
-//         false
-//     }
-// }
-// struct B {
-//     a: A,
-// }
-//
-// impl SomeTrait for B {
-//     type T = <A as SomeTrait>::T;
-//
-//     fn fn_(arg: u32) -> u32 {
-//         <A as SomeTrait>::fn_(arg)
-//     }
-//
-//     fn method_(&mut self) -> bool {
-//         <A as SomeTrait>::method_(&mut self.a)
-//     }
-// }
-// ```
+use crate::{
+    assist_context::{AssistContext, Assists},
+    utils::convert_param_list_to_arg_list,
+};
+
 pub(crate) fn generate_delegate_trait(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     if !ctx.config.code_action_grouping {
         return None;
             }
         }
 
-        Some(Field {
-            name,
-            ty,
-            range,
-            impls,
-            edition,
-        })
+        Some(Field { name, ty, range, impls, edition })
     }
 }
 
             };
 
             acc.add_group(
-                &GroupLabel(format!(
-                    "Generate delegate trait impls for field `{}`",
-                    field.name
-                )),
+                &GroupLabel(format!("Generate delegate trait impls for field `{}`", field.name)),
                 AssistId(
                     "generate_delegate_trait",
                     ide_db::assists::AssistKind::Generate,
                     Some(index),
                 ),
-                format!(
-                    "Generate delegate trait impl `{}` for `{}`",
-                    signature, field.name
-                ),
+                format!("Generate delegate trait impl `{}` for `{}`", signature, field.name),
                 field.range,
                 |builder| {
                     builder.insert(
 
             // 2.3) Instantiate generics with `transform_impl`, this step also
             // remove unused params.
-            let trait_gen_args = old_impl
-                .trait_()?
-                .generic_arg_list()
-                .and_then(|trait_args| {
-                    let trait_args = &mut trait_args.clone_for_update();
-                    if let Some(new_args) = transform_impl(
-                        ctx,
-                        ast_strukt,
-                        &old_impl,
-                        &transform_args,
-                        trait_args.clone_subtree(),
-                    ) {
-                        *trait_args = new_args.clone_subtree();
-                        Some(new_args)
-                    } else {
-                        None
-                    }
-                });
+            let trait_gen_args = old_impl.trait_()?.generic_arg_list().and_then(|trait_args| {
+                let trait_args = &mut trait_args.clone_for_update();
+                if let Some(new_args) = transform_impl(
+                    ctx,
+                    ast_strukt,
+                    &old_impl,
+                    &transform_args,
+                    trait_args.clone_subtree(),
+                ) {
+                    *trait_args = new_args.clone_subtree();
+                    Some(new_args)
+                } else {
+                    None
+                }
+            });
 
             let type_gen_args = strukt_params.clone().map(|params| params.to_generic_args());
             let path_type =
         .collect::<FxHashSet<_>>();
 
     // Keep where-clauses that have generics after substitution, and remove the
+
     // rest.
     let has_live_generics = |pred: &WherePred| {
         pred.syntax()
             .any(|e| e.kind() == SyntaxKind::IDENT && live_generics.contains(&e.to_string()))
             .not()
     };
-    wc.predicates()
-        .filter(has_live_generics)
-        .for_each(|pred| wc.remove_predicate(pred));
+    wc.predicates().filter(has_live_generics).for_each(|pred| wc.remove_predicate(pred));
 
     if wc.predicates().count() == 0 {
         // Remove useless whitespaces
     }
 }
 
-// Generate generic args that should be apply to current impl.
-//
-// For example, say we have implementation `impl<A, B, C> Trait for B<A>`,
-// and `b: B<T>` in struct `S<T>`. Then the `A` should be instantiated to `T`.
-// While the last two generic args `B` and `C` doesn't change, it remains
-// `<B, C>`. So we apply `<T, B, C>` as generic arguments to impl.
 fn generate_args_for_impl(
     old_impl_gpl: Option<GenericParamList>,
     self_ty: &ast::Type,
         let field_args = field_ty.generic_arg_list().map(|gal| gal.generic_args());
         let self_ty_args = self_ty.generic_arg_list().map(|gal| gal.generic_args());
         if let (Some(field_args), Some(self_ty_args)) = (field_args, self_ty_args) {
-            self_ty_args
-                .zip(field_args)
-                .for_each(|(self_ty_arg, field_arg)| {
-                    arg_substs
-                        .entry(self_ty_arg.to_string())
-                        .or_insert(field_arg);
-                })
+            self_ty_args.zip(field_args).for_each(|(self_ty_arg, field_arg)| {
+                arg_substs.entry(self_ty_arg.to_string()).or_insert(field_arg);
+            })
         }
     }
 
     let path_expr_segment = make::path_from_text(item.name()?.to_string().as_str());
 
     // We want rhs of the const assignment to be a qualified path
+
     // The general case for const assignment can be found [here](`https://doc.rust-lang.org/reference/items/constant-items.html`)
+
     // The qualified will have the following generic syntax :
+
     // <Base as Trait<GenArgs>>::ConstName;
+
     // FIXME : We can't rely on `make::path_qualified` for now but it would be nice to replace the following with it.
+
     // make::path_qualified(qual_path_ty, path_expr_segment.as_single_segment().unwrap());
     let qualified_path = qualified_path(qual_path_ty, path_expr_segment);
     let inner = make::item_const(
 
                 make::expr_call(make::expr_path(qualified_path), args)
             }
-            None => make::expr_call(
-                make::expr_path(qualified_path),
-                convert_param_list_to_arg_list(l),
-            ),
+            None => {
+                make::expr_call(make::expr_path(qualified_path), convert_param_list_to_arg_list(l))
+            }
         },
         None => make::expr_call(
             make::expr_path(qualified_path),
 
 #[cfg(test)]
 mod test {
-
     use super::*;
     use crate::tests::{
         check_assist, check_assist_not_applicable, check_assist_not_applicable_no_grouping,
     };
-
     #[test]
     fn test_tuple_struct_basic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_self_ty() {
         // trait with `Self` type cannot be delegated
 "#,
         );
     }
-
     #[test]
     fn test_struct_struct_basic() {
         check_assist(
 "#,
         )
     }
-
-    // Structs need to be by def populated with fields
-    // However user can invoke this assist while still editing
-    // We therefore assert its non-applicability
     #[test]
     fn test_yet_empty_struct() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn test_yet_unspecified_field_type() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_unsafe_trait() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_unsafe_trait_with_unsafe_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_struct_with_where_clause() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_fields_with_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generics_with_conflict_names() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_lifetime_with_conflict_names() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generics_multiplex() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_complex_without_where() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_complex_two() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn test_complex_three() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_type_bound() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_type_bound_with_generics_1() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_type_bound_with_generics_2() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_docstring_example() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn import_from_other_mod() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn test_fn_with_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_ty_alias_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn assoc_items_attributes_mutably_cloned() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn delegate_trait_skipped_when_no_grouping() {
         check_assist_not_applicable_no_grouping(