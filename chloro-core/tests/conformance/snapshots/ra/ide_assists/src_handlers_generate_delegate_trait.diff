COMPARISON DIFF
============================================================

Original size: 46739 bytes
Chloro size:   45092 bytes
Rustfmt size:  47157 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::ops::Not;
 
-use crate::{
-    assist_context::{AssistContext, Assists},
-    utils::convert_param_list_to_arg_list,
-};
 use either::Either;
 use hir::{db::HirDatabase, HasVisibility};
 use ide_db::{
 use itertools::Itertools;
 use syntax::{
     ast::{
-        self,
-        edit::{self, AstNodeEdit},
-        make, AssocItem, GenericArgList, GenericParamList, HasAttrs, HasGenericArgs,
-        HasGenericParams, HasName, HasTypeBounds, HasVisibility as astHasVisibility, Path,
-        WherePred,
+        self, edit::{self, AstNodeEdit}, make, AssocItem, GenericArgList, GenericParamList,
+        HasAttrs, HasGenericArgs, HasGenericParams, HasName, HasTypeBounds,
+        HasVisibility as astHasVisibility, Path, WherePred,
     },
     ted::{self, Position},
     AstNode, Edition, NodeOrToken, SmolStr, SyntaxKind, ToSmolStr,
 };
 
-// Assist: generate_delegate_trait
-//
-// Generate delegate trait implementation for `StructField`s.
-//
-// ```
-// trait SomeTrait {
-//     type T;
-//     fn fn_(arg: u32) -> u32;
-//     fn method_(&mut self) -> bool;
-// }
-// struct A;
-// impl SomeTrait for A {
-//     type T = u32;
-//
-//     fn fn_(arg: u32) -> u32 {
-//         42
-//     }
-//
-//     fn method_(&mut self) -> bool {
-//         false
-//     }
-// }
-// struct B {
-//     a$0: A,
-// }
-// ```
-// ->
-// ```
-// trait SomeTrait {
-//     type T;
-//     fn fn_(arg: u32) -> u32;
-//     fn method_(&mut self) -> bool;
-// }
-// struct A;
-// impl SomeTrait for A {
-//     type T = u32;
-//
-//     fn fn_(arg: u32) -> u32 {
-//         42
-//     }
-//
-//     fn method_(&mut self) -> bool {
-//         false
-//     }
-// }
-// struct B {
-//     a: A,
-// }
-//
-// impl SomeTrait for B {
-//     type T = <A as SomeTrait>::T;
-//
-//     fn fn_(arg: u32) -> u32 {
-//         <A as SomeTrait>::fn_(arg)
-//     }
-//
-//     fn method_(&mut self) -> bool {
-//         <A as SomeTrait>::method_(&mut self.a)
-//     }
-// }
-// ```
+use crate::{
+    assist_context::{AssistContext, Assists},
+    utils::convert_param_list_to_arg_list,
+};
+
 pub(crate) fn generate_delegate_trait(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     if !ctx.config.code_action_grouping {
         return None;
             }
         }
 
-        Some(Field {
-            name,
-            ty,
-            range,
-            impls,
-            edition,
-        })
+        Some(Field { name, ty, range, impls, edition })
     }
 }
 
         let db = ctx.db();
 
         for (index, delegee) in field.impls.iter().enumerate() {
-            let trait_ = match delegee {
-                Delegee::Bound(b) => b,
-                Delegee::Impls(i, _) => i,
-            };
-
             // Skip trait that has `Self` type, which cannot be delegated
             //
             // See [`test_self_ty`]
-            if has_self_type(*trait_, ctx).is_some() {
-                continue;
-            }
-
             // FIXME :  We can omit already implemented impl_traits
             // But we don't know what the &[hir::Type] argument should look like.
             // if self.hir_ty.impls_trait(db, trait_, &[]) {
             //     continue;
             // }
+            let trait_ = match delegee {
+                Delegee::Bound(b) => b,
+                Delegee::Impls(i, _) => i,
+            };
+            if has_self_type(*trait_, ctx).is_some() {
+                continue;
+            }
             let signature = delegee.signature(db, field.edition);
-
             let Some(delegate) =
                 generate_impl(ctx, self, &field.ty, &field.name, delegee, field.edition)
             else {
                 continue;
             };
-
             acc.add_group(
-                &GroupLabel(format!(
-                    "Generate delegate trait impls for field `{}`",
-                    field.name
-                )),
+                &GroupLabel(format!("Generate delegate trait impls for field `{}`", field.name)),
                 AssistId(
                     "generate_delegate_trait",
                     ide_db::assists::AssistKind::Generate,
                     Some(index),
                 ),
-                format!(
-                    "Generate delegate trait impl `{}` for `{}`",
-                    signature, field.name
-                ),
+                format!("Generate delegate trait impl `{}` for `{}`", signature, field.name),
                 field.range,
                 |builder| {
                     builder.insert(
 
     match delegee {
         Delegee::Bound(delegee) => {
+            // Goto link : https://doc.rust-lang.org/reference/paths.html#qualified-paths
             let bound_def = ctx.sema.source(delegee.to_owned())?.value;
             let bound_params = bound_def.generic_param_list();
-
             let delegate = make::impl_trait(
                 None,
                 delegee.is_unsafe(db),
                 None,
             )
             .clone_for_update();
-
-            // Goto link : https://doc.rust-lang.org/reference/paths.html#qualified-paths
             let qualified_path_type =
                 make::path_from_text(&format!("<{} as {}>", field_ty, delegate.trait_()?));
-
             let delegate_assoc_items = delegate.get_or_create_assoc_item_list();
             if let Some(ai) = bound_def.assoc_item_list() {
                 ai.assoc_items()
                         }
                     });
             };
-
             let target_scope = ctx.sema.scope(strukt.strukt.syntax())?;
             let source_scope = ctx.sema.scope(bound_def.syntax())?;
             let transform = PathTransform::generic_transformation(&target_scope, &source_scope);
             ast::Impl::cast(transform.apply(delegate.syntax()))
         }
         Delegee::Impls(trait_, old_impl) => {
-            let old_impl = ctx.sema.source(old_impl.to_owned())?.value;
-            let old_impl_params = old_impl.generic_param_list();
-
             // 1) Resolve conflicts between generic parameters in old_impl and
             // those in strukt.
             //
             // These generics parameters will also be used in `field_ty` and
             // `where_clauses`, so we should substitute arguments in them as well.
+            // 2) Handle instantiated generics in `field_ty`.
+            // 2.1) Some generics used in `self_ty` may be instantiated, so they
+            // are no longer generics, we should remove and instantiate those
+            // generics in advance.
+            // `old_trait_args` contains names of generic args for trait in `old_impl`
+            // 2.2) Generate generic args applied on impl.
+            // 2.3) Instantiate generics with `transform_impl`, this step also
+            // remove unused params.
+            // 3) Generate delegate trait impl
+            // Goto link : https://doc.rust-lang.org/reference/paths.html#qualified-paths
+            // 4) Transform associated items in delegte trait impl
+            // 5) Remove useless where clauses
+            let old_impl = ctx.sema.source(old_impl.to_owned())?.value;
+            let old_impl_params = old_impl.generic_param_list();
             let strukt_params = resolve_name_conflicts(strukt_params, &old_impl_params);
             let (field_ty, ty_where_clause) = match &strukt_params {
                 Some(strukt_params) => {
                 }
                 None => (field_ty.clone_for_update(), None),
             };
-
-            // 2) Handle instantiated generics in `field_ty`.
-
-            // 2.1) Some generics used in `self_ty` may be instantiated, so they
-            // are no longer generics, we should remove and instantiate those
-            // generics in advance.
-
-            // `old_trait_args` contains names of generic args for trait in `old_impl`
             let old_impl_trait_args = old_impl
                 .trait_()?
                 .generic_arg_list()
                 .map(|l| l.generic_args().map(|arg| arg.to_string()))
                 .map_or_else(FxHashSet::default, |it| it.collect());
-
             let trait_gen_params = remove_instantiated_params(
                 &old_impl.self_ty()?,
                 old_impl_params.clone(),
                 &old_impl_trait_args,
             );
-
-            // 2.2) Generate generic args applied on impl.
             let transform_args = generate_args_for_impl(
                 old_impl_params,
                 &old_impl.self_ty()?,
                 &trait_gen_params,
                 &old_impl_trait_args,
             );
-
-            // 2.3) Instantiate generics with `transform_impl`, this step also
-            // remove unused params.
-            let trait_gen_args = old_impl
-                .trait_()?
-                .generic_arg_list()
-                .and_then(|trait_args| {
-                    let trait_args = &mut trait_args.clone_for_update();
-                    if let Some(new_args) = transform_impl(
-                        ctx,
-                        ast_strukt,
-                        &old_impl,
-                        &transform_args,
-                        trait_args.clone_subtree(),
-                    ) {
-                        *trait_args = new_args.clone_subtree();
-                        Some(new_args)
-                    } else {
-                        None
-                    }
-                });
-
+            let trait_gen_args = old_impl.trait_()?.generic_arg_list().and_then(|trait_args| {
+                let trait_args = &mut trait_args.clone_for_update();
+                if let Some(new_args) = transform_impl(
+                    ctx,
+                    ast_strukt,
+                    &old_impl,
+                    &transform_args,
+                    trait_args.clone_subtree(),
+                ) {
+                    *trait_args = new_args.clone_subtree();
+                    Some(new_args)
+                } else {
+                    None
+                }
+            });
             let type_gen_args = strukt_params.clone().map(|params| params.to_generic_args());
             let path_type =
                 make::ty(&trait_.name(db).display_no_db(edition).to_smolstr()).clone_for_update();
             let path_type = transform_impl(ctx, ast_strukt, &old_impl, &transform_args, path_type)?;
-            // 3) Generate delegate trait impl
             let delegate = make::impl_trait(
                 None,
                 trait_.is_unsafe(db),
                 None,
             )
             .clone_for_update();
-            // Goto link : https://doc.rust-lang.org/reference/paths.html#qualified-paths
             let qualified_path_type =
                 make::path_from_text(&format!("<{} as {}>", field_ty, delegate.trait_()?));
-
-            // 4) Transform associated items in delegte trait impl
             let delegate_assoc_items = delegate.get_or_create_assoc_item_list();
             for item in old_impl
                 .get_or_create_assoc_item_list()
                 let assoc = process_assoc_item(item, qualified_path_type.clone(), field_name)?;
                 delegate_assoc_items.add_item(assoc);
             }
-
-            // 5) Remove useless where clauses
             if let Some(wc) = delegate.where_clause() {
                 remove_useless_where_clauses(&delegate.trait_()?, &delegate.self_ty()?, wc);
             }
         .collect::<FxHashSet<_>>();
 
     // Keep where-clauses that have generics after substitution, and remove the
+
     // rest.
     let has_live_generics = |pred: &WherePred| {
         pred.syntax()
             .any(|e| e.kind() == SyntaxKind::IDENT && live_generics.contains(&e.to_string()))
             .not()
     };
-    wc.predicates()
-        .filter(has_live_generics)
-        .for_each(|pred| wc.remove_predicate(pred));
+    wc.predicates().filter(has_live_generics).for_each(|pred| wc.remove_predicate(pred));
 
     if wc.predicates().count() == 0 {
         // Remove useless whitespaces
+        // Remove where clause
         [syntax::Direction::Prev, syntax::Direction::Next]
             .into_iter()
             .flat_map(|dir| {
                     .take_while(|node_or_tok| node_or_tok.kind() == SyntaxKind::WHITESPACE)
             })
             .for_each(ted::remove);
-
         ted::insert(
             ted::Position::after(wc.syntax()),
             NodeOrToken::Token(make::token(SyntaxKind::WHITESPACE)),
         );
-        // Remove where clause
         ted::remove(wc.syntax());
     }
 }
 
-// Generate generic args that should be apply to current impl.
-//
-// For example, say we have implementation `impl<A, B, C> Trait for B<A>`,
-// and `b: B<T>` in struct `S<T>`. Then the `A` should be instantiated to `T`.
-// While the last two generic args `B` and `C` doesn't change, it remains
-// `<B, C>`. So we apply `<T, B, C>` as generic arguments to impl.
 fn generate_args_for_impl(
     old_impl_gpl: Option<GenericParamList>,
     self_ty: &ast::Type,
         let field_args = field_ty.generic_arg_list().map(|gal| gal.generic_args());
         let self_ty_args = self_ty.generic_arg_list().map(|gal| gal.generic_args());
         if let (Some(field_args), Some(self_ty_args)) = (field_args, self_ty_args) {
-            self_ty_args
-                .zip(field_args)
-                .for_each(|(self_ty_arg, field_arg)| {
-                    arg_substs
-                        .entry(self_ty_arg.to_string())
-                        .or_insert(field_arg);
-                })
+            self_ty_args.zip(field_args).for_each(|(self_ty_arg, field_arg)| {
+                arg_substs.entry(self_ty_arg.to_string()).or_insert(field_arg);
+            })
         }
     }
 
     match (strukt_params, old_impl_params) {
         (Some(old_strukt_params), Some(old_impl_params)) => {
             let params = make::generic_param_list(std::iter::empty()).clone_for_update();
-
             for old_strukt_param in old_strukt_params.generic_params() {
                 // Get old name from `strukt`
                 let name = SmolStr::from(match &old_strukt_param {
     let path_expr_segment = make::path_from_text(item.name()?.to_string().as_str());
 
     // We want rhs of the const assignment to be a qualified path
+
     // The general case for const assignment can be found [here](`https://doc.rust-lang.org/reference/items/constant-items.html`)
+
     // The qualified will have the following generic syntax :
+
     // <Base as Trait<GenArgs>>::ConstName;
+
     // FIXME : We can't rely on `make::path_qualified` for now but it would be nice to replace the following with it.
+
     // make::path_qualified(qual_path_ty, path_expr_segment.as_single_segment().unwrap());
     let qualified_path = qualified_path(qual_path_ty, path_expr_segment);
     let inner = make::item_const(
 
                 make::expr_call(make::expr_path(qualified_path), args)
             }
-            None => make::expr_call(
-                make::expr_path(qualified_path),
-                convert_param_list_to_arg_list(l),
-            ),
+            None => {
+                make::expr_call(make::expr_path(qualified_path), convert_param_list_to_arg_list(l))
+            }
         },
         None => make::expr_call(
             make::expr_path(qualified_path),
 
 #[cfg(test)]
 mod test {
-
     use super::*;
     use crate::tests::{
         check_assist, check_assist_not_applicable, check_assist_not_applicable_no_grouping,
     };
-
     #[test]
     fn test_tuple_struct_basic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_self_ty() {
         // trait with `Self` type cannot be delegated
 "#,
         );
     }
-
     #[test]
     fn test_struct_struct_basic() {
         check_assist(
 "#,
         )
     }
-
-    // Structs need to be by def populated with fields
-    // However user can invoke this assist while still editing
-    // We therefore assert its non-applicability
     #[test]
     fn test_yet_empty_struct() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn test_yet_unspecified_field_type() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_unsafe_trait() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_unsafe_trait_with_unsafe_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_struct_with_where_clause() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_fields_with_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generics_with_conflict_names() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_lifetime_with_conflict_names() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generics_multiplex() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_complex_without_where() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_complex_two() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn test_complex_three() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_type_bound() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_type_bound_with_generics_1() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_type_bound_with_generics_2() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_docstring_example() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn import_from_other_mod() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn test_fn_with_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_ty_alias_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn assoc_items_attributes_mutably_cloned() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn delegate_trait_skipped_when_no_grouping() {
         check_assist_not_applicable_no_grouping(