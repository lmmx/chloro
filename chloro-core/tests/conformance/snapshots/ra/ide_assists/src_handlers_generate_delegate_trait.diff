COMPARISON DIFF
============================================================

Original size: 46739 bytes
Chloro size:   46695 bytes
Rustfmt size:  47157 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     ast::{
         self, AssocItem, GenericArgList, GenericParamList, HasAttrs, HasGenericArgs,
         HasGenericParams, HasName, HasTypeBounds, HasVisibility as astHasVisibility, Path,
-        WherePred,
-        edit::{self, AstNodeEdit},
-        make,
+        WherePred, edit::{self, AstNodeEdit}, make,
     },
     ted::{self, Position},
 };
             }
         }
 
-        Some(Field {
-            name,
-            ty,
-            range,
-            impls,
-            edition,
-        })
+        Some(Field { name, ty, range, impls, edition })
     }
 }
 
             };
 
             acc.add_group(
-                &GroupLabel(format!(
-                    "Generate delegate trait impls for field `{}`",
-                    field.name
-                )),
+                &GroupLabel(format!("Generate delegate trait impls for field `{}`", field.name)),
                 AssistId(
                     "generate_delegate_trait",
                     ide_db::assists::AssistKind::Generate,
                     Some(index),
                 ),
-                format!(
-                    "Generate delegate trait impl `{}` for `{}`",
-                    signature, field.name
-                ),
+                format!("Generate delegate trait impl `{}` for `{}`", signature, field.name),
                 field.range,
                 |builder| {
                     builder.insert(
             };
 
             // 2) Handle instantiated generics in `field_ty`.
-
             // 2.1) Some generics used in `self_ty` may be instantiated, so they
             // are no longer generics, we should remove and instantiate those
             // generics in advance.
-
             // `old_trait_args` contains names of generic args for trait in `old_impl`
             let old_impl_trait_args = old_impl
                 .trait_()?
 
             // 2.3) Instantiate generics with `transform_impl`, this step also
             // remove unused params.
-            let trait_gen_args = old_impl
-                .trait_()?
-                .generic_arg_list()
-                .and_then(|trait_args| {
-                    let trait_args = &mut trait_args.clone_for_update();
-                    if let Some(new_args) = transform_impl(
-                        ctx,
-                        ast_strukt,
-                        &old_impl,
-                        &transform_args,
-                        trait_args.clone_subtree(),
-                    ) {
-                        *trait_args = new_args.clone_subtree();
-                        Some(new_args)
-                    } else {
-                        None
-                    }
-                });
+            let trait_gen_args = old_impl.trait_()?.generic_arg_list().and_then(|trait_args| {
+                let trait_args = &mut trait_args.clone_for_update();
+                if let Some(new_args) = transform_impl(
+                    ctx,
+                    ast_strukt,
+                    &old_impl,
+                    &transform_args,
+                    trait_args.clone_subtree(),
+                ) {
+                    *trait_args = new_args.clone_subtree();
+                    Some(new_args)
+                } else {
+                    None
+                }
+            });
 
             let type_gen_args = strukt_params.clone().map(|params| params.to_generic_args());
             let path_type =
             .any(|e| e.kind() == SyntaxKind::IDENT && live_generics.contains(&e.to_string()))
             .not()
     };
-    wc.predicates()
-        .filter(has_live_generics)
-        .for_each(|pred| wc.remove_predicate(pred));
+    wc.predicates().filter(has_live_generics).for_each(|pred| wc.remove_predicate(pred));
 
     if wc.predicates().count() == 0 {
         // Remove useless whitespaces
         let field_args = field_ty.generic_arg_list().map(|gal| gal.generic_args());
         let self_ty_args = self_ty.generic_arg_list().map(|gal| gal.generic_args());
         if let (Some(field_args), Some(self_ty_args)) = (field_args, self_ty_args) {
-            self_ty_args
-                .zip(field_args)
-                .for_each(|(self_ty_arg, field_arg)| {
-                    arg_substs
-                        .entry(self_ty_arg.to_string())
-                        .or_insert(field_arg);
-                })
+            self_ty_args.zip(field_args).for_each(|(self_ty_arg, field_arg)| {
+                arg_substs.entry(self_ty_arg.to_string()).or_insert(field_arg);
+            })
         }
     }
 
 
                 make::expr_call(make::expr_path(qualified_path), args)
             }
-            None => make::expr_call(
-                make::expr_path(qualified_path),
-                convert_param_list_to_arg_list(l),
-            ),
+            None => {
+                make::expr_call(make::expr_path(qualified_path), convert_param_list_to_arg_list(l))
+            }
         },
         None => make::expr_call(
             make::expr_path(qualified_path),
 
 #[cfg(test)]
 mod test {
-
     use super::*;
     use crate::tests::{
         check_assist, check_assist_not_applicable, check_assist_not_applicable_no_grouping,
     };
-
     #[test]
     fn test_tuple_struct_basic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_self_ty() {
         // trait with `Self` type cannot be delegated
 "#,
         );
     }
-
     #[test]
     fn test_struct_struct_basic() {
         check_assist(
 "#,
         )
     }
-
     // Structs need to be by def populated with fields
     // However user can invoke this assist while still editing
     // We therefore assert its non-applicability
 "#,
         )
     }
-
     #[test]
     fn test_yet_unspecified_field_type() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_unsafe_trait() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_unsafe_trait_with_unsafe_fn() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_struct_with_where_clause() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_fields_with_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generics_with_conflict_names() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_lifetime_with_conflict_names() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_multiple_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_generics_multiplex() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_complex_without_where() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_complex_two() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn test_complex_three() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_type_bound() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_type_bound_with_generics_1() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_type_bound_with_generics_2() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_docstring_example() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn import_from_other_mod() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn test_fn_with_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_ty_alias_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn assoc_items_attributes_mutably_cloned() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn delegate_trait_skipped_when_no_grouping() {
         check_assist_not_applicable_no_grouping(