COMPARISON DIFF
============================================================

Original size: 6359 bytes
Chloro size:   6061 bytes
Rustfmt size:  6555 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::assists::AssistId;
 use itertools::Itertools;
 use syntax::{
     algo::previous_non_trivia_token,
     ast::{
-        self, edit::AstNodeEdit, make, syntax_factory::SyntaxFactory, HasArgList, HasLoopBody,
+        edit::AstNodeEdit, make, self, syntax_factory::SyntaxFactory, HasArgList, HasLoopBody,
         HasName, RangeItem,
     },
     syntax_editor::{Element, Position},
 
 use crate::assist_context::{AssistContext, Assists};
 
-// Assist: convert_range_for_to_while
-//
-// Convert for each range into while loop.
-//
-// ```
-// fn foo() {
-//     $0for i in 3..7 {
-//         foo(i);
-//     }
-// }
-// ```
-// ->
-// ```
-// fn foo() {
-//     let mut i = 3;
-//     while i < 7 {
-//         foo(i);
-//         i += 1;
-//     }
-// }
-// ```
-pub(crate) fn convert_range_for_to_while(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn convert_range_for_to_while(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let for_kw = ctx.find_token_syntax_at_offset(T![for])?;
     let for_ = ast::ForExpr::cast(for_kw.parent()?)?;
-    let ast::Pat::IdentPat(pat) = for_.pat()? else {
-        return None;
-    };
+    let ast::Pat::IdentPat(pat) = for_.pat()? else { return None };
     let iterable = for_.iterable()?;
     let (start, end, step, inclusive) = extract_range(&iterable)?;
     let name = pat.name()?;
                 elements.extend([
                     make.token(T![while]).syntax_element(),
                     make.whitespace(" ").syntax_element(),
-                    make.expr_bin(var_expr.clone(), op, end)
-                        .syntax()
-                        .syntax_element(),
+                    make.expr_bin(var_expr.clone(), op, end).syntax().syntax_element(),
                 ]);
             } else {
                 elements.push(make.token(T![loop]).syntax_element());
                 elements,
             );
 
-            let op = ast::BinaryOp::Assignment {
-                op: Some(ast::ArithOp::Add),
-            };
+            let op = ast::BinaryOp::Assignment { op: Some(ast::ArithOp::Add) };
             edit.insert_all(
                 Position::after(last),
                 vec![
-                    make.whitespace(&format!("\n{}", indent + 1))
-                        .syntax_element(),
+                    make.whitespace(&format!("\n{}", indent + 1)).syntax_element(),
                     make.expr_bin(var_expr, op, step).syntax().syntax_element(),
                     make.token(T![;]).syntax_element(),
                 ],
         ast::Expr::ParenExpr(expr) => extract_range(&expr.expr()?)?,
         ast::Expr::RangeExpr(range) => {
             let inclusive = range.op_kind()? == ast::RangeOp::Inclusive;
-            (
-                range.start()?,
-                range.end(),
-                make::expr_literal("1").into(),
-                inclusive,
-            )
+            (range.start()?, range.end(), make::expr_literal("1").into(), inclusive)
         }
         ast::Expr::MethodCallExpr(call) if call.name_ref()?.text() == "step_by" => {
             let [step] = call.arg_list()?.args().collect_array()?;
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_convert_range_for_to_while() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_convert_range_for_to_while_no_end_bound() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_convert_range_for_to_while_with_mut_binding() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_convert_range_for_to_while_with_label() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_convert_range_for_to_while_step_by() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_convert_range_for_to_while_not_applicable_non_range() {
         check_assist_not_applicable(