COMPARISON DIFF
============================================================

Original size: 25096 bytes
Chloro size:   25032 bytes
Rustfmt size:  25274 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::ast::syntax_factory::SyntaxFactory;
 use syntax::syntax_editor::SyntaxEditor;
 use syntax::{
-    ast::{self, HasGenericParams, HasName},
     AstNode, NodeOrToken, SyntaxNode,
+    ast::{self, HasGenericParams, HasName},
 };
 
 use crate::{
-    assist_context::{AssistContext, Assists},
     AssistId,
+    assist_context::{AssistContext, Assists},
 };
 
 use super::inline_call::split_refs_and_uses;
     }
 
     // until this is ok
-
     acc.add(
         AssistId::refactor_inline("inline_type_alias_uses"),
         "Inline type alias into all uses",
 
                 let (path_types, path_type_uses) =
                     split_refs_and_uses(builder, refs, |path_type| {
-                        path_type
-                            .syntax()
-                            .ancestors()
-                            .nth(3)
-                            .and_then(ast::PathType::cast)
+                        path_type.syntax().ancestors().nth(3).and_then(ast::PathType::cast)
                     });
                 path_type_uses
                     .iter()
 impl Replacement {
     fn replace_generic(&self, concrete_type: &ast::Type) -> SyntaxNode {
         match self {
-            Replacement::Generic {
-                lifetime_map,
-                const_and_type_map,
-            } => create_replacement(lifetime_map, const_and_type_map, concrete_type),
+            Replacement::Generic { lifetime_map, const_and_type_map } => {
+                create_replacement(lifetime_map, const_and_type_map, concrete_type)
+            }
             Replacement::Plain => concrete_type.syntax().clone_subtree().clone_for_update(),
         }
     }
             cov_mark::hit!(no_generics_params);
             return None;
         }
-        let instance_args = alias_instance
-            .syntax()
-            .descendants()
-            .find_map(ast::GenericArgList::cast);
+        let instance_args =
+            alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast);
 
         Replacement::Generic {
             lifetime_map: LifetimeMap::new(&instance_args, &alias_generics)?,
     }
 
     fn replacement_value(&self) -> Option<SyntaxNode> {
-        Some(
-            match self {
-                ConstOrTypeGeneric::ConstArg(ca) => ca.expr()?.syntax().clone(),
-                ConstOrTypeGeneric::TypeArg(ta) => ta.syntax().clone(),
-                ConstOrTypeGeneric::ConstParam(cp) => cp.default_val()?.syntax().clone(),
-                ConstOrTypeGeneric::TypeParam(tp) => tp.default_type()?.syntax().clone(),
-            }
-            .clone_for_update(),
-        )
+        Some(match self {
+            ConstOrTypeGeneric::ConstArg(ca) => ca.expr()?.syntax().clone(),
+            ConstOrTypeGeneric::TypeArg(ta) => ta.syntax().clone(),
+            ConstOrTypeGeneric::ConstParam(cp) => cp.default_val()?.syntax().clone(),
+            ConstOrTypeGeneric::TypeParam(tp) => tp.default_type()?.syntax().clone(),
+        }.clone_for_update())
     }
 }
 
 mod test {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn empty_generic_params() {
         cov_mark::check!(no_generics_params);
             "#,
         );
     }
-
     #[test]
     fn too_many_generic_args() {
         cov_mark::check!(too_many_generic_args);
             "#,
         );
     }
-
     #[test]
     fn too_many_lifetimes() {
         cov_mark::check!(too_many_lifetimes);
 "#,
         );
     }
-
     // This must be supported in order to support "inline_alias_to_users" or
     // whatever it will be called.
     #[test]
 "#,
         );
     }
-
     #[test]
     fn primitive_arg() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_generic_replacements() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_expression() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_default_value() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn all_param_types() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_lifetimes() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_everything() {
         check_assist(
 "#,
         );
     }
-
     // This doesn't actually cause the GenericArgsList to contain a AssocTypeArg.
     #[test]
     fn arg_associated_type() {
 "#,
         );
     }
-
     #[test]
     fn param_default_associated_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_pointer() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn closure() {
         check_assist(
 "#,
         );
     }
-
     // Type aliases can't be used in traits, but someone might use the assist to
     // fix the error.
     #[test]
             r#"type A = std::io::Write; fn f<T>() where T: std::io::Write {}"#,
         );
     }
-
     #[test]
     fn function_parameter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn arg_expression() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn alias_instance_generic_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn generic_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn missing_replacement_param() {
         cov_mark::check!(missing_replacement_param);
 "#,
         );
     }
-
     #[test]
     fn full_path_type_is_replaced() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_self_type() {
         check_assist(
 "#,
         );
     }
-
     mod inline_type_alias_uses {
         use crate::{handlers::inline_type_alias::inline_type_alias_uses, tests::check_assist};
-
         #[test]
         fn inline_uses() {
             check_assist(
 "#,
             );
         }
-
         #[test]
         fn inline_uses_across_files() {
             check_assist(
 "#,
             );
         }
-
         #[test]
         fn inline_uses_across_files_2() {
             check_assist(