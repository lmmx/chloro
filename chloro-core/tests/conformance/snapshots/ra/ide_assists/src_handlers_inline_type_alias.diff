COMPARISON DIFF
============================================================

Original size: 25096 bytes
Chloro size:   24043 bytes
Rustfmt size:  25274 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-// Some ideas for future improvements:
-// - Support replacing aliases which are used in expressions, e.g. `A::new()`.
-// - Remove unused aliases if there are no longer any users, see inline_call.rs.
-
 use hir::{HasSource, PathResolution};
 use ide_db::FxHashMap;
 use ide_db::{
 use syntax::ast::syntax_factory::SyntaxFactory;
 use syntax::syntax_editor::SyntaxEditor;
 use syntax::{
-    ast::{self, HasGenericParams, HasName},
     AstNode, NodeOrToken, SyntaxNode,
+    ast::{self, HasGenericParams, HasName},
 };
 
 use crate::{
-    assist_context::{AssistContext, Assists},
     AssistId,
+    assist_context::{AssistContext, Assists},
 };
-
 use super::inline_call::split_refs_and_uses;
 
-// Assist: inline_type_alias_uses
-//
-// Inline a type alias into all of its uses where possible.
-//
-// ```
-// type $0A = i32;
-// fn id(x: A) -> A {
-//     x
-// };
-// fn foo() {
-//     let _: A = 3;
-// }
-// ```
-// ->
-// ```
-//
-// fn id(x: i32) -> i32 {
-//     x
-// };
-// fn foo() {
-//     let _: i32 = 3;
-// }
-// ```
-pub(crate) fn inline_type_alias_uses(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn inline_type_alias_uses(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let name = ctx.find_node_at_offset::<ast::Name>()?;
     let ast_alias = name.syntax().parent().and_then(ast::TypeAlias::cast)?;
-
     let hir_alias = ctx.sema.to_def(&ast_alias)?;
     let concrete_type = ast_alias.ty()?;
-
     let usages = Definition::TypeAlias(hir_alias).usages(&ctx.sema);
     if !usages.at_least_one() {
         return None;
     }
-
     // until this is ok
-
     acc.add(
         AssistId::refactor_inline("inline_type_alias_uses"),
         "Inline type alias into all uses",
 
                 let (path_types, path_type_uses) =
                     split_refs_and_uses(builder, refs, |path_type| {
-                        path_type
-                            .syntax()
-                            .ancestors()
-                            .nth(3)
-                            .and_then(ast::PathType::cast)
+                        path_type.syntax().ancestors().nth(3).and_then(ast::PathType::cast)
                     });
                 path_type_uses
                     .iter()
     )
 }
 
-// Assist: inline_type_alias
-//
-// Replace a type alias with its concrete type.
-//
-// ```
-// type A<T = u32> = Vec<T>;
-//
-// fn main() {
-//     let a: $0A;
-// }
-// ```
-// ->
-// ```
-// type A<T = u32> = Vec<T>;
-//
-// fn main() {
-//     let a: Vec<u32>;
-// }
-// ```
-pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn inline_type_alias(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let alias_instance = ctx.find_node_at_offset::<ast::PathType>()?;
     let concrete_type;
     let replacement;
             replacement = inline(&alias, &alias_instance)?;
         }
     }
-
     acc.add(
         AssistId::refactor_inline("inline_type_alias"),
         "Inline type alias",
 }
 
 impl Replacement {
-    fn replace_generic(&self, concrete_type: &ast::Type) -> SyntaxNode {
+    fn replace_generic(
+        &self,
+        concrete_type: &ast::Type,
+    ) -> SyntaxNode {
         match self {
-            Replacement::Generic {
-                lifetime_map,
-                const_and_type_map,
-            } => create_replacement(lifetime_map, const_and_type_map, concrete_type),
+            Replacement::Generic { lifetime_map, const_and_type_map } => {
+                create_replacement(lifetime_map, const_and_type_map, concrete_type)
+            }
             Replacement::Plain => concrete_type.syntax().clone_subtree().clone_for_update(),
         }
     }
     Plain,
 }
 
-fn inline(alias_def: &ast::TypeAlias, alias_instance: &ast::PathType) -> Option<Replacement> {
+fn inline(
+    alias_def: &ast::TypeAlias,
+    alias_instance: &ast::PathType,
+) -> Option<Replacement> {
     let repl = if let Some(alias_generics) = alias_def.generic_param_list() {
         if alias_generics.generic_params().next().is_none() {
             cov_mark::hit!(no_generics_params);
             return None;
         }
-        let instance_args = alias_instance
-            .syntax()
-            .descendants()
-            .find_map(ast::GenericArgList::cast);
+        let instance_args =
+            alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast);
 
         Replacement::Generic {
             lifetime_map: LifetimeMap::new(&instance_args, &alias_generics)?,
             .filter_map(|lp| lp.lifetime())
             .map(|l| l.to_string())
             .collect_vec();
-
         for lifetime in &lifetimes {
             inner.insert(lifetime.to_string(), wildcard_lifetime.clone());
         }
-
         if let Some(instance_generic_args_list) = &instance_args {
             for (index, lifetime) in instance_generic_args_list
                 .lifetime_args()
                 inner.insert(key.clone(), lifetime);
             }
         }
-
         Some(Self(inner))
     }
 }
         let mut inner = FxHashMap::default();
         let instance_generics = generic_args_to_const_and_type_generics(instance_args);
         let alias_generics = generic_param_list_to_const_and_type_generics(alias_generics);
-
         if instance_generics.len() > alias_generics.len() {
             cov_mark::hit!(too_many_generic_args);
             return None;
         }
-
         // Any declaration generics that don't have a default value must have one
         // provided by the instance.
         for (i, declaration_generic) in alias_generics.iter().enumerate() {
                 return None;
             }
         }
-
         Some(Self(inner))
     }
 }
 ) -> SyntaxNode {
     let updated_concrete_type = concrete_type.syntax().clone_subtree();
     let mut editor = SyntaxEditor::new(updated_concrete_type.clone());
-
     let mut replacements: Vec<(SyntaxNode, SyntaxNode)> = Vec::new();
     let mut removals: Vec<NodeOrToken<SyntaxNode, _>> = Vec::new();
-
     for syntax in updated_concrete_type.descendants() {
         if let Some(old_lifetime) = ast::Lifetime::cast(syntax.clone()) {
             if let Some(new_lifetime) = lifetime_map.0.get(&old_lifetime.to_string()) {
             replacements.push((syntax.clone(), new));
         }
     }
-
     for (old, new) in replacements {
         editor.replace(old, new);
     }
-
     for syntax in removals {
         editor.delete(syntax);
     }
     editor.finish().new_root().clone()
 }
 
-fn get_type_alias(ctx: &AssistContext<'_>, path: &ast::PathType) -> Option<ast::TypeAlias> {
+fn get_type_alias(
+    ctx: &AssistContext<'_>,
+    path: &ast::PathType,
+) -> Option<ast::TypeAlias> {
     let resolved_path = ctx.sema.resolve_path(&path.path()?)?;
-
     // We need the generics in the correct order to be able to map any provided
     // instance generics to declaration generics. The `hir::TypeAlias` doesn't
     // keep the order, so we must get the `ast::TypeAlias` from the hir
     }
 }
 
-fn generic_param_list_to_const_and_type_generics(
-    generics: &ast::GenericParamList,
-) -> Vec<ConstOrTypeGeneric> {
+fn generic_param_list_to_const_and_type_generics(generics: &ast::GenericParamList) -> Vec<ConstOrTypeGeneric> {
     let mut others = Vec::new();
-
     for param in generics.generic_params() {
         match param {
             ast::GenericParam::LifetimeParam(_) => {}
             ast::GenericParam::TypeParam(tp) => others.push(ConstOrTypeGeneric::TypeParam(tp)),
         }
     }
-
     others
 }
 
-fn generic_args_to_const_and_type_generics(
-    generics: &Option<ast::GenericArgList>,
-) -> Vec<ConstOrTypeGeneric> {
+fn generic_args_to_const_and_type_generics(generics: &Option<ast::GenericArgList>) -> Vec<ConstOrTypeGeneric> {
     let mut others = Vec::new();
-
     // It's fine for there to be no instance generics because the declaration
     // might have default values or they might be inferred.
     if let Some(generics) = generics {
             }
         }
     }
-
     others
 }
 
 mod test {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn empty_generic_params() {
         cov_mark::check!(no_generics_params);
             "#,
         );
     }
-
     #[test]
     fn too_many_generic_args() {
         cov_mark::check!(too_many_generic_args);
             "#,
         );
     }
-
     #[test]
     fn too_many_lifetimes() {
         cov_mark::check!(too_many_lifetimes);
 "#,
         );
     }
-
-    // This must be supported in order to support "inline_alias_to_users" or
-    // whatever it will be called.
     #[test]
     fn alias_as_expression_ignored() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn primitive_arg() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_generic_replacements() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_expression() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_default_value() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn all_param_types() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_lifetimes() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_everything() {
         check_assist(
 "#,
         );
     }
-
-    // This doesn't actually cause the GenericArgsList to contain a AssocTypeArg.
     #[test]
     fn arg_associated_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_default_associated_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_pointer() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn closure() {
         check_assist(
 "#,
         );
     }
-
-    // Type aliases can't be used in traits, but someone might use the assist to
-    // fix the error.
     #[test]
     fn bounds() {
         check_assist(
             r#"type A = std::io::Write; fn f<T>() where T: std::io::Write {}"#,
         );
     }
-
     #[test]
     fn function_parameter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn arg_expression() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn alias_instance_generic_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn generic_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn missing_replacement_param() {
         cov_mark::check!(missing_replacement_param);
 "#,
         );
     }
-
     #[test]
     fn full_path_type_is_replaced() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_self_type() {
         check_assist(
 }
 "#,
         );
-
         check_assist_not_applicable(
             inline_type_alias,
             r#"
 "#,
         );
     }
-
     mod inline_type_alias_uses {
         use crate::{handlers::inline_type_alias::inline_type_alias_uses, tests::check_assist};
-
         #[test]
         fn inline_uses() {
             check_assist(
 "#,
             );
         }
-
         #[test]
         fn inline_uses_across_files() {
             check_assist(
 "#,
             );
         }
-
         #[test]
         fn inline_uses_across_files_2() {
             check_assist(