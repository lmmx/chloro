COMPARISON DIFF
============================================================

Original size: 25096 bytes
Chloro size:   24163 bytes
Rustfmt size:  25274 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 // Some ideas for future improvements:
 // - Support replacing aliases which are used in expressions, e.g. `A::new()`.
 // - Remove unused aliases if there are no longer any users, see inline_call.rs.
-
 use hir::{HasSource, PathResolution};
 use ide_db::FxHashMap;
 use ide_db::{
 use syntax::ast::syntax_factory::SyntaxFactory;
 use syntax::syntax_editor::SyntaxEditor;
 use syntax::{
-    ast::{self, HasGenericParams, HasName},
     AstNode, NodeOrToken, SyntaxNode,
+    ast::{self, HasGenericParams, HasName},
 };
 
 use crate::{
-    assist_context::{AssistContext, Assists},
     AssistId,
+    assist_context::{AssistContext, Assists},
 };
 
 use super::inline_call::split_refs_and_uses;
 
-// Assist: inline_type_alias_uses
-//
-// Inline a type alias into all of its uses where possible.
-//
-// ```
-// type $0A = i32;
-// fn id(x: A) -> A {
-//     x
-// };
-// fn foo() {
-//     let _: A = 3;
-// }
-// ```
-// ->
-// ```
-//
-// fn id(x: i32) -> i32 {
-//     x
-// };
-// fn foo() {
-//     let _: i32 = 3;
-// }
-// ```
 pub(crate) fn inline_type_alias_uses(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let name = ctx.find_node_at_offset::<ast::Name>()?;
     let ast_alias = name.syntax().parent().and_then(ast::TypeAlias::cast)?;
 
                 let (path_types, path_type_uses) =
                     split_refs_and_uses(builder, refs, |path_type| {
-                        path_type
-                            .syntax()
-                            .ancestors()
-                            .nth(3)
-                            .and_then(ast::PathType::cast)
+                        path_type.syntax().ancestors().nth(3).and_then(ast::PathType::cast)
                     });
                 path_type_uses
                     .iter()
     )
 }
 
-// Assist: inline_type_alias
-//
-// Replace a type alias with its concrete type.
-//
-// ```
-// type A<T = u32> = Vec<T>;
-//
-// fn main() {
-//     let a: $0A;
-// }
-// ```
-// ->
-// ```
-// type A<T = u32> = Vec<T>;
-//
-// fn main() {
-//     let a: Vec<u32>;
-// }
-// ```
 pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let alias_instance = ctx.find_node_at_offset::<ast::PathType>()?;
     let concrete_type;
 impl Replacement {
     fn replace_generic(&self, concrete_type: &ast::Type) -> SyntaxNode {
         match self {
-            Replacement::Generic {
-                lifetime_map,
-                const_and_type_map,
-            } => create_replacement(lifetime_map, const_and_type_map, concrete_type),
+            Replacement::Generic { lifetime_map, const_and_type_map } => {
+                create_replacement(lifetime_map, const_and_type_map, concrete_type)
+            }
             Replacement::Plain => concrete_type.syntax().clone_subtree().clone_for_update(),
         }
     }
             cov_mark::hit!(no_generics_params);
             return None;
         }
-        let instance_args = alias_instance
-            .syntax()
-            .descendants()
-            .find_map(ast::GenericArgList::cast);
+        let instance_args =
+            alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast);
 
         Replacement::Generic {
             lifetime_map: LifetimeMap::new(&instance_args, &alias_generics)?,
         }
 
         // Any declaration generics that don't have a default value must have one
+
         // provided by the instance.
+
         for (i, declaration_generic) in alias_generics.iter().enumerate() {
             let key = declaration_generic.replacement_key()?;
 
     let resolved_path = ctx.sema.resolve_path(&path.path()?)?;
 
     // We need the generics in the correct order to be able to map any provided
+
     // instance generics to declaration generics. The `hir::TypeAlias` doesn't
+
     // keep the order, so we must get the `ast::TypeAlias` from the hir
+
     // definition.
+
     if let PathResolution::Def(hir::ModuleDef::TypeAlias(ta)) = resolved_path {
         Some(ctx.sema.source(ta)?.value)
     } else {
     }
 
     fn replacement_value(&self) -> Option<SyntaxNode> {
-        Some(
-            match self {
-                ConstOrTypeGeneric::ConstArg(ca) => ca.expr()?.syntax().clone(),
-                ConstOrTypeGeneric::TypeArg(ta) => ta.syntax().clone(),
-                ConstOrTypeGeneric::ConstParam(cp) => cp.default_val()?.syntax().clone(),
-                ConstOrTypeGeneric::TypeParam(tp) => tp.default_type()?.syntax().clone(),
-            }
-            .clone_for_update(),
-        )
+        Some(match self {
+            ConstOrTypeGeneric::ConstArg(ca) => ca.expr()?.syntax().clone(),
+            ConstOrTypeGeneric::TypeArg(ta) => ta.syntax().clone(),
+            ConstOrTypeGeneric::ConstParam(cp) => cp.default_val()?.syntax().clone(),
+            ConstOrTypeGeneric::TypeParam(tp) => tp.default_type()?.syntax().clone(),
+        }.clone_for_update())
     }
 }
 
     let mut others = Vec::new();
 
     // It's fine for there to be no instance generics because the declaration
+
     // might have default values or they might be inferred.
+
     if let Some(generics) = generics {
         for arg in generics.generic_args() {
             match arg {
 mod test {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn empty_generic_params() {
         cov_mark::check!(no_generics_params);
             "#,
         );
     }
-
     #[test]
     fn too_many_generic_args() {
         cov_mark::check!(too_many_generic_args);
             "#,
         );
     }
-
     #[test]
     fn too_many_lifetimes() {
         cov_mark::check!(too_many_lifetimes);
 "#,
         );
     }
-
-    // This must be supported in order to support "inline_alias_to_users" or
-    // whatever it will be called.
     #[test]
     fn alias_as_expression_ignored() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn primitive_arg() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_generic_replacements() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_expression() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_default_value() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn all_param_types() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_lifetimes() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn omitted_everything() {
         check_assist(
 "#,
         );
     }
-
-    // This doesn't actually cause the GenericArgsList to contain a AssocTypeArg.
     #[test]
     fn arg_associated_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn param_default_associated_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_pointer() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn closure() {
         check_assist(
 "#,
         );
     }
-
-    // Type aliases can't be used in traits, but someone might use the assist to
-    // fix the error.
     #[test]
     fn bounds() {
         check_assist(
             r#"type A = std::io::Write; fn f<T>() where T: std::io::Write {}"#,
         );
     }
-
     #[test]
     fn function_parameter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn arg_expression() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn alias_instance_generic_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn generic_type() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn missing_replacement_param() {
         cov_mark::check!(missing_replacement_param);
 "#,
         );
     }
-
     #[test]
     fn full_path_type_is_replaced() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_self_type() {
         check_assist(
 "#,
         );
     }
-
     mod inline_type_alias_uses {
         use crate::{handlers::inline_type_alias::inline_type_alias_uses, tests::check_assist};
-
         #[test]
         fn inline_uses() {
             check_assist(
 "#,
             );
         }
-
         #[test]
         fn inline_uses_across_files() {
             check_assist(
 "#,
             );
         }
-
         #[test]
         fn inline_uses_across_files_2() {
             check_assist(