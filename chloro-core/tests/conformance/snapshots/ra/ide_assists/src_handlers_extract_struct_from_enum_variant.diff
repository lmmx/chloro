COMPARISON DIFF
============================================================

Original size: 30062 bytes
Chloro size:   29586 bytes
Rustfmt size:  30062 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::iter;
 
 use either::Either;
 use hir::{HasCrate, Module, ModuleDef, Name, Variant};
 use ide_db::{
-    FxHashSet, RootDatabase,
     defs::Definition,
     helpers::mod_path_to_ast,
-    imports::insert_use::{ImportScope, InsertUseConfig, insert_use},
+    imports::insert_use::{insert_use, ImportScope, InsertUseConfig},
     path_transform::PathTransform,
     search::FileReference,
+    FxHashSet, RootDatabase,
 };
 use itertools::Itertools;
 use syntax::{
-    Edition, SyntaxElement,
+    ast::{
+        self, edit::{AstNodeEdit, IndentLevel}, make, AstNode, HasAttrs, HasGenericParams,
+        HasName, HasVisibility,
+    },
+    match_ast, ted, Edition, SyntaxElement,
     SyntaxKind::*,
     SyntaxNode, T,
-    ast::{
-        self, AstNode, HasAttrs, HasGenericParams, HasName, HasVisibility,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
-    },
-    match_ast, ted,
 };
 
-use crate::{AssistContext, AssistId, Assists, assist_context::SourceChangeBuilder};
+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, Assists};
 
-// Assist: extract_struct_from_enum_variant
-//
-// Extracts a struct from enum variant.
-//
-// ```
-// enum A { $0One(u32, u32) }
-// ```
-// ->
-// ```
-// struct One(u32, u32);
-//
-// enum A { One(One) }
-// ```
 pub(crate) fn extract_struct_from_enum_variant(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     Some(())
 }
 
-// Note: this also detaches whitespace after comments,
-// since `SyntaxNode::splice_children` (and by extension `ted::insert_all_raw`)
-// detaches nodes. If we only took the comments, we'd leave behind the old whitespace.
 fn take_all_comments(node: &SyntaxNode) -> Vec<SyntaxElement> {
     let mut remove_next_ws = false;
     node.children_with_tokens()
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_with_marco() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn issue_16197() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_several_fields_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_several_fields_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_one_field_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_carries_over_generics() {
         check_assist(
 enum En<T> { Var(Var<T>) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_carries_over_attributes() {
         check_assist(
 enum Enum { Variant(Variant) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_indent_to_parent_enum() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_indent_to_parent_enum_in_mod() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_one_field_named() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_several_fields_named() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_several_fields_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_move_struct_variant_comments() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_move_tuple_variant_comments() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_existing_visibility_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_existing_visibility_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_enum_variant_name_value_namespace() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_no_visibility() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_visibility() {
         check_assist(
 pub enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_in_mod_visibility() {
         check_assist(
 pub(in something) enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_crate_visibility() {
         check_assist(
 pub(crate) enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_with_complex_imports() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn extract_record_fix_references() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_record_fix_references2() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_several_files() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_several_files_record() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_extract_struct_record_nested_call_exp() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_enum_not_applicable_for_element_with_no_fields() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r#"enum A { $0One }"#);
     }
-
     #[test]
     fn test_extract_enum_not_applicable_if_struct_exists() {
         cov_mark::check!(test_extract_enum_not_applicable_if_struct_exists);
 "#,
         );
     }
-
     #[test]
     fn test_extract_not_applicable_one_field() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0One(u32) }");
     }
-
     #[test]
     fn test_extract_not_applicable_no_field_tuple() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0None() }");
     }
-
     #[test]
     fn test_extract_not_applicable_no_field_named() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0None {} }");
     }
-
     #[test]
     fn test_extract_struct_only_copies_needed_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_with_lifetime_type_const() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_without_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_keeps_trait_bounds() {
         check_assist(