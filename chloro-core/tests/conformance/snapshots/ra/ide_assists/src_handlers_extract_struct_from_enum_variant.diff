COMPARISON DIFF
============================================================

Original size: 30062 bytes
Chloro size:   30017 bytes
Rustfmt size:  30549 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     SyntaxNode, T,
     ast::{
         self, AstNode, HasAttrs, HasGenericParams, HasName, HasVisibility,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
+        edit::{AstNodeEdit, IndentLevel}, make,
     },
     match_ast, ted,
 };
             let generic_params = enum_ast
                 .generic_param_list()
                 .and_then(|known_generics| extract_generic_params(&known_generics, &field_list));
-            let generics = generic_params
-                .as_ref()
-                .map(|generics| generics.clone_for_update());
+            let generics = generic_params.as_ref().map(|generics| generics.clone_for_update());
 
             // resolve GenericArg in field_list to actual type
-            let field_list = if let Some((target_scope, source_scope)) = ctx
-                .sema
-                .scope(enum_ast.syntax())
-                .zip(ctx.sema.scope(field_list.syntax()))
+            let field_list = if let Some((target_scope, source_scope)) =
+                ctx.sema.scope(enum_ast.syntax()).zip(ctx.sema.scope(field_list.syntax()))
             {
                 let field_list = field_list.reset_indent();
                 let field_list =
                 field_list.clone_for_update()
             };
 
-            let def = create_struct_def(
-                variant_name.clone(),
-                &variant,
-                &field_list,
-                generics,
-                &enum_ast,
-            );
+            let def =
+                create_struct_def(variant_name.clone(), &variant, &field_list, generics, &enum_ast);
 
             let enum_ast = variant.parent_enum();
             let indent = enum_ast.indent_level();
     known_generics: &ast::GenericParamList,
     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,
 ) -> Option<ast::GenericParamList> {
-    let mut generics = known_generics
-        .generic_params()
-        .map(|param| (param, false))
-        .collect_vec();
+    let mut generics = known_generics.generic_params().map(|param| (param, false)).collect_vec();
 
     let tagged_one = match field_list {
         Either::Left(field_list) => field_list
             .fields()
             .filter_map(|f| f.ty())
-            .fold(false, |tagged, ty| {
-                tag_generics_in_variant(&ty, &mut generics) || tagged
-            }),
+            .fold(false, |tagged, ty| tag_generics_in_variant(&ty, &mut generics) || tagged),
         Either::Right(field_list) => field_list
             .fields()
             .filter_map(|f| f.ty())
-            .fold(false, |tagged, ty| {
-                tag_generics_in_variant(&ty, &mut generics) || tagged
-            }),
+            .fold(false, |tagged, ty| tag_generics_in_variant(&ty, &mut generics) || tagged),
     };
 
-    let generics = generics
-        .into_iter()
-        .filter_map(|(param, tag)| tag.then_some(param));
+    let generics = generics.into_iter().filter_map(|(param, tag)| tag.then_some(param));
     tagged_one.then(|| make::generic_param_list(generics))
 }
 
 fn tag_generics_in_variant(ty: &ast::Type, generics: &mut [(ast::GenericParam, bool)]) -> bool {
     let mut tagged_one = false;
 
-    for token in ty
-        .syntax()
-        .descendants_with_tokens()
-        .filter_map(SyntaxElement::into_token)
-    {
+    for token in ty.syntax().descendants_with_tokens().filter_map(SyntaxElement::into_token) {
         for (param, tag) in generics.iter_mut().filter(|(_, tag)| !tag) {
             match param {
                 ast::GenericParam::LifetimeParam(lt)
         enum_
             .attrs()
             .flat_map(|it| {
-                vec![
-                    it.syntax().clone_for_update().into(),
-                    make::tokens::single_newline().into(),
-                ]
+                vec![it.syntax().clone_for_update().into(), make::tokens::single_newline().into()]
             })
             .collect(),
     );
     }
     // deep clone to prevent cycle
     let path = make::path_from_segments(iter::once(segment.clone_subtree()), false);
-    ted::insert_raw(
-        ted::Position::before(segment.syntax()),
-        path.clone_for_update().syntax(),
-    );
-    ted::insert_raw(
-        ted::Position::before(segment.syntax()),
-        make::token(T!['(']),
-    );
+    ted::insert_raw(ted::Position::before(segment.syntax()), path.clone_for_update().syntax());
+    ted::insert_raw(ted::Position::before(segment.syntax()), make::token(T!['(']));
     ted::insert_raw(ted::Position::after(&node), make::token(T![')']));
 }
 
     enum_module_def: &ModuleDef,
     variant_hir_name: &Name,
     refs: Vec<FileReference>,
-) -> Vec<(
-    ast::PathSegment,
-    SyntaxNode,
-    Option<(ImportScope, hir::ModPath)>,
-)> {
+) -> Vec<(ast::PathSegment, SyntaxNode, Option<(ImportScope, hir::ModPath)>)> {
     // we have to recollect here eagerly as we are about to edit the tree we need to calculate the changes
     // and corresponding nodes up front
     refs.into_iter()
             let segment = builder.make_mut(segment);
             let scope_node = builder.make_syntax_mut(scope_node);
             if !visited_modules.contains(&module) {
-                let cfg = ctx
-                    .config
-                    .find_path_config(ctx.sema.is_nightly(module.krate()));
+                let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
                 let mod_path = module.find_use_path(
                     ctx.sema.db,
                     *enum_module_def,
     sema: &hir::Semantics<'_, RootDatabase>,
     reference: FileReference,
 ) -> Option<(ast::PathSegment, SyntaxNode, hir::Module)> {
-    let segment = reference
-        .name
-        .as_name_ref()?
-        .syntax()
-        .parent()
-        .and_then(ast::PathSegment::cast)?;
+    let segment =
+        reference.name.as_name_ref()?.syntax().parent().and_then(ast::PathSegment::cast)?;
 
     // filter out the reference in marco
     let segment_range = segment.syntax().text_range();
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_with_marco() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn issue_16197() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_several_fields_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_several_fields_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_one_field_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_carries_over_generics() {
         check_assist(
 enum En<T> { Var(Var<T>) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_carries_over_attributes() {
         check_assist(
 enum Enum { Variant(Variant) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_indent_to_parent_enum() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_indent_to_parent_enum_in_mod() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_one_field_named() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_several_fields_named() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_several_fields_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_move_struct_variant_comments() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_move_tuple_variant_comments() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_existing_visibility_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_existing_visibility_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_enum_variant_name_value_namespace() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_no_visibility() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_visibility() {
         check_assist(
 pub enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_in_mod_visibility() {
         check_assist(
 pub(in something) enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_crate_visibility() {
         check_assist(
 pub(crate) enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_with_complex_imports() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn extract_record_fix_references() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_record_fix_references2() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_several_files() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_several_files_record() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_extract_struct_record_nested_call_exp() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_enum_not_applicable_for_element_with_no_fields() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r#"enum A { $0One }"#);
     }
-
     #[test]
     fn test_extract_enum_not_applicable_if_struct_exists() {
         cov_mark::check!(test_extract_enum_not_applicable_if_struct_exists);
 "#,
         );
     }
-
     #[test]
     fn test_extract_not_applicable_one_field() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0One(u32) }");
     }
-
     #[test]
     fn test_extract_not_applicable_no_field_tuple() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0None() }");
     }
-
     #[test]
     fn test_extract_not_applicable_no_field_named() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0None {} }");
     }
-
     #[test]
     fn test_extract_struct_only_copies_needed_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_with_lifetime_type_const() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_without_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_keeps_trait_bounds() {
         check_assist(