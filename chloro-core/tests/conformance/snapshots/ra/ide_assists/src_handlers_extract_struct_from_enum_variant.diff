COMPARISON DIFF
============================================================

Original size: 30062 bytes
Chloro size:   29100 bytes
Rustfmt size:  30062 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::iter;
 
 use either::Either;
 use hir::{HasCrate, Module, ModuleDef, Name, Variant};
 use ide_db::{
-    FxHashSet, RootDatabase,
     defs::Definition,
     helpers::mod_path_to_ast,
-    imports::insert_use::{ImportScope, InsertUseConfig, insert_use},
+    imports::insert_use::{insert_use, ImportScope, InsertUseConfig},
     path_transform::PathTransform,
     search::FileReference,
+    FxHashSet, RootDatabase,
 };
 use itertools::Itertools;
 use syntax::{
-    Edition, SyntaxElement,
+    ast::{
+        self, edit::{AstNodeEdit, IndentLevel}, make, AstNode, HasAttrs, HasGenericParams,
+        HasName, HasVisibility,
+    },
+    match_ast, ted, Edition, SyntaxElement,
     SyntaxKind::*,
     SyntaxNode, T,
-    ast::{
-        self, AstNode, HasAttrs, HasGenericParams, HasName, HasVisibility,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
-    },
-    match_ast, ted,
 };
 
-use crate::{AssistContext, AssistId, Assists, assist_context::SourceChangeBuilder};
+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, Assists};
 
-// Assist: extract_struct_from_enum_variant
-//
-// Extracts a struct from enum variant.
-//
-// ```
-// enum A { $0One(u32, u32) }
-// ```
-// ->
-// ```
-// struct One(u32, u32);
-//
-// enum A { One(One) }
-// ```
 pub(crate) fn extract_struct_from_enum_variant(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         "Extract struct from enum variant",
         target,
         |builder| {
-            let edition = enum_hir.krate(ctx.db()).edition(ctx.db());
-            let variant_hir_name = variant_hir.name(ctx.db());
-            let enum_module_def = ModuleDef::from(enum_hir);
-            let usages = Definition::Variant(variant_hir).usages(&ctx.sema).all();
-
-            let mut visited_modules_set = FxHashSet::default();
-            let current_module = enum_hir.module(ctx.db());
-            visited_modules_set.insert(current_module);
-            // record file references of the file the def resides in, we only want to swap to the edited file in the builder once
-            let mut def_file_references = None;
-            for (file_id, references) in usages {
+        let edition = enum_hir.krate(ctx.db()).edition(ctx.db());
+        let variant_hir_name = variant_hir.name(ctx.db());
+        let enum_module_def = ModuleDef::from(enum_hir);
+        let usages = Definition::Variant(variant_hir).usages(&ctx.sema).all();
+        let mut visited_modules_set = FxHashSet::default();
+        let current_module = enum_hir.module(ctx.db());
+        visited_modules_set.insert(current_module);
+        let mut def_file_references = None;
+        for (file_id, references) in usages {
                 if file_id == ctx.file_id() {
                     def_file_references = Some(references);
                     continue;
                     apply_references(ctx.config.insert_use, path, node, import, edition)
                 });
             }
-            builder.edit_file(ctx.vfs_file_id());
-
-            let variant = builder.make_mut(variant.clone());
-            if let Some(references) = def_file_references {
+        builder.edit_file(ctx.vfs_file_id());
+        let variant = builder.make_mut(variant.clone());
+        if let Some(references) = def_file_references {
                 let processed = process_references(
                     ctx,
                     builder,
                     apply_references(ctx.config.insert_use, path, node, import, edition)
                 });
             }
-
-            let generic_params = enum_ast
+        let generic_params = enum_ast
                 .generic_param_list()
                 .and_then(|known_generics| extract_generic_params(&known_generics, &field_list));
-            let generics = generic_params.as_ref().map(|generics| generics.clone_for_update());
-
-            // resolve GenericArg in field_list to actual type
-            let field_list = if let Some((target_scope, source_scope)) =
+        let generics = generic_params.as_ref().map(|generics| generics.clone_for_update());
+        let field_list = if let Some((target_scope, source_scope)) =
                 ctx.sema.scope(enum_ast.syntax()).zip(ctx.sema.scope(field_list.syntax()))
             {
                 let field_list = field_list.reset_indent();
             } else {
                 field_list.clone_for_update()
             };
-
-            let def =
+        let def =
                 create_struct_def(variant_name.clone(), &variant, &field_list, generics, &enum_ast);
-
-            let enum_ast = variant.parent_enum();
-            let indent = enum_ast.indent_level();
-            let def = def.indent(indent);
-
-            ted::insert_all(
+        let enum_ast = variant.parent_enum();
+        let indent = enum_ast.indent_level();
+        let def = def.indent(indent);
+        ted::insert_all(
                 ted::Position::before(enum_ast.syntax()),
                 vec![
                     def.syntax().clone().into(),
                     make::tokens::whitespace(&format!("\n\n{indent}")).into(),
                 ],
             );
-
-            update_variant(&variant, generic_params.map(|g| g.clone_for_update()));
-        },
+        update_variant(&variant, generic_params.map(|g| g.clone_for_update()));
+    },
     )
 }
 
     match variant.kind() {
         ast::StructKind::Record(field_list) if field_list.fields().next().is_some() => {
             Some(Either::Left(field_list))
-        }
+        },
         ast::StructKind::Tuple(field_list) if field_list.fields().count() > 1 => {
             Some(Either::Right(field_list))
-        }
+        },
         _ => None,
     }
 }
 
 fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Variant) -> bool {
-    variant
-        .parent_enum(db)
-        .module(db)
-        .scope(db, None)
-        .into_iter()
-        .filter(|(_, def)| match def {
-            // only check type-namespace
-            hir::ScopeDef::ModuleDef(def) => matches!(
+    variant.parent_enum(db).module(db).scope(db, None).into_iter().filter(|(_, def)| match def {
+        hir::ScopeDef::ModuleDef(def) => matches!(
                 def,
                 ModuleDef::Module(_)
                     | ModuleDef::Adt(_)
                     | ModuleDef::TypeAlias(_)
                     | ModuleDef::BuiltinType(_)
             ),
-            _ => false,
-        })
-        .any(|(name, _)| name.as_str() == variant_name.text().trim_start_matches("r#"))
+        _ => false,
+    }).any(
+        |(name, _)| name.as_str() == variant_name.text().trim_start_matches("r#"),
+    )
 }
 
 fn extract_generic_params(
     Some(())
 }
 
-// Note: this also detaches whitespace after comments,
-// since `SyntaxNode::splice_children` (and by extension `ted::insert_all_raw`)
-// detaches nodes. If we only took the comments, we'd leave behind the old whitespace.
 fn take_all_comments(node: &SyntaxNode) -> Vec<SyntaxElement> {
     let mut remove_next_ws = false;
-    node.children_with_tokens()
-        .filter_map(move |child| match child.kind() {
-            COMMENT => {
-                remove_next_ws = true;
-                child.detach();
-                Some(child)
-            }
-            WHITESPACE if remove_next_ws => {
-                remove_next_ws = false;
-                child.detach();
-                Some(make::tokens::single_newline().into())
-            }
-            _ => {
-                remove_next_ws = false;
-                None
-            }
-        })
-        .collect()
+    node.children_with_tokens().filter_map(move |child| match child.kind() {
+        COMMENT => {
+            remove_next_ws = true;
+            child.detach();
+            Some(child)
+        },
+        WHITESPACE if remove_next_ws => {
+            remove_next_ws = false;
+            child.detach();
+            Some(make::tokens::single_newline().into())
+        },
+        _ => {
+            remove_next_ws = false;
+            None
+        },
+    }).collect(
+    )
 }
 
 fn apply_references(
 ) -> Vec<(ast::PathSegment, SyntaxNode, Option<(ImportScope, hir::ModPath)>)> {
     // we have to recollect here eagerly as we are about to edit the tree we need to calculate the changes
     // and corresponding nodes up front
-    refs.into_iter()
-        .flat_map(|reference| {
-            let (segment, scope_node, module) = reference_to_node(&ctx.sema, reference)?;
-            let segment = builder.make_mut(segment);
-            let scope_node = builder.make_syntax_mut(scope_node);
-            if !visited_modules.contains(&module) {
+    refs.into_iter().flat_map(|reference| {
+        let (segment, scope_node, module) = reference_to_node(&ctx.sema, reference)?;
+        let segment = builder.make_mut(segment);
+        let scope_node = builder.make_syntax_mut(scope_node);
+        if !visited_modules.contains(&module) {
                 let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
                 let mod_path = module.find_use_path(
                     ctx.sema.db,
                     return Some((segment, scope_node, Some((scope, mod_path))));
                 }
             }
-            Some((segment, scope_node, None))
-        })
-        .collect()
+        Some((segment, scope_node, None))
+    }).collect(
+    )
 }
 
 fn reference_to_node(
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_with_marco() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn issue_16197() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_several_fields_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_several_fields_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_one_field_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_carries_over_generics() {
         check_assist(
 enum En<T> { Var(Var<T>) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_carries_over_attributes() {
         check_assist(
 enum Enum { Variant(Variant) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_indent_to_parent_enum() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_indent_to_parent_enum_in_mod() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_one_field_named() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_several_fields_named() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_several_fields_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_move_struct_variant_comments() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_move_tuple_variant_comments() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_existing_visibility_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_existing_visibility_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_enum_variant_name_value_namespace() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_no_visibility() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_visibility() {
         check_assist(
 pub enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_in_mod_visibility() {
         check_assist(
 pub(in something) enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_crate_visibility() {
         check_assist(
 pub(crate) enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_with_complex_imports() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn extract_record_fix_references() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_record_fix_references2() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_several_files() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_several_files_record() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_extract_struct_record_nested_call_exp() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_enum_not_applicable_for_element_with_no_fields() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r#"enum A { $0One }"#);
     }
-
     #[test]
     fn test_extract_enum_not_applicable_if_struct_exists() {
         cov_mark::check!(test_extract_enum_not_applicable_if_struct_exists);
 "#,
         );
     }
-
     #[test]
     fn test_extract_not_applicable_one_field() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0One(u32) }");
     }
-
     #[test]
     fn test_extract_not_applicable_no_field_tuple() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0None() }");
     }
-
     #[test]
     fn test_extract_not_applicable_no_field_named() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0None {} }");
     }
-
     #[test]
     fn test_extract_struct_only_copies_needed_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_with_lifetime_type_const() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_without_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_keeps_trait_bounds() {
         check_assist(