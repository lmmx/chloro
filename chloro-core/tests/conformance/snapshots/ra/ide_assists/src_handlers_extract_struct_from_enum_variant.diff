COMPARISON DIFF
============================================================

Original size: 30062 bytes
Chloro size:   29596 bytes
Rustfmt size:  30062 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     SyntaxNode, T,
     ast::{
         self, AstNode, HasAttrs, HasGenericParams, HasName, HasVisibility,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
+        edit::{AstNodeEdit, IndentLevel}, make,
     },
     match_ast, ted,
 };
 
 use crate::{AssistContext, AssistId, Assists, assist_context::SourceChangeBuilder};
 
-// Assist: extract_struct_from_enum_variant
-//
-// Extracts a struct from enum variant.
-//
-// ```
-// enum A { $0One(u32, u32) }
-// ```
-// ->
-// ```
-// struct One(u32, u32);
-//
-// enum A { One(One) }
-// ```
 pub(crate) fn extract_struct_from_enum_variant(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     };
 
     // for fields without any existing visibility, use visibility of enum
+
     let field_list: ast::FieldList = match field_list {
         Either::Left(field_list) => {
             if let Some(vis) = &enum_vis {
     let strukt = make::struct_(enum_vis, name, generics, field_list).clone_for_update();
 
     // take comments from variant
+
     ted::insert_all(
         ted::Position::first_child_of(strukt.syntax()),
         take_all_comments(variant.syntax()),
     );
 
     // copy attributes from enum
+
     ted::insert_all(
         ted::Position::first_child_of(strukt.syntax()),
         enum_
     };
 
     // change from a record to a tuple field list
+
     let tuple_field = make::tuple_field(None, ty);
     let field_list = make::tuple_field_list(iter::once(tuple_field)).clone_for_update();
     ted::replace(variant.field_list()?.syntax(), field_list.syntax());
 
     // remove any ws after the name
+
     if let Some(ws) = name
         .syntax()
         .siblings_with_tokens(syntax::Direction::Next)
     Some(())
 }
 
-// Note: this also detaches whitespace after comments,
-// since `SyntaxNode::splice_children` (and by extension `ted::insert_all_raw`)
-// detaches nodes. If we only took the comments, we'd leave behind the old whitespace.
 fn take_all_comments(node: &SyntaxNode) -> Vec<SyntaxElement> {
     let mut remove_next_ws = false;
     node.children_with_tokens()
         reference.name.as_name_ref()?.syntax().parent().and_then(ast::PathSegment::cast)?;
 
     // filter out the reference in marco
+
     let segment_range = segment.syntax().text_range();
     if segment_range != reference.range {
         return None;
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_with_marco() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn issue_16197() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_several_fields_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_several_fields_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_one_field_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_carries_over_generics() {
         check_assist(
 enum En<T> { Var(Var<T>) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_carries_over_attributes() {
         check_assist(
 enum Enum { Variant(Variant) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_indent_to_parent_enum() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_indent_to_parent_enum_in_mod() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_one_field_named() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_several_fields_named() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_comments_and_attrs_several_fields_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_move_struct_variant_comments() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_move_tuple_variant_comments() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_existing_visibility_named() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_keep_existing_visibility_tuple() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_enum_variant_name_value_namespace() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_no_visibility() {
         check_assist(
 enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_visibility() {
         check_assist(
 pub enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_in_mod_visibility() {
         check_assist(
 pub(in something) enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_pub_crate_visibility() {
         check_assist(
 pub(crate) enum A { One(One) }"#,
         );
     }
-
     #[test]
     fn test_extract_struct_with_complex_imports() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn extract_record_fix_references() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_record_fix_references2() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_several_files() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_several_files_record() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_extract_struct_record_nested_call_exp() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_enum_not_applicable_for_element_with_no_fields() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r#"enum A { $0One }"#);
     }
-
     #[test]
     fn test_extract_enum_not_applicable_if_struct_exists() {
         cov_mark::check!(test_extract_enum_not_applicable_if_struct_exists);
 "#,
         );
     }
-
     #[test]
     fn test_extract_not_applicable_one_field() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0One(u32) }");
     }
-
     #[test]
     fn test_extract_not_applicable_no_field_tuple() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0None() }");
     }
-
     #[test]
     fn test_extract_not_applicable_no_field_named() {
         check_assist_not_applicable(extract_struct_from_enum_variant, r"enum A { $0None {} }");
     }
-
     #[test]
     fn test_extract_struct_only_copies_needed_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_with_lifetime_type_const() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_without_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_extract_struct_keeps_trait_bounds() {
         check_assist(