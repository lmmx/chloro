COMPARISON DIFF
============================================================

Original size: 41039 bytes
Chloro size:   41031 bytes
Rustfmt size:  41558 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::{
     AstNode, NodeOrToken, SyntaxKind,
     ast::{
-        self, HasArgList, HasGenericArgs, Pat, PathExpr, edit::IndentLevel, edit_in_place::Indent,
+        self, HasArgList, HasGenericArgs, Pat, PathExpr, edit_in_place::Indent, edit::IndentLevel,
     },
     ted,
 };
                 let replaced = call_infos
                     .into_iter()
                     .map(|(call_info, mut_node)| {
-                        let replacement = inline(
-                            &ctx.sema, def_file, function, &func_body, &params, &call_info,
-                        );
+                        let replacement =
+                            inline(&ctx.sema, def_file, function, &func_body, &params, &call_info);
                         ted::replace(mut_node, replacement.syntax());
                     })
                     .count();
             FileReferenceNode::NameRef(name_ref) => Some(name_ref),
             _ => None,
         })
-        .filter_map(
-            |name_ref| match name_ref.syntax().ancestors().find_map(ast::UseTree::cast) {
-                Some(use_tree) => builder.make_mut(use_tree).path().map(Either::Right),
-                None => map_ref(name_ref).map(Either::Left),
-            },
-        )
+        .filter_map(|name_ref| match name_ref.syntax().ancestors().find_map(ast::UseTree::cast) {
+            Some(use_tree) => builder.make_mut(use_tree).path().map(Either::Right),
+            None => map_ref(name_ref).map(Either::Left),
+        })
         .partition_map(|either| either)
 }
 
     let name_ref: ast::NameRef = ctx.find_node_at_offset()?;
     let call_info = CallInfo::from_name_ref(
         name_ref.clone(),
-        ctx.sema
-            .file_to_module_def(ctx.vfs_file_id())?
-            .krate()
-            .into(),
+        ctx.sema.file_to_module_def(ctx.vfs_file_id())?.krate().into(),
     )?;
     let (function, label) = match &call_info.node {
         ast::CallableExpr::Call(call) => {
             };
             (function, format!("Inline `{path}`"))
         }
-        ast::CallableExpr::MethodCall(call) => (
-            ctx.sema.resolve_method_call(call)?,
-            format!("Inline `{name_ref}`"),
-        ),
+        ast::CallableExpr::MethodCall(call) => {
+            (ctx.sema.resolve_method_call(call)?, format!("Inline `{name_ref}`"))
+        }
     };
 
     let fn_source = ctx.sema.source(function)?;
         label,
         syntax.text_range(),
         |builder| {
-            let replacement = inline(&ctx.sema, file_id, function, &fn_body, &params, &call_info);
-            builder.replace_ast(
-                match call_info.node {
-                    ast::CallableExpr::Call(it) => ast::Expr::CallExpr(it),
-                    ast::CallableExpr::MethodCall(it) => ast::Expr::MethodCallExpr(it),
-                },
-                replacement,
-            );
-        },
+        let replacement = inline(&ctx.sema, file_id, function, &fn_body, &params, &call_info);
+        builder.replace_ast(
+            match call_info.node {
+                ast::CallableExpr::Call(it) => ast::Expr::CallExpr(it),
+                ast::CallableExpr::MethodCall(it) => ast::Expr::MethodCallExpr(it),
+            },
+            replacement,
+        );
+    },
     )
 }
 
     function: hir::Function,
     fn_body: &ast::BlockExpr,
     params: &[(ast::Pat, Option<ast::Type>, hir::Param<'_>)],
-    CallInfo {
-        node,
-        arguments,
-        generic_arg_list,
-        krate,
-    }: &CallInfo,
+    CallInfo { node, arguments, generic_arg_list, krate }: &CallInfo,
 ) -> ast::Expr {
     let file_id = sema.hir_file_for(fn_body.syntax());
     let mut body = if let Some(macro_file) = file_id.macro_file() {
     // We should place the following code after last usage of `usages_for_locals`
     // because `ted::replace` will change the offset in syntax tree, which makes
     // `FileReference` incorrect
-    if let Some(imp) = sema
-        .ancestors_with_macros(fn_body.syntax().clone())
-        .find_map(ast::Impl::cast)
+    if let Some(imp) =
+        sema.ancestors_with_macros(fn_body.syntax().clone()).find_map(ast::Impl::cast)
         && !node.syntax().ancestors().any(|anc| &anc == imp.syntax())
         && let Some(t) = imp.self_ty()
     {
                 }
             });
 
-            let ty = sema
-                .type_of_expr(expr)
-                .filter(TypeInfo::has_adjustment)
-                .and(param_ty);
+            let ty = sema.type_of_expr(expr).filter(TypeInfo::has_adjustment).and(param_ty);
 
             let is_self = param.name(sema.db).is_some_and(|name| name == sym::self_);
 
                         }
                     }
                 };
-                let_stmts.push(
-                    make::let_stmt(this_pat.into(), ty, Some(expr))
-                        .clone_for_update()
-                        .into(),
-                )
+                let_stmts
+                    .push(make::let_stmt(this_pat.into(), ty, Some(expr)).clone_for_update().into())
             } else {
                 let_stmts.push(
-                    make::let_stmt(pat.clone(), ty, Some(expr.clone()))
-                        .clone_for_update()
-                        .into(),
+                    make::let_stmt(pat.clone(), ty, Some(expr.clone())).clone_for_update().into(),
                 );
             }
         };
             body = make::block_expr(let_stmts, Some(body.into())).clone_for_update();
         }
     } else if let Some(stmt_list) = body.stmt_list() {
-        let position = stmt_list
-            .l_curly_token()
-            .expect("L_CURLY for StatementList is missing.");
+        let position = stmt_list.l_curly_token().expect("L_CURLY for StatementList is missing.");
         let_stmts.into_iter().rev().for_each(|let_stmt| {
-            ted::insert(
-                ted::Position::after(position.clone()),
-                let_stmt.syntax().clone(),
-            );
+            ted::insert(ted::Position::after(position.clone()), let_stmt.syntax().clone());
         });
     }
 
             .syntax()
             .parent()
             .and_then(ast::BinExpr::cast)
-            .and_then(|bin_expr| bin_expr.lhs())
-        {
+            .and_then(|bin_expr| bin_expr.lhs()) {
             Some(lhs) if lhs.syntax() == node.syntax() => {
-                make::expr_paren(ast::Expr::BlockExpr(body))
-                    .clone_for_update()
-                    .into()
+                make::expr_paren(ast::Expr::BlockExpr(body)).clone_for_update().into()
             }
             _ => ast::Expr::BlockExpr(body),
         },
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn no_args_or_return_value_gets_inlined_without_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_when_incorrect_number_of_parameters_are_provided() {
         cov_mark::check!(inline_call_incorrect_number_of_arguments);
 "#,
         );
     }
-
     #[test]
     fn args_with_side_effects() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_with_multiple_statements() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_with_self_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_val() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generic_method_by_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_ref_mut() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_multi_use_expr_in_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_use_local_in_param() {
         cov_mark::check!(inline_call_inline_locals);
 "#,
         );
     }
-
     #[test]
     fn method_in_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn wraps_closure_in_paren() {
         cov_mark::check!(inline_call_inline_closure);
 "#,
         );
     }
-
     #[test]
     fn inline_single_literal_expr() {
         cov_mark::check!(inline_call_inline_literal);
 "#,
         );
     }
-
     #[test]
     fn inline_emits_type_for_coercion() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_substitutes_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_across_files() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_across_files_with_def_file() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_recursive() {
         cov_mark::check!(inline_into_callers_recursive);
 "#,
         );
     }
-
     #[test]
     fn inline_call_recursive() {
         cov_mark::check!(inline_call_recursive);
 "#,
         );
     }
-
     #[test]
     fn inline_call_field_shorthand() {
         cov_mark::check!(inline_call_inline_direct_field);
 "#,
         );
     }
-
     #[test]
     fn inline_callers_wrapped_in_parentheses() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_wrapped_in_parentheses() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_defined_in_macro() {
         cov_mark::check!(inline_call_defined_in_macro);
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type_but_within_same_impl() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn local_variable_shadowing_callers_argument() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn async_fn_single_expression() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn async_fn_multiple_statements() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn async_fn_with_let_statements() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn inline_call_closure_body() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_call_with_multiple_self_types_eq() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type_in_macros() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_by_reborrow() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_by_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_reference_in_macros() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_into_callers_in_macros_not_applicable() {
         check_assist_not_applicable(