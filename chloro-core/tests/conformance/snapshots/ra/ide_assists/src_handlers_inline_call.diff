COMPARISON DIFF
============================================================

Original size: 41039 bytes
Chloro size:   41032 bytes
Rustfmt size:  41039 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::{
     AstNode, NodeOrToken, SyntaxKind,
     ast::{
-        self, HasArgList, HasGenericArgs, Pat, PathExpr, edit::IndentLevel, edit_in_place::Indent,
+        self, HasArgList, HasGenericArgs, Pat, PathExpr, edit_in_place::Indent, edit::IndentLevel,
     },
     ted,
 };
     }
 
     let syntax = call_info.node.syntax().clone();
-    acc.add(AssistId::refactor_inline("inline_call"), label, syntax.text_range(), |builder| {
+    acc.add(
+        AssistId::refactor_inline("inline_call"),
+        label,
+        syntax.text_range(),
+        |builder| {
         let replacement = inline(&ctx.sema, file_id, function, &fn_body, &params, &call_info);
         builder.replace_ast(
             match call_info.node {
             },
             replacement,
         );
-    })
+    },
+    )
 }
 
 struct CallInfo {
             let path = segment.syntax().parent().and_then(ast::Path::cast)?;
             let path = path.syntax().parent().and_then(ast::PathExpr::cast)?;
             let call = path.syntax().parent().and_then(ast::CallExpr::cast)?;
-
             Some(CallInfo {
                 arguments: call.arg_list()?.args().collect(),
                 node: ast::CallableExpr::Call(call),
     }
 
     // We should place the following code after last usage of `usages_for_locals`
+
     // because `ted::replace` will change the offset in syntax tree, which makes
+
     // `FileReference` incorrect
     if let Some(imp) =
         sema.ancestors_with_macros(fn_body.syntax().clone()).find_map(ast::Impl::cast)
             .syntax()
             .parent()
             .and_then(ast::BinExpr::cast)
-            .and_then(|bin_expr| bin_expr.lhs())
-        {
+            .and_then(|bin_expr| bin_expr.lhs()) {
             Some(lhs) if lhs.syntax() == node.syntax() => {
                 make::expr_paren(ast::Expr::BlockExpr(body)).clone_for_update().into()
             }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn no_args_or_return_value_gets_inlined_without_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_when_incorrect_number_of_parameters_are_provided() {
         cov_mark::check!(inline_call_incorrect_number_of_arguments);
 "#,
         );
     }
-
     #[test]
     fn args_with_side_effects() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_with_multiple_statements() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_with_self_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_val() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generic_method_by_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_ref_mut() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_multi_use_expr_in_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_use_local_in_param() {
         cov_mark::check!(inline_call_inline_locals);
 "#,
         );
     }
-
     #[test]
     fn method_in_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn wraps_closure_in_paren() {
         cov_mark::check!(inline_call_inline_closure);
 "#,
         );
     }
-
     #[test]
     fn inline_single_literal_expr() {
         cov_mark::check!(inline_call_inline_literal);
 "#,
         );
     }
-
     #[test]
     fn inline_emits_type_for_coercion() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_substitutes_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_across_files() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_across_files_with_def_file() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_recursive() {
         cov_mark::check!(inline_into_callers_recursive);
 "#,
         );
     }
-
     #[test]
     fn inline_call_recursive() {
         cov_mark::check!(inline_call_recursive);
 "#,
         );
     }
-
     #[test]
     fn inline_call_field_shorthand() {
         cov_mark::check!(inline_call_inline_direct_field);
 "#,
         );
     }
-
     #[test]
     fn inline_callers_wrapped_in_parentheses() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_wrapped_in_parentheses() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_defined_in_macro() {
         cov_mark::check!(inline_call_defined_in_macro);
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type_but_within_same_impl() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn local_variable_shadowing_callers_argument() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn async_fn_single_expression() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn async_fn_multiple_statements() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn async_fn_with_let_statements() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn inline_call_closure_body() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_call_with_multiple_self_types_eq() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type_in_macros() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_by_reborrow() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_by_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_reference_in_macros() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_into_callers_in_macros_not_applicable() {
         check_assist_not_applicable(