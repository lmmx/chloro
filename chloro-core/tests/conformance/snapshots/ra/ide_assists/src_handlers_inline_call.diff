COMPARISON DIFF
============================================================

Original size: 41039 bytes
Chloro size:   39316 bytes
Rustfmt size:  41039 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::collections::BTreeSet;
 
 use ast::make;
 use either::Either;
 use hir::{
-    FileRange, PathResolution, Semantics, TypeInfo,
     db::{ExpandDatabase, HirDatabase},
-    sym,
+    sym, FileRange, PathResolution, Semantics, TypeInfo,
 };
 use ide_db::{
-    EditionedFileId, RootDatabase,
     base_db::Crate,
     defs::Definition,
     imports::insert_use::remove_path_if_in_use_stmt,
     search::{FileReference, FileReferenceNode, SearchScope},
     source_change::SourceChangeBuilder,
     syntax_helpers::{node_ext::expr_as_name_ref, prettify_macro_expansion},
+    EditionedFileId, RootDatabase,
 };
-use itertools::{Itertools, izip};
+use itertools::{izip, Itertools};
 use syntax::{
-    AstNode, NodeOrToken, SyntaxKind,
     ast::{
-        self, HasArgList, HasGenericArgs, Pat, PathExpr, edit::IndentLevel, edit_in_place::Indent,
+        self, edit::IndentLevel, edit_in_place::Indent, HasArgList, HasGenericArgs, Pat, PathExpr,
     },
-    ted,
+    ted, AstNode, NodeOrToken, SyntaxKind,
 };
 
 use crate::{
-    AssistId,
     assist_context::{AssistContext, Assists},
+    AssistId,
 };
 
-// Assist: inline_into_callers
-//
-// Inline a function or method body into all of its callers where possible, creating a `let` statement per parameter
-// unless the parameter can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
-// or if the parameter is only accessed inside the function body once.
-// If all calls can be inlined the function will be removed.
-//
-// ```
-// fn print(_: &str) {}
-// fn foo$0(word: &str) {
-//     if !word.is_empty() {
-//         print(word);
-//     }
-// }
-// fn bar() {
-//     foo("안녕하세요");
-//     foo("여러분");
-// }
-// ```
-// ->
-// ```
-// fn print(_: &str) {}
-//
-// fn bar() {
-//     {
-//         let word: &str = "안녕하세요";
-//         if !word.is_empty() {
-//             print(word);
-//         }
-//     };
-//     {
-//         let word: &str = "여러분";
-//         if !word.is_empty() {
-//             print(word);
-//         }
-//     };
-// }
-// ```
 pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let def_file = ctx.file_id();
     let vfs_def_file = ctx.vfs_file_id();
         "Inline into all callers",
         name.syntax().text_range(),
         |builder| {
-            let mut usages = usages.all();
-            let current_file_usage = usages.references.remove(&def_file);
-
-            let mut remove_def = true;
-            let mut inline_refs_for_file = |file_id: EditionedFileId, refs: Vec<FileReference>| {
+        let mut usages = usages.all();
+        let current_file_usage = usages.references.remove(&def_file);
+        let mut remove_def = true;
+        let mut inline_refs_for_file = |file_id: EditionedFileId, refs: Vec<FileReference>| {
                 let file_id = file_id.file_id(ctx.db());
                 builder.edit_file(file_id);
                 let call_krate = ctx.sema.file_to_module_def(file_id).map(|it| it.krate());
                     remove_def = false;
                 }
             };
-            for (file_id, refs) in usages.into_iter() {
+        for (file_id, refs) in usages.into_iter() {
                 inline_refs_for_file(file_id, refs);
             }
-            match current_file_usage {
+        match current_file_usage {
                 Some(refs) => inline_refs_for_file(def_file, refs),
                 None => builder.edit_file(vfs_def_file),
             }
-            if remove_def {
-                builder.delete(ast_func.syntax().text_range());
-            }
-        },
+        if remove_def {
+            builder.delete(ast_func.syntax().text_range());
+        }
+    },
     )
 }
 
     iter: impl IntoIterator<Item = FileReference>,
     mut map_ref: impl FnMut(ast::NameRef) -> Option<T>,
 ) -> (Vec<T>, Vec<ast::Path>) {
-    iter.into_iter()
-        .filter_map(|file_ref| match file_ref.name {
-            FileReferenceNode::NameRef(name_ref) => Some(name_ref),
-            _ => None,
-        })
-        .filter_map(|name_ref| match name_ref.syntax().ancestors().find_map(ast::UseTree::cast) {
-            Some(use_tree) => builder.make_mut(use_tree).path().map(Either::Right),
-            None => map_ref(name_ref).map(Either::Left),
-        })
-        .partition_map(|either| either)
+    iter.into_iter().filter_map(|file_ref| match file_ref.name {
+        FileReferenceNode::NameRef(name_ref) => Some(name_ref),
+        _ => None,
+    }).filter_map(|name_ref| match name_ref.syntax().ancestors().find_map(ast::UseTree::cast) {
+        Some(use_tree) => builder.make_mut(use_tree).path().map(Either::Right),
+        None => map_ref(name_ref).map(Either::Left),
+    }).partition_map(
+        |either| either,
+    )
 }
 
-// Assist: inline_call
-//
-// Inlines a function or method body creating a `let` statement per parameter unless the parameter
-// can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
-// or if the parameter is only accessed inside the function body once.
-//
-// ```
-// # //- minicore: option
-// fn foo(name: Option<&str>) {
-//     let name = name.unwrap$0();
-// }
-// ```
-// ->
-// ```
-// fn foo(name: Option<&str>) {
-//     let name = match name {
-//             Some(val) => val,
-//             None => panic!("called `Option::unwrap()` on a `None` value"),
-//         };
-// }
-// ```
 pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let name_ref: ast::NameRef = ctx.find_node_at_offset()?;
     let call_info = CallInfo::from_name_ref(
     }
 
     let syntax = call_info.node.syntax().clone();
-    acc.add(AssistId::refactor_inline("inline_call"), label, syntax.text_range(), |builder| {
+    acc.add(
+        AssistId::refactor_inline("inline_call"),
+        label,
+        syntax.text_range(),
+        |builder| {
         let replacement = inline(&ctx.sema, file_id, function, &fn_body, &params, &call_info);
         builder.replace_ast(
             match call_info.node {
             },
             replacement,
         );
-    })
+    },
+    )
 }
 
 struct CallInfo {
             let path = segment.syntax().parent().and_then(ast::Path::cast)?;
             let path = path.syntax().parent().and_then(ast::PathExpr::cast)?;
             let call = path.syntax().parent().and_then(ast::CallExpr::cast)?;
-
             Some(CallInfo {
                 arguments: call.arg_list()?.args().collect(),
                 node: ast::CallableExpr::Call(call),
     }
 
     // We should place the following code after last usage of `usages_for_locals`
+
     // because `ted::replace` will change the offset in syntax tree, which makes
+
     // `FileReference` incorrect
     if let Some(imp) =
         sema.ancestors_with_macros(fn_body.syntax().clone()).find_map(ast::Impl::cast)
     match body.tail_expr() {
         Some(expr) if matches!(expr, ast::Expr::ClosureExpr(_)) && no_stmts => {
             make::expr_paren(expr).clone_for_update().into()
-        }
+        },
         Some(expr) if !is_async_fn && no_stmts => expr,
-        _ => match node
-            .syntax()
-            .parent()
-            .and_then(ast::BinExpr::cast)
-            .and_then(|bin_expr| bin_expr.lhs())
-        {
+        _ => match node.syntax().parent().and_then(ast::BinExpr::cast).and_then(|bin_expr| bin_expr.lhs()) {
             Some(lhs) if lhs.syntax() == node.syntax() => {
                 make::expr_paren(ast::Expr::BlockExpr(body)).clone_for_update().into()
-            }
+            },
             _ => ast::Expr::BlockExpr(body),
         },
     }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn no_args_or_return_value_gets_inlined_without_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_when_incorrect_number_of_parameters_are_provided() {
         cov_mark::check!(inline_call_incorrect_number_of_arguments);
 "#,
         );
     }
-
     #[test]
     fn args_with_side_effects() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_with_multiple_statements() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_with_self_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_val() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generic_method_by_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_ref_mut() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_multi_use_expr_in_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_use_local_in_param() {
         cov_mark::check!(inline_call_inline_locals);
 "#,
         );
     }
-
     #[test]
     fn method_in_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn wraps_closure_in_paren() {
         cov_mark::check!(inline_call_inline_closure);
 "#,
         );
     }
-
     #[test]
     fn inline_single_literal_expr() {
         cov_mark::check!(inline_call_inline_literal);
 "#,
         );
     }
-
     #[test]
     fn inline_emits_type_for_coercion() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_substitutes_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_across_files() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_across_files_with_def_file() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_recursive() {
         cov_mark::check!(inline_into_callers_recursive);
 "#,
         );
     }
-
     #[test]
     fn inline_call_recursive() {
         cov_mark::check!(inline_call_recursive);
 "#,
         );
     }
-
     #[test]
     fn inline_call_field_shorthand() {
         cov_mark::check!(inline_call_inline_direct_field);
 "#,
         );
     }
-
     #[test]
     fn inline_callers_wrapped_in_parentheses() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_wrapped_in_parentheses() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_defined_in_macro() {
         cov_mark::check!(inline_call_defined_in_macro);
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type_but_within_same_impl() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn local_variable_shadowing_callers_argument() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn async_fn_single_expression() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn async_fn_multiple_statements() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn async_fn_with_let_statements() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn inline_call_closure_body() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_call_with_multiple_self_types_eq() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type_in_macros() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_by_reborrow() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_by_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_reference_in_macros() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_into_callers_in_macros_not_applicable() {
         check_assist_not_applicable(