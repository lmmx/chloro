COMPARISON DIFF
============================================================

Original size: 41039 bytes
Chloro size:   39454 bytes
Rustfmt size:  41039 bytes

✗ Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::{
     AstNode, NodeOrToken, SyntaxKind,
     ast::{
-        self, HasArgList, HasGenericArgs, Pat, PathExpr, edit::IndentLevel, edit_in_place::Indent,
+        self, HasArgList, HasGenericArgs, Pat, PathExpr, edit_in_place::Indent, edit::IndentLevel,
     },
     ted,
 };
     assist_context::{AssistContext, Assists},
 };
 
-// Assist: inline_into_callers
-//
-// Inline a function or method body into all of its callers where possible, creating a `let` statement per parameter
-// unless the parameter can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
-// or if the parameter is only accessed inside the function body once.
-// If all calls can be inlined the function will be removed.
-//
-// ```
-// fn print(_: &str) {}
-// fn foo$0(word: &str) {
-//     if !word.is_empty() {
-//         print(word);
-//     }
-// }
-// fn bar() {
-//     foo("안녕하세요");
-//     foo("여러분");
-// }
-// ```
-// ->
-// ```
-// fn print(_: &str) {}
-//
-// fn bar() {
-//     {
-//         let word: &str = "안녕하세요";
-//         if !word.is_empty() {
-//             print(word);
-//         }
-//     };
-//     {
-//         let word: &str = "여러분";
-//         if !word.is_empty() {
-//             print(word);
-//         }
-//     };
-// }
-// ```
 pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let def_file = ctx.file_id();
     let vfs_def_file = ctx.vfs_file_id();
         .partition_map(|either| either)
 }
 
-// Assist: inline_call
-//
-// Inlines a function or method body creating a `let` statement per parameter unless the parameter
-// can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
-// or if the parameter is only accessed inside the function body once.
-//
-// ```
-// # //- minicore: option
-// fn foo(name: Option<&str>) {
-//     let name = name.unwrap$0();
-// }
-// ```
-// ->
-// ```
-// fn foo(name: Option<&str>) {
-//     let name = match name {
-//             Some(val) => val,
-//             None => panic!("called `Option::unwrap()` on a `None` value"),
-//         };
-// }
-// ```
 pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let name_ref: ast::NameRef = ctx.find_node_at_offset()?;
     let call_info = CallInfo::from_name_ref(
     }
 
     let syntax = call_info.node.syntax().clone();
-    acc.add(AssistId::refactor_inline("inline_call"), label, syntax.text_range(), |builder| {
+    acc.add(
+        AssistId::refactor_inline("inline_call"),
+        label,
+        syntax.text_range(),
+        |builder| {
         let replacement = inline(&ctx.sema, file_id, function, &fn_body, &params, &call_info);
         builder.replace_ast(
             match call_info.node {
             },
             replacement,
         );
-    })
+    },
+    )
 }
 
 struct CallInfo {
             let path = segment.syntax().parent().and_then(ast::Path::cast)?;
             let path = path.syntax().parent().and_then(ast::PathExpr::cast)?;
             let call = path.syntax().parent().and_then(ast::CallExpr::cast)?;
-
             Some(CallInfo {
                 arguments: call.arg_list()?.args().collect(),
                 node: ast::CallableExpr::Call(call),
     }
 
     // We should place the following code after last usage of `usages_for_locals`
+
     // because `ted::replace` will change the offset in syntax tree, which makes
+
     // `FileReference` incorrect
+
     if let Some(imp) =
         sema.ancestors_with_macros(fn_body.syntax().clone()).find_map(ast::Impl::cast)
         && !node.syntax().ancestors().any(|anc| &anc == imp.syntax())
     let mut func_let_vars: BTreeSet<String> = BTreeSet::new();
 
     // grab all of the local variable declarations in the function
+
     for stmt in fn_body.statements() {
         if let Some(let_stmt) = ast::LetStmt::cast(stmt.syntax().to_owned()) {
             for has_token in let_stmt.syntax().children_with_tokens() {
     let mut let_stmts = Vec::new();
 
     // Inline parameter expressions or generate `let` statements depending on whether inlining works or not.
+
     for ((pat, param_ty, param), usages, expr) in izip!(params, param_use_nodes, arguments) {
         // izip confuses RA due to our lack of hygiene info currently losing us type info causing incorrect errors
         let usages: &[ast::PathExpr] = &usages;
             .syntax()
             .parent()
             .and_then(ast::BinExpr::cast)
-            .and_then(|bin_expr| bin_expr.lhs())
-        {
+            .and_then(|bin_expr| bin_expr.lhs()) {
             Some(lhs) if lhs.syntax() == node.syntax() => {
                 make::expr_paren(ast::Expr::BlockExpr(body)).clone_for_update().into()
             }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn no_args_or_return_value_gets_inlined_without_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_when_incorrect_number_of_parameters_are_provided() {
         cov_mark::check!(inline_call_incorrect_number_of_arguments);
 "#,
         );
     }
-
     #[test]
     fn args_with_side_effects() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_with_multiple_statements() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_with_self_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_val() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generic_method_by_ref() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn method_by_ref_mut() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_multi_use_expr_in_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn function_use_local_in_param() {
         cov_mark::check!(inline_call_inline_locals);
 "#,
         );
     }
-
     #[test]
     fn method_in_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn wraps_closure_in_paren() {
         cov_mark::check!(inline_call_inline_closure);
 "#,
         );
     }
-
     #[test]
     fn inline_single_literal_expr() {
         cov_mark::check!(inline_call_inline_literal);
 "#,
         );
     }
-
     #[test]
     fn inline_emits_type_for_coercion() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_substitutes_generics() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_across_files() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_across_files_with_def_file() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_callers_recursive() {
         cov_mark::check!(inline_into_callers_recursive);
 "#,
         );
     }
-
     #[test]
     fn inline_call_recursive() {
         cov_mark::check!(inline_call_recursive);
 "#,
         );
     }
-
     #[test]
     fn inline_call_field_shorthand() {
         cov_mark::check!(inline_call_inline_direct_field);
 "#,
         );
     }
-
     #[test]
     fn inline_callers_wrapped_in_parentheses() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_wrapped_in_parentheses() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_defined_in_macro() {
         cov_mark::check!(inline_call_defined_in_macro);
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type_but_within_same_impl() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn local_variable_shadowing_callers_argument() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn async_fn_single_expression() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn async_fn_multiple_statements() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn async_fn_with_let_statements() {
         cov_mark::check!(inline_call_async_fn);
 "#,
         );
     }
-
     #[test]
     fn inline_call_closure_body() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn inline_call_with_multiple_self_types_eq() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_self_type_in_macros() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_by_reborrow() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_by_mut() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_call_with_reference_in_macros() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn inline_into_callers_in_macros_not_applicable() {
         check_assist_not_applicable(