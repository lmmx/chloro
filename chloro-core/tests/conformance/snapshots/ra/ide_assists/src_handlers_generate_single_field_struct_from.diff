COMPARISON DIFF
============================================================

Original size: 27066 bytes
Chloro size:   26376 bytes
Rustfmt size:  27358 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     AssistId,
 };
 
-// Assist: generate_single_field_struct_from
-//
-// Implement From for a single field structure, ignore trivial types.
-//
-// ```
-// # //- minicore: from, phantom_data
-// use core::marker::PhantomData;
-// struct $0Foo<T> {
-//     id: i32,
-//     _phantom_data: PhantomData<T>,
-// }
-// ```
-// ->
-// ```
-// use core::marker::PhantomData;
-// struct Foo<T> {
-//     id: i32,
-//     _phantom_data: PhantomData<T>,
-// }
-//
-// impl<T> From<i32> for Foo<T> {
-//     fn from(id: i32) -> Self {
-//         Self { id, _phantom_data: PhantomData }
-//     }
-// }
-// ```
 pub(crate) fn generate_single_field_struct_from(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         return None;
     }
 
-    let main_field_name = names
-        .as_ref()
-        .map_or(TokenText::borrowed("value"), |names| {
-            names[main_field_i].text()
-        });
+    let main_field_name =
+        names.as_ref().map_or(TokenText::borrowed("value"), |names| names[main_field_i].text());
     let main_field_ty = types[main_field_i].clone();
 
     acc.add(
         "Generate single field `From`",
         strukt.syntax().text_range(),
         |builder| {
-            let indent = strukt.indent_level();
-            let ty_where_clause = strukt.where_clause();
-            let type_gen_params = strukt.generic_param_list();
-            let type_gen_args = type_gen_params
-                .as_ref()
-                .map(|params| params.to_generic_args());
-            let trait_gen_args = Some(make::generic_arg_list([ast::GenericArg::TypeArg(
+        let indent = strukt.indent_level();
+        let ty_where_clause = strukt.where_clause();
+        let type_gen_params = strukt.generic_param_list();
+        let type_gen_args = type_gen_params.as_ref().map(|params| params.to_generic_args());
+        let trait_gen_args = Some(make::generic_arg_list([ast::GenericArg::TypeArg(
                 make::type_arg(main_field_ty.clone()),
             )]));
-
-            let ty = make::ty(&strukt_name.text());
-
-            let constructor =
+        let ty = make::ty(&strukt_name.text());
+        let constructor =
                 make_adt_constructor(names.as_deref(), constructors, &main_field_name);
-            let body = make::block_expr([], Some(constructor));
-
-            let fn_ = make::fn_(
+        let body = make::block_expr([], Some(constructor));
+        let fn_ = make::fn_(
                 None,
                 None,
                 make::name("from"),
                 false,
             )
             .indent(1.into());
-
-            let cfg_attrs = strukt.attrs().filter(|attr| {
-                attr.as_simple_call()
-                    .is_some_and(|(name, _arg)| name == "cfg")
-            });
-
-            let impl_ = make::impl_trait(
+        let cfg_attrs = strukt
+                .attrs()
+                .filter(|attr| attr.as_simple_call().is_some_and(|(name, _arg)| name == "cfg"));
+        let impl_ = make::impl_trait(
                 cfg_attrs,
                 false,
                 None,
                 None,
             )
             .clone_for_update();
-
-            impl_.get_or_create_assoc_item_list().add_item(fn_.into());
-            let impl_ = impl_.indent(indent);
-
-            let mut edit = builder.make_editor(strukt.syntax());
-
-            edit.insert_all(
+        impl_.get_or_create_assoc_item_list().add_item(fn_.into());
+        let impl_ = impl_.indent(indent);
+        let mut edit = builder.make_editor(strukt.syntax());
+        edit.insert_all(
                 Position::after(strukt.syntax()),
                 vec![
                     make::tokens::whitespace(&format!("\n\n{indent}")).syntax_element(),
                     impl_.syntax().syntax_element(),
                 ],
             );
-
-            builder.add_file_edits(ctx.vfs_file_id(), edit);
-        },
+        builder.add_file_edits(ctx.vfs_file_id(), edit);
+    },
     )
 }
 
     types: &[ast::Type],
 ) -> Vec<Option<ast::Expr>> {
     let (db, sema) = (ctx.db(), &ctx.sema);
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(module.krate()));
-    types
-        .iter()
-        .map(|ty| {
-            let ty = sema.resolve_type(ty)?;
-            if ty.is_unit() {
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
+    types.iter().map(|ty| {
+        let ty = sema.resolve_type(ty)?;
+        if ty.is_unit() {
                 return Some(make::expr_tuple([]).into());
             }
-            let item_in_ns = ModuleDef::Adt(ty.as_adt()?).into();
-            let edition = module.krate().edition(db);
-
-            let ty_path = module.find_path(db, item_for_path_search(db, item_in_ns)?, cfg)?;
-
-            use_trivial_constructor(db, mod_path_to_ast(&ty_path, edition), &ty, edition)
-        })
-        .collect()
+        let item_in_ns = ModuleDef::Adt(ty.as_adt()?).into();
+        let edition = module.krate().edition(db);
+        let ty_path = module.find_path(db, item_for_path_search(db, item_in_ns)?, cfg)?;
+        use_trivial_constructor(db, mod_path_to_ast(&ty_path, edition), &ty, edition)
+    }).collect(
+    )
 }
 
 fn get_fields(strukt: &ast::Struct) -> Option<(Option<Vec<ast::Name>>, Vec<ast::Type>)> {
     Some(match strukt.kind() {
         ast::StructKind::Unit => return None,
         ast::StructKind::Record(fields) => {
-            let names = fields
-                .fields()
-                .map(|field| field.name())
-                .collect::<Option<_>>()?;
-            let types = fields
-                .fields()
-                .map(|field| field.ty())
-                .collect::<Option<_>>()?;
+            let names = fields.fields().map(|field| field.name()).collect::<Option<_>>()?;
+            let types = fields.fields().map(|field| field.ty()).collect::<Option<_>>()?;
             (Some(names), types)
-        }
-        ast::StructKind::Tuple(fields) => (
-            None,
-            fields
-                .fields()
-                .map(|field| field.ty())
-                .collect::<Option<_>>()?,
-        ),
+        },
+        ast::StructKind::Tuple(fields) => {
+            (None, fields.fields().map(|field| field.ty()).collect::<Option<_>>()?)
+        },
     })
 }
 
     let field_ty = strukt.fields(db).get(main_field_i)?.ty(db);
     let struct_ty = strukt.ty(db);
     tracing::debug!(?strukt, ?field_ty, ?struct_ty);
-    struct_ty
-        .impls_trait(infcx, from_trait, &[field_ty])
-        .then_some(())
+    struct_ty.impls_trait(infcx, from_trait, &[field_ty]).then_some(())
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::generate_single_field_struct_from;
-
     #[test]
     fn works() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn cfgs() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn indent() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn where_clause_indent() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn generics() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn tuple() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn trivial() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn unit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn invalid_multiple_main_field() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn exists_other_from() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn exists_from() {
         check_assist_not_applicable(