COMPARISON DIFF
============================================================

Original size: 27066 bytes
Chloro size:   27054 bytes
Rustfmt size:  27354 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
         return None;
     }
 
-    let main_field_name = names
-        .as_ref()
-        .map_or(TokenText::borrowed("value"), |names| {
-            names[main_field_i].text()
-        });
+    let main_field_name =
+        names.as_ref().map_or(TokenText::borrowed("value"), |names| names[main_field_i].text());
     let main_field_ty = types[main_field_i].clone();
 
     acc.add(
             let indent = strukt.indent_level();
             let ty_where_clause = strukt.where_clause();
             let type_gen_params = strukt.generic_param_list();
-            let type_gen_args = type_gen_params
-                .as_ref()
-                .map(|params| params.to_generic_args());
+            let type_gen_args = type_gen_params.as_ref().map(|params| params.to_generic_args());
             let trait_gen_args = Some(make::generic_arg_list([ast::GenericArg::TypeArg(
                 make::type_arg(main_field_ty.clone()),
             )]));
             )
             .indent(1.into());
 
-            let cfg_attrs = strukt.attrs().filter(|attr| {
-                attr.as_simple_call()
-                    .is_some_and(|(name, _arg)| name == "cfg")
-            });
+            let cfg_attrs = strukt
+                .attrs()
+                .filter(|attr| attr.as_simple_call().is_some_and(|(name, _arg)| name == "cfg"));
 
             let impl_ = make::impl_trait(
                 cfg_attrs,
     types: &[ast::Type],
 ) -> Vec<Option<ast::Expr>> {
     let (db, sema) = (ctx.db(), &ctx.sema);
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(module.krate()));
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
     types
         .iter()
         .map(|ty| {
     Some(match strukt.kind() {
         ast::StructKind::Unit => return None,
         ast::StructKind::Record(fields) => {
-            let names = fields
-                .fields()
-                .map(|field| field.name())
-                .collect::<Option<_>>()?;
-            let types = fields
-                .fields()
-                .map(|field| field.ty())
-                .collect::<Option<_>>()?;
+            let names = fields.fields().map(|field| field.name()).collect::<Option<_>>()?;
+            let types = fields.fields().map(|field| field.ty()).collect::<Option<_>>()?;
             (Some(names), types)
         }
-        ast::StructKind::Tuple(fields) => (
-            None,
-            fields
-                .fields()
-                .map(|field| field.ty())
-                .collect::<Option<_>>()?,
-        ),
+        ast::StructKind::Tuple(fields) => {
+            (None, fields.fields().map(|field| field.ty()).collect::<Option<_>>()?)
+        }
     })
 }
 
     let field_ty = strukt.fields(db).get(main_field_i)?.ty(db);
     let struct_ty = strukt.ty(db);
     tracing::debug!(?strukt, ?field_ty, ?struct_ty);
-    struct_ty
-        .impls_trait(infcx, from_trait, &[field_ty])
-        .then_some(())
+    struct_ty.impls_trait(infcx, from_trait, &[field_ty]).then_some(())
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::generate_single_field_struct_from;
-
     #[test]
     fn works() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn cfgs() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn indent() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn where_clause_indent() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn generics() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn tuple() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn trivial() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn unit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn invalid_multiple_main_field() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn exists_other_from() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn exists_from() {
         check_assist_not_applicable(