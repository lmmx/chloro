COMPARISON DIFF
============================================================

Original size: 8077 bytes
Chloro size:   7853 bytes
Rustfmt size:  8186 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: move_module_to_file
-//
-// Moves inline module's contents to a separate file.
-//
-// ```
-// mod $0foo {
-//     fn t() {}
-// }
-// ```
-// ->
-// ```
-// mod foo;
-// ```
 pub(crate) fn move_module_to_file(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let module_ast = ctx.find_node_at_offset::<ast::Module>()?;
     let module_items = module_ast.item_list()?;
         "Extract module to file",
         target,
         |builder| {
-            let path = {
+        let path = {
                 let mut buf = String::from("./");
                 let db = ctx.db();
                 match parent_module.name(db) {
                 }
                 buf
             };
-            let contents = {
+        let contents = {
                 let items = module_items.dedent(IndentLevel(1)).to_string();
-                let mut items = items
-                    .trim_start_matches('{')
-                    .trim_end_matches('}')
-                    .trim()
-                    .to_owned();
+                let mut items =
+                    items.trim_start_matches('{').trim_end_matches('}').trim().to_owned();
                 if !items.is_empty() {
                     items.push('\n');
                 }
                 items
             };
-
-            let buf = format!("mod {module_name};");
-
-            let replacement_start = match module_ast.mod_token() {
+        let buf = format!("mod {module_name};");
+        let replacement_start = match module_ast.mod_token() {
                 Some(mod_token) => mod_token.text_range(),
                 None => module_ast.syntax().text_range(),
             }
             .start();
-
-            builder.replace(
+        builder.replace(
                 TextRange::new(replacement_start, module_ast.syntax().text_range().end()),
                 buf,
             );
-
-            let dst = AnchoredPathBuf {
-                anchor: ctx.vfs_file_id(),
-                path,
-            };
-            builder.create_file(dst, contents);
-        },
+        let dst = AnchoredPathBuf { anchor: ctx.vfs_file_id(), path };
+        builder.create_file(dst, contents);
+    },
     )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn extract_with_specified_path_attr() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_from_root() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_from_submodule() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_from_mod_rs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_public() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_public_crate() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn available_before_curly() {
         cov_mark::check!(available_before_curly);
         check_assist_not_applicable(move_module_to_file, r#"mod m { $0 }"#);
     }
-
     #[test]
     fn keep_outer_comments_and_attributes() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_nested() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn extract_mod_with_raw_ident() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_r_mod() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_r_mod_from_mod_rs() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn extract_nested_r_mod() {
         check_assist(