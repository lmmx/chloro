COMPARISON DIFF
============================================================

Original size: 6719 bytes
Chloro size:   6084 bytes
Rustfmt size:  6719 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use ide_db::{famous_defs::FamousDefs, traits::resolve_target_trait};
 use syntax::ast::edit::IndentLevel;
-use syntax::ast::{self, AstNode, HasGenericArgs, HasName, make};
+use syntax::ast::{self, make, AstNode, HasGenericArgs, HasName};
 use syntax::syntax_editor::{Element, Position};
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: convert_from_to_tryfrom
-//
-// Converts a From impl to a TryFrom impl, wrapping returns in `Ok`.
-//
-// ```
-// # //- minicore: from
-// impl $0From<usize> for Thing {
-//     fn from(val: usize) -> Self {
-//         Thing {
-//             b: val.to_string(),
-//             a: val
-//         }
-//     }
-// }
-// ```
-// ->
-// ```
-// impl TryFrom<usize> for Thing {
-//     type Error = ${0:()};
-//
-//     fn try_from(val: usize) -> Result<Self, Self::Error> {
-//         Ok(Thing {
-//             b: val.to_string(),
-//             a: val
-//         })
-//     }
-// }
-// ```
 pub(crate) fn convert_from_to_tryfrom(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let impl_ = ctx.find_node_at_offset::<ast::Impl>()?;
     let trait_ty = impl_.trait_()?;
         "Convert From to TryFrom",
         impl_.syntax().text_range(),
         |builder| {
-            let mut editor = builder.make_editor(impl_.syntax());
-            editor.replace(
+        let mut editor = builder.make_editor(impl_.syntax());
+        editor.replace(
                 trait_ty.syntax(),
                 make::ty(&format!("TryFrom<{from_type}>")).syntax().clone_for_update(),
             );
-            editor.replace(
+        editor.replace(
                 from_fn_return_type.syntax(),
                 make::ty("Result<Self, Self::Error>").syntax().clone_for_update(),
             );
-            editor
+        editor
                 .replace(from_fn_name.syntax(), make::name("try_from").syntax().clone_for_update());
-            editor.replace(
+        editor.replace(
                 tail_expr.syntax(),
                 wrap_ok(tail_expr.clone()).syntax().clone_for_update(),
             );
-
-            for r in return_exprs {
+        for r in return_exprs {
                 let t = r.expr().unwrap_or_else(make::ext::expr_unit);
                 editor.replace(t.syntax(), wrap_ok(t.clone()).syntax().clone_for_update());
             }
-
-            let error_type = ast::AssocItem::TypeAlias(make::ty_alias(
+        let error_type = ast::AssocItem::TypeAlias(make::ty_alias(
                 None,
                 "Error",
                 None,
                 Some((make::ty_unit(), None)),
             ))
             .clone_for_update();
-
-            if let Some(cap) = ctx.config.snippet_cap
+        if let Some(cap) = ctx.config.snippet_cap
                 && let ast::AssocItem::TypeAlias(type_alias) = &error_type
                 && let Some(ty) = type_alias.ty()
             {
                 let placeholder = builder.make_placeholder_snippet(cap);
                 editor.add_annotation(ty.syntax(), placeholder);
             }
-
-            let indent = IndentLevel::from_token(&associated_l_curly) + 1;
-            editor.insert_all(
+        let indent = IndentLevel::from_token(&associated_l_curly) + 1;
+        editor.insert_all(
                 Position::after(associated_l_curly),
                 vec![
                     make::tokens::whitespace(&format!("\n{indent}")).syntax_element(),
                     make::tokens::whitespace("\n").syntax_element(),
                 ],
             );
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
     make::expr_call(
         make::expr_path(make::ext::ident_path("Ok")),
         make::arg_list(std::iter::once(expr)),
+    ).into(
     )
-    .into()
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn converts_from_to_tryfrom() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn converts_from_to_tryfrom_nested_type() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn converts_from_to_tryfrom_preserves_lifetimes() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn other_trait_not_applicable() {
         check_assist_not_applicable(