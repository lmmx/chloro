COMPARISON DIFF
============================================================

Original size: 11517 bytes
Chloro size:   11241 bytes
Rustfmt size:  11571 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     EditionedFileId, RootDatabase,
 };
 use syntax::{
-    ast::{self, make, HasGenericParams, HasName, HasTypeBounds, Name, NameLike, PathType},
+    ast::{self, HasGenericParams, HasName, HasTypeBounds, Name, NameLike, PathType, make},
     match_ast, AstNode,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: replace_named_generic_with_impl
-//
-// Replaces named generic with an `impl Trait` in function argument.
-//
-// ```
-// fn new<P$0: AsRef<Path>>(location: P) -> Self {}
-// ```
-// ->
-// ```
-// fn new(location: impl AsRef<Path>) -> Self {}
-// ```
 pub(crate) fn replace_named_generic_with_impl(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     let type_param = ctx.find_node_at_offset::<ast::TypeParam>()?;
     // returns `P`
     let type_param_name = type_param.name()?;
-
     // The list of type bounds / traits: `AsRef<Path>`
     let type_bound_list = type_param.type_bound_list()?;
-
     let fn_ = type_param.syntax().ancestors().find_map(ast::Fn::cast)?;
     let param_list_text_range = fn_.param_list()?.syntax().text_range();
-
     let type_param_hir_def = ctx.sema.to_def(&type_param)?;
     let type_param_def = Definition::GenericParam(hir::GenericParam::TypeParam(type_param_hir_def));
-
     // get all usage references for the type param
     let usage_refs = find_usages(&ctx.sema, &fn_, type_param_def, ctx.file_id());
     if usage_refs.is_empty() {
         return None;
     }
-
     // All usage references need to be valid (inside the function param list)
     if !check_valid_usages(&usage_refs, param_list_text_range) {
         return None;
     }
-
     let mut path_types_to_replace = Vec::new();
     for (_a, refs) in usage_refs.iter() {
         for usage_ref in refs {
             path_types_to_replace.push(param_node);
         }
     }
-
     let target = type_param.syntax().text_range();
-
     acc.add(
         AssistId::refactor_rewrite("replace_named_generic_with_impl"),
         "Replace named generic with impl trait",
     type_param_name: &Name,
     param: &NameLike,
 ) -> Option<PathType> {
-    let path_type = sema
-        .ancestors_with_macros(param.syntax().clone())
-        .find_map(ast::PathType::cast)?;
-
+    let path_type =
+        sema.ancestors_with_macros(param.syntax().clone()).find_map(ast::PathType::cast)?;
     // Ignore any path types that look like `P::Assoc`
     if path_type.path()?.as_single_name_ref()?.text() != type_param_name.text() {
         return None;
     }
-
     let ancestors = sema.ancestors_with_macros(path_type.syntax().clone());
-
     let mut in_generic_arg_list = false;
     let mut is_associated_type = false;
-
     // walking the ancestors checks them in a heuristic way until the `Fn` node is reached.
     for ancestor in ancestors {
         match_ast! {
             }
         }
     }
-
     None
 }
 
     type_param_def: Definition,
     file_id: EditionedFileId,
 ) -> UsageSearchResult {
-    let file_range = FileRange {
-        file_id,
-        range: fn_.syntax().text_range(),
-    };
-    type_param_def
-        .usages(sema)
-        .in_scope(&SearchScope::file_range(file_range))
-        .all()
+    let file_range = FileRange { file_id, range: fn_.syntax().text_range() };
+    type_param_def.usages(sema).in_scope(&SearchScope::file_range(file_range)).all()
 }
 
-fn check_valid_usages(usages: &UsageSearchResult, param_list_range: TextRange) -> bool {
+fn check_valid_usages(
+    usages: &UsageSearchResult,
+    param_list_range: TextRange,
+) -> bool {
     usages
         .iter()
         .flat_map(|(_, usage_refs)| usage_refs)
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn replace_generic_moves_into_function() {
         check_assist(
             r#"fn new(input: impl ToString) -> Self {}"#,
         );
     }
-
     #[test]
     fn replace_generic_with_inner_associated_type() {
         check_assist(
             r#"fn new(input: impl AsRef<Path>) -> Self {}"#,
         );
     }
-
     #[test]
     fn replace_generic_trait_applies_to_all_matching_params() {
         check_assist(
             r#"fn new(a: impl ToString, b: impl ToString) -> Self {}"#,
         );
     }
-
     #[test]
     fn replace_generic_trait_applies_to_generic_arguments_in_params() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_when_one_param_type_is_invalid() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_when_referenced_in_where_clause() {
         check_assist_not_applicable(
             r#"fn foo<P$0: Trait, I>() where I: FromRef<P> {}"#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_when_used_with_type_alias() {
         check_assist_not_applicable(
             r#"fn foo<P$0: Trait>(p: <P as Trait>::Assoc) {}"#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_when_used_as_argument_in_outer_trait_alias() {
         check_assist_not_applicable(
             r#"fn foo<P$0: Trait>(_: <() as OtherTrait<P>>::Assoc) {}"#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_with_inner_associated_type() {
         check_assist_not_applicable(
             r#"fn foo<P$0: Trait>(_: P::Assoc) {}"#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_when_passed_into_outer_impl_trait() {
         check_assist_not_applicable(
             r#"fn foo<P$0: Trait>(_: impl OtherTrait<P>) {}"#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_when_used_in_passed_function_parameter() {
         check_assist_not_applicable(
             r#"fn foo<P$0: Trait>(_: &dyn Fn(P)) {}"#,
         );
     }
-
     #[test]
     fn replace_generic_with_multiple_generic_params() {
         check_assist(
             r#"fn new<A: Send, C: Debug>(a: A, b: impl ToString, c: C) -> Self {}"#,
         );
     }
-
     #[test]
     fn replace_generic_with_multiple_trait_bounds() {
         check_assist(
             r#"fn new(p: impl Send + Sync) -> Self {}"#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_if_param_used_as_return_type() {
         check_assist_not_applicable(
             r#"fn new<P$0: Send + Sync>(p: P) -> P {}"#,
         );
     }
-
     #[test]
     fn replace_generic_not_applicable_if_param_used_in_fn_body() {
         check_assist_not_applicable(
             r#"fn new<P$0: ToString>(p: P) { let x: &dyn P = &O; }"#,
         );
     }
-
     #[test]
     fn replace_generic_ignores_another_function_with_same_param_type() {
         check_assist(