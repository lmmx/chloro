COMPARISON DIFF
============================================================

Original size: 53759 bytes
Chloro size:   53248 bytes
Rustfmt size:  53759 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use std::{iter::once, ops::RangeInclusive};
 
 use hir::{HasSource, ModuleSource};
 use ide_db::{
-    FileId, FxHashMap, FxHashSet,
     assists::AssistId,
     defs::{Definition, NameClass, NameRefClass},
     search::{FileReference, SearchScope},
+    FileId, FxHashMap, FxHashSet,
 };
 use itertools::Itertools;
 use smallvec::SmallVec;
 use syntax::{
-    AstNode,
+    algo::find_node_at_range,
+    ast::{self, edit::{AstNodeEdit, IndentLevel}, make, HasVisibility},
+    match_ast, ted, AstNode,
     SyntaxKind::{self, WHITESPACE},
     SyntaxNode, TextRange, TextSize,
-    algo::find_node_at_range,
-    ast::{
-        self, HasVisibility,
-        edit::{AstNodeEdit, IndentLevel},
-        make,
-    },
-    match_ast, ted,
 };
 
 use crate::{AssistContext, Assists};
-
 use super::remove_unused_param::range_to_remove;
 
-// Assist: extract_module
-//
-// Extracts a selected region as separate module. All the references, visibility and imports are
-// resolved.
-//
-// ```
-// $0fn foo(name: i32) -> i32 {
-//     name + 1
-// }$0
-//
-// fn bar(name: i32) -> i32 {
-//     name + 2
-// }
-// ```
-// ->
-// ```
-// mod modname {
-//     pub(crate) fn foo(name: i32) -> i32 {
-//         name + 1
-//     }
-// }
-//
-// fn bar(name: i32) -> i32 {
-//     name + 2
-// }
-// ```
 pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     if ctx.has_empty_selection() {
         return None;
     let old_items: Vec<_> = module.use_items.iter().chain(&module.body_items).cloned().collect();
 
     // If the selection is inside impl block, we need to place new module outside impl block,
-    // as impl blocks cannot contain modules
 
+    // as impl blocks cannot contain modules
     let mut impl_parent: Option<ast::Impl> = None;
     let mut impl_child_count: usize = 0;
     if let Some(parent_assoc_list) = module.body_items[0].syntax().parent()
         &self,
         ctx: &AssistContext<'_>,
         replace_range: TextRange,
-    ) -> (FxHashMap<FileId, Vec<(TextRange, String)>>, Vec<SyntaxNode>, FxHashMap<TextSize, ast::Use>)
-    {
+    ) -> (FxHashMap<FileId, Vec<(TextRange, String)>>, Vec<SyntaxNode>, FxHashMap<TextSize, ast::Use>) {
         let mut adt_fields = Vec::new();
         let mut refs: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();
         // use `TextSize` as key to avoid repeated use stmts
         let mut use_stmts_to_be_inserted = FxHashMap::default();
 
         //Here impl is not included as each item inside impl will be tied to the parent of
-        //implementing block(a struct, enum, etc), if the parent is in selected module, it will
-        //get updated by ADT section given below or if it is not, then we dont need to do any operation
 
+        //implementing block(a struct, enum, etc), if the parent is in selected module, it will
+
+        //get updated by ADT section given below or if it is not, then we dont need to do any operation
         for item in &self.body_items {
             match_ast! {
                 match (item.syntax()) {
                     _ => true,
                 }
             });
-
             add_change_vis(vis, item);
         }
     }
         //- Def is outside: Import it inside with super
 
         //Exists inside selection but not outside -> Check for the import of it in original module,
-        //get the use_tree_str, reconstruct the use stmt in new module
 
+        //get the use_tree_str, reconstruct the use stmt in new module
         let mut import_path_to_be_removed: Option<TextRange> = None;
         if uses_exist_in_sel && uses_exist_out_sel {
             //Changes to be made only inside new module
 }
 
 fn add_change_vis(vis: Option<ast::Visibility>, node_or_token_opt: Option<syntax::SyntaxElement>) {
-    if vis.is_none()
-        && let Some(node_or_token) = node_or_token_opt
-    {
+    if vis.is_none() && let Some(node_or_token) = node_or_token_opt {
         let pub_crate_vis = make::visibility_pub_crate().clone_for_update();
         ted::insert(ted::Position::before(node_or_token), pub_crate_vis.syntax());
     }
 }
 
 fn indent_range_before_given_node(node: &SyntaxNode) -> Option<TextRange> {
-    node.siblings_with_tokens(syntax::Direction::Prev)
-        .find(|x| x.kind() == WHITESPACE)
-        .map(|x| x.text_range())
+    node.siblings_with_tokens(syntax::Direction::Prev).find(|x| x.kind() == WHITESPACE).map(
+        |x| x.text_range(),
+    )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_not_applicable_without_selection() {
         check_assist_not_applicable(
             ",
         )
     }
-
     #[test]
     fn test_extract_module() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_extract_module_for_function_only() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_extract_module_for_impl_having_corresponding_adt_in_selection() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_import_resolve_when_its_only_inside_selection() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_import_resolve_when_its_inside_and_outside_selection_and_source_not_in_same_mod() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_import_resolve_when_its_inside_and_outside_selection_and_source_is_in_same_mod() {
         check_assist(
             ",
         )
     }
-
     #[test]
-    fn test_extract_module_for_corresponding_adt_of_impl_present_in_same_mod_but_not_in_selection()
-    {
+    fn test_extract_module_for_corresponding_adt_of_impl_present_in_same_mod_but_not_in_selection(
+    ) {
         check_assist(
             extract_module,
             r"
             ",
         )
     }
-
     #[test]
-    fn test_extract_module_for_impl_not_having_corresponding_adt_in_selection_and_not_in_same_mod_but_with_super()
-     {
+    fn test_extract_module_for_impl_not_having_corresponding_adt_in_selection_and_not_in_same_mod_but_with_super(
+    ) {
         check_assist(
             extract_module,
             r"
             ",
         )
     }
-
     #[test]
     fn test_import_resolve_for_trait_bounds_on_function() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_extract_module_for_module() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_extract_module_with_multiple_files() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_extract_module_macro_rules() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_do_not_apply_visibility_modifier_to_trait_impl_items() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_if_inside_impl_block_generate_module_outside() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn test_if_inside_impl_block_generate_module_outside_but_impl_block_having_one_child() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn test_issue_11766() {
         //https://github.com/rust-lang/rust-analyzer/issues/11766
         ",
         )
     }
-
     #[test]
     fn test_issue_12790() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn test_merge_multiple_intersections() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_remove_import_path_inside_selection() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_miss_select_item() {
         check_assist(