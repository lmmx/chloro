COMPARISON DIFF
============================================================

Original size: 23615 bytes
Chloro size:   22879 bytes
Rustfmt size:  23945 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     SyntaxKind,
 };
 
-use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, Assists};
+use crate::{AssistContext, AssistId, Assists, assist_context::SourceChangeBuilder};
 
-// Assist: convert_named_struct_to_tuple_struct
-//
-// Converts struct with named fields to tuple struct, and analogously for enum variants with named
-// fields.
-//
-// ```
-// struct Point$0 { x: f32, y: f32 }
-//
-// impl Point {
-//     pub fn new(x: f32, y: f32) -> Self {
-//         Point { x, y }
-//     }
-//
-//     pub fn x(&self) -> f32 {
-//         self.x
-//     }
-//
-//     pub fn y(&self) -> f32 {
-//         self.y
-//     }
-// }
-// ```
-// ->
-// ```
-// struct Point(f32, f32);
-//
-// impl Point {
-//     pub fn new(x: f32, y: f32) -> Self {
-//         Point(x, y)
-//     }
-//
-//     pub fn x(&self) -> f32 {
-//         self.0
-//     }
-//
-//     pub fn y(&self) -> f32 {
-//         self.1
-//     }
-// }
-// ```
 pub(crate) fn convert_named_struct_to_tuple_struct(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         .find_node_at_offset::<ast::Struct>()
         .map(Either::Left)
         .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;
-    let field_list = strukt_or_variant
-        .as_ref()
-        .either(|s| s.field_list(), |v| v.field_list())?;
+    let field_list = strukt_or_variant.as_ref().either(|s| s.field_list(), |v| v.field_list())?;
 
     if ctx.offset() > field_list.syntax().text_range().start() {
         // Assist could be distracting after the braces
         let mut editor = SyntaxEditor::new(field.syntax().clone());
         editor.insert_all(
             Position::first_child_of(field.syntax()),
-            f.attrs()
-                .map(|attr| attr.syntax().clone_subtree().clone_for_update().into())
-                .collect(),
+            f.attrs().map(|attr| attr.syntax().clone_subtree().clone_for_update().into()).collect(),
         );
         let field_syntax = editor.finish().new_root().clone();
         let field = ast::TupleField::cast(field_syntax)?;
             where_clause.push(';');
 
             edit.delete(w.syntax().text_range());
-            edit.insert(
-                record_fields_text_range.end(),
-                ast::make::tokens::single_newline().text(),
-            );
+            edit.insert(record_fields_text_range.end(), ast::make::tokens::single_newline().text());
             edit.insert(record_fields_text_range.end(), where_clause);
-            edit.insert(
-                record_fields_text_range.end(),
-                ast::make::tokens::single_newline().text(),
-            );
+            edit.insert(record_fields_text_range.end(), ast::make::tokens::single_newline().text());
 
             if let Some(tok) = strukt
                 .generic_param_list()
     // First check if it's the last semgnet of a path that directly belongs to a record
     // expression/pattern.
     let name_ref = r.name.as_name_ref()?;
-    let path_segment = name_ref
-        .syntax()
-        .parent()
-        .and_then(ast::PathSegment::cast)?;
+    let path_segment = name_ref.syntax().parent().and_then(ast::PathSegment::cast)?;
     // A `PathSegment` always belongs to a `Path`, so there's at least one `Path` at this point.
-    let full_path = path_segment
-        .syntax()
-        .parent()?
-        .ancestors()
-        .map_while(ast::Path::cast)
-        .last()?;
+    let full_path =
+        path_segment.syntax().parent()?.ancestors().map_while(ast::Path::cast).last()?;
 
     if full_path.segment()?.name_ref()? != *name_ref {
         // `name_ref` isn't the last segment of the path, so `full_path` doesn't point to the
             for r in refs {
                 if let Some(name_ref) = r.name.as_name_ref() {
                     // Only edit the field reference if it's part of a `.field` access
-                    if name_ref
-                        .syntax()
-                        .parent()
-                        .and_then(ast::FieldExpr::cast)
-                        .is_some()
-                    {
+                    if name_ref.syntax().parent().and_then(ast::FieldExpr::cast).is_some() {
                         edit.replace(r.range, index.to_string());
                     }
                 }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn not_applicable_other_than_record_struct() {
         check_assist_not_applicable(convert_named_struct_to_tuple_struct, r#"struct Foo$0(u32)"#);
         check_assist_not_applicable(convert_named_struct_to_tuple_struct, r#"struct Foo$0;"#);
     }
-
     #[test]
     fn convert_simple_struct() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_simple_struct_cursor_on_struct_keyword() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_and_rest_pat() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_simple_struct_cursor_on_visibility_keyword() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_referenced_via_self_kw() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_destructured_struct() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_visibility() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_wrapped_references() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_struct_with_multi_file_references() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_struct_with_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_other_than_record_variant() {
         check_assist_not_applicable(
             r#"enum Enum { Variant$0 }"#,
         );
     }
-
     #[test]
     fn convert_simple_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_referenced_via_self_kw() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_destructured_variant() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_with_wrapped_references() {
         check_assist(
 }"#,
         );
     }
-
     #[test]
     fn convert_variant_with_multi_file_references() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn convert_directly_used_variant() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn field_access_inside_macro_call() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn struct_usage_inside_macro_call() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn struct_name_ref_may_not_be_part_of_struct_expr_or_struct_pat() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn fields_with_attrs() {
         check_assist(