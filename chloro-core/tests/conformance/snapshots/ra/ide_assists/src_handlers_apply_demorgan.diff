COMPARISON DIFF
============================================================

Original size: 18486 bytes
Chloro size:   17306 bytes
Rustfmt size:  18486 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::{
     NodeOrToken, SyntaxKind, T,
     ast::{
-        self, AstNode,
-        Expr::BinExpr,
-        HasArgList,
-        prec::{ExprPrecedence, precedence},
+        self, AstNode, Expr::BinExpr, HasArgList, prec::{ExprPrecedence, precedence},
         syntax_factory::SyntaxFactory,
     },
     syntax_editor::{Position, SyntaxEditor},
 
 use crate::{AssistContext, AssistId, Assists, utils::invert_boolean_expression};
 
-// Assist: apply_demorgan
-//
-// Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).
-// This transforms expressions of the form `!l || !r` into `!(l && r)`.
-// This also works with `&&`. This assist can only be applied with the cursor
-// on either `||` or `&&`.
-//
-// ```
-// fn main() {
-//     if x != 4 ||$0 y < 3.14 {}
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     if !(x == 4 && y >= 3.14) {}
-// }
-// ```
 pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let mut bin_expr = if let Some(not) = ctx.find_token_syntax_at_offset(T![!])
         && let Some(NodeOrToken::Node(next)) = not.next_sibling_or_token()
     )
 }
 
-// Assist: apply_demorgan_iterator
-//
-// Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws) to
-// `Iterator::all` and `Iterator::any`.
-//
-// This transforms expressions of the form `!iter.any(|x| predicate(x))` into
-// `iter.all(|x| !predicate(x))` and vice versa. This also works the other way for
-// `Iterator::all` into `Iterator::any`.
-//
-// ```
-// # //- minicore: iterator
-// fn main() {
-//     let arr = [1, 2, 3];
-//     if !arr.into_iter().$0any(|num| num == 4) {
-//         println!("foo");
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let arr = [1, 2, 3];
-//     if arr.into_iter().all(|num| num != 4) {
-//         println!("foo");
-//     }
-// }
-// ```
 pub(crate) fn apply_demorgan_iterator(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let method_call: ast::MethodCallExpr = ctx.find_node_at_offset()?;
     let (name, arg_expr) = validate_method_call_expr(ctx, &method_call)?;
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn demorgan_handles_leq() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_handles_geq() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_turns_and_into_or() {
         check_assist(apply_demorgan, "fn f() { !x &&$0 !x }", "fn f() { !(x || x) }")
     }
-
     #[test]
     fn demorgan_turns_or_into_and() {
         check_assist(apply_demorgan, "fn f() { !x ||$0 !x }", "fn f() { !(x && x) }")
     }
-
     #[test]
     fn demorgan_removes_inequality() {
         check_assist(apply_demorgan, "fn f() { x != x ||$0 !x }", "fn f() { !(x == x && x) }")
     }
-
     #[test]
     fn demorgan_general_case() {
         check_assist(apply_demorgan, "fn f() { x ||$0 x }", "fn f() { !(!x && !x) }")
     }
-
     #[test]
     fn demorgan_multiple_terms() {
         check_assist(apply_demorgan, "fn f() { x ||$0 y || z }", "fn f() { !(!x && !y && !z) }");
         check_assist(apply_demorgan, "fn f() { x || y ||$0 z }", "fn f() { !(!x && !y && !z) }");
     }
-
     #[test]
     fn demorgan_doesnt_apply_with_cursor_not_on_op() {
         check_assist_not_applicable(apply_demorgan, "fn f() { $0 !x || !x }")
     }
-
     #[test]
     fn demorgan_doesnt_double_negation() {
         cov_mark::check!(demorgan_double_negation);
         check_assist(apply_demorgan, "fn f() { !(x ||$0 x) }", "fn f() { !x && !x }")
     }
-
     #[test]
     fn demorgan_doesnt_double_parens() {
         cov_mark::check!(demorgan_double_parens);
         check_assist(apply_demorgan, "fn f() { (x ||$0 x) }", "fn f() { !(!x && !x) }")
     }
-
     #[test]
     fn demorgan_doesnt_hang() {
         check_assist(
             "fn f() { 1 || !(!3 || !4) || 5 }",
         )
     }
-
     #[test]
     fn demorgan_on_not() {
         check_assist(
             "fn f() { !1 && !(3 && 4) && !5 }",
         )
     }
-
     #[test]
     fn demorgan_keep_pars_for_op_precedence() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn demorgan_keep_pars_for_op_precedence2() {
         cov_mark::check!(demorgan_keep_parens_for_op_precedence2);
             "fn f() { (a && (!b || !c); }",
         );
     }
-
     #[test]
     fn demorgan_keep_pars_for_op_precedence3() {
         check_assist(
             "fn f() { (a || (!b || !c); }",
         );
     }
-
     #[test]
     fn demorgan_keeps_pars_in_eq_precedence() {
         check_assist(
             "fn() { let x = a && (b && c); }",
         )
     }
-
     #[test]
     fn demorgan_removes_pars_for_op_precedence2() {
         check_assist(apply_demorgan, "fn f() { (a || !(b ||$0 c); }", "fn f() { (a || !b && !c; }");
     }
-
     #[test]
     fn demorgan_iterator_any_all_reverse() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_all_any() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_multiple_terms() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_double_negation() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_double_parens() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_multiline() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_block_closure() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_wrong_method() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn demorgan_method_call_receiver() {
         check_assist(
             "fn f() { (!(!x && y)).then_some(42) }",
         );
     }
-
     #[test]
     fn demorgan_method_call_receiver_complex() {
         check_assist(
             "fn f() { (!(!(a && b) && !(c && d))).then_some(42) }",
         );
     }
-
     #[test]
     fn demorgan_method_call_receiver_chained() {
         check_assist(