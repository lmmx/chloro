COMPARISON DIFF
============================================================

Original size: 18486 bytes
Chloro size:   17364 bytes
Rustfmt size:  18486 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 use crate::{AssistContext, AssistId, Assists, utils::invert_boolean_expression};
 
-// Assist: apply_demorgan
-//
-// Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).
-// This transforms expressions of the form `!l || !r` into `!(l && r)`.
-// This also works with `&&`. This assist can only be applied with the cursor
-// on either `||` or `&&`.
-//
-// ```
-// fn main() {
-//     if x != 4 ||$0 y < 3.14 {}
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     if !(x == 4 && y >= 3.14) {}
-// }
-// ```
-pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn apply_demorgan(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let mut bin_expr = if let Some(not) = ctx.find_token_syntax_at_offset(T![!])
         && let Some(NodeOrToken::Node(next)) = not.next_sibling_or_token()
         && let Some(paren) = ast::ParenExpr::cast(next)
 
         bin_expr
     };
-
     let op = bin_expr.op_kind()?;
     let op_range = bin_expr.op_token()?.text_range();
-
     // Walk up the tree while we have the same binary operator
     while let Some(parent_expr) = bin_expr.syntax().parent().and_then(ast::BinExpr::cast) {
         match parent_expr.op_kind() {
             _ => break,
         }
     }
-
     let op = bin_expr.op_kind()?;
     let (inv_token, prec) = match op {
         ast::BinaryOp::LogicOp(ast::LogicOp::And) => (SyntaxKind::PIPE2, ExprPrecedence::LOr),
         ast::BinaryOp::LogicOp(ast::LogicOp::Or) => (SyntaxKind::AMP2, ExprPrecedence::LAnd),
         _ => return None,
     };
-
     let make = SyntaxFactory::with_mappings();
-
     let demorganed = bin_expr.clone_subtree();
     let mut editor = SyntaxEditor::new(demorganed.syntax().clone());
     editor.replace(demorganed.op_token()?, make.token(inv_token));
-
     let mut exprs = VecDeque::from([
         (bin_expr.lhs()?, demorganed.lhs()?, prec),
         (bin_expr.rhs()?, demorganed.rhs()?, prec),
     ]);
-
     while let Some((expr, demorganed, prec)) = exprs.pop_front() {
         if let BinExpr(bin_expr) = &expr {
             if let BinExpr(cbin_expr) = &demorganed {
             editor.replace(demorganed.syntax(), inv.syntax());
         }
     }
-
     editor.add_mappings(make.finish_with_mappings());
     let edit = editor.finish();
     let demorganed = ast::Expr::cast(edit.new_root().clone())?;
-
     acc.add_group(
         &GroupLabel("Apply De Morgan's law".to_owned()),
         AssistId::refactor_rewrite("apply_demorgan"),
     )
 }
 
-// Assist: apply_demorgan_iterator
-//
-// Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws) to
-// `Iterator::all` and `Iterator::any`.
-//
-// This transforms expressions of the form `!iter.any(|x| predicate(x))` into
-// `iter.all(|x| !predicate(x))` and vice versa. This also works the other way for
-// `Iterator::all` into `Iterator::any`.
-//
-// ```
-// # //- minicore: iterator
-// fn main() {
-//     let arr = [1, 2, 3];
-//     if !arr.into_iter().$0any(|num| num == 4) {
-//         println!("foo");
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let arr = [1, 2, 3];
-//     if arr.into_iter().all(|num| num != 4) {
-//         println!("foo");
-//     }
-// }
-// ```
-pub(crate) fn apply_demorgan_iterator(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn apply_demorgan_iterator(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let method_call: ast::MethodCallExpr = ctx.find_node_at_offset()?;
     let (name, arg_expr) = validate_method_call_expr(ctx, &method_call)?;
-
     let ast::Expr::ClosureExpr(closure_expr) = arg_expr else { return None };
     let closure_body = closure_expr.body()?.clone_for_update();
-
     let op_range = method_call.syntax().text_range();
     let label = format!("Apply De Morgan's law to `Iterator::{}`", name.text().as_str());
     acc.add_group(
         return None;
     }
     let arg_expr = method_call.arg_list()?.args().next()?;
-
     let sema = &ctx.sema;
-
     let receiver = method_call.receiver()?;
     let it_type = sema.type_of_expr(&receiver)?.adjusted();
     let module = sema.scope(receiver.syntax())?.module();
     let krate = module.krate();
-
     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;
     it_type.impls_trait(sema.db, iter_trait, &[]).then_some((name_ref, arg_expr))
 }
 
-fn tail_cb_impl(editor: &mut SyntaxEditor, make: &SyntaxFactory, e: &ast::Expr) {
+fn tail_cb_impl(
+    editor: &mut SyntaxEditor,
+    make: &SyntaxFactory,
+    e: &ast::Expr,
+) {
     match e {
         ast::Expr::BreakExpr(break_expr) => {
             if let Some(break_expr_arg) = break_expr.expr() {
 }
 
 /// Add bang and parentheses to the expression.
-fn add_bang_paren(make: &SyntaxFactory, expr: ast::Expr) -> ast::Expr {
+fn add_bang_paren(
+    make: &SyntaxFactory,
+    expr: ast::Expr,
+) -> ast::Expr {
     make.expr_prefix(T![!], make.expr_paren(expr).into()).into()
 }
 
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn demorgan_handles_leq() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_handles_geq() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_turns_and_into_or() {
         check_assist(apply_demorgan, "fn f() { !x &&$0 !x }", "fn f() { !(x || x) }")
     }
-
     #[test]
     fn demorgan_turns_or_into_and() {
         check_assist(apply_demorgan, "fn f() { !x ||$0 !x }", "fn f() { !(x && x) }")
     }
-
     #[test]
     fn demorgan_removes_inequality() {
         check_assist(apply_demorgan, "fn f() { x != x ||$0 !x }", "fn f() { !(x == x && x) }")
     }
-
     #[test]
     fn demorgan_general_case() {
         check_assist(apply_demorgan, "fn f() { x ||$0 x }", "fn f() { !(!x && !x) }")
     }
-
     #[test]
     fn demorgan_multiple_terms() {
         check_assist(apply_demorgan, "fn f() { x ||$0 y || z }", "fn f() { !(!x && !y && !z) }");
         check_assist(apply_demorgan, "fn f() { x || y ||$0 z }", "fn f() { !(!x && !y && !z) }");
     }
-
     #[test]
     fn demorgan_doesnt_apply_with_cursor_not_on_op() {
         check_assist_not_applicable(apply_demorgan, "fn f() { $0 !x || !x }")
     }
-
     #[test]
     fn demorgan_doesnt_double_negation() {
         cov_mark::check!(demorgan_double_negation);
         check_assist(apply_demorgan, "fn f() { !(x ||$0 x) }", "fn f() { !x && !x }")
     }
-
     #[test]
     fn demorgan_doesnt_double_parens() {
         cov_mark::check!(demorgan_double_parens);
         check_assist(apply_demorgan, "fn f() { (x ||$0 x) }", "fn f() { !(!x && !x) }")
     }
-
     #[test]
     fn demorgan_doesnt_hang() {
         check_assist(
             "fn f() { 1 || !(!3 || !4) || 5 }",
         )
     }
-
     #[test]
     fn demorgan_on_not() {
         check_assist(
             "fn f() { !1 && !(3 && 4) && !5 }",
         )
     }
-
     #[test]
     fn demorgan_keep_pars_for_op_precedence() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn demorgan_keep_pars_for_op_precedence2() {
         cov_mark::check!(demorgan_keep_parens_for_op_precedence2);
             "fn f() { (a && (!b || !c); }",
         );
     }
-
     #[test]
     fn demorgan_keep_pars_for_op_precedence3() {
         check_assist(
             "fn f() { (a || (!b || !c); }",
         );
     }
-
     #[test]
     fn demorgan_keeps_pars_in_eq_precedence() {
         check_assist(
             "fn() { let x = a && (b && c); }",
         )
     }
-
     #[test]
     fn demorgan_removes_pars_for_op_precedence2() {
         check_assist(apply_demorgan, "fn f() { (a || !(b ||$0 c); }", "fn f() { (a || !b && !c; }");
     }
-
     #[test]
     fn demorgan_iterator_any_all_reverse() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_all_any() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_multiple_terms() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_double_negation() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_double_parens() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_multiline() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_block_closure() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn demorgan_iterator_wrong_method() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn demorgan_method_call_receiver() {
         check_assist(
             "fn f() { (!(!x && y)).then_some(42) }",
         );
     }
-
     #[test]
     fn demorgan_method_call_receiver_complex() {
         check_assist(
             "fn f() { (!(!(a && b) && !(c && d))).then_some(42) }",
         );
     }
-
     #[test]
     fn demorgan_method_call_receiver_chained() {
         check_assist(