COMPARISON DIFF
============================================================

Original size: 27122 bytes
Chloro size:   26659 bytes
Rustfmt size:  27284 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     helpers::mod_path_to_ast,
     imports::import_assets::{ImportCandidate, LocatedImport},
 };
-use syntax::ast::HasGenericArgs;
 use syntax::Edition;
+use syntax::ast::HasGenericArgs;
 use syntax::{
     ast,
     ast::{make, HasArgList},
     AssistId, GroupLabel,
 };
 
-// Assist: qualify_path
-//
-// If the name is unresolved, provides all possible qualified paths for it.
-//
-// ```
-// fn main() {
-//     let map = HashMap$0::new();
-// }
-// # pub mod std { pub mod collections { pub struct HashMap { } } }
-// ```
-// ->
-// ```
-// fn main() {
-//     let map = std::collections::HashMap::new();
-// }
-// # pub mod std { pub mod collections { pub struct HashMap { } } }
-// ```
 pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let (import_assets, syntax_under_caret, expected) = find_importable_node(ctx)?;
     let cfg = ctx.config.import_path_config();
 
-    let mut proposed_imports: Vec<_> = import_assets
-        .search_for_relative_paths(&ctx.sema, cfg)
-        .collect();
+    let mut proposed_imports: Vec<_> =
+        import_assets.search_for_relative_paths(&ctx.sema, cfg).collect();
     if proposed_imports.is_empty() {
         return None;
     }
 
     let range = ctx.sema.original_range(&syntax_under_caret).range;
-    let current_module = ctx
-        .sema
-        .scope(&syntax_under_caret)
-        .map(|scope| scope.module());
+    let current_module = ctx.sema.scope(&syntax_under_caret).map(|scope| scope.module());
 
     let candidate = import_assets.import_candidate();
     let qualify_candidate = match candidate {
     proposed_imports.sort_by(|a, b| a.import_path.cmp(&b.import_path));
     proposed_imports.dedup_by(|a, b| a.import_path == b.import_path);
 
-    let current_edition = current_module
-        .map(|it| it.krate().edition(ctx.db()))
-        .unwrap_or(Edition::CURRENT);
+    let current_edition =
+        current_module.map(|it| it.krate().edition(ctx.db())).unwrap_or(Edition::CURRENT);
     // prioritize more relevant imports
     proposed_imports.sort_by_key(|import| {
         Reverse(super::auto_import::relevance_score(
     }
     Some(())
 }
+
 pub(crate) enum QualifyCandidate<'db> {
     QualifierStart(ast::PathSegment, Option<ast::GenericArgList>),
     UnqualifiedName(Option<ast::GenericArgList>),
         let import = mod_path_to_ast(import, edition);
         match self {
             QualifyCandidate::QualifierStart(segment, generics) => {
-                let generics = generics
-                    .as_ref()
-                    .map_or_else(String::new, ToString::to_string);
+                let generics = generics.as_ref().map_or_else(String::new, ToString::to_string);
                 replacer(format!("{import}{generics}::{segment}"));
-            }
+            },
             QualifyCandidate::UnqualifiedName(generics) => {
-                let generics = generics
-                    .as_ref()
-                    .map_or_else(String::new, ToString::to_string);
+                let generics = generics.as_ref().map_or_else(String::new, ToString::to_string);
                 replacer(format!("{import}{generics}"));
-            }
+            },
             QualifyCandidate::TraitAssocItem(qualifier, segment) => {
                 replacer(format!("<{qualifier} as {import}>::{segment}"));
-            }
+            },
             QualifyCandidate::TraitMethod(db, mcall_expr) => {
                 Self::qualify_trait_method(db, mcall_expr, replacer, import, item);
-            }
+            },
             QualifyCandidate::ImplMethod(db, mcall_expr, hir_fn) => {
                 Self::qualify_fn_call(db, mcall_expr, replacer, import, hir_fn);
-            }
+            },
         }
     }
 
     ) -> Option<()> {
         let receiver = mcall_expr.receiver()?;
         let method_name = mcall_expr.name_ref()?;
-        let generics = mcall_expr
-            .generic_arg_list()
-            .as_ref()
-            .map_or_else(String::new, ToString::to_string);
+        let generics =
+            mcall_expr.generic_arg_list().as_ref().map_or_else(String::new, ToString::to_string);
         let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());
 
         if let Some(self_access) = hir_fn.self_param(db).map(|sp| sp.access(db)) {
     trait_: hir::Trait,
     trait_method_name: &ast::NameRef,
 ) -> Option<hir::Function> {
-    if let Some(hir::AssocItem::Function(method)) =
-        trait_.items(db).into_iter().find(|item: &hir::AssocItem| {
-            item.name(db)
-                .map(|name| name.as_str() == trait_method_name.text().trim_start_matches("r#"))
-                .unwrap_or(false)
-        })
-    {
+    if let Some(hir::AssocItem::Function(method)) = trait_.items(db).into_iter().find(|item: &hir::AssocItem| {
+        item.name(db).map(|name| name.as_str() == trait_method_name.text().trim_start_matches("r#")).unwrap_or(
+            false,
+        )
+    }) {
         Some(method)
     } else {
         None
     match candidate {
         ImportCandidate::Path(candidate) if candidate.qualifier.is_empty() => {
             format!("Qualify as `{}`", import_path.display(db, edition))
-        }
+        },
         _ => format!("Qualify with `{}`", import_path.display(db, edition)),
     }
 }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     use super::*;
-
     #[test]
     fn applicable_when_found_an_import_partial() {
         cov_mark::check!(qualify_path_unqualified_name);
 "#,
         );
     }
-
     #[test]
     fn applicable_when_found_an_import() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn applicable_in_macros() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn applicable_when_found_multiple_imports() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_for_already_imported_types() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_for_types_with_private_paths() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_when_no_imports_found() {
         check_assist_not_applicable(qualify_path, r#"PubStruct$0"#);
     }
-
     #[test]
     fn qualify_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn qualify_macro() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn qualify_path_target() {
         check_assist_target(
             "GroupLabel",
         )
     }
-
     #[test]
     fn not_applicable_when_path_start_is_imported() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_for_imported_function() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn associated_struct_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn associated_struct_const() {
         cov_mark::check!(qualify_path_qualifier_start);
 "#,
         );
     }
-
     #[test]
     fn associated_struct_const_unqualified() {
         // FIXME: non-trait assoc items completion is unsupported yet, see FIXME in the import_assets.rs for more details
 "#,
         );
     }
-
     #[test]
     fn associated_trait_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_for_imported_trait_for_function() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn associated_trait_const() {
         cov_mark::check!(qualify_path_trait_assoc_item);
 "#,
         );
     }
-
     #[test]
     fn not_applicable_for_imported_trait_for_const() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn trait_method() {
         cov_mark::check!(qualify_path_trait_method);
 "#,
         );
     }
-
     #[test]
     fn trait_method_multi_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method_consume() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method_cross_crate() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn assoc_fn_cross_crate() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn assoc_const_cross_crate() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn assoc_fn_as_method_cross_crate() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn private_trait_cross_crate() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_for_imported_trait_for_method() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn dep_import() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn whole_segment() {
         // Tests that only imports whose last segment matches the identifier get suggested.
 ",
         );
     }
-
     #[test]
     fn macro_generated() {
         // Tests that macro-generated items are suggested from external crates.
 ",
         );
     }
-
     #[test]
     fn casing() {
         // Tests that differently cased names don't interfere and we only suggest the matching one.
 ",
         );
     }
-
     #[test]
     fn keep_generic_annotations() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn keep_generic_annotations_leading_colon() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn associated_struct_const_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn associated_trait_const_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn trait_method_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn works_in_derives() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn works_in_use_start() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_in_non_start_use() {
         check_assist_not_applicable(