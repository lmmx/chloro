COMPARISON DIFF
============================================================

Original size: 45288 bytes
Chloro size:   44092 bytes
Rustfmt size:  45288 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Assorted functions shared by several assists.
 
+mod gen_trait_fn_body;
+pub(crate) mod ref_field_expr;
+
 use std::slice;
 
 pub(crate) use gen_trait_fn_body::gen_trait_fn_body;
 use hir::{
+    db::{ExpandDatabase, HirDatabase},
     DisplayTarget, HasAttrs as HirHasAttrs, HirDisplay, InFile, ModuleDef, PathResolution,
     Semantics,
-    db::{ExpandDatabase, HirDatabase},
 };
 use ide_db::{
-    RootDatabase,
     assists::ExprFillDefaultMode,
     famous_defs::FamousDefs,
     path_transform::PathTransform,
     syntax_helpers::{node_ext::preorder_expr, prettify_macro_expansion},
+    RootDatabase,
 };
 use stdx::format_to;
 use syntax::{
-    AstNode, AstToken, Direction, NodeOrToken, SourceFile,
-    SyntaxKind::*,
-    SyntaxNode, SyntaxToken, T, TextRange, TextSize, WalkEvent,
     ast::{
-        self, HasArgList, HasAttrs, HasGenericParams, HasName, HasTypeBounds, Whitespace,
-        edit::{AstNodeEdit, IndentLevel},
-        edit_in_place::AttrsOwnerEdit,
-        make,
-        syntax_factory::SyntaxFactory,
+        edit::{AstNodeEdit, IndentLevel}, edit_in_place::AttrsOwnerEdit, make, self,
+        syntax_factory::SyntaxFactory, HasArgList, HasAttrs, HasGenericParams, HasName,
+        HasTypeBounds, Whitespace,
     },
     syntax_editor::{Removable, SyntaxEditor},
+    AstNode, AstToken, Direction, NodeOrToken, SourceFile,
+    SyntaxKind::*,
+    SyntaxNode, SyntaxToken, TextRange, TextSize, WalkEvent, T,
 };
 
 use crate::{
-    AssistConfig,
     assist_context::{AssistContext, SourceChangeBuilder},
+    AssistConfig,
 };
 
-mod gen_trait_fn_body;
-pub(crate) mod ref_field_expr;
-
 pub(crate) fn unwrap_trivial_block(block_expr: ast::BlockExpr) -> ast::Expr {
     extract_trivial_expression(&block_expr)
         .filter(|expr| !expr.syntax().text().contains_char('\n'))
     {
         return None;
     }
-
     if let Some(expr) = stmt_list.tail_expr() {
         if has_anything_else(expr.syntax()) {
             return None;
             _ => default_methods == DefaultMethods::No,
         })
         .collect();
-
     fn has_def_name(item: &InFile<ast::AssocItem>) -> bool {
         match &item.value {
             ast::AssocItem::Fn(def) => def.name(),
     invert_special_case(make, &expr).unwrap_or_else(|| make.expr_prefix(T![!], expr).into())
 }
 
-// FIXME: Migrate usages of this function to the above function and remove this.
 pub(crate) fn invert_boolean_expression_legacy(expr: ast::Expr) -> ast::Expr {
     invert_special_case_legacy(&expr).unwrap_or_else(|| make::expr_prefix(T![!], expr).into())
 }
 
 pub(crate) fn does_pat_match_variant(pat: &ast::Pat, var: &ast::Pat) -> bool {
     let first_node_text = |pat: &ast::Pat| pat.syntax().first_child().map(|node| node.text());
-
     let pat_head = match pat {
         ast::Pat::IdentPat(bind_pat) => match bind_pat.pat() {
             Some(p) => first_node_text(&p),
         },
         pat => first_node_text(pat),
     };
-
     let var_head = first_node_text(var);
-
     pat_head == var_head
 }
 
     if depth_after_refutable > 1 {
         return true;
     }
-
     match pat {
         ast::Pat::RestPat(_) | ast::Pat::WildcardPat(_) | ast::Pat::RefPat(_) => false,
 
     }
 }
 
-// Uses a syntax-driven approach to find any impl blocks for the struct that
-// exist within the module/file
-//
-// Returns `None` if we've found an existing fn
-//
-// FIXME: change the new fn checking to a more semantic approach when that's more
-// viable (e.g. we process proc macros, etc)
-// FIXME: this partially overlaps with `find_impl_block_*`
-
 /// `find_struct_impl` looks for impl of a struct, but this also has additional feature
 /// where it takes a list of function names and check if they exist inside impl_, if
 /// even one match is found, it returns None.
 ) -> Option<Option<ast::Impl>> {
     let db = ctx.db();
     let module = adt.syntax().parent()?;
-
     let struct_def = ctx.sema.to_def(adt)?;
-
     let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {
         let blk = ctx.sema.to_def(&impl_blk)?;
 
 
         if !(same_ty && not_trait_impl) { None } else { Some(impl_blk) }
     });
-
     if let Some(ref impl_blk) = block
         && has_any_fn(impl_blk, names)
     {
         return None;
     }
-
     Some(block)
 }
 
             }
         }
     }
-
     false
 }
 
 /// Find the end of the `impl` block for the given `ast::Impl`.
-//
-// FIXME: this partially overlaps with `find_struct_impl`
 pub(crate) fn find_impl_block_end(impl_def: ast::Impl, buf: &mut String) -> Option<TextSize> {
     buf.push('\n');
     let end = impl_def
 
 /// Generates the surrounding `impl Type { <code> }` including type and lifetime
 /// parameters.
-// FIXME: migrate remaining uses to `generate_impl`
 pub(crate) fn generate_impl_text(adt: &ast::Adt, code: &str) -> String {
     generate_impl_text_inner(adt, None, true, code)
 }
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-// FIXME: migrate remaining uses to `generate_trait_impl`
 #[allow(dead_code)]
 pub(crate) fn generate_trait_impl_text(adt: &ast::Adt, trait_text: &str, code: &str) -> String {
     generate_impl_text_inner(adt, Some(trait_text), true, code)
 /// and lifetime parameters, with `impl`'s generic parameters' bounds kept as-is.
 ///
 /// This is useful for traits like `From<T>`, since `impl<T> From<T> for U<T>` doesn't require `T: From<T>`.
-// FIXME: migrate remaining uses to `generate_trait_impl_intransitive`
 pub(crate) fn generate_trait_impl_text_intransitive(
     adt: &ast::Adt,
     trait_text: &str,
 
         make::generic_param_list(itertools::chain(lifetime_params, ty_or_const_params))
     });
-
     // FIXME: use syntax::make & mutable AST apis instead
     // `trait_text` and `code` can't be opaque blobs of text
     let mut buf = String::with_capacity(code.len());
-
     // Copy any cfg attrs from the original adt
     buf.push_str("\n\n");
     let cfg_attrs = adt
         .attrs()
         .filter(|attr| attr.as_simple_call().map(|(name, _arg)| name == "cfg").unwrap_or(false));
     cfg_attrs.for_each(|attr| buf.push_str(&format!("{attr}\n")));
-
     // `impl{generic_params} {trait_text} for {name}{generic_params.to_generic_args()}`
     buf.push_str("impl");
     if let Some(generic_params) = &generic_params {
     if let Some(generic_params) = generic_params {
         format_to!(buf, "{}", generic_params.to_generic_args());
     }
-
     match adt.where_clause() {
         Some(where_clause) => {
             format_to!(buf, "\n{where_clause}\n{{\n{code}\n}}");
             format_to!(buf, " {{\n{code}\n}}");
         }
     }
-
     buf
 }
 
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-pub(crate) fn generate_trait_impl(is_unsafe: bool, adt: &ast::Adt, trait_: ast::Type) -> ast::Impl {
+pub(crate) fn generate_trait_impl(
+    is_unsafe: bool,
+    adt: &ast::Adt,
+    trait_: ast::Type,
+) -> ast::Impl {
     generate_impl_inner(is_unsafe, adt, Some(trait_), true, None)
 }
 
     let generic_args =
         generic_params.as_ref().map(|params| params.to_generic_args().clone_for_update());
     let ty = make::ty_path(make::ext::ident_path(&adt.name().unwrap().text()));
-
     let cfg_attrs =
         adt.attrs().filter(|attr| attr.as_simple_call().is_some_and(|(name, _arg)| name == "cfg"));
     match trait_ {
         buf.push('\n');
     }
     buf.push_str(method);
-
     let start_offset = impl_def
         .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))
         .unwrap_or_else(|| {
             buf = generate_impl_text(adt, &buf);
             adt.syntax().text_range().end()
         });
-
     builder.insert(start_offset, buf);
 }
 
 
 #[derive(Debug)]
 enum ReferenceConversionType {
-    // reference can be stripped if the type is Copy
     Copy,
-    // &String -> &str
     AsRefStr,
-    // &Vec<T> -> &[T]
     AsRefSlice,
-    // &Box<T> -> &T
     Dereferenced,
-    // &Option<T> -> Option<&T>
     Option,
-    // &Result<T, E> -> Result<&T, &E>
     Result,
 }
 
                 format!("Result<&{first_type_argument_name}, &{second_type_argument_name}>")
             }
         };
-
         make::ty(&ty)
     }
 
     pub(crate) fn getter(&self, field_name: String) -> ast::Expr {
         let expr = make::expr_field(make::ext::expr_self(), &field_name);
-
         match self.conversion {
             ReferenceConversionType::Copy => expr,
             ReferenceConversionType::AsRefStr
     }
 }
 
-// FIXME: It should return a new hir::Type, but currently constructing new types is too cumbersome
-//        and all users of this function operate on string type names, so they can do the conversion
-//        itself themselves.
 pub(crate) fn convert_reference_type<'db>(
     ty: hir::Type<'db>,
     db: &'db RootDatabase,
         .map(|(conversion, impls_deref)| ReferenceConversion { ty, conversion, impls_deref })
 }
 
-fn could_deref_to_target(ty: &hir::Type<'_>, target: &hir::Type<'_>, db: &dyn HirDatabase) -> bool {
+fn could_deref_to_target(
+    ty: &hir::Type<'_>,
+    target: &hir::Type<'_>,
+    db: &dyn HirDatabase,
+) -> bool {
     let ty_ref = ty.add_reference(hir::Mutability::Shared);
     let target_ref = target.add_reference(hir::Mutability::Shared);
     ty_ref.could_coerce_to(db, &target_ref)
     famous_defs: &FamousDefs<'_, '_>,
 ) -> Option<(ReferenceConversionType, bool)> {
     let str_type = hir::BuiltinType::str().ty(db);
-
     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&str_type))
         .then_some((ReferenceConversionType::AsRefStr, could_deref_to_target(ty, &str_type, db)))
 }
 ) -> Option<(ReferenceConversionType, bool)> {
     let type_argument = ty.type_arguments().next()?;
     let slice_type = hir::Type::new_slice(type_argument);
-
     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&slice_type)).then_some((
         ReferenceConversionType::AsRefSlice,
         could_deref_to_target(ty, &slice_type, db),
     famous_defs: &FamousDefs<'_, '_>,
 ) -> Option<(ReferenceConversionType, bool)> {
     let type_argument = ty.type_arguments().next()?;
-
     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&type_argument))
         .then_some((
             ReferenceConversionType::Dereferenced,
     }
     res
 }
+
 #[test]
 fn test_required_hashes() {
     assert_eq!(0, required_hashes("abc"));
 pub(crate) fn string_suffix(s: &str) -> Option<&str> {
     s.rfind(['"', '\'', '#']).map(|i| &s[i + 1..])
 }
+
 #[test]
 fn test_string_suffix() {
     assert_eq!(Some(""), string_suffix(r#""abc""#));
 pub(crate) fn string_prefix(s: &str) -> Option<&str> {
     s.split_once(['"', '\'', '#']).map(|(prefix, _)| prefix)
 }
+
 #[test]
 fn test_string_prefix() {
     assert_eq!(Some(""), string_prefix(r#""abc""#));
 /// Assumes that the input syntax node is a valid syntax tree.
 pub(crate) fn tt_from_syntax(node: SyntaxNode) -> Vec<NodeOrToken<ast::TokenTree, SyntaxToken>> {
     let mut tt_stack = vec![(None, vec![])];
-
     for element in node.descendants_with_tokens() {
         let NodeOrToken::Token(token) = element else { continue };
 
             }
         }
     }
-
     tt_stack.pop().expect("parent token tree was closed before it was completed").1
 }
 
     is_const
 }
 
-// FIXME: #20460 When hir-ty can analyze the `never` statement at the end of block, remove it
 pub(crate) fn is_never_block(
     sema: &Semantics<'_, RootDatabase>,
     block_expr: &ast::BlockExpr,