COMPARISON DIFF
============================================================

Original size: 45288 bytes
Chloro size:   45271 bytes
Rustfmt size:  45288 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     SyntaxNode, SyntaxToken, T, TextRange, TextSize, WalkEvent,
     ast::{
         self, HasArgList, HasAttrs, HasGenericParams, HasName, HasTypeBounds, Whitespace,
-        edit::{AstNodeEdit, IndentLevel},
-        edit_in_place::AttrsOwnerEdit,
-        make,
+        edit_in_place::AttrsOwnerEdit, edit::{AstNodeEdit, IndentLevel}, make,
         syntax_factory::SyntaxFactory,
     },
     syntax_editor::{Removable, SyntaxEditor},
     false
 }
 
-/// Find the end of the `impl` block for the given `ast::Impl`.
 //
 // FIXME: this partially overlaps with `find_struct_impl`
+/// Find the end of the `impl` block for the given `ast::Impl`.
 pub(crate) fn find_impl_block_end(impl_def: ast::Impl, buf: &mut String) -> Option<TextSize> {
     buf.push('\n');
     let end = impl_def
     Some(end)
 }
 
+// FIXME: migrate remaining uses to `generate_impl`
 /// Generates the surrounding `impl Type { <code> }` including type and lifetime
 /// parameters.
-// FIXME: migrate remaining uses to `generate_impl`
 pub(crate) fn generate_impl_text(adt: &ast::Adt, code: &str) -> String {
     generate_impl_text_inner(adt, None, true, code)
 }
 
+// FIXME: migrate remaining uses to `generate_trait_impl`
 /// Generates the surrounding `impl <trait> for Type { <code> }` including type
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-// FIXME: migrate remaining uses to `generate_trait_impl`
 #[allow(dead_code)]
 pub(crate) fn generate_trait_impl_text(adt: &ast::Adt, trait_text: &str, code: &str) -> String {
     generate_impl_text_inner(adt, Some(trait_text), true, code)
 }
 
+// FIXME: migrate remaining uses to `generate_trait_impl_intransitive`
 /// Generates the surrounding `impl <trait> for Type { <code> }` including type
 /// and lifetime parameters, with `impl`'s generic parameters' bounds kept as-is.
 ///
 /// This is useful for traits like `From<T>`, since `impl<T> From<T> for U<T>` doesn't require `T: From<T>`.
-// FIXME: migrate remaining uses to `generate_trait_impl_intransitive`
 pub(crate) fn generate_trait_impl_text_intransitive(
     adt: &ast::Adt,
     trait_text: &str,
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-pub(crate) fn generate_trait_impl(is_unsafe: bool, adt: &ast::Adt, trait_: ast::Type) -> ast::Impl {
+pub(crate) fn generate_trait_impl(
+    is_unsafe: bool,
+    adt: &ast::Adt,
+    trait_: ast::Type,
+) -> ast::Impl {
     generate_impl_inner(is_unsafe, adt, Some(trait_), true, None)
 }
 
             body,
         ),
         None => make::impl_(cfg_attrs, generic_params, generic_args, ty, adt.where_clause(), body),
-    }
-    .clone_for_update()
+    }.clone_for_update()
 }
 
 pub(crate) fn add_method_to_adt(
                 if self.impls_deref {
                     make::expr_ref(expr, false)
                 } else {
-                    make::expr_method_call(expr, make::name_ref("as_ref"), make::arg_list([]))
-                        .into()
+                    make::expr_method_call(expr, make::name_ref("as_ref"), make::arg_list([])).into()
                 }
             }
         }
         .map(|(conversion, impls_deref)| ReferenceConversion { ty, conversion, impls_deref })
 }
 
-fn could_deref_to_target(ty: &hir::Type<'_>, target: &hir::Type<'_>, db: &dyn HirDatabase) -> bool {
+fn could_deref_to_target(
+    ty: &hir::Type<'_>,
+    target: &hir::Type<'_>,
+    db: &dyn HirDatabase,
+) -> bool {
     let ty_ref = ty.add_reference(hir::Mutability::Shared);
     let target_ref = target.add_reference(hir::Mutability::Shared);
     ty_ref.could_coerce_to(db, &target_ref)
     }
     res
 }
+
 #[test]
 fn test_required_hashes() {
     assert_eq!(0, required_hashes("abc"));
 pub(crate) fn string_suffix(s: &str) -> Option<&str> {
     s.rfind(['"', '\'', '#']).map(|i| &s[i + 1..])
 }
+
 #[test]
 fn test_string_suffix() {
     assert_eq!(Some(""), string_suffix(r#""abc""#));
 pub(crate) fn string_prefix(s: &str) -> Option<&str> {
     s.split_once(['"', '\'', '#']).map(|(prefix, _)| prefix)
 }
+
 #[test]
 fn test_string_prefix() {
     assert_eq!(Some(""), string_prefix(r#""abc""#));
     if let Some(tail_expr) = block_expr.tail_expr() {
         sema.type_of_expr(&tail_expr).is_some_and(|ty| ty.original.is_never())
     } else if let Some(ast::Stmt::ExprStmt(expr_stmt)) = block_expr.statements().last()
-        && let Some(expr) = expr_stmt.expr()
-    {
+        && let Some(expr) = expr_stmt.expr() {
         sema.type_of_expr(&expr).is_some_and(|ty| ty.original.is_never())
     } else {
         false