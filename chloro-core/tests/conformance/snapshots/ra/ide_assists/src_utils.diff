COMPARISON DIFF
============================================================

Original size: 45288 bytes
Chloro size:   44542 bytes
Rustfmt size:  45288 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 //! Assorted functions shared by several assists.
 
+mod gen_trait_fn_body;
+pub(crate) mod ref_field_expr;
+
 use std::slice;
 
 pub(crate) use gen_trait_fn_body::gen_trait_fn_body;
 use hir::{
+    db::{ExpandDatabase, HirDatabase},
     DisplayTarget, HasAttrs as HirHasAttrs, HirDisplay, InFile, ModuleDef, PathResolution,
     Semantics,
-    db::{ExpandDatabase, HirDatabase},
 };
 use ide_db::{
-    RootDatabase,
     assists::ExprFillDefaultMode,
     famous_defs::FamousDefs,
     path_transform::PathTransform,
     syntax_helpers::{node_ext::preorder_expr, prettify_macro_expansion},
+    RootDatabase,
 };
 use stdx::format_to;
 use syntax::{
-    AstNode, AstToken, Direction, NodeOrToken, SourceFile,
-    SyntaxKind::*,
-    SyntaxNode, SyntaxToken, T, TextRange, TextSize, WalkEvent,
     ast::{
-        self, HasArgList, HasAttrs, HasGenericParams, HasName, HasTypeBounds, Whitespace,
-        edit::{AstNodeEdit, IndentLevel},
-        edit_in_place::AttrsOwnerEdit,
-        make,
-        syntax_factory::SyntaxFactory,
+        self, edit::{AstNodeEdit, IndentLevel}, edit_in_place::AttrsOwnerEdit, make,
+        syntax_factory::SyntaxFactory, HasArgList, HasAttrs, HasGenericParams, HasName,
+        HasTypeBounds, Whitespace,
     },
     syntax_editor::{Removable, SyntaxEditor},
+    AstNode, AstToken, Direction, NodeOrToken, SourceFile,
+    SyntaxKind::*,
+    SyntaxNode, SyntaxToken, TextRange, TextSize, WalkEvent, T,
 };
 
 use crate::{
-    AssistConfig,
     assist_context::{AssistContext, SourceChangeBuilder},
+    AssistConfig,
 };
 
-mod gen_trait_fn_body;
-pub(crate) mod ref_field_expr;
-
 pub(crate) fn unwrap_trivial_block(block_expr: ast::BlockExpr) -> ast::Expr {
-    extract_trivial_expression(&block_expr)
-        .filter(|expr| !expr.syntax().text().contains_char('\n'))
-        .unwrap_or_else(|| block_expr.into())
+    extract_trivial_expression(&block_expr).filter(|expr| !expr.syntax().text().contains_char('\n')).unwrap_or_else(
+        || block_expr.into(),
+    )
 }
 
 pub fn extract_trivial_expression(block_expr: &ast::BlockExpr) -> Option<ast::Expr> {
     target_scope: &hir::SemanticsScope<'_>,
 ) -> Vec<ast::AssocItem> {
     let new_indent_level = IndentLevel::from_node(impl_.syntax()) + 1;
-    original_items
-        .iter()
-        .map(|InFile { file_id, value: original_item }| {
+    original_items.iter().map(|InFile { file_id, value: original_item }| {
             let mut cloned_item = {
                 if let Some(macro_file) = file_id.macro_file() {
                     let span_map = sema.db.expansion_span_map(macro_file);
             }
             cloned_item.remove_attrs_and_docs();
             cloned_item
-        })
-        .filter_map(|item| match item {
+        }).filter_map(|item| match item {
             ast::AssocItem::Fn(fn_) if fn_.body().is_none() => {
                 let fn_ = fn_.clone_subtree();
                 let new_body = &make::block_expr(
                 }
             }
             item => Some(item),
-        })
-        .map(|item| AstNodeEdit::indent(&item, new_indent_level))
-        .collect()
+        }).map(
+        |item| AstNodeEdit::indent(&item, new_indent_level),
+    ).collect(
+    )
 }
 
 pub(crate) fn vis_offset(node: &SyntaxNode) -> TextSize {
-    node.children_with_tokens()
-        .find(|it| !matches!(it.kind(), WHITESPACE | COMMENT | ATTR))
-        .map(|it| it.text_range().start())
-        .unwrap_or_else(|| node.text_range().start())
+    node.children_with_tokens().find(|it| !matches!(it.kind(), WHITESPACE | COMMENT | ATTR)).map(
+        |it| it.text_range().start(),
+    ).unwrap_or_else(
+        || node.text_range().start(),
+    )
 }
 
 pub(crate) fn invert_boolean_expression(make: &SyntaxFactory, expr: ast::Expr) -> ast::Expr {
     invert_special_case(make, &expr).unwrap_or_else(|| make.expr_prefix(T![!], expr).into())
 }
 
-// FIXME: Migrate usages of this function to the above function and remove this.
 pub(crate) fn invert_boolean_expression_legacy(expr: ast::Expr) -> ast::Expr {
     invert_special_case_legacy(&expr).unwrap_or_else(|| make::expr_prefix(T![!], expr).into())
 }
                     );
                 }
             };
-
             Some(make.expr_bin(bin.lhs()?, rev_kind, bin.rhs()?).into())
         }
         ast::Expr::MethodCallExpr(mce) => {
             let receiver = mce.receiver()?;
             let method = mce.name_ref()?;
             let arg_list = mce.arg_list()?;
-
             let method = match method.text().as_str() {
                 "is_some" => "is_none",
                 "is_none" => "is_some",
                 "is_err" => "is_ok",
                 _ => return None,
             };
-
             Some(make.expr_method_call(receiver, make.name_ref(method), arg_list).into())
         }
         ast::Expr::PrefixExpr(pe) if pe.op_kind()? == ast::UnaryOp::Not => match pe.expr()? {
             let receiver = mce.receiver()?;
             let method = mce.name_ref()?;
             let arg_list = mce.arg_list()?;
-
             let method = match method.text().as_str() {
                 "is_some" => "is_none",
                 "is_none" => "is_some",
 
     match pat {
         ast::Pat::RestPat(_) | ast::Pat::WildcardPat(_) | ast::Pat::RefPat(_) => false,
-
         ast::Pat::LiteralPat(_)
         | ast::Pat::RangePat(_)
         | ast::Pat::MacroPat(_)
         | ast::Pat::PathPat(_)
         | ast::Pat::BoxPat(_)
         | ast::Pat::ConstBlockPat(_) => true,
-
         ast::Pat::IdentPat(ident_pat) => ident_pat.pat().is_some_and(|pat| {
             check_pat_variant_nested_or_literal_with_depth(ctx, &pat, depth_after_refutable)
         }),
         }
         ast::Pat::SlicePat(slice_pat) => {
             let mut pats = slice_pat.pats();
-            pats.next()
-                .is_none_or(|pat| !matches!(pat, ast::Pat::RestPat(_)) || pats.next().is_some())
+            pats.next().is_none_or(
+                |pat| !matches!(pat, ast::Pat::RestPat(_)) || pats.next().is_some(),
+            )
         }
     }
 }
 
 // Uses a syntax-driven approach to find any impl blocks for the struct that
-// exist within the module/file
-//
-// Returns `None` if we've found an existing fn
-//
-// FIXME: change the new fn checking to a more semantic approach when that's more
-// viable (e.g. we process proc macros, etc)
-// FIXME: this partially overlaps with `find_impl_block_*`
 
+// exist within the module/file
+
+//
+
+// Returns `None` if we've found an existing fn
+
+//
+
+// FIXME: change the new fn checking to a more semantic approach when that's more
+
+// viable (e.g. we process proc macros, etc)
+
+// FIXME: this partially overlaps with `find_impl_block_*`
 /// `find_struct_impl` looks for impl of a struct, but this also has additional feature
 /// where it takes a list of function names and check if they exist inside impl_, if
 /// even one match is found, it returns None.
 }
 
 /// Find the end of the `impl` block for the given `ast::Impl`.
-//
-// FIXME: this partially overlaps with `find_struct_impl`
 pub(crate) fn find_impl_block_end(impl_def: ast::Impl, buf: &mut String) -> Option<TextSize> {
     buf.push('\n');
     let end = impl_def
 
 /// Generates the surrounding `impl Type { <code> }` including type and lifetime
 /// parameters.
-// FIXME: migrate remaining uses to `generate_impl`
 pub(crate) fn generate_impl_text(adt: &ast::Adt, code: &str) -> String {
     generate_impl_text_inner(adt, None, true, code)
 }
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-// FIXME: migrate remaining uses to `generate_trait_impl`
 #[allow(dead_code)]
 pub(crate) fn generate_trait_impl_text(adt: &ast::Adt, trait_text: &str, code: &str) -> String {
     generate_impl_text_inner(adt, Some(trait_text), true, code)
 /// and lifetime parameters, with `impl`'s generic parameters' bounds kept as-is.
 ///
 /// This is useful for traits like `From<T>`, since `impl<T> From<T> for U<T>` doesn't require `T: From<T>`.
-// FIXME: migrate remaining uses to `generate_trait_impl_intransitive`
 pub(crate) fn generate_trait_impl_text_intransitive(
     adt: &ast::Adt,
     trait_text: &str,
     });
 
     // FIXME: use syntax::make & mutable AST apis instead
+
     // `trait_text` and `code` can't be opaque blobs of text
     let mut buf = String::with_capacity(code.len());
 
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-pub(crate) fn generate_trait_impl(is_unsafe: bool, adt: &ast::Adt, trait_: ast::Type) -> ast::Impl {
+pub(crate) fn generate_trait_impl(
+    is_unsafe: bool,
+    adt: &ast::Adt,
+    trait_: ast::Type,
+) -> ast::Impl {
     generate_impl_inner(is_unsafe, adt, Some(trait_), true, None)
 }
 
             body,
         ),
         None => make::impl_(cfg_attrs, generic_params, generic_args, ty, adt.where_clause(), body),
-    }
-    .clone_for_update()
+    }.clone_for_update(
+    )
 }
 
 pub(crate) fn add_method_to_adt(
                 if self.impls_deref {
                     make::expr_ref(expr, false)
                 } else {
-                    make::expr_method_call(expr, make::name_ref("as_ref"), make::arg_list([]))
-                        .into()
+                    make::expr_method_call(expr, make::name_ref("as_ref"), make::arg_list([])).into(
+                    )
                 }
             }
         }
     }
 }
 
-// FIXME: It should return a new hir::Type, but currently constructing new types is too cumbersome
-//        and all users of this function operate on string type names, so they can do the conversion
-//        itself themselves.
 pub(crate) fn convert_reference_type<'db>(
     ty: hir::Type<'db>,
     db: &'db RootDatabase,
     famous_defs: &FamousDefs<'_, 'db>,
 ) -> Option<ReferenceConversion<'db>> {
-    handle_copy(&ty, db)
-        .or_else(|| handle_as_ref_str(&ty, db, famous_defs))
-        .or_else(|| handle_as_ref_slice(&ty, db, famous_defs))
-        .or_else(|| handle_dereferenced(&ty, db, famous_defs))
-        .or_else(|| handle_option_as_ref(&ty, db, famous_defs))
-        .or_else(|| handle_result_as_ref(&ty, db, famous_defs))
-        .map(|(conversion, impls_deref)| ReferenceConversion { ty, conversion, impls_deref })
+    handle_copy(&ty, db).or_else(|| handle_as_ref_str(&ty, db, famous_defs)).or_else(
+        || handle_as_ref_slice(&ty, db, famous_defs),
+    ).or_else(
+        || handle_dereferenced(&ty, db, famous_defs),
+    ).or_else(
+        || handle_option_as_ref(&ty, db, famous_defs),
+    ).or_else(
+        || handle_result_as_ref(&ty, db, famous_defs),
+    ).map(
+        |(conversion, impls_deref)| ReferenceConversion { ty, conversion, impls_deref },
+    )
 }
 
-fn could_deref_to_target(ty: &hir::Type<'_>, target: &hir::Type<'_>, db: &dyn HirDatabase) -> bool {
+fn could_deref_to_target(
+    ty: &hir::Type<'_>,
+    target: &hir::Type<'_>,
+    db: &dyn HirDatabase,
+) -> bool {
     let ty_ref = ty.add_reference(hir::Mutability::Shared);
     let target_ref = target.add_reference(hir::Mutability::Shared);
     ty_ref.could_coerce_to(db, &target_ref)
 ) -> Option<(ReferenceConversionType, bool)> {
     let str_type = hir::BuiltinType::str().ty(db);
 
-    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&str_type))
-        .then_some((ReferenceConversionType::AsRefStr, could_deref_to_target(ty, &str_type, db)))
+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&str_type)).then_some(
+        (ReferenceConversionType::AsRefStr, could_deref_to_target(ty, &str_type, db)),
+    )
 }
 
 fn handle_as_ref_slice(
     let type_argument = ty.type_arguments().next()?;
     let slice_type = hir::Type::new_slice(type_argument);
 
-    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&slice_type)).then_some((
-        ReferenceConversionType::AsRefSlice,
-        could_deref_to_target(ty, &slice_type, db),
-    ))
+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&slice_type)).then_some(
+        (ReferenceConversionType::AsRefSlice, could_deref_to_target(ty, &slice_type, db)),
+    )
 }
 
 fn handle_dereferenced(
 ) -> Option<(ReferenceConversionType, bool)> {
     let type_argument = ty.type_arguments().next()?;
 
-    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&type_argument))
-        .then_some((
-            ReferenceConversionType::Dereferenced,
-            could_deref_to_target(ty, &type_argument, db),
-        ))
+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&type_argument)).then_some(
+        (ReferenceConversionType::Dereferenced, could_deref_to_target(ty, &type_argument, db)),
+    )
 }
 
 fn handle_option_as_ref(
 }
 
 pub(crate) fn get_methods(items: &ast::AssocItemList) -> Vec<ast::Fn> {
-    items
-        .assoc_items()
-        .flat_map(|i| match i {
+    items.assoc_items().flat_map(|i| match i {
             ast::AssocItem::Fn(f) => Some(f),
             _ => None,
-        })
-        .filter(|f| f.name().is_some())
-        .collect()
+        }).filter(
+        |f| f.name().is_some(),
+    ).collect(
+    )
 }
 
 /// Trim(remove leading and trailing whitespace) `initial_range` in `source_file`, return the trimmed range.
     }
     res
 }
+
 #[test]
 fn test_required_hashes() {
     assert_eq!(0, required_hashes("abc"));
 pub(crate) fn string_suffix(s: &str) -> Option<&str> {
     s.rfind(['"', '\'', '#']).map(|i| &s[i + 1..])
 }
+
 #[test]
 fn test_string_suffix() {
     assert_eq!(Some(""), string_suffix(r#""abc""#));
 pub(crate) fn string_prefix(s: &str) -> Option<&str> {
     s.split_once(['"', '\'', '#']).map(|(prefix, _)| prefix)
 }
+
 #[test]
 fn test_string_prefix() {
     assert_eq!(Some(""), string_prefix(r#""abc""#));
     initializer: ast::Expr,
 ) {
     if let Some(ast::Expr::PathExpr(path_expr)) = record_field.expr() {
-        // replace field shorthand
         let file_range = ctx.sema.original_range(path_expr.syntax());
         edit.insert(file_range.range.end(), format!(": {}", initializer.syntax().text()))
     } else if let Some(expr) = record_field.expr() {
-        // just replace expr
         let file_range = ctx.sema.original_range(expr.syntax());
         edit.replace(file_range.range, initializer.syntax().text());
     }
         } else {
             (Some(expr), None)
         };
-
         if let Some(chain_expr) = chain_expr
             && chain_expr.syntax().text_range().contains_range(range)
         {
     is_const
 }
 
-// FIXME: #20460 When hir-ty can analyze the `never` statement at the end of block, remove it
 pub(crate) fn is_never_block(
     sema: &Semantics<'_, RootDatabase>,
     block_expr: &ast::BlockExpr,
 ) -> bool {
     if let Some(tail_expr) = block_expr.tail_expr() {
         sema.type_of_expr(&tail_expr).is_some_and(|ty| ty.original.is_never())
-    } else if let Some(ast::Stmt::ExprStmt(expr_stmt)) = block_expr.statements().last()
-        && let Some(expr) = expr_stmt.expr()
-    {
+    } else if let Some(ast::Stmt::ExprStmt(expr_stmt)) = block_expr.statements().last() && let Some(expr) = expr_stmt.expr() {
         sema.type_of_expr(&expr).is_some_and(|ty| ty.original.is_never())
     } else {
         false