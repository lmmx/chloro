COMPARISON DIFF
============================================================

Original size: 45288 bytes
Chloro size:   45271 bytes
Rustfmt size:  46860 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     SyntaxNode, SyntaxToken, T, TextRange, TextSize, WalkEvent,
     ast::{
         self, HasArgList, HasAttrs, HasGenericParams, HasName, HasTypeBounds, Whitespace,
-        edit::{AstNodeEdit, IndentLevel},
-        edit_in_place::AttrsOwnerEdit,
-        make,
+        edit_in_place::AttrsOwnerEdit, edit::{AstNodeEdit, IndentLevel}, make,
         syntax_factory::SyntaxFactory,
     },
     syntax_editor::{Removable, SyntaxEditor},
     let stmt_list = block_expr.stmt_list()?;
     let has_anything_else = |thing: &SyntaxNode| -> bool {
         let mut non_trivial_children =
-            stmt_list
-                .syntax()
-                .children_with_tokens()
-                .filter(|it| match it.kind() {
-                    WHITESPACE | T!['{'] | T!['}'] => false,
-                    _ => it.as_node() != Some(thing),
-                });
+            stmt_list.syntax().children_with_tokens().filter(|it| match it.kind() {
+                WHITESPACE | T!['{'] | T!['}'] => false,
+                _ => it.as_node() != Some(thing),
+            });
         non_trivial_children.next().is_some()
     };
     if stmt_list
             return None;
         }
         let expr = expr_stmt.expr()?;
-        if matches!(
-            expr.syntax().kind(),
-            CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR
-        ) {
+        if matches!(expr.syntax().kind(), CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR) {
             return Some(expr);
         }
     }
     fn_def.attrs().find_map(|attr| {
         let path = attr.path()?;
         let text = path.syntax().text().to_string();
-        if text.starts_with("test") || text.ends_with("test") {
-            Some(attr)
-        } else {
-            None
-        }
+        if text.starts_with("test") || text.ends_with("test") { Some(attr) } else { None }
     })
 }
 
     let new_indent_level = IndentLevel::from_node(impl_.syntax()) + 1;
     original_items
         .iter()
-        .map(
-            |InFile {
-                 file_id,
-                 value: original_item,
-             }| {
-                let mut cloned_item = {
-                    if let Some(macro_file) = file_id.macro_file() {
-                        let span_map = sema.db.expansion_span_map(macro_file);
-                        let item_prettified = prettify_macro_expansion(
-                            sema.db,
-                            original_item.syntax().clone(),
-                            &span_map,
-                            target_scope.krate().into(),
-                        );
-                        if let Some(formatted) = ast::AssocItem::cast(item_prettified) {
-                            return formatted;
-                        } else {
-                            stdx::never!(
-                                "formatted `AssocItem` could not be cast back to `AssocItem`"
-                            );
-                        }
-                    }
-                    original_item
-                }
-                .reset_indent();
-
-                if let Some(source_scope) = sema.scope(original_item.syntax()) {
-                    // FIXME: Paths in nested macros are not handled well. See
-                    // `add_missing_impl_members::paths_in_nested_macro_should_get_transformed` test.
-                    let transform = PathTransform::trait_impl(
-                        target_scope,
-                        &source_scope,
-                        trait_,
-                        impl_.clone(),
+        .map(|InFile { file_id, value: original_item }| {
+            let mut cloned_item = {
+                if let Some(macro_file) = file_id.macro_file() {
+                    let span_map = sema.db.expansion_span_map(macro_file);
+                    let item_prettified = prettify_macro_expansion(
+                        sema.db,
+                        original_item.syntax().clone(),
+                        &span_map,
+                        target_scope.krate().into(),
                     );
-                    cloned_item =
-                        ast::AssocItem::cast(transform.apply(cloned_item.syntax())).unwrap();
+                    if let Some(formatted) = ast::AssocItem::cast(item_prettified) {
+                        return formatted;
+                    } else {
+                        stdx::never!("formatted `AssocItem` could not be cast back to `AssocItem`");
+                    }
                 }
-                cloned_item.remove_attrs_and_docs();
-                cloned_item
-            },
-        )
+                original_item
+            }
+            .reset_indent();
+
+            if let Some(source_scope) = sema.scope(original_item.syntax()) {
+                // FIXME: Paths in nested macros are not handled well. See
+                // `add_missing_impl_members::paths_in_nested_macro_should_get_transformed` test.
+                let transform =
+                    PathTransform::trait_impl(target_scope, &source_scope, trait_, impl_.clone());
+                cloned_item = ast::AssocItem::cast(transform.apply(cloned_item.syntax())).unwrap();
+            }
+            cloned_item.remove_attrs_and_docs();
+            cloned_item
+        })
         .filter_map(|item| match item {
             ast::AssocItem::Fn(fn_) if fn_.body().is_none() => {
                 let fn_ = fn_.clone_subtree();
                 ast::BinaryOp::CmpOp(ast::CmpOp::Eq { negated }) => {
                     ast::BinaryOp::CmpOp(ast::CmpOp::Eq { negated: !negated })
                 }
-                ast::BinaryOp::CmpOp(ast::CmpOp::Ord {
-                    ordering: ast::Ordering::Less,
-                    strict,
-                }) => ast::BinaryOp::CmpOp(ast::CmpOp::Ord {
-                    ordering: ast::Ordering::Greater,
-                    strict: !strict,
-                }),
+                ast::BinaryOp::CmpOp(ast::CmpOp::Ord { ordering: ast::Ordering::Less, strict }) => {
+                    ast::BinaryOp::CmpOp(ast::CmpOp::Ord {
+                        ordering: ast::Ordering::Greater,
+                        strict: !strict,
+                    })
+                }
                 ast::BinaryOp::CmpOp(ast::CmpOp::Ord {
                     ordering: ast::Ordering::Greater,
                     strict,
                 // Parenthesize other expressions before prefixing `!`
                 _ => {
                     return Some(
-                        make.expr_prefix(T![!], make.expr_paren(expr.clone()).into())
-                            .into(),
+                        make.expr_prefix(T![!], make.expr_paren(expr.clone()).into()).into(),
                     );
                 }
             };
                 _ => return None,
             };
 
-            Some(
-                make.expr_method_call(receiver, make.name_ref(method), arg_list)
-                    .into(),
-            )
+            Some(make.expr_method_call(receiver, make.name_ref(method), arg_list).into())
         }
         ast::Expr::PrefixExpr(pe) if pe.op_kind()? == ast::UnaryOp::Not => match pe.expr()? {
             ast::Expr::ParenExpr(parexpr) => {
 }
 
 fn check_pat_variant_from_enum(ctx: &AssistContext<'_>, pat: &ast::Pat) -> bool {
-    ctx.sema
-        .type_of_pat(pat)
-        .is_none_or(|ty: hir::TypeInfo<'_>| {
-            ty.adjusted()
-                .as_adt()
-                .is_some_and(|adt| matches!(adt, hir::Adt::Enum(_)))
-        })
+    ctx.sema.type_of_pat(pat).is_none_or(|ty: hir::TypeInfo<'_>| {
+        ty.adjusted().as_adt().is_some_and(|adt| matches!(adt, hir::Adt::Enum(_)))
+    })
 }
 
 fn check_pat_variant_nested_or_literal_with_depth(
             check_pat_variant_nested_or_literal_with_depth(ctx, &pat, depth_after_refutable)
         }),
         ast::Pat::RecordPat(record_pat) => {
-            let adjusted_next_depth = depth_after_refutable
-                + if check_pat_variant_from_enum(ctx, pat) {
-                    1
-                } else {
-                    0
-                };
+            let adjusted_next_depth =
+                depth_after_refutable + if check_pat_variant_from_enum(ctx, pat) { 1 } else { 0 };
             record_pat.record_pat_field_list().is_none_or(|pat| {
                 pat.fields().any(|pat| {
                     pat.pat().is_none_or(|pat| {
             check_pat_variant_nested_or_literal_with_depth(ctx, &pat, depth_after_refutable)
         }),
         ast::Pat::TupleStructPat(tuple_struct_pat) => {
-            let adjusted_next_depth = depth_after_refutable
-                + if check_pat_variant_from_enum(ctx, pat) {
-                    1
-                } else {
-                    0
-                };
+            let adjusted_next_depth =
+                depth_after_refutable + if check_pat_variant_from_enum(ctx, pat) { 1 } else { 0 };
             tuple_struct_pat.fields().any(|pat| {
                 check_pat_variant_nested_or_literal_with_depth(ctx, &pat, adjusted_next_depth)
             })
 
     let struct_def = ctx.sema.to_def(adt)?;
 
-    let block = module
-        .descendants()
-        .filter_map(ast::Impl::cast)
-        .find_map(|impl_blk| {
-            let blk = ctx.sema.to_def(&impl_blk)?;
+    let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {
+        let blk = ctx.sema.to_def(&impl_blk)?;
 
-            // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`
-            // (we currently use the wrong type parameter)
-            // also we wouldn't want to use e.g. `impl S<u32>`
+        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`
+        // (we currently use the wrong type parameter)
+        // also we wouldn't want to use e.g. `impl S<u32>`
 
-            let same_ty = match blk.self_ty(db).as_adt() {
-                Some(def) => def == struct_def,
-                None => false,
-            };
-            let not_trait_impl = blk.trait_(db).is_none();
+        let same_ty = match blk.self_ty(db).as_adt() {
+            Some(def) => def == struct_def,
+            None => false,
+        };
+        let not_trait_impl = blk.trait_(db).is_none();
 
-            if !(same_ty && not_trait_impl) {
-                None
-            } else {
-                Some(impl_blk)
-            }
-        });
+        if !(same_ty && not_trait_impl) { None } else { Some(impl_blk) }
+    });
 
     if let Some(ref impl_blk) = block
         && has_any_fn(impl_blk, names)
     false
 }
 
-/// Find the end of the `impl` block for the given `ast::Impl`.
 //
 // FIXME: this partially overlaps with `find_struct_impl`
+/// Find the end of the `impl` block for the given `ast::Impl`.
 pub(crate) fn find_impl_block_end(impl_def: ast::Impl, buf: &mut String) -> Option<TextSize> {
     buf.push('\n');
     let end = impl_def
     Some(end)
 }
 
+// FIXME: migrate remaining uses to `generate_impl`
 /// Generates the surrounding `impl Type { <code> }` including type and lifetime
 /// parameters.
-// FIXME: migrate remaining uses to `generate_impl`
 pub(crate) fn generate_impl_text(adt: &ast::Adt, code: &str) -> String {
     generate_impl_text_inner(adt, None, true, code)
 }
 
+// FIXME: migrate remaining uses to `generate_trait_impl`
 /// Generates the surrounding `impl <trait> for Type { <code> }` including type
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-// FIXME: migrate remaining uses to `generate_trait_impl`
 #[allow(dead_code)]
 pub(crate) fn generate_trait_impl_text(adt: &ast::Adt, trait_text: &str, code: &str) -> String {
     generate_impl_text_inner(adt, Some(trait_text), true, code)
 }
 
+// FIXME: migrate remaining uses to `generate_trait_impl_intransitive`
 /// Generates the surrounding `impl <trait> for Type { <code> }` including type
 /// and lifetime parameters, with `impl`'s generic parameters' bounds kept as-is.
 ///
 /// This is useful for traits like `From<T>`, since `impl<T> From<T> for U<T>` doesn't require `T: From<T>`.
-// FIXME: migrate remaining uses to `generate_trait_impl_intransitive`
 pub(crate) fn generate_trait_impl_text_intransitive(
     adt: &ast::Adt,
     trait_text: &str,
 ) -> String {
     // Ensure lifetime params are before type & const params
     let generic_params = adt.generic_param_list().map(|generic_params| {
-        let lifetime_params = generic_params
-            .lifetime_params()
-            .map(ast::GenericParam::LifetimeParam);
+        let lifetime_params =
+            generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);
         let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {
             let param = match param {
                 ast::TypeOrConstParam::Type(param) => {
                     // remove defaults since they can't be specified in impls
-                    let mut bounds = param
-                        .type_bound_list()
-                        .map_or_else(Vec::new, |it| it.bounds().collect());
+                    let mut bounds =
+                        param.type_bound_list().map_or_else(Vec::new, |it| it.bounds().collect());
                     if let Some(trait_) = trait_text {
                         // Add the current trait to `bounds` if the trait is transitive,
                         // meaning `impl<T> Trait for U<T>` requires `T: Trait`.
 
     // Copy any cfg attrs from the original adt
     buf.push_str("\n\n");
-    let cfg_attrs = adt.attrs().filter(|attr| {
-        attr.as_simple_call()
-            .map(|(name, _arg)| name == "cfg")
-            .unwrap_or(false)
-    });
+    let cfg_attrs = adt
+        .attrs()
+        .filter(|attr| attr.as_simple_call().map(|(name, _arg)| name == "cfg").unwrap_or(false));
     cfg_attrs.for_each(|attr| buf.push_str(&format!("{attr}\n")));
 
     // `impl{generic_params} {trait_text} for {name}{generic_params.to_generic_args()}`
 /// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.
 ///
 /// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.
-pub(crate) fn generate_trait_impl(is_unsafe: bool, adt: &ast::Adt, trait_: ast::Type) -> ast::Impl {
+pub(crate) fn generate_trait_impl(
+    is_unsafe: bool,
+    adt: &ast::Adt,
+    trait_: ast::Type,
+) -> ast::Impl {
     generate_impl_inner(is_unsafe, adt, Some(trait_), true, None)
 }
 
 ) -> ast::Impl {
     // Ensure lifetime params are before type & const params
     let generic_params = adt.generic_param_list().map(|generic_params| {
-        let lifetime_params = generic_params
-            .lifetime_params()
-            .map(ast::GenericParam::LifetimeParam);
+        let lifetime_params =
+            generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);
         let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {
             let param = match param {
                 ast::TypeOrConstParam::Type(param) => {
                     // remove defaults since they can't be specified in impls
-                    let mut bounds = param
-                        .type_bound_list()
-                        .map_or_else(Vec::new, |it| it.bounds().collect());
+                    let mut bounds =
+                        param.type_bound_list().map_or_else(Vec::new, |it| it.bounds().collect());
                     if let Some(trait_) = &trait_ {
                         // Add the current trait to `bounds` if the trait is transitive,
                         // meaning `impl<T> Trait for U<T>` requires `T: Trait`.
 
         make::generic_param_list(itertools::chain(lifetime_params, ty_or_const_params))
     });
-    let generic_args = generic_params
-        .as_ref()
-        .map(|params| params.to_generic_args().clone_for_update());
+    let generic_args =
+        generic_params.as_ref().map(|params| params.to_generic_args().clone_for_update());
     let ty = make::ty_path(make::ext::ident_path(&adt.name().unwrap().text()));
 
-    let cfg_attrs = adt.attrs().filter(|attr| {
-        attr.as_simple_call()
-            .is_some_and(|(name, _arg)| name == "cfg")
-    });
+    let cfg_attrs =
+        adt.attrs().filter(|attr| attr.as_simple_call().is_some_and(|(name, _arg)| name == "cfg"));
     match trait_ {
         Some(trait_) => make::impl_trait(
             cfg_attrs,
             adt.where_clause(),
             body,
         ),
-        None => make::impl_(
-            cfg_attrs,
-            generic_params,
-            generic_args,
-            ty,
-            adt.where_clause(),
-            body,
-        ),
-    }
-    .clone_for_update()
+        None => make::impl_(cfg_attrs, generic_params, generic_args, ty, adt.where_clause(), body),
+    }.clone_for_update()
 }
 
 pub(crate) fn add_method_to_adt(
             }
             ReferenceConversionType::Result => {
                 let mut type_arguments = self.ty.type_arguments();
-                let first_type_argument_name = type_arguments
-                    .next()
-                    .unwrap()
-                    .display(db, display_target)
-                    .to_string();
-                let second_type_argument_name = type_arguments
-                    .next()
-                    .unwrap()
-                    .display(db, display_target)
-                    .to_string();
+                let first_type_argument_name =
+                    type_arguments.next().unwrap().display(db, display_target).to_string();
+                let second_type_argument_name =
+                    type_arguments.next().unwrap().display(db, display_target).to_string();
                 format!("Result<&{first_type_argument_name}, &{second_type_argument_name}>")
             }
         };
                 if self.impls_deref {
                     make::expr_ref(expr, false)
                 } else {
-                    make::expr_method_call(expr, make::name_ref("as_ref"), make::arg_list([]))
-                        .into()
+                    make::expr_method_call(expr, make::name_ref("as_ref"), make::arg_list([])).into()
                 }
             }
         }
         .or_else(|| handle_dereferenced(&ty, db, famous_defs))
         .or_else(|| handle_option_as_ref(&ty, db, famous_defs))
         .or_else(|| handle_result_as_ref(&ty, db, famous_defs))
-        .map(|(conversion, impls_deref)| ReferenceConversion {
-            ty,
-            conversion,
-            impls_deref,
-        })
+        .map(|(conversion, impls_deref)| ReferenceConversion { ty, conversion, impls_deref })
 }
 
-fn could_deref_to_target(ty: &hir::Type<'_>, target: &hir::Type<'_>, db: &dyn HirDatabase) -> bool {
+fn could_deref_to_target(
+    ty: &hir::Type<'_>,
+    target: &hir::Type<'_>,
+    db: &dyn HirDatabase,
+) -> bool {
     let ty_ref = ty.add_reference(hir::Mutability::Shared);
     let target_ref = target.add_reference(hir::Mutability::Shared);
     ty_ref.could_coerce_to(db, &target_ref)
     ty: &hir::Type<'_>,
     db: &dyn HirDatabase,
 ) -> Option<(ReferenceConversionType, bool)> {
-    ty.is_copy(db)
-        .then_some((ReferenceConversionType::Copy, true))
+    ty.is_copy(db).then_some((ReferenceConversionType::Copy, true))
 }
 
 fn handle_as_ref_str(
 ) -> Option<(ReferenceConversionType, bool)> {
     let str_type = hir::BuiltinType::str().ty(db);
 
-    ty.impls_trait(
-        db,
-        famous_defs.core_convert_AsRef()?,
-        slice::from_ref(&str_type),
-    )
-    .then_some((
-        ReferenceConversionType::AsRefStr,
-        could_deref_to_target(ty, &str_type, db),
-    ))
+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&str_type))
+        .then_some((ReferenceConversionType::AsRefStr, could_deref_to_target(ty, &str_type, db)))
 }
 
 fn handle_as_ref_slice(
     let type_argument = ty.type_arguments().next()?;
     let slice_type = hir::Type::new_slice(type_argument);
 
-    ty.impls_trait(
-        db,
-        famous_defs.core_convert_AsRef()?,
-        slice::from_ref(&slice_type),
-    )
-    .then_some((
+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&slice_type)).then_some((
         ReferenceConversionType::AsRefSlice,
         could_deref_to_target(ty, &slice_type, db),
     ))
 ) -> Option<(ReferenceConversionType, bool)> {
     let type_argument = ty.type_arguments().next()?;
 
-    ty.impls_trait(
-        db,
-        famous_defs.core_convert_AsRef()?,
-        slice::from_ref(&type_argument),
-    )
-    .then_some((
-        ReferenceConversionType::Dereferenced,
-        could_deref_to_target(ty, &type_argument, db),
-    ))
+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, slice::from_ref(&type_argument))
+        .then_some((
+            ReferenceConversionType::Dereferenced,
+            could_deref_to_target(ty, &type_argument, db),
+        ))
 }
 
 fn handle_option_as_ref(
     }
     res
 }
+
 #[test]
 fn test_required_hashes() {
     assert_eq!(0, required_hashes("abc"));
 pub(crate) fn string_suffix(s: &str) -> Option<&str> {
     s.rfind(['"', '\'', '#']).map(|i| &s[i + 1..])
 }
+
 #[test]
 fn test_string_suffix() {
     assert_eq!(Some(""), string_suffix(r#""abc""#));
 pub(crate) fn string_prefix(s: &str) -> Option<&str> {
     s.split_once(['"', '\'', '#']).map(|(prefix, _)| prefix)
 }
+
 #[test]
 fn test_string_prefix() {
     assert_eq!(Some(""), string_prefix(r#""abc""#));
     if let Some(ast::Expr::PathExpr(path_expr)) = record_field.expr() {
         // replace field shorthand
         let file_range = ctx.sema.original_range(path_expr.syntax());
-        edit.insert(
-            file_range.range.end(),
-            format!(": {}", initializer.syntax().text()),
-        )
+        edit.insert(file_range.range.end(), format!(": {}", initializer.syntax().text()))
     } else if let Some(expr) = record_field.expr() {
         // just replace expr
         let file_range = ctx.sema.original_range(expr.syntax());
     let mut tt_stack = vec![(None, vec![])];
 
     for element in node.descendants_with_tokens() {
-        let NodeOrToken::Token(token) = element else {
-            continue;
-        };
+        let NodeOrToken::Token(token) = element else { continue };
 
         match token.kind() {
             T!['('] | T!['{'] | T!['['] => {
         }
     }
 
-    tt_stack
-        .pop()
-        .expect("parent token tree was closed before it was completed")
-        .1
+    tt_stack.pop().expect("parent token tree was closed before it was completed").1
 }
 
 pub(crate) fn cover_let_chain(mut expr: ast::Expr, range: TextRange) -> Option<ast::Expr> {
                 }
             }
             ast::Expr::MethodCallExpr(call) => {
-                is_const &= sema
-                    .resolve_method_call(&call)
-                    .map(|it| it.is_const(sema.db))
-                    .unwrap_or(true)
+                is_const &=
+                    sema.resolve_method_call(&call).map(|it| it.is_const(sema.db)).unwrap_or(true)
             }
             ast::Expr::ForExpr(_)
             | ast::Expr::ReturnExpr(_)
     block_expr: &ast::BlockExpr,
 ) -> bool {
     if let Some(tail_expr) = block_expr.tail_expr() {
-        sema.type_of_expr(&tail_expr)
-            .is_some_and(|ty| ty.original.is_never())
+        sema.type_of_expr(&tail_expr).is_some_and(|ty| ty.original.is_never())
     } else if let Some(ast::Stmt::ExprStmt(expr_stmt)) = block_expr.statements().last()
-        && let Some(expr) = expr_stmt.expr()
-    {
-        sema.type_of_expr(&expr)
-            .is_some_and(|ty| ty.original.is_never())
+        && let Some(expr) = expr_stmt.expr() {
+        sema.type_of_expr(&expr).is_some_and(|ty| ty.original.is_never())
     } else {
         false
     }