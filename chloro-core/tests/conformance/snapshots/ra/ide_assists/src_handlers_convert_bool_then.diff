COMPARISON DIFF
============================================================

Original size: 15319 bytes
Chloro size:   14415 bytes
Rustfmt size:  15319 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use hir::{AsAssocItem, Semantics, sym};
+use hir::{sym, AsAssocItem, Semantics};
 use ide_db::{
-    RootDatabase,
     famous_defs::FamousDefs,
     syntax_helpers::node_ext::{
         block_as_lone_tail, for_each_tail_expr, is_pattern_cond, preorder_expr,
     },
+    RootDatabase,
 };
 use itertools::Itertools;
 use syntax::{
-    AstNode, SyntaxNode,
-    ast::{self, HasArgList, edit::AstNodeEdit, syntax_factory::SyntaxFactory},
+    ast::{self, edit::AstNodeEdit, syntax_factory::SyntaxFactory, HasArgList},
     syntax_editor::SyntaxEditor,
+    AstNode, SyntaxNode,
 };
 
 use crate::{
-    AssistContext, AssistId, Assists,
     utils::{invert_boolean_expression, unwrap_trivial_block},
+    AssistContext, AssistId, Assists,
 };
 
-// Assist: convert_if_to_bool_then
-//
-// Converts an if expression into a corresponding `bool::then` call.
-//
-// ```
-// # //- minicore: option
-// fn main() {
-//     if$0 cond {
-//         Some(val)
-//     } else {
-//         None
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     cond.then(|| val)
-// }
-// ```
 pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // FIXME applies to match as well
     let expr = ctx.find_node_at_offset::<ast::IfExpr>()?;
         "Convert `if` expression to `bool::then` call",
         target,
         |builder| {
-            let closure_body = closure_body.clone_subtree();
-            let mut editor = SyntaxEditor::new(closure_body.syntax().clone());
-            // Rewrite all `Some(e)` in tail position to `e`
-            for_each_tail_expr(&closure_body, &mut |e| {
+        let closure_body = closure_body.clone_subtree();
+        let mut editor = SyntaxEditor::new(closure_body.syntax().clone());
+        for_each_tail_expr(&closure_body, &mut |e| {
                 let e = match e {
                     ast::Expr::BreakExpr(e) => e.expr(),
                     e @ ast::Expr::CallExpr(_) => Some(e.clone()),
                     editor.replace(call.syntax(), arg.syntax());
                 }
             });
-            let edit = editor.finish();
-            let closure_body = ast::Expr::cast(edit.new_root().clone()).unwrap();
-
-            let mut editor = builder.make_editor(expr.syntax());
-            let make = SyntaxFactory::with_mappings();
-            let closure_body = match closure_body {
+        let edit = editor.finish();
+        let closure_body = ast::Expr::cast(edit.new_root().clone()).unwrap();
+        let mut editor = builder.make_editor(expr.syntax());
+        let make = SyntaxFactory::with_mappings();
+        let closure_body = match closure_body {
                 ast::Expr::BlockExpr(block) => unwrap_trivial_block(block),
                 e => e,
             };
-
-            let parenthesize = matches!(
+        let parenthesize = matches!(
                 cond,
                 ast::Expr::BinExpr(_)
                     | ast::Expr::BlockExpr(_)
                     | ast::Expr::WhileExpr(_)
                     | ast::Expr::YieldExpr(_)
             );
-            let cond = if invert_cond {
+        let cond = if invert_cond {
                 invert_boolean_expression(&make, cond)
             } else {
                 cond.clone_for_update()
             };
-            let cond = if parenthesize { make.expr_paren(cond).into() } else { cond };
-            let arg_list = make.arg_list(Some(make.expr_closure(None, closure_body).into()));
-            let mcall = make.expr_method_call(cond, make.name_ref("then"), arg_list);
-            editor.replace(expr.syntax(), mcall.syntax());
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        let cond = if parenthesize { make.expr_paren(cond).into() } else { cond };
+        let arg_list = make.arg_list(Some(make.expr_closure(None, closure_body).into()));
+        let mcall = make.expr_method_call(cond, make.name_ref("then"), arg_list);
+        editor.replace(expr.syntax(), mcall.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
-// Assist: convert_bool_then_to_if
-//
-// Converts a `bool::then` method call to an equivalent if expression.
-//
-// ```
-// # //- minicore: bool_impl
-// fn main() {
-//     (0 == 0).then$0(|| val)
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     if 0 == 0 {
-//         Some(val)
-//     } else {
-//         None
-//     }
-// }
-// ```
 pub(crate) fn convert_bool_then_to_if(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let name_ref = ctx.find_node_at_offset::<ast::NameRef>()?;
     let mcall = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;
         "Convert `bool::then` call to `if`",
         target,
         |builder| {
-            let mapless_make = SyntaxFactory::without_mappings();
-            let closure_body = match closure_body.reset_indent() {
+        let mapless_make = SyntaxFactory::without_mappings();
+        let closure_body = match closure_body.reset_indent() {
                 ast::Expr::BlockExpr(block) => block,
                 e => mapless_make.block_expr(None, Some(e)),
             };
-
-            let closure_body = closure_body.clone_subtree();
-            let mut editor = SyntaxEditor::new(closure_body.syntax().clone());
-            // Wrap all tails in `Some(...)`
-            let none_path = mapless_make.expr_path(mapless_make.ident_path("None"));
-            let some_path = mapless_make.expr_path(mapless_make.ident_path("Some"));
-            for_each_tail_expr(&ast::Expr::BlockExpr(closure_body), &mut |e| {
+        let closure_body = closure_body.clone_subtree();
+        let mut editor = SyntaxEditor::new(closure_body.syntax().clone());
+        let none_path = mapless_make.expr_path(mapless_make.ident_path("None"));
+        let some_path = mapless_make.expr_path(mapless_make.ident_path("Some"));
+        for_each_tail_expr(&ast::Expr::BlockExpr(closure_body), &mut |e| {
                 let e = match e {
                     ast::Expr::BreakExpr(e) => e.expr(),
                     ast::Expr::ReturnExpr(e) => e.expr(),
                     );
                 }
             });
-            let edit = editor.finish();
-            let closure_body = ast::BlockExpr::cast(edit.new_root().clone()).unwrap();
-
-            let mut editor = builder.make_editor(mcall.syntax());
-            let make = SyntaxFactory::with_mappings();
-
-            let cond = match &receiver {
+        let edit = editor.finish();
+        let closure_body = ast::BlockExpr::cast(edit.new_root().clone()).unwrap();
+        let mut editor = builder.make_editor(mcall.syntax());
+        let make = SyntaxFactory::with_mappings();
+        let cond = match &receiver {
                 ast::Expr::ParenExpr(expr) => expr.expr().unwrap_or(receiver),
                 _ => receiver,
             };
-            let if_expr = make
+        let if_expr = make
                 .expr_if(
                     cond,
                     closure_body,
                     Some(ast::ElseBranch::Block(make.block_expr(None, Some(none_path)))),
                 )
                 .indent(mcall.indent_level());
-            editor.replace(mcall.syntax().clone(), if_expr.syntax().clone());
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.replace(mcall.syntax().clone(), if_expr.syntax().clone());
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn convert_if_to_bool_then_simple() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_invert() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_none_none() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_some_some() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_mixed() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_chain() {
         cov_mark::check!(convert_if_to_bool_then_chain);
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_pattern_cond() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_pattern_invalid_body() {
         cov_mark::check_count!(convert_if_to_bool_then_pattern_invalid_body, 2);
 ",
         );
     }
-
     #[test]
     fn convert_bool_then_to_if_inapplicable() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_bool_then_to_if_simple() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn convert_bool_then_to_if_tails() {
         check_assist(