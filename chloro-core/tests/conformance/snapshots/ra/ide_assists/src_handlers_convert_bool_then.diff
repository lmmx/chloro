COMPARISON DIFF
============================================================

Original size: 15319 bytes
Chloro size:   14664 bytes
Rustfmt size:  15319 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use hir::{AsAssocItem, Semantics, sym};
+use hir::{sym, AsAssocItem, Semantics};
 use ide_db::{
-    RootDatabase,
     famous_defs::FamousDefs,
     syntax_helpers::node_ext::{
         block_as_lone_tail, for_each_tail_expr, is_pattern_cond, preorder_expr,
     },
+    RootDatabase,
 };
 use itertools::Itertools;
 use syntax::{
-    AstNode, SyntaxNode,
-    ast::{self, HasArgList, edit::AstNodeEdit, syntax_factory::SyntaxFactory},
+    ast::{self, edit::AstNodeEdit, syntax_factory::SyntaxFactory, HasArgList},
     syntax_editor::SyntaxEditor,
+    AstNode, SyntaxNode,
 };
 
 use crate::{
-    AssistContext, AssistId, Assists,
     utils::{invert_boolean_expression, unwrap_trivial_block},
+    AssistContext, AssistId, Assists,
 };
 
-// Assist: convert_if_to_bool_then
-//
-// Converts an if expression into a corresponding `bool::then` call.
-//
-// ```
-// # //- minicore: option
-// fn main() {
-//     if$0 cond {
-//         Some(val)
-//     } else {
-//         None
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     cond.then(|| val)
-// }
-// ```
 pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     // FIXME applies to match as well
     let expr = ctx.find_node_at_offset::<ast::IfExpr>()?;
     )
 }
 
-// Assist: convert_bool_then_to_if
-//
-// Converts a `bool::then` method call to an equivalent if expression.
-//
-// ```
-// # //- minicore: bool_impl
-// fn main() {
-//     (0 == 0).then$0(|| val)
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     if 0 == 0 {
-//         Some(val)
-//     } else {
-//         None
-//     }
-// }
-// ```
 pub(crate) fn convert_bool_then_to_if(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let name_ref = ctx.find_node_at_offset::<ast::NameRef>()?;
     let mcall = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn convert_if_to_bool_then_simple() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_invert() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_none_none() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_some_some() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_mixed() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_chain() {
         cov_mark::check!(convert_if_to_bool_then_chain);
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_pattern_cond() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_if_to_bool_then_pattern_invalid_body() {
         cov_mark::check_count!(convert_if_to_bool_then_pattern_invalid_body, 2);
 ",
         );
     }
-
     #[test]
     fn convert_bool_then_to_if_inapplicable() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn convert_bool_then_to_if_simple() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn convert_bool_then_to_if_tails() {
         check_assist(