COMPARISON DIFF
============================================================

Original size: 12337 bytes
Chloro size:   11752 bytes
Rustfmt size:  12415 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     AssistId,
 };
 
-// Assist: convert_match_to_let_else
-//
-// Converts let statement with match initializer to let-else statement.
-//
-// ```
-// # //- minicore: option
-// fn foo(opt: Option<()>) {
-//     let val$0 = match opt {
-//         Some(it) => it,
-//         None => return,
-//     };
-// }
-// ```
-// ->
-// ```
-// fn foo(opt: Option<()>) {
-//     let Some(val) = opt else { return };
-// }
-// ```
 pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let let_stmt: ast::LetStmt = ctx.find_node_at_offset()?;
     let pat = let_stmt.pat()?;
         return None;
     }
 
-    let Some(ast::Expr::MatchExpr(initializer)) = let_stmt.initializer() else {
-        return None;
-    };
+    let Some(ast::Expr::MatchExpr(initializer)) = let_stmt.initializer() else { return None };
     let initializer_expr = initializer.expr()?;
 
     let (extracting_arm, diverging_arm) = find_arms(ctx, &initializer)?;
         "Convert match to let-else",
         let_stmt.syntax().text_range(),
         |builder| {
-            let extracting_arm_pat =
+        let extracting_arm_pat =
                 rename_variable(&extracting_arm_pat, &extracted_variable_positions, pat);
-            builder.replace(
-                let_stmt.syntax().text_range(),
-                format!("let {extracting_arm_pat} = {initializer_expr} else {diverging_arm_expr};"),
-            )
-        },
+        builder.replace(
+            let_stmt.syntax().text_range(),
+            format!("let {extracting_arm_pat} = {initializer_expr} else {diverging_arm_expr};"),
+        )
+    },
     )
 }
 
-// Given a match expression, find extracting and diverging arms.
 fn find_arms(
     ctx: &AssistContext<'_>,
     match_expr: &ast::MatchExpr,
         _ => {
             cov_mark::hit!(non_diverging_match);
             None
-        }
+        },
     }
 }
 
-// Given an extracting arm, find the extracted variable.
 fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Option<Vec<Name>> {
     match arm.expr()? {
         ast::Expr::PathExpr(path) => {
             let name_ref = path.syntax().descendants().find_map(ast::NameRef::cast)?;
             match NameRefClass::classify(&ctx.sema, &name_ref)? {
                 NameRefClass::Definition(Definition::Local(local), _) => {
-                    let source = local
-                        .sources(ctx.db())
-                        .into_iter()
-                        .map(|x| x.into_ident_pat()?.name());
+                    let source =
+                        local.sources(ctx.db()).into_iter().map(|x| x.into_ident_pat()?.name());
                     source.collect()
-                }
+                },
                 _ => None,
             }
-        }
+        },
         _ => {
             cov_mark::hit!(extracting_arm_is_not_an_identity_expr);
             None
-        }
+        },
     }
 }
 
-// Rename `extracted` with `binding` in `pat`.
 fn rename_variable(pat: &ast::Pat, extracted: &[Name], binding: ast::Pat) -> SyntaxNode {
     let syntax = pat.syntax().clone_subtree();
     let mut editor = SyntaxEditor::new(syntax.clone());
     for extracted_syntax in extracted {
         // If `extracted` variable is a record field, we should rename it to `binding`,
         // otherwise we just need to replace `extracted` with `binding`.
-        if let Some(record_pat_field) = extracted_syntax
-            .ancestors()
-            .find_map(ast::RecordPatField::cast)
+        if let Some(record_pat_field) =
+            extracted_syntax.ancestors().find_map(ast::RecordPatField::cast)
         {
             if let Some(name_ref) = record_pat_field.field_name() {
                 editor.replace(
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn should_not_be_applicable_for_non_diverging_match() {
         cov_mark::check!(non_diverging_match);
 "#,
         );
     }
-
     #[test]
     fn or_pattern_multiple_binding() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn indent_level() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn should_not_be_applicable_if_extracting_arm_is_not_an_identity_expr() {
         cov_mark::check_count!(extracting_arm_is_not_an_identity_expr, 2);
 "#,
         );
     }
-
     #[test]
     fn should_not_be_applicable_if_extracting_arm_has_guard() {
         cov_mark::check!(extracting_arm_has_guard);
 "#,
         );
     }
-
     #[test]
     fn basic_pattern() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn keeps_modifiers() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn nested_pattern() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn works_with_any_diverging_block() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn struct_pattern() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn renames_whole_binding() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn complex_pattern() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn diverging_block() {
         check_assist(