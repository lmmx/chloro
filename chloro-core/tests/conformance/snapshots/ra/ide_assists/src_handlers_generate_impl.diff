COMPARISON DIFF
============================================================

Original size: 21468 bytes
Chloro size:   20381 bytes
Rustfmt size:  21468 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use syntax::{
-    ast::{self, AstNode, HasGenericParams, HasName, edit_in_place::Indent, make},
+    ast::{self, edit_in_place::Indent, make, AstNode, HasGenericParams, HasName},
     syntax_editor::{Position, SyntaxEditor},
 };
 
 use crate::{
-    AssistContext, AssistId, Assists,
     utils::{self, DefaultMethods, IgnoreAssocItems},
+    AssistContext, AssistId, Assists,
 };
 
 fn insert_impl(editor: &mut SyntaxEditor, impl_: &ast::Impl, nominal: &impl Indent) {
     );
 }
 
-// Assist: generate_impl
-//
-// Adds a new inherent impl for a type.
-//
-// ```
-// struct Ctx$0<T: Clone> {
-//     data: T,
-// }
-// ```
-// ->
-// ```
-// struct Ctx<T: Clone> {
-//     data: T,
-// }
-//
-// impl<T: Clone> Ctx<T> {$0}
-// ```
 pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let nominal = ctx.find_node_at_offset::<ast::Adt>()?;
     let name = nominal.name()?;
         format!("Generate impl for `{name}`"),
         target,
         |edit| {
-            // Generate the impl
-            let impl_ = utils::generate_impl(&nominal);
-
-            let mut editor = edit.make_editor(nominal.syntax());
-            // Add a tabstop after the left curly brace
-            if let Some(cap) = ctx.config.snippet_cap
+        let impl_ = utils::generate_impl(&nominal);
+        let mut editor = edit.make_editor(nominal.syntax());
+        if let Some(cap) = ctx.config.snippet_cap
                 && let Some(l_curly) = impl_.assoc_item_list().and_then(|it| it.l_curly_token())
             {
                 let tabstop = edit.make_tabstop_after(cap);
                 editor.add_annotation(l_curly, tabstop);
             }
-
-            insert_impl(&mut editor, &impl_, &nominal);
-            edit.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        insert_impl(&mut editor, &impl_, &nominal);
+        edit.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
-// Assist: generate_trait_impl
-//
-// Adds a new trait impl for a type.
-//
-// ```
-// struct $0Ctx<T: Clone> {
-//     data: T,
-// }
-// ```
-// ->
-// ```
-// struct Ctx<T: Clone> {
-//     data: T,
-// }
-//
-// impl<T: Clone> ${1:_} for Ctx<T> {$0}
-// ```
 pub(crate) fn generate_trait_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let nominal = ctx.find_node_at_offset::<ast::Adt>()?;
     let name = nominal.name()?;
         format!("Generate trait impl for `{name}`"),
         target,
         |edit| {
-            // Generate the impl
-            let impl_ = utils::generate_trait_impl_intransitive(&nominal, make::ty_placeholder());
-
-            let mut editor = edit.make_editor(nominal.syntax());
-            // Make the trait type a placeholder snippet
-            if let Some(cap) = ctx.config.snippet_cap {
+        let impl_ = utils::generate_trait_impl_intransitive(&nominal, make::ty_placeholder());
+        let mut editor = edit.make_editor(nominal.syntax());
+        if let Some(cap) = ctx.config.snippet_cap {
                 if let Some(trait_) = impl_.trait_() {
                     let placeholder = edit.make_placeholder_snippet(cap);
                     editor.add_annotation(trait_.syntax(), placeholder);
                     editor.add_annotation(l_curly, tabstop);
                 }
             }
-
-            insert_impl(&mut editor, &impl_, &nominal);
-            edit.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        insert_impl(&mut editor, &impl_, &nominal);
+        edit.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
-// Assist: generate_impl_trait
-//
-// Adds this trait impl for a type.
-//
-// ```
-// trait $0Foo {
-//     fn foo(&self) -> i32;
-// }
-// ```
-// ->
-// ```
-// trait Foo {
-//     fn foo(&self) -> i32;
-// }
-//
-// impl Foo for ${1:_} {
-//     fn foo(&self) -> i32 {
-//         $0todo!()
-//     }
-// }
-// ```
 pub(crate) fn generate_impl_trait(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let name = ctx.find_node_at_offset::<ast::Name>()?;
     let trait_ = ast::Trait::cast(name.syntax().parent()?)?;
         format!("Generate `{name}` impl for type"),
         target,
         |edit| {
-            let mut editor = edit.make_editor(trait_.syntax());
-
-            let holder_arg = ast::GenericArg::TypeArg(make::type_arg(make::ty_placeholder()));
-            let missing_items = utils::filter_assoc_items(
+        let mut editor = edit.make_editor(trait_.syntax());
+        let holder_arg = ast::GenericArg::TypeArg(make::type_arg(make::ty_placeholder()));
+        let missing_items = utils::filter_assoc_items(
                 &ctx.sema,
                 &hir_trait.items(ctx.db()),
                 DefaultMethods::No,
                 IgnoreAssocItems::DocHiddenAttrPresent,
             );
-
-            let trait_gen_args = trait_.generic_param_list().map(|list| {
+        let trait_gen_args = trait_.generic_param_list().map(|list| {
                 make::generic_arg_list(list.generic_params().map(|_| holder_arg.clone()))
             });
-
-            let make_impl_ = |body| {
+        let make_impl_ = |body| {
                 make::impl_trait(
                     None,
                     trait_.unsafe_token().is_some(),
                 )
                 .clone_for_update()
             };
-
-            let impl_ = if missing_items.is_empty() {
+        let impl_ = if missing_items.is_empty() {
                 make_impl_(None)
             } else {
                 let impl_ = make_impl_(None);
                 let assoc_item_list = make::assoc_item_list(Some(assoc_items));
                 make_impl_(Some(assoc_item_list))
             };
-
-            if let Some(cap) = ctx.config.snippet_cap {
+        if let Some(cap) = ctx.config.snippet_cap {
                 if let Some(generics) = impl_.trait_().and_then(|it| it.generic_arg_list()) {
                     for generic in generics.generic_args() {
                         let placeholder = edit.make_placeholder_snippet(cap);
                     editor.add_annotation(l_curly, tabstop);
                 }
             }
-
-            insert_impl(&mut editor, &impl_, &trait_);
-            edit.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        insert_impl(&mut editor, &impl_, &trait_);
+        edit.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_target};
-
     use super::*;
-
     #[test]
     fn test_add_impl() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_with_generics() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_with_generics_and_lifetime_parameters() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_with_attributes() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_with_default_generic() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_with_constrained_default_generic() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_with_const_defaulted_generic() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_with_trait_constraint() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn add_impl_target() {
         check_assist_target(
             "/// Has a lifetime parameter\nstruct Foo<'a, T: Foo<'a>> {}",
         );
     }
-
     #[test]
     fn test_add_trait_impl() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_trait_impl_with_generics() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_trait_impl_with_generics_and_lifetime_parameters() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_trait_impl_with_attributes() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_trait_impl_with_default_generic() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_trait_impl_with_constrained_default_generic() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_trait_impl_with_const_defaulted_generic() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_trait_impl_with_trait_constraint() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn add_trait_impl_target() {
         check_assist_target(
             "/// Has a lifetime parameter\nstruct Foo<'a, T: Foo<'a>> {}",
         );
     }
-
     #[test]
     fn add_impl_with_indent() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn add_impl_with_multiple_indent() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn add_trait_impl_with_indent() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_trait() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_trait_use_generic() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_trait_docs() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_trait_assoc_types() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_trait_indent() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn test_add_impl_trait_empty() {
         check_assist(