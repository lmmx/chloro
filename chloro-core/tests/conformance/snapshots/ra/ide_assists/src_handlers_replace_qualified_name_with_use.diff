COMPARISON DIFF
============================================================

Original size: 10666 bytes
Chloro size:   9931 bytes
Rustfmt size:  10666 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::AsAssocItem;
 use ide_db::{
     helpers::mod_path_to_ast,
-    imports::insert_use::{ImportScope, insert_use},
+    imports::insert_use::{insert_use, ImportScope},
 };
 use syntax::{
-    AstNode, Edition, SyntaxNode,
-    ast::{self, HasGenericArgs, make},
-    match_ast, ted,
+    ast::{self, make, HasGenericArgs},
+    match_ast, ted, AstNode, Edition, SyntaxNode,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: replace_qualified_name_with_use
-//
-// Adds a use statement for a given fully-qualified name.
-//
-// ```
-// # mod std { pub mod collections { pub struct HashMap<T, U>(T, U); } }
-// fn process(map: std::collections::$0HashMap<String, String>) {}
-// ```
-// ->
-// ```
-// use std::collections::HashMap;
-//
-// # mod std { pub mod collections { pub struct HashMap<T, U>(T, U); } }
-// fn process(map: HashMap<String, String>) {}
-// ```
 pub(crate) fn replace_qualified_name_with_use(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         "Replace qualified path with use",
         target,
         |builder| {
-            // Now that we've brought the name into scope, re-qualify all paths that could be
-            // affected (that is, all paths inside the node we added the `use` to).
-            let scope = builder.make_import_scope_mut(scope);
-            shorten_paths(scope.as_syntax_node(), &original_path);
-            let path = drop_generic_args(&original_path);
-            let edition = ctx
+        let scope = builder.make_import_scope_mut(scope);
+        shorten_paths(scope.as_syntax_node(), &original_path);
+        let path = drop_generic_args(&original_path);
+        let edition = ctx
                 .sema
                 .scope(original_path.syntax())
                 .map(|semantics_scope| semantics_scope.krate().edition(ctx.db()))
                 .unwrap_or(Edition::CURRENT);
-            // stick the found import in front of the to be replaced path
-            let path =
+        let path =
                 match path_to_qualifier.and_then(|it| mod_path_to_ast(&it, edition).qualifier()) {
                     Some(qualifier) => make::path_concat(qualifier, path),
                     None => path,
                 };
-            insert_use(&scope, path, &ctx.config.insert_use);
-        },
+        insert_use(&scope, path, &ctx.config.insert_use);
+    },
     )
 }
 
                         .is_some_and(|(lhs, rhs)| lhs.text() == rhs.text()) => {}
             _ => return false,
         }
-
         match (lhs_curr.qualifier(), rhs_curr.qualifier()) {
             (Some(lhs), Some(rhs)) => {
                 lhs_curr = lhs;
                 rhs_curr = rhs;
-            }
+            },
             (None, None) => return true,
             _ => return false,
         }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_replace_already_imported() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn test_replace_add_use_no_anchor() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn test_replace_add_use_no_anchor_middle_segment() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn test_replace_not_applicable_in_use() {
         cov_mark::check!(not_applicable_in_use);
         check_assist_not_applicable(replace_qualified_name_with_use, r"use std::fmt$0;");
     }
-
     #[test]
     fn replaces_all_affected_paths() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn assist_runs_on_first_segment() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn does_not_replace_in_submodules() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn does_not_replace_in_use() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn does_not_replace_assoc_item_path() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn replace_reuses_path_qualifier() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn replace_does_not_always_try_to_replace_by_full_item_path() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn replace_should_drop_generic_args_in_use() {
         check_assist(