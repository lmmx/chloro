COMPARISON DIFF
============================================================

Original size: 10666 bytes
Chloro size:   10653 bytes
Rustfmt size:  10762 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 ) -> Option<()> {
     let mut original_path: ast::Path = ctx.find_node_at_offset()?;
     // We don't want to mess with use statements
-    if original_path
-        .syntax()
-        .ancestors()
-        .find_map(ast::UseTree::cast)
-        .is_some()
-    {
+    if original_path.syntax().ancestors().find_map(ast::UseTree::cast).is_some() {
         cov_mark::hit!(not_applicable_in_use);
         return None;
     }
     }
     // then search for an import for the first path segment of what we want to replace
     // that way it is less likely that we import the item from a different location due re-exports
-    let module = match ctx
-        .sema
-        .resolve_path(&original_path.first_qualifier_or_self())?
-    {
+    let module = match ctx.sema.resolve_path(&original_path.first_qualifier_or_self())? {
         hir::PathResolution::Def(module @ hir::ModuleDef::Module(_)) => module,
         _ => return None,
     };
     let path_to_qualifier = starts_with_name_ref
         .then(|| {
             let mod_ = ctx.sema.scope(original_path.syntax())?.module();
-            let cfg = ctx
-                .config
-                .find_path_config(ctx.sema.is_nightly(mod_.krate()));
+            let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(mod_.krate()));
             mod_.find_use_path(ctx.sema.db, module, ctx.config.insert_use.prefix_kind, cfg)
         })
         .flatten();
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_replace_already_imported() {
         check_assist(
 }",
         )
     }
-
     #[test]
     fn test_replace_add_use_no_anchor() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn test_replace_add_use_no_anchor_middle_segment() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn test_replace_not_applicable_in_use() {
         cov_mark::check!(not_applicable_in_use);
         check_assist_not_applicable(replace_qualified_name_with_use, r"use std::fmt$0;");
     }
-
     #[test]
     fn replaces_all_affected_paths() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn assist_runs_on_first_segment() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn does_not_replace_in_submodules() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn does_not_replace_in_use() {
         check_assist(
     ",
         );
     }
-
     #[test]
     fn does_not_replace_assoc_item_path() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn replace_reuses_path_qualifier() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn replace_does_not_always_try_to_replace_by_full_item_path() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn replace_should_drop_generic_args_in_use() {
         check_assist(