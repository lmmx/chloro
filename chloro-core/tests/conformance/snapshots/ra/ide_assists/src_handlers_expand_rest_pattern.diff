COMPARISON DIFF
============================================================

Original size: 17027 bytes
Chloro size:   15684 bytes
Rustfmt size:  17604 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: expand_record_rest_pattern
-//
-// Fills fields by replacing rest pattern in record patterns.
-//
-// ```
-// struct Bar { y: Y, z: Z }
-//
-// fn foo(bar: Bar) {
-//     let Bar { ..$0 } = bar;
-// }
-// ```
-// ->
-// ```
-// struct Bar { y: Y, z: Z }
-//
-// fn foo(bar: Bar) {
-//     let Bar { y, z } = bar;
-// }
-// ```
 fn expand_record_rest_pattern(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         return None;
     }
 
-    let edition = ctx
-        .sema
-        .scope(record_pat.syntax())?
-        .krate()
-        .edition(ctx.db());
+    let edition = ctx.sema.scope(record_pat.syntax())?.krate().edition(ctx.db());
     acc.add(
         AssistId::refactor_rewrite("expand_record_rest_pattern"),
         "Fill struct fields",
         rest_pat.syntax().text_range(),
         |builder| {
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = builder.make_editor(rest_pat.syntax());
-            let new_fields = old_field_list
-                .fields()
-                .chain(missing_fields.iter().map(|(f, _)| {
-                    make.record_pat_field_shorthand(
-                        make.ident_pat(
-                            false,
-                            false,
-                            make.name(&f.name(ctx.sema.db).display_no_db(edition).to_smolstr()),
-                        )
-                        .into(),
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = builder.make_editor(rest_pat.syntax());
+        let new_fields = old_field_list.fields().chain(missing_fields.iter().map(|(f, _)| {
+                make.record_pat_field_shorthand(
+                    make.ident_pat(
+                        false,
+                        false,
+                        make.name(&f.name(ctx.sema.db).display_no_db(edition).to_smolstr()),
                     )
-                }));
-            let new_field_list = make.record_pat_field_list(new_fields, None);
-
-            editor.replace(old_field_list.syntax(), new_field_list.syntax());
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+                    .into(),
+                )
+            }));
+        let new_field_list = make.record_pat_field_list(new_fields, None);
+        editor.replace(old_field_list.syntax(), new_field_list.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
-// Assist: expand_tuple_struct_rest_pattern
-//
-// Fills fields by replacing rest pattern in tuple struct patterns.
-//
-// ```
-// struct Bar(Y, Z);
-//
-// fn foo(bar: Bar) {
-//     let Bar(..$0) = bar;
-// }
-// ```
-// ->
-// ```
-// struct Bar(Y, Z);
-//
-// fn foo(bar: Bar) {
-//     let Bar(_0, _1) = bar;
-// }
-// ```
 fn expand_tuple_struct_rest_pattern(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     rest_pat: ast::RestPat,
 ) -> Option<()> {
     let path = pat.path()?;
-    let fields = match ctx
-        .sema
-        .type_of_pat(&pat.clone().into())?
-        .original
-        .as_adt()?
-    {
+    let fields = match ctx.sema.type_of_pat(&pat.clone().into())?.original.as_adt()? {
         hir::Adt::Struct(s) if s.kind(ctx.sema.db) == StructKind::Tuple => s.fields(ctx.sema.db),
         hir::Adt::Enum(_) => match ctx.sema.resolve_path(&path)? {
             PathResolution::Def(hir::ModuleDef::Variant(v))
     let rest_pat = rest_pat.into();
     let (prefix_count, suffix_count) = calculate_counts(&rest_pat, pat.fields())?;
 
-    if fields
-        .len()
-        .saturating_sub(prefix_count)
-        .saturating_sub(suffix_count)
-        == 0
-    {
+    if fields.len().saturating_sub(prefix_count).saturating_sub(suffix_count) == 0 {
         cov_mark::hit!(no_missing_fields_tuple_struct);
         return None;
     }
         "Fill tuple struct fields",
         rest_pat.syntax().text_range(),
         |builder| {
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = builder.make_editor(rest_pat.syntax());
-
-            let mut name_gen = NameGenerator::new_from_scope_locals(ctx.sema.scope(pat.syntax()));
-            let new_pat = make.tuple_struct_pat(
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = builder.make_editor(rest_pat.syntax());
+        let mut name_gen = NameGenerator::new_from_scope_locals(ctx.sema.scope(pat.syntax()));
+        let new_pat = make.tuple_struct_pat(
                 path,
                 pat.fields()
                     .take(prefix_count)
-                    .chain(
-                        fields[prefix_count..fields.len() - suffix_count]
-                            .iter()
-                            .map(|f| {
-                                gen_unnamed_pat(
-                                    ctx,
-                                    &make,
-                                    &mut name_gen,
-                                    &f.ty(ctx.db()).to_type(ctx.sema.db),
-                                    f.index(),
-                                )
-                            }),
-                    )
+                    .chain(fields[prefix_count..fields.len() - suffix_count].iter().map(|f| {
+                        gen_unnamed_pat(
+                            ctx,
+                            &make,
+                            &mut name_gen,
+                            &f.ty(ctx.db()).to_type(ctx.sema.db),
+                            f.index(),
+                        )
+                    }))
                     .chain(pat.fields().skip(prefix_count + 1)),
             );
-
-            editor.replace(pat.syntax(), new_pat.syntax());
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.replace(pat.syntax(), new_pat.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
-// Assist: expand_tuple_rest_pattern
-//
-// Fills fields by replacing rest pattern in tuple patterns.
-//
-// ```
-// fn foo(bar: (char, i32, i32)) {
-//     let (ch, ..$0) = bar;
-// }
-// ```
-// ->
-// ```
-// fn foo(bar: (char, i32, i32)) {
-//     let (ch, _1, _2) = bar;
-// }
-// ```
 fn expand_tuple_rest_pattern(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     pat: ast::TuplePat,
     rest_pat: ast::RestPat,
 ) -> Option<()> {
-    let fields = ctx
-        .sema
-        .type_of_pat(&pat.clone().into())?
-        .original
-        .tuple_fields(ctx.db());
+    let fields = ctx.sema.type_of_pat(&pat.clone().into())?.original.tuple_fields(ctx.db());
     let len = fields.len();
 
     let rest_pat = rest_pat.into();
     let (prefix_count, suffix_count) = calculate_counts(&rest_pat, pat.fields())?;
 
-    if len
-        .saturating_sub(prefix_count)
-        .saturating_sub(suffix_count)
-        == 0
-    {
+    if len.saturating_sub(prefix_count).saturating_sub(suffix_count) == 0 {
         cov_mark::hit!(no_missing_fields_tuple);
         return None;
     }
         "Fill tuple fields",
         rest_pat.syntax().text_range(),
         |builder| {
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = builder.make_editor(rest_pat.syntax());
-
-            let mut name_gen = NameGenerator::new_from_scope_locals(ctx.sema.scope(pat.syntax()));
-            let new_pat = make.tuple_pat(
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = builder.make_editor(rest_pat.syntax());
+        let mut name_gen = NameGenerator::new_from_scope_locals(ctx.sema.scope(pat.syntax()));
+        let new_pat = make.tuple_pat(
                 pat.fields()
                     .take(prefix_count)
-                    .chain(
-                        fields[prefix_count..len - suffix_count]
-                            .iter()
-                            .enumerate()
-                            .map(|(index, ty)| {
-                                gen_unnamed_pat(ctx, &make, &mut name_gen, ty, prefix_count + index)
-                            }),
-                    )
+                    .chain(fields[prefix_count..len - suffix_count].iter().enumerate().map(
+                        |(index, ty)| {
+                            gen_unnamed_pat(ctx, &make, &mut name_gen, ty, prefix_count + index)
+                        },
+                    ))
                     .chain(pat.fields().skip(prefix_count + 1)),
             );
-
-            editor.replace(pat.syntax(), new_pat.syntax());
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.replace(pat.syntax(), new_pat.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
-// Assist: expand_slice_rest_pattern
-//
-// Fills fields by replacing rest pattern in slice patterns.
-//
-// ```
-// fn foo(bar: [i32; 3]) {
-//     let [first, ..$0] = bar;
-// }
-// ```
-// ->
-// ```
-// fn foo(bar: [i32; 3]) {
-//     let [first, _1, _2] = bar;
-// }
-// ```
 fn expand_slice_rest_pattern(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     pat: ast::SlicePat,
     rest_pat: ast::RestPat,
 ) -> Option<()> {
-    let (ty, len) = ctx
-        .sema
-        .type_of_pat(&pat.clone().into())?
-        .original
-        .as_array(ctx.db())?;
+    let (ty, len) = ctx.sema.type_of_pat(&pat.clone().into())?.original.as_array(ctx.db())?;
 
     let rest_pat = rest_pat.into();
     let (prefix_count, suffix_count) = calculate_counts(&rest_pat, pat.pats())?;
 
-    if len
-        .saturating_sub(prefix_count)
-        .saturating_sub(suffix_count)
-        == 0
-    {
+    if len.saturating_sub(prefix_count).saturating_sub(suffix_count) == 0 {
         cov_mark::hit!(no_missing_fields_slice);
         return None;
     }
         "Fill slice fields",
         rest_pat.syntax().text_range(),
         |builder| {
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = builder.make_editor(rest_pat.syntax());
-
-            let mut name_gen = NameGenerator::new_from_scope_locals(ctx.sema.scope(pat.syntax()));
-            let new_pat = make.slice_pat(
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = builder.make_editor(rest_pat.syntax());
+        let mut name_gen = NameGenerator::new_from_scope_locals(ctx.sema.scope(pat.syntax()));
+        let new_pat = make.slice_pat(
                 pat.pats()
                     .take(prefix_count)
                     .chain(
                     )
                     .chain(pat.pats().skip(prefix_count + 1)),
             );
-
-            editor.replace(pat.syntax(), new_pat.syntax());
-
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.replace(pat.syntax(), new_pat.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
         false,
         false,
         match name_gen.for_type(ty, ctx.sema.db, ctx.edition()) {
-            Some(name) => make.name(&name),
-            None => make.name(&format!("_{index}")),
-        },
+        Some(name) => make.name(&name),
+        None => make.name(&format!("_{index}")),
+    },
+    ).into(
     )
-    .into()
 }
 
 fn calculate_counts(
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn fill_fields_enum_with_only_ellipsis() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn fill_fields_enum_with_fields() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn fill_fields_struct_with_only_ellipsis() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn fill_fields_struct_with_fields() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn fill_tuple_with_fields() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn fill_array_with_fields() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn fill_fields_struct_generated_by_macro() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn fill_fields_enum_generated_by_macro() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_when_not_in_ellipsis() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn not_applicable_when_no_missing_fields() {
         // This is still possible even though it's meaningless