COMPARISON DIFF
============================================================

Original size: 6743 bytes
Chloro size:   6171 bytes
Rustfmt size:  6902 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: flip_binexpr
-//
-// Flips operands of a binary expression.
-//
-// ```
-// fn main() {
-//     let _ = 90 +$0 2;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let _ = 2 + 90;
-// }
-// ```
 pub(crate) fn flip_binexpr(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let expr = ctx.find_node_at_offset::<BinExpr>()?;
     let lhs = expr.lhs()?;
 
     let op_token = expr.op_token()?;
     // The assist should be applied only if the cursor is on the operator
-    let cursor_in_range = op_token
-        .text_range()
-        .contains_range(ctx.selection_trimmed());
+    let cursor_in_range = op_token.text_range().contains_range(ctx.selection_trimmed());
     if !cursor_in_range {
         return None;
     }
         "Flip binary expression",
         op_token.text_range(),
         |builder| {
-            let mut editor = builder.make_editor(&expr.syntax().parent().unwrap());
-            let make = SyntaxFactory::with_mappings();
-            if let FlipAction::FlipAndReplaceOp(binary_op) = action {
+        let mut editor = builder.make_editor(&expr.syntax().parent().unwrap());
+        let make = SyntaxFactory::with_mappings();
+        if let FlipAction::FlipAndReplaceOp(binary_op) = action {
                 editor.replace(op_token, make.token(binary_op))
             };
-            editor.replace(lhs.syntax(), rhs.syntax());
-            editor.replace(rhs.syntax(), lhs.syntax());
-            editor.add_mappings(make.finish_with_mappings());
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.replace(lhs.syntax(), rhs.syntax());
+        editor.replace(rhs.syntax(), lhs.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
                     (ast::Ordering::Greater, false) => T![<=],
                 };
                 FlipAction::FlipAndReplaceOp(rev_op)
-            }
+            },
             _ => FlipAction::Flip,
         }
     }
 }
 
-// Assist: flip_range_expr
-//
-// Flips operands of a range expression.
-//
-// ```
-// fn main() {
-//     let _ = 90..$02;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let _ = 2..90;
-// }
-// ```
-// ---
-// ```
-// fn main() {
-//     let _ = 90..$0;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let _ = ..90;
-// }
-// ```
 pub(crate) fn flip_range_expr(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let range_expr = ctx.find_node_at_offset::<ast::RangeExpr>()?;
     let op = range_expr.op_token()?;
         "Flip range expression",
         op.text_range(),
         |builder| {
-            let mut edit = builder.make_editor(range_expr.syntax());
-
-            match (start, end) {
+        let mut edit = builder.make_editor(range_expr.syntax());
+        match (start, end) {
                 (Some(start), Some(end)) => {
                     edit.replace(start.syntax(), end.syntax());
                     edit.replace(end.syntax(), start.syntax());
                 }
                 (None, None) => (),
             }
-
-            builder.add_file_edits(ctx.vfs_file_id(), edit);
-        },
+        builder.add_file_edits(ctx.vfs_file_id(), edit);
+    },
     )
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     #[test]
     fn flip_binexpr_target_is_the_op() {
         check_assist_target(flip_binexpr, "fn f() { let res = 1 ==$0 2; }", "==")
     }
-
     #[test]
     fn flip_binexpr_not_applicable_for_assignment() {
         check_assist_not_applicable(flip_binexpr, "fn f() { let mut _x = 1; _x +=$0 2 }")
     }
-
     #[test]
     fn flip_binexpr_works_for_eq() {
-        check_assist(
-            flip_binexpr,
-            "fn f() { let res = 1 ==$0 2; }",
-            "fn f() { let res = 2 == 1; }",
-        )
+        check_assist(flip_binexpr, "fn f() { let res = 1 ==$0 2; }", "fn f() { let res = 2 == 1; }")
     }
-
     #[test]
     fn flip_binexpr_works_for_gt() {
-        check_assist(
-            flip_binexpr,
-            "fn f() { let res = 1 >$0 2; }",
-            "fn f() { let res = 2 < 1; }",
-        )
+        check_assist(flip_binexpr, "fn f() { let res = 1 >$0 2; }", "fn f() { let res = 2 < 1; }")
     }
-
     #[test]
     fn flip_binexpr_works_for_lteq() {
-        check_assist(
-            flip_binexpr,
-            "fn f() { let res = 1 <=$0 2; }",
-            "fn f() { let res = 2 >= 1; }",
-        )
+        check_assist(flip_binexpr, "fn f() { let res = 1 <=$0 2; }", "fn f() { let res = 2 >= 1; }")
     }
-
     #[test]
     fn flip_binexpr_works_for_complex_expr() {
         check_assist(
             "fn f() { let res = (2 + 2) == (1 + 1); }",
         )
     }
-
     #[test]
     fn flip_binexpr_works_for_lhs_arith() {
         check_assist(
             r"fn f() { let res = 1 + 4 + (2 - 3) + 5; }",
         )
     }
-
     #[test]
     fn flip_binexpr_works_for_lhs_cmp() {
         check_assist(
             r"fn f() { let res = 4 + 5 < 1 + (2 - 3); }",
         )
     }
-
     #[test]
     fn flip_binexpr_works_inside_match() {
         check_assist(