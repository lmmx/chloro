COMPARISON DIFF
============================================================

Original size: 20081 bytes
Chloro size:   19151 bytes
Rustfmt size:  20081 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir::ModuleDef;
 use ide_db::{
-    FxHashSet,
     assists::AssistId,
     defs::Definition,
     helpers::mod_path_to_ast,
-    imports::insert_use::{ImportScope, insert_use},
+    imports::insert_use::{insert_use, ImportScope},
     search::{FileReference, UsageSearchResult},
     source_change::SourceChangeBuilder,
     syntax_helpers::node_ext::{for_each_tail_expr, walk_expr},
+    FxHashSet,
 };
 use syntax::{
-    AstNode, SyntaxNode,
-    ast::{self, HasName, edit::IndentLevel, edit_in_place::Indent, make},
-    match_ast, ted,
+    ast::{self, edit::IndentLevel, edit_in_place::Indent, make, HasName},
+    match_ast, ted, AstNode, SyntaxNode,
 };
 
 use crate::assist_context::{AssistContext, Assists};
 
-// Assist: convert_tuple_return_type_to_struct
-//
-// This converts the return type of a function from a tuple type
-// into a tuple struct and updates the body accordingly.
-//
-// ```
-// fn bar() {
-//     let (a, b, c) = foo();
-// }
-//
-// fn foo() -> ($0u32, u32, u32) {
-//     (1, 2, 3)
-// }
-// ```
-// ->
-// ```
-// fn bar() {
-//     let FooResult(a, b, c) = foo();
-// }
-//
-// struct FooResult(u32, u32, u32);
-//
-// fn foo() -> FooResult {
-//     FooResult(1, 2, 3)
-// }
-// ```
 pub(crate) fn convert_tuple_return_type_to_struct(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         "Convert tuple return type to tuple struct",
         target,
         move |edit| {
-            let ret_type = edit.make_mut(ret_type);
-            let fn_ = edit.make_mut(fn_);
-
-            let usages = Definition::Function(fn_def).usages(&ctx.sema).all();
-            let struct_name = format!("{}Result", stdx::to_camel_case(&fn_name.to_string()));
-            let parent = fn_.syntax().ancestors().find_map(<Either<ast::Impl, ast::Trait>>::cast);
-            add_tuple_struct_def(
+        let ret_type = edit.make_mut(ret_type);
+        let fn_ = edit.make_mut(fn_);
+        let usages = Definition::Function(fn_def).usages(&ctx.sema).all();
+        let struct_name = format!("{}Result", stdx::to_camel_case(&fn_name.to_string()));
+        let parent = fn_.syntax().ancestors().find_map(<Either<ast::Impl, ast::Trait>>::cast);
+        add_tuple_struct_def(
                 edit,
                 ctx,
                 &usages,
                 &struct_name,
                 &target_module,
             );
-
-            ted::replace(
+        ted::replace(
                 ret_type.syntax(),
                 make::ret_type(make::ty(&struct_name)).syntax().clone_for_update(),
             );
-
-            if let Some(fn_body) = fn_.body() {
+        if let Some(fn_body) = fn_.body() {
                 replace_body_return_values(ast::Expr::BlockExpr(fn_body), &struct_name);
             }
-
-            replace_usages(edit, ctx, &usages, &struct_name, &target_module);
-        },
+        replace_usages(edit, ctx, &usages, &struct_name, &target_module);
+    },
     )
 }
 
 ) {
     for (file_id, references) in usages.iter() {
         edit.edit_file(file_id.file_id(ctx.db()));
-
         let refs_with_imports =
             augment_references_with_imports(edit, ctx, references, struct_name, target_module);
-
         refs_with_imports.into_iter().rev().for_each(|(name, import_data)| {
             if let Some(fn_) = name.syntax().parent().and_then(ast::Fn::cast) {
                 cov_mark::hit!(replace_trait_impl_fns);
                     );
                 }
             }
-            // add imports across modules where needed
             if let Some((import_scope, path)) = import_data {
                 insert_use(&import_scope, path, &ctx.config.insert_use);
             }
 ) -> Vec<(ast::NameLike, Option<(ImportScope, ast::Path)>)> {
     let mut visited_modules = FxHashSet::default();
 
-    references
-        .iter()
-        .filter_map(|FileReference { name, .. }| {
-            let name = name.clone().into_name_like()?;
-            ctx.sema.scope(name.syntax()).map(|scope| (name, scope.module()))
-        })
-        .map(|(name, ref_module)| {
-            let new_name = edit.make_mut(name);
-
-            // if the referenced module is not the same as the target one and has not been seen before, add an import
-            let import_data = if ref_module.nearest_non_block_module(ctx.db()) != *target_module
+    references.iter().filter_map(|FileReference { name, .. }| {
+        let name = name.clone().into_name_like()?;
+        ctx.sema.scope(name.syntax()).map(|scope| (name, scope.module()))
+    }).map(|(name, ref_module)| {
+        let new_name = edit.make_mut(name);
+        let import_data = if ref_module.nearest_non_block_module(ctx.db()) != *target_module
                 && !visited_modules.contains(&ref_module)
             {
                 visited_modules.insert(ref_module);
             } else {
                 None
             };
-
-            (new_name, import_data)
-        })
-        .collect()
+        (new_name, import_data)
+    }).collect(
+    )
 }
 
-// Adds the definition of the tuple struct before the parent function.
 fn add_tuple_struct_def(
     edit: &mut SourceChangeBuilder,
     ctx: &AssistContext<'_>,
             if let Some(break_expr_arg) = break_expr.expr() {
                 for_each_tail_expr(&break_expr_arg, &mut |e| tail_cb_impl(acc, e))
             }
-        }
+        },
         ast::Expr::ReturnExpr(_) => {
-            // all return expressions have already been handled by the walk loop
-        }
+        },
         e => acc.push(e.clone()),
     }
 }
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn function_basic() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn struct_and_usages_indented() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn field_usage() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_usage() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_usage_within_same_impl() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn multiple_usages() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn usage_match_tuple_pat() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn usage_if_let_tuple_pat() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn function_nested_outer() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn function_nested_inner() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn trait_impl_and_usage() {
         cov_mark::check!(replace_trait_impl_fns);
 "#,
         )
     }
-
     #[test]
     fn body_wraps_nested() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn body_wraps_break_and_return() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn body_doesnt_wrap_identifier() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn body_doesnt_wrap_other_exprs() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn cross_file_and_module() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn does_not_replace_nested_usage() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn function_with_non_tuple_return_type() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn function_with_impl_type() {
         check_assist_not_applicable(