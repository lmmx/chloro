COMPARISON DIFF
============================================================

Original size: 20081 bytes
Chloro size:   19510 bytes
Rustfmt size:  20081 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use either::Either;
 use hir::ModuleDef;
 use ide_db::{
-    FxHashSet,
     assists::AssistId,
     defs::Definition,
     helpers::mod_path_to_ast,
-    imports::insert_use::{ImportScope, insert_use},
+    imports::insert_use::{insert_use, ImportScope},
     search::{FileReference, UsageSearchResult},
     source_change::SourceChangeBuilder,
     syntax_helpers::node_ext::{for_each_tail_expr, walk_expr},
+    FxHashSet,
 };
 use syntax::{
-    AstNode, SyntaxNode,
-    ast::{self, HasName, edit::IndentLevel, edit_in_place::Indent, make},
-    match_ast, ted,
+    ast::{edit::IndentLevel, edit_in_place::Indent, make, self, HasName},
+    match_ast, ted, AstNode, SyntaxNode,
 };
 
 use crate::assist_context::{AssistContext, Assists};
 
-// Assist: convert_tuple_return_type_to_struct
-//
-// This converts the return type of a function from a tuple type
-// into a tuple struct and updates the body accordingly.
-//
-// ```
-// fn bar() {
-//     let (a, b, c) = foo();
-// }
-//
-// fn foo() -> ($0u32, u32, u32) {
-//     (1, 2, 3)
-// }
-// ```
-// ->
-// ```
-// fn bar() {
-//     let FooResult(a, b, c) = foo();
-// }
-//
-// struct FooResult(u32, u32, u32);
-//
-// fn foo() -> FooResult {
-//     FooResult(1, 2, 3)
-// }
-// ```
 pub(crate) fn convert_tuple_return_type_to_struct(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         .collect()
 }
 
-// Adds the definition of the tuple struct before the parent function.
 fn add_tuple_struct_def(
     edit: &mut SourceChangeBuilder,
     ctx: &AssistContext<'_>,
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn function_basic() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn struct_and_usages_indented() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn field_usage() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_usage() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn method_usage_within_same_impl() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn multiple_usages() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn usage_match_tuple_pat() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn usage_if_let_tuple_pat() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn function_nested_outer() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn function_nested_inner() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn trait_impl_and_usage() {
         cov_mark::check!(replace_trait_impl_fns);
 "#,
         )
     }
-
     #[test]
     fn body_wraps_nested() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn body_wraps_break_and_return() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn body_doesnt_wrap_identifier() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn body_doesnt_wrap_other_exprs() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn cross_file_and_module() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn does_not_replace_nested_usage() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn function_with_non_tuple_return_type() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn function_with_impl_type() {
         check_assist_not_applicable(