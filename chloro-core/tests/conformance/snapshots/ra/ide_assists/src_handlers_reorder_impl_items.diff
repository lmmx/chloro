COMPARISON DIFF
============================================================

Original size: 6390 bytes
Chloro size:   5845 bytes
Rustfmt size:  6460 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use hir::{PathResolution, Semantics};
 use ide_db::{FxHashMap, RootDatabase};
 use itertools::Itertools;
 use syntax::{
-    ast::{self, HasName},
     AstNode, SyntaxElement,
+    ast::{self, HasName},
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: reorder_impl_items
-//
-// Reorder the items of an `impl Trait`. The items will be ordered
-// in the same order as in the trait definition.
-//
-// ```
-// trait Foo {
-//     type A;
-//     const B: u8;
-//     fn c();
-// }
-//
-// struct Bar;
-// $0impl Foo for Bar$0 {
-//     const B: u8 = 17;
-//     fn c() {}
-//     type A = String;
-// }
-// ```
-// ->
-// ```
-// trait Foo {
-//     type A;
-//     const B: u8;
-//     fn c();
-// }
-//
-// struct Bar;
-// impl Foo for Bar {
-//     type A = String;
-//     const B: u8 = 17;
-//     fn c() {}
-// }
-// ```
-pub(crate) fn reorder_impl_items(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn reorder_impl_items(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let impl_ast = ctx.find_node_at_offset::<ast::Impl>()?;
     let items = impl_ast.assoc_item_list()?;
-
     let parent_node = match ctx.covering_element() {
         SyntaxElement::Node(n) => n,
         SyntaxElement::Token(t) => t.parent()?,
     };
-
     // restrict the range
     // if cursor is in assoc_items, abort
     let assoc_range = items.syntax().text_range();
         cov_mark::hit!(not_applicable_editing_assoc_items);
         return None;
     }
-
     let assoc_items = items.assoc_items().collect::<Vec<_>>();
-
     let path = impl_ast
         .trait_()
         .and_then(|t| match t {
             _ => None,
         })?
         .path()?;
-
     let ranks = compute_item_ranks(&path, ctx)?;
     let sorted: Vec<_> = assoc_items
         .iter()
                 ast::AssocItem::MacroCall(_) => None,
             };
 
-            name.and_then(|n| {
-                ranks
-                    .get(n.text().as_str().trim_start_matches("r#"))
-                    .copied()
-            })
-            .unwrap_or(usize::MAX)
+            name.and_then(|n| ranks.get(n.text().as_str().trim_start_matches("r#")).copied())
+                .unwrap_or(usize::MAX)
         })
         .collect();
-
     // Don't edit already sorted methods:
     if assoc_items == sorted {
         cov_mark::hit!(not_applicable_if_sorted);
         return None;
     }
-
     let target = items.syntax().text_range();
     acc.add(
         AssistId::refactor_rewrite("reorder_impl_items"),
     ctx: &AssistContext<'_>,
 ) -> Option<FxHashMap<String, usize>> {
     let td = trait_definition(path, &ctx.sema)?;
-
     Some(
         td.items(ctx.db())
             .iter()
     )
 }
 
-fn trait_definition(path: &ast::Path, sema: &Semantics<'_, RootDatabase>) -> Option<hir::Trait> {
+fn trait_definition(
+    path: &ast::Path,
+    sema: &Semantics<'_, RootDatabase>,
+) -> Option<hir::Trait> {
     match sema.resolve_path(path)? {
         PathResolution::Def(hir::ModuleDef::Trait(trait_)) => Some(trait_),
         _ => None,
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn not_applicable_if_sorted() {
         cov_mark::check!(not_applicable_if_sorted);
         "#,
         )
     }
-
     #[test]
     fn reorder_impl_trait_functions() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn not_applicable_if_empty() {
         check_assist_not_applicable(
         "#,
         )
     }
-
     #[test]
     fn reorder_impl_trait_items() {
         check_assist(
         "#,
         )
     }
-
     #[test]
     fn reorder_impl_trait_items_uneven_ident_lengths() {
         check_assist(
 }"#,
         )
     }
-
     #[test]
     fn not_applicable_editing_assoc_items() {
         cov_mark::check!(not_applicable_editing_assoc_items);