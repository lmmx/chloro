COMPARISON DIFF
============================================================

Original size: 12569 bytes
Chloro size:   12167 bytes
Rustfmt size:  12721 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use hir::{db::HirDatabase, HasSource, HasVisibility, ModuleDef, PathResolution, ScopeDef};
+use hir::{HasSource, HasVisibility, ModuleDef, PathResolution, ScopeDef, db::HirDatabase};
 use ide_db::FileId;
 use syntax::{
-    ast::{self, edit_in_place::HasVisibilityEdit, make, HasVisibility as _},
+    ast::{self, HasVisibility as _, edit_in_place::HasVisibilityEdit, make},
     AstNode, TextRange,
 };
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: fix_visibility
-//
-// Note that there is some duplication between this and the no_such_field diagnostic.
-//
-// Makes inaccessible item public.
-//
-// ```
-// mod m {
-//     fn frobnicate() {}
-// }
-// fn main() {
-//     m::frobnicate$0();
-// }
-// ```
-// ->
-// ```
-// mod m {
-//     $0pub(crate) fn frobnicate() {}
-// }
-// fn main() {
-//     m::frobnicate();
-// }
-// ```
 pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     add_vis_to_referenced_module_def(acc, ctx)
 }
     let ScopeDef::ModuleDef(def) = def else {
         return None;
     };
-
     let current_module = ctx.sema.scope(path.syntax())?.module();
     let target_module = def.module(ctx.db())?;
-
-    if def
-        .visibility(ctx.db())
-        .is_visible_from(ctx.db(), current_module.into())
-    {
+    if def.visibility(ctx.db()).is_visible_from(ctx.db(), current_module.into()) {
         return None;
     };
-
     let (vis_owner, target, target_file, target_name) = target_data_for_def(ctx.db(), def)?;
-
     let missing_visibility = if current_module.krate() == target_module.krate() {
         make::visibility_pub_crate()
     } else {
         make::visibility_pub()
     };
-
     let assist_label = match target_name {
         None => format!("Change visibility to {missing_visibility}"),
         Some(name) => {
             )
         }
     };
+    acc.add(AssistId::quick_fix("fix_visibility"), assist_label, target, |edit| {
+        edit.edit_file(target_file);
 
-    acc.add(
-        AssistId::quick_fix("fix_visibility"),
-        assist_label,
-        target,
-        |edit| {
-            edit.edit_file(target_file);
+        let vis_owner = edit.make_mut(vis_owner);
+        vis_owner.set_visibility(Some(missing_visibility.clone_for_update()));
 
-            let vis_owner = edit.make_mut(vis_owner);
-            vis_owner.set_visibility(Some(missing_visibility.clone_for_update()));
-
-            if let Some((cap, vis)) = ctx.config.snippet_cap.zip(vis_owner.visibility()) {
-                edit.add_tabstop_before(cap, vis);
-            }
-        },
-    )
+        if let Some((cap, vis)) = ctx.config.snippet_cap.zip(vis_owner.visibility()) {
+            edit.add_tabstop_before(cap, vis);
+        }
+    })
 }
 
 fn target_data_for_def(
             file_id.original_file(db).file_id(db),
         ))
     }
-
     let target_name;
     let (offset, target, target_file) = match def {
         hir::ModuleDef::Function(f) => {
             let in_file_source = m.declaration_source(db)?;
             let file_id = in_file_source.file_id.original_file(db);
             let range = in_file_source.value.syntax().text_range();
-            (
-                ast::AnyHasVisibility::new(in_file_source.value),
-                range,
-                file_id.file_id(db),
-            )
+            (ast::AnyHasVisibility::new(in_file_source.value), range, file_id.file_id(db))
         }
         // FIXME
         hir::ModuleDef::Macro(_) => return None,
         // Enum variants can't be private, we can't modify builtin types
         hir::ModuleDef::Variant(_) | hir::ModuleDef::BuiltinType(_) => return None,
     };
-
     Some((offset, target, target_file, target_name))
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn fix_visibility_of_fn() {
         check_assist(
               fn main() { foo::foo$0() } ",
         )
     }
-
     #[test]
     fn fix_visibility_of_adt_in_submodule() {
         check_assist(
               fn main() { foo::Foo$0 } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_adt_in_other_file() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn fix_visibility_of_enum_variant_field() {
         // Enum variants, as well as their fields, always get the enum's visibility. In fact, rustc
 ",
         );
     }
-
     #[test]
     fn fix_visibility_of_const() {
         check_assist(
               fn main() { foo::FOO$0 } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_static() {
         check_assist(
               fn main() { foo::FOO$0 } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_trait() {
         check_assist(
               fn main() { let x: &dyn foo::Foo$0; } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_type_alias() {
         check_assist(
               fn main() { let x: foo::Foo$0; } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_module() {
         check_assist(
             r"mod foo { $0pub(crate) mod bar { fn bar() {} } }
               fn main() { foo::bar::bar(); } ",
         );
-
         check_assist(
             fix_visibility,
             r"
 }
 ",
         );
-
         check_assist_not_applicable(
             fix_visibility,
             r"mod foo { pub mod bar { pub fn bar() {} } }
               fn main() { foo::bar$0::bar(); } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_inline_module_in_other_file() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn fix_visibility_of_module_declaration_in_other_file() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn adds_pub_when_target_is_in_another_crate() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn replaces_pub_crate_with_pub() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn fix_visibility_of_reexport() {
         // FIXME: broken test, this should fix visibility of the re-export