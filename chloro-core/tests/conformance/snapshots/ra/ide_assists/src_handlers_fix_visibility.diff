COMPARISON DIFF
============================================================

Original size: 12569 bytes
Chloro size:   12593 bytes
Rustfmt size:  12721 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     let current_module = ctx.sema.scope(path.syntax())?.module();
     let target_module = def.module(ctx.db())?;
 
-    if def
-        .visibility(ctx.db())
-        .is_visible_from(ctx.db(), current_module.into())
-    {
+    if def.visibility(ctx.db()).is_visible_from(ctx.db(), current_module.into()) {
         return None;
     };
 
         assist_label,
         target,
         |edit| {
-            edit.edit_file(target_file);
+        edit.edit_file(target_file);
 
-            let vis_owner = edit.make_mut(vis_owner);
-            vis_owner.set_visibility(Some(missing_visibility.clone_for_update()));
+        let vis_owner = edit.make_mut(vis_owner);
+        vis_owner.set_visibility(Some(missing_visibility.clone_for_update()));
 
-            if let Some((cap, vis)) = ctx.config.snippet_cap.zip(vis_owner.visibility()) {
-                edit.add_tabstop_before(cap, vis);
-            }
-        },
+        if let Some((cap, vis)) = ctx.config.snippet_cap.zip(vis_owner.visibility()) {
+            edit.add_tabstop_before(cap, vis);
+        }
+    },
     )
 }
 
             let in_file_source = m.declaration_source(db)?;
             let file_id = in_file_source.file_id.original_file(db);
             let range = in_file_source.value.syntax().text_range();
-            (
-                ast::AnyHasVisibility::new(in_file_source.value),
-                range,
-                file_id.file_id(db),
-            )
+            (ast::AnyHasVisibility::new(in_file_source.value), range, file_id.file_id(db))
         }
         // FIXME
         hir::ModuleDef::Macro(_) => return None,
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn fix_visibility_of_fn() {
         check_assist(
               fn main() { foo::foo$0() } ",
         )
     }
-
     #[test]
     fn fix_visibility_of_adt_in_submodule() {
         check_assist(
               fn main() { foo::Foo$0 } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_adt_in_other_file() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn fix_visibility_of_enum_variant_field() {
         // Enum variants, as well as their fields, always get the enum's visibility. In fact, rustc
 ",
         );
     }
-
     #[test]
     fn fix_visibility_of_const() {
         check_assist(
               fn main() { foo::FOO$0 } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_static() {
         check_assist(
               fn main() { foo::FOO$0 } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_trait() {
         check_assist(
               fn main() { let x: &dyn foo::Foo$0; } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_type_alias() {
         check_assist(
               fn main() { let x: foo::Foo$0; } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_module() {
         check_assist(
               fn main() { foo::bar$0::bar(); } ",
         );
     }
-
     #[test]
     fn fix_visibility_of_inline_module_in_other_file() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn fix_visibility_of_module_declaration_in_other_file() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn adds_pub_when_target_is_in_another_crate() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn replaces_pub_crate_with_pub() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn fix_visibility_of_reexport() {
         // FIXME: broken test, this should fix visibility of the re-export