COMPARISON DIFF
============================================================

Original size: 31919 bytes
Chloro size:   31199 bytes
Rustfmt size:  31919 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
-use crate::{
-    AssistConfig,
-    assist_context::{AssistContext, Assists},
-};
 use hir::{HasCrate, Semantics};
 use ide_db::{
-    RootDatabase,
     assists::{AssistId, AssistKind, ExprFillDefaultMode},
     famous_defs::FamousDefs,
     syntax_helpers::suggest_name,
+    RootDatabase,
 };
 use syntax::{
-    AstNode,
     ast::{
-        self, AssocItem, BlockExpr, GenericParam, HasAttrs, HasGenericParams, HasName,
-        HasTypeBounds, HasVisibility, edit::AstNodeEdit, make,
+        self, edit::AstNodeEdit, make, AssocItem, BlockExpr, GenericParam, HasAttrs,
+        HasGenericParams, HasName, HasTypeBounds, HasVisibility,
     },
     syntax_editor::Position,
+    AstNode,
+};
+
+use crate::{
+    assist_context::{AssistContext, Assists},
+    AssistConfig,
 };
 
-// Assist: generate_blanket_trait_impl
-//
-// Generate blanket trait implementation.
-//
-// ```
-// trait $0Foo<T: Send>: ToOwned
-// where
-//     Self::Owned: Default,
-// {
-//     fn foo(&self) -> T;
-//
-//     fn print_foo(&self) {
-//         println!("{}", self.foo());
-//     }
-// }
-// ```
-// ->
-// ```
-// trait Foo<T: Send>: ToOwned
-// where
-//     Self::Owned: Default,
-// {
-//     fn foo(&self) -> T;
-//
-//     fn print_foo(&self) {
-//         println!("{}", self.foo());
-//     }
-// }
-//
-// impl<T: Send, T1: ToOwned + ?Sized> Foo<T> for $0T1
-// where
-//     Self::Owned: Default,
-// {
-//     fn foo(&self) -> T {
-//         todo!()
-//     }
-// }
-// ```
 pub(crate) fn generate_blanket_trait_impl(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     Some(())
 }
 
-fn existing_any_impl(traitd: &ast::Trait, sema: &Semantics<'_, RootDatabase>) -> Option<hir::Impl> {
+fn existing_any_impl(
+    traitd: &ast::Trait,
+    sema: &Semantics<'_, RootDatabase>,
+) -> Option<hir::Impl> {
     let db = sema.db;
     let traitd = sema.to_def(traitd)?;
-    traitd
-        .module(db)
-        .impl_defs(db)
-        .into_iter()
-        .find(|impl_| impl_.trait_(db).is_some_and(|it| it == traitd))
+    traitd.module(db).impl_defs(db).into_iter().find(
+        |impl_| impl_.trait_(db).is_some_and(|it| it == traitd),
+    )
 }
 
 fn has_sized(traitd: &ast::Trait, sema: &Semantics<'_, RootDatabase>) -> bool {
     } else if let Some(is_sized) = where_clause_sized(traitd.where_clause()) {
         is_sized
     } else {
-        contained_owned_self_method(traitd.assoc_item_list())
-            || super_traits_has_sized(traitd, sema) == Some(true)
+        contained_owned_self_method(traitd.assoc_item_list()) || super_traits_has_sized(traitd, sema) == Some(true)
     }
 }
 
-fn super_traits_has_sized(traitd: &ast::Trait, sema: &Semantics<'_, RootDatabase>) -> Option<bool> {
+fn super_traits_has_sized(
+    traitd: &ast::Trait,
+    sema: &Semantics<'_, RootDatabase>,
+) -> Option<bool> {
     let traitd = sema.to_def(traitd)?;
     let sized = FamousDefs(sema, traitd.krate(sema.db)).core_marker_Sized()?;
 
         match item {
             AssocItem::Fn(f) => {
                 has_owned_self(&f) && where_clause_sized(f.where_clause()).is_none()
-            }
+            },
             _ => false,
         }
     })
 }
 
 fn has_owned_self_param(f: &ast::Fn) -> bool {
-    f.param_list()
-        .and_then(|param_list| param_list.self_param())
-        .is_some_and(|sp| sp.amp_token().is_none() && sp.colon_token().is_none())
+    f.param_list().and_then(|param_list| param_list.self_param()).is_some_and(
+        |sp| sp.amp_token().is_none() && sp.colon_token().is_none(),
+    )
 }
 
 fn has_ret_owned_self(f: &ast::Fn) -> bool {
-    f.ret_type()
-        .and_then(|ret| match ret.ty() {
-            Some(ast::Type::PathType(ty)) => ty.path(),
-            _ => None,
-        })
-        .is_some_and(|path| {
-            path.segment()
-                .and_then(|seg| seg.name_ref())
-                .is_some_and(|name| path.qualifier().is_none() && name.text() == "Self")
-        })
+    f.ret_type().and_then(|ret| match ret.ty() {
+        Some(ast::Type::PathType(ty)) => ty.path(),
+        _ => None,
+    }).is_some_and(|path| {
+        path.segment().and_then(|seg| seg.name_ref()).is_some_and(
+            |name| path.qualifier().is_none() && name.text() == "Self",
+        )
+    })
 }
 
 fn where_clause_sized(where_clause: Option<ast::WhereClause>) -> Option<bool> {
     where_clause?.predicates().find_map(|pred| {
-        find_bound("Sized", pred.type_bound_list())
-            .map(|bound| bound.question_mark_token().is_none())
+        find_bound("Sized", pred.type_bound_list()).map(
+            |bound| bound.question_mark_token().is_none(),
+        )
     })
 }
 
     let mut name_gen =
         suggest_name::NameGenerator::new_with_names(params.iter().map(String::as_str));
 
-    make::name(&name_gen.suggest_name(if has_iter { "I" } else { "T" }))
+    make::name(&name_gen.suggest_name(if has_iter {
+        "I"
+    } else {
+        "T"
+    }))
 }
 
 fn find_bound(s: &str, bounds: Option<ast::TypeBoundList>) -> Option<ast::TypeBound> {
 
 #[cfg(test)]
 mod test {
-
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn test_gen_blanket_works() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_sized() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_super_sized() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_non_sized() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_other_assoc_items() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_indent() {
         check_assist(
         "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_remove_attribute() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_not_gen_type_alias() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_no_quick_bound() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_no_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_basic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_cfg_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_quick_bounds() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause_comma() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause_newline() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause_newline_newline() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause_newline_newline_comma() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_multiple_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_multiple_bounds_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_generate() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_trait_with_doc() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_multiple_method() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_lifetimes() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_lifetime_bounds() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_lifetime_quick_bounds() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_multiple_lifetimes() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_lifetime_bounds_at_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_not_on_name() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_existing_impl() {
         cov_mark::check!(existing_any_impl);
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_existing_other_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_apply_on_other_impl_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_apply_on_other_blanket_impl_block() {
         check_assist(