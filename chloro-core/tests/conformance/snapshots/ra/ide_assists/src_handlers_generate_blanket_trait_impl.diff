COMPARISON DIFF
============================================================

Original size: 31919 bytes
Chloro size:   31917 bytes
Rustfmt size:  32022 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
                 apply_sized(has_sized(&traitd, &ctx.sema), bounds),
             ))]);
 
-            let trait_gen_args = traitd
-                .generic_param_list()
-                .map(|param_list| param_list.to_generic_args());
+            let trait_gen_args =
+                traitd.generic_param_list().map(|param_list| param_list.to_generic_args());
 
             let impl_ = make::impl_trait(
                 cfg_attrs(&traitd),
     Some(())
 }
 
-fn existing_any_impl(traitd: &ast::Trait, sema: &Semantics<'_, RootDatabase>) -> Option<hir::Impl> {
+fn existing_any_impl(
+    traitd: &ast::Trait,
+    sema: &Semantics<'_, RootDatabase>,
+) -> Option<hir::Impl> {
     let db = sema.db;
     let traitd = sema.to_def(traitd)?;
     traitd
     } else if let Some(is_sized) = where_clause_sized(traitd.where_clause()) {
         is_sized
     } else {
-        contained_owned_self_method(traitd.assoc_item_list())
-            || super_traits_has_sized(traitd, sema) == Some(true)
+        contained_owned_self_method(traitd.assoc_item_list()) || super_traits_has_sized(traitd, sema) == Some(true)
     }
 }
 
-fn super_traits_has_sized(traitd: &ast::Trait, sema: &Semantics<'_, RootDatabase>) -> Option<bool> {
+fn super_traits_has_sized(
+    traitd: &ast::Trait,
+    sema: &Semantics<'_, RootDatabase>,
+) -> Option<bool> {
     let traitd = sema.to_def(traitd)?;
     let sized = FamousDefs(sema, traitd.krate(sema.db)).core_marker_Sized()?;
 
 }
 
 fn contained_owned_self_method(item_list: Option<ast::AssocItemList>) -> bool {
-    item_list
-        .into_iter()
-        .flat_map(|assoc_item_list| assoc_item_list.assoc_items())
-        .any(|item| match item {
+    item_list.into_iter().flat_map(|assoc_item_list| assoc_item_list.assoc_items()).any(|item| {
+        match item {
             AssocItem::Fn(f) => {
                 has_owned_self(&f) && where_clause_sized(f.where_clause()).is_none()
             }
             _ => false,
-        })
+        }
+    })
 }
 
 fn has_owned_self(f: &ast::Fn) -> bool {
     let mut name_gen =
         suggest_name::NameGenerator::new_with_names(params.iter().map(String::as_str));
 
-    make::name(&name_gen.suggest_name(if has_iter { "I" } else { "T" }))
+    make::name(&name_gen.suggest_name(if has_iter {
+        "I"
+    } else {
+        "T"
+    }))
 }
 
 fn find_bound(s: &str, bounds: Option<ast::TypeBoundList>) -> Option<ast::TypeBound> {
-    bounds
-        .into_iter()
-        .flat_map(|bounds| bounds.bounds())
-        .find(|bound| ty_bound_is(bound, s))
+    bounds.into_iter().flat_map(|bounds| bounds.bounds()).find(|bound| ty_bound_is(bound, s))
 }
 
 fn ty_bound_is(bound: &ast::TypeBound, s: &str) -> bool {
 }
 
 fn todo_fn(f: &ast::Fn, config: &AssistConfig) -> ast::Fn {
-    let params = f
-        .param_list()
-        .unwrap_or_else(|| make::param_list(None, None));
+    let params = f.param_list().unwrap_or_else(|| make::param_list(None, None));
     make::fn_(
         cfg_attrs(f),
         f.visibility(),
 }
 
 fn cfg_attrs(node: &impl HasAttrs) -> impl Iterator<Item = ast::Attr> {
-    node.attrs().filter(|attr| {
-        attr.as_simple_call()
-            .is_some_and(|(name, _arg)| name == "cfg")
-    })
+    node.attrs().filter(|attr| attr.as_simple_call().is_some_and(|(name, _arg)| name == "cfg"))
 }
 
 #[cfg(test)]
 mod test {
-
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn test_gen_blanket_works() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_sized() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_super_sized() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_non_sized() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_other_assoc_items() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_indent() {
         check_assist(
         "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_remove_attribute() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_not_gen_type_alias() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_no_quick_bound() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_no_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_basic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_cfg_attrs() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_quick_bounds() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause_comma() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause_newline() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause_newline_newline() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_where_clause_newline_newline_comma() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_multiple_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_trait_with_multiple_bounds_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_empty_generate() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_trait_with_doc() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_multiple_method() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_generic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_lifetimes() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_lifetime_bounds() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_lifetime_quick_bounds() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_multiple_lifetimes() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_method_with_lifetime_bounds_at_where_clause() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_not_on_name() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_existing_impl() {
         cov_mark::check!(existing_any_impl);
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_existing_other_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_apply_on_other_impl_block() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_gen_blanket_apply_on_other_blanket_impl_block() {
         check_assist(