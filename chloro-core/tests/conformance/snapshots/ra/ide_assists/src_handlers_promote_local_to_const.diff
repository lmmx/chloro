COMPARISON DIFF
============================================================

Original size: 6477 bytes
Chloro size:   5873 bytes
Rustfmt size:  6522 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{
     assist_context::{AssistContext, Assists},
-    utils::{self},
+    utils::self,
 };
 
-// Assist: promote_local_to_const
-//
-// Promotes a local variable to a const item changing its name to a `SCREAMING_SNAKE_CASE` variant
-// if the local uses no non-const expressions.
-//
-// ```
-// fn main() {
-//     let foo$0 = true;
-//
-//     if foo {
-//         println!("It's true");
-//     } else {
-//         println!("It's false");
-//     }
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     const $0FOO: bool = true;
-//
-//     if FOO {
-//         println!("It's true");
-//     } else {
-//         println!("It's false");
-//     }
-// }
-// ```
 pub(crate) fn promote_local_to_const(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let pat = ctx.find_node_at_offset::<ast::IdentPat>()?;
     let name = pat.name()?;
         "Promote local to constant",
         let_stmt.syntax().text_range(),
         |edit| {
-            let make = SyntaxFactory::with_mappings();
-            let mut editor = edit.make_editor(let_stmt.syntax());
-            let name = to_upper_snake_case(&name.to_string());
-            let usages = Definition::Local(local).usages(&ctx.sema).all();
-            if let Some(usages) = usages.references.get(&ctx.file_id()) {
+        let make = SyntaxFactory::with_mappings();
+        let mut editor = edit.make_editor(let_stmt.syntax());
+        let name = to_upper_snake_case(&name.to_string());
+        let usages = Definition::Local(local).usages(&ctx.sema).all();
+        if let Some(usages) = usages.references.get(&ctx.file_id()) {
                 let name_ref = make.name_ref(&name);
 
                 for usage in usages {
-                    let Some(usage_name) = usage.name.as_name_ref().cloned() else {
-                        continue;
-                    };
+                    let Some(usage_name) = usage.name.as_name_ref().cloned() else { continue };
                     if let Some(record_field) = ast::RecordExprField::for_name_ref(&usage_name) {
                         let path = make.ident_path(&name);
                         let name_expr = make.expr_path(path);
                     }
                 }
             }
-
-            let item = make.item_const(None, None, make.name(&name), make.ty(&ty), initializer);
-
-            if let Some((cap, name)) = ctx.config.snippet_cap.zip(item.name()) {
+        let item = make.item_const(None, None, make.name(&name), make.ty(&ty), initializer);
+        if let Some((cap, name)) = ctx.config.snippet_cap.zip(item.name()) {
                 let tabstop = edit.make_tabstop_before(cap);
                 editor.add_annotation(name.syntax().clone(), tabstop);
             }
-
-            editor.replace(let_stmt.syntax(), item.syntax());
-
-            editor.add_mappings(make.finish_with_mappings());
-            edit.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.replace(let_stmt.syntax(), item.syntax());
+        editor.add_mappings(make.finish_with_mappings());
+        edit.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn simple() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn multiple_uses() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn usage_in_field_shorthand() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn usage_in_macro() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn usage_shorthand_in_macro() {
         check_assist(
 ",
         )
     }
-
     #[test]
     fn not_applicable_non_const_meth_call() {
         cov_mark::check!(promote_local_non_const);
 ",
         );
     }
-
     #[test]
     fn not_applicable_non_const_call() {
         check_assist_not_applicable(
 ",
         );
     }
-
     #[test]
     fn not_applicable_unknown_ty() {
         check_assist(
 ",
         );
     }
-
     #[test]
     fn not_applicable_non_simple_ident() {
         cov_mark::check!(promote_local_non_simple_ident);