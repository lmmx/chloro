COMPARISON DIFF
============================================================

Original size: 14759 bytes
Chloro size:   13767 bytes
Rustfmt size:  14777 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 
 use crate::{AssistContext, Assists};
 
-// Assist: sugar_impl_future_into_async
-//
-// Rewrites asynchronous function from `-> impl Future` into `async fn`.
-// This action does not touch the function body and therefore `async { 0 }`
-// block does not transform to just `0`.
-//
-// ```
-// # //- minicore: future
-// pub fn foo() -> impl core::future::F$0uture<Output = usize> {
-//     async { 0 }
-// }
-// ```
-// ->
-// ```
-// pub async fn foo() -> usize {
-//     async { 0 }
-// }
-// ```
 pub(crate) fn sugar_impl_future_into_async(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         "Convert `impl Future` into async",
         function.syntax().text_range(),
         |builder| {
-            match future_output {
+        match future_output {
                 // Empty tuple
                 ast::Type::TupleType(t) if t.fields().next().is_none() => {
                     let mut ret_type_range = ret_type.syntax().text_range();
                     );
                 }
             }
-
-            let (place_for_async, async_kw) = match function.visibility() {
+        let (place_for_async, async_kw) = match function.visibility() {
                 Some(vis) => (vis.syntax().text_range().end(), " async"),
                 None => (function.syntax().text_range().start(), "async "),
             };
-            builder.insert(place_for_async, async_kw);
-        },
+        builder.insert(place_for_async, async_kw);
+    },
     )
 }
 
-// Assist: desugar_async_into_impl_future
-//
-// Rewrites asynchronous function from `async fn` into `-> impl Future`.
-// This action does not touch the function body and therefore `0`
-// block does not transform to `async { 0 }`.
-//
-// ```
-// # //- minicore: future
-// pub as$0ync fn foo() -> usize {
-//     0
-// }
-// ```
-// ->
-// ```
-// pub fn foo() -> impl core::future::Future<Output = usize> {
-//     0
-// }
-// ```
 pub(crate) fn desugar_async_into_impl_future(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
 
     let scope = ctx.sema.scope(function.syntax())?;
     let module = scope.module();
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(module.krate()));
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(module.krate()));
     let future_trait = FamousDefs(&ctx.sema, scope.krate()).core_future_Future()?;
     let trait_path = module.find_path(ctx.db(), ModuleDef::Trait(future_trait), cfg)?;
     let edition = scope.krate().edition(ctx.db());
         "Convert async into `impl Future`",
         function.syntax().text_range(),
         |builder| {
-            let mut async_range = async_token.text_range();
-
-            if let Some(whitespace_range) = following_whitespace(NodeOrToken::Token(async_token)) {
+        let mut async_range = async_token.text_range();
+        if let Some(whitespace_range) = following_whitespace(NodeOrToken::Token(async_token)) {
                 async_range = TextRange::new(async_range.start(), whitespace_range.end());
             }
-            builder.delete(async_range);
-
-            match return_type {
-                Some(ret_type) => builder.replace(
-                    ret_type.syntax().text_range(),
-                    format!("impl {trait_path}<Output = {ret_type}>"),
-                ),
-                None => builder.insert(
-                    rparen.text_range().end(),
-                    format!(" -> impl {trait_path}<Output = ()>"),
-                ),
-            }
-        },
+        builder.delete(async_range);
+        match return_type {
+            Some(ret_type) => builder.replace(
+                ret_type.syntax().text_range(),
+                format!("impl {trait_path}<Output = {ret_type}>"),
+            ),
+            None => builder.insert(rparen.text_range().end(), format!(" -> impl {trait_path}<Output = ()>")),
+        }
+    },
     )
 }
 
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     #[test]
     fn sugar_with_use() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn desugar_with_use() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn sugar_without_use() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn desugar_without_use() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn not_applicable() {
         check_assist_not_applicable(
     "#,
         );
     }
-
     #[test]
     fn sugar_definition_with_use() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn sugar_definition_without_use() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn sugar_more_types() {
         check_assist(
     "#,
         );
     }
-
     #[test]
     fn sugar_with_modifiers() {
         check_assist_not_applicable(