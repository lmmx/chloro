COMPARISON DIFF
============================================================

Original size: 33414 bytes
Chloro size:   33368 bytes
Rustfmt size:  33727 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
                     doc_lines.append(&mut lines);
                 }
             }
-            builder.insert(
-                text_range.start(),
-                documentation_from_lines(doc_lines, indent_level),
-            );
+            builder.insert(text_range.start(), documentation_from_lines(doc_lines, indent_level));
         },
     )
 }
 pub(crate) fn generate_doc_example(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let tok: ast::Comment = ctx.find_token_at_offset()?;
     let node = tok.syntax().parent()?;
-    let last_doc_token = ast::AnyHasDocComments::cast(node.clone())?
-        .doc_comments()
-        .last()?
-        .syntax()
-        .clone();
+    let last_doc_token =
+        ast::AnyHasDocComments::cast(node.clone())?.doc_comments().last()?.syntax().clone();
     let next_token = skip_whitespace_token(last_doc_token.next_token()?, syntax::Direction::Next)?;
 
     let example = match_ast! {
                 };
 
                 let self_ty = linkable_self_ty?;
-                Some(format!(
-                    "Returns{reference} the {what} of this [`{self_ty}`]."
-                ))
+                Some(format!("Returns{reference} the {what} of this [`{self_ty}`]."))
             }
             _ => None,
         };
 /// Builds an optional `# Errors` section
 fn errors_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {
     match return_type(ast_func)?.to_string().contains("Result") {
-        true => Some(string_vec_from(&[
-            "# Errors",
-            "",
-            "This function will return an error if .",
-        ])),
+        true => Some(string_vec_from(&["# Errors", "", "This function will return an error if ."])),
         false => None,
     }
 }
 fn is_public(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<bool> {
     let hir_func = ctx.sema.to_def(ast_func)?;
     Some(
-        hir_func.visibility(ctx.db()) == Visibility::Public
-            && all_parent_mods_public(&hir_func, ctx),
+        hir_func.visibility(ctx.db()) == Visibility::Public && all_parent_mods_public(&hir_func, ctx),
     )
 }
 
     let body = ast_func.body()?.to_string();
     let mut iter = body.chars();
     let assert_postfix = |s| {
-        ["!(", "_eq!(", "_ne!(", "_matches!("]
-            .iter()
-            .any(|postfix| str::starts_with(s, postfix))
+        ["!(", "_eq!(", "_ne!(", "_matches!("].iter().any(|postfix| str::starts_with(s, postfix))
     };
 
     while !iter.as_str().is_empty() {
 
 /// Helper function to get the name of the type of `self`
 fn self_type(ast_func: &ast::Fn) -> Option<ast::Type> {
-    ast_func
-        .syntax()
-        .ancestors()
-        .find_map(ast::Impl::cast)
-        .and_then(|i| i.self_ty())
+    ast_func.syntax().ancestors().find_map(ast::Impl::cast).and_then(|i| i.self_ty())
 }
 
 /// Output the real name of `Self` like `MyType<T>`, without the lifetimes.
         _ => return None,
     };
     let mut name = path_segment.name_ref()?.to_string();
-    let generics = path_segment
-        .generic_arg_list()
-        .into_iter()
-        .flat_map(|list| {
-            list.generic_args()
-                .filter(|generic| matches!(generic, ast::GenericArg::TypeArg(_)))
-                .map(|generic| generic.to_string())
-        });
+    let generics = path_segment.generic_arg_list().into_iter().flat_map(|list| {
+        list.generic_args()
+            .filter(|generic| matches!(generic, ast::GenericArg::TypeArg(_)))
+            .map(|generic| generic.to_string())
+    });
     let generics: String = generics.format(", ").to_string();
     if !generics.is_empty() {
         name.push('<');
 
 /// Helper function to count the parameters including `self`
 fn count_parameters(param_list: &ast::ParamList) -> usize {
-    param_list.params().count()
-        + if param_list.self_param().is_some() {
-            1
-        } else {
-            0
-        }
+    param_list.params().count() + if param_list.self_param().is_some() { 1 } else { 0 }
 }
 
 /// Helper function to transform lines of documentation into a Rust code documentation
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn not_applicable_on_function_calls() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn not_applicable_in_trait_impl() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn not_applicable_if_function_already_documented() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn supports_noop_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn is_applicable_if_function_is_private() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_doc_example_for_private_fn() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn supports_a_parameter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn detects_unsafe_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_panic_macro_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_debug_assert_macro_cannot_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_assert_macro_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_assert_eq_macro_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_unwrap_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_expect_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn checks_output_in_example() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn detects_result_output() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn checks_ref_mut_in_example() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn stores_result_if_at_least_3_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_fn_in_mods() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_fn_in_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_unsafe_fn_in_trait() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_fn_in_trait_with_default_panicking() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_fn_in_trait_returning_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn detects_new() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn removes_one_lifetime_from_description() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn removes_all_lifetimes_from_description() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn removes_all_lifetimes_and_brackets_from_description() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn detects_new_with_self() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_method_call() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn checks_modified_self_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generates_intro_for_getters() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_getter_intro_for_prefixed_methods() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generates_intro_for_setters() {
         check_assist(