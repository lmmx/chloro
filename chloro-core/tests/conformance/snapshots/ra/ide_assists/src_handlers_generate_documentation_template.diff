COMPARISON DIFF
============================================================

Original size: 33414 bytes
Chloro size:   32429 bytes
Rustfmt size:  33414 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{AsAssocItem, HasVisibility, ModuleDef, Visibility};
 use ide_db::assists::AssistId;
 use itertools::Itertools;
 use stdx::{format_to, to_lower_snake_case};
 use syntax::{
-    AstNode, AstToken, Edition,
     algo::skip_whitespace_token,
     ast::{self, HasDocComments, HasGenericArgs, HasName, edit::IndentLevel},
-    match_ast,
+    match_ast, AstNode, AstToken, Edition,
 };
 
 use crate::assist_context::{AssistContext, Assists};
 
-// Assist: generate_documentation_template
-//
-// Adds a documentation template above a function definition / declaration.
-//
-// ```
-// pub struct S;
-// impl S {
-//     pub unsafe fn set_len$0(&mut self, len: usize) -> Result<(), std::io::Error> {
-//         /* ... */
-//     }
-// }
-// ```
-// ->
-// ```
-// pub struct S;
-// impl S {
-//     /// Sets the length of this [`S`].
-//     ///
-//     /// # Errors
-//     ///
-//     /// This function will return an error if .
-//     ///
-//     /// # Safety
-//     ///
-//     /// .
-//     pub unsafe fn set_len(&mut self, len: usize) -> Result<(), std::io::Error> {
-//         /* ... */
-//     }
-// }
-// ```
 pub(crate) fn generate_documentation_template(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     if is_in_trait_impl(&ast_func, ctx) || ast_func.doc_comments().next().is_some() {
         return None;
     }
-
     let parent_syntax = ast_func.syntax();
     let text_range = parent_syntax.text_range();
     let indent_level = IndentLevel::from_node(parent_syntax);
-
     acc.add(
         AssistId::generate("generate_documentation_template"),
         "Generate a documentation template",
     )
 }
 
-// Assist: generate_doc_example
-//
-// Generates a rustdoc example when editing an item's documentation.
-//
-// ```
-// /// Adds two numbers.$0
-// pub fn add(a: i32, b: i32) -> i32 { a + b }
-// ```
-// ->
-// ```
-// /// Adds two numbers.
-// ///
-// /// # Examples
-// ///
-// /// ```
-// /// use ra_test_fixture::add;
-// ///
-// /// assert_eq!(add(a, b), );
-// /// ```
-// pub fn add(a: i32, b: i32) -> i32 { a + b }
-// ```
-pub(crate) fn generate_doc_example(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn generate_doc_example(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let tok: ast::Comment = ctx.find_token_at_offset()?;
     let node = tok.syntax().parent()?;
     let last_doc_token =
         ast::AnyHasDocComments::cast(node.clone())?.doc_comments().last()?.syntax().clone();
     let next_token = skip_whitespace_token(last_doc_token.next_token()?, syntax::Direction::Next)?;
-
     let example = match_ast! {
         match node {
             ast::Fn(it) => make_example_for_fn(&it, ctx)?,
             _ => return None,
         }
     };
-
     let mut lines = string_vec_from(&["", "# Examples", "", "```"]);
     lines.extend(example.lines().map(String::from));
     lines.push("```".into());
     let indent_level = IndentLevel::from_node(&node);
-
     acc.add(
         AssistId::generate("generate_doc_example"),
         "Generate a documentation example",
     )
 }
 
-fn make_example_for_fn(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<String> {
+fn make_example_for_fn(
+    ast_func: &ast::Fn,
+    ctx: &AssistContext<'_>,
+) -> Option<String> {
     if !is_public(ast_func, ctx)? {
         // Doctests for private items can't actually name the item, so they're pretty useless.
         return None;
     }
-
     if is_in_trait_def(ast_func, ctx) {
         // This is not yet implemented.
         return None;
     }
-
     let mut example = String::new();
-
     let edition = ctx.sema.scope(ast_func.syntax())?.krate().edition(ctx.db());
     let use_path = build_path(ast_func, ctx, edition)?;
     let is_unsafe = ast_func.unsafe_token().is_some();
     let param_list = ast_func.param_list()?;
     let ref_mut_params = ref_mut_params(&param_list);
     let self_name = self_name(ast_func);
-
     format_to!(example, "use {use_path};\n\n");
     if let Some(self_name) = &self_name
         && let Some(mut_) = is_ref_mut_self(ast_func)
     for param_name in &ref_mut_params {
         format_to!(example, "assert_eq!({param_name}, );");
     }
-
     Some(example)
 }
 
-fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<String> {
+fn introduction_builder(
+    ast_func: &ast::Fn,
+    ctx: &AssistContext<'_>,
+) -> Option<String> {
     let hir_func = ctx.sema.to_def(ast_func)?;
     let container = hir_func.as_assoc_item(ctx.db())?.container(ctx.db());
     if let hir::AssocItemContainer::Impl(imp) = container {
 }
 
 /// Checks if the function is public / exported
-fn is_public(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<bool> {
+fn is_public(
+    ast_func: &ast::Fn,
+    ctx: &AssistContext<'_>,
+) -> Option<bool> {
     let hir_func = ctx.sema.to_def(ast_func)?;
     Some(
         hir_func.visibility(ctx.db()) == Visibility::Public
 }
 
 /// Checks that all parent modules of the function are public / exported
-fn all_parent_mods_public(hir_func: &hir::Function, ctx: &AssistContext<'_>) -> bool {
+fn all_parent_mods_public(
+    hir_func: &hir::Function,
+    ctx: &AssistContext<'_>,
+) -> bool {
     let mut module = hir_func.module(ctx.db());
     loop {
         if let Some(parent) = module.parent(ctx.db()) {
 }
 
 /// Returns the name of the current crate
-fn crate_name(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> Option<String> {
+fn crate_name(
+    ast_func: &ast::Fn,
+    ctx: &AssistContext<'_>,
+) -> Option<String> {
     let krate = ctx.sema.scope(ast_func.syntax())?.krate();
     Some(krate.display_name(ctx.db())?.to_string())
 }
     let assert_postfix = |s| {
         ["!(", "_eq!(", "_ne!(", "_matches!("].iter().any(|postfix| str::starts_with(s, postfix))
     };
-
     while !iter.as_str().is_empty() {
         let s = iter.as_str();
         iter.next();
             return Some(true);
         }
     }
-
     Some(false)
 }
 
 }
 
 /// Helper function to determine if the function is in a trait implementation
-fn is_in_trait_impl(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> bool {
+fn is_in_trait_impl(
+    ast_func: &ast::Fn,
+    ctx: &AssistContext<'_>,
+) -> bool {
     ctx.sema
         .to_def(ast_func)
         .and_then(|hir_func| hir_func.as_assoc_item(ctx.db()))
 }
 
 /// Helper function to determine if the function definition is in a trait definition
-fn is_in_trait_def(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> bool {
+fn is_in_trait_def(
+    ast_func: &ast::Fn,
+    ctx: &AssistContext<'_>,
+) -> bool {
     ctx.sema
         .to_def(ast_func)
         .and_then(|hir_func| hir_func.as_assoc_item(ctx.db()))
 }
 
 /// Helper function to transform lines of documentation into a Rust code documentation
-fn documentation_from_lines(doc_lines: Vec<String>, indent_level: IndentLevel) -> String {
+fn documentation_from_lines(
+    doc_lines: Vec<String>,
+    indent_level: IndentLevel,
+) -> String {
     let mut result = String::new();
     for doc_line in doc_lines {
         result.push_str("///");
 }
 
 /// Helper function to build the path of the module in the which is the node
-fn build_path(ast_func: &ast::Fn, ctx: &AssistContext<'_>, edition: Edition) -> Option<String> {
+fn build_path(
+    ast_func: &ast::Fn,
+    ctx: &AssistContext<'_>,
+    edition: Edition,
+) -> Option<String> {
     let crate_name = crate_name(ast_func, ctx)?;
     let leaf = self_partial_type(ast_func)
         .or_else(|| ast_func.name().map(|n| n.to_string()))
 }
 
 /// Helper function to determine if the function returns some data
-fn returns_a_value(ast_func: &ast::Fn, ctx: &AssistContext<'_>) -> bool {
+fn returns_a_value(
+    ast_func: &ast::Fn,
+    ctx: &AssistContext<'_>,
+) -> bool {
     ctx.sema
         .to_def(ast_func)
         .map(|hir_func| hir_func.ret_type(ctx.db()))
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn not_applicable_on_function_calls() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn not_applicable_in_trait_impl() {
         check_assist_not_applicable(
 "#,
         )
     }
-
     #[test]
     fn not_applicable_if_function_already_documented() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn supports_noop_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn is_applicable_if_function_is_private() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_doc_example_for_private_fn() {
         check_assist_not_applicable(
 "#,
         );
     }
-
     #[test]
     fn supports_a_parameter() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn detects_unsafe_function() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_panic_macro_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_debug_assert_macro_cannot_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_assert_macro_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_assert_eq_macro_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_unwrap_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn guesses_expect_can_panic() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn checks_output_in_example() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn detects_result_output() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn checks_ref_mut_in_example() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn stores_result_if_at_least_3_params() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_fn_in_mods() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_fn_in_impl() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_unsafe_fn_in_trait() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_fn_in_trait_with_default_panicking() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_fn_in_trait_returning_result() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn detects_new() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn removes_one_lifetime_from_description() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn removes_all_lifetimes_from_description() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn removes_all_lifetimes_and_brackets_from_description() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn detects_new_with_self() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn supports_method_call() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn checks_modified_self_param() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generates_intro_for_getters() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn no_getter_intro_for_prefixed_methods() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn generates_intro_for_setters() {
         check_assist(