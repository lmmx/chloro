COMPARISON DIFF
============================================================

Original size: 30915 bytes
Chloro size:   30917 bytes
Rustfmt size:  31569 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
     let current_module = ctx.sema.scope(adt.syntax())?.module();
     let current_crate = current_module.krate();
     let current_edition = current_crate.edition(ctx.db());
-    let cfg = ctx
-        .config
-        .find_path_config(ctx.sema.is_nightly(current_crate));
+    let cfg = ctx.config.find_path_config(ctx.sema.is_nightly(current_crate));
 
     let found_traits = items_locator::items_with_name(
         ctx.db(),
         )?;
     }
     if no_traits_found {
-        add_assist(
-            acc,
-            ctx,
-            &attr,
-            &current_derives,
-            &args,
-            &path,
-            &path,
-            None,
-            &adt,
-        )?;
+        add_assist(acc, ctx, &attr, &current_derives, &args, &path, &path, None, &adt)?;
     }
     Some(())
 }
         label,
         target,
         |builder| {
-            let insert_after = Position::after(adt.syntax());
-            let impl_is_unsafe = trait_.map(|s| s.is_unsafe(ctx.db())).unwrap_or(false);
-            let impl_def = impl_def_from_trait(
-                &ctx.sema,
-                ctx.config,
-                adt,
-                &annotated_name,
-                trait_,
-                replace_trait_path,
-                impl_is_unsafe,
-            );
+        let insert_after = Position::after(adt.syntax());
+        let impl_is_unsafe = trait_.map(|s| s.is_unsafe(ctx.db())).unwrap_or(false);
+        let impl_def = impl_def_from_trait(
+            &ctx.sema,
+            ctx.config,
+            adt,
+            &annotated_name,
+            trait_,
+            replace_trait_path,
+            impl_is_unsafe,
+        );
 
-            let mut editor = builder.make_editor(attr.syntax());
-            update_attribute(&mut editor, old_derives, old_tree, old_trait_path, attr);
+        let mut editor = builder.make_editor(attr.syntax());
+        update_attribute(&mut editor, old_derives, old_tree, old_trait_path, attr);
 
-            let trait_path = make::ty_path(replace_trait_path.clone());
+        let trait_path = make::ty_path(replace_trait_path.clone());
 
-            let (impl_def, first_assoc_item) = if let Some(impl_def) = impl_def {
-                (
-                    impl_def.clone(),
-                    impl_def
-                        .assoc_item_list()
-                        .and_then(|list| list.assoc_items().next()),
-                )
-            } else {
-                (generate_trait_impl(impl_is_unsafe, adt, trait_path), None)
-            };
+        let (impl_def, first_assoc_item) = if let Some(impl_def) = impl_def {
+            (
+                impl_def.clone(),
+                impl_def.assoc_item_list().and_then(|list| list.assoc_items().next()),
+            )
+        } else {
+            (generate_trait_impl(impl_is_unsafe, adt, trait_path), None)
+        };
 
-            if let Some(cap) = ctx.config.snippet_cap {
-                if let Some(first_assoc_item) = first_assoc_item {
-                    if let ast::AssocItem::Fn(ref func) = first_assoc_item
-                        && let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast)
-                        && m.syntax().text() == "todo!()"
-                    {
-                        // Make the `todo!()` a placeholder
-                        builder.add_placeholder_snippet(cap, m);
-                    } else {
-                        // If we haven't already added a snippet, add a tabstop before the generated function
-                        builder.add_tabstop_before(cap, first_assoc_item);
-                    }
-                } else if let Some(l_curly) =
-                    impl_def.assoc_item_list().and_then(|it| it.l_curly_token())
+        if let Some(cap) = ctx.config.snippet_cap {
+            if let Some(first_assoc_item) = first_assoc_item {
+                if let ast::AssocItem::Fn(ref func) = first_assoc_item
+                    && let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast)
+                    && m.syntax().text() == "todo!()"
                 {
-                    builder.add_tabstop_after_token(cap, l_curly);
+                    // Make the `todo!()` a placeholder
+                    builder.add_placeholder_snippet(cap, m);
+                } else {
+                    // If we haven't already added a snippet, add a tabstop before the generated function
+                    builder.add_tabstop_before(cap, first_assoc_item);
                 }
+            } else if let Some(l_curly) =
+                impl_def.assoc_item_list().and_then(|it| it.l_curly_token())
+            {
+                builder.add_tabstop_after_token(cap, l_curly);
             }
+        }
 
-            editor.insert_all(
-                insert_after,
-                vec![
-                    make::tokens::blank_line().into(),
-                    impl_def.syntax().clone().into(),
-                ],
-            );
-            builder.add_file_edits(ctx.vfs_file_id(), editor);
-        },
+        editor.insert_all(
+            insert_after,
+            vec![make::tokens::blank_line().into(), impl_def.syntax().clone().into()],
+        );
+        builder.add_file_edits(ctx.vfs_file_id(), editor);
+    },
     )
 }
 
         IgnoreAssocItems::DocHiddenAttrPresent
     };
 
-    let trait_items = filter_assoc_items(
-        sema,
-        &trait_.items(sema.db),
-        DefaultMethods::No,
-        ignore_items,
-    );
+    let trait_items =
+        filter_assoc_items(sema, &trait_.items(sema.db), DefaultMethods::No, ignore_items);
 
     if trait_items.is_empty() {
         return None;
 
     let assoc_items =
         add_trait_assoc_items_to_impl(sema, config, &trait_items, trait_, &impl_def, &target_scope);
-    let assoc_item_list = if let Some((first, other)) = assoc_items
-        .split_first()
-        .map(|(first, other)| (first.clone_subtree(), other))
+    let assoc_item_list = if let Some((first, other)) =
+        assoc_items.split_first().map(|(first, other)| (first.clone_subtree(), other))
     {
         let first_item = if let ast::AssocItem::Fn(ref func) = first
             && let Some(body) = gen_trait_fn_body(func, trait_path, adt, None)
         } else {
             Some(first.clone())
         };
-        let items = first_item
-            .into_iter()
-            .chain(other.iter().cloned())
-            .collect();
+        let items = first_item.into_iter().chain(other.iter().cloned()).collect();
         make::assoc_item_list(Some(items))
     } else {
         make::assoc_item_list(None)
 
     let impl_def = impl_def.clone_subtree();
     let mut editor = SyntaxEditor::new(impl_def.syntax().clone());
-    editor.replace(
-        impl_def.assoc_item_list()?.syntax(),
-        assoc_item_list.syntax(),
-    );
+    editor.replace(impl_def.assoc_item_list()?.syntax(), assoc_item_list.syntax());
     let impl_def = ast::Impl::cast(editor.finish().new_root().clone())?;
     Some(impl_def)
 }
 
     if has_more_derives {
         // Make the paths into flat lists of tokens in a vec
-        let tt = new_derives
-            .iter()
-            .map(|path| path.syntax().clone())
-            .map(|node| {
-                node.descendants_with_tokens()
-                    .filter_map(|element| element.into_token())
-                    .collect::<Vec<_>>()
-            });
+        let tt = new_derives.iter().map(|path| path.syntax().clone()).map(|node| {
+            node.descendants_with_tokens()
+                .filter_map(|element| element.into_token())
+                .collect::<Vec<_>>()
+        });
         // ...which are interspersed with ", "
         let tt = Itertools::intersperse(tt, vec![make::token(T![,]), make::tokens::single_space()]);
         // ...wrap them into the appropriate `NodeOrToken` variant
         editor.replace(old_tree.syntax(), new_tree.syntax());
     } else {
         // Remove the attr and any trailing whitespace
-
-        if let Some(line_break) = attr
-            .syntax()
-            .next_sibling_or_token()
-            .filter(|t| t.kind() == WHITESPACE)
+        if let Some(line_break) =
+            attr.syntax().next_sibling_or_token().filter(|t| t.kind() == WHITESPACE)
         {
             editor.delete(line_break)
         }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn add_custom_impl_debug_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_debug_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_empty_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_record_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_record_struct_multi_field() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_empty_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_single_variant_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_partial_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum_generic() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum_generic_existing_bounds() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_record_enum() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_for_with_visibility_modifier() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_when_multiple_inputs() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_default_generic_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_generic_tuple_struct_with_bounds() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_ignore_derive_macro_without_input() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn test_ignore_if_cursor_on_param() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn test_ignore_if_not_derive() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn works_at_start_of_file() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn add_custom_impl_keep_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_replace_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn unsafeness_of_a_trait_observed() {
         check_assist(