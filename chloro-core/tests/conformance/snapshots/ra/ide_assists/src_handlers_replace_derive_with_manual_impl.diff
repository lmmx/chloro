COMPARISON DIFF
============================================================

Original size: 30915 bytes
Chloro size:   30318 bytes
Rustfmt size:  30915 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{InFile, ModuleDef};
 use ide_db::{helpers::mod_path_to_ast, imports::import_assets::NameToImport, items_locator};
 use itertools::Itertools;
 use syntax::{
+    ast::{self, make, AstNode, HasName},
+    syntax_editor::{Position, SyntaxEditor},
     SyntaxKind::WHITESPACE,
     T,
-    ast::{self, AstNode, HasName, make},
-    syntax_editor::{Position, SyntaxEditor},
 };
 
 use crate::{
-    AssistConfig, AssistId,
     assist_context::{AssistContext, Assists},
     utils::{
-        DefaultMethods, IgnoreAssocItems, add_trait_assoc_items_to_impl, filter_assoc_items,
-        gen_trait_fn_body, generate_trait_impl,
+        add_trait_assoc_items_to_impl, filter_assoc_items, gen_trait_fn_body, generate_trait_impl,
+        DefaultMethods, IgnoreAssocItems,
     },
+    AssistConfig, AssistId,
 };
 
-// Assist: replace_derive_with_manual_impl
-//
-// Converts a `derive` impl into a manual one.
-//
-// ```
-// # //- minicore: derive
-// # trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }
-// #[derive(Deb$0ug, Display)]
-// struct S;
-// ```
-// ->
-// ```
-// # trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }
-// #[derive(Display)]
-// struct S;
-//
-// impl Debug for S {
-//     $0fn fmt(&self, f: &mut Formatter) -> Result<()> {
-//         f.debug_struct("S").finish()
-//     }
-// }
-// ```
 pub(crate) fn replace_derive_with_manual_impl(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
         .descendants()
         .filter_map(ast::Attr::cast)
         .filter_map(|attr| attr.path())
-        .collect::<Vec<_>>();
+        .collect();
 
     let adt = value.parent().and_then(ast::Adt::cast)?;
     let attr = ast::Attr::cast(value)?;
         NameToImport::exact_case_sensitive(path.segments().last()?.to_string()),
         items_locator::AssocSearchMode::Exclude,
     )
-    .filter_map(|(item, _)| match item.into_module_def() {
+        .filter_map(|(item, _)| match item.into_module_def() {
         ModuleDef::Trait(trait_) => Some(trait_),
         _ => None,
     })
-    .flat_map(|trait_| {
+        .flat_map(|trait_| {
         current_module
             .find_path(ctx.sema.db, hir::ModuleDef::Trait(trait_), cfg)
             .as_ref()
         IgnoreAssocItems::DocHiddenAttrPresent
     };
 
-    let trait_items =
-        filter_assoc_items(sema, &trait_.items(sema.db), DefaultMethods::No, ignore_items);
+    let trait_items = filter_assoc_items(sema, &trait_.items(sema.db), DefaultMethods::No, ignore_items);
 
     if trait_items.is_empty() {
         return None;
     }
     let impl_def = generate_trait_impl(impl_is_unsafe, adt, make::ty_path(trait_path.clone()));
 
-    let assoc_items =
-        add_trait_assoc_items_to_impl(sema, config, &trait_items, trait_, &impl_def, &target_scope);
+    let assoc_items = add_trait_assoc_items_to_impl(sema, config, &trait_items, trait_, &impl_def, &target_scope);
     let assoc_item_list = if let Some((first, other)) =
         assoc_items.split_first().map(|(first, other)| (first.clone_subtree(), other))
     {
     } else {
         make::assoc_item_list(None)
     }
-    .clone_for_update();
+        .clone_for_update();
 
     let impl_def = impl_def.clone_subtree();
     let mut editor = SyntaxEditor::new(impl_def.syntax().clone());
     old_trait_path: &ast::Path,
     attr: &ast::Attr,
 ) {
-    let new_derives = old_derives
-        .iter()
-        .filter(|t| t.to_string() != old_trait_path.to_string())
-        .collect::<Vec<_>>();
+    let new_derives = old_derives.iter().filter(|t| t.to_string() != old_trait_path.to_string()).collect();
     let has_more_derives = !new_derives.is_empty();
 
     if has_more_derives {
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn add_custom_impl_debug_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_debug_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_empty_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_record_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_record_struct_multi_field() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_empty_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_single_variant_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_partial_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum_generic() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum_generic_existing_bounds() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_record_enum() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_for_with_visibility_modifier() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_when_multiple_inputs() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_default_generic_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_generic_tuple_struct_with_bounds() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_ignore_derive_macro_without_input() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn test_ignore_if_cursor_on_param() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn test_ignore_if_not_derive() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn works_at_start_of_file() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn add_custom_impl_keep_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_replace_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn unsafeness_of_a_trait_observed() {
         check_assist(