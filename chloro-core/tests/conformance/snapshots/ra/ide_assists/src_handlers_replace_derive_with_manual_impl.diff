COMPARISON DIFF
============================================================

Original size: 30915 bytes
Chloro size:   30120 bytes
Rustfmt size:  30915 bytes

âœ— Outputs DIFFER

=== DIFF (- rustfmt, + chloro) ===
 use hir::{InFile, ModuleDef};
 use ide_db::{helpers::mod_path_to_ast, imports::import_assets::NameToImport, items_locator};
 use itertools::Itertools;
 use syntax::{
+    ast::{self, make, AstNode, HasName},
+    syntax_editor::{Position, SyntaxEditor},
     SyntaxKind::WHITESPACE,
     T,
-    ast::{self, AstNode, HasName, make},
-    syntax_editor::{Position, SyntaxEditor},
 };
 
 use crate::{
-    AssistConfig, AssistId,
     assist_context::{AssistContext, Assists},
     utils::{
-        DefaultMethods, IgnoreAssocItems, add_trait_assoc_items_to_impl, filter_assoc_items,
-        gen_trait_fn_body, generate_trait_impl,
+        add_trait_assoc_items_to_impl, filter_assoc_items, gen_trait_fn_body, generate_trait_impl,
+        DefaultMethods, IgnoreAssocItems,
     },
+    AssistConfig, AssistId,
 };
 
-// Assist: replace_derive_with_manual_impl
-//
-// Converts a `derive` impl into a manual one.
-//
-// ```
-// # //- minicore: derive
-// # trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }
-// #[derive(Deb$0ug, Display)]
-// struct S;
-// ```
-// ->
-// ```
-// # trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }
-// #[derive(Display)]
-// struct S;
-//
-// impl Debug for S {
-//     $0fn fmt(&self, f: &mut Formatter) -> Result<()> {
-//         f.debug_struct("S").finish()
-//     }
-// }
-// ```
 pub(crate) fn replace_derive_with_manual_impl(
     acc: &mut Assists,
     ctx: &AssistContext<'_>,
     let annotated_name = adt.name()?;
     let label = format!("Convert to manual `impl {replace_trait_path} for {annotated_name}`");
 
-    acc.add(AssistId::refactor("replace_derive_with_manual_impl"), label, target, |builder| {
+    acc.add(
+        AssistId::refactor("replace_derive_with_manual_impl"),
+        label,
+        target,
+        |builder| {
         let insert_after = Position::after(adt.syntax());
         let impl_is_unsafe = trait_.map(|s| s.is_unsafe(ctx.db())).unwrap_or(false);
         let impl_def = impl_def_from_trait(
             vec![make::tokens::blank_line().into(), impl_def.syntax().clone().into()],
         );
         builder.add_file_edits(ctx.vfs_file_id(), editor);
-    })
+    },
+    )
 }
 
 fn impl_def_from_trait(
     let has_more_derives = !new_derives.is_empty();
 
     if has_more_derives {
-        // Make the paths into flat lists of tokens in a vec
         let tt = new_derives.iter().map(|path| path.syntax().clone()).map(|node| {
             node.descendants_with_tokens()
                 .filter_map(|element| element.into_token())
                 .collect::<Vec<_>>()
         });
-        // ...which are interspersed with ", "
         let tt = Itertools::intersperse(tt, vec![make::token(T![,]), make::tokens::single_space()]);
-        // ...wrap them into the appropriate `NodeOrToken` variant
         let tt = tt.flatten().map(syntax::NodeOrToken::Token);
-        // ...and make them into a flat list of tokens
         let tt = tt.collect::<Vec<_>>();
-
         let new_tree = make::token_tree(T!['('], tt).clone_for_update();
         editor.replace(old_tree.syntax(), new_tree.syntax());
     } else {
-        // Remove the attr and any trailing whitespace
-
         if let Some(line_break) =
             attr.syntax().next_sibling_or_token().filter(|t| t.kind() == WHITESPACE)
         {
             editor.delete(line_break)
         }
-
         editor.delete(attr.syntax())
     }
 }
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn add_custom_impl_debug_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_debug_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_hash_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_empty_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_record_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_record_struct_multi_field() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_ord_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_empty_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_single_variant_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_partial_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum_generic() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_tuple_enum_generic_existing_bounds() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_partial_eq_record_enum() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_for_with_visibility_modifier() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_when_multiple_inputs() {
         check_assist(
             "#,
         )
     }
-
     #[test]
     fn add_custom_impl_default_generic_record_struct() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_clone_generic_tuple_struct_with_bounds() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn test_ignore_derive_macro_without_input() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn test_ignore_if_cursor_on_param() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn test_ignore_if_not_derive() {
         check_assist_not_applicable(
             "#,
         )
     }
-
     #[test]
     fn works_at_start_of_file() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn add_custom_impl_keep_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn add_custom_impl_replace_path() {
         check_assist(
 "#,
         )
     }
-
     #[test]
     fn unsafeness_of_a_trait_observed() {
         check_assist(