COMPARISON DIFF
============================================================

Original size: 11079 bytes
Chloro size:   10737 bytes
Rustfmt size:  11433 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Definition of `InferCtxtLike` from the librarified type layer.
 
 use rustc_type_ir::{
-    inherent::{Const as _, IntoKind, Ty as _},
-    relate::combine::PredicateEmittingRelation,
     ConstVid, FloatVarValue, FloatVid, GenericArgKind, InferConst, InferTy, IntVarValue, IntVid,
     RegionVid, TyVid, TypeFoldable, TypingMode, UniverseIndex,
+    inherent::{Const as _, IntoKind, Ty as _},
+    relate::combine::PredicateEmittingRelation,
 };
 
 use crate::next_solver::{
-    infer::opaque_types::{table::OpaqueTypeStorageEntries, OpaqueHiddenType},
     Binder, Const, ConstKind, DbInterner, ErrorGuaranteed, GenericArgs, OpaqueTypeKey, Region,
     SolverDefId, Span, Ty, TyKind,
+    infer::opaque_types::{OpaqueHiddenType, table::OpaqueTypeStorageEntries},
 };
-
-use super::{relate::RelateResult, BoundRegionConversionTime, InferCtxt};
+use super::{BoundRegionConversionTime, InferCtxt, relate::RelateResult};
 
 impl<'db> rustc_type_ir::InferCtxtLike for InferCtxt<'db> {
     type Interner = DbInterner<'db>;
     }
 
     fn universe_of_lt(&self, lt: RegionVid) -> Option<UniverseIndex> {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .probe_value(lt)
-            .err()
+        self.inner.borrow_mut().unwrap_region_constraints().probe_value(lt).err()
     }
 
     fn universe_of_ct(&self, ct: ConstVid) -> Option<UniverseIndex> {
             GenericArgKind::Type(ty) => {
                 if let TyKind::Infer(infer_ty) = ty.kind() {
                     match infer_ty {
-                        InferTy::TyVar(vid) => !self
-                            .probe_ty_var(vid)
-                            .is_err_and(|_| self.root_var(vid) == vid),
+                        InferTy::TyVar(vid) => {
+                            !self.probe_ty_var(vid).is_err_and(|_| self.root_var(vid) == vid)
+                        }
                         InferTy::IntVar(vid) => {
                             let mut inner = self.inner.borrow_mut();
                             !matches!(
         self.fresh_args_for_item(def_id)
     }
 
-    fn instantiate_binder_with_infer<T: TypeFoldable<DbInterner<'db>> + Clone>(
-        &self,
-        value: Binder<'db, T>,
-    ) -> T {
+    fn instantiate_binder_with_infer<T: TypeFoldable<DbInterner<'db>> + Clone>(&self, value: Binder<'db, T>) -> T {
         self.instantiate_binder_with_fresh_vars(BoundRegionConversionTime::HigherRankedType, value)
     }
 
-    fn enter_forall<T: TypeFoldable<DbInterner<'db>> + Clone, U>(
-        &self,
-        value: Binder<'db, T>,
-        f: impl FnOnce(T) -> U,
-    ) -> U {
+    fn enter_forall<T: TypeFoldable<DbInterner<'db>> + Clone, U>(&self, value: Binder<'db, T>, f: impl FnOnce(T) -> U) -> U {
         self.enter_forall(value, f)
     }
 
     }
 
     fn equate_float_vids_raw(&self, a: rustc_type_ir::FloatVid, b: rustc_type_ir::FloatVid) {
-        self.inner
-            .borrow_mut()
-            .float_unification_table()
-            .union(a, b);
+        self.inner.borrow_mut().float_unification_table().union(a, b);
     }
 
     fn equate_const_vids_raw(&self, a: rustc_type_ir::ConstVid, b: rustc_type_ir::ConstVid) {
-        self.inner
-            .borrow_mut()
-            .const_unification_table()
-            .union(a, b);
+        self.inner.borrow_mut().const_unification_table().union(a, b);
     }
 
-    fn instantiate_ty_var_raw<R: PredicateEmittingRelation<Self>>(
-        &self,
-        relation: &mut R,
-        target_is_expected: bool,
-        target_vid: rustc_type_ir::TyVid,
-        instantiation_variance: rustc_type_ir::Variance,
-        source_ty: Ty<'db>,
-    ) -> RelateResult<'db, ()> {
+    fn instantiate_ty_var_raw<R: PredicateEmittingRelation<Self>>(&self, relation: &mut R, target_is_expected: bool, target_vid: rustc_type_ir::TyVid, instantiation_variance: rustc_type_ir::Variance, source_ty: Ty<'db>) -> RelateResult<'db, ()> {
         self.instantiate_ty_var(
             relation,
             target_is_expected,
         )
     }
 
-    fn instantiate_int_var_raw(
-        &self,
-        vid: rustc_type_ir::IntVid,
-        value: rustc_type_ir::IntVarValue,
-    ) {
-        self.inner
-            .borrow_mut()
-            .int_unification_table()
-            .union_value(vid, value);
+    fn instantiate_int_var_raw(&self, vid: rustc_type_ir::IntVid, value: rustc_type_ir::IntVarValue) {
+        self.inner.borrow_mut().int_unification_table().union_value(vid, value);
     }
 
-    fn instantiate_float_var_raw(
-        &self,
-        vid: rustc_type_ir::FloatVid,
-        value: rustc_type_ir::FloatVarValue,
-    ) {
-        self.inner
-            .borrow_mut()
-            .float_unification_table()
-            .union_value(vid, value);
+    fn instantiate_float_var_raw(&self, vid: rustc_type_ir::FloatVid, value: rustc_type_ir::FloatVarValue) {
+        self.inner.borrow_mut().float_unification_table().union_value(vid, value);
     }
 
-    fn instantiate_const_var_raw<R: PredicateEmittingRelation<Self>>(
-        &self,
-        relation: &mut R,
-        target_is_expected: bool,
-        target_vid: rustc_type_ir::ConstVid,
-        source_ct: Const<'db>,
-    ) -> RelateResult<'db, ()> {
+    fn instantiate_const_var_raw<R: PredicateEmittingRelation<Self>>(&self, relation: &mut R, target_is_expected: bool, target_vid: rustc_type_ir::ConstVid, source_ct: Const<'db>) -> RelateResult<'db, ()> {
         self.instantiate_const_var(relation, target_is_expected, target_vid, source_ct)
     }
 
     fn shallow_resolve(&self, ty: Ty<'db>) -> Ty<'db> {
         self.shallow_resolve(ty)
     }
+
     fn shallow_resolve_const(&self, ct: Const<'db>) -> Const<'db> {
         self.shallow_resolve_const(ct)
     }
 
     fn resolve_vars_if_possible<T>(&self, value: T) -> T
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         self.resolve_vars_if_possible(value)
     }
 
     }
 
     fn sub_regions(&self, sub: Region<'db>, sup: Region<'db>, _span: Span) {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .make_subregion(sub, sup);
+        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(sub, sup);
     }
 
     fn equate_regions(&self, a: Region<'db>, b: Region<'db>, _span: Span) {
-        self.inner
-            .borrow_mut()
-            .unwrap_region_constraints()
-            .make_eqregion(a, b);
+        self.inner.borrow_mut().unwrap_region_constraints().make_eqregion(a, b);
     }
 
     fn register_ty_outlives(&self, _ty: Ty<'db>, _r: Region<'db>, _span: Span) {
     fn opaque_types_storage_num_entries(&self) -> OpaqueTypeStorageEntries {
         self.inner.borrow_mut().opaque_types().num_entries()
     }
+
     fn clone_opaque_types_lookup_table(&self) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
-        self.inner
-            .borrow_mut()
-            .opaque_types()
-            .iter_lookup_table()
-            .map(|(k, h)| (k, h.ty))
-            .collect()
+        self.inner.borrow_mut().opaque_types().iter_lookup_table().map(|(k, h)| (k, h.ty)).collect()
     }
+
     fn clone_duplicate_opaque_types(&self) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
         self.inner
             .borrow_mut()
             .map(|(k, h)| (k, h.ty))
             .collect()
     }
-    fn clone_opaque_types_added_since(
-        &self,
-        prev_entries: OpaqueTypeStorageEntries,
-    ) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
+
+    fn clone_opaque_types_added_since(&self, prev_entries: OpaqueTypeStorageEntries) -> Vec<(OpaqueTypeKey<'db>, Ty<'db>)> {
         self.inner
             .borrow_mut()
             .opaque_types()
             .collect()
     }
 
-    fn register_hidden_type_in_storage(
-        &self,
-        opaque_type_key: OpaqueTypeKey<'db>,
-        hidden_ty: Ty<'db>,
-        _span: Span,
-    ) -> Option<Ty<'db>> {
+    fn register_hidden_type_in_storage(&self, opaque_type_key: OpaqueTypeKey<'db>, hidden_ty: Ty<'db>, _span: Span) -> Option<Ty<'db>> {
         self.register_hidden_type_in_storage(opaque_type_key, OpaqueHiddenType { ty: hidden_ty })
     }
-    fn add_duplicate_opaque_type(
-        &self,
-        opaque_type_key: OpaqueTypeKey<'db>,
-        hidden_ty: Ty<'db>,
-        _span: Span,
-    ) {
+
+    fn add_duplicate_opaque_type(&self, opaque_type_key: OpaqueTypeKey<'db>, hidden_ty: Ty<'db>, _span: Span) {
         self.inner
             .borrow_mut()
             .opaque_types()
         self.sub_unify_ty_vids_raw(a, b);
     }
 
-    fn opaques_with_sub_unified_hidden_type(
-        &self,
-        _ty: TyVid,
-    ) -> Vec<rustc_type_ir::AliasTy<Self::Interner>> {
+    fn opaques_with_sub_unified_hidden_type(&self, _ty: TyVid) -> Vec<rustc_type_ir::AliasTy<Self::Interner>> {
         // FIXME: I guess we are okay without this for now since currently r-a lacks of
         // detailed checks over opaque types. Might need to implement this in future.
         vec![]