COMPARISON DIFF
============================================================

Original size: 58275 bytes
Chloro size:   57301 bytes
Rustfmt size:  58275 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 impl IntoIterator for UsageSearchResult {
     type Item = (EditionedFileId, Vec<FileReference>);
+
     type IntoIter = <FxHashMap<EditionedFileId, Vec<FileReference>> as IntoIterator>::IntoIter;
 
     fn into_iter(self) -> Self::IntoIter {
             FileReferenceNode::FormatStringEntry(_, range) => *range,
         }
     }
+
     pub fn syntax(&self) -> SyntaxElement {
         match self {
             FileReferenceNode::Name(it) => it.syntax().clone().into(),
             FileReferenceNode::FormatStringEntry(it, _) => it.syntax().clone().into(),
         }
     }
+
     pub fn into_name_like(self) -> Option<ast::NameLike> {
         match self {
             FileReferenceNode::Name(it) => Some(ast::NameLike::Name(it)),
             FileReferenceNode::FormatStringEntry(_, _) => None,
         }
     }
+
     pub fn as_name_ref(&self) -> Option<&ast::NameRef> {
         match self {
             FileReferenceNode::NameRef(name_ref) => Some(name_ref),
             _ => None,
         }
     }
+
     pub fn as_lifetime(&self) -> Option<&ast::Lifetime> {
         match self {
             FileReferenceNode::Lifetime(lifetime) => Some(lifetime),
             _ => None,
         }
     }
+
     pub fn text(&self) -> syntax::TokenText<'_> {
         match self {
             FileReferenceNode::NameRef(name_ref) => name_ref.text(),
         }
     }
 }
-
-bitflags::bitflags! {
-    #[derive(Copy, Clone, Default, PartialEq, Eq, Hash, Debug)]
-    pub struct ReferenceCategory: u8 {
-        // FIXME: Add this variant and delete the `retain_adt_literal_usages` function.
-        // const CREATE = 1 << 0;
-        const WRITE = 1 << 0;
-        const READ = 1 << 1;
-        const IMPORT = 1 << 2;
-        const TEST = 1 << 3;
-    }
-}
-
+// FIXME: Add this variant and delete the `retain_adt_literal_usages` function.
+// const CREATE = 1 << 0;
 /// Generally, `search_scope` returns files that might contain references for the element.
 /// For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.
 /// In some cases, the location of the references is known to within a `TextRange`,
     /// Build a search scope spanning the entire crate graph of files.
     fn crate_graph(db: &RootDatabase) -> SearchScope {
         let mut entries = FxHashMap::default();
-
         let all_crates = db.all_crates();
         for &krate in all_crates.iter() {
             let crate_data = krate.data(db);
     /// Build a search scope spanning the given crate.
     fn krate(db: &RootDatabase, of: hir::Crate) -> SearchScope {
         let root_file = of.root_file(db);
-
         let source_root_id = db.file_source_root(root_file).source_root_id(db);
         let source_root = db.source_root(source_root_id).source_root(db);
         SearchScope {
     /// Build a search scope spanning the given module and all its submodules.
     pub fn module_and_children(db: &RootDatabase, module: hir::Module) -> SearchScope {
         let mut entries = FxHashMap::default();
-
         let (file_id, range) = {
             let InFile { file_id, value } = module.definition_source_range(db);
             if let Some(InRealFile { file_id, value: call_source }) = file_id.original_call_node(db)
             }
         };
         entries.entry(file_id).or_insert(range);
-
         let mut to_visit: Vec<_> = module.children(db).collect();
         while let Some(module) = to_visit.pop() {
             if let Some(file_id) = module.as_source_file_id(db) {
         if small.len() > large.len() {
             mem::swap(&mut small, &mut large)
         }
-
         let intersect_ranges =
             |r1: Option<TextRange>, r2: Option<TextRange>| -> Option<Option<TextRange>> {
                 match (r1, r2) {
                 Some((file_id, r))
             })
             .collect();
-
         SearchScope::new(res)
     }
 }
 
 impl IntoIterator for SearchScope {
     type Item = (EditionedFileId, Option<TextRange>);
+
     type IntoIter = std::collections::hash_map::IntoIter<EditionedFileId, Option<TextRange>>;
 
     fn into_iter(self) -> Self::IntoIter {
 impl Definition {
     fn search_scope(&self, db: &RootDatabase) -> SearchScope {
         let _p = tracing::info_span!("search_scope").entered();
-
         if let Definition::BuiltinType(_) = self {
             return SearchScope::crate_graph(db);
         }
-
         // def is crate root
         if let &Definition::Module(module) = self
             && module.is_crate_root()
         {
             return SearchScope::reverse_dependencies(db, module.krate());
         }
-
         let module = match self.module(db) {
             Some(it) => it,
             None => return SearchScope::empty(),
         };
         let InFile { file_id, value: module_source } = module.definition_source(db);
         let file_id = file_id.original_file(db);
-
         if let Definition::Local(var) = self {
             let def = match var.parent(db) {
                 DefWithBody::Function(f) => f.source(db).map(|src| src.syntax().cloned()),
                 None => SearchScope::single_file(file_id),
             };
         }
-
         if let Definition::InlineAsmOperand(op) = self {
             let def = match op.parent(db) {
                 DefWithBody::Function(f) => f.source(db).map(|src| src.syntax().cloned()),
                 None => SearchScope::single_file(file_id),
             };
         }
-
         if let Definition::SelfType(impl_) = self {
             return match impl_.source(db).map(|src| src.syntax().cloned()) {
                 Some(def) => SearchScope::file_range(
                 None => SearchScope::single_file(file_id),
             };
         }
-
         if let Definition::GenericParam(hir::GenericParam::LifetimeParam(param)) = self {
             let def = match param.parent(db) {
                 hir::GenericDef::Function(it) => it.source(db).map(|src| src.syntax().cloned()),
                 None => SearchScope::single_file(file_id),
             };
         }
-
         if let Definition::Macro(macro_def) = self {
             return match macro_def.kind(db) {
                 hir::MacroKind::Declarative => {
                 }
             };
         }
-
         if let Definition::DeriveHelper(_) = self {
             return SearchScope::reverse_dependencies(db, module.krate());
         }
-
         if let Some(vis) = self.visibility(db) {
             return match vis {
                 Visibility::Module(module, _) => {
                 Visibility::Public => SearchScope::reverse_dependencies(db, module.krate()),
             };
         }
-
         let range = match module_source {
             ModuleSource::Module(m) => Some(m.syntax().text_range()),
             ModuleSource::BlockExpr(b) => Some(b.syntax().text_range()),
         self
     }
 
-    // FIXME: This is just a temporary fix for not handling import aliases like
-    // `use Foo as Bar`. We need to support them in a proper way.
-    // See issue #14079
     pub fn with_rename(mut self, rename: Option<&'a Rename>) -> Self {
         self.rename = rename;
         self
         res
     }
 
-    fn scope_files<'b>(
-        db: &'b RootDatabase,
-        scope: &'b SearchScope,
-    ) -> impl Iterator<Item = (Arc<str>, EditionedFileId, TextRange)> + 'b {
+    fn scope_files<'b>(db: &'b RootDatabase, scope: &'b SearchScope) -> impl Iterator<Item = (Arc<str>, EditionedFileId, TextRange)> + 'b {
         scope.entries.iter().map(|(&file_id, &search_range)| {
             let text = db.file_text(file_id.file_id(db)).text(db);
             let search_range =
         })
     }
 
-    fn match_indices<'b>(
-        text: &'b str,
-        finder: &'b Finder<'b>,
-        search_range: TextRange,
-    ) -> impl Iterator<Item = TextSize> + 'b {
+    fn match_indices<'b>(text: &'b str, finder: &'b Finder<'b>, search_range: TextRange) -> impl Iterator<Item = TextSize> + 'b {
         finder.find_iter(text.as_bytes()).filter_map(move |idx| {
             let offset: TextSize = idx.try_into().unwrap();
             if !search_range.contains_inclusive(offset) {
         })
     }
 
-    fn find_nodes<'b>(
-        sema: &'b Semantics<'_, RootDatabase>,
-        name: &str,
-        file_id: EditionedFileId,
-        node: &syntax::SyntaxNode,
-        offset: TextSize,
-    ) -> impl Iterator<Item = SyntaxNode> + 'b {
+    fn find_nodes<'b>(sema: &'b Semantics<'_, RootDatabase>, name: &str, file_id: EditionedFileId, node: &syntax::SyntaxNode, offset: TextSize) -> impl Iterator<Item = SyntaxNode> + 'b {
         node.token_at_offset(offset)
             .find(|it| {
                 // `name` is stripped of raw ident prefix. See the comment on name retrieval below.
     /// that).
     ///
     /// Returns true if completed the search.
-    // FIXME: Extend this to other cases, such as associated types/consts/enum variants (note those can be `use`d).
-    fn short_associated_function_fast_search(
-        &self,
-        sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
-        search_scope: &SearchScope,
-        name: &str,
-    ) -> bool {
+    fn short_associated_function_fast_search(&self, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool, search_scope: &SearchScope, name: &str) -> bool {
         if self.scope.is_some() {
             return false;
         }
-
         let _p = tracing::info_span!("short_associated_function_fast_search").entered();
-
         let container = (|| {
             let Definition::Function(function) = self.def else {
                 return None;
         let Some(container) = container else {
             return false;
         };
-
         fn has_any_name(node: &SyntaxNode, mut predicate: impl FnMut(&str) -> bool) -> bool {
             node.descendants().any(|node| {
                 match_ast! {
                 }
             })
         }
-
         // This is a fixpoint algorithm with O(number of aliases), but most types have no or few aliases,
         // so this should stay fast.
         //
 
             Some((completed, is_possibly_self))
         }
-
         fn search(
             this: &FindUsages<'_>,
             finder: &Finder<'_>,
                 }
             }
         }
-
         let Some((container_possible_aliases, is_possibly_self)) =
             collect_possible_aliases(self.sema, container)
         else {
             return false;
         };
-
         cov_mark::hit!(short_associated_function_fast_search);
-
         // FIXME: If Rust ever gains the ability to `use Struct::method` we'll also need to account for free
         // functions.
         let finder = Finder::new(name.as_bytes());
                 sink,
             )
         });
-
         true
     }
 
     pub fn search(&self, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool) {
         let _p = tracing::info_span!("FindUsages:search").entered();
         let sema = self.sema;
-
         let search_scope = {
             // FIXME: Is the trait scope needed for trait impl assoc items?
             let base =
                 Some(scope) => base.intersection(scope),
             }
         };
-
         let name = match (self.rename, self.def) {
             (Some(rename), _) => {
                 if rename.underscore_token().is_some() {
             Some(s) => s.as_str(),
             None => return,
         };
-
         // FIXME: This should probably depend on the number of the results (specifically, the number of false results).
         if name.len() <= 7 && self.short_associated_function_fast_search(sink, &search_scope, name)
         {
             return;
         }
-
         let finder = &Finder::new(name);
         let include_self_kw_refs =
             self.include_self_kw_refs.as_ref().map(|ty| (ty, Finder::new("Self")));
                 }
             }
         }
-
         // Search for `super` and `crate` resolving to our module
         if let Definition::Module(module) = self.def {
             let scope =
                 }
             }
         }
-
         // search for module `self` references in our module's definition source
         match self.def {
             Definition::Module(module) if self.search_self_mod => {
         }
     }
 
-    fn found_self_ty_name_ref(
-        &self,
-        self_ty: &hir::Type<'_>,
-        name_ref: &ast::NameRef,
-        sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
-    ) -> bool {
+    fn found_self_ty_name_ref(&self, self_ty: &hir::Type<'_>, name_ref: &ast::NameRef, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool) -> bool {
         // See https://github.com/rust-lang/rust-analyzer/pull/15864/files/e0276dc5ddc38c65240edb408522bb869f15afb4#r1389848845
         let ty_eq = |ty: hir::Type<'_>| match (ty.as_adt(), self_ty.as_adt()) {
             (Some(ty), Some(self_ty)) => ty == self_ty,
             (None, None) => ty == *self_ty,
             _ => false,
         };
-
         match NameRefClass::classify(self.sema, name_ref) {
             Some(NameRefClass::Definition(Definition::SelfType(impl_), _))
                 if ty_eq(impl_.self_ty(self.sema.db)) =>
         }
     }
 
-    fn found_self_module_name_ref(
-        &self,
-        name_ref: &ast::NameRef,
-        sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
-    ) -> bool {
+    fn found_self_module_name_ref(&self, name_ref: &ast::NameRef, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool) -> bool {
         match NameRefClass::classify(self.sema, name_ref) {
             Some(NameRefClass::Definition(def @ Definition::Module(_), _)) if def == self.def => {
                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());
         }
     }
 
-    fn found_format_args_ref(
-        &self,
-        file_id: EditionedFileId,
-        range: TextRange,
-        token: ast::String,
-        res: Either<PathResolution, InlineAsmOperand>,
-        sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
-    ) -> bool {
+    fn found_format_args_ref(&self, file_id: EditionedFileId, range: TextRange, token: ast::String, res: Either<PathResolution, InlineAsmOperand>, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool) -> bool {
         let def = res.either(Definition::from, Definition::from);
         if def == self.def {
             let reference = FileReference {
         }
     }
 
-    fn found_lifetime(
-        &self,
-        lifetime: &ast::Lifetime,
-        sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
-    ) -> bool {
+    fn found_lifetime(&self, lifetime: &ast::Lifetime, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool) -> bool {
         match NameRefClass::classify_lifetime(self.sema, lifetime) {
             Some(NameRefClass::Definition(def, _)) if def == self.def => {
                 let FileRange { file_id, range } = self.sema.original_range(lifetime.syntax());
         }
     }
 
-    fn found_name_ref(
-        &self,
-        name_ref: &ast::NameRef,
-        sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
-    ) -> bool {
+    fn found_name_ref(&self, name_ref: &ast::NameRef, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool) -> bool {
         match NameRefClass::classify(self.sema, name_ref) {
             Some(NameRefClass::Definition(def, _))
                 if self.def == def
         }
     }
 
-    fn found_name(
-        &self,
-        name: &ast::Name,
-        sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool,
-    ) -> bool {
+    fn found_name(&self, name: &ast::Name, sink: &mut dyn FnMut(EditionedFileId, FileReference) -> bool) -> bool {
         match NameClass::classify(self.sema, name) {
             Some(NameClass::PatFieldShorthand { local_def: _, field_ref, adt_subst: _ })
                 if matches!(
 }
 
 impl ReferenceCategory {
-    fn new(
-        sema: &Semantics<'_, RootDatabase>,
-        def: &Definition,
-        r: &ast::NameRef,
-    ) -> ReferenceCategory {
+    fn new(sema: &Semantics<'_, RootDatabase>, def: &Definition, r: &ast::NameRef) -> ReferenceCategory {
         let mut result = ReferenceCategory::empty();
         if is_name_ref_in_test(sema, r) {
             result |= ReferenceCategory::TEST;
         }
-
         // Only Locals and Fields have accesses for now.
         if !matches!(def, Definition::Local(_) | Definition::Field(_)) {
             if is_name_ref_in_import(r) {
             }
             return result;
         }
-
         let mode = r.syntax().ancestors().find_map(|node| {
             match_ast! {
                 match node {
                 }
             }
         }).unwrap_or(ReferenceCategory::READ);
-
         result | mode
     }
 }