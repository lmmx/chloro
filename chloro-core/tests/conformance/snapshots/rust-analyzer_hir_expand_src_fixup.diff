COMPARISON DIFF
============================================================

Original size: 28147 bytes
Chloro size:   27522 bytes
Rustfmt size:  28368 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! To make attribute macros work reliably when typing, we need to take care to
 //! fix up syntax errors in the code we're passing to them.
 
 use intern::sym;
 use rustc_hash::{FxHashMap, FxHashSet};
 use span::{
-    ErasedFileAstId, Span, SpanAnchor, SyntaxContext, FIXUP_ERASED_FILE_AST_ID_MARKER,
-    ROOT_ERASED_FILE_AST_ID,
+    ErasedFileAstId, FIXUP_ERASED_FILE_AST_ID_MARKER, ROOT_ERASED_FILE_AST_ID, Span, SpanAnchor,
+    SyntaxContext,
 };
 use stdx::never;
 use syntax::{
+    SyntaxElement, SyntaxKind, SyntaxNode, TextRange, TextSize,
     ast::{self, AstNode, HasLoopBody},
-    match_ast, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, TextSize,
+    match_ast,
 };
 use syntax_bridge::DocCommentDesugarMode;
 use triomphe::Arc;
     span_map::SpanMapRef,
     tt::{self, Ident, Leaf, Punct, TopSubtree},
 };
-
 /// The result of calculating fixes for a syntax node -- a bunch of changes
 /// (appending to and replacing nodes), the information that is needed to
 /// reverse those changes afterwards, and a token map.
 /// This is the information needed to reverse the fixups.
 #[derive(Clone, Debug, Default, PartialEq, Eq)]
 pub struct SyntaxFixupUndoInfo {
-    // FIXME: ThinArc<[Subtree]>
     original: Option<Arc<Box<[TopSubtree]>>>,
 }
 
 impl SyntaxFixupUndoInfo {
-    pub(crate) const NONE: Self = SyntaxFixupUndoInfo { original: None };
 }
 
 // We mark spans with `FIXUP_DUMMY_AST_ID` to indicate that they are fake.
-const FIXUP_DUMMY_AST_ID: ErasedFileAstId = FIXUP_ERASED_FILE_AST_ID_MARKER;
-const FIXUP_DUMMY_RANGE: TextRange = TextRange::empty(TextSize::new(0));
+
+
 // If the fake span has this range end, that means that the range start is an index into the
 // `original` list in `SyntaxFixupUndoInfo`.
-const FIXUP_DUMMY_RANGE_END: TextSize = TextSize::new(!0);
 
-pub(crate) fn fixup_syntax(
-    span_map: SpanMapRef<'_>,
-    node: &SyntaxNode,
-    call_site: Span,
-    mode: DocCommentDesugarMode,
-) -> SyntaxFixups {
+pub(crate) fn fixup_syntax(span_map: SpanMapRef<'_>, node: &SyntaxNode, call_site: Span, mode: DocCommentDesugarMode) -> SyntaxFixups {
     let mut append = FxHashMap::<SyntaxElement, _>::default();
     let mut remove = FxHashSet::<SyntaxElement>::default();
     let mut preorder = node.preorder();
         let span = span_map.span_for_range(range);
         Span {
             range: dummy_range,
-            anchor: SpanAnchor {
-                ast_id: FIXUP_DUMMY_AST_ID,
-                ..span.anchor
-            },
+            anchor: SpanAnchor { ast_id: FIXUP_DUMMY_AST_ID, ..span.anchor },
             ctx: span.ctx,
         }
     };
     while let Some(event) = preorder.next() {
-        let syntax::WalkEvent::Enter(node) = event else {
-            continue;
-        };
+        let syntax::WalkEvent::Enter(node) = event else { continue };
 
         let node_range = node.text_range();
         if can_handle_error(&node) && has_error_to_handle(&node) {
                 sym: sym::__ra_fixup,
                 span: Span {
                     range: TextRange::new(TextSize::new(idx), FIXUP_DUMMY_RANGE_END),
-                    anchor: SpanAnchor {
-                        ast_id: FIXUP_DUMMY_AST_ID,
-                        ..span.anchor
-                    },
+                    anchor: SpanAnchor { ast_id: FIXUP_DUMMY_AST_ID, ..span.anchor },
                     ctx: span.ctx,
                 },
                 is_raw: tt::IdentIsRaw::No,
 }
 
 fn has_error_to_handle(node: &SyntaxNode) -> bool {
-    has_error(node)
-        || node
-            .children()
-            .any(|c| !can_handle_error(&c) && has_error_to_handle(&c))
+    has_error(node) || node.children().any(|c| !can_handle_error(&c) && has_error_to_handle(&c))
 }
 
 pub(crate) fn reverse_fixups(tt: &mut TopSubtree, undo_info: &SyntaxFixupUndoInfo) {
-    let Some(undo_info) = undo_info.original.as_deref() else {
-        return;
-    };
+    let Some(undo_info) = undo_info.original.as_deref() else { return };
     let undo_info = &**undo_info;
     let delimiter = tt.top_subtree_delimiter_mut();
     #[allow(deprecated)]
     ) {
         let span = |file_id| Span {
             range: TextRange::empty(TextSize::new(0)),
-            anchor: SpanAnchor {
-                file_id,
-                ast_id: ROOT_ERASED_FILE_AST_ID,
-            },
+            anchor: SpanAnchor { file_id, ast_id: ROOT_ERASED_FILE_AST_ID },
             ctx: SyntaxContext::root(span::Edition::Edition2015),
         };
         delimiter.open = span(delimiter.open.anchor.file_id);
 /// This function takes a token tree, and calls `callback` with each token tree in it.
 /// Then it does what the callback says: keeps the tt or replaces it with a (possibly empty)
 /// tts view.
-fn transform_tt<'a, 'b>(
-    tt: &'a mut Vec<tt::TokenTree>,
-    mut callback: impl FnMut(&mut tt::TokenTree) -> TransformTtAction<'b>,
-) {
+fn transform_tt<'a, 'b>(tt: &'a mut Vec<tt::TokenTree>, mut callback: impl FnMut(&mut tt::TokenTree) -> TransformTtAction<'b>) {
     // We need to keep a stack of the currently open subtrees, because we need to update
     // them if we change the number of items in them.
     let mut subtrees_stack = Vec::new();
 
 #[cfg(test)]
 mod tests {
-    use expect_test::{expect, Expect};
+    use expect_test::{Expect, expect};
     use span::{Edition, EditionedFileId, FileId};
     use syntax::TextRange;
     use syntax_bridge::DocCommentDesugarMode;
     use triomphe::Arc;
-
     use crate::{
         fixup::reverse_fixups,
         span_map::{RealSpanMap, SpanMap},
         tt,
     };
-
-    // The following three functions are only meant to check partial structural equivalence of
-    // `TokenTree`s, see the last assertion in `check()`.
     fn check_leaf_eq(a: &tt::Leaf, b: &tt::Leaf) -> bool {
         match (a, b) {
             (tt::Leaf::Literal(a), tt::Leaf::Literal(b)) => a.symbol == b.symbol,
             _ => false,
         }
     }
-
     fn check_subtree_eq(a: &tt::TopSubtree, b: &tt::TopSubtree) -> bool {
         let a = a.view().as_token_trees().flat_tokens();
         let b = b.view().as_token_trees().flat_tokens();
         a.len() == b.len() && std::iter::zip(a, b).all(|(a, b)| check_tt_eq(a, b))
     }
-
     fn check_tt_eq(a: &tt::TokenTree, b: &tt::TokenTree) -> bool {
         match (a, b) {
             (tt::TokenTree::Leaf(a), tt::TokenTree::Leaf(b)) => check_leaf_eq(a, b),
             _ => false,
         }
     }
-
     #[track_caller]
     fn check(#[rust_analyzer::rust_fixture] ra_fixture: &str, mut expect: Expect) {
         let parsed = syntax::SourceFile::parse(ra_fixture, span::Edition::CURRENT);
             span_map.span_for_range(TextRange::empty(0.into())),
             DocCommentDesugarMode::Mbe,
         );
-
         let actual = format!("{tt}\n");
-
         expect.indent(false);
         expect.assert_eq(&actual);
-
         // the fixed-up tree should be syntactically valid
         let (parse, _) = syntax_bridge::token_tree_to_syntax_node(
             &tt,
             "parse has syntax errors. parse tree:\n{:#?}",
             parse.syntax_node()
         );
-
         // the fixed-up tree should not contain braces as punct
         // FIXME: should probably instead check that it's a valid punctuation character
         for x in tt.token_trees().flat_tokens() {
                 _ => (),
             }
         }
-
         reverse_fixups(&mut tt, &fixups.undo_info);
-
         // the fixed-up + reversed version should be equivalent to the original input
         // modulo token IDs and `Punct`s' spacing.
         let original_as_tt = syntax_bridge::syntax_node_to_token_tree(
             "different token tree:\n{tt:?}\n\n{original_as_tt:?}"
         );
     }
-
     #[test]
     fn just_for_token() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn for_no_iter_pattern() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn for_no_body() {
         check(
 "#]],
         )
     }
-
-    // FIXME: https://github.com/rust-lang/rust-analyzer/pull/12937#discussion_r937633695
     #[test]
     fn for_no_pat() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn match_no_expr_no_arms() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn match_expr_no_arms() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn match_no_expr() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn incomplete_field_expr_1() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn incomplete_field_expr_2() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn incomplete_field_expr_3() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn incomplete_let() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn incomplete_field_expr_in_let() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn field_expr_before_call() {
         // another case that easily happens while typing
 "#]],
         )
     }
-
     #[test]
     fn extraneous_comma() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_if_1() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_if_2() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_if_3() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_while_1() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_while_2() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_loop() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_path() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_record_ctor_field() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn no_fixup_record_ctor_field() {
         check(
 "#]],
         )
     }
-
     #[test]
     fn fixup_arg_list() {
         check(
 "#]],
         );
     }
-
     #[test]
     fn fixup_closure() {
         check(
 "#]],
         );
     }
-
     #[test]
     fn fixup_regression_() {
         check(