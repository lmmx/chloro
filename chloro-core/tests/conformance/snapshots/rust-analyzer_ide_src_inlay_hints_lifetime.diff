COMPARISON DIFF
============================================================

Original size: 17157 bytes
Chloro size:   17024 bytes
Rustfmt size:  17157 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Implementation of "lifetime elision" inlay hints:
 //! ```no_run
 //! fn example/* <'0> */(a: &/* '0 */()) {}
 //! ```
+
 use std::iter;
 
 use ide_db::{FxHashMap, famous_defs::FamousDefs, syntax_helpers::node_ext::walk_ty};
 use itertools::Itertools;
-use syntax::{SmolStr, format_smolstr};
 use syntax::{
     SyntaxKind, SyntaxToken,
     ast::{self, AstNode, HasGenericParams, HasName},
 };
+use syntax::{SmolStr, format_smolstr};
 
 use crate::{
     InlayHint, InlayHintPosition, InlayHintsConfig, InlayKind, LifetimeElisionHints,
     inlay_hints::InlayHintCtx,
 };
-
-pub(super) fn fn_hints(
-    acc: &mut Vec<InlayHint>,
-    ctx: &mut InlayHintCtx,
-    fd: &FamousDefs<'_, '_>,
-    config: &InlayHintsConfig<'_>,
-    func: ast::Fn,
-) -> Option<()> {
+pub(super) fn fn_hints(acc: &mut Vec<InlayHint>, ctx: &mut InlayHintCtx, fd: &FamousDefs<'_, '_>, config: &InlayHintsConfig<'_>, func: ast::Fn) -> Option<()> {
     if config.lifetime_elision_hints == LifetimeElisionHints::Never {
         return None;
     }
-
     let param_list = func.param_list()?;
     let generic_param_list = func.generic_param_list();
     let ret_type = func.ret_type();
     )
 }
 
-pub(super) fn fn_ptr_hints(
-    acc: &mut Vec<InlayHint>,
-    ctx: &mut InlayHintCtx,
-    fd: &FamousDefs<'_, '_>,
-    config: &InlayHintsConfig<'_>,
-    func: ast::FnPtrType,
-) -> Option<()> {
+pub(super) fn fn_ptr_hints(acc: &mut Vec<InlayHint>, ctx: &mut InlayHintCtx, fd: &FamousDefs<'_, '_>, config: &InlayHintsConfig<'_>, func: ast::FnPtrType) -> Option<()> {
     if config.lifetime_elision_hints == LifetimeElisionHints::Never {
         return None;
     }
-
     let parent_for_binder = func
         .syntax()
         .ancestors()
         .take_while(|it| matches!(it.kind(), SyntaxKind::PAREN_TYPE | SyntaxKind::FOR_TYPE))
         .find_map(ast::ForType::cast)
         .and_then(|it| it.for_binder());
-
     let param_list = func.param_list()?;
     let generic_param_list = parent_for_binder.as_ref().and_then(|it| it.generic_param_list());
     let ret_type = func.ret_type();
     )
 }
 
-pub(super) fn fn_path_hints(
-    acc: &mut Vec<InlayHint>,
-    ctx: &mut InlayHintCtx,
-    fd: &FamousDefs<'_, '_>,
-    config: &InlayHintsConfig<'_>,
-    func: &ast::PathType,
-) -> Option<()> {
+pub(super) fn fn_path_hints(acc: &mut Vec<InlayHint>, ctx: &mut InlayHintCtx, fd: &FamousDefs<'_, '_>, config: &InlayHintsConfig<'_>, func: &ast::PathType) -> Option<()> {
     if config.lifetime_elision_hints == LifetimeElisionHints::Never {
         return None;
     }
-
     // FIXME: Support general path types
     let (param_list, ret_type) = func.path().as_ref().and_then(path_as_fn)?;
     let parent_for_binder = func
         .take_while(|it| matches!(it.kind(), SyntaxKind::PAREN_TYPE | SyntaxKind::FOR_TYPE))
         .find_map(ast::ForType::cast)
         .and_then(|it| it.for_binder());
-
     let generic_param_list = parent_for_binder.as_ref().and_then(|it| it.generic_param_list());
     let for_kw = parent_for_binder.as_ref().and_then(|it| it.for_token());
     hints_(
     path.segment().and_then(|it| it.parenthesized_arg_list().zip(Some(it.ret_type())))
 }
 
-fn hints_(
-    acc: &mut Vec<InlayHint>,
-    ctx: &mut InlayHintCtx,
-    FamousDefs(_, _): &FamousDefs<'_, '_>,
-    config: &InlayHintsConfig<'_>,
-    params: impl Iterator<Item = (Option<ast::Name>, ast::Type)>,
-    generic_param_list: Option<ast::GenericParamList>,
-    ret_type: Option<ast::RetType>,
-    self_param: Option<ast::SelfParam>,
-    on_missing_gpl: impl FnOnce(&mut Vec<InlayHint>, &[SmolStr]),
-    mut is_trivial: bool,
-) -> Option<()> {
+fn hints_(acc: &mut Vec<InlayHint>, ctx: &mut InlayHintCtx, FamousDefs(_, _): &FamousDefs<'_, '_>, config: &InlayHintsConfig<'_>, params: impl Iterator<Item = (Option<ast::Name>, ast::Type)>, generic_param_list: Option<ast::GenericParamList>, ret_type: Option<ast::RetType>, self_param: Option<ast::SelfParam>, on_missing_gpl: impl FnOnce(&mut Vec<InlayHint>, &[SmolStr]), mut is_trivial: bool) -> Option<()> {
     let is_elided = |lt: &Option<ast::Lifetime>| match lt {
         Some(lt) => matches!(lt.text().as_str(), "'_"),
         None => true,
     };
-
     let mk_lt_hint = |t: SyntaxToken, label: String| InlayHint {
         range: t.text_range(),
         kind: InlayKind::Lifetime,
         pad_right: true,
         resolve_parent: None,
     };
-
     let potential_lt_refs = {
         let mut acc: Vec<_> = vec![];
         if let Some(self_param) = &self_param {
         });
         acc
     };
-
     let mut used_names: FxHashMap<SmolStr, usize> =
         ctx.lifetime_stacks.iter().flat_map(|it| it.iter()).cloned().zip(iter::repeat(0)).collect();
     // allocate names
         }
     };
     let mut allocated_lifetimes = vec![];
-
     {
         let mut potential_lt_refs = potential_lt_refs.iter().filter(|&&(.., is_elided)| is_elided);
         if self_param.is_some() && potential_lt_refs.next().is_some() {
             allocated_lifetimes.push(name);
         });
     }
-
     // fetch output lifetime if elision rule applies
     let output = match potential_lt_refs.as_slice() {
         [(_, _, lifetime, _), ..] if self_param.is_some() || potential_lt_refs.len() == 1 => {
         }
         [..] => None,
     };
-
     if allocated_lifetimes.is_empty() && output.is_none() {
         return None;
     }
-
     // apply hints
     // apply output if required
     if let (Some(output_lt), Some(r)) = (&output, ret_type)
             _ => false,
         })
     }
-
     if config.lifetime_elision_hints == LifetimeElisionHints::SkipTrivial && is_trivial {
         return None;
     }
-
     let mut a = allocated_lifetimes.iter();
     for (_, amp_token, _, is_elided) in potential_lt_refs {
         if is_elided {
             acc.push(mk_lt_hint(t, lt.to_string()));
         }
     }
-
     // generate generic param list things
     match (generic_param_list, allocated_lifetimes.as_slice()) {
         (_, []) => (),
         InlayHintsConfig, LifetimeElisionHints,
         inlay_hints::tests::{TEST_CONFIG, check, check_with_config},
     };
-
     #[test]
     fn hints_lifetimes() {
         check(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_named() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_trivial_skip() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn no_collide() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_lifetimes_fn_ptr() {
         check_with_config(
 "#,
         );
     }
-
     #[test]
     fn hints_in_non_gen_defs() {
         check_with_config(