COMPARISON DIFF
============================================================

Original size: 16250 bytes
Chloro size:   12450 bytes
Rustfmt size:  16896 bytes

✗ Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use std::sync::LazyLock;
 
 use ide_db::{
+    FxHashMap, SymbolKind,
     generated::lints::{
-        Lint, CLIPPY_LINTS, CLIPPY_LINT_GROUPS, DEFAULT_LINTS, FEATURES, RUSTDOC_LINTS,
+        CLIPPY_LINT_GROUPS, CLIPPY_LINTS, DEFAULT_LINTS, FEATURES, Lint, RUSTDOC_LINTS,
     },
     syntax_helpers::node_ext::parse_tt_as_comma_sep_paths,
-    FxHashMap, SymbolKind,
 };
 use itertools::Itertools;
 use syntax::{
-    ast::{self, AttrKind},
     AstNode, Edition, SyntaxKind, T,
+    ast::{self, AttrKind},
 };
 
 use crate::{
+    Completions,
     context::{AttrCtx, CompletionContext, PathCompletionCtx, Qualified},
     item::CompletionItem,
-    Completions,
 };
+pub(crate) use self::derive::complete_derive_path;
 
 mod cfg;
-mod derive;
-mod diagnostic;
-mod lint;
-mod macro_use;
-mod repr;
 
-pub(crate) use self::derive::complete_derive_path;
+mod derive;
+
+mod diagnostic;
+
+mod lint;
+
+mod macro_use;
+
+mod repr;
 
 /// Complete inputs to known builtin attributes as well as derive attributes
 pub(crate) fn complete_known_attribute_input(
 ) -> Option<()> {
     let attribute = fake_attribute_under_caret;
     let path = attribute.path()?;
-    let segments = path
-        .segments()
-        .map(|s| s.name_ref())
-        .collect::<Option<Vec<_>>>()?;
+    let segments = path.segments().map(|s| s.name_ref()).collect::<Option<Vec<_>>>()?;
     let segments = segments.iter().map(|n| n.text()).collect::<Vec<_>>();
     let segments = segments.iter().map(|t| t.as_str()).collect::<Vec<_>>();
     let tt = attribute.token_tree()?;
-
     match segments.as_slice() {
         ["repr"] => repr::complete_repr(acc, ctx, tt),
         ["feature"] => lint::complete_lint(
     acc: &mut Completions,
     ctx: &CompletionContext<'_>,
     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx<'_>,
-    &AttrCtx {
-        kind,
-        annotated_item_kind,
-        ref derive_helpers,
-    }: &AttrCtx,
+    &AttrCtx { kind, annotated_item_kind, ref derive_helpers }: &AttrCtx,
 ) {
     let is_inner = kind == AttrKind::Inner;
-
     for (derive_helper, derive_name) in derive_helpers {
         let mut item = CompletionItem::new(
             SymbolKind::Attribute,
         item.detail(format!("derive helper of `{derive_name}`"));
         item.add_to(acc, ctx.db);
     }
-
     match qualified {
         Qualified::With {
             resolution: Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))),
         }
         Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}
     }
-    let qualifier_path = if let Qualified::With { path, .. } = qualified {
-        Some(path)
-    } else {
-        None
-    };
-
+    let qualifier_path =
+        if let Qualified::With { path, .. } = qualified { Some(path) } else { None };
     let attributes = annotated_item_kind.and_then(|kind| {
         if ast::Expr::can_cast(kind) {
             Some(EXPR_ATTRIBUTES)
             KIND_TO_ATTRIBUTES.get(&kind).copied()
         }
     });
-
     let add_completion = |attr_completion: &AttrCompletion| {
         // if we don't already have the qualifiers of the completion, then
         // add the missing parts to the label and snippet
         let mut label = attr_completion.label.to_owned();
         let mut snippet = attr_completion.snippet.map(|s| s.to_owned());
-        let segments = qualifier_path
-            .iter()
-            .flat_map(|q| q.segments())
-            .collect::<Vec<_>>();
+        let segments = qualifier_path.iter().flat_map(|q| q.segments()).collect::<Vec<_>>();
         let qualifiers = attr_completion.qualifiers;
         let matching_qualifiers = segments
             .iter()
             }
         }
 
-        let mut item = CompletionItem::new(
-            SymbolKind::Attribute,
-            ctx.source_range(),
-            label,
-            ctx.edition,
-        );
+        let mut item =
+            CompletionItem::new(SymbolKind::Attribute, ctx.source_range(), label, ctx.edition);
 
         if let Some(lookup) = attr_completion.lookup {
             item.lookup_by(lookup);
             item.add_to(acc, ctx.db);
         }
     };
-
     match attributes {
         Some(applicable) => applicable
             .iter()
-            .flat_map(|name| {
-                ATTRIBUTES
-                    .binary_search_by(|attr| attr.key().cmp(name))
-                    .ok()
-            })
+            .flat_map(|name| ATTRIBUTES.binary_search_by(|attr| attr.key().cmp(name)).ok())
             .flat_map(|idx| ATTRIBUTES.get(idx))
             .for_each(add_completion),
         None if is_inner => ATTRIBUTES.iter().for_each(add_completion),
-        None => ATTRIBUTES
-            .iter()
-            .filter(|compl| !compl.prefer_inner)
-            .for_each(add_completion),
+        None => ATTRIBUTES.iter().filter(|compl| !compl.prefer_inner).for_each(add_completion),
     }
 }
 
         self.lookup.unwrap_or(self.label)
     }
 
-    const fn qualifiers(self, qualifiers: &'static [&'static str]) -> AttrCompletion {
+    const fn qualifiers(
+        self,
+        qualifiers: &'static [&'static str],
+    ) -> AttrCompletion {
         AttrCompletion { qualifiers, ..self }
     }
 
     const fn prefer_inner(self) -> AttrCompletion {
-        AttrCompletion {
-            prefer_inner: true,
-            ..self
-        }
+        AttrCompletion { prefer_inner: true, ..self }
     }
 }
 
     lookup: Option<&'static str>,
     snippet: Option<&'static str>,
 ) -> AttrCompletion {
-    AttrCompletion {
-        label,
-        lookup,
-        snippet,
-        qualifiers: &[],
-        prefer_inner: false,
-    }
+    AttrCompletion { label, lookup, snippet, qualifiers: &[], prefer_inner: false }
 }
 
 macro_rules! attrs {
 }
 
 #[rustfmt::skip]
-static KIND_TO_ATTRIBUTES: LazyLock<FxHashMap<SyntaxKind, &[&str]>> = LazyLock::new(|| {
+{
     use SyntaxKind::*;
     [
         (
         (RECORD_PAT_FIELD, attrs!()),
     ]
     .into_iter()
-    .collect()
-});
-const EXPR_ATTRIBUTES: &[&str] = attrs!();
+    .collect();
+}
 
 /// <https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index>
 // Keep these sorted for the binary search!
-const ATTRIBUTES: &[AttrCompletion] = &[
-    attr("allow(…)", Some("allow"), Some("allow(${0:lint})")),
-    attr("automatically_derived", None, None),
-    attr("cfg(…)", Some("cfg"), Some("cfg(${0:predicate})")),
-    attr(
-        "cfg_attr(…)",
-        Some("cfg_attr"),
-        Some("cfg_attr(${1:predicate}, ${0:attr})"),
-    ),
-    attr("cold", None, None),
-    attr(
-        r#"crate_name = """#,
-        Some("crate_name"),
-        Some(r#"crate_name = "${0:crate_name}""#),
-    )
-    .prefer_inner(),
-    attr("deny(…)", Some("deny"), Some("deny(${0:lint})")),
-    attr(r#"deprecated"#, Some("deprecated"), Some(r#"deprecated"#)),
-    attr("derive(…)", Some("derive"), Some(r#"derive(${0:Debug})"#)),
-    attr(
-        "do_not_recommend",
-        Some("diagnostic::do_not_recommend"),
-        None,
-    )
-    .qualifiers(&["diagnostic"]),
-    attr(
-        "on_unimplemented",
-        Some("diagnostic::on_unimplemented"),
-        Some(r#"on_unimplemented(${0:keys})"#),
-    )
-    .qualifiers(&["diagnostic"]),
-    attr(r#"doc = "…""#, Some("doc"), Some(r#"doc = "${0:docs}""#)),
-    attr(
-        r#"doc(alias = "…")"#,
-        Some("docalias"),
-        Some(r#"doc(alias = "${0:docs}")"#),
-    ),
-    attr(r#"doc(hidden)"#, Some("dochidden"), Some(r#"doc(hidden)"#)),
-    attr(
-        r#"doc = include_str!("…")"#,
-        Some("docinclude"),
-        Some(r#"doc = include_str!("$0")"#),
-    ),
-    attr("expect(…)", Some("expect"), Some("expect(${0:lint})")),
-    attr(
-        r#"export_name = "…""#,
-        Some("export_name"),
-        Some(r#"export_name = "${0:exported_symbol_name}""#),
-    ),
-    attr("feature(…)", Some("feature"), Some("feature(${0:flag})")).prefer_inner(),
-    attr("forbid(…)", Some("forbid"), Some("forbid(${0:lint})")),
-    attr("global_allocator", None, None),
-    attr(
-        r#"ignore = "…""#,
-        Some("ignore"),
-        Some(r#"ignore = "${0:reason}""#),
-    ),
-    attr("inline", Some("inline"), Some("inline")),
-    attr("link", None, None),
-    attr(
-        r#"link_name = "…""#,
-        Some("link_name"),
-        Some(r#"link_name = "${0:symbol_name}""#),
-    ),
-    attr(
-        r#"link_section = "…""#,
-        Some("link_section"),
-        Some(r#"link_section = "${0:section_name}""#),
-    ),
-    attr("macro_export", None, None),
-    attr("macro_use", None, None),
-    attr(r#"must_use"#, Some("must_use"), Some(r#"must_use"#)),
-    attr("no_implicit_prelude", None, None).prefer_inner(),
-    attr("no_link", None, None).prefer_inner(),
-    attr("no_main", None, None).prefer_inner(),
-    attr("no_mangle", None, None),
-    attr("no_std", None, None).prefer_inner(),
-    attr("non_exhaustive", None, None),
-    attr("panic_handler", None, None),
-    attr(r#"path = "…""#, Some("path"), Some(r#"path ="${0:path}""#)),
-    attr("proc_macro", None, None),
-    attr("proc_macro_attribute", None, None),
-    attr(
-        "proc_macro_derive(…)",
-        Some("proc_macro_derive"),
-        Some("proc_macro_derive(${0:Trait})"),
-    ),
-    attr(
-        r#"recursion_limit = "…""#,
-        Some("recursion_limit"),
-        Some(r#"recursion_limit = "${0:128}""#),
-    )
-    .prefer_inner(),
-    attr("repr(…)", Some("repr"), Some("repr(${0:C})")),
-    attr(
-        "should_panic",
-        Some("should_panic"),
-        Some(r#"should_panic"#),
-    ),
-    attr(
-        r#"target_feature(enable = "…")"#,
-        Some("target_feature"),
-        Some(r#"target_feature(enable = "${0:feature}")"#),
-    ),
-    attr("test", None, None),
-    attr("track_caller", None, None),
-    attr(
-        "type_length_limit = …",
-        Some("type_length_limit"),
-        Some("type_length_limit = ${0:128}"),
-    )
-    .prefer_inner(),
-    attr("used", None, None),
-    attr("warn(…)", Some("warn"), Some("warn(${0:lint})")),
-    attr(
-        r#"windows_subsystem = "…""#,
-        Some("windows_subsystem"),
-        Some(r#"windows_subsystem = "${0:subsystem}""#),
-    )
-    .prefer_inner(),
-];
 
 fn parse_comma_sep_expr(input: ast::TokenTree) -> Option<Vec<ast::Expr>> {
     let r_paren = input.r_paren_token()?;
 fn attributes_are_sorted() {
     let mut attrs = ATTRIBUTES.iter().map(|attr| attr.key());
     let mut prev = attrs.next().unwrap();
-
     attrs.for_each(|next| {
         assert!(
             prev < next,