COMPARISON DIFF
============================================================

Original size: 18749 bytes
Chloro size:   18646 bytes
Rustfmt size:  18749 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Various helper functions to work with SyntaxNodes.
+
 use std::ops::ControlFlow;
 
 use itertools::Itertools;
     AstNode, AstToken, Preorder, RustLanguage, WalkEvent,
     ast::{self, HasLoopBody, MacroCall, PathSegmentKind, VisibilityKind},
 };
-
 pub fn expr_as_name_ref(expr: &ast::Expr) -> Option<ast::NameRef> {
     if let ast::Expr::PathExpr(expr) = expr {
         let path = expr.path()?;
 
 pub fn full_path_of_name_ref(name_ref: &ast::NameRef) -> Option<ast::Path> {
     let mut ancestors = name_ref.syntax().ancestors();
-    let _ = ancestors.next()?; // skip self
-    let _ = ancestors.next().filter(|it| ast::PathSegment::can_cast(it.kind()))?; // skip self
+    let _ = ancestors.next()?;
+    // skip self
+    let _ = ancestors.next().filter(|it| ast::PathSegment::can_cast(it.kind()))?;
+    // skip self
     ancestors.take_while(|it| ast::Path::can_cast(it.kind())).last().and_then(ast::Path::cast)
 }
 
     preorder_expr_with_ctx_checker(start, &is_closure_or_blk_with_modif, cb);
 }
 
-pub fn preorder_expr_with_ctx_checker(
-    start: &ast::Expr,
-    check_ctx: &dyn Fn(&ast::Expr) -> bool,
-    cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool,
-) {
+pub fn preorder_expr_with_ctx_checker(start: &ast::Expr, check_ctx: &dyn Fn(&ast::Expr) -> bool, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {
     let mut preorder = start.syntax().preorder();
     while let Some(event) = preorder.next() {
         let node = match event {
 }
 
 /// Preorder walk all the pattern's sub patterns.
-pub fn walk_pat<T>(
-    pat: &ast::Pat,
-    cb: &mut dyn FnMut(ast::Pat) -> ControlFlow<T>,
-) -> ControlFlow<T> {
+pub fn walk_pat<T>(pat: &ast::Pat, cb: &mut dyn FnMut(ast::Pat) -> ControlFlow<T>) -> ControlFlow<T> {
     let mut preorder = pat.syntax().preorder();
     while let Some(event) = preorder.next() {
         let node = match event {
 }
 
 /// Preorder walk all the type's sub types.
-// FIXME: Make the control flow more proper
 pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type) -> bool) {
     let mut preorder = ty.syntax().preorder();
     while let Some(event) = preorder.next() {
     }
 }
 
-pub fn for_each_break_and_continue_expr(
-    label: Option<ast::Label>,
-    body: Option<ast::StmtList>,
-    cb: &mut dyn FnMut(ast::Expr),
-) {
+pub fn for_each_break_and_continue_expr(label: Option<ast::Label>, body: Option<ast::StmtList>, cb: &mut dyn FnMut(ast::Expr)) {
     let label = label.and_then(|lbl| lbl.lifetime());
     if let Some(b) = body {
         let tree_depth_iterator = TreeWithDepthIterator::new(b);
     }
 }
 
-fn for_each_break_expr(
-    label: Option<ast::Label>,
-    body: Option<ast::StmtList>,
-    cb: &mut dyn FnMut(ast::BreakExpr),
-) {
+fn for_each_break_expr(label: Option<ast::Label>, body: Option<ast::StmtList>, cb: &mut dyn FnMut(ast::BreakExpr)) {
     let label = label.and_then(|lbl| lbl.lifetime());
     if let Some(b) = body {
         let tree_depth_iterator = TreeWithDepthIterator::new(b);
 }
 
 /// Parses the input token tree as comma separated plain paths.
-pub fn parse_tt_as_comma_sep_paths(
-    input: ast::TokenTree,
-    edition: Edition,
-) -> Option<Vec<ast::Path>> {
+pub fn parse_tt_as_comma_sep_paths(input: ast::TokenTree, edition: Edition) -> Option<Vec<ast::Path>> {
     let r_paren = input.r_paren_token();
     let tokens =
         input.syntax().children_with_tokens().skip(1).map_while(|it| match it.into_token() {