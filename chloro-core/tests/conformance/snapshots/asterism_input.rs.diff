COMPARISON DIFF
============================================================

Original size: 7367 bytes
Chloro size:   6856 bytes
Rustfmt size:  7367 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
@@ -2,24 +2,21 @@
 //! Document discovery and section extraction using tree-sitter.
 //!
 //! This module handles finding markdown files in the filesystem and parsing
 //! them with tree-sitter queries to extract section hierarchies.
-
 use crate::formats::Format;
+
 use crate::section::Section;
+
 use std::fs;
+
 use std::io;
+
 use std::path::{Path, PathBuf};
+
 use streaming_iterator::StreamingIterator;
+
 use tree_sitter::{Parser, Query, QueryCursor};
 
-/// Find documents matching the given extensions.
-///
-/// If paths is empty, scans the current directory recursively.
-/// Skips common build/dependency directories.
-///
-/// # Errors
-///
-/// Returns an error if directory traversal fails.
 pub fn find_documents(paths: Vec<PathBuf>, extensions: &[String]) -> io::Result<Vec<PathBuf>> {
     if paths.is_empty() {
         find_in_directory(Path::new("."), extensions)
@@ -44,7 +41,6 @@
 
 fn find_in_directory(dir: &Path, extensions: &[String]) -> io::Result<Vec<PathBuf>> {
     let mut results = Vec::new();
-
     if let Ok(entries) = fs::read_dir(dir) {
         for entry in entries.flatten() {
             let path = entry.path();
@@ -69,49 +65,32 @@
             }
         }
     }
-
     Ok(results)
 }
 
-/// Extract sections from a document using tree-sitter.
-///
-/// Parses the file with the given format and extracts all sections,
-/// building parent/child relationships based on heading levels.
-///
-/// # Errors
-///
-/// Returns an error if file reading or parsing fails.
 pub fn extract_sections<F: Format>(file_path: &Path, format: &F) -> io::Result<Vec<Section>> {
     let content = fs::read_to_string(file_path)?;
-
     let mut parser = Parser::new();
     parser
         .set_language(&format.language())
         .map_err(|e| io::Error::other(format!("Language error: {e}")))?;
-
     let tree = parser
         .parse(&content, None)
         .ok_or_else(|| io::Error::other("Parse failed"))?;
-
     let section_query = Query::new(&format.language(), format.section_query())
         .map_err(|e| io::Error::other(format!("Query error: {e}")))?;
-
     let title_query = Query::new(&format.language(), format.title_query())
         .map_err(|e| io::Error::other(format!("Query error: {e}")))?;
-
     // Collect all heading nodes by traversing the entire tree
     let mut headings: Vec<tree_sitter::Node> = Vec::new();
     let mut cursor = QueryCursor::new();
     let mut matches = cursor.matches(&section_query, tree.root_node(), content.as_bytes());
-
     while let Some(m) = matches.next() {
         if let Some(c) = m.captures.first() {
             headings.push(c.node);
         }
     }
-
     let mut sections = Vec::new();
-
     for (i, heading) in headings.iter().enumerate() {
         // Determine level from the heading marker child node
         let mut level = 1;
@@ -183,16 +162,14 @@
             rhs_content: None,
         });
     }
-
     // Build parent/child relationships
     build_hierarchy(&mut sections);
-
     Ok(sections)
 }
 
 fn build_hierarchy(sections: &mut [Section]) {
-    let mut stack: Vec<(usize, usize)> = Vec::new(); // (index, level)
-
+    let mut stack: Vec<(usize, usize)> = Vec::new();
+    // (index, level)
     for i in 0..sections.len() {
         let current_level = sections[i].level;
 
