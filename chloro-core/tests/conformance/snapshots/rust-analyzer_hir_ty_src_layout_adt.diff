COMPARISON DIFF
============================================================

Original size: 6298 bytes
Chloro size:   6306 bytes
Rustfmt size:  6451 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Compute the binary representation of structs, unions and enums
 
 use std::{cmp, ops::Bound};
 
 use hir_def::{
-    signatures::{StructFlags, VariantFields},
     AdtId, VariantId,
+    signatures::{StructFlags, VariantFields},
 };
 use intern::sym;
 use rustc_abi::{Integer, ReprOptions, TargetDataLayout};
 use triomphe::Arc;
 
 use crate::{
-    db::HirDatabase,
-    layout::{field_ty, Layout, LayoutCx, LayoutError},
-    next_solver::GenericArgs,
     TraitEnvironment,
+    db::HirDatabase,
+    layout::{Layout, LayoutCx, LayoutError, field_ty},
+    next_solver::GenericArgs,
 };
 
 pub fn layout_of_adt_query<'db>(
             (
                 r,
                 sig.repr.unwrap_or_default(),
-                sig.flags
-                    .intersects(StructFlags::IS_UNSAFE_CELL | StructFlags::IS_UNSAFE_PINNED),
+                sig.flags.intersects(StructFlags::IS_UNSAFE_CELL | StructFlags::IS_UNSAFE_PINNED),
             )
         }
         AdtId::UnionId(id) => {
         .iter()
         .map(|it| it.iter().map(|it| &**it).collect::<Vec<_>>())
         .collect::<SmallVec<[_; 1]>>();
-    let variants = variants
-        .iter()
-        .map(|it| it.iter().collect())
-        .collect::<IndexVec<_, _>>();
+    let variants = variants.iter().map(|it| it.iter().collect()).collect::<IndexVec<_, _>>();
     let result = if matches!(def, AdtId::UnionId(..)) {
         cx.calc.layout_of_union(&repr, &variants)?
     } else {
             |min, max| repr_discr(dl, &repr, min, max).unwrap_or((Integer::I8, false)),
             variants.iter_enumerated().filter_map(|(id, _)| {
                 let AdtId::EnumId(e) = def else { return None };
-                let d = db
-                    .const_eval_discriminant(e.enum_variants(db).variants[id.0].0)
-                    .ok()?;
+                let d = db.const_eval_discriminant(e.enum_variants(db).variants[id.0].0).ok()?;
                 Some((id, d))
             }),
             !matches!(def, AdtId::EnumId(..))
     Err(LayoutError::RecursiveTypeWithoutIndirection)
 }
 
-fn layout_scalar_valid_range(db: &dyn HirDatabase, def: AdtId) -> (Bound<u128>, Bound<u128>) {
+fn layout_scalar_valid_range(
+    db: &dyn HirDatabase,
+    def: AdtId,
+) -> (Bound<u128>, Bound<u128>) {
     let attrs = db.attrs(def.into());
     let get = |name| {
         let attr = attrs.by_key(name).tt_values();
         }
         Bound::Unbounded
     };
-    (
-        get(sym::rustc_layout_scalar_valid_range_start),
-        get(sym::rustc_layout_scalar_valid_range_end),
-    )
+    (get(sym::rustc_layout_scalar_valid_range_start), get(sym::rustc_layout_scalar_valid_range_end))
 }
 
 /// Finds the appropriate Integer type and signedness for the given
     // which can fit all i128 values, so the result remains unaffected.
     let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u128, max as u128));
     let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));
-
     if let Some(ity) = repr.int {
         let discr = Integer::from_attr(dl, ity);
-        let fit = if ity.is_signed() {
-            signed_fit
-        } else {
-            unsigned_fit
-        };
+        let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };
         if discr < fit {
             return Err(LayoutError::UserReprTooSmall);
         }
         return Ok((discr, ity.is_signed()));
     }
-
     let at_least = if repr.c() {
         // This is usually I32, however it can be different on some platforms,
         // notably hexagon and arm-none/thumb-none
         // repr(Rust) enums try to be as small as possible
         Integer::I8
     };
-
     // If there are no negative values, we can use the unsigned fit.
     Ok(if min >= 0 {
         (cmp::max(unsigned_fit, at_least), false)