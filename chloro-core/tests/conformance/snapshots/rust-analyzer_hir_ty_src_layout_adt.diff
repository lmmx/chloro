COMPARISON DIFF
============================================================

Original size: 6298 bytes
Chloro size:   6238 bytes
Rustfmt size:  6451 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Compute the binary representation of structs, unions and enums
 
 use std::{cmp, ops::Bound};
 
 use hir_def::{
-    signatures::{StructFlags, VariantFields},
     AdtId, VariantId,
+    signatures::{StructFlags, VariantFields},
 };
 use intern::sym;
 use rustc_abi::{Integer, ReprOptions, TargetDataLayout};
 use triomphe::Arc;
 
 use crate::{
-    db::HirDatabase,
-    layout::{field_ty, Layout, LayoutCx, LayoutError},
-    next_solver::GenericArgs,
     TraitEnvironment,
+    db::HirDatabase,
+    layout::{Layout, LayoutCx, LayoutError, field_ty},
+    next_solver::GenericArgs,
 };
 
-pub fn layout_of_adt_query<'db>(
-    db: &'db dyn HirDatabase,
-    def: AdtId,
-    args: GenericArgs<'db>,
-    trait_env: Arc<TraitEnvironment<'db>>,
-) -> Result<Arc<Layout>, LayoutError> {
+pub fn layout_of_adt_query<'db>(db: &'db dyn HirDatabase, def: AdtId, args: GenericArgs<'db>, trait_env: Arc<TraitEnvironment<'db>>) -> Result<Arc<Layout>, LayoutError> {
     let krate = trait_env.krate;
     let Ok(target) = db.target_data_layout(krate) else {
         return Err(LayoutError::TargetLayoutNotAvailable);
             (
                 r,
                 sig.repr.unwrap_or_default(),
-                sig.flags
-                    .intersects(StructFlags::IS_UNSAFE_CELL | StructFlags::IS_UNSAFE_PINNED),
+                sig.flags.intersects(StructFlags::IS_UNSAFE_CELL | StructFlags::IS_UNSAFE_PINNED),
             )
         }
         AdtId::UnionId(id) => {
         .iter()
         .map(|it| it.iter().map(|it| &**it).collect::<Vec<_>>())
         .collect::<SmallVec<[_; 1]>>();
-    let variants = variants
-        .iter()
-        .map(|it| it.iter().collect())
-        .collect::<IndexVec<_, _>>();
+    let variants = variants.iter().map(|it| it.iter().collect()).collect::<IndexVec<_, _>>();
     let result = if matches!(def, AdtId::UnionId(..)) {
         cx.calc.layout_of_union(&repr, &variants)?
     } else {
             |min, max| repr_discr(dl, &repr, min, max).unwrap_or((Integer::I8, false)),
             variants.iter_enumerated().filter_map(|(id, _)| {
                 let AdtId::EnumId(e) = def else { return None };
-                let d = db
-                    .const_eval_discriminant(e.enum_variants(db).variants[id.0].0)
-                    .ok()?;
+                let d = db.const_eval_discriminant(e.enum_variants(db).variants[id.0].0).ok()?;
                 Some((id, d))
             }),
             !matches!(def, AdtId::EnumId(..))
     Ok(Arc::new(result))
 }
 
-pub(crate) fn layout_of_adt_cycle_result<'db>(
-    _: &'db dyn HirDatabase,
-    _def: AdtId,
-    _args: GenericArgs<'db>,
-    _trait_env: Arc<TraitEnvironment<'db>>,
-) -> Result<Arc<Layout>, LayoutError> {
+pub(crate) fn layout_of_adt_cycle_result<'db>(_: &'db dyn HirDatabase, _def: AdtId, _args: GenericArgs<'db>, _trait_env: Arc<TraitEnvironment<'db>>) -> Result<Arc<Layout>, LayoutError> {
     Err(LayoutError::RecursiveTypeWithoutIndirection)
 }
 
         }
         Bound::Unbounded
     };
-    (
-        get(sym::rustc_layout_scalar_valid_range_start),
-        get(sym::rustc_layout_scalar_valid_range_end),
-    )
+    (get(sym::rustc_layout_scalar_valid_range_start), get(sym::rustc_layout_scalar_valid_range_end))
 }
 
 /// Finds the appropriate Integer type and signedness for the given
 /// signed discriminant range and `#[repr]` attribute.
 /// N.B.: `u128` values above `i128::MAX` will be treated as signed, but
 /// that shouldn't affect anything, other than maybe debuginfo.
-fn repr_discr(
-    dl: &TargetDataLayout,
-    repr: &ReprOptions,
-    min: i128,
-    max: i128,
-) -> Result<(Integer, bool), LayoutError> {
+fn repr_discr(dl: &TargetDataLayout, repr: &ReprOptions, min: i128, max: i128) -> Result<(Integer, bool), LayoutError> {
     // Theoretically, negative values could be larger in unsigned representation
     // than the unsigned representation of the signed minimum. However, if there
     // are any negative values, the only valid unsigned representation is u128
     // which can fit all i128 values, so the result remains unaffected.
     let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u128, max as u128));
     let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));
-
     if let Some(ity) = repr.int {
         let discr = Integer::from_attr(dl, ity);
-        let fit = if ity.is_signed() {
-            signed_fit
-        } else {
-            unsigned_fit
-        };
+        let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };
         if discr < fit {
             return Err(LayoutError::UserReprTooSmall);
         }
         return Ok((discr, ity.is_signed()));
     }
-
     let at_least = if repr.c() {
         // This is usually I32, however it can be different on some platforms,
         // notably hexagon and arm-none/thumb-none
         // repr(Rust) enums try to be as small as possible
         Integer::I8
     };
-
     // If there are no negative values, we can use the unsigned fit.
     Ok(if min >= 0 {
         (cmp::max(unsigned_fit, at_least), false)