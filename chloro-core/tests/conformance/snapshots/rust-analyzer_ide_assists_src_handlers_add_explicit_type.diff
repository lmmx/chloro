COMPARISON DIFF
============================================================

Original size: 8388 bytes
Chloro size:   8174 bytes
Rustfmt size:  8479 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use either::Either;
 use hir::HirDisplay;
 use ide_db::syntax_helpers::node_ext::walk_ty;
 use syntax::ast::{self, AstNode, LetStmt, Param};
 
 use crate::{AssistContext, AssistId, Assists};
-
-// Assist: add_explicit_type
-//
-// Specify type for a let binding.
-//
-// ```
-// fn main() {
-//     let x$0 = 92;
-// }
-// ```
-// ->
-// ```
-// fn main() {
-//     let x: i32 = 92;
-// }
-// ```
 pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     let syntax_node = ctx.find_node_at_offset::<Either<LetStmt, Param>>()?;
     let (ascribed_ty, expr, pat) = if let Either::Left(let_stmt) = syntax_node {
 
         (let_stmt.ty(), let_stmt.initializer(), let_stmt.pat()?)
     } else if let Either::Right(param) = syntax_node {
-        if param
-            .syntax()
-            .ancestors()
-            .nth(2)
-            .and_then(ast::ClosureExpr::cast)
-            .is_none()
-        {
+        if param.syntax().ancestors().nth(2).and_then(ast::ClosureExpr::cast).is_none() {
             cov_mark::hit!(add_explicit_type_not_applicable_in_fn_param);
             return None;
         }
     } else {
         return None;
     };
-
     let module = ctx.sema.scope(pat.syntax())?.module();
     let pat_range = pat.syntax().text_range();
-
     // Don't enable the assist if there is a type ascription without any placeholders
     if let Some(ty) = &ascribed_ty {
         let mut contains_infer_ty = false;
             return None;
         }
     }
-
     let ty = match (pat, expr) {
         (ast::Pat::IdentPat(_), Some(expr)) => ctx.sema.type_of_expr(&expr)?,
         (pat, _) => ctx.sema.type_of_pat(&pat)?,
     }
     .adjusted();
-
     // Fully unresolved or unnameable types can't be annotated
     if (ty.contains_unknown() && ty.type_arguments().count() == 0) || ty.is_closure() {
         cov_mark::hit!(add_explicit_type_not_applicable_if_ty_not_inferred);
         return None;
     }
-
-    let inferred_type = ty
-        .display_source_code(ctx.db(), module.into(), false)
-        .ok()?;
+    let inferred_type = ty.display_source_code(ctx.db(), module.into(), false).ok()?;
     acc.add(
         AssistId::refactor_rewrite("add_explicit_type"),
         format!("Insert explicit type `{inferred_type}`"),
 #[cfg(test)]
 mod tests {
     use super::*;
-
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     #[test]
     fn add_explicit_type_target() {
         check_assist_target(add_explicit_type, r#"fn f() { let a$0 = 1; }"#, "a");
     }
-
     #[test]
     fn add_explicit_type_simple() {
         check_assist(
             r#"fn f() { let a: i32 = 1; }"#,
         );
     }
-
     #[test]
     fn add_explicit_type_simple_on_infer_ty() {
         check_assist(
             r#"fn f() { let a: i32 = 1; }"#,
         );
     }
-
     #[test]
     fn add_explicit_type_simple_nested_infer_ty() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_explicit_type_macro_call_expr() {
         check_assist(
             r"macro_rules! v { () => {0u64} } fn f() { let a: u64 = v!(); }",
         );
     }
-
     #[test]
     fn add_explicit_type_not_applicable_for_fully_unresolved() {
         cov_mark::check!(add_explicit_type_not_applicable_if_ty_not_inferred);
         check_assist_not_applicable(add_explicit_type, r#"fn f() { let a$0 = None; }"#);
     }
-
     #[test]
     fn add_explicit_type_applicable_for_partially_unresolved() {
         check_assist(
         fn f() { let a: Vec<_, Vec<_, i32>> = Vec::new(); }"#,
         );
     }
-
     #[test]
     fn add_explicit_type_not_applicable_closure_expr() {
         check_assist_not_applicable(add_explicit_type, r#"fn f() { let a$0 = || {}; }"#);
     }
-
     #[test]
     fn add_explicit_type_not_applicable_ty_already_specified() {
         cov_mark::check!(add_explicit_type_not_applicable_if_ty_already_specified);
         check_assist_not_applicable(add_explicit_type, r#"fn f() { let a$0: i32 = 1; }"#);
     }
-
     #[test]
     fn add_explicit_type_not_applicable_cursor_after_equals_of_let() {
         cov_mark::check!(add_explicit_type_not_applicable_if_cursor_after_equals);
             r#"fn f() {let a =$0 match 1 {2 => 3, 3 => 5};}"#,
         )
     }
-
     /// https://github.com/rust-lang/rust-analyzer/issues/2922
     #[test]
     fn regression_issue_2922() {
 "#,
         );
     }
-
     #[test]
     fn default_generics_should_not_be_added() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn type_should_be_added_after_pattern() {
         // LetStmt = Attr* 'let' Pat (':' Type)? '=' initializer:Expr ';'
 "#,
         );
     }
-
     #[test]
     fn add_explicit_type_inserts_coercions() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn add_explicit_type_not_applicable_fn_param() {
         cov_mark::check!(add_explicit_type_not_applicable_in_fn_param);
         check_assist_not_applicable(add_explicit_type, r#"fn f(x$0: ()) {}"#);
     }
-
     #[test]
     fn add_explicit_type_ascribes_closure_param() {
         check_assist(
 }
 "#,
         );
-
         check_assist(
             add_explicit_type,
             r#"
 "#,
         );
     }
-
     #[test]
     fn add_explicit_type_ascribes_closure_param_already_ascribed() {
         check_assist(