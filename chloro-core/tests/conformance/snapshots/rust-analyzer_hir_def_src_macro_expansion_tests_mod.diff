COMPARISON DIFF
============================================================

Original size: 15554 bytes
Chloro size:   15280 bytes
Rustfmt size:  15554 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! write unit-tests (in fact, we used to do that), but that makes tests brittle
 //! and harder to understand.
 
-mod builtin_derive_macro;
-mod builtin_fn_macro;
-mod mbe;
-mod proc_macros;
-
 use std::{any::TypeId, iter, ops::Range, sync};
 
 use base_db::RootQueryDb;
     tt::TopSubtree,
 };
 
+mod builtin_derive_macro;
+
+mod builtin_fn_macro;
+
+mod mbe;
+
+mod proc_macros;
+
 #[track_caller]
 fn check_errors(#[rust_analyzer::rust_fixture] ra_fixture: &str, expect: Expect) {
     let db = TestDB::with_files(ra_fixture);
             disabled: false,
         },
     )];
-
     fn resolve(
         db: &dyn DefDatabase,
         def_map: &DefMap,
             module.1.scope.macro_invoc(ast_id)
         })
     }
-
     let db = TestDB::with_files_extra_proc_macros(ra_fixture, extra_proc_macros);
     let krate = db.fetch_test_crate();
     let def_map = crate_def_map(&db, krate);
         ModuleSource::SourceFile(it) => it,
         ModuleSource::Module(_) | ModuleSource::BlockExpr(_) => panic!(),
     };
-
     let mut text_edits = Vec::new();
     let mut expansions = Vec::new();
-
     for macro_call_node in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {
         let ast_id = db.ast_id_map(source.file_id).ast_id(&macro_call_node);
         let ast_id = InFile::new(source.file_id, ast_id);
         let expansion_result = db.parse_macro_expansion(macro_call_id);
         expansions.push((macro_call_node.clone(), expansion_result));
     }
-
     for (call, exp) in expansions.into_iter().rev() {
         let mut tree = false;
         let mut expect_errors = false;
         let range: Range<usize> = range.into();
         text_edits.push((range, expn_text));
     }
-
     text_edits.sort_by_key(|(range, _)| range.start);
     text_edits.reverse();
     let mut expanded_text = source_file.to_string();
     for (range, text) in text_edits {
         expanded_text.replace_range(range, &text);
     }
-
     for decl_id in def_map[local_id].scope.declarations() {
         // FIXME: I'm sure there's already better way to do this
         let src = match decl_id {
             format_to!(expanded_text, "\n{}", pp)
         }
     }
-
     for impl_id in def_map[local_id].scope.impls() {
         let src = impl_id.lookup(&db).source(&db);
         if let Some(macro_file) = src.file_id.macro_file()
             format_to!(expanded_text, "\n{}", pp)
         }
     }
-
     expect.indent(false);
     expect.assert_eq(&expanded_text);
 }
     res
 }
 
-fn pretty_print_macro_expansion(
-    expn: SyntaxNode,
-    map: SpanMapRef<'_>,
-    show_spans: bool,
-    show_ctxt: bool,
-) -> String {
+fn pretty_print_macro_expansion(expn: SyntaxNode, map: SpanMapRef<'_>, show_spans: bool, show_ctxt: bool) -> String {
     let mut res = String::new();
     let mut prev_kind = EOF;
     let mut indent_level = 0;
     res
 }
 
-// Identity mapping, but only works when the input is syntactically valid. This
-// simulates common proc macros that unnecessarily parse their input and return
-// compile errors.
 #[derive(Debug)]
 struct IdentityWhenValidProcMacroExpander;
+
 impl ProcMacroExpander for IdentityWhenValidProcMacroExpander {
-    fn expand(
-        &self,
-        subtree: &TopSubtree,
-        _: Option<&TopSubtree>,
-        _: &base_db::Env,
-        _: Span,
-        _: Span,
-        _: Span,
-        _: String,
-    ) -> Result<TopSubtree, ProcMacroExpansionError> {
+    fn expand(&self, subtree: &TopSubtree, _: Option<&TopSubtree>, _: &base_db::Env, _: Span, _: Span, _: Span, _: String) -> Result<TopSubtree, ProcMacroExpansionError> {
         let (parse, _) = syntax_bridge::token_tree_to_syntax_node(
             subtree,
             syntax_bridge::TopEntryPoint::MacroItems,