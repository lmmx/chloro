COMPARISON DIFF
============================================================

Original size: 34201 bytes
Chloro size:   33962 bytes
Rustfmt size:  34201 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
     Highlight, HlMod, HlTag,
     syntax_highlighting::tags::{HlOperator, HlPunct},
 };
-
-pub(super) fn token(
-    sema: &Semantics<'_, RootDatabase>,
-    token: SyntaxToken,
-    edition: Edition,
-    is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
-    in_tt: bool,
-) -> Option<Highlight> {
+pub(super) fn token(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken, edition: Edition, is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool, in_tt: bool) -> Option<Highlight> {
     if let Some(comment) = ast::Comment::cast(token.clone()) {
         let h = HlTag::Comment;
         return Some(match comment.kind().doc {
             None => h.into(),
         });
     }
-
     let h = match token.kind() {
         STRING | BYTE_STRING | C_STRING => HlTag::StringLiteral.into(),
         INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),
     Some(h)
 }
 
-pub(super) fn name_like(
-    sema: &Semantics<'_, RootDatabase>,
-    krate: Option<hir::Crate>,
-    bindings_shadow_count: Option<&mut FxHashMap<hir::Name, u32>>,
-    is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
-    syntactic_name_ref_highlighting: bool,
-    name_like: ast::NameLike,
-    edition: Edition,
-) -> Option<(Highlight, Option<u64>)> {
+pub(super) fn name_like(sema: &Semantics<'_, RootDatabase>, krate: Option<hir::Crate>, bindings_shadow_count: Option<&mut FxHashMap<hir::Name, u32>>, is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool, syntactic_name_ref_highlighting: bool, name_like: ast::NameLike, edition: Edition) -> Option<(Highlight, Option<u64>)> {
     let mut binding_hash = None;
     let highlight = match name_like {
         ast::NameLike::NameRef(name_ref) => highlight_name_ref(
     Some((highlight, binding_hash))
 }
 
-fn punctuation(
-    sema: &Semantics<'_, RootDatabase>,
-    token: SyntaxToken,
-    kind: SyntaxKind,
-    is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
-) -> Highlight {
+fn punctuation(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken, kind: SyntaxKind, is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool) -> Highlight {
     let operator_parent = token.parent();
     let parent_kind = operator_parent.as_ref().map_or(EOF, SyntaxNode::kind);
-
     match (kind, parent_kind) {
         (T![?], TRY_EXPR) => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,
         (T![&], BIN_EXPR) => HlOperator::Bitwise.into(),
     }
 }
 
-fn highlight_name_ref(
-    sema: &Semantics<'_, RootDatabase>,
-    krate: Option<hir::Crate>,
-    bindings_shadow_count: Option<&mut FxHashMap<hir::Name, u32>>,
-    binding_hash: &mut Option<u64>,
-    is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
-    syntactic_name_ref_highlighting: bool,
-    name_ref: ast::NameRef,
-    edition: Edition,
-) -> Highlight {
+fn highlight_name_ref(sema: &Semantics<'_, RootDatabase>, krate: Option<hir::Crate>, bindings_shadow_count: Option<&mut FxHashMap<hir::Name, u32>>, binding_hash: &mut Option<u64>, is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool, syntactic_name_ref_highlighting: bool, name_ref: ast::NameRef, edition: Edition) -> Highlight {
     let db = sema.db;
     if let Some(res) = highlight_method_call_by_name_ref(sema, krate, &name_ref, is_unsafe_node) {
         return res;
     }
-
     let name_class = match NameRefClass::classify(sema, &name_ref) {
         Some(name_kind) => name_kind,
         None if syntactic_name_ref_highlighting => {
             h
         }
     };
-
     h.tag = match name_ref.token_kind() {
         T![Self] => HlTag::Symbol(SymbolKind::SelfType),
         T![self] => HlTag::Symbol(SymbolKind::SelfParam),
     h
 }
 
-fn highlight_name(
-    sema: &Semantics<'_, RootDatabase>,
-    bindings_shadow_count: Option<&mut FxHashMap<hir::Name, u32>>,
-    binding_hash: &mut Option<u64>,
-    is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
-    krate: Option<hir::Crate>,
-    name: ast::Name,
-    edition: Edition,
-) -> Highlight {
+fn highlight_name(sema: &Semantics<'_, RootDatabase>, bindings_shadow_count: Option<&mut FxHashMap<hir::Name, u32>>, binding_hash: &mut Option<u64>, is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool, krate: Option<hir::Crate>, name: ast::Name, edition: Edition) -> Highlight {
     let name_kind = NameClass::classify(sema, &name);
     if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind
         && let Some(bindings_shadow_count) = bindings_shadow_count
     hash_once::<ide_db::FxHasher>((name.as_str(), shadow_count))
 }
 
-pub(super) fn highlight_def(
-    sema: &Semantics<'_, RootDatabase>,
-    krate: Option<hir::Crate>,
-    def: Definition,
-    edition: Edition,
-    is_ref: bool,
-) -> Highlight {
+pub(super) fn highlight_def(sema: &Semantics<'_, RootDatabase>, krate: Option<hir::Crate>, def: Definition, edition: Edition, is_ref: bool) -> Highlight {
     let db = sema.db;
     let mut h = match def {
         Definition::Macro(m) => Highlight::new(HlTag::Symbol(m.kind(sema.db).into())),
         }
         Definition::InlineAsmOperand(_) => Highlight::new(HlTag::Symbol(SymbolKind::Local)),
     };
-
     let def_crate = def.krate(db);
     let is_from_other_crate = def_crate != krate;
     let is_from_builtin_crate = def_crate.is_some_and(|def_crate| def_crate.is_builtin(db));
         false if def.visibility(db) == Some(hir::Visibility::Public) => h |= HlMod::Public,
         _ => (),
     }
-
     if is_from_builtin_crate {
         h |= HlMod::DefaultLibrary;
     }
-
     h
 }
 
-fn highlight_method_call_by_name_ref(
-    sema: &Semantics<'_, RootDatabase>,
-    krate: Option<hir::Crate>,
-    name_ref: &ast::NameRef,
-    is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
-) -> Option<Highlight> {
+fn highlight_method_call_by_name_ref(sema: &Semantics<'_, RootDatabase>, krate: Option<hir::Crate>, name_ref: &ast::NameRef, is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool) -> Option<Highlight> {
     let mc = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;
     highlight_method_call(sema, krate, &mc, is_unsafe_node)
 }
 
-fn highlight_method_call(
-    sema: &Semantics<'_, RootDatabase>,
-    krate: Option<hir::Crate>,
-    method_call: &ast::MethodCallExpr,
-    is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
-) -> Option<Highlight> {
+fn highlight_method_call(sema: &Semantics<'_, RootDatabase>, krate: Option<hir::Crate>, method_call: &ast::MethodCallExpr, is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool) -> Option<Highlight> {
     let func = sema.resolve_method_call(method_call)?;
-
     let mut h = SymbolKind::Method.into();
-
     let is_unsafe = is_unsafe_node(AstPtr::new(method_call).upcast::<ast::Expr>().wrap_left());
     if is_unsafe {
         h |= HlMod::Unsafe;
     {
         h |= HlMod::Trait;
     }
-
     let def_crate = func.module(sema.db).krate();
     let is_from_other_crate = krate.as_ref().map_or(false, |krate| def_crate != *krate);
     let is_from_builtin_crate = def_crate.is_builtin(sema.db);
     let is_public = func.visibility(sema.db) == hir::Visibility::Public;
-
     if is_from_other_crate {
         h |= HlMod::Library;
     } else if is_public {
         h |= HlMod::Public;
     }
-
     if is_from_builtin_crate {
         h |= HlMod::DefaultLibrary;
     }
-
     if let Some(self_param) = func.self_param(sema.db) {
         match self_param.access(sema.db) {
             hir::Access::Shared => h |= HlMod::Reference,
 
 fn highlight_name_by_syntax(name: ast::Name) -> Highlight {
     let default = HlTag::UnresolvedReference;
-
     let parent = match name.syntax().parent() {
         Some(it) => it,
         _ => return default.into(),
     };
-
     let tag = match parent.kind() {
         STRUCT => SymbolKind::Struct,
         ENUM => SymbolKind::Enum,
         ASM_OPERAND_NAMED => SymbolKind::Local,
         _ => return default.into(),
     };
-
     tag.into()
 }
 
-fn highlight_name_ref_by_syntax(
-    name: ast::NameRef,
-    sema: &Semantics<'_, RootDatabase>,
-    krate: Option<hir::Crate>,
-    is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool,
-) -> Highlight {
+fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<'_, RootDatabase>, krate: Option<hir::Crate>, is_unsafe_node: &impl Fn(AstPtr<Either<ast::Expr, ast::Pat>>) -> bool) -> Highlight {
     let default = HlTag::UnresolvedReference;
-
     let parent = match name.syntax().parent() {
         Some(it) => it,
         _ => return default.into(),
     };
-
     match parent.kind() {
         EXTERN_CRATE => HlTag::Symbol(SymbolKind::Module) | HlMod::CrateRoot,
         METHOD_CALL_EXPR => ast::MethodCallExpr::cast(parent)
         node = parent.into();
         kinds = rest;
     }
-
     // Only true if we matched all expected kinds
     kinds.is_empty()
 }