COMPARISON DIFF
============================================================

Original size: 7893 bytes
Chloro size:   7437 bytes
Rustfmt size:  7893 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: unqualify_method_call
-//
-// Transforms universal function call syntax into a method call.
-//
-// ```
-// fn main() {
-//     std::ops::Add::add$0(1, 2);
-// }
-// # mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }
-// ```
-// ->
-// ```
-// use std::ops::Add;
-//
-// fn main() {
-//     1.add(2);
-// }
-// # mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }
-// ```
-pub(crate) fn unqualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn unqualify_method_call(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let call = ctx.find_node_at_offset::<ast::CallExpr>()?;
     let ast::Expr::PathExpr(path_expr) = call.expr()? else { return None };
     let path = path_expr.path()?;
-
     let cursor_in_range = path.syntax().text_range().contains_range(ctx.selection_trimmed());
     if !cursor_in_range {
         return None;
     }
-
     let args = call.arg_list()?;
     let l_paren = args.l_paren_token()?;
     let mut args_iter = args.args();
     let first_arg = args_iter.next()?;
     let second_arg = args_iter.next();
-
     let qualifier = path.qualifier()?;
     let method_name = path.segment()?.name_ref()?;
-
     let scope = ctx.sema.scope(path.syntax())?;
     let res = ctx.sema.resolve_path(&path)?;
     let hir::PathResolution::Def(hir::ModuleDef::Function(fun)) = res else { return None };
     if !fun.has_self_param(ctx.sema.db) {
         return None;
     }
-
     // `core::ops::Add::add(` -> ``
     let delete_path =
         TextRange::new(path.syntax().text_range().start(), l_paren.text_range().end());
-
     // Parens around `expr` if needed
     let parens = first_arg.precedence().needs_parentheses_in(ExprPrecedence::Postfix).then(|| {
         let range = first_arg.syntax().text_range();
         (range.start(), range.end())
     });
-
     // `, ` -> `.add(`
     let replace_comma = TextRange::new(
         first_arg.syntax().text_range().end(),
             .map(|a| a.syntax().text_range().start())
             .unwrap_or_else(|| first_arg.syntax().text_range().end()),
     );
-
     acc.add(
         AssistId::refactor_rewrite("unqualify_method_call"),
         "Unqualify method call",
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn unqualify_method_call_simple() {
         check_assist(
 fn f() { S.f(S); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_trait() {
         check_assist(
 
 fn f() { 2.add(2); }"#,
         );
-
         check_assist(
             unqualify_method_call,
             r#"
 
 fn f() { 2.add(2); }"#,
         );
-
         check_assist(
             unqualify_method_call,
             r#"
 fn f() { 2.add(2); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_single_arg() {
         check_assist(
         fn f() { S.f(); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_parens() {
         check_assist(
 fn f() { (&S).deref(); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_doesnt_apply_with_cursor_not_on_path() {
         check_assist_not_applicable(
 fn f() { core::ops::Add::add(2,$0 2); }"#,
         );
     }
-
     #[test]
     fn unqualify_method_call_doesnt_apply_with_no_self() {
         check_assist_not_applicable(
 fn f() { S::assoc$0(S, S); }"#,
         );
     }
-
     #[test]
     fn inherent_method() {
         check_assist(
         "#,
         );
     }
-
     #[test]
     fn trait_method_in_impl() {
         check_assist(
         "#,
         );
     }
-
     #[test]
     fn trait_method_already_imported() {
         check_assist(