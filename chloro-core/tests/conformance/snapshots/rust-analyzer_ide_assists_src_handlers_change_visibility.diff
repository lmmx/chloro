COMPARISON DIFF
============================================================

Original size: 9744 bytes
Chloro size:   9549 bytes
Rustfmt size:  10260 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use syntax::{
-    ast::{self, HasName, HasVisibility},
     AstNode,
     SyntaxKind::{
         self, ASSOC_ITEM_LIST, CONST, ENUM, FN, MACRO_DEF, MODULE, SOURCE_FILE, STATIC, STRUCT,
         TRAIT, TYPE_ALIAS, USE, VISIBILITY,
     },
     SyntaxNode, T,
+    ast::{self, HasName, HasVisibility},
 };
 
-use crate::{utils::vis_offset, AssistContext, AssistId, Assists};
+use crate::{AssistContext, AssistId, Assists, utils::vis_offset};
 
-// Assist: change_visibility
-//
-// Adds or changes existing visibility specifier.
-//
-// ```
-// $0fn frobnicate() {}
-// ```
-// ->
-// ```
-// pub(crate) fn frobnicate() {}
-// ```
 pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     if let Some(vis) = ctx.find_node_at_offset::<ast::Visibility>() {
         return change_vis(acc, vis);
                 | T![macro]
         )
     });
-
     let (offset, target) = if let Some(keyword) = item_keyword {
         let parent = keyword.parent()?;
 
         }
         (vis_offset(&parent), keyword.text_range())
     } else if let Some(field_name) = ctx.find_node_at_offset::<ast::Name>() {
-        let field = field_name
-            .syntax()
-            .ancestors()
-            .find_map(ast::RecordField::cast)?;
+        let field = field_name.syntax().ancestors().find_map(ast::RecordField::cast)?;
         if field.name()? != field_name {
             cov_mark::hit!(change_visibility_field_false_positive);
             return None;
     } else {
         return None;
     };
-
     acc.add(
         AssistId::refactor_rewrite("change_visibility"),
         "Change visibility to pub(crate)",
 }
 
 fn can_add(node: &SyntaxNode) -> bool {
-    const LEGAL: &[SyntaxKind] = &[
-        CONST, STATIC, TYPE_ALIAS, FN, MODULE, STRUCT, ENUM, TRAIT, USE, MACRO_DEF,
-    ];
-
+    const LEGAL: &[SyntaxKind] =
+        &[CONST, STATIC, TYPE_ALIAS, FN, MODULE, STRUCT, ENUM, TRAIT, USE, MACRO_DEF];
     LEGAL.contains(&node.kind()) && {
         let Some(p) = node.parent() else {
             return false;
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};
-
     use super::*;
-
     #[test]
     fn change_visibility_adds_pub_crate_to_items() {
         check_assist(change_visibility, "$0fn foo() {}", "pub(crate) fn foo() {}");
         check_assist(change_visibility, "f$0n foo() {}", "pub(crate) fn foo() {}");
-        check_assist(
-            change_visibility,
-            "$0struct Foo {}",
-            "pub(crate) struct Foo {}",
-        );
+        check_assist(change_visibility, "$0struct Foo {}", "pub(crate) struct Foo {}");
         check_assist(change_visibility, "$0mod foo {}", "pub(crate) mod foo {}");
-        check_assist(
-            change_visibility,
-            "$0trait Foo {}",
-            "pub(crate) trait Foo {}",
-        );
+        check_assist(change_visibility, "$0trait Foo {}", "pub(crate) trait Foo {}");
         check_assist(change_visibility, "m$0od {}", "pub(crate) mod {}");
-        check_assist(
-            change_visibility,
-            "unsafe f$0n foo() {}",
-            "pub(crate) unsafe fn foo() {}",
-        );
-        check_assist(
-            change_visibility,
-            "$0macro foo() {}",
-            "pub(crate) macro foo() {}",
-        );
+        check_assist(change_visibility, "unsafe f$0n foo() {}", "pub(crate) unsafe fn foo() {}");
+        check_assist(change_visibility, "$0macro foo() {}", "pub(crate) macro foo() {}");
         check_assist(change_visibility, "$0use foo;", "pub(crate) use foo;");
         check_assist(
             change_visibility,
             "fn bar() { impl Foo { pub(crate) fn foo() {} } }",
         );
     }
-
     #[test]
     fn change_visibility_works_with_struct_fields() {
         check_assist(
             r"struct S { $0field: u32 }",
             r"struct S { pub(crate) field: u32 }",
         );
-        check_assist(
-            change_visibility,
-            r"struct S ( $0u32 )",
-            r"struct S ( pub(crate) u32 )",
-        );
+        check_assist(change_visibility, r"struct S ( $0u32 )", r"struct S ( pub(crate) u32 )");
     }
-
     #[test]
     fn change_visibility_field_false_positive() {
         cov_mark::check!(change_visibility_field_false_positive);
             r"struct S { field: [(); { let $0x = ();}] }",
         )
     }
-
     #[test]
     fn change_visibility_pub_to_pub_crate() {
-        check_assist(
-            change_visibility,
-            "$0pub fn foo() {}",
-            "pub(crate) fn foo() {}",
-        )
+        check_assist(change_visibility, "$0pub fn foo() {}", "pub(crate) fn foo() {}")
     }
-
     #[test]
     fn change_visibility_pub_crate_to_pub() {
-        check_assist(
-            change_visibility,
-            "$0pub(crate) fn foo() {}",
-            "pub fn foo() {}",
-        )
+        check_assist(change_visibility, "$0pub(crate) fn foo() {}", "pub fn foo() {}")
     }
-
     #[test]
     fn change_visibility_const() {
-        check_assist(
-            change_visibility,
-            "$0const FOO = 3u8;",
-            "pub(crate) const FOO = 3u8;",
-        );
+        check_assist(change_visibility, "$0const FOO = 3u8;", "pub(crate) const FOO = 3u8;");
     }
-
     #[test]
     fn change_visibility_static() {
-        check_assist(
-            change_visibility,
-            "$0static FOO = 3u8;",
-            "pub(crate) static FOO = 3u8;",
-        );
+        check_assist(change_visibility, "$0static FOO = 3u8;", "pub(crate) static FOO = 3u8;");
     }
-
     #[test]
     fn change_visibility_type_alias() {
-        check_assist(
-            change_visibility,
-            "$0type T = ();",
-            "pub(crate) type T = ();",
-        );
+        check_assist(change_visibility, "$0type T = ();", "pub(crate) type T = ();");
     }
-
     #[test]
     fn change_visibility_handles_comment_attrs() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn not_applicable_for_enum_variants() {
         check_assist_not_applicable(
               fn main() { foo::Foo::Foo1$0 } ",
         );
     }
-
     #[test]
     fn not_applicable_for_enum_variant_fields() {
         check_assist_not_applicable(change_visibility, r"pub enum Foo { Foo1($0i32) }");
-
         check_assist_not_applicable(change_visibility, r"pub enum Foo { Foo1 { $0n: i32 } }");
     }
-
     #[test]
     fn change_visibility_target() {
         check_assist_target(change_visibility, "$0fn foo() {}", "fn");
         check_assist_target(change_visibility, "pub(crate)$0 fn foo() {}", "pub(crate)");
         check_assist_target(change_visibility, "struct S { $0field: u32 }", "field");
     }
-
     #[test]
     fn not_applicable_for_items_within_traits() {
         check_assist_not_applicable(change_visibility, "trait Foo { f$0n run() {} }");
         check_assist_not_applicable(change_visibility, "trait Foo { con$0st FOO: u8 = 69; }");
         check_assist_not_applicable(change_visibility, "impl Foo for Bar { f$0n quox() {} }");
     }
-
     #[test]
     fn not_applicable_for_items_within_fns() {
         check_assist_not_applicable(change_visibility, "fn foo() { f$0n inner() {} }");