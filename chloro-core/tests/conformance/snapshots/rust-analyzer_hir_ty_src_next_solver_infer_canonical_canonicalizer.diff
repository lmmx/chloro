COMPARISON DIFF
============================================================

Original size: 29589 bytes
Chloro size:   29011 bytes
Rustfmt size:  29841 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 use rustc_hash::FxHashMap;
 use rustc_index::Idx;
-use rustc_type_ir::inherent::{Const as _, IntoKind as _, Region as _, SliceLike, Ty as _};
 use rustc_type_ir::InferTy::{self, FloatVar, IntVar, TyVar};
+use rustc_type_ir::inherent::{Const as _, IntoKind as _, Region as _, SliceLike, Ty as _};
 use rustc_type_ir::{
     BoundVar, BoundVarIndexKind, CanonicalQueryInput, DebruijnIndex, Flags, InferConst, RegionKind,
     TyVid, TypeFlags, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitableExt, UniverseIndex,
     Binder, Canonical, CanonicalVarKind, CanonicalVars, Const, ConstKind, DbInterner, GenericArg,
     ParamEnvAnd, Placeholder, Region, Ty, TyKind,
 };
-
 /// When we canonicalize a value to form a query, we wind up replacing
 /// various parts of it with canonical variables. This struct stores
 /// those replaced bits to remember for when we process the query
     /// we only ever put ROOT values into the query, so this map is very
     /// simple.
     pub universe_map: SmallVec<[UniverseIndex; 4]>,
-
     /// This is equivalent to `CanonicalVarValues`, but using a
     /// `SmallVec` yields a significant performance win.
     pub var_values: SmallVec<[GenericArg<'db>; 8]>,
     fn default() -> Self {
         let mut universe_map = SmallVec::default();
         universe_map.push(UniverseIndex::ROOT);
-
-        Self {
-            universe_map,
-            var_values: SmallVec::default(),
-        }
+        Self { universe_map, var_values: SmallVec::default() }
     }
 }
 
     /// out the [chapter in the rustc dev guide][c].
     ///
     /// [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html#canonicalizing-the-query
-    pub fn canonicalize_query<V>(
-        &self,
-        value: ParamEnvAnd<'db, V>,
-        query_state: &mut OriginalQueryValues<'db>,
-    ) -> CanonicalQueryInput<DbInterner<'db>, ParamEnvAnd<'db, V>>
+    pub fn canonicalize_query<V>(&self, value: ParamEnvAnd<'db, V>, query_state: &mut OriginalQueryValues<'db>) -> CanonicalQueryInput<DbInterner<'db>, ParamEnvAnd<'db, V>>
     where
-        V: TypeFoldable<DbInterner<'db>>,
-    {
+        V: TypeFoldable<DbInterner<'db>>, {
         let (param_env, value) = value.into_parts();
         // FIXME(#118965): We don't canonicalize the static lifetimes that appear in the
         // `param_env` because they are treated differently by trait selection.
             &CanonicalizeFreeRegionsOtherThanStatic,
             query_state,
         );
-
         let canonical = Canonicalizer::canonicalize_with_base(
             canonical_param_env,
             value,
             query_state,
         )
         .unchecked_map(|(param_env, value)| ParamEnvAnd { param_env, value });
-        CanonicalQueryInput {
-            canonical,
-            typing_mode: self.typing_mode(),
-        }
+        CanonicalQueryInput { canonical, typing_mode: self.typing_mode() }
     }
 
     /// Canonicalizes a query *response* `V`. When we canonicalize a
     /// [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html#canonicalizing-the-query-result
     pub fn canonicalize_response<V>(&self, value: V) -> Canonical<'db, V>
     where
-        V: TypeFoldable<DbInterner<'db>>,
-    {
+        V: TypeFoldable<DbInterner<'db>>, {
         let mut query_state = OriginalQueryValues::default();
         Canonicalizer::canonicalize(
             value,
 
     pub fn canonicalize_user_type_annotation<V>(&self, value: V) -> Canonical<'db, V>
     where
-        V: TypeFoldable<DbInterner<'db>>,
-    {
+        V: TypeFoldable<DbInterner<'db>>, {
         let mut query_state = OriginalQueryValues::default();
         Canonicalizer::canonicalize(
             value,
 /// maximally general query. But if we are canonicalizing a *query
 /// response*, then we don't typically replace free regions, as they
 /// must have been introduced from other parts of the system.
-trait CanonicalizeMode {
-    fn canonicalize_free_region<'db>(
-        &self,
-        canonicalizer: &mut Canonicalizer<'_, 'db>,
-        r: Region<'db>,
-    ) -> Region<'db>;
-
-    fn any(&self) -> bool;
-
-    // Do we preserve universe of variables.
-    fn preserve_universes(&self) -> bool;
-}
+fn canonicalize_free_region<'db>(&self, canonicalizer: &mut Canonicalizer<'_, 'db>, r: Region<'db>) -> Region<'db>;
+fn any(&self) -> bool;
+fn preserve_universes(&self) -> bool;
 
 struct CanonicalizeQueryResponse;
 
 impl CanonicalizeMode for CanonicalizeQueryResponse {
-    fn canonicalize_free_region<'db>(
-        &self,
-        canonicalizer: &mut Canonicalizer<'_, 'db>,
-        mut r: Region<'db>,
-    ) -> Region<'db> {
+    fn canonicalize_free_region<'db>(&self, canonicalizer: &mut Canonicalizer<'_, 'db>, mut r: Region<'db>) -> Region<'db> {
         let infcx = canonicalizer.infcx;
-
         if let RegionKind::ReVar(vid) = r.kind() {
             r = infcx
                 .inner
                      opportunistically resolved to {r:?}",
             );
         };
-
         match r.kind() {
             RegionKind::ReLateParam(_)
             | RegionKind::ReErased
 struct CanonicalizeUserTypeAnnotation;
 
 impl CanonicalizeMode for CanonicalizeUserTypeAnnotation {
-    fn canonicalize_free_region<'db>(
-        &self,
-        canonicalizer: &mut Canonicalizer<'_, 'db>,
-        r: Region<'db>,
-    ) -> Region<'db> {
+    fn canonicalize_free_region<'db>(&self, canonicalizer: &mut Canonicalizer<'_, 'db>, r: Region<'db>) -> Region<'db> {
         match r.kind() {
             RegionKind::ReEarlyParam(_)
             | RegionKind::ReLateParam(_)
 struct CanonicalizeAllFreeRegions;
 
 impl CanonicalizeMode for CanonicalizeAllFreeRegions {
-    fn canonicalize_free_region<'db>(
-        &self,
-        canonicalizer: &mut Canonicalizer<'_, 'db>,
-        r: Region<'db>,
-    ) -> Region<'db> {
+    fn canonicalize_free_region<'db>(&self, canonicalizer: &mut Canonicalizer<'_, 'db>, r: Region<'db>) -> Region<'db> {
         canonicalizer.canonical_var_for_region_in_root_universe(r)
     }
 
 struct CanonicalizeFreeRegionsOtherThanStatic;
 
 impl CanonicalizeMode for CanonicalizeFreeRegionsOtherThanStatic {
-    fn canonicalize_free_region<'db>(
-        &self,
-        canonicalizer: &mut Canonicalizer<'_, 'db>,
-        r: Region<'db>,
-    ) -> Region<'db> {
-        if r.is_static() {
-            r
-        } else {
-            canonicalizer.canonical_var_for_region_in_root_universe(r)
-        }
+    fn canonicalize_free_region<'db>(&self, canonicalizer: &mut Canonicalizer<'_, 'db>, r: Region<'db>) -> Region<'db> {
+        if r.is_static() { r } else { canonicalizer.canonical_var_for_region_in_root_universe(r) }
     }
 
     fn any(&self) -> bool {
     tcx: DbInterner<'db>,
     variables: SmallVec<[CanonicalVarKind<'db>; 8]>,
     query_state: &'cx mut OriginalQueryValues<'db>,
-    // Note that indices is only used once `var_values` is big enough to be
-    // heap-allocated.
     indices: FxHashMap<GenericArg<'db>, BoundVar>,
     /// Maps each `sub_unification_table_root_var` to the index of the first
     /// variable which used it.
     sub_root_lookup_table: FxHashMap<TyVid, usize>,
     canonicalize_mode: &'cx dyn CanonicalizeMode,
     needs_canonical_flags: TypeFlags,
-
     binder_index: DebruijnIndex,
 }
 
 
     fn fold_binder<T>(&mut self, t: Binder<'db, T>) -> Binder<'db, T>
     where
-        T: TypeFoldable<DbInterner<'db>>,
-    {
+        T: TypeFoldable<DbInterner<'db>>, {
         self.binder_index.shift_in(1);
         let t = t.super_fold_with(self);
         self.binder_index.shift_out(1);
             }
             _ => {}
         }
-
         if ct.flags().intersects(self.needs_canonical_flags) {
             ct.super_fold_with(self)
         } else {
 impl<'cx, 'db> Canonicalizer<'cx, 'db> {
     /// The main `canonicalize` method, shared impl of
     /// `canonicalize_query` and `canonicalize_response`.
-    fn canonicalize<V>(
-        value: V,
-        infcx: &InferCtxt<'db>,
-        tcx: DbInterner<'db>,
-        canonicalize_region_mode: &dyn CanonicalizeMode,
-        query_state: &mut OriginalQueryValues<'db>,
-    ) -> Canonical<'db, V>
+    fn canonicalize<V>(value: V, infcx: &InferCtxt<'db>, tcx: DbInterner<'db>, canonicalize_region_mode: &dyn CanonicalizeMode, query_state: &mut OriginalQueryValues<'db>) -> Canonical<'db, V>
     where
-        V: TypeFoldable<DbInterner<'db>>,
-    {
+        V: TypeFoldable<DbInterner<'db>>, {
         let base = Canonical {
             max_universe: UniverseIndex::ROOT,
             variables: CanonicalVars::new_from_iter(tcx, []),
         .unchecked_map(|((), val)| val)
     }
 
-    fn canonicalize_with_base<U, V>(
-        base: Canonical<'db, U>,
-        value: V,
-        infcx: &InferCtxt<'db>,
-        tcx: DbInterner<'db>,
-        canonicalize_region_mode: &dyn CanonicalizeMode,
-        query_state: &mut OriginalQueryValues<'db>,
-    ) -> Canonical<'db, (U, V)>
+    fn canonicalize_with_base<U, V>(base: Canonical<'db, U>, value: V, infcx: &InferCtxt<'db>, tcx: DbInterner<'db>, canonicalize_region_mode: &dyn CanonicalizeMode, query_state: &mut OriginalQueryValues<'db>) -> Canonical<'db, (U, V)>
     where
-        V: TypeFoldable<DbInterner<'db>>,
-    {
+        V: TypeFoldable<DbInterner<'db>>, {
         let needs_canonical_flags = if canonicalize_region_mode.any() {
             TypeFlags::HAS_INFER | TypeFlags::HAS_PLACEHOLDER | TypeFlags::HAS_FREE_REGIONS
         } else {
             TypeFlags::HAS_INFER | TypeFlags::HAS_PLACEHOLDER
         };
-
         // Fast path: nothing that needs to be canonicalized.
         if !value.has_type_flags(needs_canonical_flags) {
             return base.unchecked_map(|b| (b, value));
         }
-
         let mut canonicalizer = Canonicalizer {
             infcx,
             tcx,
                 .collect();
         }
         let out_value = value.fold_with(&mut canonicalizer);
-
         // Once we have canonicalized `out_value`, it should not
         // contain anything that ties it to this inference context
         // anymore.
         debug_assert!(!out_value.has_infer() && !out_value.has_placeholders());
-
         let canonical_variables =
             CanonicalVars::new_from_iter(tcx, canonicalizer.universe_canonicalized_variables());
-
         let max_universe = canonical_variables
             .iter()
             .map(|cvar| cvar.universe())
             .max()
             .unwrap_or(UniverseIndex::ROOT);
-
-        Canonical {
-            max_universe,
-            variables: canonical_variables,
-            value: (base.value, out_value),
-        }
+        Canonical { max_universe, variables: canonical_variables, value: (base.value, out_value) }
     }
 
     /// Creates a canonical variable replacing `kind` from the input,
     /// seen. `kind` is expected to be an unbound variable (or
     /// potentially a free region).
     fn canonical_var(&mut self, info: CanonicalVarKind<'db>, kind: GenericArg<'db>) -> BoundVar {
-        let Canonicalizer {
-            variables,
-            query_state,
-            indices,
-            ..
-        } = self;
-
+        let Canonicalizer { variables, query_state, indices, .. } = self;
         let var_values = &mut query_state.var_values;
-
         let universe = info.universe();
         if universe != UniverseIndex::ROOT {
             assert!(self.canonicalize_mode.preserve_universes());
                 Ok(_) => {}
             }
         }
-
         // This code is hot. `variables` and `var_values` are usually small
         // (fewer than 8 elements ~95% of the time). They are SmallVec's to
         // avoid allocations in those cases. We also don't use `indices` to
 
     fn get_or_insert_sub_root(&mut self, vid: TyVid) -> BoundVar {
         let root_vid = self.infcx.sub_unification_table_root_var(vid);
-        let idx = *self
-            .sub_root_lookup_table
-            .entry(root_vid)
-            .or_insert_with(|| self.variables.len());
+        let idx =
+            *self.sub_root_lookup_table.entry(root_vid).or_insert_with(|| self.variables.len());
         BoundVar::from(idx)
     }
 
         if self.query_state.universe_map.len() == 1 {
             return self.variables;
         }
-
         let reverse_universe_map: FxHashMap<UniverseIndex, UniverseIndex> = self
             .query_state
             .universe_map
             .enumerate()
             .map(|(idx, universe)| (*universe, UniverseIndex::from_usize(idx)))
             .collect();
-
         self.variables
             .iter()
             .map(|v| match *v {
                 CanonicalVarKind::Int | CanonicalVarKind::Float => *v,
-                CanonicalVarKind::Ty { ui, sub_root } => CanonicalVarKind::Ty {
-                    ui: reverse_universe_map[&ui],
-                    sub_root,
-                },
+                CanonicalVarKind::Ty { ui, sub_root } => {
+                    CanonicalVarKind::Ty { ui: reverse_universe_map[&ui], sub_root }
+                }
                 CanonicalVarKind::Region(u) => CanonicalVarKind::Region(reverse_universe_map[&u]),
                 CanonicalVarKind::Const(u) => CanonicalVarKind::Const(reverse_universe_map[&u]),
                 CanonicalVarKind::PlaceholderTy(placeholder) => {
 
     /// Creates a canonical variable (with the given `info`)
     /// representing the region `r`; return a region referencing it.
-    fn canonical_var_for_region(
-        &mut self,
-        info: CanonicalVarKind<'db>,
-        r: Region<'db>,
-    ) -> Region<'db> {
+    fn canonical_var_for_region(&mut self, info: CanonicalVarKind<'db>, r: Region<'db>) -> Region<'db> {
         let var = self.canonical_var(info, r.into());
         Region::new_canonical_bound(self.cx(), var)
     }
     /// if `const_var` is bound to anything; if so, canonicalize
     /// *that*. Otherwise, create a new canonical variable for
     /// `const_var`.
-    fn canonicalize_const_var(
-        &mut self,
-        info: CanonicalVarKind<'db>,
-        const_var: Const<'db>,
-    ) -> Const<'db> {
+    fn canonicalize_const_var(&mut self, info: CanonicalVarKind<'db>, const_var: Const<'db>) -> Const<'db> {
         debug_assert_eq!(const_var, self.infcx.shallow_resolve_const(const_var));
         let var = self.canonical_var(info, const_var.into());
         Const::new_canonical_bound(self.cx(), var)