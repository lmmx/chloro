COMPARISON DIFF
============================================================

Original size: 25435 bytes
Chloro size:   25027 bytes
Rustfmt size:  25435 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
-mod render;
-
-#[cfg(test)]
-mod tests;
-
 use std::{iter, ops::Not};
 
 use either::Either;
     runnables::{runnable_fn, runnable_mod},
 };
 
+mod render;
+#[cfg(test)]
+mod tests;
+
 #[derive(Clone, Debug)]
 pub struct HoverConfig<'a> {
     pub links_in_hover: bool,
     pub actions: Vec<HoverAction>,
 }
 
-// Feature: Hover
-//
-// Shows additional information, like the type of an expression or the documentation for a definition when "focusing" code.
-// Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.
-//
-// ![Hover](https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif)
 pub(crate) fn hover(
     db: &RootDatabase,
     frange @ FileRange { file_id, range }: FileRange,
     } else {
         hover_ranged(sema, frange, file, config, edition, display_target)
     }?;
-
     if let HoverDocFormat::PlainText = config.format {
         res.info.markup = remove_markdown(res.info.markup.as_str()).into();
     }
         kind if kind.is_trivia() => 0,
         _ => 1,
     })?;
-
     if let Some(doc_comment) = token_as_doc_comment(&original_token) {
         cov_mark::hit!(no_highlight_on_comment_hover);
         return doc_comment.get_definition_with_descend_at(sema, offset, |def, node, range| {
             Some(RangeInfo::new(range, res))
         });
     }
-
     if let Some((range, _, _, resolution)) =
         sema.check_for_format_args_template(original_token.clone(), offset)
     {
         );
         return Some(RangeInfo::new(range, res));
     }
-
     if let Some(literal) = ast::String::cast(original_token.clone())
         && let Some((analysis, fixture_analysis)) =
             Analysis::from_ra_fixture(sema, literal.clone(), &literal, config.minicore)
             .upmap_from_ra_fixture(&fixture_analysis, virtual_file_id, file_id)
             .ok();
     }
-
     // prefer descending the same token kind in attribute expansions, in normal macros text
     // equivalency is more important
     let mut descended = sema.descend_into_macros(original_token.clone());
-
     let ranker = Ranker::from_token(&original_token);
-
     descended.sort_by_cached_key(|tok| !ranker.rank_token(tok));
-
     let mut res = vec![];
     for token in descended {
         let is_same_kind = token.kind() == ranker.kind;
             res.push(result)
         }
     }
-
     res.into_iter()
         .unique()
         .reduce(|mut acc: HoverResult, HoverResult { markup, actions }| {
     })
 }
 
-// FIXME: Why is this pub(crate)?
 pub(crate) fn hover_for_definition(
     sema: &Semantics<'_, RootDatabase>,
     file_id: FileId,
         Definition::BuiltinType(_) => sema.scope(scope_node).map(|it| FamousDefs(sema, it.krate())),
         _ => None,
     };
-
     let db = sema.db;
     let def_ty = match def {
         Definition::Local(it) => Some(it.ty(db)),
     };
     let notable_traits = def_ty.map(|ty| notable_traits(db, &ty)).unwrap_or_default();
     let subst_types = subst.map(|subst| subst.types(db));
-
     let (markup, range_map) = render::definition(
         sema.db,
         def,
         // impls any trait, and we don't want to show it as having any notable trait.
         return Vec::new();
     }
-
     db.notable_traits_in_deps(ty.krate(db).into())
         .iter()
         .flat_map(|it| &**it)
             offset: nav_target.focus_or_full_range().start(),
         })
     }
-
     let adt = match def {
         Definition::Trait(it) => {
             return it.try_to_nav(sema).map(UpmappingResult::call_site).map(to_action);
             targets.push(item);
         }
     };
-
     for &(trait_, ref assocs) in notable_traits {
         push_new_def(trait_.into());
         assocs.iter().filter_map(|(ty, _)| ty.as_ref()).for_each(|ty| {
             walk_and_push_ty(db, ty, &mut push_new_def);
         });
     }
-
     if let Ok(generic_def) = GenericDef::try_from(def) {
         generic_def.type_or_const_params(db).into_iter().for_each(|it| {
             walk_and_push_ty(db, &it.ty(db), &mut push_new_def);
         });
     }
-
     let ty = match def {
         Definition::Local(it) => Some(it.ty(db)),
         Definition::Field(field) => Some(field.ty(db).to_type(db)),
     if let Some(ty) = ty {
         walk_and_push_ty(db, &ty, &mut push_new_def);
     }
-
     if let Some(subst_types) = subst_types {
         for (_, ty) in subst_types {
             walk_and_push_ty(db, &ty, &mut push_new_def);
         }
     }
-
     HoverAction::goto_type_from_targets(sema, targets, edition)
 }
 
 fn dedupe_or_merge_hover_actions(actions: Vec<HoverAction>) -> Vec<HoverAction> {
     let mut deduped_actions = Vec::with_capacity(actions.len());
     let mut go_to_type_targets = FxIndexSet::default();
-
     let mut seen_implementation = false;
     let mut seen_reference = false;
     let mut seen_runnable = false;
             }
         };
     }
-
     if !go_to_type_targets.is_empty() {
         deduped_actions.push(HoverAction::GoToType(
             go_to_type_targets.into_iter().sorted_by(|a, b| a.mod_path.cmp(&b.mod_path)).collect(),
         ));
     }
-
     deduped_actions
 }