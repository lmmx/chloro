COMPARISON DIFF
============================================================

Original size: 19839 bytes
Chloro size:   19475 bytes
Rustfmt size:  20426 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
-pub(crate) use rustc_next_trait_solver::solve::inspect::*;
-
 use rustc_ast_ir::try_visit;
+pub(crate) use rustc_next_trait_solver::solve::inspect::*;
 use rustc_next_trait_solver::{
     canonical::instantiate_canonical_state,
     resolve::eager_resolve_vars,
-    solve::{inspect, SolverDelegateEvalExt},
+    solve::{SolverDelegateEvalExt, inspect},
 };
 use rustc_type_ir::{
+    VisitorResult,
     inherent::{IntoKind, Span as _},
     solve::{Certainty, GoalSource, MaybeCause, NoSolution},
-    VisitorResult,
 };
 
 use crate::next_solver::{
-    fulfill::NextSolverError,
-    infer::{
-        traits::{Obligation, ObligationCause},
-        InferCtxt,
-    },
-    obligation_ctxt::ObligationCtxt,
     DbInterner, GenericArg, GenericArgs, Goal, NormalizesTo, ParamEnv, Predicate, PredicateKind,
     QueryResult, SolverContext, Span, Term,
+    fulfill::NextSolverError,
+    infer::{
+        InferCtxt,
+        traits::{Obligation, ObligationCause},
+    },
+    obligation_ctxt::ObligationCtxt,
 };
 
 pub(crate) struct InspectConfig {
     /// Relate the `term` with the new `unconstrained_term` created
     /// when computing the proof tree for this `NormalizesTo` goals.
     /// This handles nested obligations.
-    fn constrain_and(
-        &self,
-        infcx: &InferCtxt<'db>,
-        param_env: ParamEnv<'db>,
-        f: impl FnOnce(&mut ObligationCtxt<'_, 'db>),
-    ) -> Result<Certainty, NoSolution> {
+    fn constrain_and(&self, infcx: &InferCtxt<'db>, param_env: ParamEnv<'db>, f: impl FnOnce(&mut ObligationCtxt<'_, 'db>)) -> Result<Certainty, NoSolution> {
         let mut ocx = ObligationCtxt::new(infcx);
-        ocx.eq(
-            &ObligationCause::dummy(),
-            param_env,
-            self.term,
-            self.unconstrained_term,
-        )?;
+        ocx.eq(&ObligationCause::dummy(), param_env, self.term, self.unconstrained_term)?;
         f(&mut ocx);
         let errors = ocx.evaluate_obligations_error_on_ambiguity();
         if errors.is_empty() {
             Ok(Certainty::Yes)
-        } else if errors
-            .iter()
-            .all(|e| !matches!(e, NextSolverError::TrueError(_)))
-        {
+        } else if errors.iter().all(|e| !matches!(e, NextSolverError::TrueError(_))) {
             Ok(Certainty::AMBIGUOUS)
         } else {
             Err(NoSolution)
     /// Visit all nested goals of this candidate without rolling
     /// back their inference constraints. This function modifies
     /// the state of the `infcx`.
-    pub(crate) fn visit_nested_no_probe<V: ProofTreeVisitor<'db>>(
-        &self,
-        visitor: &mut V,
-    ) -> V::Result {
+    pub(crate) fn visit_nested_no_probe<V: ProofTreeVisitor<'db>>(&self, visitor: &mut V) -> V::Result {
         for goal in self.instantiate_nested_goals() {
             try_visit!(goal.visit_with(visitor));
         }
-
         V::Result::output()
     }
 
         let infcx = self.goal.infcx;
         let param_env = self.goal.goal.param_env;
         let mut orig_values = self.goal.orig_values.to_vec();
-
         let mut instantiated_goals = vec![];
         for step in &self.steps {
             match **step {
                 | inspect::ProbeStep::NestedProbe(_) => unreachable!(),
             }
         }
-
         let () = instantiate_canonical_state(
             infcx,
             Span::dummy(),
             &mut orig_values,
             self.final_state,
         );
-
         if let Some(term_hack) = &self.goal.normalizes_to_term_hack {
             // FIXME: We ignore the expected term of `NormalizesTo` goals
             // when computing the result of its candidates. This is
             // scuffed.
             let _ = term_hack.constrain_and(infcx, param_env, |_| {});
         }
-
         instantiated_goals
             .into_iter()
             .map(|(source, goal)| self.instantiate_proof_tree_for_nested_goal(source, goal))
         let infcx = self.goal.infcx;
         let param_env = self.goal.goal.param_env;
         let mut orig_values = self.goal.orig_values.to_vec();
-
         for step in &self.steps {
             match **step {
                 inspect::ProbeStep::RecordImplArgs { impl_args } => {
                 | inspect::ProbeStep::NestedProbe(_) => unreachable!(),
             }
         }
-
         panic!("expected impl args probe step for `instantiate_impl_args`");
     }
 
-    pub(crate) fn instantiate_proof_tree_for_nested_goal(
-        &self,
-        source: GoalSource,
-        goal: Goal<'db, Predicate<'db>>,
-    ) -> InspectGoal<'a, 'db> {
+    pub(crate) fn instantiate_proof_tree_for_nested_goal(&self, source: GoalSource, goal: Goal<'db, Predicate<'db>>) -> InspectGoal<'a, 'db> {
         let infcx = self.goal.infcx;
         match goal.predicate.kind().no_bound_vars() {
             Some(PredicateKind::NormalizesTo(NormalizesTo { alias, term })) => {
                 let unconstrained_term = infcx.next_term_var_of_kind(term);
-                let goal = goal.with(
-                    infcx.interner,
-                    NormalizesTo {
-                        alias,
-                        term: unconstrained_term,
-                    },
-                );
+                let goal =
+                    goal.with(infcx.interner, NormalizesTo { alias, term: unconstrained_term });
                 // We have to use a `probe` here as evaluating a `NormalizesTo` can constrain the
                 // expected term. This means that candidates which only fail due to nested goals
                 // and which normalize to a different term then the final result could ICE: when
                 // building their proof tree, the expected term was unconstrained, but when
                 // instantiating the candidate it is already constrained to the result of another
                 // candidate.
-                let normalizes_to_term_hack = NormalizesToTermHack {
-                    term,
-                    unconstrained_term,
-                };
+                let normalizes_to_term_hack = NormalizesToTermHack { term, unconstrained_term };
                 let (proof_tree, nested_goals_result) = infcx.probe(|_| {
                     // Here, if we have any nested goals, then we make sure to apply them
                     // considering the constrained RHS, and pass the resulting certainty to
                 // into another candidate who ends up with different inference
                 // constraints, we get an ICE if we already applied the constraints
                 // from the chosen candidate.
-                let proof_tree = infcx.probe(|_| {
-                    infcx
-                        .evaluate_root_goal_for_proof_tree(goal, Span::dummy())
-                        .1
-                });
+                let proof_tree =
+                    infcx.probe(|_| infcx.evaluate_root_goal_for_proof_tree(goal, Span::dummy()).1);
                 InspectGoal::new(infcx, self.goal.depth + 1, proof_tree, None, source)
             }
         }
     /// Visit all nested goals of this candidate, rolling back
     /// all inference constraints.
     #[expect(dead_code, reason = "used in rustc")]
-    pub(crate) fn visit_nested_in_probe<V: ProofTreeVisitor<'db>>(
-        &self,
-        visitor: &mut V,
-    ) -> V::Result {
-        self.goal
-            .infcx
-            .probe(|_| self.visit_nested_no_probe(visitor))
+    pub(crate) fn visit_nested_in_probe<V: ProofTreeVisitor<'db>>(&self, visitor: &mut V) -> V::Result {
+        self.goal.infcx.probe(|_| self.visit_nested_no_probe(visitor))
     }
 }
 
         self.depth
     }
 
-    fn candidates_recur(
-        &'a self,
-        candidates: &mut Vec<InspectCandidate<'a, 'db>>,
-        steps: &mut Vec<&'a inspect::ProbeStep<DbInterner<'db>>>,
-        probe: &'a inspect::Probe<DbInterner<'db>>,
-    ) {
+    fn candidates_recur(&'a self, candidates: &mut Vec<InspectCandidate<'a, 'db>>, steps: &mut Vec<&'a inspect::ProbeStep<DbInterner<'db>>>, probe: &'a inspect::Probe<DbInterner<'db>>) {
         let mut shallow_certainty = None;
         for step in &probe.steps {
             match *step {
                 inspect::ProbeStep::AddGoal(..) | inspect::ProbeStep::RecordImplArgs { .. } => {
                     steps.push(step)
                 }
-                inspect::ProbeStep::MakeCanonicalResponse {
-                    shallow_certainty: c,
-                } => {
+                inspect::ProbeStep::MakeCanonicalResponse { shallow_certainty: c } => {
                     assert!(matches!(
                         shallow_certainty.replace(c),
-                        None | Some(Certainty::Maybe {
-                            cause: MaybeCause::Ambiguity,
-                            ..
-                        })
+                        None | Some(Certainty::Maybe { cause: MaybeCause::Ambiguity, .. })
                     ));
                 }
                 inspect::ProbeStep::NestedProbe(ref probe) => {
                 }
             }
         }
-
         match probe.kind {
             inspect::ProbeKind::ProjectionCompatibility
             | inspect::ProbeKind::ShadowedEnvProbing => {
         candidates.pop().filter(|_| candidates.is_empty())
     }
 
-    fn new(
-        infcx: &'a InferCtxt<'db>,
-        depth: usize,
-        root: inspect::GoalEvaluation<DbInterner<'db>>,
-        term_hack_and_nested_certainty: Option<(
+    fn new(infcx: &'a InferCtxt<'db>, depth: usize, root: inspect::GoalEvaluation<DbInterner<'db>>, term_hack_and_nested_certainty: Option<(
             NormalizesToTermHack<'db>,
             Result<Certainty, NoSolution>,
-        )>,
-        source: GoalSource,
-    ) -> Self {
+        )>, source: GoalSource) -> Self {
         let infcx = <&SolverContext<'db>>::from(infcx);
-
-        let inspect::GoalEvaluation {
-            uncanonicalized_goal,
-            orig_values,
-            final_revision,
-            result,
-        } = root;
+        let inspect::GoalEvaluation { uncanonicalized_goal, orig_values, final_revision, result } =
+            root;
         // If there's a normalizes-to goal, AND the evaluation result with the result of
         // constraining the normalizes-to RHS and computing the nested goals.
         let result = result.and_then(|ok| {
                 term_hack_and_nested_certainty.map_or(Ok(Certainty::Yes), |(_, c)| c)?;
             Ok(ok.value.certainty.and(nested_goals_certainty))
         });
-
         InspectGoal {
             infcx,
             depth,
         if self.depth < visitor.config().max_depth {
             try_visit!(visitor.visit_goal(self));
         }
-
         V::Result::output()
     }
 }
 
 /// The public API to interact with proof trees.
-pub(crate) trait ProofTreeVisitor<'db> {
-    type Result: VisitorResult;
-
-    fn config(&self) -> InspectConfig {
-        InspectConfig { max_depth: 10 }
-    }
-
-    fn visit_goal(&mut self, goal: &InspectGoal<'_, 'db>) -> Self::Result;
+type Result;
+fn config(&self) -> InspectConfig {
+    InspectConfig { max_depth: 10 }
 }
+fn visit_goal(&mut self, goal: &InspectGoal<'_, 'db>) -> Self::Result;
 
 impl<'db> InferCtxt<'db> {
-    pub(crate) fn visit_proof_tree<V: ProofTreeVisitor<'db>>(
-        &self,
-        goal: Goal<'db, Predicate<'db>>,
-        visitor: &mut V,
-    ) -> V::Result {
+    pub(crate) fn visit_proof_tree<V: ProofTreeVisitor<'db>>(&self, goal: Goal<'db, Predicate<'db>>, visitor: &mut V) -> V::Result {
         self.visit_proof_tree_at_depth(goal, 0, visitor)
     }
 
-    pub(crate) fn visit_proof_tree_at_depth<V: ProofTreeVisitor<'db>>(
-        &self,
-        goal: Goal<'db, Predicate<'db>>,
-        depth: usize,
-        visitor: &mut V,
-    ) -> V::Result {
+    pub(crate) fn visit_proof_tree_at_depth<V: ProofTreeVisitor<'db>>(&self, goal: Goal<'db, Predicate<'db>>, depth: usize, visitor: &mut V) -> V::Result {
         let (_, proof_tree) = <&SolverContext<'db>>::from(self)
             .evaluate_root_goal_for_proof_tree(goal, Span::dummy());
-        visitor.visit_goal(&InspectGoal::new(
-            self,
-            depth,
-            proof_tree,
-            None,
-            GoalSource::Misc,
-        ))
+        visitor.visit_goal(&InspectGoal::new(self, depth, proof_tree, None, GoalSource::Misc))
     }
 }