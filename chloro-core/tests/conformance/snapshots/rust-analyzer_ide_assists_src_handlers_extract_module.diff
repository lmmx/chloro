COMPARISON DIFF
============================================================

Original size: 53759 bytes
Chloro size:   52978 bytes
Rustfmt size:  53759 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 };
 
 use crate::{AssistContext, Assists};
-
 use super::remove_unused_param::range_to_remove;
 
-// Assist: extract_module
-//
-// Extracts a selected region as separate module. All the references, visibility and imports are
-// resolved.
-//
-// ```
-// $0fn foo(name: i32) -> i32 {
-//     name + 1
-// }$0
-//
-// fn bar(name: i32) -> i32 {
-//     name + 2
-// }
-// ```
-// ->
-// ```
-// mod modname {
-//     pub(crate) fn foo(name: i32) -> i32 {
-//         name + 1
-//     }
-// }
-//
-// fn bar(name: i32) -> i32 {
-//     name + 2
-// }
-// ```
 pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
     if ctx.has_empty_selection() {
         return None;
     }
-
     let node = ctx.covering_element();
     let node = match node {
         syntax::NodeOrToken::Node(n) => n,
         syntax::NodeOrToken::Token(t) => t.parent()?,
     };
-
     let mut curr_parent_module: Option<ast::Module> = None;
     if let Some(mod_syn_opt) = node.ancestors().find(|it| ast::Module::can_cast(it.kind())) {
         curr_parent_module = ast::Module::cast(mod_syn_opt);
     }
-
     let selection_range = ctx.selection_trimmed();
     let (mut module, module_text_range) = if let Some(item) = ast::Item::cast(node.clone()) {
         let module = extract_single_target(&item);
     if module.body_items.is_empty() {
         return None;
     }
-
     let mut old_item_indent = module.body_items[0].indent_level();
     let old_items: Vec<_> = module.use_items.iter().chain(&module.body_items).cloned().collect();
-
     // If the selection is inside impl block, we need to place new module outside impl block,
     // as impl blocks cannot contain modules
-
     let mut impl_parent: Option<ast::Impl> = None;
     let mut impl_child_count: usize = 0;
     if let Some(parent_assoc_list) = module.body_items[0].syntax().parent()
         old_item_indent = impl_.indent_level();
         impl_parent = Some(impl_);
     }
-
     acc.add(
         AssistId::refactor_extract("extract_module"),
         "Extract Module",
     )
 }
 
-fn generate_module_def(
-    parent_impl: &Option<ast::Impl>,
-    Module { name, body_items, use_items }: &Module,
-) -> ast::Module {
+fn generate_module_def(parent_impl: &Option<ast::Impl>, Module { name, body_items, use_items }: &Module) -> ast::Module {
     let items: Vec<_> = if let Some(impl_) = parent_impl.as_ref()
         && let Some(self_ty) = impl_.self_ty()
     {
     } else {
         use_items.iter().chain(body_items).cloned().collect()
     };
-
     let items = items.into_iter().map(|it| it.reset_indent().indent(IndentLevel(1))).collect_vec();
     let module_body = make::item_list(Some(items));
-
     let module_name = make::name(name);
     make::mod_(module_name, Some(module_body))
 }
         None,
         make::use_tree(make::join_paths(vec![super_path, node_path]), None, None, false),
     );
-
     ast::Item::from(use_)
 }
 
     Module { name, body_items, use_items }
 }
 
-fn extract_child_target(
-    node: &SyntaxNode,
-    selection_range: TextRange,
-) -> Option<(Module, RangeInclusive<SyntaxNode>)> {
+fn extract_child_target(node: &SyntaxNode, selection_range: TextRange) -> Option<(Module, RangeInclusive<SyntaxNode>)> {
     let selected_nodes = node
         .children()
         .filter(|node| selection_range.contains_range(node.text_range()))
 }
 
 impl Module {
-    fn get_usages_and_record_fields(
-        &self,
-        ctx: &AssistContext<'_>,
-        replace_range: TextRange,
-    ) -> (FxHashMap<FileId, Vec<(TextRange, String)>>, Vec<SyntaxNode>, FxHashMap<TextSize, ast::Use>)
-    {
+    fn get_usages_and_record_fields(&self, ctx: &AssistContext<'_>, replace_range: TextRange) -> (FxHashMap<FileId, Vec<(TextRange, String)>>, Vec<SyntaxNode>, FxHashMap<TextSize, ast::Use>) {
         let mut adt_fields = Vec::new();
         let mut refs: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();
         // use `TextSize` as key to avoid repeated use stmts
         let mut use_stmts_to_be_inserted = FxHashMap::default();
-
         //Here impl is not included as each item inside impl will be tied to the parent of
         //implementing block(a struct, enum, etc), if the parent is in selected module, it will
         //get updated by ADT section given below or if it is not, then we dont need to do any operation
-
         for item in &self.body_items {
             match_ast! {
                 match (item.syntax()) {
                 }
             }
         }
-
         (refs, adt_fields, use_stmts_to_be_inserted)
     }
 
-    fn expand_and_group_usages_file_wise(
-        &self,
-        ctx: &AssistContext<'_>,
-        replace_range: TextRange,
-        node_def: Definition,
-        refs_in_files: &mut FxHashMap<FileId, Vec<(TextRange, String)>>,
-        use_stmts_to_be_inserted: &mut FxHashMap<TextSize, ast::Use>,
-    ) {
+    fn expand_and_group_usages_file_wise(&self, ctx: &AssistContext<'_>, replace_range: TextRange, node_def: Definition, refs_in_files: &mut FxHashMap<FileId, Vec<(TextRange, String)>>, use_stmts_to_be_inserted: &mut FxHashMap<TextSize, ast::Use>) {
         let mod_name = self.name;
         let covering_node = match ctx.covering_element() {
             syntax::NodeOrToken::Node(node) => node,
         };
         let out_of_sel = |node: &SyntaxNode| !replace_range.contains_range(node.text_range());
         let mut use_stmts_set = FxHashSet::default();
-
         for (file_id, refs) in node_def.usages(&ctx.sema).all() {
             let source_file = ctx.sema.parse(file_id);
             let usages = refs.into_iter().filter_map(|FileReference { range, .. }| {
     fn change_visibility(&mut self, record_fields: Vec<SyntaxNode>) {
         let (mut replacements, record_field_parents, impls) =
             get_replacements_for_visibility_change(&mut self.body_items, false);
-
         let mut impl_items = impls
             .into_iter()
             .flat_map(|impl_| impl_.syntax().descendants())
             .filter_map(ast::Item::cast)
             .collect_vec();
-
         let (mut impl_item_replacements, _, _) =
             get_replacements_for_visibility_change(&mut impl_items, true);
-
         replacements.append(&mut impl_item_replacements);
-
         for (_, field_owner) in record_field_parents {
             for desc in field_owner.descendants().filter_map(ast::RecordField::cast) {
                 let is_record_field_present =
                 }
             }
         }
-
         for (vis, syntax) in replacements {
             let item = syntax.children_with_tokens().find(|node_or_token| {
                 match node_or_token.kind() {
         }
     }
 
-    fn resolve_imports(
-        &mut self,
-        module: Option<ast::Module>,
-        ctx: &AssistContext<'_>,
-    ) -> Vec<TextRange> {
+    fn resolve_imports(&mut self, module: Option<ast::Module>, ctx: &AssistContext<'_>) -> Vec<TextRange> {
         let mut imports_to_remove = vec![];
         let mut node_set = FxHashSet::default();
-
         for item in self.body_items.clone() {
             item.syntax()
                 .descendants()
                     }
                 })
         }
-
         imports_to_remove
     }
 
-    fn process_def_in_sel(
-        &mut self,
-        def: Definition,
-        use_node: &SyntaxNode,
-        curr_parent_module: &Option<ast::Module>,
-        ctx: &AssistContext<'_>,
-    ) -> Option<TextRange> {
+    fn process_def_in_sel(&mut self, def: Definition, use_node: &SyntaxNode, curr_parent_module: &Option<ast::Module>, ctx: &AssistContext<'_>) -> Option<TextRange> {
         //We only need to find in the current file
         let selection_range = ctx.selection_trimmed();
         let file_id = ctx.file_id();
         let usage_res = def.usages(&ctx.sema).in_scope(&SearchScope::single_file(file_id)).all();
-
         let file = ctx.sema.parse(file_id);
-
         // track uses which does not exists in `Use`
         let mut uses_exist_in_sel = false;
         let mut uses_exist_out_sel = false;
                 }
             }
         }
-
         let (def_in_mod, def_out_sel) = check_def_in_mod_and_out_sel(
             def,
             ctx,
             selection_range,
             file_id.file_id(ctx.db()),
         );
-
         // Find use stmt that use def in current file
         let use_stmt: Option<ast::Use> = usage_res
             .into_iter()
         let use_stmt_not_in_sel = use_stmt.as_ref().is_some_and(|use_stmt| {
             !selection_range.contains_range(use_stmt.syntax().text_range())
         });
-
         let mut use_tree_paths: Option<Vec<ast::Path>> = None;
         //Exists inside and outside selection
         // - Use stmt for item is present -> get the use_tree_str and reconstruct the path in new
         //outside:
         //- Def is inside: Nothing to import
         //- Def is outside: Import it inside with super
-
         //Exists inside selection but not outside -> Check for the import of it in original module,
         //get the use_tree_str, reconstruct the use stmt in new module
-
         let mut import_path_to_be_removed: Option<TextRange> = None;
         if uses_exist_in_sel && uses_exist_out_sel {
             //Changes to be made only inside new module
                 self.use_items.insert(0, super_use_node);
             }
         }
-
         if let Some(mut use_tree_paths) = use_tree_paths {
             use_tree_paths.reverse();
 
                 self.use_items.insert(0, ast::Item::from(use_));
             }
         }
-
         import_path_to_be_removed
     }
 
-    fn process_use_stmt_for_import_resolve(
-        &self,
-        use_stmt: Option<ast::Use>,
-        node_syntax: &SyntaxNode,
-    ) -> Option<(Vec<ast::Path>, Option<TextRange>)> {
+    fn process_use_stmt_for_import_resolve(&self, use_stmt: Option<ast::Use>, node_syntax: &SyntaxNode) -> Option<(Vec<ast::Path>, Option<TextRange>)> {
         let use_stmt = use_stmt?;
         for path_seg in use_stmt.syntax().descendants().filter_map(ast::PathSegment::cast) {
             if path_seg.syntax().to_string() == node_syntax.to_string() {
                 return Some((use_tree_str, None));
             }
         }
-
         None
     }
 }
 
-fn check_intersection_and_push(
-    import_paths_to_be_removed: &mut Vec<TextRange>,
-    mut import_path: TextRange,
-) {
+fn check_intersection_and_push(import_paths_to_be_removed: &mut Vec<TextRange>, mut import_path: TextRange) {
     // Text ranges received here for imports are extended to the
     // next/previous comma which can cause intersections among them
     // and later deletion of these can cause panics similar
     import_paths_to_be_removed.push(import_path);
 }
 
-fn check_def_in_mod_and_out_sel(
-    def: Definition,
-    ctx: &AssistContext<'_>,
-    curr_parent_module: &Option<ast::Module>,
-    selection_range: TextRange,
-    curr_file_id: FileId,
-) -> (bool, bool) {
+fn check_def_in_mod_and_out_sel(def: Definition, ctx: &AssistContext<'_>, curr_parent_module: &Option<ast::Module>, selection_range: TextRange, curr_file_id: FileId) -> (bool, bool) {
     macro_rules! check_item {
         ($x:ident) => {
             if let Some(source) = $x.source(ctx.db()) {
             }
         };
     }
-
     match def {
         Definition::Module(x) => {
             let source = x.definition_source(ctx.db());
         Definition::TypeAlias(x) => check_item!(x),
         _ => {}
     }
-
     (false, false)
 }
 
-fn get_replacements_for_visibility_change(
-    items: &mut [ast::Item],
-    is_clone_for_updated: bool,
-) -> (
+fn get_replacements_for_visibility_change(items: &mut [ast::Item], is_clone_for_updated: bool) -> (
     Vec<(Option<ast::Visibility>, SyntaxNode)>,
     Vec<(Option<ast::Visibility>, SyntaxNode)>,
     Vec<ast::Impl>,
     let mut replacements = Vec::new();
     let mut record_field_parents = Vec::new();
     let mut impls = Vec::new();
-
     for item in items {
         if !is_clone_for_updated {
             *item = item.clone_for_update();
             _ => (),
         }
     }
-
     (replacements, record_field_parents, impls)
 }
 
-fn get_use_tree_paths_from_path(
-    path: ast::Path,
-    use_tree_str: &mut Vec<ast::Path>,
-) -> Option<&mut Vec<ast::Path>> {
+fn get_use_tree_paths_from_path(path: ast::Path, use_tree_str: &mut Vec<ast::Path>) -> Option<&mut Vec<ast::Path>> {
     path.syntax()
         .ancestors()
         .filter(|x| x.to_string() != path.to_string())
             }
             None
         })?;
-
     Some(use_tree_str)
 }
 
 #[cfg(test)]
 mod tests {
     use crate::tests::{check_assist, check_assist_not_applicable};
-
     use super::*;
-
     #[test]
     fn test_not_applicable_without_selection() {
         check_assist_not_applicable(
             ",
         )
     }
-
     #[test]
     fn test_extract_module() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_extract_module_for_function_only() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_extract_module_for_impl_having_corresponding_adt_in_selection() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_import_resolve_when_its_only_inside_selection() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_import_resolve_when_its_inside_and_outside_selection_and_source_not_in_same_mod() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_import_resolve_when_its_inside_and_outside_selection_and_source_is_in_same_mod() {
         check_assist(
             ",
         )
     }
-
     #[test]
-    fn test_extract_module_for_corresponding_adt_of_impl_present_in_same_mod_but_not_in_selection()
-    {
+    fn test_extract_module_for_corresponding_adt_of_impl_present_in_same_mod_but_not_in_selection() {
         check_assist(
             extract_module,
             r"
             ",
         )
     }
-
     #[test]
-    fn test_extract_module_for_impl_not_having_corresponding_adt_in_selection_and_not_in_same_mod_but_with_super()
-     {
+    fn test_extract_module_for_impl_not_having_corresponding_adt_in_selection_and_not_in_same_mod_but_with_super() {
         check_assist(
             extract_module,
             r"
             ",
         )
     }
-
     #[test]
     fn test_import_resolve_for_trait_bounds_on_function() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_extract_module_for_module() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_extract_module_with_multiple_files() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_extract_module_macro_rules() {
         check_assist(
             ",
         );
     }
-
     #[test]
     fn test_do_not_apply_visibility_modifier_to_trait_impl_items() {
         check_assist(
             ",
         )
     }
-
     #[test]
     fn test_if_inside_impl_block_generate_module_outside() {
         check_assist(
             }
         ",
         );
-
         check_assist(
             extract_module,
             r"struct A {}
         ",
         )
     }
-
     #[test]
     fn test_if_inside_impl_block_generate_module_outside_but_impl_block_having_one_child() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn test_issue_11766() {
         //https://github.com/rust-lang/rust-analyzer/issues/11766
         ",
         )
     }
-
     #[test]
     fn test_issue_12790() {
         check_assist(
         ",
         )
     }
-
     #[test]
     fn test_merge_multiple_intersections() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_remove_import_path_inside_selection() {
         check_assist(
 "#,
         );
     }
-
     #[test]
     fn test_miss_select_item() {
         check_assist(