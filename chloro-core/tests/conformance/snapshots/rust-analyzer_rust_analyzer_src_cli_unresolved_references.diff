COMPARISON DIFF
============================================================

Original size: 6105 bytes
Chloro size:   6064 bytes
Rustfmt size:  6316 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Reports references in code that the IDE layer cannot resolve.
-use hir::{db::HirDatabase, sym, AnyDiagnostic, Crate, Module, Semantics};
+
+use hir::{AnyDiagnostic, Crate, Module, Semantics, db::HirDatabase, sym};
 use ide::{AnalysisHost, RootDatabase, TextRange};
 use ide_db::{
-    base_db::SourceDatabase, defs::NameRefClass, EditionedFileId, FxHashSet, LineIndexDatabase as _,
+    EditionedFileId, FxHashSet, LineIndexDatabase as _, base_db::SourceDatabase, defs::NameRefClass,
 };
-use load_cargo::{load_workspace_at, LoadCargoConfig, ProcMacroServerChoice};
+use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
 use parser::SyntaxKind;
-use syntax::{ast, AstNode, WalkEvent};
+use syntax::{AstNode, WalkEvent, ast};
 use vfs::FileId;
 
 use crate::cli::flags;
 impl flags::UnresolvedReferences {
     pub fn run(self) -> anyhow::Result<()> {
         const STACK_SIZE: usize = 1024 * 1024 * 8;
-
         let handle = stdx::thread::Builder::new(
             stdx::thread::ThreadIntent::LatencySensitive,
             "BIG_STACK_THREAD",
         .stack_size(STACK_SIZE)
         .spawn(|| self.run_())
         .unwrap();
-
         handle.join()
     }
 
         let host = AnalysisHost::with_database(db);
         let db = host.raw_database();
         let sema = Semantics::new(db);
-
         let mut visited_files = FxHashSet::default();
-
         let work = all_modules(db).into_iter().filter(|module| {
             let file_id = module.definition_source_file_id(db).original_file(db);
             let source_root = db.file_source_root(file_id.file_id(db)).source_root_id(db);
             let source_root = db.source_root(source_root).source_root(db);
             !source_root.is_library
         });
-
         for module in work {
             let file_id = module.definition_source_file_id(db).original_file(db);
             let file_id = file_id.file_id(db);
             if !visited_files.contains(&file_id) {
-                let crate_name = module
-                    .krate()
-                    .display_name(db)
-                    .as_deref()
-                    .unwrap_or(&sym::unknown)
-                    .to_owned();
+                let crate_name =
+                    module.krate().display_name(db).as_deref().unwrap_or(&sym::unknown).to_owned();
                 let file_path = vfs.file_path(file_id);
                 eprintln!("processing crate: {crate_name}, module: {file_path}",);
 
                 visited_files.insert(file_id);
             }
         }
-
         eprintln!();
         eprintln!("scan complete");
-
         Ok(())
     }
 }
 
 fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {
-    let mut worklist: Vec<_> = Crate::all(db)
-        .into_iter()
-        .map(|krate| krate.root_module())
-        .collect();
+    let mut worklist: Vec<_> =
+        Crate::all(db).into_iter().map(|krate| krate.root_module()).collect();
     let mut modules = Vec::new();
-
     while let Some(module) = worklist.pop() {
         modules.push(module);
         worklist.extend(module.children(db));
     }
-
     modules
 }
 
-fn find_unresolved_references(
-    db: &RootDatabase,
-    sema: &Semantics<'_, RootDatabase>,
-    file_id: FileId,
-    module: &Module,
-) -> Vec<TextRange> {
+fn find_unresolved_references(db: &RootDatabase, sema: &Semantics<'_, RootDatabase>, file_id: FileId, module: &Module) -> Vec<TextRange> {
     let mut unresolved_references = all_unresolved_references(sema, file_id);
-
     // remove unresolved references which are within inactive code
     let mut diagnostics = Vec::new();
     module.diagnostics(db, &mut diagnostics, false);
         };
 
         let node = inactive_code.node;
-        let range = node
-            .map(|it| it.text_range())
-            .original_node_file_range_rooted(db);
+        let range = node.map(|it| it.text_range()).original_node_file_range_rooted(db);
 
         if range.file_id.file_id(db) != file_id {
             continue;
 
         unresolved_references.retain(|r| !range.range.contains_range(*r));
     }
-
     unresolved_references
 }
 
-fn all_unresolved_references(
-    sema: &Semantics<'_, RootDatabase>,
-    file_id: FileId,
-) -> Vec<TextRange> {
+fn all_unresolved_references(sema: &Semantics<'_, RootDatabase>, file_id: FileId) -> Vec<TextRange> {
     let file_id = sema
         .attach_first_edition(file_id)
         .unwrap_or_else(|| EditionedFileId::current_edition(sema.db, file_id));
     let file = sema.parse(file_id);
     let root = file.syntax();
-
     let mut unresolved_references = Vec::new();
     for event in root.preorder() {
         let WalkEvent::Enter(syntax) = event else {
             continue;
         };
         let Some(descended_name_ref) = name_ref.syntax().first_token().and_then(|tok| {
-            sema.descend_into_macros_single_exact(tok)
-                .parent()
-                .and_then(ast::NameRef::cast)
+            sema.descend_into_macros_single_exact(tok).parent().and_then(ast::NameRef::cast)
         }) else {
             continue;
         };
         }
 
         // if we couldn't classify it, but it's in an attr, ignore it. See #10935
-        if descended_name_ref
-            .syntax()
-            .ancestors()
-            .any(|it| it.kind() == SyntaxKind::ATTR)
-        {
+        if descended_name_ref.syntax().ancestors().any(|it| it.kind() == SyntaxKind::ATTR) {
             continue;
         }
 