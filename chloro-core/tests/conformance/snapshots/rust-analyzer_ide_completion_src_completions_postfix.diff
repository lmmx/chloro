COMPARISON DIFF
============================================================

Original size: 32377 bytes
Chloro size:   32260 bytes
Rustfmt size:  32377 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Postfix completions, like `Ok(10).ifl$0` => `if let Ok() = Ok(10) { $0 }`.
 
-mod format_like;
-
 use base_db::SourceDatabase;
 use hir::{ItemInNs, Semantics};
 use ide_db::{
     item::{Builder, CompletionRelevancePostfixMatch},
 };
 
-pub(crate) fn complete_postfix(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    dot_access: &DotAccess<'_>,
-) {
+mod format_like;
+
+pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext<'_>, dot_access: &DotAccess<'_>) {
     if !ctx.config.enable_postfix_completions {
         return;
     }
-
     let (dot_receiver, receiver_ty, receiver_is_ambiguous_float_literal) = match dot_access {
         DotAccess { receiver_ty: Some(ty), receiver: Some(it), kind, .. } => (
             it,
         _ => return,
     };
     let expr_ctx = &dot_access.ctx;
-
     let receiver_text =
         get_receiver_text(&ctx.sema, dot_receiver, receiver_is_ambiguous_float_literal);
-
     let cap = match ctx.config.snippet_cap {
         Some(it) => it,
         None => return,
     };
-
     let postfix_snippet = match build_postfix_snippet_builder(ctx, cap, dot_receiver) {
         Some(it) => it,
         None => return,
     };
-
     let cfg = ctx.config.find_path_config(ctx.is_nightly);
-
     if let Some(drop_trait) = ctx.famous_defs().core_ops_Drop()
         && receiver_ty.impls_trait(ctx.db, drop_trait, &[])
         && let Some(drop_fn) = ctx.famous_defs().core_mem_drop()
         item.set_documentation(drop_fn.docs(ctx.db));
         item.add_to(acc, ctx.db);
     }
-
     postfix_snippet("ref", "&expr", &format!("&{receiver_text}")).add_to(acc, ctx.db);
     postfix_snippet("refm", "&mut expr", &format!("&mut {receiver_text}")).add_to(acc, ctx.db);
     postfix_snippet("deref", "*expr", &format!("*{receiver_text}")).add_to(acc, ctx.db);
-
     // The rest of the postfix completions create an expression that moves an argument,
     // so it's better to consider references now to avoid breaking the compilation
-
     let (dot_receiver_including_refs, prefix) = include_references(dot_receiver);
     let mut receiver_text =
         get_receiver_text(&ctx.sema, dot_receiver, receiver_is_ambiguous_float_literal);
             Some(it) => it,
             None => return,
         };
-
     if !ctx.config.snippets.is_empty() {
         add_custom_postfix_completions(acc, ctx, &postfix_snippet, &receiver_text);
     }
-
     postfix_snippet("box", "Box::new(expr)", &format!("Box::new({receiver_text})"))
         .add_to(acc, ctx.db);
-    postfix_snippet("dbg", "dbg!(expr)", &format!("dbg!({receiver_text})")).add_to(acc, ctx.db); // fixme
+    postfix_snippet("dbg", "dbg!(expr)", &format!("dbg!({receiver_text})")).add_to(acc, ctx.db);
+    // fixme
     postfix_snippet("dbgr", "dbg!(&expr)", &format!("dbg!(&{receiver_text})")).add_to(acc, ctx.db);
     postfix_snippet("call", "function(expr)", &format!("${{1}}({receiver_text})"))
         .add_to(acc, ctx.db);
-
     let try_enum = TryEnum::from_ty(&ctx.sema, &receiver_ty.strip_references());
     let mut is_in_cond = false;
     if let Some(parent) = dot_receiver_including_refs.syntax().parent()
             _ => (),
         }
     }
-
     if !is_in_cond {
         match try_enum {
             Some(try_enum) => match try_enum {
             .add_to(acc, ctx.db);
         }
     }
-
     let block_should_be_wrapped = if let ast::Expr::BlockExpr(block) = dot_receiver {
         block.modifier().is_some() || !block.is_standalone()
     } else {
             format!("{open_paren}const {open_brace}{receiver_text}{close_brace}{close_paren}");
         postfix_snippet("const", "const {}", &const_completion_string).add_to(acc, ctx.db);
     }
-
     if let ast::Expr::Literal(literal) = dot_receiver_including_refs.clone()
         && let Some(literal_text) = ast::String::cast(literal.token())
     {
         add_format_like_completions(acc, ctx, &dot_receiver_including_refs, cap, &literal_text);
     }
-
     postfix_snippet(
         "return",
         "return expr",
         ),
     )
     .add_to(acc, ctx.db);
-
     if let Some(BreakableKind::Block | BreakableKind::Loop) = expr_ctx.in_breakable {
         postfix_snippet(
             "break",
     }
 }
 
-fn get_receiver_text(
-    sema: &Semantics<'_, RootDatabase>,
-    receiver: &ast::Expr,
-    receiver_is_ambiguous_float_literal: bool,
-) -> String {
+fn get_receiver_text(sema: &Semantics<'_, RootDatabase>, receiver: &ast::Expr, receiver_is_ambiguous_float_literal: bool) -> String {
     // Do not just call `receiver.to_string()`, as that will mess up whitespaces inside macros.
     let Some(mut range) = sema.original_range_opt(receiver.syntax()) else {
         return receiver.to_string();
     }
     let file_text = sema.db.file_text(range.file_id.file_id(sema.db));
     let mut text = file_text.text(sema.db)[range.range].to_owned();
-
     // The receiver texts should be interpreted as-is, as they are expected to be
     // normal Rust expressions.
     escape_snippet_bits(&mut text);
 
 fn include_references(initial_element: &ast::Expr) -> (ast::Expr, String) {
     let mut resulting_element = initial_element.clone();
-
     while let Some(field_expr) = resulting_element.syntax().parent().and_then(ast::FieldExpr::cast)
     {
         resulting_element = ast::Expr::from(field_expr);
     }
-
     let mut prefix = String::new();
-
     let mut found_ref_or_deref = false;
-
     while let Some(parent_deref_element) =
         resulting_element.syntax().parent().and_then(ast::PrefixExpr::cast)
     {
 
         prefix.insert(0, '*');
     }
-
     while let Some(parent_ref_element) =
         resulting_element.syntax().parent().and_then(ast::RefExpr::cast)
     {
 
         prefix.insert_str(0, if exclusive { "&mut " } else { "&" });
     }
-
     if !found_ref_or_deref {
         // If we do not find any ref/deref expressions, restore
         // all the progress of tree climbing
         prefix.clear();
         resulting_element = initial_element.clone();
     }
-
     (resulting_element, prefix)
 }
 
-fn build_postfix_snippet_builder<'ctx>(
-    ctx: &'ctx CompletionContext<'_>,
-    cap: SnippetCap,
-    receiver: &'ctx ast::Expr,
-) -> Option<impl Fn(&str, &str, &str) -> Builder + 'ctx> {
+fn build_postfix_snippet_builder<'ctx>(ctx: &'ctx CompletionContext<'_>, cap: SnippetCap, receiver: &'ctx ast::Expr) -> Option<impl Fn(&str, &str, &str) -> Builder + 'ctx> {
     let receiver_range = ctx.sema.original_range_opt(receiver.syntax())?.range;
     if ctx.source_range().end() < receiver_range.start() {
         // This shouldn't happen, yet it does. I assume this might be due to an incorrect token
         return None;
     }
     let delete_range = TextRange::new(receiver_range.start(), ctx.source_range().end());
-
     // Wrapping impl Fn in an option ruins lifetime inference for the parameters in a way that
     // can't be annotated for the closure, hence fix it by constructing it without the Option first
     fn build<'ctx>(
     Some(build(ctx, cap, delete_range))
 }
 
-fn add_custom_postfix_completions(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    postfix_snippet: impl Fn(&str, &str, &str) -> Builder,
-    receiver_text: &str,
-) -> Option<()> {
+fn add_custom_postfix_completions(acc: &mut Completions, ctx: &CompletionContext<'_>, postfix_snippet: impl Fn(&str, &str, &str) -> Builder, receiver_text: &str) -> Option<()> {
     ImportScope::find_insert_use_container(&ctx.token.parent()?, &ctx.sema)?;
     ctx.config.postfix_snippets().filter(|(_, snip)| snip.scope == SnippetScope::Expr).for_each(
         |(trigger, snippet)| {
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::{
         CompletionConfig, Snippet,
         tests::{TEST_CONFIG, check, check_edit, check_edit_with_config},
     };
-
     #[test]
     fn postfix_completion_works_for_trivial_path_expression() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn postfix_completion_works_for_function_calln() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn postfix_type_filtering() {
         check(
             "#]],
         )
     }
-
     #[test]
     fn let_middle_block() {
         check(
             "#]],
         );
     }
-
     #[test]
     fn option_iflet() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn option_iflet_cond() {
         check(
 "#,
         );
     }
-
     #[test]
     fn option_letelse() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn result_match() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_works_for_ambiguous_float_literal() {
         check_edit("refm", r#"fn main() { 42.$0 }"#, r#"fn main() { &mut 42 }"#)
     }
-
     #[test]
     fn works_in_simple_macro() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_for_references() {
         check_edit("dbg", r#"fn main() { &&42.$0 }"#, r#"fn main() { dbg!(&&42) }"#);
 "#,
         )
     }
-
     #[test]
     fn postfix_completion_for_unsafe() {
         postfix_completion_for_block("unsafe");
     }
-
     #[test]
     fn postfix_completion_for_const() {
         postfix_completion_for_block("const");
     }
-
     fn postfix_completion_for_block(kind: &str) {
         check_edit(kind, r#"fn main() { foo.$0 }"#, &format!("fn main() {{ {kind} {{ foo }} }}"));
         check_edit(
             r#"fn main() { let x = if true {1} else {2}.$0 }"#,
             &format!("fn main() {{ let x = {kind} {{ if true {{1}} else {{2}} }} }}"),
         );
-
         if kind == "const" {
             check_edit(
                 kind,
                 &format!("fn main() {{ {kind} {{ const {{1}} }} }}"),
             );
         }
-
         // completion will not be triggered
         check_edit(
             kind,
             &format!("fn main() {{ let x = true else {{panic!()}}.{kind} $0}}"),
         );
     }
-
     #[test]
     fn custom_postfix_completion() {
         let config = CompletionConfig {
             ],
             ..TEST_CONFIG
         };
-
         check_edit_with_config(
             config.clone(),
             "break",
 fn main() { ControlFlow::Break(42) }
 "#,
         );
-
         // The receiver texts should be escaped, see comments in `get_receiver_text()`
         // for detail.
         //
 fn main() { ControlFlow::Break('\\\\') }
 "#,
         );
-
         check_edit_with_config(
             config,
             "break",
 "#,
         );
     }
-
     #[test]
     fn postfix_completion_for_format_like_strings() {
         check_edit(
             r#"fn main() { log::error!("{}", 2+2) }"#,
         );
     }
-
     #[test]
     fn postfix_custom_snippets_completion_for_references() {
         // https://github.com/rust-lang/rust-analyzer/issues/7929
-
         let snippet = Snippet::new(
             &[],
             &["ok".into()],
             crate::SnippetScope::Expr,
         )
         .unwrap();
-
         check_edit_with_config(
             CompletionConfig { snippets: vec![snippet.clone()], ..TEST_CONFIG },
             "ok",
             r#"fn main() { &&42.o$0 }"#,
             r#"fn main() { Ok(&&42) }"#,
         );
-
         check_edit_with_config(
             CompletionConfig { snippets: vec![snippet.clone()], ..TEST_CONFIG },
             "ok",
             r#"fn main() { &&42.$0 }"#,
             r#"fn main() { Ok(&&42) }"#,
         );
-
         check_edit_with_config(
             CompletionConfig { snippets: vec![snippet], ..TEST_CONFIG },
             "ok",
             "#,
         );
     }
-
     #[test]
     fn no_postfix_completions_in_if_block_that_has_an_else() {
         check(
             expect![[r#""#]],
         );
     }
-
     #[test]
     fn mut_ref_consuming() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn deref_consuming() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn inside_macro() {
         check_edit(