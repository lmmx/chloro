COMPARISON DIFF
============================================================

Original size: 11037 bytes
Chloro size:   10961 bytes
Rustfmt size:  11348 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Complete fields in record literals and patterns.
+
 use ide_db::SymbolKind;
 use syntax::{
-    ast::{self, Expr},
     SmolStr,
+    ast::{self, Expr},
 };
 
 use crate::{
-    context::{DotAccess, DotAccessExprCtx, DotAccessKind, PatternContext},
     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,
     CompletionRelevancePostfixMatch, Completions,
+    context::{DotAccess, DotAccessExprCtx, DotAccessKind, PatternContext},
 };
-
-pub(crate) fn complete_record_pattern_fields(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    pattern_ctx: &PatternContext,
-) {
-    if let PatternContext {
-        record_pat: Some(record_pat),
-        ..
-    } = pattern_ctx
-    {
-        let ty = ctx
-            .sema
-            .type_of_pat(&ast::Pat::RecordPat(record_pat.clone()));
+pub(crate) fn complete_record_pattern_fields(acc: &mut Completions, ctx: &CompletionContext<'_>, pattern_ctx: &PatternContext) {
+    if let PatternContext { record_pat: Some(record_pat), .. } = pattern_ctx {
+        let ty = ctx.sema.type_of_pat(&ast::Pat::RecordPat(record_pat.clone()));
         let missing_fields = match ty.as_ref().and_then(|t| t.original.as_adt()) {
             Some(hir::Adt::Union(un)) => {
                 // ctx.sema.record_pat_missing_fields will always return
                 // an empty Vec on a union literal. This is normally
                 // reasonable, but here we'd like to present the full list
                 // of fields if the literal is empty.
-                let were_fields_specified = record_pat
-                    .record_pat_field_list()
-                    .and_then(|fl| fl.fields().next())
-                    .is_some();
+                let were_fields_specified =
+                    record_pat.record_pat_field_list().and_then(|fl| fl.fields().next()).is_some();
 
                 match were_fields_specified {
                     false => un
     }
 }
 
-pub(crate) fn complete_record_expr_fields(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    record_expr: &ast::RecordExpr,
-    &dot_prefix: &bool,
-) {
-    let ty = ctx
-        .sema
-        .type_of_expr(&Expr::RecordExpr(record_expr.clone()));
-
+pub(crate) fn complete_record_expr_fields(acc: &mut Completions, ctx: &CompletionContext<'_>, record_expr: &ast::RecordExpr, &dot_prefix: &bool) {
+    let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));
     let missing_fields = match ty.as_ref().and_then(|t| t.original.as_adt()) {
         Some(hir::Adt::Union(un)) => {
             // ctx.sema.record_literal_missing_fields will always return
             // an empty Vec on a union literal. This is normally
             // reasonable, but here we'd like to present the full list
             // of fields if the literal is empty.
-            let were_fields_specified = record_expr
-                .record_expr_field_list()
-                .and_then(|fl| fl.fields().next())
-                .is_some();
+            let were_fields_specified =
+                record_expr.record_expr_field_list().and_then(|fl| fl.fields().next()).is_some();
 
             match were_fields_specified {
                 false => un
     complete_fields(acc, ctx, missing_fields);
 }
 
-pub(crate) fn add_default_update(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    ty: Option<hir::TypeInfo<'_>>,
-) {
+pub(crate) fn add_default_update(acc: &mut Completions, ctx: &CompletionContext<'_>, ty: Option<hir::TypeInfo<'_>>) {
     let default_trait = ctx.famous_defs().core_default_Default();
     let impls_default_trait = default_trait
         .zip(ty.as_ref())
             SmolStr::new_static(completion_text),
             ctx.edition,
         );
-        let completion_text = completion_text
-            .strip_prefix(ctx.token.text())
-            .unwrap_or(completion_text);
-        item.insert_text(completion_text)
-            .set_relevance(CompletionRelevance {
-                postfix_match: Some(CompletionRelevancePostfixMatch::Exact),
-                ..Default::default()
-            });
+        let completion_text =
+            completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);
+        item.insert_text(completion_text).set_relevance(CompletionRelevance {
+            postfix_match: Some(CompletionRelevancePostfixMatch::Exact),
+            ..Default::default()
+        });
         item.add_to(acc, ctx.db);
     }
 }
 
-fn complete_fields(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    missing_fields: Vec<(hir::Field, hir::Type<'_>)>,
-) {
+fn complete_fields(acc: &mut Completions, ctx: &CompletionContext<'_>, missing_fields: Vec<(hir::Field, hir::Type<'_>)>) {
     for (field, ty) in missing_fields {
         // This should call something else, we shouldn't be synthesizing a DotAccess here
         acc.add_field(
             &DotAccess {
                 receiver: None,
                 receiver_ty: None,
-                kind: DotAccessKind::Field {
-                    receiver_is_ambiguous_float_literal: false,
-                },
-                ctx: DotAccessExprCtx {
-                    in_block_expr: false,
-                    in_breakable: None,
-                },
+                kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal: false },
+                ctx: DotAccessExprCtx { in_block_expr: false, in_breakable: None },
             },
             None,
             field,
 #[cfg(test)]
 mod tests {
     use ide_db::SnippetCap;
-
     use crate::{
-        tests::{check_edit, check_edit_with_config, TEST_CONFIG},
         CompletionConfig,
+        tests::{TEST_CONFIG, check_edit, check_edit_with_config},
     };
-
     #[test]
     fn literal_struct_completion_edit() {
         check_edit(
             "#,
         )
     }
-
     #[test]
     fn literal_struct_completion_shorthand() {
         check_edit(
             "#,
         )
     }
-
     #[test]
     fn enum_variant_no_snippets() {
-        let conf = CompletionConfig {
-            snippet_cap: SnippetCap::new(false),
-            ..TEST_CONFIG
-        };
+        let conf = CompletionConfig { snippet_cap: SnippetCap::new(false), ..TEST_CONFIG };
         // tuple variant
         check_edit_with_config(
             conf.clone(),
 }
 "#,
         );
-
         // record variant
         check_edit_with_config(
             conf,
 "#,
         )
     }
-
     #[test]
     fn literal_struct_impl_self_completion() {
         check_edit(
 }
             "#,
         );
-
         check_edit(
             "Self()",
             r#"
             "#,
         )
     }
-
     #[test]
     fn literal_struct_completion_from_sub_modules() {
         check_edit(
             "#,
         )
     }
-
     #[test]
     fn literal_struct_complexion_module() {
         check_edit(
             "#,
         );
     }
-
     #[test]
     fn default_completion_edit() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn callable_field_struct_init() {
         check_edit(