COMPARISON DIFF
============================================================

Original size: 3259 bytes
Chloro size:   3240 bytes
Rustfmt size:  3430 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Pretty printing of macros output.
 
 use base_db::Crate;
 use rustc_hash::FxHashMap;
 use syntax::NodeOrToken;
-use syntax::{ast::make, SyntaxNode};
+use syntax::{SyntaxNode, ast::make};
 
 use crate::{db::ExpandDatabase, span_map::ExpansionSpanMap};
 
 /// Inserts whitespace and replaces `$crate` in macro expansions.
 #[expect(deprecated)]
-pub fn prettify_macro_expansion(
-    db: &dyn ExpandDatabase,
-    syn: SyntaxNode,
-    span_map: &ExpansionSpanMap,
-    target_crate_id: Crate,
-) -> SyntaxNode {
+pub fn prettify_macro_expansion(db: &dyn ExpandDatabase, syn: SyntaxNode, span_map: &ExpansionSpanMap, target_crate_id: Crate) -> SyntaxNode {
     // Because `syntax_bridge::prettify_macro_expansion::prettify_macro_expansion()` clones subtree for `syn`,
     // that means it will be offsetted to the beginning.
     let span_offset = syn.text_range().start();
     syntax_bridge::prettify_macro_expansion::prettify_macro_expansion(
         syn,
         &mut |dollar_crate| {
-            let ctx = span_map
-                .span_at(dollar_crate.text_range().start() + span_offset)
-                .ctx;
-            let replacement = syntax_ctx_id_to_dollar_crate_replacement
-                .entry(ctx)
-                .or_insert_with(|| {
+            let ctx = span_map.span_at(dollar_crate.text_range().start() + span_offset).ctx;
+            let replacement =
+                syntax_ctx_id_to_dollar_crate_replacement.entry(ctx).or_insert_with(|| {
                     let macro_call_id = ctx
                         .outer_expn(db)
                         .expect("`$crate` cannot come from `SyntaxContextId::ROOT`");
                     // Lastly, if nothing else found, resort to leaving `$crate`.
                     if target_crate_id == macro_def_crate {
                         make::tokens::crate_kw()
-                    } else if let Some(dep) = target_crate
-                        .dependencies
-                        .iter()
-                        .find(|dep| dep.crate_id == macro_def_crate)
+                    } else if let Some(dep) =
+                        target_crate.dependencies.iter().find(|dep| dep.crate_id == macro_def_crate)
                     {
                         make::tokens::ident(dep.name.as_str())
                     } else if let Some(crate_name) = &macro_def_crate.extra_data(db).display_name {
                 return None;
             }
             // We need to `clone_subtree()` but rowan doesn't provide such operation for tokens.
-            let parent = replacement
-                .parent()
-                .unwrap()
-                .clone_subtree()
-                .clone_for_update();
+            let parent = replacement.parent().unwrap().clone_subtree().clone_for_update();
             parent
                 .children_with_tokens()
                 .filter_map(NodeOrToken::into_token)