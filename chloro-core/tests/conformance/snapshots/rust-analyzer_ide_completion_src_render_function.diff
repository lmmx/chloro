COMPARISON DIFF
============================================================

Original size: 21606 bytes
Chloro size:   21429 bytes
Rustfmt size:  21606 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
         RenderContext, compute_exact_name_match, compute_ref_match, compute_type_match, match_types,
     },
 };
-
 #[derive(Debug)]
 enum FuncKind<'ctx> {
     Function(&'ctx PathCompletionCtx<'ctx>),
     Method(&'ctx DotAccess<'ctx>, Option<SmolStr>),
 }
 
-pub(crate) fn render_fn(
-    ctx: RenderContext<'_>,
-    path_ctx: &PathCompletionCtx<'_>,
-    local_name: Option<hir::Name>,
-    func: hir::Function,
-) -> Builder {
+pub(crate) fn render_fn(ctx: RenderContext<'_>, path_ctx: &PathCompletionCtx<'_>, local_name: Option<hir::Name>, func: hir::Function) -> Builder {
     let _p = tracing::info_span!("render_fn").entered();
     render(ctx, local_name, func, FuncKind::Function(path_ctx))
 }
 
-pub(crate) fn render_method(
-    ctx: RenderContext<'_>,
-    dot_access: &DotAccess<'_>,
-    receiver: Option<SmolStr>,
-    local_name: Option<hir::Name>,
-    func: hir::Function,
-) -> Builder {
+pub(crate) fn render_method(ctx: RenderContext<'_>, dot_access: &DotAccess<'_>, receiver: Option<SmolStr>, local_name: Option<hir::Name>, func: hir::Function) -> Builder {
     let _p = tracing::info_span!("render_method").entered();
     render(ctx, local_name, func, FuncKind::Method(dot_access, receiver))
 }
 
-fn render(
-    ctx @ RenderContext { completion, .. }: RenderContext<'_>,
-    local_name: Option<hir::Name>,
-    func: hir::Function,
-    func_kind: FuncKind<'_>,
-) -> Builder {
+fn render(ctx @ RenderContext { completion, .. }: RenderContext<'_>, local_name: Option<hir::Name>, func: hir::Function, func_kind: FuncKind<'_>) -> Builder {
     let db = completion.db;
-
     let name = local_name.unwrap_or_else(|| func.name(db));
-
     let (call, escaped_call) = match &func_kind {
         FuncKind::Method(_, Some(receiver)) => (
             format_smolstr!("{}.{}", receiver, name.as_str()),
         call.clone(),
         completion.edition,
     );
-
     let ret_type = func.ret_type(db);
     let assoc_item = func.as_assoc_item(db);
-
     let trait_info =
         assoc_item.and_then(|trait_| trait_.container_or_implemented_trait(db)).map(|trait_| {
             CompletionRelevanceTraitInfo {
                 is_op_method: completion.is_ops_trait(trait_),
             }
         });
-
     let (has_dot_receiver, has_call_parens, cap) = match func_kind {
         FuncKind::Function(&PathCompletionCtx {
             kind: PathKind::Expr { .. },
     let complete_call_parens = cap
         .filter(|_| !has_call_parens)
         .and_then(|cap| Some((cap, params(ctx.completion, func, &func_kind, has_dot_receiver)?)));
-
     let function = assoc_item
         .and_then(|assoc_item| assoc_item.implementing_ty(db))
         .map(|self_type| compute_return_type_match(db, &ctx, self_type, &ret_type))
             has_self_param,
             return_type,
         });
-
     item.set_relevance(CompletionRelevance {
         type_match: if has_call_parens || complete_call_parens.is_some() {
             compute_type_match(completion, &ret_type)
         is_skipping_completion: matches!(func_kind, FuncKind::Method(_, Some(_))),
         ..ctx.completion_relevance()
     });
-
     match func_kind {
         FuncKind::Function(path_ctx) => {
             super::path_ref_match(completion, path_ctx, &ret_type, &mut item);
         }
         _ => (),
     }
-
     let detail = if ctx.completion.config.full_function_signatures {
         detail_full(ctx.completion, func)
     } else {
         .set_deprecated(ctx.is_deprecated(func) || ctx.is_deprecated_assoc_item(func))
         .detail(detail)
         .lookup_by(name.as_str().to_smolstr());
-
     if let Some((cap, (self_param, params))) = complete_call_parens {
         add_call_parens(
             &mut item,
             &ret_type,
         );
     }
-
     match ctx.import_to_add {
         Some(import_to_add) => {
             item.add_import(import_to_add);
             }
         }
     }
-
     item.doc_aliases(ctx.doc_aliases);
     item
 }
 
-fn compute_return_type_match(
-    db: &dyn HirDatabase,
-    ctx: &RenderContext<'_>,
-    self_type: hir::Type<'_>,
-    ret_type: &hir::Type<'_>,
-) -> CompletionRelevanceReturnType {
+fn compute_return_type_match(db: &dyn HirDatabase, ctx: &RenderContext<'_>, self_type: hir::Type<'_>, ret_type: &hir::Type<'_>) -> CompletionRelevanceReturnType {
     if match_types(ctx.completion, &self_type, ret_type).is_some() {
         // fn([..]) -> Self
         CompletionRelevanceReturnType::DirectConstructor
     }
 }
 
-pub(super) fn add_call_parens<'b>(
-    builder: &'b mut Builder,
-    ctx: &CompletionContext<'_>,
-    cap: SnippetCap,
-    name: SmolStr,
-    escaped_name: SmolStr,
-    self_param: Option<hir::SelfParam>,
-    params: Vec<hir::Param<'_>>,
-    ret_type: &hir::Type<'_>,
-) -> &'b mut Builder {
+pub(super) fn add_call_parens<'b>(builder: &'b mut Builder, ctx: &CompletionContext<'_>, cap: SnippetCap, name: SmolStr, escaped_name: SmolStr, self_param: Option<hir::SelfParam>, params: Vec<hir::Param<'_>>, ret_type: &hir::Type<'_>) -> &'b mut Builder {
     cov_mark::hit!(inserts_parens_for_function_calls);
-
     let (mut snippet, label_suffix) = if self_param.is_none() && params.is_empty() {
         (format!("{escaped_name}()$0"), "()")
     } else {
 fn detail(ctx: &CompletionContext<'_>, func: hir::Function) -> String {
     let mut ret_ty = func.ret_type(ctx.db);
     let mut detail = String::new();
-
     if func.is_const(ctx.db) {
         format_to!(detail, "const ");
     }
     if func.is_unsafe_to_call(ctx.db, ctx.containing_function, ctx.edition) {
         format_to!(detail, "unsafe ");
     }
-
     detail.push_str("fn(");
     params_display(ctx, &mut detail, func);
     detail.push(')');
 fn detail_full(ctx: &CompletionContext<'_>, func: hir::Function) -> String {
     let signature = format!("{}", func.display(ctx.db, ctx.display_target));
     let mut detail = String::with_capacity(signature.len());
-
     for segment in signature.split_whitespace() {
         if !detail.is_empty() {
             detail.push(' ');
 
         detail.push_str(segment);
     }
-
     detail
 }
 
             assoc_fn_params.iter().map(|p| p.ty().display(ctx.db, ctx.display_target)).format(", ")
         );
     }
-
     if func.is_varargs(ctx.db) {
         detail.push_str(", ...");
     }
 }
 
-fn params<'db>(
-    ctx: &CompletionContext<'db>,
-    func: hir::Function,
-    func_kind: &FuncKind<'_>,
-    has_dot_receiver: bool,
-) -> Option<(Option<hir::SelfParam>, Vec<hir::Param<'db>>)> {
+fn params<'db>(ctx: &CompletionContext<'db>, func: hir::Function, func_kind: &FuncKind<'_>, has_dot_receiver: bool) -> Option<(Option<hir::SelfParam>, Vec<hir::Param<'db>>)> {
     ctx.config.callable.as_ref()?;
-
     // Don't add parentheses if the expected type is a function reference with the same signature.
     if let Some(expected) = ctx.expected_type.as_ref().filter(|e| e.is_fn())
         && let Some(expected) = expected.as_callable(ctx.db)
         cov_mark::hit!(no_call_parens_if_fn_ptr_needed);
         return None;
     }
-
     let self_param = if has_dot_receiver || matches!(func_kind, FuncKind::Method(_, Some(_))) {
         None
     } else {
         CallableSnippets, CompletionConfig,
         tests::{TEST_CONFIG, check_edit, check_edit_with_config},
     };
-
     #[test]
     fn inserts_parens_for_function_calls() {
         cov_mark::check!(inserts_parens_for_function_calls);
 fn main() { no_args();$0 }
 "#,
         );
-
         check_edit(
             "with_args",
             r#"
 fn main() { with_args(${1:x}, ${2:y});$0 }
 "#,
         );
-
         check_edit(
             "foo",
             r#"
 fn bar(s: &S) { s.foo()$0 }
 "#,
         );
-
         check_edit(
             "foo",
             r#"
 }
 "#,
         );
-
         check_edit(
             "foo",
             r#"
 "#,
         );
     }
-
     #[test]
     fn parens_for_method_call_as_assoc_fn() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn suppress_arg_snippets() {
         cov_mark::check!(suppress_arg_snippets);
 "#,
         );
     }
-
     #[test]
     fn strips_underscores_from_args() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_ref_when_matching_local_in_scope() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_mut_ref_when_matching_local_in_scope() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn insert_ref_when_matching_local_in_scope_for_method() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn trim_mut_keyword_in_func_completion() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_pattern_args_with_type_name_if_adt() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn complete_fn_param() {
         // has mut kw
 fn g(foo: (), mut bar: u32)
 "#,
         );
-
         // has type param
         check_edit(
             "mut bar: u32",
 "#,
         );
     }
-
     #[test]
     fn complete_fn_mut_param_add_comma() {
         // add leading and trailing comma
 "#,
         );
     }
-
     #[test]
     fn complete_fn_mut_param_has_attribute() {
         check_edit(
 fn g(foo: (), #[baz = "qux"] mut bar: u32)
 "#,
         );
-
         check_edit(
             r#"#[baz = "qux"] mut bar: u32"#,
             r#"
 fn g(foo: (), #[baz = "qux"] mut bar: u32)
 "#,
         );
-
         check_edit(
             r#", #[baz = "qux"] mut bar: u32"#,
             r#"
 "#,
         );
     }
-
     #[test]
     fn complete_semicolon_for_unit() {
         cov_mark::check!(complete_semicolon);
 "#,
         );
     }
-
     #[test]
     fn complete_comma_for_unit_match_arm() {
         cov_mark::check!(complete_semicolon);
 "#,
         );
     }
-
     #[test]
     fn no_semicolon_in_closure_ret() {
         check_edit(