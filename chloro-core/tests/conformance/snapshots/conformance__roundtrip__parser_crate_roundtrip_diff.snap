---
source: chloro-core/tests/conformance/roundtrip.rs
expression: cleaned_diff
---
+//! Adapted from a `rustc` test, which can be found at
+//! https://github.com/rust-lang/rust/blob/6d34ec18c7d7e574553f6347ecf08e1e1c45c13d/src/test/run-pass/weird-exprs.rs.
+//!
+//! Reported to rust-analyzer in https://github.com/rust-lang/rust-analyzer/issues/290
+//! docs
+//! See [`Input`].
+//! The Rust parser.
+//!
+//! NOTE: The crate is undergoing refactors, don't believe everything the docs
+//! say :-)
+//!
+//! The parser doesn't know about concrete representation of tokens and syntax
+//! trees. Abstract [`TokenSource`] and [`TreeSink`] traits are used instead. As
+//! a consequence, this crate does not contain a lexer.
+//!
+//! The [`Parser`] struct from the [`parser`] module is a cursor into the
+//! sequence of tokens.  Parsing routines use [`Parser`] to inspect current
+//! state and advance the parsing.
+//!
+//! The actual parsing happens in the [`grammar`] module.
+//!
+//! Tests for this crate live in the `syntax` crate.
+//!
+//! [`Parser`]: crate::parser::Parser
+//! This module provides a way to construct a `File`.
+//! It is intended to be completely decoupled from the
+//! parser, so as to allow to evolve the tree representation
+//! and the parser algorithm independently.
+//! This is the actual "grammar" of the Rust language.
+//!
+//! Each function in this module and its children corresponds
+//! to a production of the formal grammar. Submodules roughly
+//! correspond to different *areas* of the grammar. By convention,
+//! each submodule starts with `use super::*` import and exports
+//! "public" productions via `pub(super)`.
+//!
+//! See docs for [`Parser`](super::parser::Parser) to learn about API,
+//! available to the grammar, and see docs for [`Event`](super::event::Event)
+//! to learn how this actually manages to produce parse trees.
+//!
+//! Code in this module also contains inline tests, which start with
+//! `// test name-of-the-test` comment and look like this:
+//!
+//! ```text
+//! // test function_with_zero_parameters
+//! // fn foo() {}
+//! ```
+//!
+//! After adding a new inline-test, run `cargo test -p xtask` to
+//! extract it as a standalone text-fixture into
+//! `crates/syntax/test_data/parser/`, and run `cargo test` once to
+//! create the "gold" value.
+//!
+//! Coding convention: rules like `where_clause` always produce either a
+//! node or an error, rules like `opt_where_clause` may produce nothing.
+//! Non-opt rules typically start with `assert!(p.at(FIRST_TOKEN))`, the
+//! caller is responsible for branching on the first token.
+//! See [`Parser`].
+//! See [`Output`]
+//! Defines [`SyntaxKind`] -- a fieldless enum of all possible syntactic
+//! constructs of the Rust language.
+//! A bit-set of `SyntaxKind`s.
+//! Shortcuts that span lexer/parser abstraction.
+//!
+//! The way Rust works, parser doesn't necessary parse text, and you might
+//! tokenize text without parsing it further. So, it makes sense to keep
+//! abstract token parsing, and string tokenization as completely separate
+//! layers.
+//!
+//! However, often you do parse text into syntax trees and the glue code for
+//! that needs to live somewhere. Rather than putting it to lexer or parser, we
+//! use a separate shortcuts module for that.
+//! Generated by `cargo xtask codegen grammar`, do not edit by hand.
+
 mod ok {
     use crate::tests::*;
     #[test]
         run_and_expect_no_errors("test_data/parser/inline/ok/arb_self_types.rs");
     }
     #[test]
-    fn arg_with_attr() { run_and_expect_no_errors("test_data/parser/inline/ok/arg_with_attr.rs"); }
+    fn arg_with_attr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/arg_with_attr.rs");
+    }
     #[test]
-    fn array_attrs() { run_and_expect_no_errors("test_data/parser/inline/ok/array_attrs.rs"); }
+    fn array_attrs() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/array_attrs.rs");
+    }
     #[test]
-    fn array_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/array_expr.rs"); }
+    fn array_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/array_expr.rs");
+    }
     #[test]
-    fn array_type() { run_and_expect_no_errors("test_data/parser/inline/ok/array_type.rs"); }
+    fn array_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/array_type.rs");
+    }
     #[test]
-    fn as_precedence() { run_and_expect_no_errors("test_data/parser/inline/ok/as_precedence.rs"); }
+    fn as_precedence() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/as_precedence.rs");
+    }
     #[test]
-    fn asm_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/asm_expr.rs"); }
+    fn asm_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/asm_expr.rs");
+    }
     #[test]
-    fn asm_kinds() { run_and_expect_no_errors("test_data/parser/inline/ok/asm_kinds.rs"); }
+    fn asm_kinds() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/asm_kinds.rs");
+    }
     #[test]
-    fn asm_label() { run_and_expect_no_errors("test_data/parser/inline/ok/asm_label.rs"); }
+    fn asm_label() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/asm_label.rs");
+    }
     #[test]
     fn assoc_const_eq() {
         run_and_expect_no_errors("test_data/parser/inline/ok/assoc_const_eq.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/assoc_type_bound.rs");
     }
     #[test]
-    fn assoc_type_eq() { run_and_expect_no_errors("test_data/parser/inline/ok/assoc_type_eq.rs"); }
+    fn assoc_type_eq() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/assoc_type_eq.rs");
+    }
     #[test]
     fn async_trait_bound() {
         run_and_expect_no_errors("test_data/parser/inline/ok/async_trait_bound.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/attr_on_expr_stmt.rs");
     }
     #[test]
-    fn await_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/await_expr.rs"); }
+    fn await_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/await_expr.rs");
+    }
     #[test]
     fn bare_dyn_types_with_leading_lifetime() {
         run_and_expect_no_errors(
         );
     }
     #[test]
-    fn become_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/become_expr.rs"); }
+    fn become_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/become_expr.rs");
+    }
     #[test]
-    fn bind_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/bind_pat.rs"); }
+    fn bind_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/bind_pat.rs");
+    }
     #[test]
     fn binop_resets_statementness() {
         run_and_expect_no_errors("test_data/parser/inline/ok/binop_resets_statementness.rs");
     }
     #[test]
-    fn block() { run_and_expect_no_errors("test_data/parser/inline/ok/block.rs"); }
+    fn block() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/block.rs");
+    }
     #[test]
-    fn block_items() { run_and_expect_no_errors("test_data/parser/inline/ok/block_items.rs"); }
+    fn block_items() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/block_items.rs");
+    }
     #[test]
-    fn box_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/box_pat.rs"); }
+    fn box_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/box_pat.rs");
+    }
     #[test]
     fn break_ambiguity() {
         run_and_expect_no_errors("test_data/parser/inline/ok/break_ambiguity.rs");
     }
     #[test]
-    fn break_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/break_expr.rs"); }
+    fn break_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/break_expr.rs");
+    }
     #[test]
-    fn builtin_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/builtin_expr.rs"); }
+    fn builtin_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/builtin_expr.rs");
+    }
     #[test]
-    fn call_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/call_expr.rs"); }
+    fn call_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/call_expr.rs");
+    }
     #[test]
-    fn cast_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/cast_expr.rs"); }
+    fn cast_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/cast_expr.rs");
+    }
     #[test]
     fn closure_binder() {
         run_and_expect_no_errors("test_data/parser/inline/ok/closure_binder.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/closure_range_method_call.rs");
     }
     #[test]
-    fn const_arg() { run_and_expect_no_errors("test_data/parser/inline/ok/const_arg.rs"); }
+    fn const_arg() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/const_arg.rs");
+    }
     #[test]
     fn const_arg_block() {
         run_and_expect_no_errors("test_data/parser/inline/ok/const_arg_block.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/const_block_pat.rs");
     }
     #[test]
-    fn const_closure() { run_and_expect_no_errors("test_data/parser/inline/ok/const_closure.rs"); }
+    fn const_closure() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/const_closure.rs");
+    }
     #[test]
-    fn const_item() { run_and_expect_no_errors("test_data/parser/inline/ok/const_item.rs"); }
+    fn const_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/const_item.rs");
+    }
     #[test]
-    fn const_param() { run_and_expect_no_errors("test_data/parser/inline/ok/const_param.rs"); }
+    fn const_param() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/const_param.rs");
+    }
     #[test]
     fn const_param_default_expression() {
         run_and_expect_no_errors("test_data/parser/inline/ok/const_param_default_expression.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/const_where_clause.rs");
     }
     #[test]
-    fn continue_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/continue_expr.rs"); }
+    fn continue_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/continue_expr.rs");
+    }
     #[test]
-    fn crate_path() { run_and_expect_no_errors("test_data/parser/inline/ok/crate_path.rs"); }
+    fn crate_path() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/crate_path.rs");
+    }
     #[test]
     fn crate_visibility() {
         run_and_expect_no_errors("test_data/parser/inline/ok/crate_visibility.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/default_async_unsafe_fn.rs");
     }
     #[test]
-    fn default_item() { run_and_expect_no_errors("test_data/parser/inline/ok/default_item.rs"); }
+    fn default_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/default_item.rs");
+    }
     #[test]
     fn default_unsafe_item() {
         run_and_expect_no_errors("test_data/parser/inline/ok/default_unsafe_item.rs");
         );
     }
     #[test]
-    fn dot_dot_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/dot_dot_pat.rs"); }
+    fn dot_dot_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/dot_dot_pat.rs");
+    }
     #[test]
     fn dyn_trait_type() {
         run_and_expect_no_errors("test_data/parser/inline/ok/dyn_trait_type.rs");
         );
     }
     #[test]
-    fn effect_blocks() { run_and_expect_no_errors("test_data/parser/inline/ok/effect_blocks.rs"); }
+    fn effect_blocks() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/effect_blocks.rs");
+    }
     #[test]
     fn exclusive_range_pat() {
         run_and_expect_no_errors("test_data/parser/inline/ok/exclusive_range_pat.rs");
     }
     #[test]
-    fn expr_literals() { run_and_expect_no_errors("test_data/parser/inline/ok/expr_literals.rs"); }
+    fn expr_literals() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/expr_literals.rs");
+    }
     #[test]
     fn expression_after_block() {
         run_and_expect_no_errors("test_data/parser/inline/ok/expression_after_block.rs");
     }
     #[test]
-    fn extern_block() { run_and_expect_no_errors("test_data/parser/inline/ok/extern_block.rs"); }
+    fn extern_block() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/extern_block.rs");
+    }
     #[test]
-    fn extern_crate() { run_and_expect_no_errors("test_data/parser/inline/ok/extern_crate.rs"); }
+    fn extern_crate() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/extern_crate.rs");
+    }
     #[test]
     fn extern_crate_rename() {
         run_and_expect_no_errors("test_data/parser/inline/ok/extern_crate_rename.rs");
     }
     #[test]
-    fn field_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/field_expr.rs"); }
+    fn field_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/field_expr.rs");
+    }
     #[test]
-    fn fn_() { run_and_expect_no_errors("test_data/parser/inline/ok/fn_.rs"); }
+    fn fn_() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/fn_.rs");
+    }
     #[test]
-    fn fn_decl() { run_and_expect_no_errors("test_data/parser/inline/ok/fn_decl.rs"); }
+    fn fn_decl() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/fn_decl.rs");
+    }
     #[test]
-    fn fn_def_param() { run_and_expect_no_errors("test_data/parser/inline/ok/fn_def_param.rs"); }
+    fn fn_def_param() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/fn_def_param.rs");
+    }
     #[test]
     fn fn_pointer_param_ident_path() {
         run_and_expect_no_errors("test_data/parser/inline/ok/fn_pointer_param_ident_path.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/for_binder_bound.rs");
     }
     #[test]
-    fn for_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/for_expr.rs"); }
+    fn for_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/for_expr.rs");
+    }
     #[test]
     fn for_range_from() {
         run_and_expect_no_errors("test_data/parser/inline/ok/for_range_from.rs");
     }
     #[test]
-    fn for_type() { run_and_expect_no_errors("test_data/parser/inline/ok/for_type.rs"); }
+    fn for_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/for_type.rs");
+    }
     #[test]
-    fn frontmatter() { run_and_expect_no_errors("test_data/parser/inline/ok/frontmatter.rs"); }
+    fn frontmatter() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/frontmatter.rs");
+    }
     #[test]
     fn full_range_expr() {
         run_and_expect_no_errors("test_data/parser/inline/ok/full_range_expr.rs");
         );
     }
     #[test]
-    fn generic_arg() { run_and_expect_no_errors("test_data/parser/inline/ok/generic_arg.rs"); }
+    fn generic_arg() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/generic_arg.rs");
+    }
     #[test]
     fn generic_arg_bounds() {
         run_and_expect_no_errors("test_data/parser/inline/ok/generic_arg_bounds.rs");
     }
     #[test]
-    fn generic_const() { run_and_expect_no_errors("test_data/parser/inline/ok/generic_const.rs"); }
+    fn generic_const() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/generic_const.rs");
+    }
     #[test]
     fn generic_param_attribute() {
         run_and_expect_no_errors("test_data/parser/inline/ok/generic_param_attribute.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/generic_param_list.rs");
     }
     #[test]
-    fn global_asm() { run_and_expect_no_errors("test_data/parser/inline/ok/global_asm.rs"); }
+    fn global_asm() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/global_asm.rs");
+    }
     #[test]
     fn half_open_range_pat() {
         run_and_expect_no_errors("test_data/parser/inline/ok/half_open_range_pat.rs");
     }
     #[test]
-    fn if_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/if_expr.rs"); }
+    fn if_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/if_expr.rs");
+    }
     #[test]
-    fn impl_item() { run_and_expect_no_errors("test_data/parser/inline/ok/impl_item.rs"); }
+    fn impl_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/impl_item.rs");
+    }
     #[test]
     fn impl_item_const() {
         run_and_expect_no_errors("test_data/parser/inline/ok/impl_item_const.rs");
     }
     #[test]
-    fn impl_item_neg() { run_and_expect_no_errors("test_data/parser/inline/ok/impl_item_neg.rs"); }
+    fn impl_item_neg() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/impl_item_neg.rs");
+    }
     #[test]
     fn impl_item_never_type() {
         run_and_expect_no_errors("test_data/parser/inline/ok/impl_item_never_type.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/impl_type_params.rs");
     }
     #[test]
-    fn index_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/index_expr.rs"); }
+    fn index_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/index_expr.rs");
+    }
     #[test]
-    fn label() { run_and_expect_no_errors("test_data/parser/inline/ok/label.rs"); }
+    fn label() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/label.rs");
+    }
     #[test]
-    fn labeled_block() { run_and_expect_no_errors("test_data/parser/inline/ok/labeled_block.rs"); }
+    fn labeled_block() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/labeled_block.rs");
+    }
     #[test]
-    fn lambda_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/lambda_expr.rs"); }
+    fn lambda_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/lambda_expr.rs");
+    }
     #[test]
     fn lambda_ret_block() {
         run_and_expect_no_errors("test_data/parser/inline/ok/lambda_ret_block.rs");
     }
     #[test]
-    fn let_else() { run_and_expect_no_errors("test_data/parser/inline/ok/let_else.rs"); }
+    fn let_else() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/let_else.rs");
+    }
     #[test]
-    fn let_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/let_expr.rs"); }
+    fn let_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/let_expr.rs");
+    }
     #[test]
-    fn let_stmt() { run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt.rs"); }
+    fn let_stmt() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt.rs");
+    }
     #[test]
     fn let_stmt_ascription() {
         run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt_ascription.rs");
     }
     #[test]
-    fn let_stmt_init() { run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt_init.rs"); }
+    fn let_stmt_init() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt_init.rs");
+    }
     #[test]
-    fn lifetime_arg() { run_and_expect_no_errors("test_data/parser/inline/ok/lifetime_arg.rs"); }
+    fn lifetime_arg() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/lifetime_arg.rs");
+    }
     #[test]
     fn lifetime_param() {
         run_and_expect_no_errors("test_data/parser/inline/ok/lifetime_param.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/literal_pattern.rs");
     }
     #[test]
-    fn loop_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/loop_expr.rs"); }
+    fn loop_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/loop_expr.rs");
+    }
     #[test]
     fn macro_call_type() {
         run_and_expect_no_errors("test_data/parser/inline/ok/macro_call_type.rs");
     }
     #[test]
-    fn macro_def() { run_and_expect_no_errors("test_data/parser/inline/ok/macro_def.rs"); }
+    fn macro_def() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/macro_def.rs");
+    }
     #[test]
     fn macro_def_curly() {
         run_and_expect_no_errors("test_data/parser/inline/ok/macro_def_curly.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/macro_rules_non_brace.rs");
     }
     #[test]
-    fn marco_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/marco_pat.rs"); }
+    fn marco_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/marco_pat.rs");
+    }
     #[test]
-    fn match_arm() { run_and_expect_no_errors("test_data/parser/inline/ok/match_arm.rs"); }
+    fn match_arm() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/match_arm.rs");
+    }
     #[test]
     fn match_arms_commas() {
         run_and_expect_no_errors("test_data/parser/inline/ok/match_arms_commas.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/match_arms_outer_attributes.rs");
     }
     #[test]
-    fn match_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/match_expr.rs"); }
+    fn match_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/match_expr.rs");
+    }
     #[test]
-    fn match_guard() { run_and_expect_no_errors("test_data/parser/inline/ok/match_guard.rs"); }
+    fn match_guard() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/match_guard.rs");
+    }
     #[test]
     fn maybe_const_trait_bound() {
         run_and_expect_no_errors("test_data/parser/inline/ok/maybe_const_trait_bound.rs");
     }
     #[test]
-    fn metas() { run_and_expect_no_errors("test_data/parser/inline/ok/metas.rs"); }
+    fn metas() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/metas.rs");
+    }
     #[test]
     fn method_call_expr() {
         run_and_expect_no_errors("test_data/parser/inline/ok/method_call_expr.rs");
     }
     #[test]
-    fn mod_contents() { run_and_expect_no_errors("test_data/parser/inline/ok/mod_contents.rs"); }
+    fn mod_contents() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/mod_contents.rs");
+    }
     #[test]
-    fn mod_item() { run_and_expect_no_errors("test_data/parser/inline/ok/mod_item.rs"); }
+    fn mod_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/mod_item.rs");
+    }
     #[test]
     fn mod_item_curly() {
         run_and_expect_no_errors("test_data/parser/inline/ok/mod_item_curly.rs");
     }
     #[test]
-    fn never_type() { run_and_expect_no_errors("test_data/parser/inline/ok/never_type.rs"); }
+    fn never_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/never_type.rs");
+    }
     #[test]
     fn no_dyn_trait_leading_for() {
         run_and_expect_no_errors("test_data/parser/inline/ok/no_dyn_trait_leading_for.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/no_semi_after_block.rs");
     }
     #[test]
-    fn nocontentexpr() { run_and_expect_no_errors("test_data/parser/inline/ok/nocontentexpr.rs"); }
+    fn nocontentexpr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/nocontentexpr.rs");
+    }
     #[test]
     fn nocontentexpr_after_item() {
         run_and_expect_no_errors("test_data/parser/inline/ok/nocontentexpr_after_item.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/offset_of_parens.rs");
     }
     #[test]
-    fn or_pattern() { run_and_expect_no_errors("test_data/parser/inline/ok/or_pattern.rs"); }
+    fn or_pattern() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/or_pattern.rs");
+    }
     #[test]
-    fn param_list() { run_and_expect_no_errors("test_data/parser/inline/ok/param_list.rs"); }
+    fn param_list() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/param_list.rs");
+    }
     #[test]
     fn param_list_vararg() {
         run_and_expect_no_errors("test_data/parser/inline/ok/param_list_vararg.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/param_outer_arg.rs");
     }
     #[test]
-    fn paren_type() { run_and_expect_no_errors("test_data/parser/inline/ok/paren_type.rs"); }
+    fn paren_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/paren_type.rs");
+    }
     #[test]
-    fn path_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/path_expr.rs"); }
+    fn path_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/path_expr.rs");
+    }
     #[test]
     fn path_fn_trait_args() {
         run_and_expect_no_errors("test_data/parser/inline/ok/path_fn_trait_args.rs");
     }
     #[test]
-    fn path_part() { run_and_expect_no_errors("test_data/parser/inline/ok/path_part.rs"); }
+    fn path_part() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/path_part.rs");
+    }
     #[test]
-    fn path_type() { run_and_expect_no_errors("test_data/parser/inline/ok/path_type.rs"); }
+    fn path_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/path_type.rs");
+    }
     #[test]
     fn path_type_with_bounds() {
         run_and_expect_no_errors("test_data/parser/inline/ok/path_type_with_bounds.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/pointer_type_mut.rs");
     }
     #[test]
-    fn postfix_range() { run_and_expect_no_errors("test_data/parser/inline/ok/postfix_range.rs"); }
+    fn postfix_range() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/postfix_range.rs");
+    }
     #[test]
     fn precise_capturing() {
         run_and_expect_no_errors("test_data/parser/inline/ok/precise_capturing.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/pub_tuple_field.rs");
     }
     #[test]
-    fn qual_paths() { run_and_expect_no_errors("test_data/parser/inline/ok/qual_paths.rs"); }
+    fn qual_paths() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/qual_paths.rs");
+    }
     #[test]
     fn question_for_type_trait_bound() {
         run_and_expect_no_errors("test_data/parser/inline/ok/question_for_type_trait_bound.rs");
     }
     #[test]
-    fn range_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/range_pat.rs"); }
+    fn range_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/range_pat.rs");
+    }
     #[test]
     fn record_field_attrs() {
         run_and_expect_no_errors("test_data/parser/inline/ok/record_field_attrs.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/record_field_pat_leading_or.rs");
     }
     #[test]
-    fn record_lit() { run_and_expect_no_errors("test_data/parser/inline/ok/record_lit.rs"); }
+    fn record_lit() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/record_lit.rs");
+    }
     #[test]
     fn record_literal_field_with_attr() {
         run_and_expect_no_errors("test_data/parser/inline/ok/record_literal_field_with_attr.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/record_pat_field_list.rs");
     }
     #[test]
-    fn ref_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/ref_expr.rs"); }
+    fn ref_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/ref_expr.rs");
+    }
     #[test]
-    fn ref_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/ref_pat.rs"); }
+    fn ref_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/ref_pat.rs");
+    }
     #[test]
     fn reference_type() {
         run_and_expect_no_errors("test_data/parser/inline/ok/reference_type.rs");
     }
     #[test]
-    fn return_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/return_expr.rs"); }
+    fn return_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/return_expr.rs");
+    }
     #[test]
     fn return_type_syntax_in_path() {
         run_and_expect_no_errors("test_data/parser/inline/ok/return_type_syntax_in_path.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/safe_outside_of_extern.rs");
     }
     #[test]
-    fn self_param() { run_and_expect_no_errors("test_data/parser/inline/ok/self_param.rs"); }
+    fn self_param() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/self_param.rs");
+    }
     #[test]
     fn self_param_outer_attr() {
         run_and_expect_no_errors("test_data/parser/inline/ok/self_param_outer_attr.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/singleton_tuple_type.rs");
     }
     #[test]
-    fn slice_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/slice_pat.rs"); }
+    fn slice_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/slice_pat.rs");
+    }
     #[test]
-    fn slice_type() { run_and_expect_no_errors("test_data/parser/inline/ok/slice_type.rs"); }
+    fn slice_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/slice_type.rs");
+    }
     #[test]
     fn stmt_bin_expr_ambiguity() {
         run_and_expect_no_errors("test_data/parser/inline/ok/stmt_bin_expr_ambiguity.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/struct_initializer_with_defaults.rs");
     }
     #[test]
-    fn struct_item() { run_and_expect_no_errors("test_data/parser/inline/ok/struct_item.rs"); }
+    fn struct_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/struct_item.rs");
+    }
     #[test]
-    fn trait_alias() { run_and_expect_no_errors("test_data/parser/inline/ok/trait_alias.rs"); }
+    fn trait_alias() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/trait_alias.rs");
+    }
     #[test]
     fn trait_alias_where_clause() {
         run_and_expect_no_errors("test_data/parser/inline/ok/trait_alias_where_clause.rs");
     }
     #[test]
-    fn trait_item() { run_and_expect_no_errors("test_data/parser/inline/ok/trait_item.rs"); }
+    fn trait_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/trait_item.rs");
+    }
     #[test]
     fn trait_item_bounds() {
         run_and_expect_no_errors("test_data/parser/inline/ok/trait_item_bounds.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/try_block_expr.rs");
     }
     #[test]
-    fn try_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/try_expr.rs"); }
+    fn try_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/try_expr.rs");
+    }
     #[test]
     fn try_macro_fallback() {
         run_and_expect_no_errors_with_edition(
         );
     }
     #[test]
-    fn tuple_attrs() { run_and_expect_no_errors("test_data/parser/inline/ok/tuple_attrs.rs"); }
+    fn tuple_attrs() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/tuple_attrs.rs");
+    }
     #[test]
-    fn tuple_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/tuple_expr.rs"); }
+    fn tuple_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/tuple_expr.rs");
+    }
     #[test]
     fn tuple_field_attrs() {
         run_and_expect_no_errors("test_data/parser/inline/ok/tuple_field_attrs.rs");
     }
     #[test]
-    fn tuple_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/tuple_pat.rs"); }
+    fn tuple_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/tuple_pat.rs");
+    }
     #[test]
     fn tuple_pat_fields() {
         run_and_expect_no_errors("test_data/parser/inline/ok/tuple_pat_fields.rs");
     }
     #[test]
-    fn tuple_struct() { run_and_expect_no_errors("test_data/parser/inline/ok/tuple_struct.rs"); }
+    fn tuple_struct() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/tuple_struct.rs");
+    }
     #[test]
     fn tuple_struct_where() {
         run_and_expect_no_errors("test_data/parser/inline/ok/tuple_struct_where.rs");
     }
     #[test]
-    fn type_alias() { run_and_expect_no_errors("test_data/parser/inline/ok/type_alias.rs"); }
+    fn type_alias() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/type_alias.rs");
+    }
     #[test]
     fn type_item_type_params() {
         run_and_expect_no_errors("test_data/parser/inline/ok/type_item_type_params.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/type_item_where_clause_deprecated.rs");
     }
     #[test]
-    fn type_param() { run_and_expect_no_errors("test_data/parser/inline/ok/type_param.rs"); }
+    fn type_param() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/type_param.rs");
+    }
     #[test]
     fn type_param_bounds() {
         run_and_expect_no_errors("test_data/parser/inline/ok/type_param_bounds.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/typepathfn_with_coloncolon.rs");
     }
     #[test]
-    fn unary_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/unary_expr.rs"); }
+    fn unary_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/unary_expr.rs");
+    }
     #[test]
-    fn union_item() { run_and_expect_no_errors("test_data/parser/inline/ok/union_item.rs"); }
+    fn union_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/union_item.rs");
+    }
     #[test]
-    fn unit_struct() { run_and_expect_no_errors("test_data/parser/inline/ok/unit_struct.rs"); }
+    fn unit_struct() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/unit_struct.rs");
+    }
     #[test]
-    fn unit_type() { run_and_expect_no_errors("test_data/parser/inline/ok/unit_type.rs"); }
+    fn unit_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/unit_type.rs");
+    }
     #[test]
-    fn use_item() { run_and_expect_no_errors("test_data/parser/inline/ok/use_item.rs"); }
+    fn use_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_item.rs");
+    }
     #[test]
-    fn use_tree() { run_and_expect_no_errors("test_data/parser/inline/ok/use_tree.rs"); }
+    fn use_tree() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_tree.rs");
+    }
     #[test]
     fn use_tree_abs_star() {
         run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_abs_star.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_alias.rs");
     }
     #[test]
-    fn use_tree_list() { run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_list.rs"); }
+    fn use_tree_list() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_list.rs");
+    }
     #[test]
-    fn use_tree_path() { run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_path.rs"); }
+    fn use_tree_path() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_path.rs");
+    }
     #[test]
     fn use_tree_path_star() {
         run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_path_star.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_path_use_tree.rs");
     }
     #[test]
-    fn use_tree_star() { run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_star.rs"); }
+    fn use_tree_star() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_star.rs");
+    }
     #[test]
     fn variant_discriminant() {
         run_and_expect_no_errors("test_data/parser/inline/ok/variant_discriminant.rs");
     }
     #[test]
-    fn where_clause() { run_and_expect_no_errors("test_data/parser/inline/ok/where_clause.rs"); }
+    fn where_clause() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/where_clause.rs");
+    }
     #[test]
     fn where_pred_for() {
         run_and_expect_no_errors("test_data/parser/inline/ok/where_pred_for.rs");
     }
     #[test]
-    fn while_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/while_expr.rs"); }
+    fn while_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/while_expr.rs");
+    }
     #[test]
-    fn yeet_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/yeet_expr.rs"); }
+    fn yeet_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/yeet_expr.rs");
+    }
     #[test]
-    fn yield_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/yield_expr.rs"); }
+    fn yield_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/yield_expr.rs");
+    }
 }
 mod err {
     use crate::tests::*;
         run_and_expect_errors("test_data/parser/inline/err/async_without_semicolon.rs");
     }
     #[test]
-    fn bad_asm_expr() { run_and_expect_errors("test_data/parser/inline/err/bad_asm_expr.rs"); }
+    fn bad_asm_expr() {
+        run_and_expect_errors("test_data/parser/inline/err/bad_asm_expr.rs");
+    }
     #[test]
     fn closure_ret_recovery() {
         run_and_expect_errors("test_data/parser/inline/err/closure_ret_recovery.rs");
         run_and_expect_errors("test_data/parser/inline/err/empty_param_slot.rs");
     }
     #[test]
-    fn empty_segment() { run_and_expect_errors("test_data/parser/inline/err/empty_segment.rs"); }
+    fn empty_segment() {
+        run_and_expect_errors("test_data/parser/inline/err/empty_segment.rs");
+    }
     #[test]
     fn fn_pointer_type_missing_fn() {
         run_and_expect_errors("test_data/parser/inline/err/fn_pointer_type_missing_fn.rs");
         run_and_expect_errors("test_data/parser/inline/err/generic_param_list_recover.rs");
     }
     #[test]
-    fn generic_static() { run_and_expect_errors("test_data/parser/inline/err/generic_static.rs"); }
+    fn generic_static() {
+        run_and_expect_errors("test_data/parser/inline/err/generic_static.rs");
+    }
     #[test]
-    fn impl_type() { run_and_expect_errors("test_data/parser/inline/err/impl_type.rs"); }
+    fn impl_type() {
+        run_and_expect_errors("test_data/parser/inline/err/impl_type.rs");
+    }
     #[test]
     fn invalid_question_for_type_trait_bound() {
         run_and_expect_errors(
         run_and_expect_errors("test_data/parser/inline/err/match_arms_recovery.rs");
     }
     #[test]
-    fn meta_recovery() { run_and_expect_errors("test_data/parser/inline/err/meta_recovery.rs"); }
+    fn meta_recovery() {
+        run_and_expect_errors("test_data/parser/inline/err/meta_recovery.rs");
+    }
     #[test]
     fn method_call_missing_argument_list() {
         run_and_expect_errors("test_data/parser/inline/err/method_call_missing_argument_list.rs");
         run_and_expect_errors("test_data/parser/inline/err/precise_capturing_invalid.rs");
     }
     #[test]
-    fn pub_expr() { run_and_expect_errors("test_data/parser/inline/err/pub_expr.rs"); }
+    fn pub_expr() {
+        run_and_expect_errors("test_data/parser/inline/err/pub_expr.rs");
+    }
     #[test]
     fn record_literal_before_ellipsis_recovery() {
         run_and_expect_errors(
         run_and_expect_errors("test_data/parser/inline/err/struct_field_recover.rs");
     }
     #[test]
-    fn top_level_let() { run_and_expect_errors("test_data/parser/inline/err/top_level_let.rs"); }
+    fn top_level_let() {
+        run_and_expect_errors("test_data/parser/inline/err/top_level_let.rs");
+    }
     #[test]
     fn tuple_expr_leading_comma() {
         run_and_expect_errors("test_data/parser/inline/err/tuple_expr_leading_comma.rs");
 fn main() {
     foo! (
         bar, "baz", 1, 2.0
-    } //~ ERROR incorrect close delimiter
 }
+//~ ERROR incorrect close delimiter
 
 fn foo() {
     match () {
         _ => (),
         _ => (),
-        #[cfg(test)]
+        #[cfg(test)]  => ,
     }
 }
 
     };
 }
 
-fn
+fn ();
 
 fn foo() {}
 
-extern struct Foo;
+struct Foo;
 
-fn foo(x: i32, y) {
-}
+fn foo(x: i32, y) {}
 
 struct S {
     f: u32,
-    pub 92
-    + - *
     pub x: u32,
     z: f64,
 }
     };
 }
 
-impl<T: Clone>
+impl<T: Clone>  {}
+
 impl<T> OnceCell<T> {}
 
 fn f() {
     };
 }
 
-struct X {a: i32}
+struct X {
+    a: i32,
+}
+
 fn f() {
     let foo = X {
         a: 1
         self.scopes.push(ScopeData { parent: None, entries: vec![] })
     }
 
-    fn set_parent
+    fn set_parent();
 }
 
 fn foo() -> i32 {
     return 92;
 }
 
-unsafe async fn foo() {}
-unsafe const fn bar() {}
+async fn foo() {}
 
-let foo = bar = {
+const ;
+
+{
     1
-} else {
+}{
     return;
-};
-
+}
 fn f() {
     S::<Item::<lol>::<nope>>;
 }
 
 fn g() {
-    let _: Item::<lol>::<nope> = ();
+    let _: Item::<lol>::<
+    nope> =
+    ();
 }
 
 fn f<T: (Copy) + (?Sized) + (for<'a> Trait<'a>)>() {}
 
 fn main() {
-    let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;
-    let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Copy)>;
-    let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;
+    let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)
+    >
+    let _: Box<(?Sized
+    )
+    +
+    (for<'a> Trait<'a>) + (Copy)>;
+    let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)
+    >
 }
 
-let foo = 1 + {
+{
     1
-} else {
+}{
     return;
-};
-
-#!/use/bin/env rusti
-#!/use/bin/env rusti
+}
+#
+use ;
+#
+use ;
 
 fn foo()
-    where for<'a>
-{}
+where for<'a>
+{
+}
 
-let foo = |x: i32| {
+{
     x
-} else {
+}{
     return;
-};
-
+}
 struct S {
     a: i32,
     b: String,
-};
-
-struct S<90 + 2> {
-    f: u32
 }
 
+struct S<90;
+
 struct T;
 
 fn main() {
-    let ref box i = ();
-    let mut box i = ();
-    let ref mut box i = ();
+    let ref box
+    i = ();
+    let mut box
+    i = ();
+    let ref mut box
+    i = ();
 }
 
 impl<T:
-use std;
+  {}
 
-pub struct Cache(
-    RefCell<HashMap<
+pub struct Cache(RefCell<HashMap<
         TypeId,
-        Box<@ Any>,
-    >>
-);
+        Box<);
 
 fn f() {
     let _ = while true {
 }
 
 #[foo(foo, +, 92)]
-fn foo() {
-}
-
+fn foo() {}
 
 #[foo(
 fn foo() {
     let bad = format_args! {""} else { return; };
 }
 
-}
 
 struct S;
 
-}
 
-fn foo(){}
+fn foo() {}
 
-}
 
 struct S {
-    a: u32
-    b: u32
+    a: u32,
+    b: u32,
 }
 
-fn foo(}) {
-}
+fn foo();
 
-let foo = 1..{
+{
     1
-} else {
+}{
     return;
-};
-
-extern "C" extern "C"
+}
+use crate::baz;
+use ;
+use ;
 
 use foo::bar;
-use
-use crate::baz;
-use
 fn f() {}
 
 fn foo(a: A) {
 }
 
 struct S(i32, i32);
+
 fn f() {
     let s = S(1, 2);
     let a = s.1e0;
     { unsafe 92 }
     { async 92 }
     { try 92 }
-    { 'label: 92 }
+    {
+        'label:
+        92
+    }
 }
 
 fn foo() {
     let
     while true {}
     let
-    loop {}
+    loop {
+    }
 }
 
 fn foo() {
     }
 
     match () {
-        #[cfg(test)]
-        #![doc("Nor here")]
+        #[cfg(test)] #  => [doc("Nor here")],
         _ => (),
         _ => (),
     }
     let _ = 0;
 }
 
-if match
 
-struct S {}
+struct S {
+}
 
-fn foo<T>() where T {}
+fn foo<T>()
+where T
+{
+}
 
-fn a() { [1, 2, @, struct, let] }
-fn b() { foo(1, 2, @, impl, let) }
-fn c() { foo.bar(1, 2, @, ], trait, let) }
+fn a() {
+    [1, 2, @
+    ,
+    struct,
+    let
+    ]
+}
 
-let foo = -{
+fn b() {
+    foo(1, 2, @
+    ,
+    impl
+    ,
+    let
+    )
+}
+
+fn c() {
+    foo.bar(1, 2, @
+    ,
+    ]
+    ,
+    trait,
+    let
+    )
+}
+
+{
     1
-} else {
+}{
     return;
-};
-
+}
 fn f() {
     let _ = match Some(1) {
         Some(_) => 1,
         return
     };
 }
-
-use std::{error::Error;
 use std::io;
 
+use std::{error::Error;
+
 fn main() {
-    || -> () unsafe { () };
+    || -> ()
+    unsafe { () };
 }
 
 fn f() {
     };
 }
 
-let foo = become {
+{
     ()
-} else {
+}{
     return;
-};
-
+}
 type ForRef = for<'a> &'a u32;
+
 type ForTup = for<'a> (&'a u32,);
+
 type ForSlice = for<'a> [u32];
+
 type ForForFn = for<'a> for<'b> fn(&'a i32, &'b i32);
+
 fn for_for_for<T>()
 where
     for<'a> for<'b> for<'c> fn(&'a T, &'b T, &'c T): Copy,
 {
 }
 
-fn foo() {
-}
+fn foo() {}
 
-bar() {
-    if true {
-        1
-    } else {
-        2 + 3
-    }
-}
-
-fn baz() {
-}
-
-let foo = &{
+{
     1
-} else {
-    return;
-};
+}{
+    2 + 3
+}
+fn baz() {}
 
+{
+    1
+}{
+    return;
+}
 fn foo() {
     (,);
 }
     S { 0 .. }
 }
 
-fn f<T>() where T: ?for<> Sized {}
+fn f<T>()
+where T: ?for<> Sized
+{
+}
 
 type T = *();
 
-const _: () = T::<0, ,T>;
-const _: () = T::<0, ,T>();
+const () = T::<0, ,T>;
 
-fn foo() -> A>]) { let x = 1; }
-fn foo() -> A>]) where T: Copy { let x = 1; }
+const () = T::<0, ,T>();
 
-struct S { f pub g: () }
-struct S { f: pub g: () }
+fn foo() -> A {
+    let x = 1;
+}
 
-static C: u32 = 0
-where i32: Copy;
+fn foo() -> A
+where T: Copy
+{
+    let x = 1;
+}
 
-type T = [() 92];
+struct S {
+    f: ,
+    pub g: (),
+}
+
+struct S {
+    f: ,
+    pub g: (),
+}
+
+static C: u32 = 0;
+
+type T = [();
 
 fn main() {
     S { field = foo }
     let S { field = foo };
 }
 
-const _: [&];
+const [&];
 
-fn foo() { let _ = async {} }
+fn foo() {
+    let _ = async {}
+}
 
 fn foo() {
     S { ..x, };
 
 type T = impl use<self, 1>;
 
-static C = 0;
+static C:  = 0;
 
-struct S(struct S;
-struct S(A,,B);
+struct S();
+
+struct S;
+
+struct S(A, B);
 
 fn foo() {
     S { .., };
 }
 
 type X = <()>;
+
 type Y = <A as B>;
 
 fn func() {
     foo.bar::<i32>;
 }
 
-foo
 
-fn func() { let Some(_) = {Some(1)} else { panic!("h") };}
+fn func() {
+    let Some(_) = {Some(1)} else { panic!("h") };
+}
 
 impl Type {}
-impl Trait1 for T {}
-impl impl NotType {}
-impl Trait2 for impl NotType {}
 
-macro_rules! {};
+impl Trait1 for T {}
+
+impl  {}
+
+impl NotType {}
+
+impl Trait2 {}
+
+impl NotType {}
+
+macro_rules! {}
 macro_rules! ()
+
 macro_rules! []
 
 fn foo() {
 }
 
 fn foo<T: T![], T: T!, T: T!{}>() -> Box<T! + T!{}> {}
+use b;
 
 use {a;
-use b;
 struct T;
+
 fn test() {}
-use {a ,, b};
+use {a, b};
 
-fn foo(){} unsafe { } fn bar(){}
+fn foo() {}
+fn bar() {}
 
-fn foo() { pub 92; }
+fn foo() {
+    pub
+    92;
+}
 
 fn f() -> impl Iterator<Item = , Item = > {}
 
 fn f<T: Clone,, U:, V>() {}
 
 fn main() {
-    'loop: impl
+    'loop:
+    impl
 }
 
 struct A<const N: i32 = , const M: i32 =>;
 
-let ref foo: fn() = 1 + 3;
 
 fn foo() {
     match () {
-        _ => (),,
+        _ => (),
         _ => ,
         _ => (),
          => (),
-        if true => (),
+         if true => (),
         _ => (),
-        () if => (),
+        () if  => (),
     }
 }
 
 pub() struct S;
 
-static C<i32>: u32 = 0;
+static C: u32 = 0;
 
-type F = unsafe ();
+type F;
 
-fn foo() { || -> A> { let x = 1; } }
+fn foo() {
+    || -> A { let x = 1; }
+}
 
-const C = 0;
+const C:  = 0;
 
 fn foo() {
     let (,);
 }
 
 // 2021
-gen fn gen_fn() {}
-async gen fn async_gen_fn() {}
+fn gen_fn() {}
+
+async fn async_gen_fn() {}
 
 fn main() {
     S { S::default() };
     S { 0::default() };
 }
 
-fn f(x y: i32, z, t: i32) {}
+fn f(x, y: i32, z, t: i32) {}
 
 fn foo() {
     builtin#asm(
     );
 }
 
-fn f(y: i32, ,t: i32) {}
+fn f(y: i32, t: i32) {}
 
-#![]
-#![p = ]
-#![p::]
-#![p:: =]
-#![unsafe]
-#![unsafe =]
+#
+#
+#
+#
+#
+#
 
 type T = T<0, ,T>;
+
 type T = T::<0, ,T>;
 
-static _: i32 = 5;
+static i32 = 5;
 
 fn foo() {
     x.self;
 }
 
 fn a() {}
+
 fn b(x: i32) {}
-fn c(x: i32, ) {}
+
+fn c(x: i32) {}
+
 fn d(x: i32, y: ()) {}
 
 fn foo() {
 
 type T = S<{90 + 2}>;
 
-fn main() { || -> i32 { 92 }(); }
+fn main() {
+    || -> i32 { 92 }();
+}
 
 fn main() {
     let .. = ();
 
 use std::collections;
 
-fn f() { let x = 92; }
+fn f() {
+    let x = 92;
+}
 
 fn main() {
     match 42 {
 
 default impl T for Foo {}
 
-trait T where Self: Copy {}
+trait T
+where Self: Copy
+{
+}
 
-fn f() { unsafe { } }
-fn f() { const { } }
-fn f() { async { } }
-fn f() { async move { } }
+fn f() {
+    unsafe {
+    }
+}
+
+fn f() {
+    const {
+    }
+}
+
+fn f() {
+    async {
+    }
+}
+
+fn f() {
+    async {
+    }
+}
 
 fn main() {
     match 92 {
 
 struct S<T: 'a + ?Sized + (Copy) + [const] Drop>;
 
-builtin#global_asm("")
 
 fn foo() {
     let _ = try {};
 }
 
 fn main() {
-   let foo = |bar, baz: Baz, qux: Qux::Quux| ();
+    let foo = |bar, baz: Baz, qux: Qux::Quux| ();
 }
 
 fn foo() {
     match { S {} } {};
 }
 
-struct S { a: i32, b: f32, unsafe c: u8 }
+struct S {
+    a: i32,
+    b: f32,
+    c: u8,
+}
 
 fn foo() {
     builtin#asm("");
     let _ = cr"h";
 }
 
-fn foo(){
+fn foo() {
     if break {}
     while break {}
     for i in break {}
-    match break {}
+    match break {
+    }
 }
 
 const A: (i64, i64) = (1, #[cfg(test)] 2);
     enum LocalEnum {
         One,
         Two,
-    };
-    fn f() {};
-    struct S {};
+    }
+    fn f() {}
+    struct S {}
 }
 
-struct S { #[attr] f: f32 }
+struct S {
+    #[attr]
+    f: f32,
+}
 
 fn main() {
     let [a, b, ..] = [];
 
 fn foo() {
     match () {
-        #![doc("Inner attribute")]
-        #![doc("Can be")]
-        #![doc("Stacked")]
         _ => (),
     }
 }
 
-impl const Send for S {}
+impl Send for S {}
 
-fn main() { let cl = const || _ = 0; }
+fn main() {
+    let cl = const || _ = 0;
+}
 
 impl S {
     fn a(self) {}
-    fn b(&self,) {}
-    fn c(&'a self,) {}
+
+    fn b(&self) {}
+
+    fn c(&'a self) {}
+
     fn d(&'a mut self, x: i32) {}
+
     fn e(mut self) {}
 }
 
 type Foo where Foo: Copy = ();
 
 macro_rules! m ( ($i:ident) => {} );
+
 macro_rules! m [ ($i:ident) => {} ];
 
-#![simple_ident]
-#![simple::path]
-#![simple_ident_expr = ""]
-#![simple::path::Expr = ""]
-#![simple_ident_tt(a b c)]
-#![simple_ident_tt[a b c]]
-#![simple_ident_tt{a b c}]
-#![simple::path::tt(a b c)]
-#![simple::path::tt[a b c]]
-#![simple::path::tt{a b c}]
-#![unsafe(simple_ident)]
-#![unsafe(simple::path)]
-#![unsafe(simple_ident_expr = "")]
-#![unsafe(simple::path::Expr = "")]
-#![unsafe(simple_ident_tt(a b c))]
-#![unsafe(simple_ident_tt[a b c])]
-#![unsafe(simple_ident_tt{a b c})]
-#![unsafe(simple::path::tt(a b c))]
-#![unsafe(simple::path::tt[a b c])]
-#![unsafe(simple::path::tt{a b c})]
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
 
 macro m { ($i:ident) => {} }
 
-fn f<T>() where T: for<> ?Sized {}
+fn f<T>()
+where T: for<> ?Sized
+{
+}
 
-struct S<T>(T) where T: Clone;
+struct S<T>(T);
 
 fn main() {
     match () {
     #[D] return ();
 }
 
-mod b { }
+mod b {
+}
 
 impl S {}
 
     TupleStruct { 0: 1 };
 }
 
-type F = fn() -> ();
+type F =
+    fn(
+    ) -> ();
+
+type A =
+    fn(
+    );
 
-type A = fn();
 type B = unsafe fn();
+
 type C = unsafe extern "C" fn();
+
 type D = extern "C" fn ( u8 , ... ) -> u8;
 
-fn f() { 'label: {}; }
+fn f() {
+    'label: {};
+}
 
 type A = for<'a> Test<'a> + Send;
 
 
 type Result<T> = ();
 
-fn main() { let <_>::Foo = (); }
+fn main() {
+    let <_>::Foo = ();
+}
 
 type T = S<true>;
 
-trait X<U: Debug + Display> {}
+trait X<U: Debug + Display> {
+}
 
 type T = StreamingIterator<Item<'a> = &'a T>;
 
     let S { #[cfg(any())] x: 1 } = ();
 }
 
-// 2015
-macro_rules! try { () => {} }
+macro_rules!
+{
+}use Trait as _;
 
 use std as stdlib;
-use Trait as _;
 
 struct S(String, usize);
 
 
 type T = S<i32, dyn T, fn()>;
 
-// 2015
 type DynPlain = dyn Path;
-type DynRef = &dyn Path;
-type DynLt = dyn 'a + Path;
-type DynQuestion = dyn ?Path;
-type DynFor = dyn for<'a> Path;
-type DynParen = dyn(Path);
-type Path = dyn::Path;
-type Generic = dyn<Path>;
 
-fn main() { || _ = 0; }
+type DynRef = &dyn Path;
+
+type DynLt = dyn 'a + Path;
+
+type DynQuestion = dyn ?Path;
+
+type DynFor = dyn for<'a> Path;
+
+type DynParen = dyn(Path);
+
+type Path = dyn::Path;
+
+type Generic = dyn;
+
+fn main() {
+    || _ = 0;
+}
 
 use {a, b, c};
 
     return 92;
 }
 
-type Foo = () where Foo: Copy;
+type Foo where Foo: Copy = ();
 
 type Never = !;
 
-fn foo<T>() where T: Copy {}
+fn foo<T>()
+where T: Copy
+{
+}
 
 fn foo() {
     let _ = a;
 
 type A = dyn Iterator<Item=Foo<'a>> + 'a;
 
-trait T { fn new() -> Self; }
+trait T {
+    fn new() -> Self;
+}
 
 fn foo() {
     let _s = S { .. };
 }
 
 fn foo() {}
+
 fn bar() -> () {}
 
 fn main() {
 }
 
 pub(crate) struct S;
+
 pub(self) struct S;
+
 pub(super) struct S;
 
 type Placeholder = _;
 
 fn foo() {
     match () {
-        #[cfg(feature = "some")]
-        _ => (),
-        #[cfg(feature = "other")]
-        _ => (),
-        #[cfg(feature = "many")]
-        #[cfg(feature = "attributes")]
-        #[cfg(feature = "before")]
-        _ => (),
+        #[cfg(feature = "some")] _ => (),
+        #[cfg(feature = "other")] _ => (),
+        #[cfg(feature = "many")] #[cfg(feature = "attributes")] #[cfg(feature = "before")] _ => (),
     }
 }
+use std::{::*};
 
 use ::*;
-use std::{::*};
 
 fn foo() {
     if true {}
 }
 
 fn foo() {
-   let mut p = F{x: 5};
-   {p}.x = 10;
+    let mut p = F{x: 5};
+    {p}.x = 10;
 }
 
 // 2015
-fn foo() { try!(Ok(())); }
+fn foo() {
+    try
+    !(Ok(()));
+}
 
 fn f<T: Clone>() {}
 
 
 struct A<const N: i32 = { 1 }>;
 
-struct U { i: i32, f: f32 }
+struct U {
+    i: i32,
+    f: f32,
+}
 
 type M = *mut ();
+
 type C = *mut ();
 
 impl<const N: u32> Bar<N> {}
 type T = [()];
 
 fn foo() {
-   for x in 0 .. {
-       break;
-   }
+    for x in 0.. {
+        break;
+    }
 }
 
 use crate::foo;
     T::method(..): Send,
     method(..): Send,
     method::(..): Send,
-{}
+{
+}
 
-impl S { #![attr] }
+impl S {}
 
 fn a() {}
-fn b() { let _ = 1; }
-fn c() { 1; 2; }
-fn d() { 1; 2 }
+
+fn b() {
+    let _ = 1;
+}
+
+fn c() {
+    1;
+    2;
+}
+
+fn d() {
+    1;
+    2
+}
 
 fn foo() {
     let _ = f();
 fn foo() {
     'a: loop {}
     'b: while true {}
-    'c: for x in () {}
+    'c: for x in () {
+    }
 }
 
 impl T for Foo {
-    default async fn foo() {}
+    async fn foo() {}
 }
 
-trait Z<U> = T<U>;
+trait Z<U> {}
 
 use std::*;
 
    T: Clone + Copy + 'static,
    Iterator::Item: 'a,
    <T as Iterator>::Item: 'a
-{}
+{
+}
 
 macro_rules! {}
+
 macro_rules! ();
+
 macro_rules! [];
+
 fn main() {
     let foo = macro_rules!();
 }
 fn f<T: Clone>() {}
 
 struct B(pub (super::A));
+
 struct B(pub (crate::A,));
 
 type A = 'static + Trait;
+
 type B = S<'static + Trait>;
 
 type A = Foo<syn::Token![_]>;
 
 fn foo<F: Foo<N=3>>() {}
+
 const TEST: usize = 3;
+
 fn bar<F: Foo<N={TEST}>>() {}
 
 type F = Start::(Middle) -> (Middle)::End;
+
 type GenericArg = S<Start(Middle)::End>;
 
 type T = S<92>;
 type T = S<-92>;
 
 type T = StreamingIterator<Item<'a>: Clone>;
+
 type T = StreamingIterator<Item(T): Clone>;
 
 fn foo() {}
+
 macro_rules! foo {}
+
 foo::bar!();
+
 super::baz! {}
+
 struct S;
 
 struct S<T = i32>;
 
 type A = for<'a> fn() -> ();
+
 type B = for<'a> unsafe extern "C" fn(&'a ()) -> ();
+
 type Obj = for<'a> PartialEq<&'a i32>;
 
 const fn foo(_: impl [const] Trait) {}
-
-use *;
 use std::{*};
 
-const _: u32 = 0;
+use *;
 
-fn foo<T: Clone + Copy>(){}
+const u32 = 0;
 
-fn f() { v = {1}&2; }
+fn foo<T: Clone + Copy>() {}
+
+fn f() {
+    v = {1}&2;
+}
 
 fn foo() {
     x.await;
 
 fn foo() {
     if let Some(_) = None && true {}
-    while 1 == 5 && (let None = None) {}
+    while 1 == 5 && (let None = None) {
+    }
 }
 
 fn foo() {
 }
 
 default unsafe impl T for Foo {
-    default unsafe fn foo() {}
+    unsafe fn foo() {}
 }
 
 pub(in super::A) struct S;
+
 pub(in crate) struct S;
 
 type Plain = Foo<Item, Item::Item, Item: Bound, Item = Item>;
+
 type GenericArgs = Foo<Item<T>, Item::<T>, Item<T>: Bound, Item::<T>: Bound, Item<T> = Item, Item::<T> = Item>;
+
 type ParenthesizedArgs = Foo<Item(T), Item::(T), Item(T): Bound, Item::(T): Bound, Item(T) = Item, Item::(T) = Item>;
+
 type RTN = Foo<Item(..), Item(..), Item(..): Bound, Item(..): Bound, Item(..) = Item, Item(..) = Item>;
 
 fn foo() {
 
 fn captures<'a: 'a, 'b: 'b, T>() -> impl Sized + use<'b, T, Self> {}
 
-enum E { X(i32) = 10 }
+enum E {
+    X(i32) = 10,
+}
 
-// 2015
 type A = Foo<dyn T>;
 
-fn foo() { let R { a: | 1 | 2 } = 0; }
+fn foo() {
+    let R { a: | 1 | 2 } = 0;
+}
 
 type A = impl Iterator<Item=Foo<'a>> + 'a;
 
 
 fn f() {
     let _ = {1} & 2;
-    {1} &2;
+    {1}
+    &2;
 }
 
 struct A<const N: i32 = i32::MAX>;
     }
 }
 
-extern "C" { fn printf(format: *const i8, ..., _: u8) -> i32; }
+extern "C" {
+    fn printf(format: *const i8, ..., _: u8) -> i32;
+}
 
 type T = [(); 92];
+use std::collections;
 
 use ::std;
-use std::collections;
 
 use self::m;
 use super::m;
 }
 
 impl T for Foo {
-    default async unsafe fn foo() {}
+    async unsafe fn foo() {}
 }
 
 fn foo() {
 
 type Foo = Bar;
 
-type Foo = fn(Bar::Baz);
-type Qux = fn(baz: Bar::Baz);
+type Foo =
+    fn(
+        Bar::Baz,
+    );
+
+type Qux =
+    fn(
+        baz: Bar::Baz,
+    );
 
 impl S {
     fn a(self: &Self) {}
+
     fn b(mut self: Box<Self>) {}
 }
 
     match () {
         _ => (),
         _ => {}
-        _ => ()
+        _ => (),
     }
 }
 
     }
 }
 
-fn f() { let x: i32; }
+fn f() {
+    let x: i32;
+}
 
-fn main() { let _ = (); }
+fn main() {
+    let _ = ();
+}
 
 type X = <A as B>::Output;
-fn foo() { <usize as Default>::default(); }
 
-const C<i32>: u32 = 0;
+fn foo() {
+    <usize as Default>::default();
+}
+
+const C: u32 = 0;
+
 impl Foo {
-    const C<'a>: &'a () = &();
+    const C: &'a () = &();
 }
 
-const C<i32>: u32 = 0
-where i32: Copy;
+const C: u32 = 0;
+
 trait Foo {
-    const C: i32 where i32: Copy;
+    const C: i32;
 }
 
-trait T: Hash + Clone {}
+trait T {
+}
 
 fn foo() {
     ();
 }
 
 type A = foo!();
+
 type B = crate::foo!();
 
 type A = Foo;
+
 type B = ::Foo;
+
 type C = self::Foo;
+
 type D = super::Foo;
 
 fn foo() {
 }
 
 type F = Box<Fn(i32) -> ()>;
+
 type F = Box<::Fn(i32) -> ()>;
+
 type F = Box<Fn::(i32) -> ()>;
+
 type F = Box<::Fn::(i32) -> ()>;
 
 fn main() {
 type T = (i32);
 
 struct MyStruct(pub (u32, u32));
+
 struct MyStruct(pub (u32));
+
 struct MyStruct(pub ());
 
-fn f() { let Some(x) = opt else { return }; }
+fn f() {
+    let Some(x) = opt else { return };
+}
 
 fn foo() {
     while true {};
     x.0()
 }
 
-fn main() { for<'a> || (); }
+fn main() {
+    for<'a> || ();
+}
 
-type Foo = fn(_: bar);
+type Foo =
+    fn(
+        _: bar,
+    );
 
-fn foo() { xs[..]; }
+fn foo() {
+    xs[..];
+}
 
-trait T { fn foo(); }
+trait T {
+    fn foo();
+}
 
-fn f() { let x: i32 = 92; super let y; super::foo; }
+fn f() {
+    let x: i32 = 92;
+    super let y;
+    super::foo;
+}
 
 fn foo() {
     82 as i32;
 
 fn f(#[attr1] pat: Type) {}
 
-struct S (#[attr] f32);
+struct S(f32);
 
 fn foo() {
     builtin#asm(
     );
 }
 
-impl !Send for S {}
+impl Send for S {}
 
-fn f() { let _ = &1 as *const i32; }
+fn f() {
+    let _ = &1 as *const i32;
+}
 
 fn for_trait<F>()
 where
    for<'a> F: Fn(&'a str)
-{ }
+{
+}
 
-#!/usr/bin/env cargo
+#
 
----
-[dependencies]
-clap = { version = "4.2", features = ["derive"] }
----
 
 fn main() {}
 
     }
 }
 
-trait Z<U> = T<U> where U: Copy;
-trait Z<U> = where Self: T<U>;
+trait Z<U>
+where U: Copy {}
+
+trait Z<U>
+where Self: T<U> {}
 
 const fn foo(_: impl const Trait) {}
 
 
 struct A<const N: i32 = -1>;
 
-struct S {}
+struct S {
+}
 
-fn foo() { safe = true; }
+fn foo() {
+    safe = true;
+}
 
 type A = &();
+
 type B = &'static ();
+
 type C = &mut ();
 
 fn main() {
 extern crate foo as bar;
 extern crate self as bar;
 
-fn foo(){
-    ;;;some_expr();;;;{;;;};;;;Ok(())
+fn foo() {
+    some_expr();
+    {;;;};
+    Ok(())
 }
 
 struct S<const N: u32>;
 
-fn a() { fn b() {} }
+fn a() {
+    fn b() {}
+}
 
 fn foo() -> Box<T + 'f> {}
+
 fn foo() -> Box<dyn T + 'f> {}
 
 fn main() {
 
 impl F {
     type A = i32;
+
     const B: i32 = 92;
+
     fn foo() {}
+
     fn bar(&self) {}
 }
 
     foo(loop {});
 }
 
-fn foo() { let r#struct = 92; let r#trait = r#struct * 2; }
+fn foo() {
+    let r#struct = 92;
+    let r#trait = r#struct * 2;
+}
 
 fn main() {
     Some(for _ in [1].into_iter() {});
 }
 
 /// Example
-
 fn test() {}
 
 static FOO: u32 = 1;
+
 static mut BAR: i32 = 92;
 
 fn a() {}
+
 pub fn b() {}
+
 pub macro m($:ident) {}
+
 pub(crate) fn c() {}
+
 pub(super) fn d() {}
+
 pub(in foo::bar::baz) fn e() {}
+use foo::bar::baz;
 
 use ::foo::bar::baz;
-use foo::bar::baz;
 
 struct S<T: Copy> {
     f: T,
 }
 
 enum E3 {
-    X
+    X,
 }
 
 enum E4 {
         a: u32,
         pub b: f64,
     },
-    F {},
-    D(u32,),
+    F {
+    },
+    D(u32),
     E(),
 }
 
 // https://github.com/rust-lang/rust-analyzer/issues/674
 
-struct Repr { raw: [u8; 1] }
+struct Repr {
+    raw: [u8; 1],
+}
 
 fn abc() {
     Repr { raw: [0] }.raw[0] = 0;
 }
 
 fn main() {
-    if 1.0f32.floor() as i64 != 1.0f32.floor() as i64 {}
+    if 1.0f32.floor() as i64 != 1.0f32.floor() as i64 {
+    }
 }
 
 fn main() {
 }
 
 enum A {
-    B(i8, i8)
+    B(i8, i8),
 }
 
 fn foo(-128..=127: i8) {}
 fn test_serialization<SER>()
 where
     SER: Serialize + for<'de> Deserialize<'de> + PartialEq + std::fmt::Debug,
-{}
+{
+}
 
 struct S {
-    r#foo: u32
+    r#foo: u32,
 }
 
 extern crate foo;
 unsafe extern {
     // sqrt (from libm) may be called with any `f64`
     pub safe fn sqrt(x: f64) -> f64;
-
     // strlen (from libc) requires a valid pointer,
     // so we mark it as being an unsafe fn
     pub unsafe fn strlen(p: *const c_char) -> usize;
-
     // this function doesn't say safe or unsafe, so it defaults to unsafe
     pub fn free(p: *mut core::ffi::c_void);
-
     pub safe static mut COUNTER: i32;
-
     pub unsafe static IMPORTANT_BYTES: [u8; 256];
-
     pub safe static LINES: SyncUnsafeCell<i32>;
 }
 
-extern "C" {
-    //! This is a doc comment
-    #![doc("This is also a doc comment")]
-}
+extern "C" {}
 
 fn inner() {
     #![doc("Inner attributes allowed here")]
     let _ = #[doc("Outer attributes are always allowed")] {};
 }
 
-// https://github.com/rust-lang/rust-analyzer/issues/689
 impl Whatever {
     fn salsa_event(&self, event_fn: impl Fn() -> Event<Self>) {
         #![allow(unused_variables)] // this is  `inner_attr` of the block
     for<'a> F: Fn(&'a str),
 {
 }
+
 fn for_ref<F>()
 where
     for<'a> &'a F: Debug,
 {
 }
+
 fn for_parens<F>()
 where
     for<'a> (&'a F): Fn(&'a str),
 {
 }
+
 fn for_slice<F>()
 where
     for<'a> [&'a F]: Eq,
 {
 }
+
 fn for_qpath<T>(_t: &T)
 where
     for<'a> <&'a T as Baz>::Foo: Iterator,
 {
 }
+
 fn for_for_fn<T>()
 where
     for<'a> for<'b> fn(&'a T, &'b T): Copy,
 {
 }
 
-#![attr]
-#![attr(true)]
-#![attr(ident)]
-#![attr(ident, 100, true, "true", ident = 100, ident = "hello", ident(100))]
-#![attr(100)]
-#![attr(enabled = true)]
-#![enabled(true)]
-#![attr("hello")]
-#![repr(C, align = 4)]
-#![repr(C, align(4))]
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
 
 extern "C" {
     fn a(_: *mut u8, ...,);
 }
 
 struct A;
-struct B {}
+
+struct B {
+}
+
 struct C();
 
 struct D {
     a: u32,
-    pub b: u32
+    pub b: u32,
 }
 
-struct E(pub x, y,);
+struct E(pub x, y);
 
-//! Adapted from a `rustc` test, which can be found at
-//! https://github.com/rust-lang/rust/blob/6d34ec18c7d7e574553f6347ecf08e1e1c45c13d/src/test/run-pass/weird-exprs.rs.
-//!
-//! Reported to rust-analyzer in https://github.com/rust-lang/rust-analyzer/issues/290
+#
+#
+#
+#
 
-#![allow(non_camel_case_types)]
-#![allow(dead_code)]
-#![allow(unreachable_code)]
-#![allow(unused_parens)]
-
-#![recursion_limit = "128"]
+#
 
 use std::cell::Cell;
 use std::mem::swap;
 
 // Just a grab bag of stuff that you wouldn't want to actually write.
 
-fn strange() -> bool { let _x: bool = return true; }
+fn strange() -> bool {
+    let _x: bool = return true;
+}
 
 fn funny() {
     fn f(_x: ()) { }
                 return;
             }
         }
-        if (return) { break; }
+        if (return) {
+            break;
+        }
     }
 }
 
 fn angrydome() {
     loop { if break { } }
     let mut i = 0;
-    loop { i += 1; if i == 1 { match (continue) { 1 => { }, _ => panic!("wat") } }
-      break; }
+    loop {
+        i += 1;
+        if i == 1 { match (continue) { 1 => { }, _ => panic!("wat") } }
+        break;
+    }
 }
 
-fn evil_lincoln() { let _evil = println!("lincoln"); }
+fn evil_lincoln() {
+    let _evil = println!("lincoln");
+}
 
 fn dots() {
     assert_eq!(String::from(".................................................."),
 }
 
 fn punch_card() -> impl std::fmt::Debug {
-    ..=..=.. ..    .. .. .. ..    .. .. .. ..    .. ..=.. ..
-    ..=.. ..=..    .. .. .. ..    .. .. .. ..    ..=..=..=..
-    ..=.. ..=..    ..=.. ..=..    .. ..=..=..    .. ..=.. ..
-    ..=..=.. ..    ..=.. ..=..    ..=.. .. ..    .. ..=.. ..
-    ..=.. ..=..    ..=.. ..=..    .. ..=.. ..    .. ..=.. ..
-    ..=.. ..=..    ..=.. ..=..    .. .. ..=..    .. ..=.. ..
-    ..=.. ..=..    .. ..=..=..    ..=..=.. ..    .. ..=.. ..
+    ..=..=........................=......=....=....................=..=..=....=....=....=....=......=..=......=......=..=......=....=....=..........=......=....=....=....=......=........=......=....=....=....=........=......=......=....=......=..=....=..=........=....
 }
 
 fn ktulhu() {
-    ;;;();;;;;;;;;()
+    ();
+    ()
 }
 
 pub fn main() {
 }
 
 use foo as bar;
-use foo::{a as b, *, ::*, ::foo as x};
+use foo::{a as b, *, ::foo as x, ::*};
 
 fn g1(#[attr1] #[attr2] pat: Type) {}
+
 fn g2(#[attr1] x: u8) {}
 
-extern "C" { fn printf(format: *const i8, #[attr] ...) -> i32; }
+extern "C" {
+    fn printf(format: *const i8, #[attr] ...) -> i32;
+}
 
 trait Foo {
     fn bar(#[attr] _: u64, # [attr] mut x: i32);
 }
 
 impl S {
-     fn f(#[must_use] self) {}
-     fn g1(#[attr] self) {}
-     fn g2(#[attr] &self) {}
-     fn g3<'a>(#[attr] &mut self) {}
-     fn g4<'a>(#[attr] &'a self) {}
-     fn g5<'a>(#[attr] &'a mut self) {}
-     fn c(#[attr] self: Self) {}
-     fn d(#[attr] self: Rc<Self>) {}
+    fn f(#[must_use] self) {}
+
+    fn g1(#[attr] self) {}
+
+    fn g2(#[attr] &self) {}
+
+    fn g3<'a>(#[attr] &mut self) {}
+
+    fn g4<'a>(#[attr] &'a self) {}
+
+    fn g5<'a>(#[attr] &'a mut self) {}
+
+    fn c(#[attr] self: Self) {}
+
+    fn d(#[attr] self: Rc<Self>) {}
 }
 
-fn r#foo() {
-}
+fn r#foo() {}
 
 use foo;
 use ::bar;
 
-
 struct S {
-    foo: u32
+    foo: u32,
 }
 
 fn foo() {
     async move {};
 }
 
-#!/use/bin/env rusti
+#
+use ;
 
 // https://github.com/rust-lang/rust-analyzer/issues/357
 
-//! docs
 // non-docs
-mod foo {}
+mod foo {
+}
 
 type X = ();
 
 fn main() {
     let ():::X = ();
 }
+use foo::*;
+use foo::{};
 
 use *;
+use ::foo::{a, b, c};
 use ::*;
 use ::{};
 use {};
-use foo::*;
-use foo::{};
-use ::foo::{a, b, c};
 
 fn foo(x: impl std::future::Future<Output = i32>) {}
 
 fn main() {
-    foo(async move { 12 })
+    foo(async {
+        12
+    })
 }
 
 struct A<T>;
+
 struct B<T:>;
+
 struct C<T: 'a>;
+
 struct D<T: 'a + >;
+
 struct E<T: 'a + 'd >;
+
 struct F<T: 'a + 'd + Clone>;
+
 struct G<T: Clone + Copy>;
+
 struct H<T: ::Foo + self::Bar + 'a>;
+
 struct I<T:, U:,>;
+
 struct K<'a: 'd, 'd: 'a + 'b, T: 'a + 'd + Clone>;
 
 async fn foo() {}
-extern fn foo() {}
+
+fn foo() {}
+
 const fn foo() {}
+
 const unsafe fn foo() {}
-unsafe extern "C" fn foo() {}
+
 unsafe fn foo() {}
+
+unsafe fn foo() {}
+
 async unsafe fn foo() {}
+
 const unsafe fn bar() {}
 
-unsafe trait T {}
-auto trait T {}
-unsafe auto trait T {}
+trait T {
+}
+
+trait T {
+}
+
+trait T {
+}
 
 unsafe impl Foo {}
+
 default impl Foo {}
-unsafe default impl Foo {}
+
+default unsafe impl Foo {}
 
 unsafe extern "C++" {}
 
 fn main() {
     unsafe fn f() {}
-    unsafe { 92 }
+    unsafe {
+        92
+    }
 }
 
 // https://github.com/rust-lang/rust-analyzer/issues/677
 }
 
 mod c {
-    fn foo() {
+    fn foo() {}
+    struct S {
     }
-    struct S {}
 }
 
 mod d {
     }
 }
 
-fn test() where (u64, u64): Foo {}
+fn test()
+where (u64, u64): Foo
+{
+}
 
 fn a() -> Foo<bar::Baz> {}
 
 fn foo() {}
 
 type Foo<'a> = &'a (dyn Send + Sync);
+
 type Foo = *const (dyn Send + Sync);
-type Foo = fn() -> (dyn Send + 'static);
+
+type Foo =
+    fn(
+    ) -> (dyn Send + 'static);
+
 fn main() {
     let b = (&a) as &(dyn Add<Other, Output = Addable> + Other);
 }
     a <<= 12;
 }
 
-
 fn main() {
     const fn f() {}
 }
 
 trait T {
     fn f1((a, b): (usize, usize)) {}
+
     fn f2(S { a, b }: S) {}
+
     fn f3(NewType(a): NewType) {}
+
     fn f4(&&a: &&usize) {}
+
     fn bar(_: u64, mut x: i32);
 }
 
-fn f<T>() where T: Fn() -> u8 + Send {}
+fn f<T>()
+where T: Fn() -> u8 + Send
+{
+}
 
 impl U {
     fn f1((a, b): (usize, usize)) {}
+
     fn f2(S { a, b }: S) {}
+
     fn f3(NewType(a): NewType) {}
+
     fn f4(&&a: &&usize) {}
 }
 
 trait T {
-  default type T = Bar;
-  default const f: u8 = 0;
-  default fn foo() {}
-  default unsafe fn bar() {}
+    type T = Bar;
+
+    const f: u8 = 0;
+
+    fn foo() {}
+
+    unsafe fn bar() {}
 }
 
 impl T for Foo {
-  default type T = Bar;
-  default const f: u8 = 0;
-  default fn foo() {}
-  default unsafe fn bar() {}
+    type T = Bar;
+
+    const f: u8 = 0;
+
+    fn foo() {}
+
+    unsafe fn bar() {}
 }
 
 default impl T for () {}
+
 default unsafe impl T for () {}
 
-extern {
-}
+extern {}
 
-extern "C" {
-}
+extern "C" {}
 
 #[cfg(test)]
 #[Ignore]
 mod b;
 
 struct S1<T>;
+
 struct S2<T>(u32);
-struct S3<T> { u: u32 }
+
+struct S3<T> {
+    u: u32,
+}
 
 struct S4<>;
+
 struct S5<'a>;
+
 struct S6<'a:>;
+
 struct S7<'a: 'b>;
+
 struct S8<'a: 'b + >;
+
 struct S9<'a: 'b + 'c>;
+
 struct S10<'a,>;
+
 struct S11<'a, 'b>;
+
 struct S12<'a: 'b+, 'b: 'c,>;
 
 struct S13<T>;
+
 struct S14<T, U>;
+
 struct S15<'a, T, U>;
 
 trait Runnable {
     fn fn_with_expr(x: [i32; 1]);
 }
 
-fn foo() {
-}
+fn foo() {}
 
 fn foo() {
-   for _x in 0 .. (0 .. {1 + 2}).sum::<u32>() {
-       break;
-   }
+    for _x in 0..(0..{
+        1 + 2
+    }).sum::<u32>() {
+        break;
+    }
 }
 
 fn foo() {
     #[C] &()
 }
 
-br##"
+//") || content.contains(";\n")) {
 
-b"\"
-b"\"
-b"\u{_0000}"
-b"\u{0000000}"
-b"\u{FFFFFF}"
-b"\u{ffffff}"
-b"\u{ffffff}"
-b"\u{DC00}"
-b"\u{DDDD}"
-b"\u{DFFF}"
-b"\u{D800}"
-b"\u{DAAA}"
-b"\u{DBFF}"
-b"\x"
-
-0e
-0E
-
-42e+
-42e-
-42E+
-42E-
-
-42.e+
-42.e-
-42.E+
-42.E-
-
-42.2e+
-42.2e-
-42.2E+
-42.2E-
-
-42.2e+f32
-42.2e-f32
-42.2E+f32
-42.2E-f32
-
-b"\x7f
-
-0b
-0o
-0x
-
-0b_
-0o_
-0x_
-
-0bnoDigit
-0onoDigit
-0xnoDigit
-
-0xG
-0xg
-
-0x_g
-0x_G
-
-'
-
-'\
-
-r## I lack a quote!
-
-b"
-
-br##"\x7f
-
-"\"
-"\"
-"\u{_0000}"
-"\u{0000000}"
-"\u{FFFFFF}"
-"\u{ffffff}"
-"\u{ffffff}"
-"\u{DC00}"
-"\u{DDDD}"
-"\u{DFFF}"
-"\u{D800}"
-"\u{DAAA}"
-"\u{DBFF}"
-"\x"
-
-b'\
-
-r##"\x7f
-
-/* /* /*
-
-br##"\n
-
-"
-
-r##"
-
-b'
-
-b"\
-
-b"
-
-/** /*! /* comment */ */
-
-fn main() {
-    hello("world);
-    // a bunch of code was here
-    env("FLAGS", "-help")
+fn finalize_with_eof(mut self) -> LexedStr<'a> {
+    self.res.push(EOF, self.offset);
+    self.res
 }
 
-b'\n
-
-'
-
-b'
-
-"
-
-b"\n
-
-br##"\u{20AA}
-
-b"\u{20AA}
-
-"\u{20AA}
-
-br##"
-
-"\x7f
-
-r##"\
-
-b'\'
-
-b'
-
-'\n
-
-br##
-
-br##"\
-
-r##"
-
-"
-
-c"\"
-c"\"
-c"\u{_0000}"
-c"\u{0000000}"
-c"\u{FFFFFF}"
-c"\u{ffffff}"
-c"\u{ffffff}"
-c"\u{DC00}"
-c"\u{DDDD}"
-c"\u{DFFF}"
-c"\u{D800}"
-c"\u{DAAA}"
-c"\u{DBFF}"
-c"\x"
-
-b"\"
-
-b'\x7f
-
-br##"
-
-'
-
-b"
-
-br## I lack a quote!
-
-r##"\u{20AA}
-
-b'\u{20AA}
-
-"\"
-
-"\
-
-"\n
-
-r##"
-
-/*
-
-'hello'
-''
-'
-'
-'spam'
-'\x0ff'
-'\"a'
-'\na'
-'\ra'
-'\ta'
-'\\a'
-'\'a'
-'\0a'
-'\u{0}x'
-'\u{1F63b}}'
-'\v'
-'\'
-'\'
-'\\\r'
-'\x'
-'\x0'
-'\xf'
-'\xa'
-'\xx'
-'\x'
-'\x'
-'\xtt'
-'\xff'
-'\xFF'
-'\x80'
-'\u'
-'\u[0123]'
-'\u{0x}'
-'\u{'
-'\u{0000'
-'\u{}'
-'\u{_0000}'
-'\u{0000000}'
-'\u{FFFFFF}'
-'\u{ffffff}'
-'\u{ffffff}'
-'\u{DC00}'
-'\u{DDDD}'
-'\u{DFFF}'
-'\u{D800}'
-'\u{DAAA}'
-'\u{DBFF}'
-
-'1
-'1lifetime
-
-'\'
-
-'\u{20AA}
-
-b''
-b'\'
-b'
-'
-b'spam'
-b'\x0ff'
-b'\"a'
-b'\na'
-b'\ra'
-b'\ta'
-b'\\a'
-b'\'a'
-b'\0a'
-b'\u{0}x'
-b'\u{1F63b}}'
-b'\v'
-b'\'
-b'\'
-b'\\\r'
-b'\x'
-b'\x0'
-b'\xf'
-b'\xa'
-b'\xx'
-b'\x'
-b'\x'
-b'\xtt'
-b'\u'
-b'\u[0123]'
-b'\u{0x}'
-b'\u{'
-b'\u{0000'
-b'\u{}'
-b'\u{_0000}'
-b'\u{0000000}'
-b'\u{FFFFFF}'
-b'\u{ffffff}'
-b'\u{ffffff}'
-b'\u{DC00}'
-b'\u{DDDD}'
-b'\u{DFFF}'
-b'\u{D800}'
-b'\u{DAAA}'
-b'\u{DBFF}'
-
-'\x7f
-
-r##"\n
-
-r##
-
-/* comment
-
-async fn use struct trait enum impl true false as extern crate
-mod pub self super in where for loop while if match const
-static mut type ref let else move return
-
-b'x' b"foo" br""
-b""ix br""br
-b'\n' b'\\' b'\''
-
-'a 'foo 'foo_bar_baz '_
-
-'x' ' ' '0' '\x7f' '\n' '\\' '\''
-
-#!/usr/bin/env cargo
-
----
-[dependencies]
-clap = "4"
----
-
-fn main() {
-}
-
-"hello" r"world" "\n\"\\no escape" "multi
-line"
-
-hello world
-
-0 00 0_ 0. 0z
-01790 0b1790 0o1790 0x1790aAbBcCdDeEfF 001279 0_1279 0.1279 0e1279 0E1279
-0..2
-0.foo()
-0e+1
-0.e+1
-0.0E-2
-0___0.10000____0000e+111__
-1i64 92.0f32 11__s
-
-/* */
-/**/
-/* /* */ */
-
-a b  c
-d
-
-e	f
-
-r###"this is a r##"raw"## string"###
-
-r#raw_ident
-
-foo foo_ _foo _ __ x 
-
-#!/usr/bin/env bash
-// hello
-//! World
-//!! Inner line doc
-/// Outer line doc
-//// Just a comment
-
-//
-//!
-//!!
-///
-////
-
-//@ edition: 2021
-
-#"foo"
-
-
----
-[dependencies]
-clap = "4"
----
-
-fn main() {
-}
-
-; , ( ) { } [ ] < > @ # ~ ? $ & | + * / ^ %
-. .. ... ..=
-: ::
-= =>
-! !=
-- ->
-
-//! Lexing `&str` into a sequence of Rust tokens.
-//!
-//! Note that strictly speaking the parser in this crate is not required to work
-//! on tokens which originated from text. Macros, eg, can synthesize tokens out
-//! of thin air. So, ideally, lexer should be an orthogonal crate. It is however
-//! convenient to include a text-based lexer here!
-//!
-//! Note that these tokens, unlike the tokens we feed into the parser, do
-//! include info about comments and whitespace.
-
-use std::ops;
-
-use rustc_literal_escaper::{
-    EscapeError, Mode, unescape_byte, unescape_byte_str, unescape_c_str, unescape_char,
-    unescape_str,
-};
-
-use crate::{
-    Edition,
-    SyntaxKind::{self, *},
-    T,
-};
-
-pub struct LexedStr<'a> {
-    text: &'a str,
-    kind: Vec<SyntaxKind>,
-    start: Vec<u32>,
-    error: Vec<LexError>,
-}
-
-struct LexError {
-    msg: String,
-    token: u32,
-}
-
-impl<'a> LexedStr<'a> {
-    pub fn new(edition: Edition, text: &'a str) -> LexedStr<'a> {
-        let _p = tracing::info_span!("LexedStr::new").entered();
-        let mut conv = Converter::new(edition, text);
-        if let Ok(script) = crate::frontmatter::ScriptSource::parse(text) {
-            if let Some(shebang) = script.shebang_span() {
-                conv.push(SHEBANG, shebang.end - shebang.start, Vec::new());
-            }
-            if script.frontmatter().is_some() {
-                conv.push(FRONTMATTER, script.content_span().start - conv.offset, Vec::new());
-            }
-        } else if let Some(shebang_len) = rustc_lexer::strip_shebang(text) {
-            // Leave error reporting to `rustc_lexer`
-            conv.push(SHEBANG, shebang_len, Vec::new());
+fn push(&mut self, kind: SyntaxKind, len: usize, errors: Vec<String>) {
+    self.res.push(kind, self.offset);
+    self.offset += len;
+
+    for msg in errors {
+        if !msg.is_empty() {
+            self.res.error.push(LexError { msg, token: self.res.len() as u32 });
         }
-
-        // Re-create the tokenizer from scratch every token because `GuardedStrPrefix` is one token in the lexer
-        // but we want to split it to two in edition <2024.
-        while let Some(token) =
-            rustc_lexer::tokenize(&text[conv.offset..], rustc_lexer::FrontmatterAllowed::No).next()
-        {
-            let token_text = &text[conv.offset..][..token.len as usize];
-
-            conv.extend_token(&token.kind, token_text);
-        }
-
-        conv.finalize_with_eof()
-    }
-
-    pub fn single_token(edition: Edition, text: &'a str) -> Option<(SyntaxKind, Option<String>)> {
-        if text.is_empty() {
-            return None;
-        }
-
-        let token = rustc_lexer::tokenize(text, rustc_lexer::FrontmatterAllowed::No).next()?;
-        if token.len as usize != text.len() {
-            return None;
-        }
-
-        let mut conv = Converter::new(edition, text);
-        conv.extend_token(&token.kind, text);
-        match &*conv.res.kind {
-            [kind] => Some((*kind, conv.res.error.pop().map(|it| it.msg))),
-            _ => None,
-        }
-    }
-
-    pub fn as_str(&self) -> &str {
-        self.text
-    }
-
-    pub fn len(&self) -> usize {
-        self.kind.len() - 1
-    }
-
-    pub fn is_empty(&self) -> bool {
-        self.len() == 0
-    }
-
-    pub fn kind(&self, i: usize) -> SyntaxKind {
-        assert!(i < self.len());
-        self.kind[i]
-    }
-
-    pub fn text(&self, i: usize) -> &str {
-        self.range_text(i..i + 1)
-    }
-
-    pub fn range_text(&self, r: ops::Range<usize>) -> &str {
-        assert!(r.start < r.end && r.end <= self.len());
-        let lo = self.start[r.start] as usize;
-        let hi = self.start[r.end] as usize;
-        &self.text[lo..hi]
-    }
-
-    // Naming is hard.
-    pub fn text_range(&self, i: usize) -> ops::Range<usize> {
-        assert!(i < self.len());
-        let lo = self.start[i] as usize;
-        let hi = self.start[i + 1] as usize;
-        lo..hi
-    }
-    pub fn text_start(&self, i: usize) -> usize {
-        assert!(i <= self.len());
-        self.start[i] as usize
-    }
-    pub fn text_len(&self, i: usize) -> usize {
-        assert!(i < self.len());
-        let r = self.text_range(i);
-        r.end - r.start
-    }
-
-    pub fn error(&self, i: usize) -> Option<&str> {
-        assert!(i < self.len());
-        let err = self.error.binary_search_by_key(&(i as u32), |i| i.token).ok()?;
-        Some(self.error[err].msg.as_str())
-    }
-
-    pub fn errors(&self) -> impl Iterator<Item = (usize, &str)> + '_ {
-        self.error.iter().map(|it| (it.token as usize, it.msg.as_str()))
-    }
-
-    fn push(&mut self, kind: SyntaxKind, offset: usize) {
-        self.kind.push(kind);
-        self.start.push(offset as u32);
     }
 }
 
-struct Converter<'a> {
-    res: LexedStr<'a>,
-    offset: usize,
-    edition: Edition,
-}
+fn extend_token(&mut self, kind: &rustc_lexer::TokenKind, mut token_text: &str) {
+    // A note on an intended tradeoff:
+    // We drop some useful information here (see patterns with double dots `..`)
+    // Storing that info in `SyntaxKind` is not possible due to its layout requirements of
+    // being `u16` that come from `rowan::SyntaxKind`.
+    let mut errors: Vec<String> = vec![];
 
-impl<'a> Converter<'a> {
-    fn new(edition: Edition, text: &'a str) -> Self {
-        Self {
-            res: LexedStr { text, kind: Vec::new(), start: Vec::new(), error: Vec::new() },
-            offset: 0,
-            edition,
-        }
-    }
-
-    /// Check for likely unterminated string by analyzing STRING token content
-    fn has_likely_unterminated_string(&self) -> bool {
-        let Some(last_idx) = self.res.kind.len().checked_sub(1) else { return false };
-
-        for i in (0..=last_idx).rev().take(5) {
-            if self.res.kind[i] == STRING {
-                let start = self.res.start[i] as usize;
-                let end = self.res.start.get(i + 1).map(|&s| s as usize).unwrap_or(self.offset);
-                let content = &self.res.text[start..end];
-
-                if content.contains('(') && (content.contains("//") || content.contains(";\n")) {
-                    return true;
-                }
-            }
-        }
-        false
-    }
-
-    fn finalize_with_eof(mut self) -> LexedStr<'a> {
-        self.res.push(EOF, self.offset);
-        self.res
-    }
-
-    fn push(&mut self, kind: SyntaxKind, len: usize, errors: Vec<String>) {
-        self.res.push(kind, self.offset);
-        self.offset += len;
-
-        for msg in errors {
-            if !msg.is_empty() {
-                self.res.error.push(LexError { msg, token: self.res.len() as u32 });
-            }
-        }
-    }
-
-    fn extend_token(&mut self, kind: &rustc_lexer::TokenKind, mut token_text: &str) {
-        // A note on an intended tradeoff:
-        // We drop some useful information here (see patterns with double dots `..`)
-        // Storing that info in `SyntaxKind` is not possible due to its layout requirements of
-        // being `u16` that come from `rowan::SyntaxKind`.
-        let mut errors: Vec<String> = vec![];
-
-        let syntax_kind = {
+    let syntax_kind = {
             match kind {
                 rustc_lexer::TokenKind::LineComment { doc_style: _ } => COMMENT,
                 rustc_lexer::TokenKind::BlockComment { doc_style: _, terminated } => {
             }
         };
 
-        self.push(syntax_kind, token_text.len(), errors);
-    }
+    self.push(syntax_kind, token_text.len(), errors);
+}
 
-    fn extend_literal(&mut self, len: usize, kind: &rustc_lexer::LiteralKind) {
-        let invalid_raw_msg = String::from("Invalid raw string literal");
+fn extend_literal(&mut self, len: usize, kind: &rustc_lexer::LiteralKind) {
+    let invalid_raw_msg = String::from("Invalid raw string literal");
 
-        let mut errors = vec![];
-        let mut no_end_quote = |c: char, kind: &str| {
+    let mut errors = vec![];
+    let mut no_end_quote = |c: char, kind: &str| {
             errors.push(format!("Missing trailing `{c}` symbol to terminate the {kind} literal"));
         };
 
-        let syntax_kind = match *kind {
+    let syntax_kind = match *kind {
             rustc_lexer::LiteralKind::Int { empty_int, base: _ } => {
                 if empty_int {
                     errors.push("Missing digits after the integer base prefix".into());
             }
         };
 
-        self.push(syntax_kind, len, errors);
-    }
+    self.push(syntax_kind, len, errors);
 }
 
 fn err_to_msg(error: EscapeError, mode: Mode) -> String {
     .into()
 }
 
-//! See [`Input`].
-
 use crate::SyntaxKind;
 
 #[allow(non_camel_case_types)]
             contextual_kind: Vec::with_capacity(capacity),
         }
     }
+
     #[inline]
     pub fn push(&mut self, kind: SyntaxKind) {
         self.push_impl(kind, SyntaxKind::EOF)
     }
+
     #[inline]
     pub fn push_ident(&mut self, contextual_kind: SyntaxKind) {
         self.push_impl(SyntaxKind::IDENT, contextual_kind)
     }
+
     /// Sets jointness for the last token we've pushed.
     ///
     /// This is a separate API rather than an argument to the `push` to make it
         let (idx, b_idx) = self.bit_index(n);
         self.joint[idx] |= 1 << b_idx;
     }
+
     #[inline]
     fn push_impl(&mut self, kind: SyntaxKind, contextual_kind: SyntaxKind) {
         let idx = self.len();
     pub(crate) fn kind(&self, idx: usize) -> SyntaxKind {
         self.kind.get(idx).copied().unwrap_or(SyntaxKind::EOF)
     }
+
     pub(crate) fn contextual_kind(&self, idx: usize) -> SyntaxKind {
         self.contextual_kind.get(idx).copied().unwrap_or(SyntaxKind::EOF)
     }
+
     pub(crate) fn is_joint(&self, n: usize) -> bool {
         let (idx, b_idx) = self.bit_index(n);
         self.joint[idx] & (1 << b_idx) != 0
         let b_idx = n % (bits::BITS as usize);
         (idx, b_idx)
     }
+
     fn len(&self) -> usize {
         self.kind.len()
     }
     expect_file![p].assert_eq(&actual)
 }
 
-//! The Rust parser.
-//!
-//! NOTE: The crate is undergoing refactors, don't believe everything the docs
-//! say :-)
-//!
-//! The parser doesn't know about concrete representation of tokens and syntax
-//! trees. Abstract [`TokenSource`] and [`TreeSink`] traits are used instead. As
-//! a consequence, this crate does not contain a lexer.
-//!
-//! The [`Parser`] struct from the [`parser`] module is a cursor into the
-//! sequence of tokens.  Parsing routines use [`Parser`] to inspect current
-//! state and advance the parsing.
-//!
-//! The actual parsing happens in the [`grammar`] module.
-//!
-//! Tests for this crate live in the `syntax` crate.
-//!
-//! [`Parser`]: crate::parser::Parser
-
-#![allow(rustdoc::private_intra_doc_links)]
-#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
+#
+#
 
 #[cfg(not(feature = "in-rust-tree"))]
 extern crate ra_ap_rustc_lexer as rustc_lexer;
     }
 }
 
-//! This module provides a way to construct a `File`.
-//! It is intended to be completely decoupled from the
-//! parser, so as to allow to evolve the tree representation
-//! and the parser algorithm independently.
 use std::mem;
 
 use crate::{
 
 impl Event {
     pub(crate) fn tombstone() -> Self {
-        Event::Start { kind: TOMBSTONE, forward_parent: None }
+        Event::Start {
+            kind: TOMBSTONE,
+            forward_parent: None,
+        }
     }
 }
 
     res
 }
 
-//! This is the actual "grammar" of the Rust language.
-//!
-//! Each function in this module and its children corresponds
-//! to a production of the formal grammar. Submodules roughly
-//! correspond to different *areas* of the grammar. By convention,
-//! each submodule starts with `use super::*` import and exports
-//! "public" productions via `pub(super)`.
-//!
-//! See docs for [`Parser`](super::parser::Parser) to learn about API,
-//! available to the grammar, and see docs for [`Event`](super::event::Event)
-//! to learn how this actually manages to produce parse trees.
-//!
-//! Code in this module also contains inline tests, which start with
-//! `// test name-of-the-test` comment and look like this:
-//!
-//! ```text
-//! // test function_with_zero_parameters
-//! // fn foo() {}
-//! ```
-//!
-//! After adding a new inline-test, run `cargo test -p xtask` to
-//! extract it as a standalone text-fixture into
-//! `crates/syntax/test_data/parser/`, and run `cargo test` once to
-//! create the "gold" value.
-//!
-//! Coding convention: rules like `where_clause` always produce either a
-//! node or an error, rules like `opt_where_clause` may produce nothing.
-//! Non-opt rules typically start with `assert!(p.at(FIRST_TOKEN))`, the
-//! caller is responsible for branching on the first token.
-
 mod attributes;
 mod expressions;
 mod generic_args;
 
 pub(crate) mod entry {
     use super::*;
-
     pub(crate) mod prefix {
         use super::*;
-
         pub(crate) fn vis(p: &mut Parser<'_>) {
             opt_visibility(p, false);
         }
-
         pub(crate) fn block(p: &mut Parser<'_>) {
             expressions::block_expr(p);
         }
-
         pub(crate) fn stmt(p: &mut Parser<'_>) {
             expressions::stmt(p, expressions::Semicolon::Forbidden);
         }
-
         pub(crate) fn pat(p: &mut Parser<'_>) {
             patterns::pattern_single(p);
         }
-
         pub(crate) fn pat_top(p: &mut Parser<'_>) {
             patterns::pattern(p);
         }
-
         pub(crate) fn ty(p: &mut Parser<'_>) {
             types::type_(p);
         }
             attributes::meta(p);
         }
     }
-
     pub(crate) mod top {
         use super::*;
-
         pub(crate) fn source_file(p: &mut Parser<'_>) {
             let m = p.start();
             // test frontmatter
             items::mod_contents(p, false);
             m.complete(p, SOURCE_FILE);
         }
-
         pub(crate) fn macro_stmts(p: &mut Parser<'_>) {
             let m = p.start();
 
 
             m.complete(p, MACRO_STMTS);
         }
-
         pub(crate) fn macro_items(p: &mut Parser<'_>) {
             let m = p.start();
             items::mod_contents(p, false);
             m.complete(p, MACRO_ITEMS);
         }
-
         pub(crate) fn pattern(p: &mut Parser<'_>) {
             let m = p.start();
             patterns::pattern(p);
             }
             m.complete(p, ERROR);
         }
-
         pub(crate) fn type_(p: &mut Parser<'_>) {
             let m = p.start();
             types::type_(p);
             }
             m.complete(p, ERROR);
         }
-
         pub(crate) fn expr(p: &mut Parser<'_>) {
             let m = p.start();
             expressions::expr(p);
             }
             m.complete(p, ERROR);
         }
-
         pub(crate) fn meta_item(p: &mut Parser<'_>) {
             let m = p.start();
             attributes::meta(p);
     }
 }
 
-const PATH_NAME_REF_KINDS: TokenSet =
-    TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self]]);
+const PATH_NAME_REF_KINDS: TokenSet = TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self]]);
 
 fn name_ref_mod_path(p: &mut Parser<'_>) {
     if p.at_ts(PATH_NAME_REF_KINDS) {
     }
 }
 
-const PATH_NAME_REF_OR_INDEX_KINDS: TokenSet =
-    PATH_NAME_REF_KINDS.union(TokenSet::new(&[INT_NUMBER]));
+const PATH_NAME_REF_OR_INDEX_KINDS: TokenSet = PATH_NAME_REF_KINDS.union(TokenSet::new(&[INT_NUMBER]));
 
 fn name_ref_mod_path_or_index(p: &mut Parser<'_>) {
     if p.at_ts(PATH_NAME_REF_OR_INDEX_KINDS) {
     p.expect(ket);
 }
 
-//! See [`Parser`].
-
 use std::cell::Cell;
 
 use drop_bomb::DropBomb;
     }
 }
 
-//! See [`Output`]
-
 use crate::SyntaxKind;
 
 /// Output of the parser -- a DFS traversal of a concrete syntax tree.
 
 #[derive(Debug)]
 pub enum Step<'a> {
-    Token { kind: SyntaxKind, n_input_tokens: u8 },
-    FloatSplit { ends_in_dot: bool },
-    Enter { kind: SyntaxKind },
+    Token {
+        kind: SyntaxKind,
+        n_input_tokens: u8,
+    },
+    FloatSplit {
+        ends_in_dot: bool,
+    },
+    Enter {
+        kind: SyntaxKind,
+    },
     Exit,
-    Error { msg: &'a str },
+    Error {
+        msg: &'a str,
+    },
 }
 
 impl Output {
     const EVENT_MASK: u32 = 0b1;
+
     const TAG_MASK: u32 = 0x0000_00F0;
+
     const N_INPUT_TOKEN_MASK: u32 = 0x0000_FF00;
+
     const KIND_MASK: u32 = 0xFFFF_0000;
 
     const ERROR_SHIFT: u32 = Self::EVENT_MASK.trailing_ones();
+
     const TAG_SHIFT: u32 = Self::TAG_MASK.trailing_zeros();
+
     const N_INPUT_TOKEN_SHIFT: u32 = Self::N_INPUT_TOKEN_MASK.trailing_zeros();
+
     const KIND_SHIFT: u32 = Self::KIND_MASK.trailing_zeros();
 
     const TOKEN_EVENT: u8 = 0;
+
     const ENTER_EVENT: u8 = 1;
+
     const EXIT_EVENT: u8 = 2;
+
     const SPLIT_EVENT: u8 = 3;
 
     pub fn iter(&self) -> impl Iterator<Item = Step<'_>> {
     }
 }
 
-//! Defines [`SyntaxKind`] -- a fieldless enum of all possible syntactic
-//! constructs of the Rust language.
-
 #[rustfmt::skip]
 mod generated;
 
     #[inline]
     fn from(d: u16) -> SyntaxKind {
         assert!(d <= (SyntaxKind::__LAST as u16));
-        unsafe { std::mem::transmute::<u16, SyntaxKind>(d) }
+        unsafe {
+            std::mem::transmute::<u16, SyntaxKind>(d)
+        }
     }
 }
 
     true
 }
 
-pub(super) const USE_TREE_LIST_RECOVERY_SET: TokenSet =
-    TokenSet::new(&[T![;], T![,], T![.], T![ident]]).union(ITEM_RECOVERY_SET);
+pub(super) const USE_TREE_LIST_RECOVERY_SET: TokenSet = TokenSet::new(&[T![;], T![,], T![.], T![ident]]).union(ITEM_RECOVERY_SET);
 
 pub(super) const USE_TREE_LIST_FIRST_SET: TokenSet = TokenSet::new(&[T!['{'], T![ident]]);
 
     if [T![#], T![>], T![const]].contains(&p.nth(1)) {
         return true;
     }
-    ([LIFETIME_IDENT, IDENT].contains(&p.nth(1)))
-        && ([T![>], T![,], T![:], T![=]].contains(&p.nth(2)))
+    ([LIFETIME_IDENT, IDENT].contains(&p.nth(1))) && ([T![>], T![,], T![:], T![=]].contains(&p.nth(2)))
 }
 
 // test_err impl_type
         // }
         generic_params::opt_where_clause(p);
     }
+
     // test_err static_where_clause
     // static C: u32 = 0
     // where i32: Copy;
-
     p.expect(T![;]);
     m.complete(p, if is_const { CONST } else { STATIC });
 }
     }
 }
 
-const TUPLE_FIELD_FIRST: TokenSet =
-    types::TYPE_FIRST.union(ATTRIBUTE_FIRST).union(VISIBILITY_FIRST);
+const TUPLE_FIELD_FIRST: TokenSet = types::TYPE_FIRST.union(ATTRIBUTE_FIRST).union(VISIBILITY_FIRST);
 
 // test_err tuple_field_list_recovery
 // struct S(struct S;
     // fn main() {
     //     let foo = macro_rules!();
     // }
-
     // test_err macro_rules_as_macro_name
     // macro_rules! {};
     // macro_rules! ()
 
 use super::*;
 
-// test expr_literals
-// fn foo() {
-//     let _ = true;
-//     let _ = false;
-//     let _ = 1;
-//     let _ = 2.0;
-//     let _ = b'a';
-//     let _ = 'b';
-//     let _ = "c";
-//     let _ = r"d";
-//     let _ = b"e";
-//     let _ = br"f";
-//     let _ = c"g";
-//     let _ = cr"h";
-// }
 pub(crate) const LITERAL_FIRST: TokenSet = TokenSet::new(&[
     T![true],
     T![false],
     Some(m.complete(p, LITERAL))
 }
 
-// E.g. for after the break in `if break {}`, this should not match
-pub(super) const ATOM_EXPR_FIRST: TokenSet =
-    LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[
+pub(super) const ATOM_EXPR_FIRST: TokenSet = LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[
         T!['('],
         T!['{'],
         T!['['],
         LIFETIME_IDENT,
     ]));
 
-pub(in crate::grammar) const EXPR_RECOVERY_SET: TokenSet =
-    TokenSet::new(&[T!['}'], T![')'], T![']'], T![,]]);
+pub(in crate::grammar) const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T!['}'], T![')'], T![']'], T![,]]);
 
 pub(super) fn atom_expr(
     p: &mut Parser<'_>,
         }
     }
     p.expect(T![')']);
-    m.complete(p, if saw_expr && !saw_comma { PAREN_EXPR } else { TUPLE_EXPR })
+    m.complete(
+        p,
+        if saw_expr && !saw_comma {
+            PAREN_EXPR
+        } else {
+            TUPLE_EXPR
+        },
+    )
 }
 
 // test builtin_expr
         }
         p.expect(T![')']);
         Some(m.complete(p, FORMAT_ARGS_EXPR))
-    } else if p.eat_contextual_kw(T![asm])
-        || p.eat_contextual_kw(T![global_asm])
-        || p.eat_contextual_kw(T![naked_asm])
-    {
+    } else if p.eat_contextual_kw(T![asm]) || p.eat_contextual_kw(T![global_asm]) || p.eat_contextual_kw(T![naked_asm]) {
         // test asm_kinds
         // fn foo() {
         //     builtin#asm("");
         // fn foo(){
         //     ;;;some_expr();;;;{;;;};;;;Ok(())
         // }
-
         // test nocontentexpr_after_item
         // fn simple_function() {
         //     enum LocalEnum {
     use Associativity::*;
     const NOT_AN_OP: (u8, SyntaxKind, Associativity) = (0, T![@], Left);
     match p.current() {
-        T![|] if p.at(T![||])  => (3,  T![||],  Left),
-        T![|] if p.at(T![|=])  => (1,  T![|=],  Right),
-        T![|]                  => (6,  T![|],   Left),
-        T![>] if p.at(T![>>=]) => (1,  T![>>=], Right),
-        T![>] if p.at(T![>>])  => (9,  T![>>],  Left),
-        T![>] if p.at(T![>=])  => (5,  T![>=],  Left),
-        T![>]                  => (5,  T![>],   Left),
-        T![=] if p.at(T![==])  => (5,  T![==],  Left),
-        T![=] if !p.at(T![=>]) => (1,  T![=],   Right),
-        T![<] if p.at(T![<=])  => (5,  T![<=],  Left),
-        T![<] if p.at(T![<<=]) => (1,  T![<<=], Right),
-        T![<] if p.at(T![<<])  => (9,  T![<<],  Left),
-        T![<]                  => (5,  T![<],   Left),
-        T![+] if p.at(T![+=])  => (1,  T![+=],  Right),
-        T![+]                  => (10, T![+],   Left),
-        T![^] if p.at(T![^=])  => (1,  T![^=],  Right),
-        T![^]                  => (7,  T![^],   Left),
-        T![%] if p.at(T![%=])  => (1,  T![%=],  Right),
-        T![%]                  => (11, T![%],   Left),
-        T![&] if p.at(T![&=])  => (1,  T![&=],  Right),
+        T![|] if p.at(T![||]) => (3, T![||], Left),
+        T![|] if p.at(T![|=]) => (1, T![|=], Right),
+        T![|] => (6, T![|], Left),
+        T![>] if p.at(T![>>=]) => (1, T![>>=], Right),
+        T![>] if p.at(T![>>]) => (9, T![>>], Left),
+        T![>] if p.at(T![>=]) => (5, T![>=], Left),
+        T![>] => (5, T![>], Left),
+        T![=] if p.at(T![==]) => (5, T![==], Left),
+        T![=] if !p.at(T![=>]) => (1, T![=], Right),
+        T![<] if p.at(T![<=]) => (5, T![<=], Left),
+        T![<] if p.at(T![<<=]) => (1, T![<<=], Right),
+        T![<] if p.at(T![<<]) => (9, T![<<], Left),
+        T![<] => (5, T![<], Left),
+        T![+] if p.at(T![+=]) => (1, T![+=], Right),
+        T![+] => (10, T![+], Left),
+        T![^] if p.at(T![^=]) => (1, T![^=], Right),
+        T![^] => (7, T![^], Left),
+        T![%] if p.at(T![%=]) => (1, T![%=], Right),
+        T![%] => (11, T![%], Left),
+        T![&] if p.at(T![&=]) => (1, T![&=], Right),
         // If you update this, remember to update `expr_let()` too.
-        T![&] if p.at(T![&&])  => (4,  T![&&],  Left),
-        T![&]                  => (8,  T![&],   Left),
-        T![/] if p.at(T![/=])  => (1,  T![/=],  Right),
-        T![/]                  => (11, T![/],   Left),
-        T![*] if p.at(T![*=])  => (1,  T![*=],  Right),
-        T![*]                  => (11, T![*],   Left),
-        T![.] if p.at(T![..=]) => (2,  T![..=], Left),
-        T![.] if p.at(T![..])  => (2,  T![..],  Left),
-        T![!] if p.at(T![!=])  => (5,  T![!=],  Left),
-        T![-] if p.at(T![-=])  => (1,  T![-=],  Right),
-        T![-]                  => (10, T![-],   Left),
-        T![as]                 => (12, T![as],  Left),
+        T![&] if p.at(T![&&]) => (4, T![&&], Left),
+        T![&] => (8, T![&], Left),
+        T![/] if p.at(T![/=]) => (1, T![/=], Right),
+        T![/] => (11, T![/], Left),
+        T![*] if p.at(T![*=]) => (1, T![*=], Right),
+        T![*] => (11, T![*], Left),
+        T![.] if p.at(T![..=]) => (2, T![..=], Left),
+        T![.] if p.at(T![..]) => (2, T![..], Left),
+        T![!] if p.at(T![!=]) => (5, T![!=], Left),
+        T![-] if p.at(T![-=]) => (1, T![-=], Right),
+        T![-] => (10, T![-], Left),
+        T![as] => (12, T![as], Left),
 
-        _                      => NOT_AN_OP
+        _ => NOT_AN_OP,
     }
 }
 
     Some((lhs, BlockLike::NotBlock))
 }
 
-const LHS_FIRST: TokenSet =
-    atom::ATOM_EXPR_FIRST.union(TokenSet::new(&[T![&], T![*], T![!], T![.], T![-], T![_]]));
+const LHS_FIRST: TokenSet = atom::ATOM_EXPR_FIRST.union(TokenSet::new(&[T![&], T![*], T![!], T![.], T![-], T![_]]));
 
 fn lhs(p: &mut Parser<'_>, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {
     let m;
 fn postfix_expr(
     p: &mut Parser<'_>,
     mut lhs: CompletedMarker,
-    // Calls are disallowed if the type is a block and we prefer statements because the call cannot be disambiguated from a tuple
-    // E.g. `while true {break}();` is parsed as
-    // `while true {break}; ();`
     mut block_like: BlockLike,
     mut allow_calls: bool,
 ) -> (CompletedMarker, BlockLike) {
 ])
 .union(types::TYPE_FIRST);
 
-// Despite its name, it can also be used for generic param list.
 const GENERIC_ARG_RECOVERY_SET: TokenSet = TokenSet::new(&[T![>], T![,]]);
 
 // test generic_arg
 
     // test_err invalid_question_for_type_trait_bound
     // fn f<T>() where T: ?for<> Sized {}
-
     if paths::is_use_path_start(p) {
         types::path_type_bounds(p, false);
         // test_err type_bounds_macro_call_recovery
 
 use super::*;
 
-pub(super) const PATTERN_FIRST: TokenSet =
-    expressions::LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[
+pub(super) const PATTERN_FIRST: TokenSet = expressions::LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[
         T![box],
         T![ref],
         T![mut],
 const PAT_TOP_FIRST: TokenSet = PATTERN_FIRST.union(TokenSet::new(&[T![|]]));
 
 /// Set of possible tokens at the start of a range pattern's end bound.
-const RANGE_PAT_END_FIRST: TokenSet =
-    expressions::LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[T![-], T![const]]));
+const RANGE_PAT_END_FIRST: TokenSet = expressions::LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[T![-], T![const]]));
 
 /// Parses a pattern list separated by pipes `|`.
 pub(crate) fn pattern(p: &mut Parser<'_>) {
     //         (..=2, _) => (),
     //     }
     // }
-
     if p.at(T![..=]) {
         let m = p.start();
         p.bump(T![..=]);
     //         1..2 => {}
     //     }
     // }
-
     // test dot_dot_pat
     // fn main() {
     //     let .. = ();
 }
 
 fn is_literal_pat_start(p: &Parser<'_>) -> bool {
-    p.at(T![-]) && (p.nth(1) == INT_NUMBER || p.nth(1) == FLOAT_NUMBER)
-        || p.at_ts(expressions::LITERAL_FIRST)
+    p.at(T![-]) && (p.nth(1) == INT_NUMBER || p.nth(1) == FLOAT_NUMBER) || p.at_ts(expressions::LITERAL_FIRST)
 }
 
 // test literal_pattern
     }
     p.expect(T![')']);
 
-    m.complete(p, if !has_comma && !has_rest && has_pat { PAREN_PAT } else { TUPLE_PAT })
+    m.complete(
+        p,
+        if !has_comma && !has_rest && has_pat {
+            PAREN_PAT
+        } else {
+            TUPLE_PAT
+        },
+    )
 }
 
 // test slice_pat
 
 use super::*;
 
-pub(super) const PATH_FIRST: TokenSet =
-    TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self], T![:], T![<]]);
+pub(super) const PATH_FIRST: TokenSet = TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self], T![:], T![<]]);
 
 pub(super) fn is_path_start(p: &Parser<'_>) -> bool {
     is_use_path_start(p) || p.at(T![<]) || p.at(T![Self])
     }
 }
 
-const EXPR_PATH_SEGMENT_RECOVERY_SET: TokenSet =
-    expressions::EXPR_RECOVERY_SET.union(items::ITEM_RECOVERY_SET);
+const EXPR_PATH_SEGMENT_RECOVERY_SET: TokenSet = expressions::EXPR_RECOVERY_SET.union(items::ITEM_RECOVERY_SET);
+
 const TYPE_PATH_SEGMENT_RECOVERY_SET: TokenSet = types::TYPE_RECOVERY_SET;
 
 fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) -> Option<CompletedMarker> {
     }
 }
 
-//! A bit-set of `SyntaxKind`s.
-
 use crate::SyntaxKind;
 
 /// A bit-set of `SyntaxKind`s
     assert!(!ts.contains(PLUS));
 }
 
-//! Shortcuts that span lexer/parser abstraction.
-//!
-//! The way Rust works, parser doesn't necessary parse text, and you might
-//! tokenize text without parsing it further. So, it makes sense to keep
-//! abstract token parsing, and string tokenization as completely separate
-//! layers.
-//!
-//! However, often you do parse text into syntax trees and the glue code for
-//! that needs to live somewhere. Rather than putting it to lexer or parser, we
-//! use a separate shortcuts module for that.
-
 use std::mem;
 
 use crate::{
 
 #[derive(Debug)]
 pub enum StrStep<'a> {
-    Token { kind: SyntaxKind, text: &'a str },
-    Enter { kind: SyntaxKind },
+    Token {
+        kind: SyntaxKind,
+        text: &'a str,
+    },
+    Enter {
+        kind: SyntaxKind,
+    },
     Exit,
-    Error { msg: &'a str, pos: usize },
+    Error {
+        msg: &'a str,
+        pos: usize,
+    },
 }
 
 impl LexedStr<'_> {
 }
 
 // Copied from https://github.com/rust-lang/cargo/blob/367fd9f213750cd40317803dd0a5a3ce3f0c676d/src/cargo/util/frontmatter.rs
-#![expect(dead_code)] // avoid editing
-#![expect(unreachable_pub)] // avoid editing
-#![expect(clippy::useless_format)] // avoid editing
+#
+// avoid editing
+#
+// avoid editing
+#
+// avoid editing
 
 type Span = std::ops::Range<usize>;
 
     //
     // Note that this set is stable (ie, it doesn't change with different
     // Unicode versions), so it's ok to just hard-code the values.
-
     matches!(
         c,
         // End-of-line characters
     //
     // Note that this set is stable (ie, it doesn't change with different
     // Unicode versions), so it's ok to just hard-code the values.
-
     matches!(
         c,
         // Horizontal space characters
 
 impl FrontmatterError {
     pub fn new(message: impl Into<String>, span: Span) -> Self {
-        Self { message: message.into(), primary_span: span, visible_spans: Vec::new() }
+        Self {
+            message: message.into(),
+            primary_span: span,
+            visible_spans: Vec::new(),
+        }
     }
 
     pub fn push_visible_span(mut self, span: Span) -> Self {
     expect.assert_eq(&parsed)
 }
 
-//! Generated by `cargo xtask codegen grammar`, do not edit by hand.
-
-#![allow(bad_style, missing_docs, unreachable_pub)]
+#
 use crate::Edition;
 #[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
 #[derive(Debug)]
             TRY_KW => "try",
         }
     }
+
     #[doc = r" Checks whether this syntax kind is a strict keyword for the given edition."]
     #[doc = r" Strict keywords are identifiers that are always considered keywords."]
     pub fn is_strict_keyword(self, edition: Edition) -> bool {
             _ => false,
         }
     }
+
     #[doc = r" Checks whether this syntax kind is a weak keyword for the given edition."]
     #[doc = r" Weak keywords are identifiers that are considered keywords only in certain contexts."]
     pub fn is_contextual_keyword(self, edition: Edition) -> bool {
             _ => false,
         }
     }
+
     #[doc = r" Checks whether this syntax kind is a strict or weak keyword for the given edition."]
     pub fn is_keyword(self, edition: Edition) -> bool {
         matches!(
             _ => false,
         }
     }
+
     pub fn is_punct(self) -> bool {
         matches!(
             self,
                 | SHREQ
         )
     }
+
     pub fn is_literal(self) -> bool {
         matches!(self, BYTE | BYTE_STRING | CHAR | C_STRING | FLOAT_NUMBER | INT_NUMBER | STRING)
     }
+
     pub fn from_keyword(ident: &str, edition: Edition) -> Option<SyntaxKind> {
         let kw = match ident {
             "Self" => SELF_TYPE_KW,
         };
         Some(kw)
     }
+
     pub fn from_contextual_keyword(ident: &str, edition: Edition) -> Option<SyntaxKind> {
         let kw = match ident {
             "asm" => ASM_KW,
         };
         Some(kw)
     }
+
     pub fn from_char(c: char) -> Option<SyntaxKind> {
         let tok = match c {
             '$' => DOLLAR,
         Some(tok)
     }
 }
+
 #[macro_export]
 macro_rules ! T_ { [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [@] => { $ crate :: SyntaxKind :: AT } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOT2 } ; [...] => { $ crate :: SyntaxKind :: DOT3 } ; [..=] => { $ crate :: SyntaxKind :: DOT2EQ } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [::] => { $ crate :: SyntaxKind :: COLON2 } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ2 } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [->] => { $ crate :: SyntaxKind :: THIN_ARROW } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [>=] => { $ crate :: SyntaxKind :: GTEQ } ; [+=] => { $ crate :: SyntaxKind :: PLUSEQ } ; [-=] => { $ crate :: SyntaxKind :: MINUSEQ } ; [|=] => { $ crate :: SyntaxKind :: PIPEEQ } ; [&=] => { $ crate :: SyntaxKind :: AMPEQ } ; [^=] => { $ crate :: SyntaxKind :: CARETEQ } ; [/=] => { $ crate :: SyntaxKind :: SLASHEQ } ; [*=] => { $ crate :: SyntaxKind :: STAREQ } ; [%=] => { $ crate :: SyntaxKind :: PERCENTEQ } ; [&&] => { $ crate :: SyntaxKind :: AMP2 } ; [||] => { $ crate :: SyntaxKind :: PIPE2 } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [<<=] => { $ crate :: SyntaxKind :: SHLEQ } ; [>>=] => { $ crate :: SyntaxKind :: SHREQ } ; [Self] => { $ crate :: SyntaxKind :: SELF_TYPE_KW } ; [abstract] => { $ crate :: SyntaxKind :: ABSTRACT_KW } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [become] => { $ crate :: SyntaxKind :: BECOME_KW } ; [box] => { $ crate :: SyntaxKind :: BOX_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [const] => { $ crate :: SyntaxKind :: CONST_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [crate] => { $ crate :: SyntaxKind :: CRATE_KW } ; [do] => { $ crate :: SyntaxKind :: DO_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [enum] => { $ crate :: SyntaxKind :: ENUM_KW } ; [extern] => { $ crate :: SyntaxKind :: EXTERN_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [final] => { $ crate :: SyntaxKind :: FINAL_KW } ; [fn] => { $ crate :: SyntaxKind :: FN_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [impl] => { $ crate :: SyntaxKind :: IMPL_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [loop] => { $ crate :: SyntaxKind :: LOOP_KW } ; [macro] => { $ crate :: SyntaxKind :: MACRO_KW } ; [match] => { $ crate :: SyntaxKind :: MATCH_KW } ; [mod] => { $ crate :: SyntaxKind :: MOD_KW } ; [move] => { $ crate :: SyntaxKind :: MOVE_KW } ; [mut] => { $ crate :: SyntaxKind :: MUT_KW } ; [override] => { $ crate :: SyntaxKind :: OVERRIDE_KW } ; [priv] => { $ crate :: SyntaxKind :: PRIV_KW } ; [pub] => { $ crate :: SyntaxKind :: PUB_KW } ; [ref] => { $ crate :: SyntaxKind :: REF_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [self] => { $ crate :: SyntaxKind :: SELF_KW } ; [static] => { $ crate :: SyntaxKind :: STATIC_KW } ; [struct] => { $ crate :: SyntaxKind :: STRUCT_KW } ; [super] => { $ crate :: SyntaxKind :: SUPER_KW } ; [trait] => { $ crate :: SyntaxKind :: TRAIT_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [type] => { $ crate :: SyntaxKind :: TYPE_KW } ; [typeof] => { $ crate :: SyntaxKind :: TYPEOF_KW } ; [unsafe] => { $ crate :: SyntaxKind :: UNSAFE_KW } ; [unsized] => { $ crate :: SyntaxKind :: UNSIZED_KW } ; [use] => { $ crate :: SyntaxKind :: USE_KW } ; [virtual] => { $ crate :: SyntaxKind :: VIRTUAL_KW } ; [where] => { $ crate :: SyntaxKind :: WHERE_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [yield] => { $ crate :: SyntaxKind :: YIELD_KW } ; [asm] => { $ crate :: SyntaxKind :: ASM_KW } ; [att_syntax] => { $ crate :: SyntaxKind :: ATT_SYNTAX_KW } ; [auto] => { $ crate :: SyntaxKind :: AUTO_KW } ; [builtin] => { $ crate :: SyntaxKind :: BUILTIN_KW } ; [clobber_abi] => { $ crate :: SyntaxKind :: CLOBBER_ABI_KW } ; [default] => { $ crate :: SyntaxKind :: DEFAULT_KW } ; [dyn] => { $ crate :: SyntaxKind :: DYN_KW } ; [format_args] => { $ crate :: SyntaxKind :: FORMAT_ARGS_KW } ; [global_asm] => { $ crate :: SyntaxKind :: GLOBAL_ASM_KW } ; [inlateout] => { $ crate :: SyntaxKind :: INLATEOUT_KW } ; [inout] => { $ crate :: SyntaxKind :: INOUT_KW } ; [label] => { $ crate :: SyntaxKind :: LABEL_KW } ; [lateout] => { $ crate :: SyntaxKind :: LATEOUT_KW } ; [macro_rules] => { $ crate :: SyntaxKind :: MACRO_RULES_KW } ; [may_unwind] => { $ crate :: SyntaxKind :: MAY_UNWIND_KW } ; [naked_asm] => { $ crate :: SyntaxKind :: NAKED_ASM_KW } ; [nomem] => { $ crate :: SyntaxKind :: NOMEM_KW } ; [noreturn] => { $ crate :: SyntaxKind :: NORETURN_KW } ; [nostack] => { $ crate :: SyntaxKind :: NOSTACK_KW } ; [offset_of] => { $ crate :: SyntaxKind :: OFFSET_OF_KW } ; [options] => { $ crate :: SyntaxKind :: OPTIONS_KW } ; [out] => { $ crate :: SyntaxKind :: OUT_KW } ; [preserves_flags] => { $ crate :: SyntaxKind :: PRESERVES_FLAGS_KW } ; [pure] => { $ crate :: SyntaxKind :: PURE_KW } ; [raw] => { $ crate :: SyntaxKind :: RAW_KW } ; [readonly] => { $ crate :: SyntaxKind :: READONLY_KW } ; [safe] => { $ crate :: SyntaxKind :: SAFE_KW } ; [sym] => { $ crate :: SyntaxKind :: SYM_KW } ; [union] => { $ crate :: SyntaxKind :: UNION_KW } ; [yeet] => { $ crate :: SyntaxKind :: YEET_KW } ; [async] => { $ crate :: SyntaxKind :: ASYNC_KW } ; [await] => { $ crate :: SyntaxKind :: AWAIT_KW } ; [dyn] => { $ crate :: SyntaxKind :: DYN_KW } ; [gen] => { $ crate :: SyntaxKind :: GEN_KW } ; [try] => { $ crate :: SyntaxKind :: TRY_KW } ; [lifetime_ident] => { $ crate :: SyntaxKind :: LIFETIME_IDENT } ; [int_number] => { $ crate :: SyntaxKind :: INT_NUMBER } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [string] => { $ crate :: SyntaxKind :: STRING } ; [shebang] => { $ crate :: SyntaxKind :: SHEBANG } ; [frontmatter] => { $ crate :: SyntaxKind :: FRONTMATTER } ; }
+
 impl ::core::marker::Copy for SyntaxKind {}
+
 impl ::core::clone::Clone for SyntaxKind {
     #[inline]
-    fn clone(&self) -> Self { *self }
+    fn clone(&self) -> Self {
+        *self
+    }
 }
+
 impl ::core::cmp::PartialEq for SyntaxKind {
     #[inline]
-    fn eq(&self, other: &Self) -> bool { (*self as u16) == (*other as u16) }
+    fn eq(&self, other: &Self) -> bool {
+        (*self as u16) == (*other as u16)
+    }
 }
+
 impl ::core::cmp::Eq for SyntaxKind {}
+
 impl ::core::cmp::PartialOrd for SyntaxKind {
     #[inline]
     fn partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering> {
         Some(self.cmp(other))
     }
 }
+
 impl ::core::cmp::Ord for SyntaxKind {
     #[inline]
-    fn cmp(&self, other: &Self) -> core::cmp::Ordering { (*self as u16).cmp(&(*other as u16)) }
+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
+        (*self as u16).cmp(&(*other as u16))
+    }
 }
+
 impl ::core::hash::Hash for SyntaxKind {
     fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
         ::core::mem::discriminant(self).hash(state);
