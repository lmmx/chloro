---
source: chloro-core/tests/conformance/roundtrip.rs
expression: cleaned_diff
---
+//! Adapted from a `rustc` test, which can be found at
+//! https://github.com/rust-lang/rust/blob/6d34ec18c7d7e574553f6347ecf08e1e1c45c13d/src/test/run-pass/weird-exprs.rs.
+//!
+//! Reported to rust-analyzer in https://github.com/rust-lang/rust-analyzer/issues/290
+//! docs
+//! See [`Input`].
+//! The Rust parser.
+//!
+//! NOTE: The crate is undergoing refactors, don't believe everything the docs
+//! say :-)
+//!
+//! The parser doesn't know about concrete representation of tokens and syntax
+//! trees. Abstract [`TokenSource`] and [`TreeSink`] traits are used instead. As
+//! a consequence, this crate does not contain a lexer.
+//!
+//! The [`Parser`] struct from the [`parser`] module is a cursor into the
+//! sequence of tokens.  Parsing routines use [`Parser`] to inspect current
+//! state and advance the parsing.
+//!
+//! The actual parsing happens in the [`grammar`] module.
+//!
+//! Tests for this crate live in the `syntax` crate.
+//!
+//! [`Parser`]: crate::parser::Parser
+//! This module provides a way to construct a `File`.
+//! It is intended to be completely decoupled from the
+//! parser, so as to allow to evolve the tree representation
+//! and the parser algorithm independently.
+//! This is the actual "grammar" of the Rust language.
+//!
+//! Each function in this module and its children corresponds
+//! to a production of the formal grammar. Submodules roughly
+//! correspond to different *areas* of the grammar. By convention,
+//! each submodule starts with `use super::*` import and exports
+//! "public" productions via `pub(super)`.
+//!
+//! See docs for [`Parser`](super::parser::Parser) to learn about API,
+//! available to the grammar, and see docs for [`Event`](super::event::Event)
+//! to learn how this actually manages to produce parse trees.
+//!
+//! Code in this module also contains inline tests, which start with
+//! `// test name-of-the-test` comment and look like this:
+//!
+//! ```text
+//! // test function_with_zero_parameters
+//! // fn foo() {}
+//! ```
+//!
+//! After adding a new inline-test, run `cargo test -p xtask` to
+//! extract it as a standalone text-fixture into
+//! `crates/syntax/test_data/parser/`, and run `cargo test` once to
+//! create the "gold" value.
+//!
+//! Coding convention: rules like `where_clause` always produce either a
+//! node or an error, rules like `opt_where_clause` may produce nothing.
+//! Non-opt rules typically start with `assert!(p.at(FIRST_TOKEN))`, the
+//! caller is responsible for branching on the first token.
+//! See [`Parser`].
+//! See [`Output`]
+//! Defines [`SyntaxKind`] -- a fieldless enum of all possible syntactic
+//! constructs of the Rust language.
+//! A bit-set of `SyntaxKind`s.
+//! Shortcuts that span lexer/parser abstraction.
+//!
+//! The way Rust works, parser doesn't necessary parse text, and you might
+//! tokenize text without parsing it further. So, it makes sense to keep
+//! abstract token parsing, and string tokenization as completely separate
+//! layers.
+//!
+//! However, often you do parse text into syntax trees and the glue code for
+//! that needs to live somewhere. Rather than putting it to lexer or parser, we
+//! use a separate shortcuts module for that.
+//! Generated by `cargo xtask codegen grammar`, do not edit by hand.
+
 mod ok {
     use crate::tests::*;
     #[test]
         run_and_expect_no_errors("test_data/parser/inline/ok/arb_self_types.rs");
     }
     #[test]
-    fn arg_with_attr() { run_and_expect_no_errors("test_data/parser/inline/ok/arg_with_attr.rs"); }
+    fn arg_with_attr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/arg_with_attr.rs");
+    }
     #[test]
-    fn array_attrs() { run_and_expect_no_errors("test_data/parser/inline/ok/array_attrs.rs"); }
+    fn array_attrs() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/array_attrs.rs");
+    }
     #[test]
-    fn array_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/array_expr.rs"); }
+    fn array_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/array_expr.rs");
+    }
     #[test]
-    fn array_type() { run_and_expect_no_errors("test_data/parser/inline/ok/array_type.rs"); }
+    fn array_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/array_type.rs");
+    }
     #[test]
-    fn as_precedence() { run_and_expect_no_errors("test_data/parser/inline/ok/as_precedence.rs"); }
+    fn as_precedence() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/as_precedence.rs");
+    }
     #[test]
-    fn asm_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/asm_expr.rs"); }
+    fn asm_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/asm_expr.rs");
+    }
     #[test]
-    fn asm_kinds() { run_and_expect_no_errors("test_data/parser/inline/ok/asm_kinds.rs"); }
+    fn asm_kinds() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/asm_kinds.rs");
+    }
     #[test]
-    fn asm_label() { run_and_expect_no_errors("test_data/parser/inline/ok/asm_label.rs"); }
+    fn asm_label() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/asm_label.rs");
+    }
     #[test]
     fn assoc_const_eq() {
         run_and_expect_no_errors("test_data/parser/inline/ok/assoc_const_eq.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/assoc_type_bound.rs");
     }
     #[test]
-    fn assoc_type_eq() { run_and_expect_no_errors("test_data/parser/inline/ok/assoc_type_eq.rs"); }
+    fn assoc_type_eq() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/assoc_type_eq.rs");
+    }
     #[test]
     fn async_trait_bound() {
         run_and_expect_no_errors("test_data/parser/inline/ok/async_trait_bound.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/attr_on_expr_stmt.rs");
     }
     #[test]
-    fn await_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/await_expr.rs"); }
+    fn await_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/await_expr.rs");
+    }
     #[test]
     fn bare_dyn_types_with_leading_lifetime() {
         run_and_expect_no_errors(
         );
     }
     #[test]
-    fn become_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/become_expr.rs"); }
+    fn become_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/become_expr.rs");
+    }
     #[test]
-    fn bind_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/bind_pat.rs"); }
+    fn bind_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/bind_pat.rs");
+    }
     #[test]
     fn binop_resets_statementness() {
         run_and_expect_no_errors("test_data/parser/inline/ok/binop_resets_statementness.rs");
     }
     #[test]
-    fn block() { run_and_expect_no_errors("test_data/parser/inline/ok/block.rs"); }
+    fn block() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/block.rs");
+    }
     #[test]
-    fn block_items() { run_and_expect_no_errors("test_data/parser/inline/ok/block_items.rs"); }
+    fn block_items() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/block_items.rs");
+    }
     #[test]
-    fn box_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/box_pat.rs"); }
+    fn box_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/box_pat.rs");
+    }
     #[test]
     fn break_ambiguity() {
         run_and_expect_no_errors("test_data/parser/inline/ok/break_ambiguity.rs");
     }
     #[test]
-    fn break_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/break_expr.rs"); }
+    fn break_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/break_expr.rs");
+    }
     #[test]
-    fn builtin_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/builtin_expr.rs"); }
+    fn builtin_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/builtin_expr.rs");
+    }
     #[test]
-    fn call_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/call_expr.rs"); }
+    fn call_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/call_expr.rs");
+    }
     #[test]
-    fn cast_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/cast_expr.rs"); }
+    fn cast_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/cast_expr.rs");
+    }
     #[test]
     fn closure_binder() {
         run_and_expect_no_errors("test_data/parser/inline/ok/closure_binder.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/closure_range_method_call.rs");
     }
     #[test]
-    fn const_arg() { run_and_expect_no_errors("test_data/parser/inline/ok/const_arg.rs"); }
+    fn const_arg() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/const_arg.rs");
+    }
     #[test]
     fn const_arg_block() {
         run_and_expect_no_errors("test_data/parser/inline/ok/const_arg_block.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/const_block_pat.rs");
     }
     #[test]
-    fn const_closure() { run_and_expect_no_errors("test_data/parser/inline/ok/const_closure.rs"); }
+    fn const_closure() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/const_closure.rs");
+    }
     #[test]
-    fn const_item() { run_and_expect_no_errors("test_data/parser/inline/ok/const_item.rs"); }
+    fn const_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/const_item.rs");
+    }
     #[test]
-    fn const_param() { run_and_expect_no_errors("test_data/parser/inline/ok/const_param.rs"); }
+    fn const_param() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/const_param.rs");
+    }
     #[test]
     fn const_param_default_expression() {
         run_and_expect_no_errors("test_data/parser/inline/ok/const_param_default_expression.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/const_where_clause.rs");
     }
     #[test]
-    fn continue_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/continue_expr.rs"); }
+    fn continue_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/continue_expr.rs");
+    }
     #[test]
-    fn crate_path() { run_and_expect_no_errors("test_data/parser/inline/ok/crate_path.rs"); }
+    fn crate_path() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/crate_path.rs");
+    }
     #[test]
     fn crate_visibility() {
         run_and_expect_no_errors("test_data/parser/inline/ok/crate_visibility.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/default_async_unsafe_fn.rs");
     }
     #[test]
-    fn default_item() { run_and_expect_no_errors("test_data/parser/inline/ok/default_item.rs"); }
+    fn default_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/default_item.rs");
+    }
     #[test]
     fn default_unsafe_item() {
         run_and_expect_no_errors("test_data/parser/inline/ok/default_unsafe_item.rs");
         );
     }
     #[test]
-    fn dot_dot_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/dot_dot_pat.rs"); }
+    fn dot_dot_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/dot_dot_pat.rs");
+    }
     #[test]
     fn dyn_trait_type() {
         run_and_expect_no_errors("test_data/parser/inline/ok/dyn_trait_type.rs");
         );
     }
     #[test]
-    fn effect_blocks() { run_and_expect_no_errors("test_data/parser/inline/ok/effect_blocks.rs"); }
+    fn effect_blocks() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/effect_blocks.rs");
+    }
     #[test]
     fn exclusive_range_pat() {
         run_and_expect_no_errors("test_data/parser/inline/ok/exclusive_range_pat.rs");
     }
     #[test]
-    fn expr_literals() { run_and_expect_no_errors("test_data/parser/inline/ok/expr_literals.rs"); }
+    fn expr_literals() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/expr_literals.rs");
+    }
     #[test]
     fn expression_after_block() {
         run_and_expect_no_errors("test_data/parser/inline/ok/expression_after_block.rs");
     }
     #[test]
-    fn extern_block() { run_and_expect_no_errors("test_data/parser/inline/ok/extern_block.rs"); }
+    fn extern_block() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/extern_block.rs");
+    }
     #[test]
-    fn extern_crate() { run_and_expect_no_errors("test_data/parser/inline/ok/extern_crate.rs"); }
+    fn extern_crate() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/extern_crate.rs");
+    }
     #[test]
     fn extern_crate_rename() {
         run_and_expect_no_errors("test_data/parser/inline/ok/extern_crate_rename.rs");
     }
     #[test]
-    fn field_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/field_expr.rs"); }
+    fn field_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/field_expr.rs");
+    }
     #[test]
-    fn fn_() { run_and_expect_no_errors("test_data/parser/inline/ok/fn_.rs"); }
+    fn fn_() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/fn_.rs");
+    }
     #[test]
-    fn fn_decl() { run_and_expect_no_errors("test_data/parser/inline/ok/fn_decl.rs"); }
+    fn fn_decl() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/fn_decl.rs");
+    }
     #[test]
-    fn fn_def_param() { run_and_expect_no_errors("test_data/parser/inline/ok/fn_def_param.rs"); }
+    fn fn_def_param() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/fn_def_param.rs");
+    }
     #[test]
     fn fn_pointer_param_ident_path() {
         run_and_expect_no_errors("test_data/parser/inline/ok/fn_pointer_param_ident_path.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/for_binder_bound.rs");
     }
     #[test]
-    fn for_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/for_expr.rs"); }
+    fn for_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/for_expr.rs");
+    }
     #[test]
     fn for_range_from() {
         run_and_expect_no_errors("test_data/parser/inline/ok/for_range_from.rs");
     }
     #[test]
-    fn for_type() { run_and_expect_no_errors("test_data/parser/inline/ok/for_type.rs"); }
+    fn for_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/for_type.rs");
+    }
     #[test]
-    fn frontmatter() { run_and_expect_no_errors("test_data/parser/inline/ok/frontmatter.rs"); }
+    fn frontmatter() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/frontmatter.rs");
+    }
     #[test]
     fn full_range_expr() {
         run_and_expect_no_errors("test_data/parser/inline/ok/full_range_expr.rs");
         );
     }
     #[test]
-    fn generic_arg() { run_and_expect_no_errors("test_data/parser/inline/ok/generic_arg.rs"); }
+    fn generic_arg() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/generic_arg.rs");
+    }
     #[test]
     fn generic_arg_bounds() {
         run_and_expect_no_errors("test_data/parser/inline/ok/generic_arg_bounds.rs");
     }
     #[test]
-    fn generic_const() { run_and_expect_no_errors("test_data/parser/inline/ok/generic_const.rs"); }
+    fn generic_const() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/generic_const.rs");
+    }
     #[test]
     fn generic_param_attribute() {
         run_and_expect_no_errors("test_data/parser/inline/ok/generic_param_attribute.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/generic_param_list.rs");
     }
     #[test]
-    fn global_asm() { run_and_expect_no_errors("test_data/parser/inline/ok/global_asm.rs"); }
+    fn global_asm() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/global_asm.rs");
+    }
     #[test]
     fn half_open_range_pat() {
         run_and_expect_no_errors("test_data/parser/inline/ok/half_open_range_pat.rs");
     }
     #[test]
-    fn if_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/if_expr.rs"); }
+    fn if_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/if_expr.rs");
+    }
     #[test]
-    fn impl_item() { run_and_expect_no_errors("test_data/parser/inline/ok/impl_item.rs"); }
+    fn impl_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/impl_item.rs");
+    }
     #[test]
     fn impl_item_const() {
         run_and_expect_no_errors("test_data/parser/inline/ok/impl_item_const.rs");
     }
     #[test]
-    fn impl_item_neg() { run_and_expect_no_errors("test_data/parser/inline/ok/impl_item_neg.rs"); }
+    fn impl_item_neg() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/impl_item_neg.rs");
+    }
     #[test]
     fn impl_item_never_type() {
         run_and_expect_no_errors("test_data/parser/inline/ok/impl_item_never_type.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/impl_type_params.rs");
     }
     #[test]
-    fn index_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/index_expr.rs"); }
+    fn index_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/index_expr.rs");
+    }
     #[test]
-    fn label() { run_and_expect_no_errors("test_data/parser/inline/ok/label.rs"); }
+    fn label() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/label.rs");
+    }
     #[test]
-    fn labeled_block() { run_and_expect_no_errors("test_data/parser/inline/ok/labeled_block.rs"); }
+    fn labeled_block() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/labeled_block.rs");
+    }
     #[test]
-    fn lambda_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/lambda_expr.rs"); }
+    fn lambda_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/lambda_expr.rs");
+    }
     #[test]
     fn lambda_ret_block() {
         run_and_expect_no_errors("test_data/parser/inline/ok/lambda_ret_block.rs");
     }
     #[test]
-    fn let_else() { run_and_expect_no_errors("test_data/parser/inline/ok/let_else.rs"); }
+    fn let_else() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/let_else.rs");
+    }
     #[test]
-    fn let_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/let_expr.rs"); }
+    fn let_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/let_expr.rs");
+    }
     #[test]
-    fn let_stmt() { run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt.rs"); }
+    fn let_stmt() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt.rs");
+    }
     #[test]
     fn let_stmt_ascription() {
         run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt_ascription.rs");
     }
     #[test]
-    fn let_stmt_init() { run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt_init.rs"); }
+    fn let_stmt_init() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/let_stmt_init.rs");
+    }
     #[test]
-    fn lifetime_arg() { run_and_expect_no_errors("test_data/parser/inline/ok/lifetime_arg.rs"); }
+    fn lifetime_arg() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/lifetime_arg.rs");
+    }
     #[test]
     fn lifetime_param() {
         run_and_expect_no_errors("test_data/parser/inline/ok/lifetime_param.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/literal_pattern.rs");
     }
     #[test]
-    fn loop_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/loop_expr.rs"); }
+    fn loop_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/loop_expr.rs");
+    }
     #[test]
     fn macro_call_type() {
         run_and_expect_no_errors("test_data/parser/inline/ok/macro_call_type.rs");
     }
     #[test]
-    fn macro_def() { run_and_expect_no_errors("test_data/parser/inline/ok/macro_def.rs"); }
+    fn macro_def() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/macro_def.rs");
+    }
     #[test]
     fn macro_def_curly() {
         run_and_expect_no_errors("test_data/parser/inline/ok/macro_def_curly.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/macro_rules_non_brace.rs");
     }
     #[test]
-    fn marco_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/marco_pat.rs"); }
+    fn marco_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/marco_pat.rs");
+    }
     #[test]
-    fn match_arm() { run_and_expect_no_errors("test_data/parser/inline/ok/match_arm.rs"); }
+    fn match_arm() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/match_arm.rs");
+    }
     #[test]
     fn match_arms_commas() {
         run_and_expect_no_errors("test_data/parser/inline/ok/match_arms_commas.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/match_arms_outer_attributes.rs");
     }
     #[test]
-    fn match_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/match_expr.rs"); }
+    fn match_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/match_expr.rs");
+    }
     #[test]
-    fn match_guard() { run_and_expect_no_errors("test_data/parser/inline/ok/match_guard.rs"); }
+    fn match_guard() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/match_guard.rs");
+    }
     #[test]
     fn maybe_const_trait_bound() {
         run_and_expect_no_errors("test_data/parser/inline/ok/maybe_const_trait_bound.rs");
     }
     #[test]
-    fn metas() { run_and_expect_no_errors("test_data/parser/inline/ok/metas.rs"); }
+    fn metas() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/metas.rs");
+    }
     #[test]
     fn method_call_expr() {
         run_and_expect_no_errors("test_data/parser/inline/ok/method_call_expr.rs");
     }
     #[test]
-    fn mod_contents() { run_and_expect_no_errors("test_data/parser/inline/ok/mod_contents.rs"); }
+    fn mod_contents() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/mod_contents.rs");
+    }
     #[test]
-    fn mod_item() { run_and_expect_no_errors("test_data/parser/inline/ok/mod_item.rs"); }
+    fn mod_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/mod_item.rs");
+    }
     #[test]
     fn mod_item_curly() {
         run_and_expect_no_errors("test_data/parser/inline/ok/mod_item_curly.rs");
     }
     #[test]
-    fn never_type() { run_and_expect_no_errors("test_data/parser/inline/ok/never_type.rs"); }
+    fn never_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/never_type.rs");
+    }
     #[test]
     fn no_dyn_trait_leading_for() {
         run_and_expect_no_errors("test_data/parser/inline/ok/no_dyn_trait_leading_for.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/no_semi_after_block.rs");
     }
     #[test]
-    fn nocontentexpr() { run_and_expect_no_errors("test_data/parser/inline/ok/nocontentexpr.rs"); }
+    fn nocontentexpr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/nocontentexpr.rs");
+    }
     #[test]
     fn nocontentexpr_after_item() {
         run_and_expect_no_errors("test_data/parser/inline/ok/nocontentexpr_after_item.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/offset_of_parens.rs");
     }
     #[test]
-    fn or_pattern() { run_and_expect_no_errors("test_data/parser/inline/ok/or_pattern.rs"); }
+    fn or_pattern() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/or_pattern.rs");
+    }
     #[test]
-    fn param_list() { run_and_expect_no_errors("test_data/parser/inline/ok/param_list.rs"); }
+    fn param_list() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/param_list.rs");
+    }
     #[test]
     fn param_list_vararg() {
         run_and_expect_no_errors("test_data/parser/inline/ok/param_list_vararg.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/param_outer_arg.rs");
     }
     #[test]
-    fn paren_type() { run_and_expect_no_errors("test_data/parser/inline/ok/paren_type.rs"); }
+    fn paren_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/paren_type.rs");
+    }
     #[test]
-    fn path_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/path_expr.rs"); }
+    fn path_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/path_expr.rs");
+    }
     #[test]
     fn path_fn_trait_args() {
         run_and_expect_no_errors("test_data/parser/inline/ok/path_fn_trait_args.rs");
     }
     #[test]
-    fn path_part() { run_and_expect_no_errors("test_data/parser/inline/ok/path_part.rs"); }
+    fn path_part() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/path_part.rs");
+    }
     #[test]
-    fn path_type() { run_and_expect_no_errors("test_data/parser/inline/ok/path_type.rs"); }
+    fn path_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/path_type.rs");
+    }
     #[test]
     fn path_type_with_bounds() {
         run_and_expect_no_errors("test_data/parser/inline/ok/path_type_with_bounds.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/pointer_type_mut.rs");
     }
     #[test]
-    fn postfix_range() { run_and_expect_no_errors("test_data/parser/inline/ok/postfix_range.rs"); }
+    fn postfix_range() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/postfix_range.rs");
+    }
     #[test]
     fn precise_capturing() {
         run_and_expect_no_errors("test_data/parser/inline/ok/precise_capturing.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/pub_tuple_field.rs");
     }
     #[test]
-    fn qual_paths() { run_and_expect_no_errors("test_data/parser/inline/ok/qual_paths.rs"); }
+    fn qual_paths() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/qual_paths.rs");
+    }
     #[test]
     fn question_for_type_trait_bound() {
         run_and_expect_no_errors("test_data/parser/inline/ok/question_for_type_trait_bound.rs");
     }
     #[test]
-    fn range_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/range_pat.rs"); }
+    fn range_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/range_pat.rs");
+    }
     #[test]
     fn record_field_attrs() {
         run_and_expect_no_errors("test_data/parser/inline/ok/record_field_attrs.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/record_field_pat_leading_or.rs");
     }
     #[test]
-    fn record_lit() { run_and_expect_no_errors("test_data/parser/inline/ok/record_lit.rs"); }
+    fn record_lit() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/record_lit.rs");
+    }
     #[test]
     fn record_literal_field_with_attr() {
         run_and_expect_no_errors("test_data/parser/inline/ok/record_literal_field_with_attr.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/record_pat_field_list.rs");
     }
     #[test]
-    fn ref_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/ref_expr.rs"); }
+    fn ref_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/ref_expr.rs");
+    }
     #[test]
-    fn ref_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/ref_pat.rs"); }
+    fn ref_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/ref_pat.rs");
+    }
     #[test]
     fn reference_type() {
         run_and_expect_no_errors("test_data/parser/inline/ok/reference_type.rs");
     }
     #[test]
-    fn return_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/return_expr.rs"); }
+    fn return_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/return_expr.rs");
+    }
     #[test]
     fn return_type_syntax_in_path() {
         run_and_expect_no_errors("test_data/parser/inline/ok/return_type_syntax_in_path.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/safe_outside_of_extern.rs");
     }
     #[test]
-    fn self_param() { run_and_expect_no_errors("test_data/parser/inline/ok/self_param.rs"); }
+    fn self_param() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/self_param.rs");
+    }
     #[test]
     fn self_param_outer_attr() {
         run_and_expect_no_errors("test_data/parser/inline/ok/self_param_outer_attr.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/singleton_tuple_type.rs");
     }
     #[test]
-    fn slice_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/slice_pat.rs"); }
+    fn slice_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/slice_pat.rs");
+    }
     #[test]
-    fn slice_type() { run_and_expect_no_errors("test_data/parser/inline/ok/slice_type.rs"); }
+    fn slice_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/slice_type.rs");
+    }
     #[test]
     fn stmt_bin_expr_ambiguity() {
         run_and_expect_no_errors("test_data/parser/inline/ok/stmt_bin_expr_ambiguity.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/struct_initializer_with_defaults.rs");
     }
     #[test]
-    fn struct_item() { run_and_expect_no_errors("test_data/parser/inline/ok/struct_item.rs"); }
+    fn struct_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/struct_item.rs");
+    }
     #[test]
-    fn trait_alias() { run_and_expect_no_errors("test_data/parser/inline/ok/trait_alias.rs"); }
+    fn trait_alias() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/trait_alias.rs");
+    }
     #[test]
     fn trait_alias_where_clause() {
         run_and_expect_no_errors("test_data/parser/inline/ok/trait_alias_where_clause.rs");
     }
     #[test]
-    fn trait_item() { run_and_expect_no_errors("test_data/parser/inline/ok/trait_item.rs"); }
+    fn trait_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/trait_item.rs");
+    }
     #[test]
     fn trait_item_bounds() {
         run_and_expect_no_errors("test_data/parser/inline/ok/trait_item_bounds.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/try_block_expr.rs");
     }
     #[test]
-    fn try_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/try_expr.rs"); }
+    fn try_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/try_expr.rs");
+    }
     #[test]
     fn try_macro_fallback() {
         run_and_expect_no_errors_with_edition(
         );
     }
     #[test]
-    fn tuple_attrs() { run_and_expect_no_errors("test_data/parser/inline/ok/tuple_attrs.rs"); }
+    fn tuple_attrs() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/tuple_attrs.rs");
+    }
     #[test]
-    fn tuple_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/tuple_expr.rs"); }
+    fn tuple_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/tuple_expr.rs");
+    }
     #[test]
     fn tuple_field_attrs() {
         run_and_expect_no_errors("test_data/parser/inline/ok/tuple_field_attrs.rs");
     }
     #[test]
-    fn tuple_pat() { run_and_expect_no_errors("test_data/parser/inline/ok/tuple_pat.rs"); }
+    fn tuple_pat() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/tuple_pat.rs");
+    }
     #[test]
     fn tuple_pat_fields() {
         run_and_expect_no_errors("test_data/parser/inline/ok/tuple_pat_fields.rs");
     }
     #[test]
-    fn tuple_struct() { run_and_expect_no_errors("test_data/parser/inline/ok/tuple_struct.rs"); }
+    fn tuple_struct() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/tuple_struct.rs");
+    }
     #[test]
     fn tuple_struct_where() {
         run_and_expect_no_errors("test_data/parser/inline/ok/tuple_struct_where.rs");
     }
     #[test]
-    fn type_alias() { run_and_expect_no_errors("test_data/parser/inline/ok/type_alias.rs"); }
+    fn type_alias() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/type_alias.rs");
+    }
     #[test]
     fn type_item_type_params() {
         run_and_expect_no_errors("test_data/parser/inline/ok/type_item_type_params.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/type_item_where_clause_deprecated.rs");
     }
     #[test]
-    fn type_param() { run_and_expect_no_errors("test_data/parser/inline/ok/type_param.rs"); }
+    fn type_param() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/type_param.rs");
+    }
     #[test]
     fn type_param_bounds() {
         run_and_expect_no_errors("test_data/parser/inline/ok/type_param_bounds.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/typepathfn_with_coloncolon.rs");
     }
     #[test]
-    fn unary_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/unary_expr.rs"); }
+    fn unary_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/unary_expr.rs");
+    }
     #[test]
-    fn union_item() { run_and_expect_no_errors("test_data/parser/inline/ok/union_item.rs"); }
+    fn union_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/union_item.rs");
+    }
     #[test]
-    fn unit_struct() { run_and_expect_no_errors("test_data/parser/inline/ok/unit_struct.rs"); }
+    fn unit_struct() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/unit_struct.rs");
+    }
     #[test]
-    fn unit_type() { run_and_expect_no_errors("test_data/parser/inline/ok/unit_type.rs"); }
+    fn unit_type() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/unit_type.rs");
+    }
     #[test]
-    fn use_item() { run_and_expect_no_errors("test_data/parser/inline/ok/use_item.rs"); }
+    fn use_item() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_item.rs");
+    }
     #[test]
-    fn use_tree() { run_and_expect_no_errors("test_data/parser/inline/ok/use_tree.rs"); }
+    fn use_tree() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_tree.rs");
+    }
     #[test]
     fn use_tree_abs_star() {
         run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_abs_star.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_alias.rs");
     }
     #[test]
-    fn use_tree_list() { run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_list.rs"); }
+    fn use_tree_list() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_list.rs");
+    }
     #[test]
-    fn use_tree_path() { run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_path.rs"); }
+    fn use_tree_path() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_path.rs");
+    }
     #[test]
     fn use_tree_path_star() {
         run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_path_star.rs");
         run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_path_use_tree.rs");
     }
     #[test]
-    fn use_tree_star() { run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_star.rs"); }
+    fn use_tree_star() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/use_tree_star.rs");
+    }
     #[test]
     fn variant_discriminant() {
         run_and_expect_no_errors("test_data/parser/inline/ok/variant_discriminant.rs");
     }
     #[test]
-    fn where_clause() { run_and_expect_no_errors("test_data/parser/inline/ok/where_clause.rs"); }
+    fn where_clause() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/where_clause.rs");
+    }
     #[test]
     fn where_pred_for() {
         run_and_expect_no_errors("test_data/parser/inline/ok/where_pred_for.rs");
     }
     #[test]
-    fn while_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/while_expr.rs"); }
+    fn while_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/while_expr.rs");
+    }
     #[test]
-    fn yeet_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/yeet_expr.rs"); }
+    fn yeet_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/yeet_expr.rs");
+    }
     #[test]
-    fn yield_expr() { run_and_expect_no_errors("test_data/parser/inline/ok/yield_expr.rs"); }
+    fn yield_expr() {
+        run_and_expect_no_errors("test_data/parser/inline/ok/yield_expr.rs");
+    }
 }
 mod err {
     use crate::tests::*;
         run_and_expect_errors("test_data/parser/inline/err/async_without_semicolon.rs");
     }
     #[test]
-    fn bad_asm_expr() { run_and_expect_errors("test_data/parser/inline/err/bad_asm_expr.rs"); }
+    fn bad_asm_expr() {
+        run_and_expect_errors("test_data/parser/inline/err/bad_asm_expr.rs");
+    }
     #[test]
     fn closure_ret_recovery() {
         run_and_expect_errors("test_data/parser/inline/err/closure_ret_recovery.rs");
         run_and_expect_errors("test_data/parser/inline/err/empty_param_slot.rs");
     }
     #[test]
-    fn empty_segment() { run_and_expect_errors("test_data/parser/inline/err/empty_segment.rs"); }
+    fn empty_segment() {
+        run_and_expect_errors("test_data/parser/inline/err/empty_segment.rs");
+    }
     #[test]
     fn fn_pointer_type_missing_fn() {
         run_and_expect_errors("test_data/parser/inline/err/fn_pointer_type_missing_fn.rs");
         run_and_expect_errors("test_data/parser/inline/err/generic_param_list_recover.rs");
     }
     #[test]
-    fn generic_static() { run_and_expect_errors("test_data/parser/inline/err/generic_static.rs"); }
+    fn generic_static() {
+        run_and_expect_errors("test_data/parser/inline/err/generic_static.rs");
+    }
     #[test]
-    fn impl_type() { run_and_expect_errors("test_data/parser/inline/err/impl_type.rs"); }
+    fn impl_type() {
+        run_and_expect_errors("test_data/parser/inline/err/impl_type.rs");
+    }
     #[test]
     fn invalid_question_for_type_trait_bound() {
         run_and_expect_errors(
         run_and_expect_errors("test_data/parser/inline/err/match_arms_recovery.rs");
     }
     #[test]
-    fn meta_recovery() { run_and_expect_errors("test_data/parser/inline/err/meta_recovery.rs"); }
+    fn meta_recovery() {
+        run_and_expect_errors("test_data/parser/inline/err/meta_recovery.rs");
+    }
     #[test]
     fn method_call_missing_argument_list() {
         run_and_expect_errors("test_data/parser/inline/err/method_call_missing_argument_list.rs");
         run_and_expect_errors("test_data/parser/inline/err/precise_capturing_invalid.rs");
     }
     #[test]
-    fn pub_expr() { run_and_expect_errors("test_data/parser/inline/err/pub_expr.rs"); }
+    fn pub_expr() {
+        run_and_expect_errors("test_data/parser/inline/err/pub_expr.rs");
+    }
     #[test]
     fn record_literal_before_ellipsis_recovery() {
         run_and_expect_errors(
         run_and_expect_errors("test_data/parser/inline/err/struct_field_recover.rs");
     }
     #[test]
-    fn top_level_let() { run_and_expect_errors("test_data/parser/inline/err/top_level_let.rs"); }
+    fn top_level_let() {
+        run_and_expect_errors("test_data/parser/inline/err/top_level_let.rs");
+    }
     #[test]
     fn tuple_expr_leading_comma() {
         run_and_expect_errors("test_data/parser/inline/err/tuple_expr_leading_comma.rs");
 fn main() {
     foo! (
         bar, "baz", 1, 2.0
-    } //~ ERROR incorrect close delimiter
 }
+//~ ERROR incorrect close delimiter
 
 fn foo() {
     match () {
         _ => (),
         _ => (),
-        #[cfg(test)]
+        #[cfg(test)]  => ,
     }
 }
 
     };
 }
 
-fn
+fn ();
 
-fn foo() {}
+fn foo() {
+}
 
-extern struct Foo;
+struct Foo;
 
 fn foo(x: i32, y) {
 }
 
 struct S {
     f: u32,
-    pub 92
-    + - *
     pub x: u32,
     z: f64,
 }
     };
 }
 
-impl<T: Clone>
-impl<T> OnceCell<T> {}
+impl<T: Clone>  {}
+
+impl<T> OnceCell<T> {
+}
 
 fn f() {
     let _ = loop {
     };
 }
 
-struct X {a: i32}
+struct X {
+    a: i32,
+}
+
 fn f() {
     let foo = X {
         a: 1
         self.scopes.push(ScopeData { parent: None, entries: vec![] })
     }
 
-    fn set_parent
+    fn set_parent();
 }
 
 fn foo() -> i32 {
     return 92;
 }
 
-unsafe async fn foo() {}
-unsafe const fn bar() {}
+async fn foo() {
+}
 
-let foo = bar = {
+const ;
+
+{
     1
-} else {
+}{
     return;
-};
-
+}
 fn f() {
     S::<Item::<lol>::<nope>>;
 }
 
 fn g() {
-    let _: Item::<lol>::<nope> = ();
+    let _: Item::<lol>::<
+    nope> =
+    ();
 }
 
-fn f<T: (Copy) + (?Sized) + (for<'a> Trait<'a>)>() {}
+fn f<T: (Copy) + (?Sized) + (for<'a> Trait<'a>)>() {
+}
 
 fn main() {
-    let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;
-    let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Copy)>;
-    let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;
+    let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)
+    >
+    let _: Box<(?Sized
+    )
+    +
+    (for<'a> Trait<'a>) + (Copy)>;
+    let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)
+    >
 }
 
-let foo = 1 + {
+{
     1
-} else {
+}{
     return;
-};
-
-#!/use/bin/env rusti
-#!/use/bin/env rusti
+}
+#
+use ;
+#
+use ;
 
 fn foo()
-    where for<'a>
-{}
+where for<'a>
+{
+}
 
-let foo = |x: i32| {
+{
     x
-} else {
+}{
     return;
-};
-
+}
 struct S {
     a: i32,
     b: String,
-};
-
-struct S<90 + 2> {
-    f: u32
 }
 
+struct S<90;
+
 struct T;
 
 fn main() {
-    let ref box i = ();
-    let mut box i = ();
-    let ref mut box i = ();
+    let ref box
+    i = ();
+    let mut box
+    i = ();
+    let ref mut box
+    i = ();
 }
 
 impl<T:
-use std;
+  {}
 
-pub struct Cache(
-    RefCell<HashMap<
+pub struct Cache(RefCell<HashMap<
         TypeId,
-        Box<@ Any>,
-    >>
-);
+        Box<);
 
 fn f() {
     let _ = while true {
 fn foo() {
 }
 
-
 #[foo(
 fn foo() {
 }
     let bad = format_args! {""} else { return; };
 }
 
-}
 
 struct S;
 
+
+fn foo() {
 }
 
-fn foo(){}
-
-}
 
 struct S {
-    a: u32
-    b: u32
+    a: u32,
+    b: u32,
 }
 
-fn foo(}) {
-}
+fn foo();
 
-let foo = 1..{
+{
     1
-} else {
+}{
     return;
-};
-
-extern "C" extern "C"
+}
+use ;
+use ;
 
 use foo::bar;
-use
 use crate::baz;
-use
-fn f() {}
+fn f() {
+}
 
 fn foo(a: A) {
     a.
 }
 
 struct S(i32, i32);
+
 fn f() {
     let s = S(1, 2);
     let a = s.1e0;
     { unsafe 92 }
     { async 92 }
     { try 92 }
-    { 'label: 92 }
+    {
+        92
+    }
 }
 
 fn foo() {
     let
     while true {}
     let
-    loop {}
+    loop {
+    }
 }
 
 fn foo() {
     }
 
     match () {
-        #[cfg(test)]
-        #![doc("Nor here")]
+        #[cfg(test)] #  => [doc("Nor here")],
         _ => (),
         _ => (),
     }
         }
     }
     // still recover later
-    let; //~ ERROR: expected pattern
+    let;
+    //~ ERROR: expected pattern
     let _ = 0;
 }
 
-if match
 
-struct S {}
+struct S {
+}
 
-fn foo<T>() where T {}
+fn foo<T>()
+where T
+{
+}
 
-fn a() { [1, 2, @, struct, let] }
-fn b() { foo(1, 2, @, impl, let) }
-fn c() { foo.bar(1, 2, @, ], trait, let) }
+fn a() {
+    [1, 2, @
+    ,
+    struct,
+    let
+    ]
+}
 
-let foo = -{
+fn b() {
+    foo(1, 2, @
+    ,
+    impl
+    ,
+    let
+    )
+}
+
+fn c() {
+    foo.bar(1, 2, @
+    ,
+    ]
+    ,
+    trait,
+    let
+    )
+}
+
+{
     1
-} else {
+}{
     return;
-};
-
+}
 fn f() {
     let _ = match Some(1) {
         Some(_) => 1,
         return
     };
 }
-
-use std::{error::Error;
 use std::io;
 
+use std::{error::Error;
+
 fn main() {
-    || -> () unsafe { () };
+    || -> ()
+    unsafe { () };
 }
 
 fn f() {
     };
 }
 
-let foo = become {
+{
     ()
-} else {
+}{
     return;
-};
-
+}
 type ForRef = for<'a> &'a u32;
+
 type ForTup = for<'a> (&'a u32,);
+
 type ForSlice = for<'a> [u32];
+
 type ForForFn = for<'a> for<'b> fn(&'a i32, &'b i32);
+
 fn for_for_for<T>()
 where
     for<'a> for<'b> for<'c> fn(&'a T, &'b T, &'c T): Copy,
 fn foo() {
 }
 
-bar() {
-    if true {
-        1
-    } else {
-        2 + 3
-    }
+{
+    1
+}{
+    2 + 3
 }
-
 fn baz() {
 }
 
-let foo = &{
+{
     1
-} else {
+}{
     return;
-};
-
+}
 fn foo() {
     (,);
 }
     S { 0 .. }
 }
 
-fn f<T>() where T: ?for<> Sized {}
+fn f<T>()
+where T: ?for<> Sized
+{
+}
 
 type T = *();
 
-const _: () = T::<0, ,T>;
-const _: () = T::<0, ,T>();
+const () = T::<0, ,T>;
 
-fn foo() -> A>]) { let x = 1; }
-fn foo() -> A>]) where T: Copy { let x = 1; }
+const () = T::<0, ,T>();
 
-struct S { f pub g: () }
-struct S { f: pub g: () }
+fn foo() -> A {
+    let x = 1;
+}
 
-static C: u32 = 0
-where i32: Copy;
+fn foo() -> A
+where T: Copy
+{
+    let x = 1;
+}
 
-type T = [() 92];
+struct S {
+    f: ,
+    pub g: (),
+}
+
+struct S {
+    f: ,
+    pub g: (),
+}
+
+static C: u32 = 0;
+
+type T = [();
 
 fn main() {
     S { field = foo }
     let S { field = foo };
 }
 
-const _: [&];
+const [&];
 
-fn foo() { let _ = async {} }
+fn foo() {
+    let _ = async {}
+}
 
 fn foo() {
     S { ..x, };
 
 type T = impl use<self, 1>;
 
-static C = 0;
+static C:  = 0;
 
-struct S(struct S;
-struct S(A,,B);
+struct S();
+
+struct S;
+
+struct S(A, B);
 
 fn foo() {
     S { .., };
 }
 
 type X = <()>;
+
 type Y = <A as B>;
 
 fn func() {
     foo.bar::<i32>;
 }
 
-foo
 
-fn func() { let Some(_) = {Some(1)} else { panic!("h") };}
+fn func() {
+    let Some(_) = {Some(1)} else { panic!("h") };
+}
 
-impl Type {}
-impl Trait1 for T {}
-impl impl NotType {}
-impl Trait2 for impl NotType {}
+impl Type {
+}
 
-macro_rules! {};
+impl Trait1 for T {
+}
+
+impl  {}
+
+impl NotType {
+}
+
+impl Trait2 {}
+
+impl NotType {
+}
+
+macro_rules! {}
 macro_rules! ()
+
 macro_rules! []
 
 fn foo() {
     ()
 }
 
-fn foo<T: T![], T: T!, T: T!{}>() -> Box<T! + T!{}> {}
+fn foo<T: T![], T: T!, T: T!{}>() -> Box<T! + T!{}> {
+}
+use b;
 
 use {a;
-use b;
 struct T;
-fn test() {}
-use {a ,, b};
 
-fn foo(){} unsafe { } fn bar(){}
+fn test() {
+}
+use {a, b};
 
-fn foo() { pub 92; }
+fn foo() {
+}
+fn bar() {
+}
 
-fn f() -> impl Iterator<Item = , Item = > {}
+fn foo() {
+    pub
+    92;
+}
 
-fn f<T: Clone,, U:, V>() {}
+fn f() -> impl Iterator<Item = , Item = > {
+}
+
+fn f<T: Clone,, U:, V>() {
+}
 
 fn main() {
-    'loop: impl
+    'loop:
+    impl
 }
 
 struct A<const N: i32 = , const M: i32 =>;
 
-let ref foo: fn() = 1 + 3;
 
 fn foo() {
     match () {
-        _ => (),,
+        _ => (),
         _ => ,
         _ => (),
          => (),
-        if true => (),
+         if true => (),
         _ => (),
-        () if => (),
+        () if  => (),
     }
 }
 
 pub() struct S;
 
-static C<i32>: u32 = 0;
+static C: u32 = 0;
 
-type F = unsafe ();
+type F;
 
-fn foo() { || -> A> { let x = 1; } }
+fn foo() {
+    || -> A { let x = 1; }
+}
 
-const C = 0;
+const C:  = 0;
 
 fn foo() {
     let (,);
 }
 
-// 2021
-gen fn gen_fn() {}
-async gen fn async_gen_fn() {}
+fn gen_fn() {
+}
+
+async fn async_gen_fn() {
+}
 
 fn main() {
     S { S::default() };
     S { 0::default() };
 }
 
-fn f(x y: i32, z, t: i32) {}
+fn f(x, y: i32, z, t: i32) {
+}
 
 fn foo() {
     builtin#asm(
     );
 }
 
-fn f(y: i32, ,t: i32) {}
+fn f(y: i32, t: i32) {
+}
 
-#![]
-#![p = ]
-#![p::]
-#![p:: =]
-#![unsafe]
-#![unsafe =]
+#
+#
+#
+#
+#
+#
 
 type T = T<0, ,T>;
+
 type T = T::<0, ,T>;
 
-static _: i32 = 5;
+static i32 = 5;
 
 fn foo() {
     x.self;
     x.0();
 }
 
-fn a() {}
-fn b(x: i32) {}
-fn c(x: i32, ) {}
-fn d(x: i32, y: ()) {}
+fn a() {
+}
+
+fn b(x: i32) {
+}
+
+fn c(x: i32) {
+}
+
+fn d(x: i32, y: ()) {
+}
 
 fn foo() {
     if true {};
 
 type T = S<{90 + 2}>;
 
-fn main() { || -> i32 { 92 }(); }
+fn main() {
+    || -> i32 { 92 }();
+}
 
 fn main() {
     let .. = ();
 
 use std::collections;
 
-fn f() { let x = 92; }
+fn f() {
+    let x = 92;
+}
 
 fn main() {
     match 42 {
-        ..0 => {}
-        1..2 => {}
+        ..0 => {},
+        1..2 => {},
     }
 }
 
-default impl T for Foo {}
+impl T for Foo {
+}
 
-trait T where Self: Copy {}
+trait T
+where Self: Copy
+{
+}
 
-fn f() { unsafe { } }
-fn f() { const { } }
-fn f() { async { } }
-fn f() { async move { } }
+fn f() {
+    unsafe {
+    }
+}
+
+fn f() {
+    const {
+    }
+}
+
+fn f() {
+    async {
+    }
+}
+
+fn f() {
+    async {
+    }
+}
 
 fn main() {
     match 92 {
 
 struct S<T: 'a + ?Sized + (Copy) + [const] Drop>;
 
-builtin#global_asm("")
 
 fn foo() {
     let _ = try {};
 }
 
 fn main() {
-   let foo = |bar, baz: Baz, qux: Qux::Quux| ();
+    let foo = |bar, baz: Baz, qux: Qux::Quux| ();
 }
 
 fn foo() {
     match { S {} } {};
 }
 
-struct S { a: i32, b: f32, unsafe c: u8 }
+struct S {
+    a: i32,
+    b: f32,
+    c: u8,
+}
 
 fn foo() {
     builtin#asm("");
     let _ = cr"h";
 }
 
-fn foo(){
+fn foo() {
     if break {}
     while break {}
     for i in break {}
-    match break {}
+    match break {
+    }
 }
 
 const A: (i64, i64) = (1, #[cfg(test)] 2);
     enum LocalEnum {
         One,
         Two,
-    };
-    fn f() {};
-    struct S {};
+    }
+    fn f() {}
+    struct S {}
 }
 
-struct S { #[attr] f: f32 }
+struct S {
+    #[attr]
+    f: f32,
+}
 
 fn main() {
     let [a, b, ..] = [];
     let [| a, ..] = [];
 }
 
-fn foo(..., (x, y): (i32, i32)) {}
+fn foo(..., (x, y): (i32, i32)) {
+}
 
 fn foo() {
     x?;
 
 fn foo() {
     match () {
-        #![doc("Inner attribute")]
-        #![doc("Can be")]
-        #![doc("Stacked")]
         _ => (),
     }
 }
 
-impl const Send for S {}
+impl Send for S {
+}
 
-fn main() { let cl = const || _ = 0; }
+fn main() {
+    let cl = const || _ = 0;
+}
 
 impl S {
-    fn a(self) {}
-    fn b(&self,) {}
-    fn c(&'a self,) {}
-    fn d(&'a mut self, x: i32) {}
-    fn e(mut self) {}
+    fn a(self) {
+    }
+
+    fn b(&self) {
+    }
+
+    fn c(&'a self) {
+    }
+
+    fn d(&'a mut self, x: i32) {
+    }
+
+    fn e(mut self) {
+    }
 }
 
 type Foo where Foo: Copy = ();
 
 macro_rules! m ( ($i:ident) => {} );
+
 macro_rules! m [ ($i:ident) => {} ];
 
-#![simple_ident]
-#![simple::path]
-#![simple_ident_expr = ""]
-#![simple::path::Expr = ""]
-#![simple_ident_tt(a b c)]
-#![simple_ident_tt[a b c]]
-#![simple_ident_tt{a b c}]
-#![simple::path::tt(a b c)]
-#![simple::path::tt[a b c]]
-#![simple::path::tt{a b c}]
-#![unsafe(simple_ident)]
-#![unsafe(simple::path)]
-#![unsafe(simple_ident_expr = "")]
-#![unsafe(simple::path::Expr = "")]
-#![unsafe(simple_ident_tt(a b c))]
-#![unsafe(simple_ident_tt[a b c])]
-#![unsafe(simple_ident_tt{a b c})]
-#![unsafe(simple::path::tt(a b c))]
-#![unsafe(simple::path::tt[a b c])]
-#![unsafe(simple::path::tt{a b c})]
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
 
 macro m { ($i:ident) => {} }
 
-fn f<T>() where T: for<> ?Sized {}
+fn f<T>()
+where T: for<> ?Sized
+{
+}
 
-struct S<T>(T) where T: Clone;
+struct S<T>(T);
 
 fn main() {
     match () {
     #[D] return ();
 }
 
-mod b { }
+mod b {
+}
 
-impl S {}
+impl S {
+}
 
 fn foo() {
     S {};
     TupleStruct { 0: 1 };
 }
 
-type F = fn() -> ();
+type F =
+    fn(
+    ) -> ();
+
+type A =
+    fn(
+    );
 
-type A = fn();
 type B = unsafe fn();
+
 type C = unsafe extern "C" fn();
+
 type D = extern "C" fn ( u8 , ... ) -> u8;
 
-fn f() { 'label: {}; }
+fn f() {
+    'label: {};
+}
 
 type A = for<'a> Test<'a> + Send;
 
-impl ! {}
+impl ! {
+}
 
-extern crate foo;
-extern crate self;
 
 type Result<T> = ();
 
-fn main() { let <_>::Foo = (); }
+fn main() {
+    let <_>::Foo = ();
+}
 
 type T = S<true>;
 
-trait X<U: Debug + Display> {}
+trait X<U: Debug + Display> {
+}
 
 type T = StreamingIterator<Item<'a> = &'a T>;
 
     let S { #[cfg(any())] x: 1 } = ();
 }
 
-// 2015
-macro_rules! try { () => {} }
+macro_rules!
+{
+}use Trait as _;
 
 use std as stdlib;
-use Trait as _;
 
 struct S(String, usize);
 
 
 type T = S<i32, dyn T, fn()>;
 
-// 2015
 type DynPlain = dyn Path;
-type DynRef = &dyn Path;
-type DynLt = dyn 'a + Path;
-type DynQuestion = dyn ?Path;
-type DynFor = dyn for<'a> Path;
-type DynParen = dyn(Path);
-type Path = dyn::Path;
-type Generic = dyn<Path>;
 
-fn main() { || _ = 0; }
+type DynRef = &dyn Path;
+
+type DynLt = dyn 'a + Path;
+
+type DynQuestion = dyn ?Path;
+
+type DynFor = dyn for<'a> Path;
+
+type DynParen = dyn(Path);
+
+type Path = dyn::Path;
+
+type Generic = dyn;
+
+fn main() {
+    || _ = 0;
+}
 
 use {a, b, c};
 
     return 92;
 }
 
-type Foo = () where Foo: Copy;
+type Foo where Foo: Copy = ();
 
 type Never = !;
 
-fn foo<T>() where T: Copy {}
+fn foo<T>()
+where T: Copy
+{
+}
 
 fn foo() {
     let _ = a;
     builtin#naked_asm("");
 }
 
-fn foo<T: for<'a> [const] async Trait>() {}
+fn foo<T: for<'a> [const] async Trait>() {
+}
 
 type A = dyn Iterator<Item=Foo<'a>> + 'a;
 
-trait T { fn new() -> Self; }
+trait T {
+    fn new() -> Self;
+}
 
 fn foo() {
     let _s = S { .. };
 }
 
-// 2024
 pub fn main() {
     gen { yield ""; };
     async gen { yield ""; };
     async gen move { yield ""; };
 }
 
-fn foo() {}
-fn bar() -> () {}
+fn foo() {
+}
+
+fn bar() -> () {
+}
 
 fn main() {
     S { #[cfg(test)] field: 1 }
 }
 
 pub(crate) struct S;
+
 pub(self) struct S;
+
 pub(super) struct S;
 
 type Placeholder = _;
 
 fn foo() {
     match () {
-        #[cfg(feature = "some")]
-        _ => (),
-        #[cfg(feature = "other")]
-        _ => (),
-        #[cfg(feature = "many")]
-        #[cfg(feature = "attributes")]
-        #[cfg(feature = "before")]
-        _ => (),
+        #[cfg(feature = "some")] _ => (),
+        #[cfg(feature = "other")] _ => (),
+        #[cfg(feature = "many")] #[cfg(feature = "attributes")] #[cfg(feature = "before")] _ => (),
     }
 }
+use std::{::*};
 
 use ::*;
-use std::{::*};
 
 fn foo() {
     if true {}
 }
 
 fn foo() {
-   let mut p = F{x: 5};
-   {p}.x = 10;
+    let mut p = F{x: 5};
+    {p}.x = 10;
 }
 
-// 2015
-fn foo() { try!(Ok(())); }
+fn foo() {
+    try
+    !(Ok(()));
+}
 
-fn f<T: Clone>() {}
+fn f<T: Clone>() {
+}
 
 fn foo() {
     let foo::Bar = ();
 
 struct A<const N: i32 = { 1 }>;
 
-struct U { i: i32, f: f32 }
+struct U {
+    i: i32,
+    f: f32,
+}
 
 type M = *mut ();
+
 type C = *mut ();
 
-impl<const N: u32> Bar<N> {}
+impl<const N: u32> Bar<N> {
+}
 
 type T = [()];
 
 fn foo() {
-   for x in 0 .. {
-       break;
-   }
+    for x in 0.. {
+        break;
+    }
 }
 
 use crate::foo;
 
-struct S { f: f32 = 0.0 }
+struct S {
+    f: f32,
+}
 
 fn foo() {
     _ = 1;
     T::method(..): Send,
     method(..): Send,
     method::(..): Send,
-{}
+{
+}
 
-impl S { #![attr] }
+impl S {
+    #![attr]
+}
 
-fn a() {}
-fn b() { let _ = 1; }
-fn c() { 1; 2; }
-fn d() { 1; 2 }
+fn a() {
+}
+
+fn b() {
+    let _ = 1;
+}
+
+fn c() {
+    1;
+    2;
+}
+
+fn d() {
+    1;
+    2
+}
 
 fn foo() {
     let _ = f();
 fn foo() {
     'a: loop {}
     'b: while true {}
-    'c: for x in () {}
+    'c: for x in () {
+    }
 }
 
 impl T for Foo {
-    default async fn foo() {}
+    async fn foo() {
+    }
 }
 
-trait Z<U> = T<U>;
+trait Z<U> {}
 
 use std::*;
 
    T: Clone + Copy + 'static,
    Iterator::Item: 'a,
    <T as Iterator>::Item: 'a
-{}
+{
+}
 
 macro_rules! {}
+
 macro_rules! ();
+
 macro_rules! [];
+
 fn main() {
     let foo = macro_rules!();
 }
 
-fn f<T: Clone>() {}
+fn f<T: Clone>() {
+}
 
 struct B(pub (super::A));
+
 struct B(pub (crate::A,));
 
 type A = 'static + Trait;
+
 type B = S<'static + Trait>;
 
 type A = Foo<syn::Token![_]>;
 
-fn foo<F: Foo<N=3>>() {}
+fn foo<F: Foo<N=3>>() {
+}
+
 const TEST: usize = 3;
-fn bar<F: Foo<N={TEST}>>() {}
+
+fn bar<F: Foo<N={TEST}>>() {
+}
 
 type F = Start::(Middle) -> (Middle)::End;
+
 type GenericArg = S<Start(Middle)::End>;
 
 type T = S<92>;
 type T = S<-92>;
 
 type T = StreamingIterator<Item<'a>: Clone>;
+
 type T = StreamingIterator<Item(T): Clone>;
 
-fn foo() {}
+fn foo() {
+}
+
 macro_rules! foo {}
+
 foo::bar!();
+
 super::baz! {}
+
 struct S;
 
 struct S<T = i32>;
 
 type A = for<'a> fn() -> ();
+
 type B = for<'a> unsafe extern "C" fn(&'a ()) -> ();
+
 type Obj = for<'a> PartialEq<&'a i32>;
 
-const fn foo(_: impl [const] Trait) {}
-
-use *;
+const fn foo(_: impl [const] Trait) {
+}
 use std::{*};
 
-const _: u32 = 0;
+use *;
 
-fn foo<T: Clone + Copy>(){}
+const u32 = 0;
 
-fn f() { v = {1}&2; }
+fn foo<T: Clone + Copy>() {
+}
+
+fn f() {
+    v = {1}&2;
+}
 
 fn foo() {
     x.await;
 
 fn foo() {
     if let Some(_) = None && true {}
-    while 1 == 5 && (let None = None) {}
+    while 1 == 5 && (let None = None) {
+    }
 }
 
 fn foo() {
     for<'a> move || {};
 }
 
-default unsafe impl T for Foo {
-    default unsafe fn foo() {}
+unsafe impl T for Foo {
+    unsafe fn foo() {
+    }
 }
 
 pub(in super::A) struct S;
+
 pub(in crate) struct S;
 
 type Plain = Foo<Item, Item::Item, Item: Bound, Item = Item>;
+
 type GenericArgs = Foo<Item<T>, Item::<T>, Item<T>: Bound, Item::<T>: Bound, Item<T> = Item, Item::<T> = Item>;
+
 type ParenthesizedArgs = Foo<Item(T), Item::(T), Item(T): Bound, Item::(T): Bound, Item(T) = Item, Item::(T) = Item>;
+
 type RTN = Foo<Item(..), Item(..), Item(..): Bound, Item(..): Bound, Item(..) = Item, Item(..) = Item>;
 
 fn foo() {
 
 struct S;
 
-fn captures<'a: 'a, 'b: 'b, T>() -> impl Sized + use<'b, T, Self> {}
+fn captures<'a: 'a, 'b: 'b, T>() -> impl Sized + use<'b, T, Self> {
+}
 
-enum E { X(i32) = 10 }
+enum E {
+    X(i32),
+}
 
-// 2015
 type A = Foo<dyn T>;
 
-fn foo() { let R { a: | 1 | 2 } = 0; }
+fn foo() {
+    let R { a: | 1 | 2 } = 0;
+}
 
 type A = impl Iterator<Item=Foo<'a>> + 'a;
 
 
 fn f() {
     let _ = {1} & 2;
-    {1} &2;
+    {1}
+    &2;
 }
 
 struct A<const N: i32 = i32::MAX>;
 
 fn foo() {
     match () {
-        _ => {}
-        () => {}
-        [] => {}
+        _ => {},
+        () => {},
+        [] => {},
     }
 }
 
-extern "C" { fn printf(format: *const i8, ..., _: u8) -> i32; }
+fn printf(format: *const i8, ..., _: u8) -> i32;
 
 type T = [(); 92];
+use std::collections;
 
 use ::std;
-use std::collections;
+use crate::m;
 
 use self::m;
 use super::m;
-use crate::m;
 
 fn main() {
     let (a, b, ..) = ();
 }
 
 impl T for Foo {
-    default async unsafe fn foo() {}
+    async unsafe fn foo() {
+    }
 }
 
 fn foo() {
 
 type Foo = Bar;
 
-type Foo = fn(Bar::Baz);
-type Qux = fn(baz: Bar::Baz);
+type Foo =
+    fn(
+        Bar::Baz,
+    );
+
+type Qux =
+    fn(
+        baz: Bar::Baz,
+    );
 
 impl S {
-    fn a(self: &Self) {}
-    fn b(mut self: Box<Self>) {}
+    fn a(self: &Self) {
+    }
+
+    fn b(mut self: Box<Self>) {
+    }
 }
 
 fn foo() {
     match () {
         _ => (),
-        _ => {}
-        _ => ()
+        _ => {},
+        _ => (),
     }
 }
 
     }
 }
 
-fn f() { let x: i32; }
+fn f() {
+    let x: i32;
+}
 
-fn main() { let _ = (); }
+fn main() {
+    let _ = ();
+}
 
 type X = <A as B>::Output;
-fn foo() { <usize as Default>::default(); }
 
-const C<i32>: u32 = 0;
+fn foo() {
+    <usize as Default>::default();
+}
+
+const C: u32 = 0;
+
 impl Foo {
-    const C<'a>: &'a () = &();
+    const C: &'a () = &();
 }
 
-const C<i32>: u32 = 0
-where i32: Copy;
+const C: u32 = 0;
+
 trait Foo {
-    const C: i32 where i32: Copy;
+    const C: i32;
 }
 
-trait T: Hash + Clone {}
+trait T {
+}
 
 fn foo() {
     ();
 }
 
 type A = foo!();
+
 type B = crate::foo!();
 
 type A = Foo;
+
 type B = ::Foo;
+
 type C = self::Foo;
+
 type D = super::Foo;
 
 fn foo() {
 }
 
 type F = Box<Fn(i32) -> ()>;
+
 type F = Box<::Fn(i32) -> ()>;
+
 type F = Box<Fn::(i32) -> ()>;
+
 type F = Box<::Fn::(i32) -> ()>;
 
 fn main() {
 
 const C: u32 = 92;
 
-unsafe extern "C" {}
-extern {}
 
 type T = (i32);
 
 struct MyStruct(pub (u32, u32));
+
 struct MyStruct(pub (u32));
+
 struct MyStruct(pub ());
 
-fn f() { let Some(x) = opt else { return }; }
+fn f() {
+    let Some(x) = opt else { return };
+}
 
 fn foo() {
     while true {};
     x.0()
 }
 
-fn main() { for<'a> || (); }
+fn main() {
+    for<'a> || ();
+}
 
-type Foo = fn(_: bar);
+type Foo =
+    fn(
+        _: bar,
+    );
 
-fn foo() { xs[..]; }
+fn foo() {
+    xs[..];
+}
 
-trait T { fn foo(); }
+trait T {
+    fn foo();
+}
 
-fn f() { let x: i32 = 92; super let y; super::foo; }
+fn f() {
+    let x: i32 = 92;
+    super let y;
+    super::foo;
+}
 
 fn foo() {
     82 as i32;
     0x36 as u8 <= 0x37;
 }
 
-fn f(#[attr1] pat: Type) {}
+fn f(#[attr1] pat: Type) {
+}
 
-struct S (#[attr] f32);
+struct S(f32);
 
 fn foo() {
     builtin#asm(
     );
 }
 
-impl !Send for S {}
+impl Send for S {
+}
 
-fn f() { let _ = &1 as *const i32; }
+fn f() {
+    let _ = &1 as *const i32;
+}
 
 fn for_trait<F>()
 where
    for<'a> F: Fn(&'a str)
-{ }
+{
+}
 
-#!/usr/bin/env cargo
+#
 
----
-[dependencies]
-clap = { version = "4.2", features = ["derive"] }
----
 
-fn main() {}
+fn main() {
+}
 
 fn foo() {
     loop {
     }
 }
 
-trait Z<U> = T<U> where U: Copy;
-trait Z<U> = where Self: T<U>;
+trait Z<U>
+where U: Copy {}
 
-const fn foo(_: impl const Trait) {}
+trait Z<U>
+where Self: T<U> {}
+
+const fn foo(_: impl const Trait) {
+}
 
 fn foo() {
     become foo();
 
 struct A<const N: i32 = -1>;
 
-struct S {}
+struct S {
+}
 
-fn foo() { safe = true; }
+fn foo() {
+    safe = true;
+}
 
 type A = &();
+
 type B = &'static ();
+
 type C = &mut ();
 
 fn main() {
     match a.b()..S { _ => () };
 }
 
-extern crate foo as bar;
-extern crate self as bar;
 
-fn foo(){
-    ;;;some_expr();;;;{;;;};;;;Ok(())
+fn foo() {
+    some_expr();
+    {;;;};
+    Ok(())
 }
 
 struct S<const N: u32>;
 
-fn a() { fn b() {} }
+fn a() {
+    fn b() {}
+}
 
-fn foo() -> Box<T + 'f> {}
-fn foo() -> Box<dyn T + 'f> {}
+fn foo() -> Box<T + 'f> {
+}
+
+fn foo() -> Box<dyn T + 'f> {
+}
 
 fn main() {
     match () {
     }
 }
 
-fn async_foo(_: impl async Fn(&i32)) {}
+fn async_foo(_: impl async Fn(&i32)) {
+}
 
-fn foo<#[lt_attr] 'a, #[t_attr] T>() {}
+fn foo<#[lt_attr] 'a, #[t_attr] T>() {
+}
 
 type T = ();
 
 impl F {
     type A = i32;
+
     const B: i32 = 92;
-    fn foo() {}
-    fn bar(&self) {}
+
+    fn foo() {
+    }
+
+    fn bar(&self) {
+    }
 }
 
-fn f<'a: 'b>() {}
+fn f<'a: 'b>() {
+}
 
-fn f(#[must_use] self) {}
+fn f(#[must_use] self) {
+}
 
 fn main() {
     let m!(x) = 0;
 
 mod a;
 
-fn foo() {}
+fn foo() {
+}
 
 type T = S<'static>;
 
     --1;
 }
 
-fn foo(x: i32) {}
+fn foo(x: i32) {
+}
 
 fn main() {
     foo(loop {});
 }
 
-fn foo() { let r#struct = 92; let r#trait = r#struct * 2; }
+fn foo() {
+    let r#struct = 92;
+    let r#trait = r#struct * 2;
+}
 
 fn main() {
     Some(for _ in [1].into_iter() {});
 }
 
 /// Example
-
-fn test() {}
+fn test() {
+}
 
 static FOO: u32 = 1;
+
 static mut BAR: i32 = 92;
 
-fn a() {}
-pub fn b() {}
+fn a() {
+}
+
+pub fn b() {
+}
+
 pub macro m($:ident) {}
-pub(crate) fn c() {}
-pub(super) fn d() {}
-pub(in foo::bar::baz) fn e() {}
+
+pub(crate) fn c() {
+}
+
+pub(super) fn d() {
+}
+
+pub(in foo::bar::baz) fn e() {
+}
+use foo::bar::baz;
 
 use ::foo::bar::baz;
-use foo::bar::baz;
 
 struct S<T: Copy> {
     f: T,
 }
 
 enum E3 {
-    X
+    X,
 }
 
 enum E4 {
 
 enum E5 {
     A,
-    B = 92,
+    B,
     C {
         a: u32,
         pub b: f64,
     },
-    F {},
-    D(u32,),
+    F {
+    },
+    D(u32),
     E(),
 }
 
 // https://github.com/rust-lang/rust-analyzer/issues/674
-
-struct Repr { raw: [u8; 1] }
+struct Repr {
+    raw: [u8; 1],
+}
 
 fn abc() {
     Repr { raw: [0] }.raw[0] = 0;
 }
 
 fn main() {
-    if 1.0f32.floor() as i64 != 1.0f32.floor() as i64 {}
+    if 1.0f32.floor() as i64 != 1.0f32.floor() as i64 {
+    }
 }
 
 fn main() {
 use super::super::bar;
 
 // https://github.com/rust-lang/rust-analyzer/issues/972
-
 fn main() {
     match Some(-1) {
         Some(-1) => (),
 }
 
 enum A {
-    B(i8, i8)
+    B(i8, i8),
 }
 
-fn foo(-128..=127: i8) {}
+fn foo(-128..=127: i8) {
+}
 
 fn test_serialization<SER>()
 where
     SER: Serialize + for<'de> Deserialize<'de> + PartialEq + std::fmt::Debug,
-{}
+{
+}
 
 struct S {
-    r#foo: u32
+    r#foo: u32,
 }
 
-extern crate foo;
-extern crate foo as bar;
-extern crate self as baz;
 
-unsafe extern {
-    // sqrt (from libm) may be called with any `f64`
-    pub safe fn sqrt(x: f64) -> f64;
+pub fn sqrt(x: f64) -> f64;
+pub unsafe fn strlen(p: *const c_char) -> usize;
+pub fn free(p: *mut core::ffi::c_void);
+pub static mut COUNTER: i32;
+pub static IMPORTANT_BYTES: [u8; 256];
+pub static LINES: SyncUnsafeCell<i32>;
 
-    // strlen (from libc) requires a valid pointer,
-    // so we mark it as being an unsafe fn
-    pub unsafe fn strlen(p: *const c_char) -> usize;
-
-    // this function doesn't say safe or unsafe, so it defaults to unsafe
-    pub fn free(p: *mut core::ffi::c_void);
-
-    pub safe static mut COUNTER: i32;
-
-    pub unsafe static IMPORTANT_BYTES: [u8; 256];
-
-    pub safe static LINES: SyncUnsafeCell<i32>;
-}
-
-extern "C" {
-    //! This is a doc comment
-    #![doc("This is also a doc comment")]
-}
+//! This is a doc comment
+#![doc("This is also a doc comment")]
 
 fn inner() {
     #![doc("Inner attributes allowed here")]
         //! As are ModuleDoc style comments
     };
     {
-        #![doc("Inner attributes are allowed in blocks when they are the last statement of another block")]
         //! As are ModuleDoc style comments
     }
 }
     let _ = #[doc("Outer attributes are always allowed")] {};
 }
 
-// https://github.com/rust-lang/rust-analyzer/issues/689
 impl Whatever {
     fn salsa_event(&self, event_fn: impl Fn() -> Event<Self>) {
-        #![allow(unused_variables)] // this is  `inner_attr` of the block
+        #![allow(unused_variables)]
+        // this is  `inner_attr` of the block
     }
 }
 
     for<'a> F: Fn(&'a str),
 {
 }
+
 fn for_ref<F>()
 where
     for<'a> &'a F: Debug,
 {
 }
+
 fn for_parens<F>()
 where
     for<'a> (&'a F): Fn(&'a str),
 {
 }
+
 fn for_slice<F>()
 where
     for<'a> [&'a F]: Eq,
 {
 }
+
 fn for_qpath<T>(_t: &T)
 where
     for<'a> <&'a T as Baz>::Foo: Iterator,
 {
 }
+
 fn for_for_fn<T>()
 where
     for<'a> for<'b> fn(&'a T, &'b T): Copy,
 {
 }
 
-#![attr]
-#![attr(true)]
-#![attr(ident)]
-#![attr(ident, 100, true, "true", ident = 100, ident = "hello", ident(100))]
-#![attr(100)]
-#![attr(enabled = true)]
-#![enabled(true)]
-#![attr("hello")]
-#![repr(C, align = 4)]
-#![repr(C, align(4))]
+#
+#
+#
+#
+#
+#
+#
+#
+#
+#
 
-extern "C" {
-    fn a(_: *mut u8, ...,);
-    fn b(_: *mut u8, _: ...);
-    fn c(_: *mut u8, #[cfg(never)] [w, t, f]: ...,);
-}
+fn a(_: *mut u8, ...);
+fn b(_: *mut u8, _: ...);
+fn c(_: *mut u8, #[cfg(never)] [w, t, f]: ...);
 
 fn main() {
     match .. {
 }
 
 struct A;
-struct B {}
+
+struct B {
+}
+
 struct C();
 
 struct D {
     a: u32,
-    pub b: u32
+    pub b: u32,
 }
 
-struct E(pub x, y,);
+struct E(pub x, y);
 
-//! Adapted from a `rustc` test, which can be found at
-//! https://github.com/rust-lang/rust/blob/6d34ec18c7d7e574553f6347ecf08e1e1c45c13d/src/test/run-pass/weird-exprs.rs.
-//!
-//! Reported to rust-analyzer in https://github.com/rust-lang/rust-analyzer/issues/290
+#
+#
+#
+#
 
-#![allow(non_camel_case_types)]
-#![allow(dead_code)]
-#![allow(unreachable_code)]
-#![allow(unused_parens)]
-
-#![recursion_limit = "128"]
+#
 
 use std::cell::Cell;
 use std::mem::swap;
 
 // Just a grab bag of stuff that you wouldn't want to actually write.
-
-fn strange() -> bool { let _x: bool = return true; }
+fn strange() -> bool {
+    let _x: bool = return true;
+}
 
 fn funny() {
     fn f(_x: ()) { }
                 return;
             }
         }
-        if (return) { break; }
+        if (return) {
+            break;
+        }
     }
 }
 
 fn angrydome() {
     loop { if break { } }
     let mut i = 0;
-    loop { i += 1; if i == 1 { match (continue) { 1 => { }, _ => panic!("wat") } }
-      break; }
+    loop {
+        i += 1;
+        if i == 1 { match (continue) { 1 => { }, _ => panic!("wat") } }
+        break;
+    }
 }
 
-fn evil_lincoln() { let _evil = println!("lincoln"); }
+fn evil_lincoln() {
+    let _evil = println!("lincoln");
+}
 
 fn dots() {
     assert_eq!(String::from(".................................................."),
 }
 
 fn punch_card() -> impl std::fmt::Debug {
-    ..=..=.. ..    .. .. .. ..    .. .. .. ..    .. ..=.. ..
-    ..=.. ..=..    .. .. .. ..    .. .. .. ..    ..=..=..=..
-    ..=.. ..=..    ..=.. ..=..    .. ..=..=..    .. ..=.. ..
-    ..=..=.. ..    ..=.. ..=..    ..=.. .. ..    .. ..=.. ..
-    ..=.. ..=..    ..=.. ..=..    .. ..=.. ..    .. ..=.. ..
-    ..=.. ..=..    ..=.. ..=..    .. .. ..=..    .. ..=.. ..
-    ..=.. ..=..    .. ..=..=..    ..=..=.. ..    .. ..=.. ..
+    ..=..=........................=......=....=....................=..=..=....=....=....=....=......=..=......=......=..=......=....=....=..........=......=....=....=....=......=........=......=....=....=....=........=......=......=....=......=..=....=..=........=....
 }
 
 fn ktulhu() {
-    ;;;();;;;;;;;;()
+    ();
+    ()
 }
 
 pub fn main() {
 }
 
 use foo as bar;
-use foo::{a as b, *, ::*, ::foo as x};
+use foo::{a as b, *, ::foo as x, ::*};
 
-fn g1(#[attr1] #[attr2] pat: Type) {}
-fn g2(#[attr1] x: u8) {}
+fn g1(#[attr1] #[attr2] pat: Type) {
+}
 
-extern "C" { fn printf(format: *const i8, #[attr] ...) -> i32; }
+fn g2(#[attr1] x: u8) {
+}
+
+fn printf(format: *const i8, #[attr] ...) -> i32;
 
 trait Foo {
     fn bar(#[attr] _: u64, # [attr] mut x: i32);
 }
 
 impl S {
-     fn f(#[must_use] self) {}
-     fn g1(#[attr] self) {}
-     fn g2(#[attr] &self) {}
-     fn g3<'a>(#[attr] &mut self) {}
-     fn g4<'a>(#[attr] &'a self) {}
-     fn g5<'a>(#[attr] &'a mut self) {}
-     fn c(#[attr] self: Self) {}
-     fn d(#[attr] self: Rc<Self>) {}
+    fn f(#[must_use] self) {
+    }
+
+    fn g1(#[attr] self) {
+    }
+
+    fn g2(#[attr] &self) {
+    }
+
+    fn g3<'a>(#[attr] &mut self) {
+    }
+
+    fn g4<'a>(#[attr] &'a self) {
+    }
+
+    fn g5<'a>(#[attr] &'a mut self) {
+    }
+
+    fn c(#[attr] self: Self) {
+    }
+
+    fn d(#[attr] self: Rc<Self>) {
+    }
 }
 
 fn r#foo() {
 use foo;
 use ::bar;
 
-
 struct S {
-    foo: u32
+    foo: u32,
 }
 
 fn foo() {
     async move {};
 }
 
-#!/use/bin/env rusti
+#
+use ;
 
 // https://github.com/rust-lang/rust-analyzer/issues/357
-
-//! docs
-// non-docs
-mod foo {}
+mod foo {
+}
 
 type X = ();
 
 fn main() {
     let ():::X = ();
 }
+use foo::*;
+use foo::{};
 
 use *;
+use ::foo::{a, b, c};
 use ::*;
 use ::{};
 use {};
-use foo::*;
-use foo::{};
-use ::foo::{a, b, c};
 
-fn foo(x: impl std::future::Future<Output = i32>) {}
+fn foo(x: impl std::future::Future<Output = i32>) {
+}
 
 fn main() {
-    foo(async move { 12 })
+    foo(async {
+        12
+    })
 }
 
 struct A<T>;
+
 struct B<T:>;
+
 struct C<T: 'a>;
+
 struct D<T: 'a + >;
+
 struct E<T: 'a + 'd >;
+
 struct F<T: 'a + 'd + Clone>;
+
 struct G<T: Clone + Copy>;
+
 struct H<T: ::Foo + self::Bar + 'a>;
+
 struct I<T:, U:,>;
+
 struct K<'a: 'd, 'd: 'a + 'b, T: 'a + 'd + Clone>;
 
-async fn foo() {}
-extern fn foo() {}
-const fn foo() {}
-const unsafe fn foo() {}
-unsafe extern "C" fn foo() {}
-unsafe fn foo() {}
-async unsafe fn foo() {}
-const unsafe fn bar() {}
+async fn foo() {
+}
 
-unsafe trait T {}
-auto trait T {}
-unsafe auto trait T {}
+fn foo() {
+}
 
-unsafe impl Foo {}
-default impl Foo {}
-unsafe default impl Foo {}
+const fn foo() {
+}
+
+const unsafe fn foo() {
+}
+
+unsafe fn foo() {
+}
+
+unsafe fn foo() {
+}
+
+async unsafe fn foo() {
+}
+
+const unsafe fn bar() {
+}
+
+trait T {
+}
+
+trait T {
+}
+
+trait T {
+}
+
+unsafe impl Foo {
+}
+
+impl Foo {
+}
+
+unsafe impl Foo {
+}
 
-unsafe extern "C++" {}
 
 fn main() {
     unsafe fn f() {}
-    unsafe { 92 }
+    unsafe {
+        92
+    }
 }
 
-// https://github.com/rust-lang/rust-analyzer/issues/677
 fn main() {
     #[cfg(feature = "backtrace")]
     let exit_code = panic::catch_unwind(move || main());
     let x = 1..;
 }
 
-// format with label break value.
 fn main() {
     'empty_block: {}
 
 }
 
 // https://github.com/rust-lang/rust-analyzer/issues/311
-
 pub fn foo<S: Iterator>() -> String
 where
     <S as Iterator>::Item: Eq,
 mod c {
     fn foo() {
     }
-    struct S {}
+    struct S {
+    }
 }
 
 mod d {
     }
 }
 
-fn test() where (u64, u64): Foo {}
+fn test()
+where (u64, u64): Foo
+{
+}
 
-fn a() -> Foo<bar::Baz> {}
+fn a() -> Foo<bar::Baz> {
+}
 
-fn b(_: impl FnMut(x::Y)) {}
+fn b(_: impl FnMut(x::Y)) {
+}
 
-fn c(_: impl FnMut(&x::Y)) {}
+fn c(_: impl FnMut(&x::Y)) {
+}
 
 #[foo(a,)]
-fn foo() {}
+fn foo() {
+}
 
 type Foo<'a> = &'a (dyn Send + Sync);
+
 type Foo = *const (dyn Send + Sync);
-type Foo = fn() -> (dyn Send + 'static);
+
+type Foo =
+    fn(
+    ) -> (dyn Send + 'static);
+
 fn main() {
     let b = (&a) as &(dyn Add<Other, Output = Addable> + Other);
 }
     }
 }
 
-extern {
-    pub fn socket(domain: ::c_int, ty: ::c_int, protocol: ::c_int) -> ::c_int;
-    pub fn bind(fd: ::c_int, addr: *const sockaddr, len: socklen_t) -> ::c_int;
-    pub fn connect(socket: ::c_int, address: *const sockaddr,
-                   len: socklen_t) -> ::c_int;
-    pub fn listen(socket: ::c_int, backlog: ::c_int) -> ::c_int;
-    pub fn getsockname(socket: ::c_int, address: *mut sockaddr,
-                       address_len: *mut socklen_t) -> ::c_int;
-    pub fn getsockopt(sockfd: ::c_int,
-                      level: ::c_int,
-                      optname: ::c_int,
-                      optval: *mut ::c_void,
-                      optlen: *mut ::socklen_t) -> ::c_int;
-    pub fn setsockopt(socket: ::c_int, level: ::c_int, name: ::c_int,
-                      value: *const ::c_void,
-                      option_len: socklen_t) -> ::c_int;
-    pub fn getpeername(socket: ::c_int, address: *mut sockaddr,
-                       address_len: *mut socklen_t) -> ::c_int;
-    pub fn sendto(socket: ::c_int, buf: *const ::c_void, len: ::size_t,
-                  flags: ::c_int, addr: *const sockaddr,
-                  addrlen: socklen_t) -> ::ssize_t;
-    pub fn send(socket: ::c_int, buf: *const ::c_void, len: ::size_t,
-                flags: ::c_int) -> ::ssize_t;
-    pub fn recvfrom(socket: ::c_int, buf: *mut ::c_void, len: ::size_t,
-                    flags: ::c_int, addr: *mut ::sockaddr,
-                    addrlen: *mut ::socklen_t) -> ::ssize_t;
-    pub fn recv(socket: ::c_int, buf: *mut ::c_void, len: ::size_t,
-                flags: ::c_int) -> ::ssize_t;
-}
+pub fn socket(domain: ::c_int, ty: ::c_int, protocol: ::c_int) -> ::c_int;
+pub fn bind(fd: ::c_int, addr: *const sockaddr, len: socklen_t) -> ::c_int;
+pub fn connect(socket: ::c_int, address: *const sockaddr, len: socklen_t) -> ::c_int;
+pub fn listen(socket: ::c_int, backlog: ::c_int) -> ::c_int;
+pub fn getsockname(
+    socket: ::c_int,
+    address: *mut sockaddr,
+    address_len: *mut socklen_t,
+) -> ::c_int;
+pub fn getsockopt(
+    sockfd: ::c_int,
+    level: ::c_int,
+    optname: ::c_int,
+    optval: *mut ::c_void,
+    optlen: *mut ::socklen_t,
+) -> ::c_int;
+pub fn setsockopt(
+    socket: ::c_int,
+    level: ::c_int,
+    name: ::c_int,
+    value: *const ::c_void,
+    option_len: socklen_t,
+) -> ::c_int;
+pub fn getpeername(
+    socket: ::c_int,
+    address: *mut sockaddr,
+    address_len: *mut socklen_t,
+) -> ::c_int;
+pub fn sendto(
+    socket: ::c_int,
+    buf: *const ::c_void,
+    len: ::size_t,
+    flags: ::c_int,
+    addr: *const sockaddr,
+    addrlen: socklen_t,
+) -> ::ssize_t;
+pub fn send(socket: ::c_int, buf: *const ::c_void, len: ::size_t, flags: ::c_int) -> ::ssize_t;
+pub fn recvfrom(
+    socket: ::c_int,
+    buf: *mut ::c_void,
+    len: ::size_t,
+    flags: ::c_int,
+    addr: *mut ::sockaddr,
+    addrlen: *mut ::socklen_t,
+) -> ::ssize_t;
+pub fn recv(socket: ::c_int, buf: *mut ::c_void, len: ::size_t, flags: ::c_int) -> ::ssize_t;
 
 // https://github.com/rust-lang/rust-analyzer/issues/596
-
 struct Foo;
 
 impl Foo {
     }
 }
 
-fn baz(_: bool) {}
+fn baz(_: bool) {
+}
 
 fn main() {
     baz(<Foo>::bar())
 }
 
 // https://github.com/rust-lang/rust-analyzer/pull/983
-
 fn compound_assignment() {
     let mut a = 0;
     a += 1;
     a <<= 12;
 }
 
-
 fn main() {
     const fn f() {}
 }
 
 trait T {
-    fn f1((a, b): (usize, usize)) {}
-    fn f2(S { a, b }: S) {}
-    fn f3(NewType(a): NewType) {}
-    fn f4(&&a: &&usize) {}
+    fn f1((a, b): (usize, usize)) {
+    }
+
+    fn f2(S { a, b }: S) {
+    }
+
+    fn f3(NewType(a): NewType) {
+    }
+
+    fn f4(&&a: &&usize) {
+    }
+
     fn bar(_: u64, mut x: i32);
 }
 
-fn f<T>() where T: Fn() -> u8 + Send {}
+fn f<T>()
+where T: Fn() -> u8 + Send
+{
+}
 
 impl U {
-    fn f1((a, b): (usize, usize)) {}
-    fn f2(S { a, b }: S) {}
-    fn f3(NewType(a): NewType) {}
-    fn f4(&&a: &&usize) {}
+    fn f1((a, b): (usize, usize)) {
+    }
+
+    fn f2(S { a, b }: S) {
+    }
+
+    fn f3(NewType(a): NewType) {
+    }
+
+    fn f4(&&a: &&usize) {
+    }
 }
 
 trait T {
-  default type T = Bar;
-  default const f: u8 = 0;
-  default fn foo() {}
-  default unsafe fn bar() {}
+    type T = Bar;
+
+    const f: u8 = 0;
+
+    fn foo() {
+    }
+
+    unsafe fn bar() {
+    }
 }
 
 impl T for Foo {
-  default type T = Bar;
-  default const f: u8 = 0;
-  default fn foo() {}
-  default unsafe fn bar() {}
+    type T = Bar;
+
+    const f: u8 = 0;
+
+    fn foo() {
+    }
+
+    unsafe fn bar() {
+    }
 }
 
-default impl T for () {}
-default unsafe impl T for () {}
-
-extern {
+impl T for () {
 }
 
-extern "C" {
+unsafe impl T for () {
 }
 
+
+
 #[cfg(test)]
 #[Ignore]
-fn foo() {}
+fn foo() {
+}
 
 #[path = "a.rs"]
 mod b;
 
 struct S1<T>;
+
 struct S2<T>(u32);
-struct S3<T> { u: u32 }
+
+struct S3<T> {
+    u: u32,
+}
 
 struct S4<>;
+
 struct S5<'a>;
+
 struct S6<'a:>;
+
 struct S7<'a: 'b>;
+
 struct S8<'a: 'b + >;
+
 struct S9<'a: 'b + 'c>;
+
 struct S10<'a,>;
+
 struct S11<'a, 'b>;
+
 struct S12<'a: 'b+, 'b: 'c,>;
 
 struct S13<T>;
+
 struct S14<T, U>;
+
 struct S15<'a, T, U>;
 
 trait Runnable {
 }
 
 fn foo() {
-   for _x in 0 .. (0 .. {1 + 2}).sum::<u32>() {
-       break;
-   }
+    for _x in 0..(0..{
+        1 + 2
+    }).sum::<u32>() {
+        break;
+    }
 }
 
 fn foo() {
     #[C] &()
 }
 
-br##"
+//") || content.contains(";\n")) {
 
-b"\"
-b"\"
-b"\u{_0000}"
-b"\u{0000000}"
-b"\u{FFFFFF}"
-b"\u{ffffff}"
-b"\u{ffffff}"
-b"\u{DC00}"
-b"\u{DDDD}"
-b"\u{DFFF}"
-b"\u{D800}"
-b"\u{DAAA}"
-b"\u{DBFF}"
-b"\x"
-
-0e
-0E
-
-42e+
-42e-
-42E+
-42E-
-
-42.e+
-42.e-
-42.E+
-42.E-
-
-42.2e+
-42.2e-
-42.2E+
-42.2E-
-
-42.2e+f32
-42.2e-f32
-42.2E+f32
-42.2E-f32
-
-b"\x7f
-
-0b
-0o
-0x
-
-0b_
-0o_
-0x_
-
-0bnoDigit
-0onoDigit
-0xnoDigit
-
-0xG
-0xg
-
-0x_g
-0x_G
-
-'
-
-'\
-
-r## I lack a quote!
-
-b"
-
-br##"\x7f
-
-"\"
-"\"
-"\u{_0000}"
-"\u{0000000}"
-"\u{FFFFFF}"
-"\u{ffffff}"
-"\u{ffffff}"
-"\u{DC00}"
-"\u{DDDD}"
-"\u{DFFF}"
-"\u{D800}"
-"\u{DAAA}"
-"\u{DBFF}"
-"\x"
-
-b'\
-
-r##"\x7f
-
-/* /* /*
-
-br##"\n
-
-"
-
-r##"
-
-b'
-
-b"\
-
-b"
-
-/** /*! /* comment */ */
-
-fn main() {
-    hello("world);
-    // a bunch of code was here
-    env("FLAGS", "-help")
+fn finalize_with_eof(mut self) -> LexedStr<'a> {
+    self.res.push(EOF, self.offset);
+    self.res
 }
 
-b'\n
-
-'
-
-b'
-
-"
-
-b"\n
-
-br##"\u{20AA}
-
-b"\u{20AA}
-
-"\u{20AA}
-
-br##"
-
-"\x7f
-
-r##"\
-
-b'\'
-
-b'
-
-'\n
-
-br##
-
-br##"\
-
-r##"
-
-"
-
-c"\"
-c"\"
-c"\u{_0000}"
-c"\u{0000000}"
-c"\u{FFFFFF}"
-c"\u{ffffff}"
-c"\u{ffffff}"
-c"\u{DC00}"
-c"\u{DDDD}"
-c"\u{DFFF}"
-c"\u{D800}"
-c"\u{DAAA}"
-c"\u{DBFF}"
-c"\x"
-
-b"\"
-
-b'\x7f
-
-br##"
-
-'
-
-b"
-
-br## I lack a quote!
-
-r##"\u{20AA}
-
-b'\u{20AA}
-
-"\"
-
-"\
-
-"\n
-
-r##"
-
-/*
-
-'hello'
-''
-'
-'
-'spam'
-'\x0ff'
-'\"a'
-'\na'
-'\ra'
-'\ta'
-'\\a'
-'\'a'
-'\0a'
-'\u{0}x'
-'\u{1F63b}}'
-'\v'
-'\'
-'\'
-'\\\r'
-'\x'
-'\x0'
-'\xf'
-'\xa'
-'\xx'
-'\x'
-'\x'
-'\xtt'
-'\xff'
-'\xFF'
-'\x80'
-'\u'
-'\u[0123]'
-'\u{0x}'
-'\u{'
-'\u{0000'
-'\u{}'
-'\u{_0000}'
-'\u{0000000}'
-'\u{FFFFFF}'
-'\u{ffffff}'
-'\u{ffffff}'
-'\u{DC00}'
-'\u{DDDD}'
-'\u{DFFF}'
-'\u{D800}'
-'\u{DAAA}'
-'\u{DBFF}'
-
-'1
-'1lifetime
-
-'\'
-
-'\u{20AA}
-
-b''
-b'\'
-b'
-'
-b'spam'
-b'\x0ff'
-b'\"a'
-b'\na'
-b'\ra'
-b'\ta'
-b'\\a'
-b'\'a'
-b'\0a'
-b'\u{0}x'
-b'\u{1F63b}}'
-b'\v'
-b'\'
-b'\'
-b'\\\r'
-b'\x'
-b'\x0'
-b'\xf'
-b'\xa'
-b'\xx'
-b'\x'
-b'\x'
-b'\xtt'
-b'\u'
-b'\u[0123]'
-b'\u{0x}'
-b'\u{'
-b'\u{0000'
-b'\u{}'
-b'\u{_0000}'
-b'\u{0000000}'
-b'\u{FFFFFF}'
-b'\u{ffffff}'
-b'\u{ffffff}'
-b'\u{DC00}'
-b'\u{DDDD}'
-b'\u{DFFF}'
-b'\u{D800}'
-b'\u{DAAA}'
-b'\u{DBFF}'
-
-'\x7f
-
-r##"\n
-
-r##
-
-/* comment
-
-async fn use struct trait enum impl true false as extern crate
-mod pub self super in where for loop while if match const
-static mut type ref let else move return
-
-b'x' b"foo" br""
-b""ix br""br
-b'\n' b'\\' b'\''
-
-'a 'foo 'foo_bar_baz '_
-
-'x' ' ' '0' '\x7f' '\n' '\\' '\''
-
-#!/usr/bin/env cargo
-
----
-[dependencies]
-clap = "4"
----
-
-fn main() {
-}
-
-"hello" r"world" "\n\"\\no escape" "multi
-line"
-
-hello world
-
-0 00 0_ 0. 0z
-01790 0b1790 0o1790 0x1790aAbBcCdDeEfF 001279 0_1279 0.1279 0e1279 0E1279
-0..2
-0.foo()
-0e+1
-0.e+1
-0.0E-2
-0___0.10000____0000e+111__
-1i64 92.0f32 11__s
-
-/* */
-/**/
-/* /* */ */
-
-a b  c
-d
-
-e	f
-
-r###"this is a r##"raw"## string"###
-
-r#raw_ident
-
-foo foo_ _foo _ __ x 
-
-#!/usr/bin/env bash
-// hello
-//! World
-//!! Inner line doc
-/// Outer line doc
-//// Just a comment
-
-//
-//!
-//!!
-///
-////
-
-//@ edition: 2021
-
-#"foo"
-
-
----
-[dependencies]
-clap = "4"
----
-
-fn main() {
-}
-
-; , ( ) { } [ ] < > @ # ~ ? $ & | + * / ^ %
-. .. ... ..=
-: ::
-= =>
-! !=
-- ->
-
-//! Lexing `&str` into a sequence of Rust tokens.
-//!
-//! Note that strictly speaking the parser in this crate is not required to work
-//! on tokens which originated from text. Macros, eg, can synthesize tokens out
-//! of thin air. So, ideally, lexer should be an orthogonal crate. It is however
-//! convenient to include a text-based lexer here!
-//!
-//! Note that these tokens, unlike the tokens we feed into the parser, do
-//! include info about comments and whitespace.
-
-use std::ops;
-
-use rustc_literal_escaper::{
-    EscapeError, Mode, unescape_byte, unescape_byte_str, unescape_c_str, unescape_char,
-    unescape_str,
-};
-
-use crate::{
-    Edition,
-    SyntaxKind::{self, *},
-    T,
-};
-
-pub struct LexedStr<'a> {
-    text: &'a str,
-    kind: Vec<SyntaxKind>,
-    start: Vec<u32>,
-    error: Vec<LexError>,
-}
-
-struct LexError {
-    msg: String,
-    token: u32,
-}
-
-impl<'a> LexedStr<'a> {
-    pub fn new(edition: Edition, text: &'a str) -> LexedStr<'a> {
-        let _p = tracing::info_span!("LexedStr::new").entered();
-        let mut conv = Converter::new(edition, text);
-        if let Ok(script) = crate::frontmatter::ScriptSource::parse(text) {
-            if let Some(shebang) = script.shebang_span() {
-                conv.push(SHEBANG, shebang.end - shebang.start, Vec::new());
-            }
-            if script.frontmatter().is_some() {
-                conv.push(FRONTMATTER, script.content_span().start - conv.offset, Vec::new());
-            }
-        } else if let Some(shebang_len) = rustc_lexer::strip_shebang(text) {
-            // Leave error reporting to `rustc_lexer`
-            conv.push(SHEBANG, shebang_len, Vec::new());
+fn push(&mut self, kind: SyntaxKind, len: usize, errors: Vec<String>) {
+    self.res.push(kind, self.offset);
+    self.offset += len;
+
+    for msg in errors {
+        if !msg.is_empty() {
+            self.res.error.push(LexError { msg, token: self.res.len() as u32 });
         }
-
-        // Re-create the tokenizer from scratch every token because `GuardedStrPrefix` is one token in the lexer
-        // but we want to split it to two in edition <2024.
-        while let Some(token) =
-            rustc_lexer::tokenize(&text[conv.offset..], rustc_lexer::FrontmatterAllowed::No).next()
-        {
-            let token_text = &text[conv.offset..][..token.len as usize];
-
-            conv.extend_token(&token.kind, token_text);
-        }
-
-        conv.finalize_with_eof()
-    }
-
-    pub fn single_token(edition: Edition, text: &'a str) -> Option<(SyntaxKind, Option<String>)> {
-        if text.is_empty() {
-            return None;
-        }
-
-        let token = rustc_lexer::tokenize(text, rustc_lexer::FrontmatterAllowed::No).next()?;
-        if token.len as usize != text.len() {
-            return None;
-        }
-
-        let mut conv = Converter::new(edition, text);
-        conv.extend_token(&token.kind, text);
-        match &*conv.res.kind {
-            [kind] => Some((*kind, conv.res.error.pop().map(|it| it.msg))),
-            _ => None,
-        }
-    }
-
-    pub fn as_str(&self) -> &str {
-        self.text
-    }
-
-    pub fn len(&self) -> usize {
-        self.kind.len() - 1
-    }
-
-    pub fn is_empty(&self) -> bool {
-        self.len() == 0
-    }
-
-    pub fn kind(&self, i: usize) -> SyntaxKind {
-        assert!(i < self.len());
-        self.kind[i]
-    }
-
-    pub fn text(&self, i: usize) -> &str {
-        self.range_text(i..i + 1)
-    }
-
-    pub fn range_text(&self, r: ops::Range<usize>) -> &str {
-        assert!(r.start < r.end && r.end <= self.len());
-        let lo = self.start[r.start] as usize;
-        let hi = self.start[r.end] as usize;
-        &self.text[lo..hi]
-    }
-
-    // Naming is hard.
-    pub fn text_range(&self, i: usize) -> ops::Range<usize> {
-        assert!(i < self.len());
-        let lo = self.start[i] as usize;
-        let hi = self.start[i + 1] as usize;
-        lo..hi
-    }
-    pub fn text_start(&self, i: usize) -> usize {
-        assert!(i <= self.len());
-        self.start[i] as usize
-    }
-    pub fn text_len(&self, i: usize) -> usize {
-        assert!(i < self.len());
-        let r = self.text_range(i);
-        r.end - r.start
-    }
-
-    pub fn error(&self, i: usize) -> Option<&str> {
-        assert!(i < self.len());
-        let err = self.error.binary_search_by_key(&(i as u32), |i| i.token).ok()?;
-        Some(self.error[err].msg.as_str())
-    }
-
-    pub fn errors(&self) -> impl Iterator<Item = (usize, &str)> + '_ {
-        self.error.iter().map(|it| (it.token as usize, it.msg.as_str()))
-    }
-
-    fn push(&mut self, kind: SyntaxKind, offset: usize) {
-        self.kind.push(kind);
-        self.start.push(offset as u32);
     }
 }
 
-struct Converter<'a> {
-    res: LexedStr<'a>,
-    offset: usize,
-    edition: Edition,
-}
+fn extend_token(&mut self, kind: &rustc_lexer::TokenKind, mut token_text: &str) {
+    // A note on an intended tradeoff:
+    // We drop some useful information here (see patterns with double dots `..`)
+    // Storing that info in `SyntaxKind` is not possible due to its layout requirements of
+    // being `u16` that come from `rowan::SyntaxKind`.
+    let mut errors: Vec<String> = vec![];
 
-impl<'a> Converter<'a> {
-    fn new(edition: Edition, text: &'a str) -> Self {
-        Self {
-            res: LexedStr { text, kind: Vec::new(), start: Vec::new(), error: Vec::new() },
-            offset: 0,
-            edition,
-        }
-    }
-
-    /// Check for likely unterminated string by analyzing STRING token content
-    fn has_likely_unterminated_string(&self) -> bool {
-        let Some(last_idx) = self.res.kind.len().checked_sub(1) else { return false };
-
-        for i in (0..=last_idx).rev().take(5) {
-            if self.res.kind[i] == STRING {
-                let start = self.res.start[i] as usize;
-                let end = self.res.start.get(i + 1).map(|&s| s as usize).unwrap_or(self.offset);
-                let content = &self.res.text[start..end];
-
-                if content.contains('(') && (content.contains("//") || content.contains(";\n")) {
-                    return true;
-                }
-            }
-        }
-        false
-    }
-
-    fn finalize_with_eof(mut self) -> LexedStr<'a> {
-        self.res.push(EOF, self.offset);
-        self.res
-    }
-
-    fn push(&mut self, kind: SyntaxKind, len: usize, errors: Vec<String>) {
-        self.res.push(kind, self.offset);
-        self.offset += len;
-
-        for msg in errors {
-            if !msg.is_empty() {
-                self.res.error.push(LexError { msg, token: self.res.len() as u32 });
-            }
-        }
-    }
-
-    fn extend_token(&mut self, kind: &rustc_lexer::TokenKind, mut token_text: &str) {
-        // A note on an intended tradeoff:
-        // We drop some useful information here (see patterns with double dots `..`)
-        // Storing that info in `SyntaxKind` is not possible due to its layout requirements of
-        // being `u16` that come from `rowan::SyntaxKind`.
-        let mut errors: Vec<String> = vec![];
-
-        let syntax_kind = {
+    let syntax_kind = {
             match kind {
                 rustc_lexer::TokenKind::LineComment { doc_style: _ } => COMMENT,
                 rustc_lexer::TokenKind::BlockComment { doc_style: _, terminated } => {
             }
         };
 
-        self.push(syntax_kind, token_text.len(), errors);
-    }
+    self.push(syntax_kind, token_text.len(), errors);
+}
 
-    fn extend_literal(&mut self, len: usize, kind: &rustc_lexer::LiteralKind) {
-        let invalid_raw_msg = String::from("Invalid raw string literal");
+fn extend_literal(&mut self, len: usize, kind: &rustc_lexer::LiteralKind) {
+    let invalid_raw_msg = String::from("Invalid raw string literal");
 
-        let mut errors = vec![];
-        let mut no_end_quote = |c: char, kind: &str| {
+    let mut errors = vec![];
+    let mut no_end_quote = |c: char, kind: &str| {
             errors.push(format!("Missing trailing `{c}` symbol to terminate the {kind} literal"));
         };
 
-        let syntax_kind = match *kind {
+    let syntax_kind = match *kind {
             rustc_lexer::LiteralKind::Int { empty_int, base: _ } => {
                 if empty_int {
                     errors.push("Missing digits after the integer base prefix".into());
             }
         };
 
-        self.push(syntax_kind, len, errors);
-    }
+    self.push(syntax_kind, len, errors);
 }
 
 fn err_to_msg(error: EscapeError, mode: Mode) -> String {
         EscapeError::NulInCStr => "null character in C string literal",
         EscapeError::UnskippedWhitespaceWarning => "",
         EscapeError::MultipleSkippedLinesWarning => "",
-    }
-    .into()
+    }.into()
 }
 
-//! See [`Input`].
-
 use crate::SyntaxKind;
 
 #[allow(non_camel_case_types)]
             contextual_kind: Vec::with_capacity(capacity),
         }
     }
+
     #[inline]
     pub fn push(&mut self, kind: SyntaxKind) {
         self.push_impl(kind, SyntaxKind::EOF)
     }
+
     #[inline]
     pub fn push_ident(&mut self, contextual_kind: SyntaxKind) {
         self.push_impl(SyntaxKind::IDENT, contextual_kind)
     }
+
     /// Sets jointness for the last token we've pushed.
     ///
     /// This is a separate API rather than an argument to the `push` to make it
         let (idx, b_idx) = self.bit_index(n);
         self.joint[idx] |= 1 << b_idx;
     }
+
     #[inline]
     fn push_impl(&mut self, kind: SyntaxKind, contextual_kind: SyntaxKind) {
         let idx = self.len();
     pub(crate) fn kind(&self, idx: usize) -> SyntaxKind {
         self.kind.get(idx).copied().unwrap_or(SyntaxKind::EOF)
     }
+
     pub(crate) fn contextual_kind(&self, idx: usize) -> SyntaxKind {
         self.contextual_kind.get(idx).copied().unwrap_or(SyntaxKind::EOF)
     }
+
     pub(crate) fn is_joint(&self, n: usize) -> bool {
         let (idx, b_idx) = self.bit_index(n);
         self.joint[idx] & (1 << b_idx) != 0
         let b_idx = n % (bits::BITS as usize);
         (idx, b_idx)
     }
+
     fn len(&self) -> usize {
         self.kind.len()
     }
     expect_file![p].assert_eq(&actual)
 }
 
-//! The Rust parser.
-//!
-//! NOTE: The crate is undergoing refactors, don't believe everything the docs
-//! say :-)
-//!
-//! The parser doesn't know about concrete representation of tokens and syntax
-//! trees. Abstract [`TokenSource`] and [`TreeSink`] traits are used instead. As
-//! a consequence, this crate does not contain a lexer.
-//!
-//! The [`Parser`] struct from the [`parser`] module is a cursor into the
-//! sequence of tokens.  Parsing routines use [`Parser`] to inspect current
-//! state and advance the parsing.
-//!
-//! The actual parsing happens in the [`grammar`] module.
-//!
-//! Tests for this crate live in the `syntax` crate.
-//!
-//! [`Parser`]: crate::parser::Parser
-
-#![allow(rustdoc::private_intra_doc_links)]
-#![cfg_attr(feature = "in-rust-tree", feature(rustc_private))]
+#
+#
 
 #[cfg(not(feature = "in-rust-tree"))]
-extern crate ra_ap_rustc_lexer as rustc_lexer;
 #[cfg(feature = "in-rust-tree")]
-extern crate rustc_lexer;
 
 mod event;
 mod frontmatter;
     }
 }
 
-//! This module provides a way to construct a `File`.
-//! It is intended to be completely decoupled from the
-//! parser, so as to allow to evolve the tree representation
-//! and the parser algorithm independently.
 use std::mem;
 
 use crate::{
 
 impl Event {
     pub(crate) fn tombstone() -> Self {
-        Event::Start { kind: TOMBSTONE, forward_parent: None }
+        Event::Start {
+            kind: TOMBSTONE,
+            forward_parent: None,
+        }
     }
 }
 
     res
 }
 
-//! This is the actual "grammar" of the Rust language.
-//!
-//! Each function in this module and its children corresponds
-//! to a production of the formal grammar. Submodules roughly
-//! correspond to different *areas* of the grammar. By convention,
-//! each submodule starts with `use super::*` import and exports
-//! "public" productions via `pub(super)`.
-//!
-//! See docs for [`Parser`](super::parser::Parser) to learn about API,
-//! available to the grammar, and see docs for [`Event`](super::event::Event)
-//! to learn how this actually manages to produce parse trees.
-//!
-//! Code in this module also contains inline tests, which start with
-//! `// test name-of-the-test` comment and look like this:
-//!
-//! ```text
-//! // test function_with_zero_parameters
-//! // fn foo() {}
-//! ```
-//!
-//! After adding a new inline-test, run `cargo test -p xtask` to
-//! extract it as a standalone text-fixture into
-//! `crates/syntax/test_data/parser/`, and run `cargo test` once to
-//! create the "gold" value.
-//!
-//! Coding convention: rules like `where_clause` always produce either a
-//! node or an error, rules like `opt_where_clause` may produce nothing.
-//! Non-opt rules typically start with `assert!(p.at(FIRST_TOKEN))`, the
-//! caller is responsible for branching on the first token.
-
 mod attributes;
 mod expressions;
 mod generic_args;
 
 pub(crate) mod entry {
     use super::*;
-
     pub(crate) mod prefix {
         use super::*;
-
         pub(crate) fn vis(p: &mut Parser<'_>) {
             opt_visibility(p, false);
         }
-
         pub(crate) fn block(p: &mut Parser<'_>) {
             expressions::block_expr(p);
         }
-
         pub(crate) fn stmt(p: &mut Parser<'_>) {
             expressions::stmt(p, expressions::Semicolon::Forbidden);
         }
-
         pub(crate) fn pat(p: &mut Parser<'_>) {
             patterns::pattern_single(p);
         }
-
         pub(crate) fn pat_top(p: &mut Parser<'_>) {
             patterns::pattern(p);
         }
-
         pub(crate) fn ty(p: &mut Parser<'_>) {
             types::type_(p);
         }
             // We can set `is_in_extern=true`, because it only allows `safe fn`, and there is no ambiguity here.
             items::item_or_macro(p, true, true);
         }
-        // Parse a meta item , which excluded [], e.g : #[ MetaItem ]
         pub(crate) fn meta_item(p: &mut Parser<'_>) {
             attributes::meta(p);
         }
     }
-
     pub(crate) mod top {
         use super::*;
-
         pub(crate) fn source_file(p: &mut Parser<'_>) {
             let m = p.start();
             // test frontmatter
             items::mod_contents(p, false);
             m.complete(p, SOURCE_FILE);
         }
-
         pub(crate) fn macro_stmts(p: &mut Parser<'_>) {
             let m = p.start();
 
 
             m.complete(p, MACRO_STMTS);
         }
-
         pub(crate) fn macro_items(p: &mut Parser<'_>) {
             let m = p.start();
             items::mod_contents(p, false);
             m.complete(p, MACRO_ITEMS);
         }
-
         pub(crate) fn pattern(p: &mut Parser<'_>) {
             let m = p.start();
             patterns::pattern(p);
             }
             m.complete(p, ERROR);
         }
-
         pub(crate) fn type_(p: &mut Parser<'_>) {
             let m = p.start();
             types::type_(p);
             }
             m.complete(p, ERROR);
         }
-
         pub(crate) fn expr(p: &mut Parser<'_>) {
             let m = p.start();
             expressions::expr(p);
             }
             m.complete(p, ERROR);
         }
-
         pub(crate) fn meta_item(p: &mut Parser<'_>) {
             let m = p.start();
             attributes::meta(p);
     }
 }
 
-const PATH_NAME_REF_KINDS: TokenSet =
-    TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self]]);
+const PATH_NAME_REF_KINDS: TokenSet = TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self]]);
 
 fn name_ref_mod_path(p: &mut Parser<'_>) {
     if p.at_ts(PATH_NAME_REF_KINDS) {
     }
 }
 
-const PATH_NAME_REF_OR_INDEX_KINDS: TokenSet =
-    PATH_NAME_REF_KINDS.union(TokenSet::new(&[INT_NUMBER]));
+const PATH_NAME_REF_OR_INDEX_KINDS: TokenSet = PATH_NAME_REF_KINDS.union(TokenSet::new(&[INT_NUMBER]));
 
 fn name_ref_mod_path_or_index(p: &mut Parser<'_>) {
     if p.at_ts(PATH_NAME_REF_OR_INDEX_KINDS) {
     m.complete(p, ERROR);
 }
 
-// test_err top_level_let
-// let ref foo: fn() = 1 + 3;
 fn error_let_stmt(p: &mut Parser<'_>, message: &str) {
     assert!(p.at(T![let]));
     let m = p.start();
     p.expect(ket);
 }
 
-//! See [`Parser`].
-
 use std::cell::Cell;
 
 use drop_bomb::DropBomb;
     }
 }
 
-//! See [`Output`]
-
 use crate::SyntaxKind;
 
 /// Output of the parser -- a DFS traversal of a concrete syntax tree.
 
 #[derive(Debug)]
 pub enum Step<'a> {
-    Token { kind: SyntaxKind, n_input_tokens: u8 },
-    FloatSplit { ends_in_dot: bool },
-    Enter { kind: SyntaxKind },
+    Token {
+        kind: SyntaxKind,
+        n_input_tokens: u8,
+    },
+    FloatSplit {
+        ends_in_dot: bool,
+    },
+    Enter {
+        kind: SyntaxKind,
+    },
     Exit,
-    Error { msg: &'a str },
+    Error {
+        msg: &'a str,
+    },
 }
 
 impl Output {
     const EVENT_MASK: u32 = 0b1;
+
     const TAG_MASK: u32 = 0x0000_00F0;
+
     const N_INPUT_TOKEN_MASK: u32 = 0x0000_FF00;
+
     const KIND_MASK: u32 = 0xFFFF_0000;
 
     const ERROR_SHIFT: u32 = Self::EVENT_MASK.trailing_ones();
+
     const TAG_SHIFT: u32 = Self::TAG_MASK.trailing_zeros();
+
     const N_INPUT_TOKEN_SHIFT: u32 = Self::N_INPUT_TOKEN_MASK.trailing_zeros();
+
     const KIND_SHIFT: u32 = Self::KIND_MASK.trailing_zeros();
 
     const TOKEN_EVENT: u8 = 0;
+
     const ENTER_EVENT: u8 = 1;
+
     const EXIT_EVENT: u8 = 2;
+
     const SPLIT_EVENT: u8 = 3;
 
     pub fn iter(&self) -> impl Iterator<Item = Step<'_>> {
     }
 }
 
-//! Defines [`SyntaxKind`] -- a fieldless enum of all possible syntactic
-//! constructs of the Rust language.
-
 #[rustfmt::skip]
 mod generated;
 
 use crate::Edition;
 
-#[allow(unreachable_pub)]
 pub use self::generated::SyntaxKind;
 
 impl From<u16> for SyntaxKind {
     #[inline]
     fn from(d: u16) -> SyntaxKind {
         assert!(d <= (SyntaxKind::__LAST as u16));
-        unsafe { std::mem::transmute::<u16, SyntaxKind>(d) }
+        unsafe {
+            std::mem::transmute::<u16, SyntaxKind>(d)
+        }
     }
 }
 
 
 use super::*;
 
-// test use_item
-// use std::collections;
 pub(super) fn use_(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![use]);
     use_tree(p, true);
     m.complete(p, USE);
 }
 
-// test use_tree
-// use outer::tree::{inner::tree};
 fn use_tree(p: &mut Parser<'_>, top_level: bool) -> bool {
     let m = p.start();
     match p.current() {
     true
 }
 
-pub(super) const USE_TREE_LIST_RECOVERY_SET: TokenSet =
-    TokenSet::new(&[T![;], T![,], T![.], T![ident]]).union(ITEM_RECOVERY_SET);
+pub(super) const USE_TREE_LIST_RECOVERY_SET: TokenSet = TokenSet::new(&[T![;], T![,], T![.], T![ident]]).union(ITEM_RECOVERY_SET);
 
 pub(super) const USE_TREE_LIST_FIRST_SET: TokenSet = TokenSet::new(&[T!['{'], T![ident]]);
 
-// test use_tree_list
-// use {a, b, c};
 pub(crate) fn use_tree_list(p: &mut Parser<'_>) {
     assert!(p.at(T!['{']));
     let m = p.start();
 
     // test_err use_tree_list_err_recovery
+
     // use {a;
+
     // use b;
+
     // struct T;
+
     // fn test() {}
+
     // use {a ,, b};
     delimited(
         p,
 
 use super::*;
 
-// test trait_item
-// trait T { fn new() -> Self; }
 pub(super) fn trait_(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![trait]);
     name_r(p, ITEM_RECOVERY_SET);
 
     // test trait_item_generic_params
+
     // trait X<U: Debug + Display> {}
     generic_params::opt_generic_param_list(p);
 
     }
 
     // test trait_item_where_clause
+
     // trait T where Self: Copy {}
     generic_params::opt_where_clause(p);
 
     m.complete(p, TRAIT);
 }
 
-// test impl_item
-// impl S {}
 pub(super) fn impl_(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![impl]);
     if p.at(T![<]) && not_a_qualified_path(p) {
     }
 
     // test impl_item_const
+
     // impl const Send for S {}
     p.eat(T![const]);
 
     // test impl_item_never_type
+
     // impl ! {}
     if p.at(T![!]) && !p.nth_at(1, T!['{']) {
         // test impl_item_neg
     m.complete(p, IMPL);
 }
 
-// test assoc_item_list
-// impl F {
-//     type A = i32;
-//     const B: i32 = 92;
-//     fn foo() {}
-//     fn bar(&self) {}
-// }
 pub(crate) fn assoc_item_list(p: &mut Parser<'_>) {
     assert!(p.at(T!['{']));
 
     m.complete(p, ASSOC_ITEM_LIST);
 }
 
-// test impl_type_params
-// impl<const N: u32> Bar<N> {}
 fn not_a_qualified_path(p: &Parser<'_>) -> bool {
     // There's an ambiguity between generic parameters and qualified paths in impls.
     // If we see `<` it may start both, so we have to inspect some following tokens.
     if [T![#], T![>], T![const]].contains(&p.nth(1)) {
         return true;
     }
-    ([LIFETIME_IDENT, IDENT].contains(&p.nth(1)))
-        && ([T![>], T![,], T![:], T![=]].contains(&p.nth(2)))
+    ([LIFETIME_IDENT, IDENT].contains(&p.nth(1))) && ([T![>], T![,], T![:], T![=]].contains(&p.nth(2)))
 }
 
-// test_err impl_type
-// impl Type {}
-// impl Trait1 for T {}
-// impl impl NotType {}
-// impl Trait2 for impl NotType {}
 pub(crate) fn impl_type(p: &mut Parser<'_>) {
     if p.at(T![impl]) {
         p.error("expected trait or type");
 
 use super::*;
 
-// test const_item
-// const C: u32 = 92;
 pub(super) fn konst(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![const]);
     const_or_static(p, m, true);
     // test_err static_where_clause
     // static C: u32 = 0
     // where i32: Copy;
-
     p.expect(T![;]);
     m.complete(p, if is_const { CONST } else { STATIC });
 }
 
 use super::*;
 
-// test struct_item
-// struct S {}
 pub(super) fn strukt(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![struct]);
     struct_or_union(p, m, true);
 }
 
-// test union_item
-// struct U { i: i32, f: f32 }
 pub(super) fn union(p: &mut Parser<'_>, m: Marker) {
     assert!(p.at_contextual_kw(T![union]));
     p.bump_remap(T![union]);
     }
 }
 
-// test record_field_list
-// struct S { a: i32, b: f32, unsafe c: u8 }
 pub(crate) fn record_field_list(p: &mut Parser<'_>) {
     assert!(p.at(T!['{']));
     let m = p.start();
     }
 }
 
-const TUPLE_FIELD_FIRST: TokenSet =
-    types::TYPE_FIRST.union(ATTRIBUTE_FIRST).union(VISIBILITY_FIRST);
+const TUPLE_FIELD_FIRST: TokenSet = types::TYPE_FIRST.union(ATTRIBUTE_FIRST).union(VISIBILITY_FIRST);
 
-// test_err tuple_field_list_recovery
-// struct S(struct S;
-// struct S(A,,B);
 fn tuple_field_list(p: &mut Parser<'_>) {
     assert!(p.at(T!['(']));
     let m = p.start();
 };
 use super::*;
 
-// test mod_contents
-// fn foo() {}
-// macro_rules! foo {}
-// foo::bar!();
-// super::baz! {}
-// struct S;
 pub(super) fn mod_contents(p: &mut Parser<'_>, stop_on_r_curly: bool) {
     attributes::inner_attrs(p);
     while !(p.at(EOF) || (p.at(T!['}']) && stop_on_r_curly)) {
     };
 
     // test macro_rules_as_macro_name
+
     // macro_rules! {}
+
     // macro_rules! ();
+
     // macro_rules! [];
+
     // fn main() {
+
     //     let foo = macro_rules!();
+
     // }
 
     // test_err macro_rules_as_macro_name
+
     // macro_rules! {};
+
     // macro_rules! ()
+
     // macro_rules! []
     if paths::is_use_path_start(p) {
         paths::use_path(p);
     }
 
     // test_err async_without_semicolon
+
     // fn foo() { let _ = async {} }
     if p.at(T![async])
         && (!matches!(p.nth(1), T!['{'] | T![gen] | T![move] | T![|])
     }
 
     // test_err gen_fn 2021
+
     // gen fn gen_fn() {}
+
     // async gen fn async_gen_fn() {}
     if p.at(T![gen]) && p.nth(1) == T![fn] {
         p.eat(T![gen]);
     }
 
     // test_err unsafe_block_in_mod
+
     // fn foo(){} unsafe { } fn bar(){}
     if p.at(T![unsafe]) && p.nth(1) != T!['{'] {
         p.eat(T![unsafe]);
     }
 
     // test safe_outside_of_extern
+
     // fn foo() { safe = true; }
     if is_in_extern && p.at_contextual_kw(T![safe]) {
         p.eat_contextual_kw(T![safe]);
     }
 
     // test default_item
+
     // default impl T for Foo {}
     if p.at_contextual_kw(T![default]) {
         match p.nth(1) {
     Ok(())
 }
 
-// test extern_crate
-// extern crate foo;
-// extern crate self;
 fn extern_crate(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![extern]);
     p.bump(T![crate]);
     name_ref_or_self(p);
 
     // test extern_crate_rename
+
     // extern crate foo as bar;
+
     // extern crate self as bar;
     opt_rename(p);
     p.expect(T![;]);
     m.complete(p, EXTERN_CRATE);
 }
 
-// test mod_item
-// mod a;
 pub(crate) fn mod_item(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![mod]);
     name(p);
     m.complete(p, MODULE);
 }
 
-// test type_alias
-// type Foo = Bar;
 fn type_alias(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![type]);
 
     name(p);
 
     // test type_item_type_params
+
     // type Result<T> = ();
     generic_params::opt_generic_param_list(p);
 
     }
 
     // test type_item_where_clause_deprecated
+
     // type Foo where Foo: Copy = ();
     generic_params::opt_where_clause(p);
     if p.eat(T![=]) {
     }
 
     // test type_item_where_clause
+
     // type Foo = () where Foo: Copy;
     generic_params::opt_where_clause(p);
 
     m.complete(p, EXTERN_ITEM_LIST);
 }
 
-// test try_macro_rules 2015
-// macro_rules! try { () => {} }
 fn macro_rules(p: &mut Parser<'_>, m: Marker) {
     assert!(p.at_contextual_kw(T![macro_rules]));
     p.bump_remap(T![macro_rules]);
     m.complete(p, MACRO_RULES);
 }
 
-// test macro_def
-// macro m($i:ident) {}
 fn macro_def(p: &mut Parser<'_>, m: Marker) {
     p.expect(T![macro]);
     name_r(p, ITEM_RECOVERY_SET);
     m.complete(p, MACRO_DEF);
 }
 
-// test fn_
-// fn foo() {}
 fn fn_(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![fn]);
 
     opt_ret_type(p);
 
     // test_err fn_ret_recovery
+
     // fn foo() -> A>]) { let x = 1; }
+
     // fn foo() -> A>]) where T: Copy { let x = 1; }
     while p.at(T![')']) | p.at(T![']']) | p.at(T![>]) {
         // recover from unbalanced return type brackets
     }
 
     // test function_where_clause
+
     // fn foo<T>() where T: Copy {}
     generic_params::opt_where_clause(p);
 
     // test fn_decl
+
     // trait T { fn foo(); }
     if !p.eat(T![;]) {
         expressions::block_expr(p);
 
 use super::*;
 
-// test expr_literals
-// fn foo() {
-//     let _ = true;
-//     let _ = false;
-//     let _ = 1;
-//     let _ = 2.0;
-//     let _ = b'a';
-//     let _ = 'b';
-//     let _ = "c";
-//     let _ = r"d";
-//     let _ = b"e";
-//     let _ = br"f";
-//     let _ = c"g";
-//     let _ = cr"h";
-// }
 pub(crate) const LITERAL_FIRST: TokenSet = TokenSet::new(&[
     T![true],
     T![false],
     Some(m.complete(p, LITERAL))
 }
 
-// E.g. for after the break in `if break {}`, this should not match
-pub(super) const ATOM_EXPR_FIRST: TokenSet =
-    LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[
+pub(super) const ATOM_EXPR_FIRST: TokenSet = LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[
         T!['('],
         T!['{'],
         T!['['],
         LIFETIME_IDENT,
     ]));
 
-pub(in crate::grammar) const EXPR_RECOVERY_SET: TokenSet =
-    TokenSet::new(&[T!['}'], T![')'], T![']'], T![,]]);
+pub(in crate::grammar) const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T!['}'], T![')'], T![']'], T![,]]);
 
 pub(super) fn atom_expr(
     p: &mut Parser<'_>,
     Some((done, blocklike))
 }
 
-// test tuple_expr
-// fn foo() {
-//     ();
-//     (1);
-//     (1,);
-// }
 fn tuple_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T!['(']));
     let m = p.start();
     let mut saw_expr = false;
 
     // test_err tuple_expr_leading_comma
+
     // fn foo() {
+
     //     (,);
+
     // }
     if p.eat(T![,]) {
         p.error("expected expression");
         }
     }
     p.expect(T![')']);
-    m.complete(p, if saw_expr && !saw_comma { PAREN_EXPR } else { TUPLE_EXPR })
+    m.complete(
+        p,
+        if saw_expr && !saw_comma {
+        PAREN_EXPR
+    } else {
+        TUPLE_EXPR
+    },
+    )
 }
 
-// test builtin_expr
-// fn foo() {
-//     builtin#asm("");
-//     builtin#format_args("", 0, 1, a = 2 + 3, a + b);
-//     builtin#offset_of(Foo, bar.baz.0);
-// }
 fn builtin_expr(p: &mut Parser<'_>) -> Option<CompletedMarker> {
     let m = p.start();
     p.bump_remap(T![builtin]);
     p.bump(T![#]);
     if p.eat_contextual_kw(T![offset_of]) {
-        p.expect(T!['(']);
-        type_(p);
-        p.expect(T![,]);
         // Due to our incomplete handling of macro groups, especially
         // those with empty delimiters, we wrap `expr` fragments in
         // parentheses sometimes. Since `offset_of` is a macro, and takes
         // `expr`, the field names could be wrapped in parentheses.
-        let wrapped_in_parens = p.eat(T!['(']);
         // test offset_of_parens
         // fn foo() {
         //     builtin#offset_of(Foo, (bar.baz.0));
         // }
+        p.expect(T!['(']);
+        type_(p);
+        p.expect(T![,]);
+        let wrapped_in_parens = p.eat(T!['(']);
         while !p.at(EOF) && !p.at(T![')']) {
             name_ref_mod_path_or_index(p);
             if !p.at(T![')']) {
         }
         p.expect(T![')']);
         Some(m.complete(p, FORMAT_ARGS_EXPR))
-    } else if p.eat_contextual_kw(T![asm])
-        || p.eat_contextual_kw(T![global_asm])
-        || p.eat_contextual_kw(T![naked_asm])
-    {
+    } else if p.eat_contextual_kw(T![asm]) || p.eat_contextual_kw(T![global_asm]) || p.eat_contextual_kw(T![naked_asm]) {
         // test asm_kinds
         // fn foo() {
         //     builtin#asm("");
     }
 }
 
-// test asm_expr
-// fn foo() {
-//     builtin#asm(
-//         "mov {tmp}, {x}",
-//         "shl {tmp}, 1",
-//         "shl {x}, 2",
-//         "add {x}, {tmp}",
-//         x = inout(reg) x,
-//         tmp = out(reg) _,
-//     );
-// }
 pub(crate) fn parse_asm_expr(p: &mut Parser<'_>, m: Marker) -> Option<CompletedMarker> {
     p.expect(T!['(']);
     if expr(p).is_none() {
     p.expect(T!['(']);
 
     while !p.eat(T![')']) && !p.at(EOF) {
+        // Allow trailing commas
         const OPTIONS: &[SyntaxKind] = &[
             T![pure],
             T![nomem],
             continue;
         }
         m.complete(p, ASM_OPTION);
-
-        // Allow trailing commas
         if p.eat(T![')']) {
             break;
         }
     p.expect(T!['(']);
 
     while !p.eat(T![')']) && !p.at(EOF) {
+        // Allow trailing commas
         if !p.expect(T![string]) {
             break;
         }
-
-        // Allow trailing commas
         if p.eat(T![')']) {
             break;
         }
     p.expect(T![')']);
 }
 
-// test array_expr
-// fn foo() {
-//     [];
-//     [1];
-//     [1, 2,];
-//     [1; 2];
-// }
 fn array_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T!['[']));
     let m = p.start();
     m.complete(p, ARRAY_EXPR)
 }
 
-// test lambda_expr
-// fn foo() {
-//     || ();
-//     || -> i32 { 92 };
-//     |x| x;
-//     move |x: i32,| x;
-//     async || {};
-//     move || {};
-//     async move || {};
-//     static || {};
-//     static move || {};
-//     static async || {};
-//     static async move || {};
-//     for<'a> || {};
-//     for<'a> move || {};
-// }
 fn closure_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(match p.current() {
         T![const] | T![static] | T![async] | T![move] | T![|] => true,
     let m = p.start();
 
     // test closure_binder
+
     // fn main() { for<'a> || (); }
     if p.at(T![for]) {
         types::for_binder(p);
     m.complete(p, CLOSURE_EXPR)
 }
 
-// test if_expr
-// fn foo() {
-//     if true {};
-//     if true {} else {};
-//     if true {} else if false {} else {};
-//     if S {};
-//     if { true } { } else { };
-// }
 fn if_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![if]));
     let m = p.start();
     m.complete(p, IF_EXPR)
 }
 
-// test label
-// fn foo() {
-//     'a: loop {}
-//     'b: while true {}
-//     'c: for x in () {}
-// }
 fn label(p: &mut Parser<'_>) {
     assert!(p.at(LIFETIME_IDENT) && p.nth(1) == T![:]);
     let m = p.start();
     m.complete(p, LABEL);
 }
 
-// test loop_expr
-// fn foo() {
-//     loop {};
-// }
 fn loop_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {
     assert!(p.at(T![loop]));
     let m = m.unwrap_or_else(|| p.start());
     m.complete(p, LOOP_EXPR)
 }
 
-// test while_expr
-// fn foo() {
-//     while true {};
-//     while let Some(x) = it.next() {};
-//     while { true } {};
-// }
 fn while_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {
     assert!(p.at(T![while]));
     let m = m.unwrap_or_else(|| p.start());
     m.complete(p, WHILE_EXPR)
 }
 
-// test for_expr
-// fn foo() {
-//     for x in [] {};
-// }
 fn for_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {
     assert!(p.at(T![for]));
     let m = m.unwrap_or_else(|| p.start());
     m.complete(p, FOR_EXPR)
 }
 
-// test let_expr
-// fn foo() {
-//     if let Some(_) = None && true {}
-//     while 1 == 5 && (let None = None) {}
-// }
 fn let_expr(p: &mut Parser<'_>) -> CompletedMarker {
     let m = p.start();
     p.bump(T![let]);
     m.complete(p, LET_EXPR)
 }
 
-// test match_expr
-// fn foo() {
-//     match () { };
-//     match S {};
-//     match { } { _ => () };
-//     match { S {} } {};
-// }
 fn match_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![match]));
     let m = p.start();
     m.complete(p, MATCH_EXPR)
 }
 
-// test_err match_arms_recovery
-// fn foo() {
-//     match () {
-//         _ => (),,
-//         _ => ,
-//         _ => (),
-//          => (),
-//         if true => (),
-//         _ => (),
-//         () if => (),
-//     }
-// }
 pub(crate) fn match_arm_list(p: &mut Parser<'_>) {
     assert!(p.at(T!['{']));
     let m = p.start();
     p.eat(T!['{']);
 
     // test match_arms_inner_attribute
+
     // fn foo() {
+
     //     match () {
+
     //         #![doc("Inner attribute")]
+
     //         #![doc("Can be")]
+
     //         #![doc("Stacked")]
+
     //         _ => (),
+
     //     }
+
     // }
     attributes::inner_attrs(p);
 
     m.complete(p, MATCH_ARM_LIST);
 }
 
-// test match_arm
-// fn foo() {
-//     match () {
-//         _ => (),
-//         _ if Test > Test{field: 0} => (),
-//         X | Y if Z => (),
-//         | X | Y if Z => (),
-//         | X => (),
-//     };
-// }
 fn match_arm(p: &mut Parser<'_>) {
     let m = p.start();
     // test match_arms_outer_attributes
     m.complete(p, MATCH_ARM);
 }
 
-// test match_guard
-// fn foo() {
-//     match () {
-//         _ if foo => (),
-//         _ if let foo = bar => (),
-//     }
-// }
 fn match_guard(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![if]));
     let m = p.start();
     m.complete(p, MATCH_GUARD)
 }
 
-// test block
-// fn a() {}
-// fn b() { let _ = 1; }
-// fn c() { 1; 2; }
-// fn d() { 1; 2 }
 pub(crate) fn block_expr(p: &mut Parser<'_>) {
     if !p.at(T!['{']) {
         p.error("expected a block");
     m.complete(p, STMT_LIST)
 }
 
-// test return_expr
-// fn foo() {
-//     return;
-//     return 92;
-// }
 fn return_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![return]));
     let m = p.start();
     m.complete(p, RETURN_EXPR)
 }
 
-// test become_expr
-// fn foo() {
-//     become foo();
-// }
 fn become_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![become]));
     let m = p.start();
     m.complete(p, BECOME_EXPR)
 }
 
-// test yield_expr
-// fn foo() {
-//     yield;
-//     yield 1;
-// }
 fn yield_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![yield]));
     let m = p.start();
     m.complete(p, YIELD_EXPR)
 }
 
-// test yeet_expr
-// fn foo() {
-//     do yeet;
-//     do yeet 1
-// }
 fn yeet_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![do]));
     assert!(p.nth_at_contextual_kw(1, T![yeet]));
     m.complete(p, YEET_EXPR)
 }
 
-// test continue_expr
-// fn foo() {
-//     loop {
-//         continue;
-//         continue 'l;
-//     }
-// }
 fn continue_expr(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![continue]));
     let m = p.start();
     m.complete(p, CONTINUE_EXPR)
 }
 
-// test break_expr
-// fn foo() {
-//     loop {
-//         break;
-//         break 'l;
-//         break 92;
-//         break 'l 92;
-//     }
-// }
 fn break_expr(p: &mut Parser<'_>, r: Restrictions) -> CompletedMarker {
     assert!(p.at(T![break]));
     let m = p.start();
     m.complete(p, BREAK_EXPR)
 }
 
-// test try_block_expr
-// fn foo() {
-//     let _ = try {};
-// }
 fn try_block_expr(p: &mut Parser<'_>, m: Option<Marker>) -> CompletedMarker {
     assert!(p.at(T![try]));
     let m = m.unwrap_or_else(|| p.start());
 use super::*;
 
 // test param_list
-// fn a() {}
-// fn b(x: i32) {}
-// fn c(x: i32, ) {}
-// fn d(x: i32, y: ()) {}
 
-// test_err empty_param_slot
-// fn f(y: i32, ,t: i32) {}
+// fn a() {}
+
+// fn b(x: i32) {}
+
+// fn c(x: i32, ) {}
+
+// fn d(x: i32, y: ()) {}
 pub(super) fn param_list_fn_def(p: &mut Parser<'_>) {
     list_(p, Flavor::FnDef);
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 enum Flavor {
-    FnDef, // Includes trait fn params; omitted param idents are not supported
+    FnDef,
+    // Includes trait fn params; omitted param idents are not supported
     FnPointer,
     Closure,
 }
     }
 }
 
-// test self_param
-// impl S {
-//     fn a(self) {}
-//     fn b(&self,) {}
-//     fn c(&'a self,) {}
-//     fn d(&'a mut self, x: i32) {}
-//     fn e(mut self) {}
-// }
 fn opt_self_param(p: &mut Parser<'_>, m: Marker) -> Result<(), Marker> {
     if p.at(T![self]) || p.at(T![mut]) && p.nth(1) == T![self] {
         p.eat(T![mut]);
 }
 
 // test_err meta_recovery
-// #![]
-// #![p = ]
-// #![p::]
-// #![p:: =]
-// #![unsafe]
-// #![unsafe =]
 
-// test metas
-// #![simple_ident]
-// #![simple::path]
-// #![simple_ident_expr = ""]
-// #![simple::path::Expr = ""]
-// #![simple_ident_tt(a b c)]
-// #![simple_ident_tt[a b c]]
-// #![simple_ident_tt{a b c}]
-// #![simple::path::tt(a b c)]
-// #![simple::path::tt[a b c]]
-// #![simple::path::tt{a b c}]
-// #![unsafe(simple_ident)]
-// #![unsafe(simple::path)]
-// #![unsafe(simple_ident_expr = "")]
-// #![unsafe(simple::path::Expr = "")]
-// #![unsafe(simple_ident_tt(a b c))]
-// #![unsafe(simple_ident_tt[a b c])]
-// #![unsafe(simple_ident_tt{a b c})]
-// #![unsafe(simple::path::tt(a b c))]
-// #![unsafe(simple::path::tt[a b c])]
-// #![unsafe(simple::path::tt{a b c})]
+// #![]
+
+// #![p = ]
+
+// #![p::]
+
+// #![p:: =]
+
+// #![unsafe]
+
+// #![unsafe =]
 pub(super) fn meta(p: &mut Parser<'_>) {
     let meta = p.start();
     let is_unsafe = p.eat(T![unsafe]);
     }
 
     // test block_items
+
     // fn a() { fn b() {} }
     let m = match items::opt_item(p, m, false) {
         Ok(()) => return,
         return;
     }
 
-    if let Some((cm, blocklike)) = expr_stmt(p, Some(m))
-        && !(p.at(T!['}']) || (semicolon != Semicolon::Required && p.at(EOF)))
-    {
+    if let Some((cm, blocklike)) = expr_stmt(p, Some(m)) && !(p.at(T!['}']) || (semicolon != Semicolon::Required && p.at(EOF))) {
         // test no_semi_after_block
         // fn foo() {
         //     if true {}
     }
 }
 
-// test let_stmt
-// fn f() { let x: i32 = 92; super let y; super::foo; }
 pub(super) fn let_stmt(p: &mut Parser<'_>, with_semi: Semicolon) {
     p.eat(T![super]);
     p.bump(T![let]);
         // fn foo(){
         //     ;;;some_expr();;;;{;;;};;;;Ok(())
         // }
-
         // test nocontentexpr_after_item
         // fn simple_function() {
         //     enum LocalEnum {
     use Associativity::*;
     const NOT_AN_OP: (u8, SyntaxKind, Associativity) = (0, T![@], Left);
     match p.current() {
-        T![|] if p.at(T![||])  => (3,  T![||],  Left),
-        T![|] if p.at(T![|=])  => (1,  T![|=],  Right),
-        T![|]                  => (6,  T![|],   Left),
-        T![>] if p.at(T![>>=]) => (1,  T![>>=], Right),
-        T![>] if p.at(T![>>])  => (9,  T![>>],  Left),
-        T![>] if p.at(T![>=])  => (5,  T![>=],  Left),
-        T![>]                  => (5,  T![>],   Left),
-        T![=] if p.at(T![==])  => (5,  T![==],  Left),
-        T![=] if !p.at(T![=>]) => (1,  T![=],   Right),
-        T![<] if p.at(T![<=])  => (5,  T![<=],  Left),
-        T![<] if p.at(T![<<=]) => (1,  T![<<=], Right),
-        T![<] if p.at(T![<<])  => (9,  T![<<],  Left),
-        T![<]                  => (5,  T![<],   Left),
-        T![+] if p.at(T![+=])  => (1,  T![+=],  Right),
-        T![+]                  => (10, T![+],   Left),
-        T![^] if p.at(T![^=])  => (1,  T![^=],  Right),
-        T![^]                  => (7,  T![^],   Left),
-        T![%] if p.at(T![%=])  => (1,  T![%=],  Right),
-        T![%]                  => (11, T![%],   Left),
-        T![&] if p.at(T![&=])  => (1,  T![&=],  Right),
+        T![|] if p.at(T![||]) => (3, T![||], Left),
+        T![|] if p.at(T![|=]) => (1, T![|=], Right),
+        T![|] => (6, T![|], Left),
+        T![>] if p.at(T![>>=]) => (1, T![>>=], Right),
+        T![>] if p.at(T![>>]) => (9, T![>>], Left),
+        T![>] if p.at(T![>=]) => (5, T![>=], Left),
+        T![>] => (5, T![>], Left),
+        T![=] if p.at(T![==]) => (5, T![==], Left),
+        T![=] if !p.at(T![=>]) => (1, T![=], Right),
+        T![<] if p.at(T![<=]) => (5, T![<=], Left),
+        T![<] if p.at(T![<<=]) => (1, T![<<=], Right),
+        T![<] if p.at(T![<<]) => (9, T![<<], Left),
+        T![<] => (5, T![<], Left),
+        T![+] if p.at(T![+=]) => (1, T![+=], Right),
+        T![+] => (10, T![+], Left),
+        T![^] if p.at(T![^=]) => (1, T![^=], Right),
+        T![^] => (7, T![^], Left),
+        T![%] if p.at(T![%=]) => (1, T![%=], Right),
+        T![%] => (11, T![%], Left),
+        T![&] if p.at(T![&=]) => (1, T![&=], Right),
         // If you update this, remember to update `expr_let()` too.
-        T![&] if p.at(T![&&])  => (4,  T![&&],  Left),
-        T![&]                  => (8,  T![&],   Left),
-        T![/] if p.at(T![/=])  => (1,  T![/=],  Right),
-        T![/]                  => (11, T![/],   Left),
-        T![*] if p.at(T![*=])  => (1,  T![*=],  Right),
-        T![*]                  => (11, T![*],   Left),
-        T![.] if p.at(T![..=]) => (2,  T![..=], Left),
-        T![.] if p.at(T![..])  => (2,  T![..],  Left),
-        T![!] if p.at(T![!=])  => (5,  T![!=],  Left),
-        T![-] if p.at(T![-=])  => (1,  T![-=],  Right),
-        T![-]                  => (10, T![-],   Left),
-        T![as]                 => (12, T![as],  Left),
+        T![&] if p.at(T![&&]) => (4, T![&&], Left),
+        T![&] => (8, T![&], Left),
+        T![/] if p.at(T![/=]) => (1, T![/=], Right),
+        T![/] => (11, T![/], Left),
+        T![*] if p.at(T![*=]) => (1, T![*=], Right),
+        T![*] => (11, T![*], Left),
+        T![.] if p.at(T![..=]) => (2, T![..=], Left),
+        T![.] if p.at(T![..]) => (2, T![..], Left),
+        T![!] if p.at(T![!=]) => (5, T![!=], Left),
+        T![-] if p.at(T![-=]) => (1, T![-=], Right),
+        T![-] => (10, T![-], Left),
+        T![as] => (12, T![as], Left),
 
-        _                      => NOT_AN_OP
+        _ => NOT_AN_OP,
     }
 }
 
-// Parses expression with binding power of at least bp.
 fn expr_bp(
     p: &mut Parser<'_>,
     m: Option<Marker>,
     Some((lhs, BlockLike::NotBlock))
 }
 
-const LHS_FIRST: TokenSet =
-    atom::ATOM_EXPR_FIRST.union(TokenSet::new(&[T![&], T![*], T![!], T![.], T![-], T![_]]));
+const LHS_FIRST: TokenSet = atom::ATOM_EXPR_FIRST.union(TokenSet::new(&[T![&], T![*], T![!], T![.], T![-], T![_]]));
 
 fn lhs(p: &mut Parser<'_>, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {
     let m;
 fn postfix_expr(
     p: &mut Parser<'_>,
     mut lhs: CompletedMarker,
-    // Calls are disallowed if the type is a block and we prefer statements because the call cannot be disambiguated from a tuple
-    // E.g. `while true {break}();` is parsed as
-    // `while true {break}; ();`
     mut block_like: BlockLike,
     mut allow_calls: bool,
 ) -> (CompletedMarker, BlockLike) {
     }
 
     // test await_expr
+
     // fn foo() {
+
     //     x.await;
+
     //     x.0.await;
+
     //     x.0().await?.hello();
+
     //     x.0.0.await;
+
     //     x.0. await;
+
     // }
     if p.nth(nth1) == T![await] {
         let m = lhs.precede(p);
     field_expr::<FLOAT_RECOVERY>(p, lhs)
 }
 
-// test call_expr
-// fn foo() {
-//     let _ = f();
-//     let _ = f()(1)(1, 2,);
-//     let _ = f(<Foo>::func());
-//     f(<Foo as Trait>::func());
-// }
 fn call_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {
     assert!(p.at(T!['(']));
     let m = lhs.precede(p);
     m.complete(p, CALL_EXPR)
 }
 
-// test index_expr
-// fn foo() {
-//     x[1][2];
-// }
 fn index_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {
     assert!(p.at(T!['[']));
     let m = lhs.precede(p);
     m.complete(p, INDEX_EXPR)
 }
 
-// test method_call_expr
-// fn foo() {
-//     x.foo();
-//     y.bar::<T>(1, 2,);
-//     x.0.0.call();
-//     x.0. call();
-//     x.0()
-// }
 fn method_call_expr<const FLOAT_RECOVERY: bool>(
     p: &mut Parser<'_>,
     lhs: CompletedMarker,
     m.complete(p, METHOD_CALL_EXPR)
 }
 
-// test field_expr
-// fn foo() {
-//     x.self;
-//     x.Self;
-//     x.foo;
-//     x.0.bar;
-//     x.0.1;
-//     x.0. bar;
-//     x.0();
-// }
 fn field_expr<const FLOAT_RECOVERY: bool>(
     p: &mut Parser<'_>,
     lhs: CompletedMarker,
     Ok(m.complete(p, FIELD_EXPR))
 }
 
-// test try_expr
-// fn foo() {
-//     x?;
-// }
 fn try_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {
     assert!(p.at(T![?]));
     let m = lhs.precede(p);
     m.complete(p, TRY_EXPR)
 }
 
-// test cast_expr
-// fn foo() {
-//     82 as i32;
-//     81 as i8 + 1;
-//     79 as i16 - 1;
-//     0x36 as u8 <= 0x37;
-// }
 fn cast_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {
     assert!(p.at(T![as]));
     let m = lhs.precede(p);
     m.complete(p, CAST_EXPR)
 }
 
-// test_err arg_list_recovery
-// fn main() {
-//     foo(bar::);
-//     foo(bar:);
-//     foo(bar+);
-//     foo(a, , b);
-// }
 fn arg_list(p: &mut Parser<'_>) {
     assert!(p.at(T!['(']));
     let m = p.start();
     m.complete(p, ARG_LIST);
 }
 
-// test path_expr
-// fn foo() {
-//     let _ = a;
-//     let _ = a::b;
-//     let _ = ::a::<b>;
-//     let _ = format!();
-// }
 fn path_expr(p: &mut Parser<'_>, r: Restrictions) -> (CompletedMarker, BlockLike) {
     assert!(paths::is_path_start(p));
     let m = p.start();
     }
 }
 
-// test record_lit
-// fn foo() {
-//     S {};
-//     S { x };
-//     S { x, y: 32, };
-//     S { x, y: 32, ..Default::default() };
-//     S { x, y: 32, .. };
-//     S { .. };
-//     S { x: ::default() };
-//     TupleStruct { 0: 1 };
-// }
 pub(crate) fn record_expr_field_list(p: &mut Parser<'_>) {
     assert!(p.at(T!['{']));
     let m = p.start();
 
 use super::*;
 
-// test_err generic_arg_list_recover_expr
-// const _: () = T::<0, ,T>;
-// const _: () = T::<0, ,T>();
 pub(super) fn opt_generic_arg_list_expr(p: &mut Parser<'_>) {
     let m;
     if p.at(T![::]) && p.nth(2) == T![<] {
 ])
 .union(types::TYPE_FIRST);
 
-// Despite its name, it can also be used for generic param list.
 const GENERIC_ARG_RECOVERY_SET: TokenSet = TokenSet::new(&[T![>], T![,]]);
 
-// test generic_arg
-// type T = S<i32, dyn T, fn()>;
 pub(crate) fn generic_arg(p: &mut Parser<'_>) -> bool {
     match p.current() {
         LIFETIME_IDENT if !p.nth_at(1, T![+]) => lifetime_arg(p),
     true
 }
 
-// test lifetime_arg
-// type T = S<'static>;
 fn lifetime_arg(p: &mut Parser<'_>) {
     let m = p.start();
     lifetime(p);
     }
 }
 
-// test const_arg
-// type T = S<92>;
 pub(super) fn const_arg(p: &mut Parser<'_>) {
     let m = p.start();
     const_arg_expr(p);
 }
 
 // test generic_param_list
-// fn f<T: Clone>() {}
 
-// test_err generic_param_list_recover
-// fn f<T: Clone,, U:, V>() {}
+// fn f<T: Clone>() {}
 pub(super) fn generic_param_list(p: &mut Parser<'_>) {
     assert!(p.at(T![<]));
     let m = p.start();
     true
 }
 
-// test lifetime_param
-// fn f<'a: 'b>() {}
 fn lifetime_param(p: &mut Parser<'_>, m: Marker) {
     assert!(p.at(LIFETIME_IDENT));
     lifetime(p);
     m.complete(p, LIFETIME_PARAM);
 }
 
-// test type_param
-// fn f<T: Clone>() {}
 fn type_param(p: &mut Parser<'_>, m: Marker) {
     assert!(p.at(IDENT));
     name(p);
     m.complete(p, TYPE_PARAM);
 }
 
-// test const_param
-// struct S<const N: u32>;
 fn const_param(p: &mut Parser<'_>, m: Marker) {
     p.bump(T![const]);
     name(p);
     marker.complete(p, TYPE_BOUND_LIST);
 }
 
-// test type_param_bounds
-// struct S<T: 'a + ?Sized + (Copy) + [const] Drop>;
 pub(super) fn bounds(p: &mut Parser<'_>) {
     p.expect(T![:]);
     bounds_without_colon(p);
     p.eat(T![?]);
 
     // test_err invalid_question_for_type_trait_bound
-    // fn f<T>() where T: ?for<> Sized {}
 
+    // fn f<T>() where T: ?for<> Sized {}
     if paths::is_use_path_start(p) {
-        types::path_type_bounds(p, false);
         // test_err type_bounds_macro_call_recovery
         // fn foo<T: T![], T: T!, T: T!{}>() -> Box<T! + T!{}> {}
+        types::path_type_bounds(p, false);
         if p.at(T![!]) {
             let m = p.start();
             p.bump(T![!]);
     }
 }
 
-// test where_clause
-// fn foo()
-// where
-//    'a: 'b + 'c,
-//    T: Clone + Copy + 'static,
-//    Iterator::Item: 'a,
-//    <T as Iterator>::Item: 'a
-// {}
 pub(super) fn opt_where_clause(p: &mut Parser<'_>) {
     if !p.at(T![where]) {
         return;
     m.complete(p, kind);
 }
 
-// test never_type
-// type Never = !;
 fn never_type(p: &mut Parser<'_>) {
     assert!(p.at(T![!]));
     let m = p.start();
     m.complete(p, kind);
 }
 
-// test reference_type
-// type A = &();
-// type B = &'static ();
-// type C = &mut ();
 fn ref_type(p: &mut Parser<'_>) {
     assert!(p.at(T![&]));
     let m = p.start();
     m.complete(p, REF_TYPE);
 }
 
-// test placeholder_type
-// type Placeholder = _;
 fn infer_type(p: &mut Parser<'_>) {
     assert!(p.at(T![_]));
     let m = p.start();
     m.complete(p, INFER_TYPE);
 }
 
-// test fn_pointer_type
-// type A = fn();
-// type B = unsafe fn();
-// type C = unsafe extern "C" fn();
-// type D = extern "C" fn ( u8 , ... ) -> u8;
 fn fn_ptr_type(p: &mut Parser<'_>) {
     let m = p.start();
     p.eat(T![unsafe]);
     m.complete(p, FOR_BINDER);
 }
 
-// test for_type
-// type A = for<'a> fn() -> ();
-// type B = for<'a> unsafe extern "C" fn(&'a ()) -> ();
-// type Obj = for<'a> PartialEq<&'a i32>;
 pub(super) fn for_type(p: &mut Parser<'_>, allow_bounds: bool) {
     assert!(p.at(T![for]));
     let m = p.start();
     let completed = m.complete(p, FOR_TYPE);
 
     // test no_dyn_trait_leading_for
+
     // type A = for<'a> Test<'a> + Send;
     if allow_bounds {
         opt_type_bounds_as_dyn_trait_type(p, completed);
     }
 }
 
-// test impl_trait_type
-// type A = impl Iterator<Item=Foo<'a>> + 'a;
 fn impl_trait_type(p: &mut Parser<'_>) {
     assert!(p.at(T![impl]));
     let m = p.start();
     m.complete(p, IMPL_TRAIT_TYPE);
 }
 
-// test dyn_trait_type
-// type A = dyn Iterator<Item=Foo<'a>> + 'a;
 fn dyn_trait_type(p: &mut Parser<'_>) {
     assert!(p.at(T![dyn]));
     let m = p.start();
     m.complete(p, DYN_TRAIT_TYPE);
 }
 
-// test dyn_trait_type_weak 2015
-// type DynPlain = dyn Path;
-// type DynRef = &dyn Path;
-// type DynLt = dyn 'a + Path;
-// type DynQuestion = dyn ?Path;
-// type DynFor = dyn for<'a> Path;
-// type DynParen = dyn(Path);
-// type Path = dyn::Path;
-// type Generic = dyn<Path>;
 fn dyn_trait_type_weak(p: &mut Parser<'_>) {
     assert!(p.at_contextual_kw(T![dyn]));
     let m = p.start();
     m.complete(p, DYN_TRAIT_TYPE);
 }
 
-// test bare_dyn_types_with_leading_lifetime
-// type A = 'static + Trait;
-// type B = S<'static + Trait>;
 fn bare_dyn_trait_type(p: &mut Parser<'_>) {
     let m = p.start();
     generic_params::bounds_without_colon(p);
     m.complete(p, DYN_TRAIT_TYPE);
 }
 
-// test macro_call_type
-// type A = foo!();
-// type B = crate::foo!();
 fn path_or_macro_type(p: &mut Parser<'_>, allow_bounds: bool) {
     assert!(paths::is_path_start(p));
     let r = p.start();
     }
 }
 
-// test path_type
-// type A = Foo;
-// type B = ::Foo;
-// type C = self::Foo;
-// type D = super::Foo;
 pub(super) fn path_type_bounds(p: &mut Parser<'_>, allow_bounds: bool) {
     assert!(paths::is_path_start(p));
     let m = p.start();
     paths::type_path(p);
 
     // test path_type_with_bounds
+
     // fn foo() -> Box<T + 'f> {}
+
     // fn foo() -> Box<dyn T + 'f> {}
     let path = m.complete(p, PATH_TYPE);
     if allow_bounds {
     let m = m.precede(p);
 
     // This gets consumed here so it gets properly set
+
     // in the TYPE_BOUND_LIST
     p.eat(T![+]);
 
 
 use super::*;
 
-pub(super) const PATTERN_FIRST: TokenSet =
-    expressions::LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[
+pub(super) const PATTERN_FIRST: TokenSet = expressions::LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[
         T![box],
         T![ref],
         T![mut],
 const PAT_TOP_FIRST: TokenSet = PATTERN_FIRST.union(TokenSet::new(&[T![|]]));
 
 /// Set of possible tokens at the start of a range pattern's end bound.
-const RANGE_PAT_END_FIRST: TokenSet =
-    expressions::LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[T![-], T![const]]));
+const RANGE_PAT_END_FIRST: TokenSet = expressions::LITERAL_FIRST.union(paths::PATH_FIRST).union(TokenSet::new(&[T![-], T![const]]));
 
 /// Parses a pattern list separated by pipes `|`.
 pub(crate) fn pattern(p: &mut Parser<'_>) {
     pattern_r(p, recovery_set);
 }
 
-// test or_pattern
-// fn main() {
-//     match () {
-//         (_ | _) => (),
-//         &(_ | _) => (),
-//         (_ | _,) => (),
-//         [_ | _,] => (),
-//     }
-// }
 /// Parses a pattern list separated by pipes `|`, with no leading `|`,using the
 /// given `recovery_set`.
 fn pattern_r(p: &mut Parser<'_>, recovery_set: TokenSet) {
     //         (..=2, _) => (),
     //     }
     // }
-
     if p.at(T![..=]) {
         let m = p.start();
         p.bump(T![..=]);
     }
 
     // test exclusive_range_pat
+
     // fn main() {
+
     //     match 42 {
+
     //         ..0 => {}
+
     //         1..2 => {}
+
     //     }
+
     // }
 
     // test dot_dot_pat
+
     // fn main() {
+
     //     let .. = ();
+
     //     //
+
     //     // Tuples
+
     //     //
+
     //     let (a, ..) = ();
+
     //     let (a, ..,) = ();
+
     //     let Tuple(a, ..) = ();
+
     //     let Tuple(a, ..,) = ();
+
     //     let (.., ..) = ();
+
     //     let Tuple(.., ..) = ();
+
     //     let (.., a, ..) = ();
+
     //     let Tuple(.., a, ..) = ();
+
     //     //
+
     //     // Slices
+
     //     //
+
     //     let [..] = ();
+
     //     let [head, ..] = ();
+
     //     let [head, tail @ ..] = ();
+
     //     let [head, .., cons] = ();
+
     //     let [head, mid @ .., cons] = ();
+
     //     let [head, .., .., cons] = ();
+
     //     let [head, .., mid, tail @ ..] = ();
+
     //     let [head, .., mid, .., cons] = ();
+
     // }
     if p.at(T![..]) {
         let m = p.start();
     if let Some(lhs) = atom_pat(p, recovery_set) {
         for range_op in [T![...], T![..=], T![..]] {
             if p.at(range_op) {
-                let m = lhs.precede(p);
-                p.bump(range_op);
-
                 // testing if we're at one of the following positions:
                 // `0 .. =>`
                 //       ^
                 //      ^
                 // `0 .. if`
                 //       ^
+                let m = lhs.precede(p);
+                p.bump(range_op);
                 if matches!(
                     p.current(),
                     T![=] | T![,] | T![:] | T![')'] | T!['}'] | T![']'] | T![if] | EOF
 }
 
 fn is_literal_pat_start(p: &Parser<'_>) -> bool {
-    p.at(T![-]) && (p.nth(1) == INT_NUMBER || p.nth(1) == FLOAT_NUMBER)
-        || p.at_ts(expressions::LITERAL_FIRST)
+    p.at(T![-]) && (p.nth(1) == INT_NUMBER || p.nth(1) == FLOAT_NUMBER) || p.at_ts(expressions::LITERAL_FIRST)
 }
 
-// test literal_pattern
-// fn main() {
-//     match () {
-//         -1 => (),
-//         92 => (),
-//         'c' => (),
-//         "hello" => (),
-//     }
-// }
 fn literal_pat(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(is_literal_pat_start(p));
     let m = p.start();
     m.complete(p, LITERAL_PAT)
 }
 
-// test path_part
-// fn foo() {
-//     let foo::Bar = ();
-//     let ::Bar = ();
-//     let Bar { .. } = ();
-//     let Bar(..) = ();
-// }
 fn path_or_macro_pat(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(paths::is_path_start(p));
     let m = p.start();
     m.complete(p, kind)
 }
 
-// test tuple_pat_fields
-// fn foo() {
-//     let S() = ();
-//     let S(_) = ();
-//     let S(_,) = ();
-//     let S(_, .. , x) = ();
-//     let S(| a) = ();
-// }
 fn tuple_pat_fields(p: &mut Parser<'_>) {
     assert!(p.at(T!['(']));
     p.bump(T!['(']);
     p.expect(T![')']);
 }
 
-// test record_pat_field
-// fn foo() {
-//     let S { 0: 1 } = ();
-//     let S { x: 1 } = ();
-//     let S { #[cfg(any())] x: 1 } = ();
-// }
 fn record_pat_field(p: &mut Parser<'_>) {
     match p.current() {
         IDENT | INT_NUMBER if p.nth(1) == T![:] => {
-            name_ref_or_index(p);
-            p.bump(T![:]);
             // test record_field_pat_leading_or
             // fn foo() { let R { a: | 1 | 2 } = 0; }
+            name_ref_or_index(p);
+            p.bump(T![:]);
             pattern(p);
         }
         // test_err record_pat_field_eq_recovery
     }
 }
 
-// test record_pat_field_list
-// fn foo() {
-//     let S {} = ();
-//     let S { f, ref mut g } = ();
-//     let S { h: _, ..} = ();
-//     let S { h: _, } = ();
-//     let S { #[cfg(any())] .. } = ();
-// }
 fn record_pat_field_list(p: &mut Parser<'_>) {
     assert!(p.at(T!['{']));
     let m = p.start();
     m.complete(p, RECORD_PAT_FIELD_LIST);
 }
 
-// test placeholder_pat
-// fn main() { let _ = (); }
 fn wildcard_pat(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![_]));
     let m = p.start();
     m.complete(p, WILDCARD_PAT)
 }
 
-// test ref_pat
-// fn main() {
-//     let &a = ();
-//     let &mut b = ();
-// }
 fn ref_pat(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![&]));
     let m = p.start();
     m.complete(p, REF_PAT)
 }
 
-// test tuple_pat
-// fn main() {
-//     let (a, b, ..) = ();
-//     let (a,) = ();
-//     let (..) = ();
-//     let () = ();
-//     let (| a | a, | b) = ((),());
-// }
 fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T!['(']));
     let m = p.start();
     let mut has_rest = false;
 
     // test_err tuple_pat_leading_comma
+
     // fn foo() {
+
     //     let (,);
+
     // }
     if p.eat(T![,]) {
         p.error("expected pattern");
     }
     p.expect(T![')']);
 
-    m.complete(p, if !has_comma && !has_rest && has_pat { PAREN_PAT } else { TUPLE_PAT })
+    m.complete(
+        p,
+        if !has_comma && !has_rest && has_pat {
+        PAREN_PAT
+    } else {
+        TUPLE_PAT
+    },
+    )
 }
 
-// test slice_pat
-// fn main() {
-//     let [a, b, ..] = [];
-//     let [| a, ..] = [];
-// }
 fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T!['[']));
     let m = p.start();
     }
 }
 
-// test bind_pat
-// fn main() {
-//     let a = ();
-//     let mut b = ();
-//     let ref c = ();
-//     let ref mut d = ();
-//     let e @ _ = ();
-//     let ref mut f @ g @ _ = ();
-// }
 fn ident_pat(p: &mut Parser<'_>, with_at: bool) -> CompletedMarker {
     assert!(matches!(p.current(), T![ref] | T![mut] | IDENT));
     let m = p.start();
     m.complete(p, IDENT_PAT)
 }
 
-// test box_pat
-// fn main() {
-//     let box i = ();
-//     let box Outer { box i, j: box Inner(box &x) } = ();
-//     let box ref mut i = ();
-// }
 fn box_pat(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![box]));
     let m = p.start();
     m.complete(p, BOX_PAT)
 }
 
-// test const_block_pat
-// fn main() {
-//     let const { 15 } = ();
-//     let const { foo(); bar() } = ();
-//
-//     match 42 {
-//         const { 0 } .. const { 1 } => (),
-//         .. const { 0 } => (),
-//         const { 2 } .. => (),
-//     }
-//
-//     let (const { () },) = ();
-// }
 fn const_block_pat(p: &mut Parser<'_>) -> CompletedMarker {
     assert!(p.at(T![const]));
     let m = p.start();
 
 use super::*;
 
-pub(super) const PATH_FIRST: TokenSet =
-    TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self], T![:], T![<]]);
+pub(super) const PATH_FIRST: TokenSet = TokenSet::new(&[IDENT, T![self], T![super], T![crate], T![Self], T![:], T![<]]);
 
 pub(super) fn is_path_start(p: &Parser<'_>) -> bool {
     is_use_path_start(p) || p.at(T![<]) || p.at(T![Self])
     }
 }
 
-const EXPR_PATH_SEGMENT_RECOVERY_SET: TokenSet =
-    expressions::EXPR_RECOVERY_SET.union(items::ITEM_RECOVERY_SET);
+const EXPR_PATH_SEGMENT_RECOVERY_SET: TokenSet = expressions::EXPR_RECOVERY_SET.union(items::ITEM_RECOVERY_SET);
+
 const TYPE_PATH_SEGMENT_RECOVERY_SET: TokenSet = types::TYPE_RECOVERY_SET;
 
 fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) -> Option<CompletedMarker> {
 
 fn opt_path_args(p: &mut Parser<'_>, mode: Mode) {
     match mode {
-        Mode::Use | Mode::Attr | Mode::Vis => {}
+        Mode::Use | Mode::Attr | Mode::Vis => {},
         Mode::Type => opt_path_type_args(p),
         Mode::Expr => generic_args::opt_generic_arg_list_expr(p),
     }
 }
 
-//! A bit-set of `SyntaxKind`s.
-
 use crate::SyntaxKind;
 
 /// A bit-set of `SyntaxKind`s
     assert!(!ts.contains(PLUS));
 }
 
-//! Shortcuts that span lexer/parser abstraction.
-//!
-//! The way Rust works, parser doesn't necessary parse text, and you might
-//! tokenize text without parsing it further. So, it makes sense to keep
-//! abstract token parsing, and string tokenization as completely separate
-//! layers.
-//!
-//! However, often you do parse text into syntax trees and the glue code for
-//! that needs to live somewhere. Rather than putting it to lexer or parser, we
-//! use a separate shortcuts module for that.
-
 use std::mem;
 
 use crate::{
 
 #[derive(Debug)]
 pub enum StrStep<'a> {
-    Token { kind: SyntaxKind, text: &'a str },
-    Enter { kind: SyntaxKind },
+    Token {
+        kind: SyntaxKind,
+        text: &'a str,
+    },
+    Enter {
+        kind: SyntaxKind,
+    },
     Exit,
-    Error { msg: &'a str, pos: usize },
+    Error {
+        msg: &'a str,
+        pos: usize,
+    },
 }
 
 impl LexedStr<'_> {
         | EXTERN_CRATE => {
             let mut res = 0;
             let mut trivias = trivias.enumerate().peekable();
-
             while let Some((i, (kind, text))) = trivias.next() {
                 match kind {
                     WHITESPACE if text.contains("\n\n") => {
 }
 
 // Copied from https://github.com/rust-lang/cargo/blob/367fd9f213750cd40317803dd0a5a3ce3f0c676d/src/cargo/util/frontmatter.rs
-#![expect(dead_code)] // avoid editing
-#![expect(unreachable_pub)] // avoid editing
-#![expect(clippy::useless_format)] // avoid editing
+#
+// avoid editing
+#
+// avoid editing
+#
 
+// avoid editing
 type Span = std::ops::Range<usize>;
 
 #[derive(Debug)]
             .push_visible_span(open_start..open_end));
         };
         let info = input.next_slice(info_nl.start);
-        let info = info.strip_suffix('\r').unwrap_or(info); // already excludes `\n`
+        let info = info.strip_suffix('\r').unwrap_or(info);
+        // already excludes `\n`
         let info = info.trim_matches(is_horizontal_whitespace);
         if !info.is_empty() {
             let info_start = info.offset_from(&raw);
             )
             .push_visible_span(open_start..open_end));
         };
-        let frontmatter_start = input.current_token_start() + 1; // skip nl from infostring
+        let frontmatter_start = input.current_token_start() + 1;
+        // skip nl from infostring
         let _ = input.next_slice(frontmatter_nl.start + 1);
         let frontmatter_end = input.current_token_start();
         source.frontmatter = Some(frontmatter_start..frontmatter_end);
     //
     // Note that this set is stable (ie, it doesn't change with different
     // Unicode versions), so it's ok to just hard-code the values.
-
     matches!(
         c,
         // End-of-line characters
     //
     // Note that this set is stable (ie, it doesn't change with different
     // Unicode versions), so it's ok to just hard-code the values.
-
     matches!(
         c,
         // Horizontal space characters
 
 impl FrontmatterError {
     pub fn new(message: impl Into<String>, span: Span) -> Self {
-        Self { message: message.into(), primary_span: span, visible_spans: Vec::new() }
+        Self {
+            message: message.into(),
+            primary_span: span,
+            visible_spans: Vec::new(),
+        }
     }
 
     pub fn push_visible_span(mut self, span: Span) -> Self {
     }
 }
 
-impl std::error::Error for FrontmatterError {}
+impl std::error::Error for FrontmatterError {
+}
 
 use crate::{Edition, LexedStr, PrefixEntryPoint, Step};
 
     expect.assert_eq(&parsed)
 }
 
-//! Generated by `cargo xtask codegen grammar`, do not edit by hand.
-
-#![allow(bad_style, missing_docs, unreachable_pub)]
+#
 use crate::Edition;
 #[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
 #[derive(Debug)]
             TRY_KW => "try",
         }
     }
+
     #[doc = r" Checks whether this syntax kind is a strict keyword for the given edition."]
     #[doc = r" Strict keywords are identifiers that are always considered keywords."]
     pub fn is_strict_keyword(self, edition: Edition) -> bool {
             _ => false,
         }
     }
+
     #[doc = r" Checks whether this syntax kind is a weak keyword for the given edition."]
     #[doc = r" Weak keywords are identifiers that are considered keywords only in certain contexts."]
     pub fn is_contextual_keyword(self, edition: Edition) -> bool {
             _ => false,
         }
     }
+
     #[doc = r" Checks whether this syntax kind is a strict or weak keyword for the given edition."]
     pub fn is_keyword(self, edition: Edition) -> bool {
         matches!(
             _ => false,
         }
     }
+
     pub fn is_punct(self) -> bool {
         matches!(
             self,
                 | SHREQ
         )
     }
+
     pub fn is_literal(self) -> bool {
         matches!(self, BYTE | BYTE_STRING | CHAR | C_STRING | FLOAT_NUMBER | INT_NUMBER | STRING)
     }
+
     pub fn from_keyword(ident: &str, edition: Edition) -> Option<SyntaxKind> {
         let kw = match ident {
             "Self" => SELF_TYPE_KW,
         };
         Some(kw)
     }
+
     pub fn from_contextual_keyword(ident: &str, edition: Edition) -> Option<SyntaxKind> {
         let kw = match ident {
             "asm" => ASM_KW,
         };
         Some(kw)
     }
+
     pub fn from_char(c: char) -> Option<SyntaxKind> {
         let tok = match c {
             '$' => DOLLAR,
         Some(tok)
     }
 }
+
 #[macro_export]
 macro_rules ! T_ { [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [@] => { $ crate :: SyntaxKind :: AT } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOT2 } ; [...] => { $ crate :: SyntaxKind :: DOT3 } ; [..=] => { $ crate :: SyntaxKind :: DOT2EQ } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [::] => { $ crate :: SyntaxKind :: COLON2 } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ2 } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [->] => { $ crate :: SyntaxKind :: THIN_ARROW } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [>=] => { $ crate :: SyntaxKind :: GTEQ } ; [+=] => { $ crate :: SyntaxKind :: PLUSEQ } ; [-=] => { $ crate :: SyntaxKind :: MINUSEQ } ; [|=] => { $ crate :: SyntaxKind :: PIPEEQ } ; [&=] => { $ crate :: SyntaxKind :: AMPEQ } ; [^=] => { $ crate :: SyntaxKind :: CARETEQ } ; [/=] => { $ crate :: SyntaxKind :: SLASHEQ } ; [*=] => { $ crate :: SyntaxKind :: STAREQ } ; [%=] => { $ crate :: SyntaxKind :: PERCENTEQ } ; [&&] => { $ crate :: SyntaxKind :: AMP2 } ; [||] => { $ crate :: SyntaxKind :: PIPE2 } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [<<=] => { $ crate :: SyntaxKind :: SHLEQ } ; [>>=] => { $ crate :: SyntaxKind :: SHREQ } ; [Self] => { $ crate :: SyntaxKind :: SELF_TYPE_KW } ; [abstract] => { $ crate :: SyntaxKind :: ABSTRACT_KW } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [become] => { $ crate :: SyntaxKind :: BECOME_KW } ; [box] => { $ crate :: SyntaxKind :: BOX_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [const] => { $ crate :: SyntaxKind :: CONST_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [crate] => { $ crate :: SyntaxKind :: CRATE_KW } ; [do] => { $ crate :: SyntaxKind :: DO_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [enum] => { $ crate :: SyntaxKind :: ENUM_KW } ; [extern] => { $ crate :: SyntaxKind :: EXTERN_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [final] => { $ crate :: SyntaxKind :: FINAL_KW } ; [fn] => { $ crate :: SyntaxKind :: FN_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [impl] => { $ crate :: SyntaxKind :: IMPL_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [loop] => { $ crate :: SyntaxKind :: LOOP_KW } ; [macro] => { $ crate :: SyntaxKind :: MACRO_KW } ; [match] => { $ crate :: SyntaxKind :: MATCH_KW } ; [mod] => { $ crate :: SyntaxKind :: MOD_KW } ; [move] => { $ crate :: SyntaxKind :: MOVE_KW } ; [mut] => { $ crate :: SyntaxKind :: MUT_KW } ; [override] => { $ crate :: SyntaxKind :: OVERRIDE_KW } ; [priv] => { $ crate :: SyntaxKind :: PRIV_KW } ; [pub] => { $ crate :: SyntaxKind :: PUB_KW } ; [ref] => { $ crate :: SyntaxKind :: REF_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [self] => { $ crate :: SyntaxKind :: SELF_KW } ; [static] => { $ crate :: SyntaxKind :: STATIC_KW } ; [struct] => { $ crate :: SyntaxKind :: STRUCT_KW } ; [super] => { $ crate :: SyntaxKind :: SUPER_KW } ; [trait] => { $ crate :: SyntaxKind :: TRAIT_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [type] => { $ crate :: SyntaxKind :: TYPE_KW } ; [typeof] => { $ crate :: SyntaxKind :: TYPEOF_KW } ; [unsafe] => { $ crate :: SyntaxKind :: UNSAFE_KW } ; [unsized] => { $ crate :: SyntaxKind :: UNSIZED_KW } ; [use] => { $ crate :: SyntaxKind :: USE_KW } ; [virtual] => { $ crate :: SyntaxKind :: VIRTUAL_KW } ; [where] => { $ crate :: SyntaxKind :: WHERE_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [yield] => { $ crate :: SyntaxKind :: YIELD_KW } ; [asm] => { $ crate :: SyntaxKind :: ASM_KW } ; [att_syntax] => { $ crate :: SyntaxKind :: ATT_SYNTAX_KW } ; [auto] => { $ crate :: SyntaxKind :: AUTO_KW } ; [builtin] => { $ crate :: SyntaxKind :: BUILTIN_KW } ; [clobber_abi] => { $ crate :: SyntaxKind :: CLOBBER_ABI_KW } ; [default] => { $ crate :: SyntaxKind :: DEFAULT_KW } ; [dyn] => { $ crate :: SyntaxKind :: DYN_KW } ; [format_args] => { $ crate :: SyntaxKind :: FORMAT_ARGS_KW } ; [global_asm] => { $ crate :: SyntaxKind :: GLOBAL_ASM_KW } ; [inlateout] => { $ crate :: SyntaxKind :: INLATEOUT_KW } ; [inout] => { $ crate :: SyntaxKind :: INOUT_KW } ; [label] => { $ crate :: SyntaxKind :: LABEL_KW } ; [lateout] => { $ crate :: SyntaxKind :: LATEOUT_KW } ; [macro_rules] => { $ crate :: SyntaxKind :: MACRO_RULES_KW } ; [may_unwind] => { $ crate :: SyntaxKind :: MAY_UNWIND_KW } ; [naked_asm] => { $ crate :: SyntaxKind :: NAKED_ASM_KW } ; [nomem] => { $ crate :: SyntaxKind :: NOMEM_KW } ; [noreturn] => { $ crate :: SyntaxKind :: NORETURN_KW } ; [nostack] => { $ crate :: SyntaxKind :: NOSTACK_KW } ; [offset_of] => { $ crate :: SyntaxKind :: OFFSET_OF_KW } ; [options] => { $ crate :: SyntaxKind :: OPTIONS_KW } ; [out] => { $ crate :: SyntaxKind :: OUT_KW } ; [preserves_flags] => { $ crate :: SyntaxKind :: PRESERVES_FLAGS_KW } ; [pure] => { $ crate :: SyntaxKind :: PURE_KW } ; [raw] => { $ crate :: SyntaxKind :: RAW_KW } ; [readonly] => { $ crate :: SyntaxKind :: READONLY_KW } ; [safe] => { $ crate :: SyntaxKind :: SAFE_KW } ; [sym] => { $ crate :: SyntaxKind :: SYM_KW } ; [union] => { $ crate :: SyntaxKind :: UNION_KW } ; [yeet] => { $ crate :: SyntaxKind :: YEET_KW } ; [async] => { $ crate :: SyntaxKind :: ASYNC_KW } ; [await] => { $ crate :: SyntaxKind :: AWAIT_KW } ; [dyn] => { $ crate :: SyntaxKind :: DYN_KW } ; [gen] => { $ crate :: SyntaxKind :: GEN_KW } ; [try] => { $ crate :: SyntaxKind :: TRY_KW } ; [lifetime_ident] => { $ crate :: SyntaxKind :: LIFETIME_IDENT } ; [int_number] => { $ crate :: SyntaxKind :: INT_NUMBER } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [string] => { $ crate :: SyntaxKind :: STRING } ; [shebang] => { $ crate :: SyntaxKind :: SHEBANG } ; [frontmatter] => { $ crate :: SyntaxKind :: FRONTMATTER } ; }
-impl ::core::marker::Copy for SyntaxKind {}
+
+impl ::core::marker::Copy for SyntaxKind {
+}
+
 impl ::core::clone::Clone for SyntaxKind {
     #[inline]
-    fn clone(&self) -> Self { *self }
+    fn clone(&self) -> Self {
+        *self
+    }
 }
+
 impl ::core::cmp::PartialEq for SyntaxKind {
     #[inline]
-    fn eq(&self, other: &Self) -> bool { (*self as u16) == (*other as u16) }
+    fn eq(&self, other: &Self) -> bool {
+        (*self as u16) == (*other as u16)
+    }
 }
-impl ::core::cmp::Eq for SyntaxKind {}
+
+impl ::core::cmp::Eq for SyntaxKind {
+}
+
 impl ::core::cmp::PartialOrd for SyntaxKind {
     #[inline]
     fn partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering> {
         Some(self.cmp(other))
     }
 }
+
 impl ::core::cmp::Ord for SyntaxKind {
     #[inline]
-    fn cmp(&self, other: &Self) -> core::cmp::Ordering { (*self as u16).cmp(&(*other as u16)) }
+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
+        (*self as u16).cmp(&(*other as u16))
+    }
 }
+
 impl ::core::hash::Hash for SyntaxKind {
     fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
         ::core::mem::discriminant(self).hash(state);
