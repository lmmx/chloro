COMPARISON DIFF
============================================================

Original size: 10586 bytes
Chloro size:   10117 bytes
Rustfmt size:  10586 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Constant evaluation details
 
-#[cfg(test)]
-mod tests;
-
 use base_db::Crate;
 use hir_def::{
     EnumVariantId, GeneralConstId, HasModule, StaticId,
         SolverDefId, Ty, ValueConst,
     },
 };
-
 use super::mir::{interpret_mir, lower_to_mir, pad16};
+#[cfg(test)]
+mod tests;
 
 pub fn unknown_const<'db>(_ty: Ty<'db>) -> Const<'db> {
     Const::new(DbInterner::conjure(), rustc_type_ir::ConstKind::Error(ErrorGuaranteed))
 }
 
 impl ConstEvalError<'_> {
-    pub fn pretty_print(
-        &self,
-        f: &mut String,
-        db: &dyn HirDatabase,
-        span_formatter: impl Fn(span::FileId, span::TextRange) -> String,
-        display_target: DisplayTarget,
-    ) -> std::result::Result<(), std::fmt::Error> {
+    pub fn pretty_print(&self, f: &mut String, db: &dyn HirDatabase, span_formatter: impl Fn(span::FileId, span::TextRange) -> String, display_target: DisplayTarget) -> std::result::Result<(), std::fmt::Error> {
         match self {
             ConstEvalError::MirLowerError(e) => {
                 e.pretty_print(f, db, span_formatter, display_target)
 }
 
 /// Interns a constant scalar with the given type
-pub fn intern_const_ref<'a>(
-    db: &'a dyn HirDatabase,
-    value: &LiteralConstRef,
-    ty: Ty<'a>,
-    krate: Crate,
-) -> Const<'a> {
+pub fn intern_const_ref<'a>(db: &'a dyn HirDatabase, value: &LiteralConstRef, ty: Ty<'a>, krate: Crate) -> Const<'a> {
     let interner = DbInterner::new_with(db, Some(krate), None);
     let layout = db.layout_of_ty(ty, TraitEnvironment::empty(krate));
     let kind = match value {
     }
 }
 
-pub(crate) fn const_eval_discriminant_variant<'db>(
-    db: &'db dyn HirDatabase,
-    variant_id: EnumVariantId,
-) -> Result<i128, ConstEvalError<'db>> {
+pub(crate) fn const_eval_discriminant_variant<'db>(db: &'db dyn HirDatabase, variant_id: EnumVariantId) -> Result<i128, ConstEvalError<'db>> {
     let interner = DbInterner::new_with(db, None, None);
     let def = variant_id.into();
     let body = db.body(def);
         };
         return Ok(value);
     }
-
     let repr = db.enum_signature(loc.parent).repr;
     let is_signed = repr.and_then(|repr| repr.int).is_none_or(|int| int.is_signed());
-
     let mir_body = db.monomorphized_mir_body(
         def,
         GenericArgs::new_from_iter(interner, []),
     Ok(c)
 }
 
-// FIXME: Ideally constants in const eval should have separate body (issue #7434), and this function should
-// get an `InferenceResult` instead of an `InferenceContext`. And we should remove `ctx.clone().resolve_all()` here
-// and make this function private. See the fixme comment on `InferenceContext::resolve_all`.
 pub(crate) fn eval_to_const<'db>(expr: ExprId, ctx: &mut InferenceContext<'_, 'db>) -> Const<'db> {
     let infer = ctx.fixme_resolve_all_clone();
     fn has_closure(body: &Body, expr: ExprId) -> bool {
     unknown_const(infer[expr])
 }
 
-pub(crate) fn const_eval_cycle_result<'db>(
-    _: &'db dyn HirDatabase,
-    _: GeneralConstId,
-    _: GenericArgs<'db>,
-    _: Option<Arc<TraitEnvironment<'db>>>,
-) -> Result<Const<'db>, ConstEvalError<'db>> {
+pub(crate) fn const_eval_cycle_result<'db>(_: &'db dyn HirDatabase, _: GeneralConstId, _: GenericArgs<'db>, _: Option<Arc<TraitEnvironment<'db>>>) -> Result<Const<'db>, ConstEvalError<'db>> {
     Err(ConstEvalError::MirLowerError(MirLowerError::Loop))
 }
 
-pub(crate) fn const_eval_static_cycle_result<'db>(
-    _: &'db dyn HirDatabase,
-    _: StaticId,
-) -> Result<Const<'db>, ConstEvalError<'db>> {
+pub(crate) fn const_eval_static_cycle_result<'db>(_: &'db dyn HirDatabase, _: StaticId) -> Result<Const<'db>, ConstEvalError<'db>> {
     Err(ConstEvalError::MirLowerError(MirLowerError::Loop))
 }
 
-pub(crate) fn const_eval_discriminant_cycle_result<'db>(
-    _: &'db dyn HirDatabase,
-    _: EnumVariantId,
-) -> Result<i128, ConstEvalError<'db>> {
+pub(crate) fn const_eval_discriminant_cycle_result<'db>(_: &'db dyn HirDatabase, _: EnumVariantId) -> Result<i128, ConstEvalError<'db>> {
     Err(ConstEvalError::MirLowerError(MirLowerError::Loop))
 }
 
-pub(crate) fn const_eval_query<'db>(
-    db: &'db dyn HirDatabase,
-    def: GeneralConstId,
-    subst: GenericArgs<'db>,
-    trait_env: Option<Arc<TraitEnvironment<'db>>>,
-) -> Result<Const<'db>, ConstEvalError<'db>> {
+pub(crate) fn const_eval_query<'db>(db: &'db dyn HirDatabase, def: GeneralConstId, subst: GenericArgs<'db>, trait_env: Option<Arc<TraitEnvironment<'db>>>) -> Result<Const<'db>, ConstEvalError<'db>> {
     let body = match def {
         GeneralConstId::ConstId(c) => {
             db.monomorphized_mir_body(c.into(), subst, db.trait_environment(c.into()))?
     Ok(c)
 }
 
-pub(crate) fn const_eval_static_query<'db>(
-    db: &'db dyn HirDatabase,
-    def: StaticId,
-) -> Result<Const<'db>, ConstEvalError<'db>> {
+pub(crate) fn const_eval_static_query<'db>(db: &'db dyn HirDatabase, def: StaticId) -> Result<Const<'db>, ConstEvalError<'db>> {
     let interner = DbInterner::new_with(db, None, None);
     let body = db.monomorphized_mir_body(
         def.into(),