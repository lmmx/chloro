COMPARISON DIFF
============================================================

Original size: 31467 bytes
Chloro size:   31387 bytes
Rustfmt size:  31467 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! The core state machine bridging document sections and the interactive editor.
 //!
 //! A TUI needs a single source of truth that can be interrogated and mutated as the user navigates
 //! and edits. We achieve this by syncing the editor save state with the files on disk. We keep
 //! track of the cumulative total number of lines that have been added to the file during the
 //! session so that we can determine the correct offset to insert content at without re-parsing.
-
 use crate::edit_plan::{Edit, EditPlan};
 use crate::formats::markdown::MarkdownFormat;
 use crate::input;
         } else {
             FileMode::Multi
         };
-
         let tree_nodes = Self::build_tree(&files, &sections);
-
         // Find first navigable node
         let initial_index = tree_nodes.iter().position(|n| n.navigable).unwrap_or(0);
-
         Self {
             sections,
             tree_nodes,
             moving_section_index: None,
         }
     }
-
     fn build_tree(files: &[PathBuf], sections: &[Section]) -> Vec<TreeNode> {
         let mut nodes = Vec::new();
-
         // Determine if this is difftastic mode by checking if multiple sections share the same file_path
         // (in markdown mode, each section has a unique file path or sections are from the same file)
         let mut file_section_counts: HashMap<String, usize> = HashMap::new();
                 .or_insert(0) += 1;
         }
         let is_difftastic = file_section_counts.values().any(|&count| count > 1);
-
         if files.len() == 1 && !is_difftastic {
             // Single markdown file mode: use section level for tree indentation
             for (idx, section) in sections.iter().enumerate() {
                 }
             }
         }
-
         nodes
     }
-
     /// Rebuild tree after sections change (e.g., after save)
     pub fn rebuild_tree(&mut self) {
         self.tree_nodes = Self::build_tree(&self.files, &self.sections);
-
         // Try to maintain current position by finding same section
         if let Some(current_section_idx) = self.get_current_section_index() {
             if let Some(node_idx) = self
             }
         }
     }
-
     /// Get the section index for the currently selected node (if it's a section)
     #[must_use]
     pub fn get_current_section_index(&self) -> Option<usize> {
             None
         }
     }
-
     /// Get the current section (if on a section node)
     #[must_use]
     pub fn get_current_section(&self) -> Option<&Section> {
         self.get_current_section_index()
             .and_then(|idx| self.sections.get(idx))
     }
-
     fn rebuild_file_offsets(&mut self) {
         self.file_offsets.clear();
-
         if let Some(section_idx) = self.get_current_section_index() {
             if let Some(section) = self.sections.get(section_idx) {
                 let lines_added = self.editor_state.as_ref().map_or(0, |es| es.lines.len());
             }
         }
     }
-
     /// Calculates total lines added before a section to determine correct write position.
     #[must_use]
     pub fn cumulative_offset(&self, index: usize) -> usize {
         let section = &self.sections[index];
         let target_file = &section.file_path;
         let target_line = section.line_start;
-
         if let Some(file_map) = self.file_offsets.get(target_file) {
             file_map
                 .iter()
             0
         }
     }
-
     /// Restores previously edited content from a saved edit plan.
     pub fn load_docs(&mut self, plan: EditPlan) {
         let mut doc_map: HashMap<String, Vec<String>> = HashMap::new();
                 .collect();
             doc_map.insert(key, lines);
         }
-
         // Match edits to sections and pre-populate editor content
         for section in &mut self.sections {
             let key = format!(
             }
         }
     }
-
     /// Creates a serialisable plan capturing current editor modifications.
     #[must_use]
     pub fn generate_edit_plan(&self) -> EditPlan {
         let mut edits = Vec::new();
-
         for section in &self.sections {
             if let Some(ref doc_lines) = section.section_content {
                 let section_content = doc_lines.join("\n");
                 });
             }
         }
-
         EditPlan { edits }
     }
-
     /// Loads selected section content into the editor buffer.
     pub fn enter_detail_view(&mut self) {
         let Some(section_idx) = self.get_current_section_index() else {
             return;
         };
-
         let section = &self.sections[section_idx];
-
         // Handle difftastic chunks differently
         if let Some(chunk_type) = &section.chunk_type {
             let content = match chunk_type {
             let lines = Lines::from(lines_text.as_str());
             self.editor_state = Some(EditorState::new(lines));
         }
-
         self.current_view = View::Detail;
     }
-
     /// Returns to section list, optionally persisting editor changes.
     pub fn exit_detail_view(&mut self, save: bool) {
         if save {
         self.editor_state = None;
         self.current_view = View::List;
     }
-
     /// Save the current section's content to disk.
     ///
     /// # Errors
         } else {
             return Ok(());
         };
-
         let Some(section_idx) = self.get_current_section_index() else {
             return Ok(());
         };
-
         self.sections[section_idx].section_content = Some(editor_lines.clone());
-
         let section = &self.sections[section_idx];
-
         let raw_content = editor_lines.join("\n");
         let trimmed_content = raw_content.trim();
         let padded_content = format!("\n{trimmed_content}\n\n");
-
         let edit = Edit {
             file_name: section.file_path.clone(),
             line_start: section.line_start,
             section_content: padded_content,
             item_name: section.title.clone(),
         };
-
         let mut plan = EditPlan { edits: vec![edit] };
         plan.apply()?;
-
         // Reload sections
         let format = MarkdownFormat;
         if let Ok(new_sections) =
                 self.rebuild_tree();
             }
         }
-
         self.rebuild_file_offsets();
         self.message = Some("Saved".to_string());
         Ok(())
     }
-
     /// Navigate to next navigable node
     #[must_use]
     pub fn find_next_node(&self) -> Option<usize> {
         ((self.current_node_index + 1)..self.tree_nodes.len())
             .find(|&i| self.tree_nodes[i].navigable)
     }
-
     /// Navigate to previous navigable node
     #[must_use]
     pub fn find_prev_node(&self) -> Option<usize> {
             .rev()
             .find(|&i| self.tree_nodes[i].navigable)
     }
-
     /// Moves to the containing section in the document hierarchy.
     #[must_use]
     pub fn navigate_to_parent(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let parent_section_idx = self.sections[section_idx].parent_index?;
-
         // Find tree node with this section index
         self.tree_nodes
             .iter()
             .position(|n| n.section_index == Some(parent_section_idx))
     }
-
     /// Descends to the first child section in the document hierarchy.
     #[must_use]
     pub fn navigate_to_first_child(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let first_child_idx = self.sections[section_idx].children_indices.first()?;
-
         self.tree_nodes
             .iter()
             .position(|n| n.section_index == Some(*first_child_idx))
     }
-
     /// Finds the next descendant section at any depth in the hierarchy.
     #[must_use]
     pub fn navigate_to_next_descendant(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
-
         // First try immediate children
         if let Some(first_child) = self.sections[section_idx].children_indices.first() {
             return self
                 .iter()
                 .position(|n| n.section_index == Some(*first_child));
         }
-
         // Otherwise find next section at deeper level
         for i in (section_idx + 1)..self.sections.len() {
             if self.sections[i].level > self.sections[section_idx].level {
                     .position(|n| n.section_index == Some(i));
             }
         }
-
         None
     }
-
     /// Finds the next section at the same hierarchy level.
     #[must_use]
     pub fn navigate_to_next_sibling(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let current_level = self.sections[section_idx].level;
-
         for i in (section_idx + 1)..self.sections.len() {
             if self.sections[i].level == current_level {
                 return self
                 break;
             }
         }
-
         None
     }
-
     /// Finds the previous section at the same hierarchy level.
     #[must_use]
     pub fn navigate_to_prev_sibling(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let current_level = self.sections[section_idx].level;
-
         for i in (0..section_idx).rev() {
             if self.sections[i].level == current_level {
                 return self
                 break;
             }
         }
-
         None
     }
-
     /// Jumps to the first navigable node.
     #[must_use]
     pub fn navigate_to_first(&self) -> Option<usize> {
         self.tree_nodes.iter().position(|n| n.navigable)
     }
-
     /// Jumps to the last navigable node.
     #[must_use]
     pub fn navigate_to_last(&self) -> Option<usize> {
         self.tree_nodes.iter().rposition(|n| n.navigable)
     }
-
     /// Finds the first section at the same hierarchy level.
     #[must_use]
     pub fn navigate_to_first_at_level(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let current_level = self.sections[section_idx].level;
-
         for i in 0..self.sections.len() {
             if self.sections[i].level == current_level {
                 return self
                     .position(|n| n.section_index == Some(i));
             }
         }
-
         None
     }
-
     /// Finds the last section at the same hierarchy level.
     #[must_use]
     pub fn navigate_to_last_at_level(&self) -> Option<usize> {
         let section_idx = self.get_current_section_index()?;
         let current_level = self.sections[section_idx].level;
-
         for i in (0..self.sections.len()).rev() {
             if self.sections[i].level == current_level {
                 return self
                     .position(|n| n.section_index == Some(i));
             }
         }
-
         None
     }
-
     /// Calculates indentation width based on section nesting level.
     #[must_use]
     pub fn get_indent(&self) -> usize {
             0
         }
     }
-
     /// Determines available width for text after accounting for indentation.
     #[must_use]
     pub fn get_max_line_width(&self) -> usize {
         let indent = self.get_indent();
         self.wrap_width.saturating_sub(indent)
     }
-
     // --- Section List Movement ---
-
     /// Start moving the current section
     pub fn start_move(&mut self) {
         if let Some(section_idx) = self.get_current_section_index() {
             self.move_state = MoveState::Selected;
         }
     }
-
     /// Cancel the current move operation
     pub fn cancel_move(&mut self) {
         self.moving_section_index = None;
         self.move_state = MoveState::None;
     }
-
     /// Mark section as moved but not yet saved
     pub fn mark_moved(&mut self) {
         self.move_state = MoveState::Moved;
     }
-
     /// Move section up by one position
     pub fn move_section_up(&mut self) -> bool {
         if let Some(moving_idx) = self.moving_section_index {
         }
         false
     }
-
     /// Move section down by one position
     pub fn move_section_down(&mut self) -> bool {
         if let Some(moving_idx) = self.moving_section_index {
         }
         false
     }
-
     /// Move section to top of document
     pub fn move_section_to_top(&mut self) -> bool {
         if let Some(moving_idx) = self.moving_section_index {
         }
         false
     }
-
     /// Move section to bottom of document
     pub fn move_section_to_bottom(&mut self) -> bool {
         if let Some(moving_idx) = self.moving_section_index {
         }
         false
     }
-
     /// Increase section level (move in - lower level number)
     pub fn move_section_in(&mut self) -> bool {
         if let Some(moving_idx) = self.moving_section_index {
         }
         false
     }
-
     /// Decrease section level (move out - higher level number)
     pub fn move_section_out(&mut self) -> bool {
         if let Some(moving_idx) = self.moving_section_index {
         }
         false
     }
-
     /// Apply section reordering to disk
     ///
     /// # Errors
         if self.move_state != MoveState::Moved {
             return Ok(());
         }
-
         // Group sections by file
         let mut file_sections: HashMap<String, Vec<&Section>> = HashMap::new();
         for section in &self.sections {
                 .or_default()
                 .push(section);
         }
-
         // Process each file
         for (file_path, sections) in file_sections {
             Self::rewrite_file_sections(&file_path, &sections)?;
         }
-
         // Reload sections to get updated positions
         let format = MarkdownFormat;
         let mut new_sections = Vec::new();
                 new_sections.extend(secs);
             }
         }
-
         self.sections = new_sections;
         self.rebuild_tree();
         self.cancel_move();
         self.message = Some("Sections reordered".to_string());
-
         Ok(())
     }
-
     /// Rewrite an entire file with reordered sections
     fn rewrite_file_sections(file_path: &str, sections: &[&Section]) -> io::Result<()> {
         let content = fs::read_to_string(file_path)?;
         let mut new_content = String::new();
-
         for section in sections {
             let heading_prefix = "#".repeat(section.level);
             let heading = format!("{} {}", heading_prefix, section.title);
                 new_content.push_str("\n\n");
             }
         }
-
         fs::write(file_path, new_content)?;
         Ok(())
     }