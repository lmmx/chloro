COMPARISON DIFF
============================================================

Original size: 54481 bytes
Chloro size:   55217 bytes
Rustfmt size:  54481 bytes

✗ Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Name resolution façade.
+
 use std::{fmt, mem};
 
 use base_db::Crate;
 }
 
 impl fmt::Debug for ModuleItemMap<'_> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("ModuleItemMap").field("module_id", &self.module_id).finish()
     }
 }
 }
 
 impl fmt::Debug for ExprScope {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+    fn fmt(
+        &self,
+        f: &mut fmt::Formatter<'_>,
+    ) -> fmt::Result {
         f.debug_struct("ExprScope")
             .field("owner", &self.owner)
             .field("scope_id", &self.scope_id)
     BlockScope(ModuleItemMap<'db>),
     /// Brings the generic parameters of an item into scope as well as the `Self` type alias /
     /// generic for ADTs and impls.
-    GenericParams { def: GenericDefId, params: Arc<GenericParams> },
+    GenericParams {
+        def: GenericDefId,
+        params: Arc<GenericParams>,
+    },
     /// Local bindings
     ExprScope(ExprScope),
     /// Macro definition inside bodies that affects all paths after it in the same block.
     GenericParam(TypeParamId),
     AdtId(AdtId),
     AdtSelfType(AdtId),
-    // Yup, enum variants are added to the types ns, but any usage of variant as
-    // type is an error.
     EnumVariantId(EnumVariantId),
     TypeAliasId(TypeAliasId),
     BuiltinType(BuiltinType),
     TraitId(TraitId),
-
     ModuleId(ModuleId),
 }
 
 
 impl<'db> Resolver<'db> {
     /// Resolve known trait from std, like `std::futures::Future`
-    pub fn resolve_known_trait(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<TraitId> {
+    pub fn resolve_known_trait(
+        &self,
+        db: &dyn DefDatabase,
+        path: &ModPath,
+    ) -> Option<TraitId> {
         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;
         match res {
             ModuleDefId::TraitId(it) => Some(it),
     }
 
     /// Resolve known struct from std, like `std::boxed::Box`
-    pub fn resolve_known_struct(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<StructId> {
+    pub fn resolve_known_struct(
+        &self,
+        db: &dyn DefDatabase,
+        path: &ModPath,
+    ) -> Option<StructId> {
         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;
         match res {
             ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it),
     }
 
     /// Resolve known enum from std, like `std::result::Result`
-    pub fn resolve_known_enum(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<EnumId> {
+    pub fn resolve_known_enum(
+        &self,
+        db: &dyn DefDatabase,
+        path: &ModPath,
+    ) -> Option<EnumId> {
         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;
         match res {
             ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it),
         }
     }
 
-    pub fn resolve_module_path_in_items(&self, db: &dyn DefDatabase, path: &ModPath) -> PerNs {
+    pub fn resolve_module_path_in_items(
+        &self,
+        db: &dyn DefDatabase,
+        path: &ModPath,
+    ) -> PerNs {
         self.resolve_module_path(db, path, BuiltinShadowMode::Module)
     }
 
         &self,
         db: &dyn DefDatabase,
         path: &Path,
-    ) -> Option<(TypeNs, Option<usize>, Option<ImportOrExternCrate>, ResolvePathResultPrefixInfo)>
-    {
+    ) -> Option<(TypeNs, Option<usize>, Option<ImportOrExternCrate>, ResolvePathResultPrefixInfo)> {
         let path = match path {
             Path::BarePath(mod_path) => mod_path,
             Path::Normal(it) => &it.mod_path,
         if skip_to_mod {
             return self.module_scope.resolve_path_in_type_ns(db, path);
         }
-
         let remaining_idx = || {
             if path.segments().len() == 1 { None } else { Some(1) }
         };
-
         for scope in self.scopes() {
             match scope {
                 Scope::ExprScope(_) | Scope::MacroDefScope(_) => continue,
         if skip_to_mod {
             return self.module_scope.resolve_path_in_value_ns(db, path);
         }
-
         if n_segments <= 1 {
             let mut hygiene_info = hygiene_info(db, hygiene_id);
             for scope in self.scopes() {
                 }
             }
         }
-
         if let Some(res) = self.module_scope.resolve_path_in_value_ns(db, path) {
             return Some(res);
         }
-
         // If a path of the shape `u16::from_le_bytes` failed to resolve at all, then we fall back
         // to resolving to the primitive type, to allow this to still work in the presence of
         // `use core::u16;`.
                 ResolvePathResultPrefixInfo::default(),
             ));
         }
-
         None
     }
 
         self.resolve_path_as_macro(db, path, expected_macro_kind).map(|(it, _)| db.macro_def(it))
     }
 
-    pub fn resolve_lifetime(&self, lifetime: &LifetimeRef) -> Option<LifetimeNs> {
+    pub fn resolve_lifetime(
+        &self,
+        lifetime: &LifetimeRef,
+    ) -> Option<LifetimeNs> {
         match lifetime {
             LifetimeRef::Static => Some(LifetimeNs::Static),
             LifetimeRef::Named(name) => self.scopes().find_map(|scope| match scope {
         def_map[module_id].scope.entries().for_each(|(name, def)| {
             res.add_per_ns(name, def);
         });
-
         def_map[module_id].scope.legacy_macros().for_each(|(name, macs)| {
             macs.iter().for_each(|&mac| {
                 res.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(mac)));
             .map(|(name, module_id)| (name.clone(), module_id.0.into()))
     }
 
-    pub fn traits_in_scope(&self, db: &dyn DefDatabase) -> FxHashSet<TraitId> {
+    pub fn traits_in_scope(
+        &self,
+        db: &dyn DefDatabase,
+    ) -> FxHashSet<TraitId> {
         // FIXME(trait_alias): Trait alias brings aliased traits in scope! Note that supertraits of
         // aliased traits are NOT brought in scope (unless also aliased).
         let mut traits = FxHashSet::default();
-
         for scope in self.scopes() {
             match scope {
                 Scope::BlockScope(m) => traits.extend(m.def_map[m.module_id].scope.traits()),
                 _ => (),
             }
         }
-
         // Fill in the prelude traits
         if let Some((prelude, _use)) = self.module_scope.def_map.prelude() {
             let prelude_def_map = prelude.def_map(db);
                 // innermost module scope instead?
             }
         }
-
         let start = self.scopes.len();
         let innermost_scope = self.scopes().find(|scope| !matches!(scope, Scope::MacroDefScope(_)));
         match innermost_scope {
         UpdateGuard(start)
     }
 
-    pub fn reset_to_guard(&mut self, UpdateGuard(start): UpdateGuard) {
+    pub fn reset_to_guard(
+        &mut self,
+        UpdateGuard(start): UpdateGuard,
+    ) {
         self.scopes.truncate(start);
     }
 }
 }
 
 impl<'db> Scope<'db> {
-    fn process_names(&self, acc: &mut ScopeNames, db: &'db dyn DefDatabase) {
+    fn process_names(
+        &self,
+        acc: &mut ScopeNames,
+        db: &'db dyn DefDatabase,
+    ) {
         match self {
             Scope::BlockScope(m) => {
                 m.def_map[m.module_id].scope.entries().for_each(|(name, def)| {
 ) -> Resolver<'db> {
     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();
     r.scopes.reserve(scope_chain.len());
-
     for scope in scope_chain.into_iter().rev() {
         if let Some(block) = scopes.block(scope) {
             let def_map = block_def_map(db, block);
 }
 
 impl<'db> Resolver<'db> {
-    fn push_scope(mut self, scope: Scope<'db>) -> Resolver<'db> {
+    fn push_scope(
+        mut self,
+        scope: Scope<'db>,
+    ) -> Resolver<'db> {
         self.scopes.push(scope);
         self
     }
         &self,
         db: &dyn DefDatabase,
         path: &ModPath,
-    ) -> Option<(TypeNs, Option<usize>, Option<ImportOrExternCrate>, ResolvePathResultPrefixInfo)>
-    {
+    ) -> Option<(TypeNs, Option<usize>, Option<ImportOrExternCrate>, ResolvePathResultPrefixInfo)> {
         let (module_def, idx, prefix_info) = self.def_map.resolve_path_locally(
             self.local_def_map,
             db,
 }
 
 impl ScopeNames {
-    fn add(&mut self, name: &Name, def: ScopeDef) {
+    fn add(
+        &mut self,
+        name: &Name,
+        def: ScopeDef,
+    ) {
         let set = self.map.entry(name.clone()).or_default();
         if !set.contains(&def) {
             set.push(def)
         }
     }
-    fn add_per_ns(&mut self, name: &Name, def: PerNs) {
+
+    fn add_per_ns(
+        &mut self,
+        name: &Name,
+        def: PerNs,
+    ) {
         if let Some(ty) = &def.types {
             self.add(name, ScopeDef::ModuleDef(ty.def))
         }
             self.add(name, ScopeDef::Unknown)
         }
     }
-    fn add_local(&mut self, name: &Name, binding: BindingId) {
+
+    fn add_local(
+        &mut self,
+        name: &Name,
+        binding: BindingId,
+    ) {
         let set = self.map.entry(name.clone()).or_default();
         // XXX: hack, account for local (and only local) shadowing.
         //
     }
 }
 
-pub trait HasResolver: Copy {
-    /// Builds a resolver for type references inside this def.
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_>;
-}
+/// Builds a resolver for type references inside this def.
+fn resolver(
+    self,
+    db: &dyn DefDatabase,
+) -> Resolver<'_>;
 
 impl HasResolver for ModuleId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         let (mut def_map, local_def_map) = self.local_def_map(db);
         let mut module_id = self.local_id;
-
         if !self.is_within_block() {
             return Resolver {
                 scopes: vec![],
                 module_scope: ModuleItemMap { def_map, local_def_map, module_id },
             };
         }
-
         let mut modules: SmallVec<[_; 1]> = smallvec![];
         while let Some(parent) = def_map.parent() {
             let block_def_map = mem::replace(&mut def_map, parent.def_map(db));
 }
 
 impl HasResolver for CrateRootModuleId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         let (def_map, local_def_map) = self.local_def_map(db);
         Resolver {
             scopes: vec![],
 }
 
 impl HasResolver for TraitId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self).push_generic_params_scope(db, self.into())
     }
 }
 
 impl<T: Into<AdtId> + Copy> HasResolver for T {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         let def = self.into();
         def.module(db).resolver(db).push_generic_params_scope(db, def.into())
     }
 }
 
 impl HasResolver for FunctionId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self).push_generic_params_scope(db, self.into())
     }
 }
 
 impl HasResolver for ConstId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self)
     }
 }
 
 impl HasResolver for StaticId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self)
     }
 }
 
 impl HasResolver for TypeAliasId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self).push_generic_params_scope(db, self.into())
     }
 }
 
 impl HasResolver for ImplId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())
     }
 }
 
 impl HasResolver for ExternBlockId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         // Same as parent's
         lookup_resolver(db, self)
     }
 }
 
 impl HasResolver for ExternCrateId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self)
     }
 }
 
 impl HasResolver for UseId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self)
     }
 }
 
 impl HasResolver for DefWithBodyId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         match self {
             DefWithBodyId::ConstId(c) => c.resolver(db),
             DefWithBodyId::FunctionId(f) => f.resolver(db),
 }
 
 impl HasResolver for ItemContainerId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         match self {
             ItemContainerId::ModuleId(it) => it.resolver(db),
             ItemContainerId::TraitId(it) => it.resolver(db),
 }
 
 impl HasResolver for GenericDefId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         match self {
             GenericDefId::FunctionId(inner) => inner.resolver(db),
             GenericDefId::AdtId(adt) => adt.resolver(db),
 }
 
 impl HasResolver for EnumVariantId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         self.lookup(db).parent.resolver(db)
     }
 }
 
 impl HasResolver for VariantId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         match self {
             VariantId::EnumVariantId(it) => it.resolver(db),
             VariantId::StructId(it) => it.resolver(db),
 }
 
 impl HasResolver for MacroId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         match self {
             MacroId::Macro2Id(it) => it.resolver(db),
             MacroId::MacroRulesId(it) => it.resolver(db),
 }
 
 impl HasResolver for Macro2Id {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self)
     }
 }
 
 impl HasResolver for ProcMacroId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self)
     }
 }
 
 impl HasResolver for MacroRulesId {
-    fn resolver(self, db: &dyn DefDatabase) -> Resolver<'_> {
+    fn resolver(
+        self,
+        db: &dyn DefDatabase,
+    ) -> Resolver<'_> {
         lookup_resolver(db, self)
     }
 }