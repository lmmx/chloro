COMPARISON DIFF
============================================================

Original size: 62212 bytes
Chloro size:   61578 bytes
Rustfmt size:  62212 bytes

✗ Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! An algorithm to find a path to refer to a certain item.
 
 use std::{cell::Cell, cmp::Ordering, iter};
 
+use Stability::*;
 use base_db::{Crate, CrateOrigin, LangCrateOrigin};
 use hir_expand::{
     Lookup,
     nameres::DefMap,
     visibility::{Visibility, VisibilityExplicitness},
 };
-
 /// Find a path that can be used to refer to a certain item. This can depend on
 /// *from where* you're referring to the item, hence the `from` parameter.
-pub fn find_path(
-    db: &dyn DefDatabase,
-    item: ItemInNs,
-    from: ModuleId,
-    mut prefix_kind: PrefixKind,
-    ignore_local_imports: bool,
-    mut cfg: FindPathConfig,
-) -> Option<ModPath> {
+pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId, mut prefix_kind: PrefixKind, ignore_local_imports: bool, mut cfg: FindPathConfig) -> Option<ModPath> {
     let _p = tracing::info_span!("find_path").entered();
-
     // - if the item is a builtin, it's in scope
     if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {
         return Some(ModPath::from_segments(PathKind::Plain, iter::once(builtin.as_name())));
     }
-
     // within block modules, forcing a `self` or `crate` prefix will not allow using inner items, so
     // default to plain paths.
     let item_module = item.module(db)?;
         prefix_kind = PrefixKind::Plain;
     }
     cfg.prefer_no_std = cfg.prefer_no_std || db.crate_supports_no_std(from.krate());
-
     find_path_inner(
         &FindPathCtx {
             db,
     Unstable,
     Stable,
 }
-use Stability::*;
 
-const MAX_PATH_LEN: usize = 15;
-const FIND_PATH_FUEL: usize = 10000;
+
 
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
 pub enum PrefixKind {
         return find_path_for_module(ctx, &mut FxHashSet::default(), module_id, true, max_len)
             .map(|choice| choice.path);
     }
-
     let may_be_in_scope = match ctx.prefix {
         PrefixKind::Plain | PrefixKind::BySelf => true,
         PrefixKind::ByCrate => ctx.from.is_crate_root(),
             return Some(ModPath::from_segments(ctx.prefix.path_kind(), iter::once(scope_name)));
         }
     }
-
     // - if the item is in the prelude, return the name from there
     if let Some(value) = find_in_prelude(ctx.db, ctx.from_def_map, item, ctx.from) {
         return Some(value.path);
     }
-
     if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {
         // - if the item is an enum variant, refer to it via the enum
         let loc = variant.lookup(ctx.db);
         // enum; that's very weird, but there might still be a reexport of the
         // variant somewhere
     }
-
     let mut best_choice = None;
     calculate_best_path(ctx, &mut FxHashSet::default(), item, max_len, &mut best_choice);
     best_choice.map(|choice| choice.path)
 }
 
 #[tracing::instrument(skip_all)]
-fn find_path_for_module(
-    ctx: &FindPathCtx<'_>,
-    visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>,
-    module_id: ModuleId,
-    maybe_extern: bool,
-    max_len: usize,
-) -> Option<Choice> {
+fn find_path_for_module(ctx: &FindPathCtx<'_>, visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>, module_id: ModuleId, maybe_extern: bool, max_len: usize) -> Option<Choice> {
     if max_len == 0 {
         // recursive base case, we can't find a path of length 0
         return None;
             return Some(Choice::new(ctx.cfg.prefer_prelude, kind, name.clone(), Stable));
         }
     }
-
     let may_be_in_scope = match ctx.prefix {
         PrefixKind::Plain | PrefixKind::BySelf => true,
         PrefixKind::ByCrate => ctx.from.is_crate_root(),
             ));
         }
     }
-
     // - if the module can be referenced as self, super or crate, do that
     if let Some(kind) = is_kw_kind_relative_to_from(ctx.from_def_map, module_id, ctx.from)
         && (ctx.prefix != PrefixKind::ByCrate || kind == PathKind::Crate)
             prefer_due_to_prelude: false,
         });
     }
-
     // - if the module is in the prelude, return it by that path
     let item = ItemInNs::Types(module_id.into());
     if let Some(choice) = find_in_prelude(ctx.db, ctx.from_def_map, item, ctx.from) {
     best_choice
 }
 
-fn find_in_scope(
-    db: &dyn DefDatabase,
-    def_map: &DefMap,
-    from: ModuleId,
-    item: ItemInNs,
-    ignore_local_imports: bool,
-) -> Option<Name> {
+fn find_in_scope(db: &dyn DefDatabase, def_map: &DefMap, from: ModuleId, item: ItemInNs, ignore_local_imports: bool) -> Option<Name> {
     // FIXME: We could have multiple applicable names here, but we currently only return the first
     def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {
         def_map[local_id].scope.names_of(item, |name, _, declared| {
 
 /// Returns single-segment path (i.e. without any prefix) if `item` is found in prelude and its
 /// name doesn't clash in current scope.
-fn find_in_prelude(
-    db: &dyn DefDatabase,
-    local_def_map: &DefMap,
-    item: ItemInNs,
-    from: ModuleId,
-) -> Option<Choice> {
+fn find_in_prelude(db: &dyn DefDatabase, local_def_map: &DefMap, item: ItemInNs, from: ModuleId) -> Option<Choice> {
     let (prelude_module, _) = local_def_map.prelude()?;
     let prelude_def_map = prelude_module.def_map(db);
     let prelude_scope = &prelude_def_map[prelude_module.local_id].scope;
     if !vis.is_visible_from(db, from) {
         return None;
     }
-
     // Check if the name is in current scope and it points to the same def.
     let found_and_same_def =
         local_def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {
             };
             Some(same_def)
         });
-
     if found_and_same_def.unwrap_or(true) {
         Some(Choice::new(false, PathKind::Plain, name.clone(), Stable))
     } else {
     }
 }
 
-fn is_kw_kind_relative_to_from(
-    def_map: &DefMap,
-    item: ModuleId,
-    from: ModuleId,
-) -> Option<PathKind> {
+fn is_kw_kind_relative_to_from(def_map: &DefMap, item: ModuleId, from: ModuleId) -> Option<PathKind> {
     if item.krate != from.krate || item.is_within_block() || from.is_within_block() {
         return None;
     }
 }
 
 #[tracing::instrument(skip_all)]
-fn calculate_best_path(
-    ctx: &FindPathCtx<'_>,
-    visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>,
-    item: ItemInNs,
-    max_len: usize,
-    best_choice: &mut Option<Choice>,
-) {
+fn calculate_best_path(ctx: &FindPathCtx<'_>, visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>, item: ItemInNs, max_len: usize, best_choice: &mut Option<Choice>) {
     let fuel = ctx.fuel.get();
     if fuel == 0 {
         // we ran out of fuel, so we stop searching here
         return;
     }
     ctx.fuel.set(fuel - 1);
-
     if item.krate(ctx.db) == Some(ctx.from.krate) {
         // Item was defined in the same crate that wants to import it. It cannot be found in any
         // dependency in this case.
     }
 }
 
-fn find_in_sysroot(
-    ctx: &FindPathCtx<'_>,
-    visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>,
-    item: ItemInNs,
-    max_len: usize,
-    best_choice: &mut Option<Choice>,
-) {
+fn find_in_sysroot(ctx: &FindPathCtx<'_>, visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>, item: ItemInNs, max_len: usize, best_choice: &mut Option<Choice>) {
     let dependencies = &ctx.from.krate.data(ctx.db).dependencies;
     let mut search = |lang, best_choice: &mut _| {
         if let Some(dep) = dependencies.iter().filter(|it| it.is_sysroot()).find(|dep| {
         });
 }
 
-fn find_in_dep(
-    ctx: &FindPathCtx<'_>,
-    visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>,
-    item: ItemInNs,
-    max_len: usize,
-    best_choice: &mut Option<Choice>,
-    dep: Crate,
-) {
+fn find_in_dep(ctx: &FindPathCtx<'_>, visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>, item: ItemInNs, max_len: usize, best_choice: &mut Option<Choice>, dep: Crate) {
     let import_map = ctx.db.import_map(dep);
     let Some(import_info_for) = import_map.import_info_for(item) else {
         return;
     }
 }
 
-fn calculate_best_path_local(
-    ctx: &FindPathCtx<'_>,
-    visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>,
-    item: ItemInNs,
-    max_len: usize,
-    best_choice: &mut Option<Choice>,
-) {
+fn calculate_best_path_local(ctx: &FindPathCtx<'_>, visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>, item: ItemInNs, max_len: usize, best_choice: &mut Option<Choice>) {
     // FIXME: cache the `find_local_import_locations` output?
     find_local_import_locations(
         ctx.db,
         self
     }
 
-    fn try_select(
-        current: &mut Option<Choice>,
-        mut other: Choice,
-        prefer_prelude: bool,
-        name: Name,
-    ) {
+    fn try_select(current: &mut Option<Choice>, mut other: Choice, prefer_prelude: bool, name: Name) {
         let Some(current) = current else {
             *current = Some(other.push(prefer_prelude, name));
             return;
 }
 
 /// Finds locations in `from.krate` from which `item` can be imported by `from`.
-fn find_local_import_locations(
-    db: &dyn DefDatabase,
-    item: ItemInNs,
-    from: ModuleId,
-    def_map: &DefMap,
-    visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>,
-    mut cb: impl FnMut(&mut FxHashSet<(ItemInNs, ModuleId)>, &Name, ModuleId),
-) {
+fn find_local_import_locations(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId, def_map: &DefMap, visited_modules: &mut FxHashSet<(ItemInNs, ModuleId)>, mut cb: impl FnMut(&mut FxHashSet<(ItemInNs, ModuleId)>, &Name, ModuleId)) {
     let _p = tracing::info_span!("find_local_import_locations").entered();
-
     // `from` can import anything below `from` with visibility of at least `from`, and anything
     // above `from` with any visibility. That means we do not need to descend into private siblings
     // of `from` (and similar).
-
     // Compute the initial worklist. We start with all direct child modules of `from` as well as all
     // of its (recursive) parent modules.
     let mut worklist = def_map[from.local_id]
         .chain(iter::successors(from.containing_module(db), |m| m.containing_module(db)))
         .zip(iter::repeat(false))
         .collect::<Vec<_>>();
-
     let def_map = def_map.crate_root().def_map(db);
     let mut block_def_map;
     let mut cursor = 0;
-
     while let Some(&mut (module, ref mut processed)) = worklist.get_mut(cursor) {
         cursor += 1;
         if !visited_modules.insert((item, module)) {
     use stdx::format_to;
     use syntax::ast::AstNode;
     use test_fixture::WithFixture;
-
     use crate::test_db::TestDB;
-
     use super::*;
-
     /// `code` needs to contain a cursor marker; checks that `find_path` for the
     /// item the `path` refers to returns that same path when called from the
     /// module the cursor is in.
     #[track_caller]
-    fn check_found_path_(
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        path: &str,
-        prefer_prelude: bool,
-        prefer_absolute: bool,
-        prefer_no_std: bool,
-        allow_unstable: bool,
-        expect: Expect,
-    ) {
+    fn check_found_path_(#[rust_analyzer::rust_fixture] ra_fixture: &str, path: &str, prefer_prelude: bool, prefer_absolute: bool, prefer_no_std: bool, allow_unstable: bool, expect: Expect) {
         let (db, pos) = TestDB::with_position(ra_fixture);
         let module = db.module_at_position(pos);
         let parsed_path_file =
             db.span_map(pos.file_id.into()).as_ref().span_for_range(range).ctx
         })
         .unwrap();
-
         let (def_map, local_def_map) = module.local_def_map(&db);
         let resolved = def_map
             .resolve_path(
             .map(ItemInNs::Types)
             .or_else(|| resolved.take_values().map(ItemInNs::Values))
             .expect("path does not resolve to a type or value");
-
         let mut res = String::new();
         for (prefix, ignore_local_imports) in
             [PrefixKind::Plain, PrefixKind::ByCrate, PrefixKind::BySelf]
         }
         expect.assert_eq(&res);
     }
-
-    fn check_found_path(
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        path: &str,
-        expect: Expect,
-    ) {
+    fn check_found_path(#[rust_analyzer::rust_fixture] ra_fixture: &str, path: &str, expect: Expect) {
         check_found_path_(ra_fixture, path, false, false, false, false, expect);
     }
-
-    fn check_found_path_prelude(
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        path: &str,
-        expect: Expect,
-    ) {
+    fn check_found_path_prelude(#[rust_analyzer::rust_fixture] ra_fixture: &str, path: &str, expect: Expect) {
         check_found_path_(ra_fixture, path, true, false, false, false, expect);
     }
-
-    fn check_found_path_absolute(
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        path: &str,
-        expect: Expect,
-    ) {
+    fn check_found_path_absolute(#[rust_analyzer::rust_fixture] ra_fixture: &str, path: &str, expect: Expect) {
         check_found_path_(ra_fixture, path, false, true, false, false, expect);
     }
-
-    fn check_found_path_prefer_no_std(
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        path: &str,
-        expect: Expect,
-    ) {
+    fn check_found_path_prefer_no_std(#[rust_analyzer::rust_fixture] ra_fixture: &str, path: &str, expect: Expect) {
         check_found_path_(ra_fixture, path, false, false, true, false, expect);
     }
-
-    fn check_found_path_prefer_no_std_allow_unstable(
-        #[rust_analyzer::rust_fixture] ra_fixture: &str,
-        path: &str,
-        expect: Expect,
-    ) {
+    fn check_found_path_prefer_no_std_allow_unstable(#[rust_analyzer::rust_fixture] ra_fixture: &str, path: &str, expect: Expect) {
         check_found_path_(ra_fixture, path, false, false, true, true, expect);
     }
-
     #[test]
     fn same_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn sub_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn super_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn self_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn crate_root() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn partially_imported() {
         cov_mark::check!(partially_imported);
                 BySelf (imports ✖): syntax::ast::ModuleItem
             "#]],
         );
-
         check_found_path(
             r#"
 //- /main.rs crate:main deps:syntax
             "#]],
         );
     }
-
     #[test]
     fn partially_imported_with_prefer_absolute() {
         cov_mark::check!(partially_imported);
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn same_crate_reexport_rename() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn shadowed_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn imported_prelude() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn enum_variant_from_prelude() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn shortest_path() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn discount_private_imports() {
         cov_mark::check!(discount_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports_crate() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn explicit_private_imports() {
         cov_mark::check!(explicit_private_imports);
             "#]],
         );
     }
-
     #[test]
     fn import_cycle() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_std_paths_over_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_core_paths_over_std() {
         check_found_path_prefer_no_std(
                 BySelf (imports ✖): core::fmt::Error
             "#]],
         );
-
         // Should also work (on a best-effort basis) if `no_std` is conditional.
         check_found_path(
             r#"
             "#]],
         );
     }
-
     #[test]
     fn prefer_alloc_paths_over_std() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_shorter_paths_if_not_alloc() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn builtins_are_in_scope() {
         let code = r#"
             "#]],
         );
     }
-
     #[test]
     fn inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_outer_scope() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn inner_items_from_inner_module() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn outer_items_with_inner_items_present() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module2() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn from_inside_module_with_inner_items() {
         check_found_path(
             "#]],
         )
     }
-
     #[test]
     fn recursive_pub_mod_reexport() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn extern_crate() {
         check_found_path(
                 BySelf (imports ✖): dep
             "#]],
         );
-
         check_found_path(
             r#"
 //- /main.rs crate:main deps:dep
             "#]],
         );
     }
-
     #[test]
     fn prelude_with_inner_items() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_renamed_through_dep() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn different_crate_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_doc_hidden() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn respect_unstable_modules() {
         check_found_path_prefer_no_std_allow_unstable(
             "#]],
         );
     }
-
     #[test]
     fn respects_prelude_setting() {
         let ra_fixture = r#"
             "#]],
         );
     }
-
     #[test]
     fn respects_absolute_setting() {
         let ra_fixture = r#"
             BySelf (imports ✖): krate::foo::Foo
         "#]],
         );
-
         check_found_path_absolute(
             ra_fixture,
             "krate::foo::Foo",
         "#]],
         );
     }
-
     #[test]
     fn respect_segment_length() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn regression_17271() {
         check_found_path(
             "#]],
         );
     }
-
     #[test]
     fn prefer_long_std_over_short_extern() {
         check_found_path(