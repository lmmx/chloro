COMPARISON DIFF
============================================================

Original size: 4492 bytes
Chloro size:   4371 bytes
Rustfmt size:  4581 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Post-nameres attribute resolution.
 
 use base_db::Crate;
 use hir_expand::{
+    MacroCallId, MacroCallKind, MacroDefId,
     attrs::{Attr, AttrId, AttrInput},
     inert_attr_macro::find_builtin_attr_idx,
     mod_path::{ModPath, PathKind},
-    MacroCallId, MacroCallKind, MacroDefId,
 };
 use span::SyntaxContext;
 use syntax::ast;
 use triomphe::Arc;
 
 use crate::{
+    AstIdWithPath, LocalModuleId, MacroId, UnresolvedMacro,
     db::DefDatabase,
     item_scope::BuiltinShadowMode,
-    nameres::{path_resolution::ResolveMode, LocalDefMap},
-    AstIdWithPath, LocalModuleId, MacroId, UnresolvedMacro,
+    nameres::{LocalDefMap, path_resolution::ResolveMode},
 };
-
 use super::{DefMap, MacroSubNs};
-
 pub enum ResolvedAttr {
     /// Attribute resolved to an attribute macro.
     Macro(MacroCallId),
 }
 
 impl DefMap {
-    pub(crate) fn resolve_attr_macro(
-        &self,
-        local_def_map: &LocalDefMap,
-        db: &dyn DefDatabase,
-        original_module: LocalModuleId,
-        ast_id: AstIdWithPath<ast::Item>,
-        attr: &Attr,
-    ) -> Result<ResolvedAttr, UnresolvedMacro> {
+    pub(crate) fn resolve_attr_macro(&self, local_def_map: &LocalDefMap, db: &dyn DefDatabase, original_module: LocalModuleId, ast_id: AstIdWithPath<ast::Item>, attr: &Attr) -> Result<ResolvedAttr, UnresolvedMacro> {
         // NB: does not currently work for derive helpers as they aren't recorded in the `DefMap`
-
         if self.is_builtin_or_registered_attr(&ast_id.path) {
             return Ok(ResolvedAttr::Other);
         }
-
         let resolved_res = self.resolve_path_fp_with_macro(
             local_def_map,
             db,
                     return Ok(ResolvedAttr::Other);
                 }
             }
-            None => {
-                return Err(UnresolvedMacro {
-                    path: ast_id.path.as_ref().clone(),
-                })
-            }
+            None => return Err(UnresolvedMacro { path: ast_id.path.as_ref().clone() }),
         };
-
         Ok(ResolvedAttr::Macro(attr_macro_as_call_id(
             db,
             &ast_id,
         if path.kind != PathKind::Plain {
             return false;
         }
-
         let segments = path.segments();
-
         if let Some(name) = segments.first() {
             let name = name.symbol();
             let pred = |n: &_| *n == *name;
     }
 }
 
-pub(super) fn attr_macro_as_call_id(
-    db: &dyn DefDatabase,
-    item_attr: &AstIdWithPath<ast::Item>,
-    macro_attr: &Attr,
-    krate: Crate,
-    def: MacroDefId,
-) -> MacroCallId {
+pub(super) fn attr_macro_as_call_id(db: &dyn DefDatabase, item_attr: &AstIdWithPath<ast::Item>, macro_attr: &Attr, krate: Crate, def: MacroDefId) -> MacroCallId {
     let arg = match macro_attr.input.as_deref() {
         Some(AttrInput::TokenTree(tt)) => {
             let mut tt = tt.clone();
 
         _ => None,
     };
-
     def.make_call(
         db,
         krate,
     )
 }
 
-pub(super) fn derive_macro_as_call_id(
-    db: &dyn DefDatabase,
-    item_attr: &AstIdWithPath<ast::Adt>,
-    derive_attr_index: AttrId,
-    derive_pos: u32,
-    call_site: SyntaxContext,
-    krate: Crate,
-    resolver: impl Fn(&ModPath) -> Option<(MacroId, MacroDefId)>,
-    derive_macro_id: MacroCallId,
-) -> Result<(MacroId, MacroDefId, MacroCallId), UnresolvedMacro> {
+pub(super) fn derive_macro_as_call_id(db: &dyn DefDatabase, item_attr: &AstIdWithPath<ast::Adt>, derive_attr_index: AttrId, derive_pos: u32, call_site: SyntaxContext, krate: Crate, resolver: impl Fn(&ModPath) -> Option<(MacroId, MacroDefId)>, derive_macro_id: MacroCallId) -> Result<(MacroId, MacroDefId, MacroCallId), UnresolvedMacro> {
     let (macro_id, def_id) = resolver(&item_attr.path)
         .filter(|(_, def_id)| def_id.is_derive())
-        .ok_or_else(|| UnresolvedMacro {
-            path: item_attr.path.as_ref().clone(),
-        })?;
+        .ok_or_else(|| UnresolvedMacro { path: item_attr.path.as_ref().clone() })?;
     let call_id = def_id.make_call(
         db,
         krate,