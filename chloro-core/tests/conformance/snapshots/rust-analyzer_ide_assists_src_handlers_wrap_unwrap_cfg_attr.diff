COMPARISON DIFF
============================================================

Original size: 18779 bytes
Chloro size:   18543 bytes
Rustfmt size:  18779 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: wrap_unwrap_cfg_attr
-//
-// Wraps an attribute to a cfg_attr attribute or unwraps a cfg_attr attribute to the inner attributes.
-//
-// ```
-// #[derive$0(Debug)]
-// struct S {
-//    field: i32
-// }
-// ```
-// ->
-// ```
-// #[cfg_attr($0, derive(Debug))]
-// struct S {
-//    field: i32
-// }
-// ```
-
 enum WrapUnwrapOption {
-    WrapDerive { derive: TextRange, attr: ast::Attr },
+    WrapDerive {
+        derive: TextRange,
+        attr: ast::Attr,
+    },
     WrapAttr(ast::Attr),
 }
 
 /// But a derive attribute list doesn't have paths. So we need to collect all the tokens before and after the ident
 ///
 /// If this functions return None just map to WrapAttr
-fn attempt_get_derive(attr: ast::Attr, ident: SyntaxToken) -> WrapUnwrapOption {
+fn attempt_get_derive(
+    attr: ast::Attr,
+    ident: SyntaxToken,
+) -> WrapUnwrapOption {
     let attempt_attr = || {
         {
             let mut derive = ident.text_range();
         attempt_attr().unwrap_or(WrapUnwrapOption::WrapAttr(attr))
     }
 }
-pub(crate) fn wrap_unwrap_cfg_attr(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+
+pub(crate) fn wrap_unwrap_cfg_attr(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let option = if ctx.has_empty_selection() {
         let ident = ctx.find_token_syntax_at_offset(T![ident]);
         let attr = ctx.find_node_at_offset::<ast::Attr>();
     let range = attr.syntax().text_range();
     let token_tree = attr.token_tree()?;
     let mut path_text = String::new();
-
     let mut cfg_derive_tokens = Vec::new();
     let mut new_derive = Vec::new();
-
     for tt in token_tree.token_trees_and_tokens() {
         let NodeOrToken::Token(token) = tt else {
             continue;
         editor.add_mappings(make.finish_with_mappings());
         edit.add_file_edits(ctx.vfs_file_id(), editor);
     };
-
     acc.add(
         AssistId::refactor("wrap_unwrap_cfg_attr"),
         format!("Wrap #[derive({path_text})] in `cfg_attr`",),
     );
     Some(())
 }
-fn wrap_cfg_attr(acc: &mut Assists, ctx: &AssistContext<'_>, attr: ast::Attr) -> Option<()> {
+
+fn wrap_cfg_attr(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+    attr: ast::Attr,
+) -> Option<()> {
     let range = attr.syntax().text_range();
     let path = attr.path()?;
     let handle_source_change = |edit: &mut SourceChangeBuilder| {
     );
     Some(())
 }
-fn unwrap_cfg_attr(acc: &mut Assists, attr: ast::Attr) -> Option<()> {
+
+fn unwrap_cfg_attr(
+    acc: &mut Assists,
+    attr: ast::Attr,
+) -> Option<()> {
     let range = attr.syntax().text_range();
     let meta = attr.meta()?;
     let meta_tt = meta.token_tree()?;
     );
     Some(())
 }
+
 #[cfg(test)]
 mod tests {
     use crate::tests::check_assist;
-
     use super::*;
-
     #[test]
     fn test_basic_to_from_cfg_attr() {
         check_assist(