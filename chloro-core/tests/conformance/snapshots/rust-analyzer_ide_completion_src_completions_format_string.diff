COMPARISON DIFF
============================================================

Original size: 4330 bytes
Chloro size:   4301 bytes
Rustfmt size:  4425 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 //! Completes identifiers in format string literals.
 
 use hir::{ModuleDef, ScopeDef};
-use ide_db::{syntax_helpers::format_string::is_format_string, SymbolKind};
+use ide_db::{SymbolKind, syntax_helpers::format_string::is_format_string};
 use itertools::Itertools;
-use syntax::{ast, AstToken, TextRange, TextSize, ToSmolStr};
+use syntax::{AstToken, TextRange, TextSize, ToSmolStr, ast};
 
-use crate::{context::CompletionContext, CompletionItem, CompletionItemKind, Completions};
+use crate::{CompletionItem, CompletionItemKind, Completions, context::CompletionContext};
 
 /// Complete identifiers in format strings.
-pub(crate) fn format_string(
-    acc: &mut Completions,
-    ctx: &CompletionContext<'_>,
-    original: &ast::String,
-    expanded: &ast::String,
-) {
+pub(crate) fn format_string(acc: &mut Completions, ctx: &CompletionContext<'_>, original: &ast::String, expanded: &ast::String) {
     if !is_format_string(expanded) {
         return;
     }
     let cursor = ctx.position.offset;
     let lit_start = ctx.original_token.text_range().start();
     let cursor_in_lit = cursor - lit_start;
-
     let prefix = &original.text()[..cursor_in_lit.into()];
-    let braces = prefix
-        .char_indices()
-        .rev()
-        .skip_while(|&(_, c)| c.is_alphanumeric())
-        .next_tuple();
+    let braces = prefix.char_indices().rev().skip_while(|&(_, c)| c.is_alphanumeric()).next_tuple();
     let brace_offset = match braces {
         // escaped brace
         Some(((_, '{'), (_, '{'))) => return,
         Some(((idx, '{'), _)) => lit_start + TextSize::from(idx as u32 + 1),
         _ => return,
     };
-
     let source_range = TextRange::new(brace_offset, cursor);
-    ctx.locals
-        .iter()
-        .sorted_by_key(|&(k, _)| k.clone())
-        .for_each(|(name, _)| {
-            CompletionItem::new(
-                CompletionItemKind::Binding,
-                source_range,
-                name.display_no_db(ctx.edition).to_smolstr(),
-                ctx.edition,
-            )
-            .add_to(acc, ctx.db);
-        });
+    ctx.locals.iter().sorted_by_key(|&(k, _)| k.clone()).for_each(|(name, _)| {
+        CompletionItem::new(
+            CompletionItemKind::Binding,
+            source_range,
+            name.display_no_db(ctx.edition).to_smolstr(),
+            ctx.edition,
+        )
+        .add_to(acc, ctx.db);
+    });
     ctx.scope.process_all_names(&mut |name, scope| {
         if let ScopeDef::ModuleDef(module_def) = scope {
             let symbol_kind = match module_def {
 #[cfg(test)]
 mod tests {
     use expect_test::expect;
-
     use crate::tests::{check_edit, check_no_kw};
-
     #[test]
     fn works_when_wrapped() {
         check_no_kw(
             expect![[]],
         );
     }
-
     #[test]
     fn no_completion_without_brace() {
         check_no_kw(
             expect![[]],
         );
     }
-
     #[test]
     fn completes_locals() {
         check_edit(
 "#,
         );
     }
-
     #[test]
     fn completes_constants() {
         check_edit(
 }
 "#,
         );
-
         check_edit(
             "FOOBAR",
             r#"
 "#,
         );
     }
-
     #[test]
     fn completes_static_constants() {
         check_edit(
 }
 "#,
         );
-
         check_edit(
             "FOOBAR",
             r#"