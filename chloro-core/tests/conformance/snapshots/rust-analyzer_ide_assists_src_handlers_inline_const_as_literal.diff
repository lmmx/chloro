COMPARISON DIFF
============================================================

Original size: 19183 bytes
Chloro size:   17826 bytes
Rustfmt size:  19179 bytes

âœ— Outputs DIFFER

--- DIFF (- rustfmt, + chloro) ---
 use hir::HasCrate;
-use syntax::{ast, AstNode};
+use syntax::{AstNode, ast};
 
 use crate::{AssistContext, AssistId, Assists};
 
-// Assist: inline_const_as_literal
-//
-// Evaluate and inline const variable as literal.
-//
-// ```
-// const STRING: &str = "Hello, World!";
-//
-// fn something() -> &'static str {
-//     STRING$0
-// }
-// ```
-// ->
-// ```
-// const STRING: &str = "Hello, World!";
-//
-// fn something() -> &'static str {
-//     "Hello, World!"
-// }
-// ```
-pub(crate) fn inline_const_as_literal(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {
+pub(crate) fn inline_const_as_literal(
+    acc: &mut Assists,
+    ctx: &AssistContext<'_>,
+) -> Option<()> {
     let variable = ctx.find_node_at_offset::<ast::PathExpr>()?;
-
     if let hir::PathResolution::Def(hir::ModuleDef::Const(konst)) =
         ctx.sema.resolve_path(&variable.path()?)?
     {
         // FIXME: Add support to handle type aliases for builtin scalar types.
         validate_type_recursively(ctx, Some(&konst_ty), false, fuel)?;
 
-        let value = konst.eval(ctx.sema.db).ok()?.render(
-            ctx.sema.db,
-            konst.krate(ctx.sema.db).to_display_target(ctx.sema.db),
-        );
+        let value = konst
+            .eval(ctx.sema.db)
+            .ok()?
+            .render(ctx.sema.db, konst.krate(ctx.sema.db).to_display_target(ctx.sema.db));
 
         let id = AssistId::refactor_inline("inline_const_as_literal");
 
 mod tests {
     use super::*;
     use crate::tests::{check_assist, check_assist_not_applicable};
-
-    const NUMBER: u8 = 1;
-    const BOOL: u8 = 2;
-    const STR: u8 = 4;
-    const CHAR: u8 = 8;
-
-    const TEST_PAIRS: &[(&str, &str, u8)] = &[
-        ("u8", "0", NUMBER),
-        ("u16", "0", NUMBER),
-        ("u32", "0", NUMBER),
-        ("u64", "0", NUMBER),
-        ("u128", "0", NUMBER),
-        ("usize", "0", NUMBER),
-        ("usize", "16", NUMBER),
-        ("i8", "0", NUMBER),
-        ("i16", "0", NUMBER),
-        ("i32", "0", NUMBER),
-        ("i64", "0", NUMBER),
-        ("i128", "0", NUMBER),
-        ("isize", "0", NUMBER),
-        ("isize", "16", NUMBER),
-        ("bool", "false", BOOL),
-        ("&str", "\"str\"", STR),
-        ("char", "'c'", CHAR),
-    ];
-
-    // -----------Not supported-----------
     #[test]
     fn inline_const_as_literal_const_fn_call_slice() {
         TEST_PAIRS.iter().for_each(|(ty, val, _)| {
             );
         });
     }
-
     #[test]
     fn inline_const_as_literal_expr_as_str_lit_not_applicable_const() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_struct_() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_enum_() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_tuple_closure() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_closure_() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_fn_() {
         check_assist_not_applicable(
             "#,
         );
     }
-
     // ----------------------------
-
     #[test]
     fn inline_const_as_literal_const_expr() {
         TEST_PAIRS.iter().for_each(|(ty, val, _)| {
             );
         });
     }
-
     #[test]
     fn inline_const_as_literal_const_block_expr() {
         TEST_PAIRS.iter().for_each(|(ty, val, _)| {
             );
         });
     }
-
     #[test]
     fn inline_const_as_literal_const_block_eval_expr() {
         TEST_PAIRS.iter().for_each(|(ty, val, _)| {
             );
         });
     }
-
     #[test]
     fn inline_const_as_literal_const_block_eval_block_expr() {
         TEST_PAIRS.iter().for_each(|(ty, val, _)| {
             );
         });
     }
-
     #[test]
     fn inline_const_as_literal_const_fn_call_block_nested_builtin() {
         TEST_PAIRS.iter().for_each(|(ty, val, _)| {
             );
         });
     }
-
     #[test]
     fn inline_const_as_literal_const_fn_call_tuple() {
         TEST_PAIRS.iter().for_each(|(ty, val, _)| {
             );
         });
     }
-
     #[test]
     fn inline_const_as_literal_const_fn_call_builtin() {
         TEST_PAIRS.iter().for_each(|(ty, val, _)| {
             );
         });
     }
-
     #[test]
     fn inline_const_as_literal_scalar_operators() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_block_scalar_calculate_param_expr() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_block_tuple_scalar_calculate_block_expr() {
         check_assist(
             "#,
         );
     }
-
-    // FIXME: Add support for nested ref slices when using `render_eval`
     #[test]
     fn inline_const_as_literal_block_slice() {
         check_assist_not_applicable(
             "#,
         );
     }
-
-    // FIXME: Add support for unary tuple expressions when using `render_eval`.
-    // `const fn abc() -> (i32) { (1) }` will results in `1` instead of `(1)` because it's evaluated
-    // as a paren expr.
     #[test]
     fn inline_const_as_literal_block_tuple() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_block_slice_single() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_block_array() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_block_recursive() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_expr_as_str_lit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_eval_const_block_expr_to_str_lit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_eval_const_block_macro_expr_to_str_lit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_eval_const_match_expr_to_str_lit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_eval_const_if_expr_to_str_lit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_eval_const_macro_expr_to_str_lit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_eval_const_call_expr_to_str_lit() {
         check_assist(
             "#,
         );
     }
-
     #[test]
     fn inline_const_as_literal_expr_as_str_lit_not_applicable() {
         check_assist_not_applicable(